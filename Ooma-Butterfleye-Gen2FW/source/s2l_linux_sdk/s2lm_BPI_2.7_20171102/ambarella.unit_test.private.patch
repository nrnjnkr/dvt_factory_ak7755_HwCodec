diff --git a/AmbaConfig b/AmbaConfig
index d543e5d..f590391 100644
--- a/AmbaConfig
+++ b/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2008/02/18 - [Anthony Ginger] Create
 ##
-## Copyright (C) 2004-2008, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 menuconfig BUILD_AMBARELLA_PRIVATE_LINUX_UNIT_TESTS
@@ -85,6 +102,10 @@ config BUILD_AMBARELLA_UNIT_TESTS_MW
 config BUILD_AMBARELLA_UNIT_TESTS_PACKAGE
 	bool "Build Package unit tests"
 	default n
+	select CONFIG_AMBARELLA_DEWARP_LIBRARY
+	select CONFIG_AMBARELLA_EIS_LIBRARY
+	select CONFIG_AMBARELLA_SMARTRC_LIBRARY
+	select CONFIG_AMBARELLA_MDET_LIBRARY
 	help
 		Build Ambarella Private Linux Package unit tests.
 
diff --git a/amba_debug/amba_debug.c b/amba_debug/amba_debug.c
index f4eaa59..0a8d90e 100644
--- a/amba_debug/amba_debug.c
+++ b/amba_debug/amba_debug.c
@@ -6,12 +6,29 @@
  *    2008/05/05 - [Oliver Li] change printf(...,errno) to perror(); remove warning
  *    2009/05/15 - [Zhenwu Xue] add peripheral debug
  *
- * Copyright (C) 2004-2008, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
diff --git a/amba_debug/arm_chide.c b/amba_debug/arm_chide.c
index 2a62787..7ccc7be 100644
--- a/amba_debug/arm_chide.c
+++ b/amba_debug/arm_chide.c
@@ -1,16 +1,33 @@
-/*****************************************************************************
+/*
  * arm_chide.c
  *****************************************************************************
  * Author: Anthony Ginger <mapfly@gmail.com>
  *
- * Copyright (C) 2012 - 2013, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- *****************************************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include <dirent.h>
 #include <errno.h>
diff --git a/amba_debug/make.inc b/amba_debug/make.inc
index c7aa8f6..886fecd 100644
--- a/amba_debug/make.inc
+++ b/amba_debug/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/01 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2011-2015, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_UNIT_TESTS_AMBADEBUG), y)
diff --git a/audio_test/aacdec/make.inc b/audio_test/aacdec/make.inc
index 202da1d..5bc3309 100644
--- a/audio_test/aacdec/make.inc
+++ b/audio_test/aacdec/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2015/03/03 - [Zhaoyang Chen] Created file
 ##
-## Copyright (C) 2015-2019, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 LOCAL_PATH	:= $(call my-dir)
diff --git a/audio_test/aacenc/make.inc b/audio_test/aacenc/make.inc
index f46752a..45cc772 100644
--- a/audio_test/aacenc/make.inc
+++ b/audio_test/aacenc/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2015/03/03 - [Zhaoyang Chen] Created file
 ##
-## Copyright (C) 2015-2019, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 LOCAL_PATH	:= $(call my-dir)
diff --git a/audio_test/make.inc b/audio_test/make.inc
index bedf627..afa7ebe 100644
--- a/audio_test/make.inc
+++ b/audio_test/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2015/03/03 - [Zhaoyang Chen] Created file
 ##
-## Copyright (C) 2015-2019, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_UNIT_TESTS_AUDIO), y)
diff --git a/calibration/arch_s2l/awb_calibration.sh b/calibration/arch_s2l/awb_calibration.sh
index 04af108..536c376 100644
--- a/calibration/arch_s2l/awb_calibration.sh
+++ b/calibration/arch_s2l/awb_calibration.sh
@@ -1,4 +1,32 @@
 #!/bin/sh
+## History:
+##
+## 2016/12/30 - [JianTang] Created file
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
 
 source calib_utils.sh
 
diff --git a/calibration/arch_s2l/bad_pixel_calibration.sh b/calibration/arch_s2l/bad_pixel_calibration.sh
index 70c3ce4..be08ad3 100644
--- a/calibration/arch_s2l/bad_pixel_calibration.sh
+++ b/calibration/arch_s2l/bad_pixel_calibration.sh
@@ -1,14 +1,31 @@
 #!/bin/sh
-
 ## History:
-##		2013/04/26
 ##
-## Copyright (C) 2011-2015, Ambarella, Inc.
+## 2016/12/30 - [JianTang] Created file
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 CALIB_UTILS_SCRIPT=`which calib_utils.sh`
diff --git a/calibration/arch_s2l/bitmap_merger.c b/calibration/arch_s2l/bitmap_merger.c
index 9b98348..eaf18a1 100644
--- a/calibration/arch_s2l/bitmap_merger.c
+++ b/calibration/arch_s2l/bitmap_merger.c
@@ -1,3 +1,35 @@
+/*
+ * bitmap_merger.c
+ *
+ * Histroy:
+ *   Dec 5, 2013 - [Shupeng Ren] created file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include <unistd.h>
 #include <fcntl.h>
 #include <stdio.h>
diff --git a/calibration/arch_s2l/cali_awb.c b/calibration/arch_s2l/cali_awb.c
index 5f17fee..fd1a497 100644
--- a/calibration/arch_s2l/cali_awb.c
+++ b/calibration/arch_s2l/cali_awb.c
@@ -1,3 +1,35 @@
+/*
+ * cali_awb.c
+ *
+ * Histroy:
+ *   Dec 5, 2013 - [Shupeng Ren] created file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include <unistd.h>
 #include <fcntl.h>
 #include <stdio.h>
diff --git a/calibration/arch_s2l/cali_bad_pixel.c b/calibration/arch_s2l/cali_bad_pixel.c
index da82b66..7a62a2a 100644
--- a/calibration/arch_s2l/cali_bad_pixel.c
+++ b/calibration/arch_s2l/cali_bad_pixel.c
@@ -1,3 +1,35 @@
+/*
+ * cali_bad_pixel.c
+ *
+ * Histroy:
+ *   Dec 5, 2013 - [Shupeng Ren] created file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include <unistd.h>
 #include <fcntl.h>
 #include <stdio.h>
diff --git a/calibration/arch_s2l/cali_fisheye_center.c b/calibration/arch_s2l/cali_fisheye_center.c
index c7ff2a4..39e9f8c 100644
--- a/calibration/arch_s2l/cali_fisheye_center.c
+++ b/calibration/arch_s2l/cali_fisheye_center.c
@@ -1,17 +1,34 @@
-/*******************************************************************************
+/*
  * cali_fisheye_center.c
  *
  * Histroy:
  *   Dec 5, 2013 - [Shupeng Ren] created file
  *
- * Copyright (C) 2008-2013, Ambarella ShangHai Co,Ltd
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- ******************************************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include <stdio.h>
 #include <stdlib.h>
diff --git a/calibration/arch_s2l/cali_lens_focus.c b/calibration/arch_s2l/cali_lens_focus.c
index e001d49..9eaffb1 100644
--- a/calibration/arch_s2l/cali_lens_focus.c
+++ b/calibration/arch_s2l/cali_lens_focus.c
@@ -1,17 +1,34 @@
-/***********************************************************
+/*
  * cali_lens_focus.c
  *
  * History:
  *	2013/08/13 - [Jingyang qiu] created file
  *
- * Copyright (C) 2008-2012, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- ***********************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 
 #include <sys/signal.h>
diff --git a/calibration/arch_s2l/cali_lens_shading.c b/calibration/arch_s2l/cali_lens_shading.c
index 13c3488..eb1b507 100644
--- a/calibration/arch_s2l/cali_lens_shading.c
+++ b/calibration/arch_s2l/cali_lens_shading.c
@@ -1,3 +1,35 @@
+/*
+ * cali_lens_shading.c
+ *
+ * Histroy:
+ *   Dec 5, 2013 - [Shupeng Ren] created file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include <unistd.h>
 #include <fcntl.h>
 #include <stdio.h>
@@ -48,8 +80,9 @@ static uint16_t ae_target = 1024;
 mw_ae_param ae_param = {
 	.anti_flicker_mode = MW_ANTI_FLICKER_50HZ,
 	.shutter_time_min  = SHUTTER_1BY8000_SEC,
-	.shutter_time_max  = SHUTTER_1BY30_SEC,
+	.shutter_time_max  = SHUTTER_1BY60_SEC,
 	.sensor_gain_max   = ISO_6400,
+	.tone_curve_duration = MAX_TONE_CURVE_DURATION,
 };
 
 #define NO_ARG  0
diff --git a/calibration/arch_s2l/calib_utils.sh b/calibration/arch_s2l/calib_utils.sh
index 1b211d1..5f3275f 100644
--- a/calibration/arch_s2l/calib_utils.sh
+++ b/calibration/arch_s2l/calib_utils.sh
@@ -1,10 +1,32 @@
 #!/bin/sh
-
 ## History:
-##		2013/04/26
-##		Author: Shawn Hu
 ##
-## Copyright (C) 2011-2015, Ambarella, Inc.
+## 2016/12/30 - [JianTang] Created file
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
 
 CALIBRATION_FILES_PATH=/ambarella/calibration
 
diff --git a/calibration/arch_s2l/dlist.c b/calibration/arch_s2l/dlist.c
index f9fd9bf..2e99662 100644
--- a/calibration/arch_s2l/dlist.c
+++ b/calibration/arch_s2l/dlist.c
@@ -1,17 +1,34 @@
-/*******************************************************************************
+/*
  * dlist.c
  *
  * Histroy:
  *   Dec 5, 2013 - [Shupeng Ren] created file
  *
- * Copyright (C) 2008-2013, Ambarella ShangHai Co,Ltd
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- ******************************************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include <stdio.h>
 #include <stdlib.h>
diff --git a/calibration/arch_s2l/dlist.h b/calibration/arch_s2l/dlist.h
index adcbc4d..3397471 100644
--- a/calibration/arch_s2l/dlist.h
+++ b/calibration/arch_s2l/dlist.h
@@ -1,17 +1,34 @@
-/*******************************************************************************
+/*
  * dlist.h
  *
  * Histroy:
  *   Dec 5, 2013 - [Shupeng Ren] created file
  *
- * Copyright (C) 2008-2013, Ambarella ShangHai Co,Ltd
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- ******************************************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #ifndef _DLIST_H_
 #define _DLIST_H_
diff --git a/calibration/arch_s2l/fish_center_calibration.sh b/calibration/arch_s2l/fish_center_calibration.sh
index 44b9e81..89ac7f1 100644
--- a/calibration/arch_s2l/fish_center_calibration.sh
+++ b/calibration/arch_s2l/fish_center_calibration.sh
@@ -1,15 +1,32 @@
 #!/bin/sh
-
 ## History:
-##    2013/08/09 [Qian Shen] created file
-##    2013/12/05 [Shupeng Ren] modified file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## 2016/12/30 - [JianTang] Created file
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
 ##
 
 source calib_utils.sh
diff --git a/calibration/arch_s2l/lens_shading_calibration.sh b/calibration/arch_s2l/lens_shading_calibration.sh
index b32d4fe..ce4b43c 100644
--- a/calibration/arch_s2l/lens_shading_calibration.sh
+++ b/calibration/arch_s2l/lens_shading_calibration.sh
@@ -1,14 +1,32 @@
 #!/bin/sh
-
 ## History:
-##		2013/04/26
 ##
-## Copyright (C) 2011-2015, Ambarella, Inc.
+## 2016/12/30 - [JianTang] Created file
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
 ##
 
 
diff --git a/calibration/arch_s2l/make.inc b/calibration/arch_s2l/make.inc
index e384880..d96a215 100644
--- a/calibration/arch_s2l/make.inc
+++ b/calibration/arch_s2l/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/06/05 - [HuaiShun Hu] Created file
 ##
-## Copyright (C) 2011-2015, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 LOCAL_PATH	:= $(call my-dir)
diff --git a/calibration/make.inc b/calibration/make.inc
index 2e81d2e..0615916 100644
--- a/calibration/make.inc
+++ b/calibration/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2013/04/26 - [Qiu Jingyang] Created file
 ##
-## Copyright (C) 2011-2015, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_UNIT_TESTS_CALIBRATION), y)
diff --git a/hwtimer_test/arch_s2l/make.inc b/hwtimer_test/arch_s2l/make.inc
index 4329ea2..48492ea 100644
--- a/hwtimer_test/arch_s2l/make.inc
+++ b/hwtimer_test/arch_s2l/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/07/10 - [Zhaoyang Chen] Created file
 ##
-## Copyright (C) 2011-2015, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 LOCAL_PATH	:= $(call my-dir)
diff --git a/hwtimer_test/arch_s2l/test_hwtimer.c b/hwtimer_test/arch_s2l/test_hwtimer.c
index 2332fcd..a21cd99 100644
--- a/hwtimer_test/arch_s2l/test_hwtimer.c
+++ b/hwtimer_test/arch_s2l/test_hwtimer.c
@@ -5,12 +5,29 @@
  * History:
  *	2014/7/10 - [Zhaoyang Chen] create this file.
  *
- * Copyright (C) 2013-2016, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
diff --git a/hwtimer_test/make.inc b/hwtimer_test/make.inc
index 0e6d9dd..4e3317f 100644
--- a/hwtimer_test/make.inc
+++ b/hwtimer_test/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/07/10 - [Zhaoyang Chen] Created file
 ##
-## Copyright (C) 2011-2015, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_UNIT_TESTS_HW_TIMER), y)
diff --git a/iav_test/auto_test/encode_test.c b/iav_test/auto_test/encode_test.c
index 834660e..d1a06fa 100644
--- a/iav_test/auto_test/encode_test.c
+++ b/iav_test/auto_test/encode_test.c
@@ -5,12 +5,29 @@
  * History:
  *	2014/07/25 - [Jingyang Qiu] create this file base on test_encode.c
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
  #include <stdlib.h>
diff --git a/iav_test/auto_test/make.inc b/iav_test/auto_test/make.inc
index 56df675..ad7f557 100644
--- a/iav_test/auto_test/make.inc
+++ b/iav_test/auto_test/make.inc
@@ -4,12 +4,30 @@
 ## History:
 ##    2014/06/05 - [Jian Tang] Created file
 ##
-## Copyright (C) 2013-2016, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
 
 
 ifeq ($(BUILD_AMBARELLA_IAV_AUTO_TEST), y)
diff --git a/iav_test/auto_test/script_encmode.sh b/iav_test/auto_test/script_encmode.sh
index c6c7d43..14f8a5d 100644
--- a/iav_test/auto_test/script_encmode.sh
+++ b/iav_test/auto_test/script_encmode.sh
@@ -5,12 +5,30 @@
 ## History:
 ##    2014/08/05 - [Jian Tang] Created file
 ##
-## Copyright (C) 2014-2016, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
 
 TEST_ENCODE="/usr/local/bin/test_encode"
 
diff --git a/iav_test/auto_test/script_encode_test.sh b/iav_test/auto_test/script_encode_test.sh
index f20c626..5b55ab8 100644
--- a/iav_test/auto_test/script_encode_test.sh
+++ b/iav_test/auto_test/script_encode_test.sh
@@ -1,8 +1,36 @@
 #!/bin/sh
+## History:
+##
+## 2016/12/30 - [JianTang] Created file
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
 echo "run ./test_encode -i1080p -V480p --hdmi"
 test_encode -i1080p -V480p --hdmi
 test_encode -A -h1080p -B -h480p -C -hcif -D -hcif
 sleep 1
 # test_image -i 0 &
 sleep 1
-encode_test
\ No newline at end of file
+encode_test
diff --git a/iav_test/chrome_convert.S b/iav_test/chrome_convert.S
index ce1295b..647d4a5 100644
--- a/iav_test/chrome_convert.S
+++ b/iav_test/chrome_convert.S
@@ -4,12 +4,30 @@
  * History:
  *	2014/04/04 - [Zhikan Yang] created file
  *
- * Copyright (C) 2007-2012, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 .fpu neon
diff --git a/iav_test/codec_parser.c b/iav_test/codec_parser.c
index 7c06d54..35bc2fd 100644
--- a/iav_test/codec_parser.c
+++ b/iav_test/codec_parser.c
@@ -2,14 +2,31 @@
  * codec_parser.c
  *
  * History:
- *	2015/02/10 - [Zhi He] create file
+ *  2015/02/10 - [Zhi He] create file
  *
- * Copyright (C) 2015 -2020, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
@@ -29,41 +46,41 @@
 
 //simple parse slice_type for h264
 typedef struct {
-	const unsigned char *buffer, *buffer_end;
-	int index;
-	int size_in_bits;
+    const unsigned char *buffer, *buffer_end;
+    int index;
+    int size_in_bits;
 } GetbitsContext;
 
-#define READ_LE_32(x)	\
-	((((const unsigned char*)(x))[3] << 24) |	\
-	(((const unsigned char*)(x))[2] << 16) |	\
-	(((const unsigned char*)(x))[1] <<  8) |	 \
-	((const unsigned char*)(x))[0])
+#define READ_LE_32(x)   \
+    ((((const unsigned char*)(x))[3] << 24) |   \
+     (((const unsigned char*)(x))[2] << 16) |    \
+     (((const unsigned char*)(x))[1] <<  8) |     \
+     ((const unsigned char*)(x))[0])
 
-#define READ_BE_32(x)	\
-	((((const unsigned char*)(x))[0] << 24) |	\
-	(((const unsigned char*)(x))[1] << 16) |	\
-	(((const unsigned char*)(x))[2] <<  8) |	 \
-	((const unsigned char*)(x))[3])
+#define READ_BE_32(x)   \
+    ((((const unsigned char*)(x))[0] << 24) |   \
+     (((const unsigned char*)(x))[1] << 16) |    \
+     (((const unsigned char*)(x))[2] <<  8) |     \
+     ((const unsigned char*)(x))[3])
 
-#define BIT_OPEN_READER(name, gb)	\
-	unsigned int name##_index = (gb)->index;	\
-	int name##_cache	= 0
+#define BIT_OPEN_READER(name, gb)   \
+    unsigned int name##_index = (gb)->index;    \
+    int name##_cache    = 0
 
 #define BITS_CLOSE_READER(name, gb) (gb)->index = name##_index
 #define BITS_UPDATE_CACHE_BE(name, gb) \
-	name##_cache = READ_BE_32(((const unsigned char *)(gb)->buffer)+(name##_index>>3)) << (name##_index&0x07)
+    name##_cache = READ_BE_32(((const unsigned char *)(gb)->buffer)+(name##_index>>3)) << (name##_index&0x07)
 #define BITS_UPDATE_CACHE_LE(name, gb) \
-	name##_cache = READ_LE_32(((const unsigned char *)(gb)->buffer)+(name##_index>>3)) >> (name##_index&0x07)
+    name##_cache = READ_LE_32(((const unsigned char *)(gb)->buffer)+(name##_index>>3)) >> (name##_index&0x07)
 
 #define BITS_SKIP_CACHE(name, gb, num) name##_cache >>= (num)
 
 #define BITS_SKIP_COUNTER(name, gb, num) name##_index += (num)
 
-#define BITS_SKIP_BITS(name, gb, num) do {	\
-	BITS_SKIP_CACHE(name, gb, num);	\
-	BITS_SKIP_COUNTER(name, gb, num);	 \
-} while (0)
+#define BITS_SKIP_BITS(name, gb, num) do {  \
+        BITS_SKIP_CACHE(name, gb, num); \
+        BITS_SKIP_COUNTER(name, gb, num);    \
+    } while (0)
 
 #define BITS_LAST_SKIP_BITS(name, gb, num) BITS_SKIP_COUNTER(name, gb, num)
 #define BITS_LAST_SKIP_CACHE(name, gb, num)
@@ -74,122 +91,122 @@ typedef struct {
 #define BITS_GET_CACHE(name, gb) ((unsigned int)name##_cache)
 
 //log2
-const unsigned char simple_log2_table[256]={
-	0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
-	5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-	6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
-	6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
-	7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
-	7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
-	7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
-	7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
+const unsigned char simple_log2_table[256] = {
+    0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
+    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
+    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
+    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
 };
 
-const unsigned char simple_golomb_vlc_len[512]={
-	19,17,15,15,13,13,13,13,11,11,11,11,11,11,11,11,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
-	7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
-	5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-	5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
-	3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
-	3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
-	3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
-	3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
-	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
-	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
+const unsigned char simple_golomb_vlc_len[512] = {
+    19, 17, 15, 15, 13, 13, 13, 13, 11, 11, 11, 11, 11, 11, 11, 11, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
+    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
+    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
 };
 
-const unsigned char simple_ue_golomb_vlc_code[512]={
-	32,32,32,32,32,32,32,32,31,32,32,32,32,32,32,32,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,
-	7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9,10,10,10,10,11,11,11,11,12,12,12,12,13,13,13,13,14,14,14,14,
-	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
-	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
-	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+const unsigned char simple_ue_golomb_vlc_code[512] = {
+    32, 32, 32, 32, 32, 32, 32, 32, 31, 32, 32, 32, 32, 32, 32, 32, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
+    7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14,
+    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 };
 
-const char simple_se_golomb_vlc_code[512]={
-	17, 17, 17, 17, 17, 17, 17, 17, 16, 17, 17, 17, 17, 17, 17, 17,  8, -8,  9, -9, 10,-10, 11,-11, 12,-12, 13,-13, 14,-14, 15,-15,
-	4,  4,  4,  4, -4, -4, -4, -4,  5,  5,  5,  5, -5, -5, -5, -5,  6,  6,  6,  6, -6, -6, -6, -6,  7,  7,  7,  7, -7, -7, -7, -7,
-	2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
-	3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,
-	1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
-	1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+const char simple_se_golomb_vlc_code[512] = {
+    17, 17, 17, 17, 17, 17, 17, 17, 16, 17, 17, 17, 17, 17, 17, 17,  8, -8,  9, -9, 10, -10, 11, -11, 12, -12, 13, -13, 14, -14, 15, -15,
+    4,  4,  4,  4, -4, -4, -4, -4,  5,  5,  5,  5, -5, -5, -5, -5,  6,  6,  6,  6, -6, -6, -6, -6,  7,  7,  7,  7, -7, -7, -7, -7,
+    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
+    3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,
+    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
+    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 };
 
 static const unsigned char default_scaling4[2][16] = {
-	{
-		6,13,20,28,
-		13,20,28,32,
-		20,28,32,37,
-		28,32,37,42
-	},
-
-	{
-		10,14,20,24,
-		14,20,24,27,
-		20,24,27,30,
-		24,27,30,34
-	}
+    {
+        6, 13, 20, 28,
+        13, 20, 28, 32,
+        20, 28, 32, 37,
+        28, 32, 37, 42
+    },
+
+    {
+        10, 14, 20, 24,
+        14, 20, 24, 27,
+        20, 24, 27, 30,
+        24, 27, 30, 34
+    }
 };
 
 static const unsigned char default_scaling8[2][64] = {
-	{
-		6,10,13,16,18,23,25,27,
-		10,11,16,18,23,25,27,29,
-		13,16,18,23,25,27,29,31,
-		16,18,23,25,27,29,31,33,
-		18,23,25,27,29,31,33,36,
-		23,25,27,29,31,33,36,38,
-		25,27,29,31,33,36,38,40,
-		27,29,31,33,36,38,40,42
-	},
-	{
-	    9,13,15,17,19,21,22,24,
-		13,13,17,19,21,22,24,25,
-		15,17,19,21,22,24,25,27,
-		17,19,21,22,24,25,27,28,
-		19,21,22,24,25,27,28,30,
-		21,22,24,25,27,28,30,32,
-		22,24,25,27,28,30,32,33,
-		24,25,27,28,30,32,33,35
-	}
+    {
+        6, 10, 13, 16, 18, 23, 25, 27,
+        10, 11, 16, 18, 23, 25, 27, 29,
+        13, 16, 18, 23, 25, 27, 29, 31,
+        16, 18, 23, 25, 27, 29, 31, 33,
+        18, 23, 25, 27, 29, 31, 33, 36,
+        23, 25, 27, 29, 31, 33, 36, 38,
+        25, 27, 29, 31, 33, 36, 38, 40,
+        27, 29, 31, 33, 36, 38, 40, 42
+    },
+    {
+        9, 13, 15, 17, 19, 21, 22, 24,
+        13, 13, 17, 19, 21, 22, 24, 25,
+        15, 17, 19, 21, 22, 24, 25, 27,
+        17, 19, 21, 22, 24, 25, 27, 28,
+        19, 21, 22, 24, 25, 27, 28, 30,
+        21, 22, 24, 25, 27, 28, 30, 32,
+        22, 24, 25, 27, 28, 30, 32, 33,
+        24, 25, 27, 28, 30, 32, 33, 35
+    }
 };
 
-static const unsigned char simple_zigzag_scan[16]={
-	0+0*4, 1+0*4, 0+1*4, 0+2*4,
-	1+1*4, 2+0*4, 3+0*4, 2+1*4,
-	1+2*4, 0+3*4, 1+3*4, 2+2*4,
-	3+1*4, 3+2*4, 2+3*4, 3+3*4,
+static const unsigned char simple_zigzag_scan[16] = {
+    0 + 0 * 4, 1 + 0 * 4, 0 + 1 * 4, 0 + 2 * 4,
+    1 + 1 * 4, 2 + 0 * 4, 3 + 0 * 4, 2 + 1 * 4,
+    1 + 2 * 4, 0 + 3 * 4, 1 + 3 * 4, 2 + 2 * 4,
+    3 + 1 * 4, 3 + 2 * 4, 2 + 3 * 4, 3 + 3 * 4,
 };
 
 const unsigned char simple_zigzag_direct[64] = {
-	0,   1,  8, 16,  9,  2,  3, 10,
+    0,   1,  8, 16,  9,  2,  3, 10,
     17, 24, 32, 25, 18, 11,  4,  5,
     12, 19, 26, 33, 40, 48, 41, 34,
     27, 20, 13,  6,  7, 14, 21, 28,
@@ -201,53 +218,55 @@ const unsigned char simple_zigzag_direct[64] = {
 
 static int simple_log2_c(unsigned int v)
 {
-	int n = 0;
-	if (v & 0xffff0000) {
-		v >>= 16;
-		n += 16;
-	}
-	if (v & 0xff00) {
-		v >>= 8;
-		n += 8;
-	}
-	n += simple_log2_table[v];
-
-	return n;
+    int n = 0;
+    if (v & 0xffff0000) {
+        v >>= 16;
+        n += 16;
+    }
+    if (v & 0xff00) {
+        v >>= 8;
+        n += 8;
+    }
+    n += simple_log2_table[v];
+
+    return n;
 }
 
-static inline int _get_ue_golomb(GetbitsContext *gb){
-	unsigned int buf;
-	int log;
-
-	BIT_OPEN_READER(re, gb);
-	BITS_UPDATE_CACHE_BE(re, gb);
-	buf=BITS_GET_CACHE(re, gb);
-	if (buf >= (1<<27)) {
-		buf >>= 32 - 9;
-		BITS_LAST_SKIP_BITS(re, gb, simple_golomb_vlc_len[buf]);
-		BITS_CLOSE_READER(re, gb);
-		return simple_ue_golomb_vlc_code[buf];
-	} else {
-		log= 2*simple_log2_c(buf) - 31;
-		buf>>= log;
-		buf--;
-		BITS_LAST_SKIP_BITS(re, gb, 32 - log);
-		BITS_CLOSE_READER(re, gb);
-		return buf;
-	}
+static inline int _get_ue_golomb(GetbitsContext *gb)
+{
+    unsigned int buf;
+    int log;
+
+    BIT_OPEN_READER(re, gb);
+    BITS_UPDATE_CACHE_BE(re, gb);
+    buf = BITS_GET_CACHE(re, gb);
+    if (buf >= (1 << 27)) {
+        buf >>= 32 - 9;
+        BITS_LAST_SKIP_BITS(re, gb, simple_golomb_vlc_len[buf]);
+        BITS_CLOSE_READER(re, gb);
+        return simple_ue_golomb_vlc_code[buf];
+    } else {
+        log = 2 * simple_log2_c(buf) - 31;
+        buf >>= log;
+        buf--;
+        BITS_LAST_SKIP_BITS(re, gb, 32 - log);
+        BITS_CLOSE_READER(re, gb);
+        return buf;
+    }
 }
 
-static inline int _get_ue_golomb_31(GetbitsContext *gb){
-	unsigned int buf;
+static inline int _get_ue_golomb_31(GetbitsContext *gb)
+{
+    unsigned int buf;
 
-	BIT_OPEN_READER(re, gb);
-	BITS_UPDATE_CACHE_BE(re, gb);
-	buf=BITS_GET_CACHE(re, gb);
-	buf >>= 32 - 9;
-	BITS_LAST_SKIP_BITS(re, gb, simple_golomb_vlc_len[buf]);
-	BITS_CLOSE_READER(re, gb);
+    BIT_OPEN_READER(re, gb);
+    BITS_UPDATE_CACHE_BE(re, gb);
+    buf = BITS_GET_CACHE(re, gb);
+    buf >>= 32 - 9;
+    BITS_LAST_SKIP_BITS(re, gb, simple_golomb_vlc_len[buf]);
+    BITS_CLOSE_READER(re, gb);
 
-	return simple_ue_golomb_vlc_code[buf];
+    return simple_ue_golomb_vlc_code[buf];
 }
 
 static inline int _get_se_golomb(GetbitsContext *gb)
@@ -259,27 +278,27 @@ static inline int _get_se_golomb(GetbitsContext *gb)
     BITS_UPDATE_CACHE_BE(re, gb);
     buf = BITS_GET_CACHE(re, gb);
 
-    if (buf >= (1<<27)) {
+    if (buf >= (1 << 27)) {
         buf >>= 32 - 9;
         BITS_LAST_SKIP_BITS(re, gb, simple_golomb_vlc_len[buf]);
         BITS_CLOSE_READER(re, gb);
 
         return simple_se_golomb_vlc_code[buf];
     } else {
-        log= simple_log2_c(buf);
+        log = simple_log2_c(buf);
         BITS_LAST_SKIP_BITS(re, gb, 31 - log);
         BITS_UPDATE_CACHE_BE(re, gb);
         buf = BITS_GET_CACHE(re, gb);
-        buf>>= log;
+        buf >>= log;
 
         BITS_LAST_SKIP_BITS(re, gb, 32 - log);
         BITS_CLOSE_READER(re, gb);
 
-        if (buf&1) {
-			buf= -(buf>>1);
-		} else {
-			buf=  (buf>>1);
-		}
+        if (buf & 1) {
+            buf = -(buf >> 1);
+        } else {
+            buf = (buf >> 1);
+        }
         return buf;
     }
 }
@@ -309,33 +328,32 @@ static inline unsigned int _get_bits1(GetbitsContext *s)
     return result;
 }
 
-unsigned char get_h264_slice_type_le(unsigned char* pdata, unsigned char* first_mb_in_slice)
+unsigned char get_h264_slice_type_le(unsigned char *pdata, unsigned char *first_mb_in_slice)
 {
-	unsigned char slice_type = 0;
-	GetbitsContext gb;
+    unsigned char slice_type = 0;
+    GetbitsContext gb;
 
-	gb.buffer = pdata;
-	gb.buffer_end = pdata + 8;//hard code here
-	gb.index = 0;
-	gb.size_in_bits = 8*8;
+    gb.buffer = pdata;
+    gb.buffer_end = pdata + 8;//hard code here
+    gb.index = 0;
+    gb.size_in_bits = 8 * 8;
 
-	*first_mb_in_slice = _get_ue_golomb(&gb);
-	slice_type = _get_ue_golomb_31(&gb);
+    *first_mb_in_slice = _get_ue_golomb(&gb);
+    slice_type = _get_ue_golomb_31(&gb);
 
-	if (slice_type > 9) {
-		printf("BAD slice_type %d, first_mb_in_slice %d\n", slice_type, *first_mb_in_slice);
-		return 0;
-	}
+    if (slice_type > 9) {
+        printf("BAD slice_type %d, first_mb_in_slice %d\n", slice_type, *first_mb_in_slice);
+        return 0;
+    }
 
-	if (slice_type > 4) {
-		slice_type -= 5;
-	}
+    if (slice_type > 4) {
+        slice_type -= 5;
+    }
 
-	return slice_type;// P B I SP SI
+    return slice_type;// P B I SP SI
 }
 
-typedef struct
-{
+typedef struct {
     unsigned int sps_id;
     unsigned int profile_idc;
     unsigned int level_idc;
@@ -361,18 +379,19 @@ typedef struct
 } s_h264_sps;
 
 static void _decode_scaling_list(GetbitsContext *gb, unsigned char *factors, int size,
-                                const unsigned char *jvt_list, const unsigned char *fallback_list){
+                                 const unsigned char *jvt_list, const unsigned char *fallback_list)
+{
     int i, last = 8, next = 8;
     const unsigned char *scan = (size == 16) ? simple_zigzag_scan : simple_zigzag_direct;
-    if(!_get_bits1(gb)) {
-        memcpy(factors, fallback_list, size*sizeof(unsigned char));
+    if (!_get_bits1(gb)) {
+        memcpy(factors, fallback_list, size * sizeof(unsigned char));
     } else {
-        for (i=0; i<size; i++){
+        for (i = 0; i < size; i++) {
             if (next) {
                 next = (last + _get_se_golomb(gb)) & 0xff;
             }
             if (!i && !next) {
-                memcpy(factors, jvt_list, size*sizeof(unsigned char));
+                memcpy(factors, jvt_list, size * sizeof(unsigned char));
                 break;
             }
             last = factors[scan[i]] = next ? next : last;
@@ -380,7 +399,8 @@ static void _decode_scaling_list(GetbitsContext *gb, unsigned char *factors, int
     }
 }
 
-static void _decode_scaling_matrices(GetbitsContext *gb, s_h264_sps *sps, unsigned char (*scaling_matrix4)[16], unsigned char (*scaling_matrix8)[64]){
+static void _decode_scaling_matrices(GetbitsContext *gb, s_h264_sps *sps, unsigned char(*scaling_matrix4)[16], unsigned char(*scaling_matrix8)[64])
+{
     const unsigned char *fallback[4] = {
         default_scaling4[0],
         default_scaling4[1],
@@ -389,25 +409,25 @@ static void _decode_scaling_matrices(GetbitsContext *gb, s_h264_sps *sps, unsign
     };
 
     if (_get_bits1(gb)) {
-        _decode_scaling_list(gb, scaling_matrix4[0],16,default_scaling4[0],fallback[0]); // Intra, Y
-        _decode_scaling_list(gb, scaling_matrix4[1],16,default_scaling4[0],scaling_matrix4[0]); // Intra, Cr
-        _decode_scaling_list(gb, scaling_matrix4[2],16,default_scaling4[0],scaling_matrix4[1]); // Intra, Cb
-        _decode_scaling_list(gb, scaling_matrix4[3],16,default_scaling4[1],fallback[1]); // Inter, Y
-        _decode_scaling_list(gb, scaling_matrix4[4],16,default_scaling4[1],scaling_matrix4[3]); // Inter, Cr
-        _decode_scaling_list(gb, scaling_matrix4[5],16,default_scaling4[1],scaling_matrix4[4]); // Inter, Cb
-
-          _decode_scaling_list(gb, scaling_matrix8[0],64,default_scaling8[0],fallback[2]);  // Intra, Y
-          _decode_scaling_list(gb, scaling_matrix8[3],64,default_scaling8[1],fallback[3]);  // Inter, Y
-          if (sps->chroma_idc == 3) {
-              _decode_scaling_list(gb, scaling_matrix8[1],64,default_scaling8[0],scaling_matrix8[0]);  // Intra, Cr
-              _decode_scaling_list(gb, scaling_matrix8[4],64,default_scaling8[1],scaling_matrix8[3]);  // Inter, Cr
-              _decode_scaling_list(gb, scaling_matrix8[2],64,default_scaling8[0],scaling_matrix8[1]);  // Intra, Cb
-              _decode_scaling_list(gb, scaling_matrix8[5],64,default_scaling8[1],scaling_matrix8[4]);  // Inter, Cb
-          }
+        _decode_scaling_list(gb, scaling_matrix4[0], 16, default_scaling4[0], fallback[0]); // Intra, Y
+        _decode_scaling_list(gb, scaling_matrix4[1], 16, default_scaling4[0], scaling_matrix4[0]); // Intra, Cr
+        _decode_scaling_list(gb, scaling_matrix4[2], 16, default_scaling4[0], scaling_matrix4[1]); // Intra, Cb
+        _decode_scaling_list(gb, scaling_matrix4[3], 16, default_scaling4[1], fallback[1]); // Inter, Y
+        _decode_scaling_list(gb, scaling_matrix4[4], 16, default_scaling4[1], scaling_matrix4[3]); // Inter, Cr
+        _decode_scaling_list(gb, scaling_matrix4[5], 16, default_scaling4[1], scaling_matrix4[4]); // Inter, Cb
+
+        _decode_scaling_list(gb, scaling_matrix8[0], 64, default_scaling8[0], fallback[2]); // Intra, Y
+        _decode_scaling_list(gb, scaling_matrix8[3], 64, default_scaling8[1], fallback[3]); // Inter, Y
+        if (sps->chroma_idc == 3) {
+            _decode_scaling_list(gb, scaling_matrix8[1], 64, default_scaling8[0], scaling_matrix8[0]); // Intra, Cr
+            _decode_scaling_list(gb, scaling_matrix8[4], 64, default_scaling8[1], scaling_matrix8[3]); // Inter, Cr
+            _decode_scaling_list(gb, scaling_matrix8[2], 64, default_scaling8[0], scaling_matrix8[1]); // Intra, Cb
+            _decode_scaling_list(gb, scaling_matrix8[5], 64, default_scaling8[1], scaling_matrix8[4]); // Inter, Cb
+        }
     }
 }
 
-int get_h264_width_height_from_sps(unsigned char* p_data, unsigned int data_size, unsigned int *width, unsigned int * height)
+int get_h264_width_height_from_sps(unsigned char *p_data, unsigned int data_size, unsigned int *width, unsigned int *height)
 {
     s_h264_sps sps;
     GetbitsContext gb;
@@ -423,7 +443,7 @@ int get_h264_width_height_from_sps(unsigned char* p_data, unsigned int data_size
     sps.profile_idc = _get_bits(&gb, 8);
     _get_bits(&gb, 8);
     sps.level_idc = _get_bits(&gb, 8);
-    sps.sps_id= _get_ue_golomb_31(&gb);
+    sps.sps_id = _get_ue_golomb_31(&gb);
 
     if (sps.sps_id >= DMAX_SPS_COUNT) {
         printf("sps_id (%d) out of range\n", sps.sps_id);
@@ -431,10 +451,10 @@ int get_h264_width_height_from_sps(unsigned char* p_data, unsigned int data_size
     }
 
     if (sps.profile_idc == 100 || sps.profile_idc == 110 ||
-        sps.profile_idc == 122 || sps.profile_idc == 244 ||
-        sps.profile_idc ==  44 || sps.profile_idc ==  83 ||
-        sps.profile_idc ==  86 || sps.profile_idc == 118 ||
-        sps.profile_idc == 128 || sps.profile_idc == 144) {
+            sps.profile_idc == 122 || sps.profile_idc == 244 ||
+            sps.profile_idc ==  44 || sps.profile_idc ==  83 ||
+            sps.profile_idc ==  86 || sps.profile_idc == 118 ||
+            sps.profile_idc == 128 || sps.profile_idc == 144) {
         sps.chroma_idc = _get_ue_golomb_31(&gb);
 
         if (sps.chroma_idc > 3) {
@@ -455,7 +475,7 @@ int get_h264_width_height_from_sps(unsigned char* p_data, unsigned int data_size
         }
         _get_bits1(&gb);
         _decode_scaling_matrices(&gb, &sps, sps.scaling_matrix4, sps.scaling_matrix8);
-    }else{
+    } else {
         sps.chroma_idc = 1;
         sps.bit_depth_luma   = 8;
         sps.bit_depth_chroma = 8;
@@ -463,12 +483,12 @@ int get_h264_width_height_from_sps(unsigned char* p_data, unsigned int data_size
 
     sps.log2_max_frame_num_minus4 = _get_ue_golomb(&gb);
     if (sps.log2_max_frame_num_minus4 < (DMIN_LOG2_MAX_FRAME_NUM - 4) ||
-        sps.log2_max_frame_num_minus4 > (DMAX_LOG2_MAX_FRAME_NUM - 4)) {
+            sps.log2_max_frame_num_minus4 > (DMAX_LOG2_MAX_FRAME_NUM - 4)) {
         printf("log2_max_frame_num_minus4 out of range (0-12): %d\n", sps.log2_max_frame_num_minus4);
         return (-5);
     }
     sps.log2_max_frame_num = sps.log2_max_frame_num_minus4 + 4;
-    sps.poc_type= _get_ue_golomb_31(&gb);
+    sps.poc_type = _get_ue_golomb_31(&gb);
 
     if (sps.poc_type == 0) {
         unsigned int t = _get_ue_golomb(&gb);
@@ -478,18 +498,18 @@ int get_h264_width_height_from_sps(unsigned char* p_data, unsigned int data_size
         }
         sps.log2_max_poc_lsb = t + 4;
     } else if (sps.poc_type == 1) {
-		sps.delta_pic_order_always_zero_flag = _get_bits1(&gb);
-		sps.offset_for_non_ref_pic = _get_se_golomb(&gb);
-		sps.offset_for_top_to_bottom_field = _get_se_golomb(&gb);
-		sps.poc_cycle_length                = _get_ue_golomb(&gb);
+        sps.delta_pic_order_always_zero_flag = _get_bits1(&gb);
+        sps.offset_for_non_ref_pic = _get_se_golomb(&gb);
+        sps.offset_for_top_to_bottom_field = _get_se_golomb(&gb);
+        sps.poc_cycle_length                = _get_ue_golomb(&gb);
 
         if (sps.poc_cycle_length >= DARRAY_ELEMS(sps.offset_for_ref_frame)) {
             printf("poc_cycle_length overflow %u\n", sps.poc_cycle_length);
             return (-7);
         }
 
-        for(i = 0; i < sps.poc_cycle_length; i++) {
-            sps.offset_for_ref_frame[i]= _get_se_golomb(&gb);
+        for (i = 0; i < sps.poc_cycle_length; i++) {
+            sps.offset_for_ref_frame[i] = _get_se_golomb(&gb);
         }
     } else if (sps.poc_type != 2) {
         printf("illegal POC type %d\n", sps.poc_type);
diff --git a/iav_test/codec_parser.h b/iav_test/codec_parser.h
index 9ab33b3..60da241 100644
--- a/iav_test/codec_parser.h
+++ b/iav_test/codec_parser.h
@@ -2,17 +2,34 @@
  * codec_parser.h
  *
  * History:
- *	2015/02/10 - [Zhi He] create file
+ *  2015/02/10 - [Zhi He] create file
  *
- * Copyright (C) 2015 -2020, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
-unsigned char get_h264_slice_type_le(unsigned char* pdata, unsigned char* first_mb_in_slice);
-int get_h264_width_height_from_sps(unsigned char* p_data, unsigned int data_size, unsigned int *width, unsigned int * height);
+unsigned char get_h264_slice_type_le(unsigned char *pdata, unsigned char *first_mb_in_slice);
+int get_h264_width_height_from_sps(unsigned char *p_data, unsigned int data_size, unsigned int *width, unsigned int *height);
 
diff --git a/iav_test/fbtest.c b/iav_test/fbtest.c
index 1331099..188f2e1 100644
--- a/iav_test/fbtest.c
+++ b/iav_test/fbtest.c
@@ -1,3 +1,34 @@
+/*
+ * fbtest.c
+ *
+ * History:
+ *   Dec 30, 2010 - [Oliver Li] created file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 //#include <string.h>
 //#include <stdio.h>
@@ -132,7 +163,7 @@ int do_show_bitmap(const char *filename)
 
 			pline = line_buffer;
 			for (j = 0; j < pic_width; j++) {
-				unsigned b = *pline++;	
+				unsigned b = *pline++;
 				unsigned g = *pline++;
 				unsigned r = *pline++;
 				b >>= 3; g >>= 2; r >>= 3;
@@ -156,7 +187,7 @@ int do_show_bitmap(const char *filename)
 
 			pline = line_buffer;
 			for (j = 0; j < pic_width; j++) {
-				unsigned b = *pline++;	
+				unsigned b = *pline++;
 				unsigned g = *pline++;
 				unsigned r = *pline++;
 				*(u32*)ptr = (255 << 24) | (r << 16) | (g << 8) | b;
diff --git a/iav_test/guard_sd_space.c b/iav_test/guard_sd_space.c
index 41b0056..928431a 100644
--- a/iav_test/guard_sd_space.c
+++ b/iav_test/guard_sd_space.c
@@ -1,17 +1,34 @@
-/*******************************************************************************
+/*
  * guard_sd_space.c
  *
  * History:
  *   Jun 18, 2015 - [longli] created file
  *
- * Copyright (C) 2008-2015, Ambarella Co, Ltd.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- ******************************************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include <stdio.h>
 #include <unistd.h>
diff --git a/iav_test/guard_vsync_loss.c b/iav_test/guard_vsync_loss.c
index 8880d85..76da01c 100644
--- a/iav_test/guard_vsync_loss.c
+++ b/iav_test/guard_vsync_loss.c
@@ -5,15 +5,31 @@
  * History:
  *	2014/07/28 - [Zhaoyang Chen] create this file
  *
- * Copyright (C) 2012-2015, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
-
 #include <unistd.h>
 #include <fcntl.h>
 #include <stdio.h>
@@ -33,57 +49,15 @@
 #include <basetypes.h>
 
 #include "iav_ioctl.h"
+#include "iav_netlink.h"
 
 // vin
 #include "../vin_test/vin_init.c"
 
 
-#define NL_PORT_VSYNC			21
-#define MAX_NL_MSG_LEN 			1024
-
 #define MAX_ENCODE_STREAM_NUM	(IAV_STREAM_MAX_NUM_IMPL)
 #define ALL_ENCODE_STREAMS		((1<<MAX_ENCODE_STREAM_NUM) - 1)
 
-
-enum NL_REQUEST_VSYNC {
-	NL_REQUEST_VSYNC_RESTORE = 0,
-	NL_REQUEST_VSYNC_FIRST = NL_REQUEST_VSYNC_RESTORE,
-	NL_REQUEST_VSYNC_LAST = NL_REQUEST_VSYNC_RESTORE + 1,
-	NL_REQUEST_VSYNC_NUM = NL_REQUEST_VSYNC_LAST - NL_REQUEST_VSYNC_FIRST,
-};
-
-enum NL_SESSION_CMD {
-	NL_SESSION_CMD_CONNECT = 0,
-	NL_SESSION_CMD_DISCONNECT,
-	NL_SESSION_CMD_FIRST = NL_SESSION_CMD_CONNECT,
-	NL_SESSION_CMD_LAST = NL_SESSION_CMD_DISCONNECT + 1,
-	NL_SESSION_CMD_NUM = NL_SESSION_CMD_LAST - NL_SESSION_CMD_FIRST,
-};
-
-enum NL_CMD_STATUS {
-	NL_CMD_STATUS_SUCCESS = 0,
-	NL_CMD_STATUS_FAIL,
-};
-
-enum NL_MSG_TYPE {
-	NL_MSG_TYPE_SESSION = 0,
-	NL_MSG_TYPE_REQUEST,
-};
-
-enum NL_MSG_DIR {
-	NL_MSG_DIR_CMD = 0,
-	NL_MSG_DIR_STATUS,
-};
-
-struct nl_msg_data {
-	u32 pid;
-	u32 port;
-	u32 type;
-	u32 dir;
-	u32 cmd;
-	u32 status;
-};
-
 struct nl_vsync_config {
 	s32 fd_nl;
 	s32 nl_connected;
@@ -293,6 +267,7 @@ static int restart_encoded_streams(void)
 static int reset_vin(void)
 {
 	struct vindev_mode video_info;
+	struct vindev_fps vsrc_fps;
 	// select channel: for multi channel VIN (initialize)
 	if (channel >= 0) {
 		if (select_channel() < 0)
@@ -301,20 +276,34 @@ static int reset_vin(void)
 
 	memset(&video_info, 0, sizeof(video_info));
 	video_info.vsrc_id = 0;
-	if(ioctl(fd_iav, IAV_IOC_VIN_GET_MODE, &video_info)){
+	if(ioctl(fd_iav, IAV_IOC_VIN_GET_MODE, &video_info) < 0) {
 		return -1;
 	} else {
 		printf("Start to restore vin_mode 0x%x and hdr_mode %d.\n",
 			video_info.video_mode, video_info.hdr_mode);
 	}
 
-	if(ioctl(fd_iav, IAV_IOC_VIN_SET_MODE, &video_info)){
+	vsrc_fps.vsrc_id = 0;
+	if(ioctl(fd_iav, IAV_IOC_VIN_GET_FPS, &vsrc_fps) < 0) {
+		return -1;
+	} else {
+		printf("Start to restore vin frame rate %d.\n", vsrc_fps.fps);
+	}
+
+	if(ioctl(fd_iav, IAV_IOC_VIN_SET_MODE, &video_info) < 0) {
 		return -1;
 	} else {
 		printf("Succeed to restore vin_mode 0x%x and hdr_mode %d.\n",
 			video_info.video_mode, video_info.hdr_mode);
 	}
 
+	if (ioctl(fd_iav, IAV_IOC_VIN_SET_FPS, &vsrc_fps) < 0) {
+		perror("IAV_IOC_VIN_SET_FPS");
+		return -1;
+	} else {
+		printf("Succeed to restore vin frame rate %d.\n", vsrc_fps.fps);
+	}
+
 	return 0;
 }
 
@@ -331,7 +320,10 @@ static int recover_vsync_loss()
 	if (ret) {
 		return ret;
 	}
-	reset_vin();
+	ret = reset_vin();
+	if (ret) {
+		return ret;
+	}
 	ret = enter_preview();
 	if (ret) {
 		return ret;
@@ -345,13 +337,13 @@ static int process_vsync_req(int vsync_req)
 {
 	int ret = 0;
 
-	if (vsync_req == NL_REQUEST_VSYNC_RESTORE) {
+	if (vsync_req == NL_REQ_VSYNC_RESTORE) {
 		ret = recover_vsync_loss();
 		vsync_config.msg.pid = getpid();
 		vsync_config.msg.port = NL_PORT_VSYNC;
 		vsync_config.msg.type = NL_MSG_TYPE_REQUEST;
 		vsync_config.msg.dir = NL_MSG_DIR_STATUS;
-		vsync_config.msg.cmd = NL_REQUEST_VSYNC_RESTORE;
+		vsync_config.msg.cmd = NL_REQ_VSYNC_RESTORE;
 		if (ret < 0) {
 			vsync_config.msg.status = NL_CMD_STATUS_FAIL;
 			send_vsync_msg_to_kernel(vsync_config.msg);
@@ -377,7 +369,7 @@ static int process_vsync_session_status(struct nl_msg_data *kernel_msg)
 	}
 
 	switch (kernel_msg->cmd) {
-	case NL_SESSION_CMD_CONNECT:
+	case NL_SESS_CMD_CONNECT:
 		if (kernel_msg->status == NL_CMD_STATUS_SUCCESS) {
 			vsync_config.nl_connected = 1;
 			printf("Connection established with kernel.\n");
@@ -386,7 +378,7 @@ static int process_vsync_session_status(struct nl_msg_data *kernel_msg)
 			printf("Failed to establish connection with kernel!\n");
 		}
 		break;
-	case NL_SESSION_CMD_DISCONNECT:
+	case NL_SESS_CMD_DISCONNECT:
 		vsync_config.nl_connected = 0;
 		if (kernel_msg->status == NL_CMD_STATUS_SUCCESS) {
 			printf("Connection removed with kernel.\n");
@@ -466,7 +458,7 @@ static void * netlink_loop(void * data)
 	int count = 100;
 
 	while (count && !vsync_config.nl_connected) {
-		if (nl_send_vsync_session_cmd(NL_SESSION_CMD_CONNECT) < 0) {
+		if (nl_send_vsync_session_cmd(NL_SESS_CMD_CONNECT) < 0) {
 			printf("Failed to establish connection with kernel!\n");
 		}
 		sleep(1);
@@ -496,7 +488,7 @@ static void * netlink_loop(void * data)
 
 static void sigstop()
 {
-	nl_send_vsync_session_cmd(NL_SESSION_CMD_DISCONNECT);
+	nl_send_vsync_session_cmd(NL_SESS_CMD_DISCONNECT);
 	exit(1);
 }
 
diff --git a/iav_test/make.inc b/iav_test/make.inc
index a3ef394..e3613e9 100644
--- a/iav_test/make.inc
+++ b/iav_test/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/05 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2011-2015, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_UNIT_TESTS_IAV), y)
@@ -132,6 +149,7 @@ include $(CLEAR_VARS)
 LOCAL_TARGET	:= test_stream
 LOCAL_SRCS	:= $(LOCAL_PATH)/test_stream.c
 LOCAL_CFLAGS	:= -I$(AMB_TOPDIR)/packages/data_transfer
+LOCAL_LDFLAGS	:= -lpthread
 LOCAL_LIBS	:= libdatatx.a
 
 include $(BUILD_APP)
@@ -408,8 +426,8 @@ $(call add-target-into-build, $(LOCAL_TARGET))
 ###
 include $(CLEAR_VARS)
 
-LOCAL_TARGET	:= test_memcpy
-LOCAL_SRCS	:= $(LOCAL_PATH)/test_memcpy.c
+LOCAL_TARGET	:= test_vin_cap
+LOCAL_SRCS	:= $(LOCAL_PATH)/test_vin_cap.c
 
 include $(BUILD_APP)
 
@@ -425,10 +443,8 @@ $(call add-target-into-build, $(LOCAL_TARGET))
 ###
 include $(CLEAR_VARS)
 
-LOCAL_TARGET	:= test_directsharing
-LOCAL_SRCS	:= $(LOCAL_PATH)/test_directsharing.cpp
-LOCAL_CFLAGS	:= -I$(LOCAL_PATH)/directsharing_lib/include
-LOCAL_LDFLAGS	:= -L$(LOCAL_PATH)/directsharing_lib/lib -lpthread -lm -lmwcg_common -lmwcg_directsharing -lmwcg_common -lm -lpthread
+LOCAL_TARGET	:= test_memcpy
+LOCAL_SRCS	:= $(LOCAL_PATH)/test_memcpy.c
 
 include $(BUILD_APP)
 
diff --git a/iav_test/playback_helper.c b/iav_test/playback_helper.c
index 0c4f0d2..48dc884 100644
--- a/iav_test/playback_helper.c
+++ b/iav_test/playback_helper.c
@@ -2,14 +2,31 @@
  * playback_helper.c
  *
  * History:
- *	2015/02/10 - [Zhi He] create file
+ *  2015/02/10 - [Zhi He] create file
  *
- * Copyright (C) 2015 -2020, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
@@ -20,268 +37,268 @@
 #include "codec_parser.h"
 #include "playback_helper.h"
 
-int file_reader_init(_t_file_reader* p_reader, FILE* file_fd, unsigned long read_buffer_size, void* prealloc_file_buffer)
+int file_reader_init(_t_file_reader *p_reader, FILE *file_fd, unsigned long read_buffer_size, void *prealloc_file_buffer)
 {
-	if (!p_reader || !file_fd) {
-		printf("NULL p_reader(%p) or NULL file_fd(%p)\n", p_reader, file_fd);
-		return (-1);
-	}
-
-	if (!prealloc_file_buffer) {
-
-		if (!read_buffer_size) {
-			read_buffer_size = 16 * 1024 * 1024;
-		}
-
-		if (!p_reader->b_alloc_read_buffer) {
-			p_reader->p_read_buffer_base = malloc(read_buffer_size);
-			if (p_reader->p_read_buffer_base) {
-				p_reader->read_buffer_size = read_buffer_size;
-				p_reader->p_read_buffer_end = p_reader->p_read_buffer_base + p_reader->read_buffer_size;
-				p_reader->b_alloc_read_buffer = 1;
-			} else {
-				printf("no memory!\n");
-				return (-2);
-			}
-			p_reader->p_read_buffer_cur_start = p_reader->p_read_buffer_cur_end = p_reader->p_read_buffer_base;
-			p_reader->data_remainning_size_in_buffer = 0;
-			printf("[file_reader_init]: alloc memory size %lu, addr %p\n", p_reader->read_buffer_size, p_reader->p_read_buffer_base);
-		} else if (p_reader->read_buffer_size < read_buffer_size) {
-			if (p_reader->p_read_buffer_base) {
-				free(p_reader->p_read_buffer_base);
-				p_reader->p_read_buffer_base = NULL;
-			}
-
-			p_reader->p_read_buffer_base = malloc(read_buffer_size);
-			if (p_reader->p_read_buffer_base) {
-				p_reader->read_buffer_size = read_buffer_size;
-				p_reader->p_read_buffer_end = p_reader->p_read_buffer_base + p_reader->read_buffer_size;
-				p_reader->b_alloc_read_buffer = 1;
-			} else {
-				printf("no memory!\n");
-				return (-2);
-			}
-			p_reader->p_read_buffer_cur_start = p_reader->p_read_buffer_cur_end = p_reader->p_read_buffer_base;
-			p_reader->data_remainning_size_in_buffer = 0;
-			printf("[file_reader_init]: re-alloc memory size %lu, addr %p\n", p_reader->read_buffer_size, p_reader->p_read_buffer_base);
-		} else {
-			p_reader->p_read_buffer_cur_start = p_reader->p_read_buffer_cur_end = p_reader->p_read_buffer_base;
-			p_reader->data_remainning_size_in_buffer = 0;
-			printf("[file_reader_init]: re-use read buffer %lu, addr %p, request size %lu\n", p_reader->read_buffer_size, p_reader->p_read_buffer_base, read_buffer_size);
-		}
-	} else {
-		p_reader->b_alloc_read_buffer = 0;
-		p_reader->read_buffer_size = read_buffer_size;
-		p_reader->p_read_buffer_base = prealloc_file_buffer;
-		p_reader->p_read_buffer_cur_start = p_reader->p_read_buffer_cur_end = p_reader->p_read_buffer_base;
-		p_reader->p_read_buffer_end = p_reader->p_read_buffer_base + p_reader->read_buffer_size;
-		p_reader->data_remainning_size_in_buffer = 0;
-	}
-
-	p_reader->fd = file_fd;
-	p_reader->b_opened_file = 0;
-
-	fseek(p_reader->fd, 0L, SEEK_END);
-	p_reader->file_total_size = ftell(p_reader->fd);
-	p_reader->file_remainning_size = p_reader->file_total_size;
-
-	fseek(p_reader->fd, 0L, SEEK_SET);
-
-	return 0;
+    if (!p_reader || !file_fd) {
+        printf("NULL p_reader(%p) or NULL file_fd(%p)\n", p_reader, file_fd);
+        return (-1);
+    }
+
+    if (!prealloc_file_buffer) {
+
+        if (!read_buffer_size) {
+            read_buffer_size = 16 * 1024 * 1024;
+        }
+
+        if (!p_reader->b_alloc_read_buffer) {
+            p_reader->p_read_buffer_base = malloc(read_buffer_size);
+            if (p_reader->p_read_buffer_base) {
+                p_reader->read_buffer_size = read_buffer_size;
+                p_reader->p_read_buffer_end = p_reader->p_read_buffer_base + p_reader->read_buffer_size;
+                p_reader->b_alloc_read_buffer = 1;
+            } else {
+                printf("no memory!\n");
+                return (-2);
+            }
+            p_reader->p_read_buffer_cur_start = p_reader->p_read_buffer_cur_end = p_reader->p_read_buffer_base;
+            p_reader->data_remainning_size_in_buffer = 0;
+            printf("[file_reader_init]: alloc memory size %lu, addr %p\n", p_reader->read_buffer_size, p_reader->p_read_buffer_base);
+        } else if (p_reader->read_buffer_size < read_buffer_size) {
+            if (p_reader->p_read_buffer_base) {
+                free(p_reader->p_read_buffer_base);
+                p_reader->p_read_buffer_base = NULL;
+            }
+
+            p_reader->p_read_buffer_base = malloc(read_buffer_size);
+            if (p_reader->p_read_buffer_base) {
+                p_reader->read_buffer_size = read_buffer_size;
+                p_reader->p_read_buffer_end = p_reader->p_read_buffer_base + p_reader->read_buffer_size;
+                p_reader->b_alloc_read_buffer = 1;
+            } else {
+                printf("no memory!\n");
+                return (-2);
+            }
+            p_reader->p_read_buffer_cur_start = p_reader->p_read_buffer_cur_end = p_reader->p_read_buffer_base;
+            p_reader->data_remainning_size_in_buffer = 0;
+            printf("[file_reader_init]: re-alloc memory size %lu, addr %p\n", p_reader->read_buffer_size, p_reader->p_read_buffer_base);
+        } else {
+            p_reader->p_read_buffer_cur_start = p_reader->p_read_buffer_cur_end = p_reader->p_read_buffer_base;
+            p_reader->data_remainning_size_in_buffer = 0;
+            printf("[file_reader_init]: re-use read buffer %lu, addr %p, request size %lu\n", p_reader->read_buffer_size, p_reader->p_read_buffer_base, read_buffer_size);
+        }
+    } else {
+        p_reader->b_alloc_read_buffer = 0;
+        p_reader->read_buffer_size = read_buffer_size;
+        p_reader->p_read_buffer_base = prealloc_file_buffer;
+        p_reader->p_read_buffer_cur_start = p_reader->p_read_buffer_cur_end = p_reader->p_read_buffer_base;
+        p_reader->p_read_buffer_end = p_reader->p_read_buffer_base + p_reader->read_buffer_size;
+        p_reader->data_remainning_size_in_buffer = 0;
+    }
+
+    p_reader->fd = file_fd;
+    p_reader->b_opened_file = 0;
+
+    fseek(p_reader->fd, 0L, SEEK_END);
+    p_reader->file_total_size = ftell(p_reader->fd);
+    p_reader->file_remainning_size = p_reader->file_total_size;
+
+    fseek(p_reader->fd, 0L, SEEK_SET);
+
+    return 0;
 }
 
-void file_reader_deinit(_t_file_reader* p_reader)
+void file_reader_deinit(_t_file_reader *p_reader)
 {
-	if (!p_reader) {
-		printf("NULL p_reader(%p)\n", p_reader);
-		return;
-	}
-
-	if (p_reader->b_alloc_read_buffer) {
-		if (p_reader->p_read_buffer_base) {
-			free(p_reader->p_read_buffer_base);
-			p_reader->b_alloc_read_buffer = 0;
-		} else {
-			printf("NULL p_reader->p_read_buffer_base\n");
-		}
-	}
-
-	return;
+    if (!p_reader) {
+        printf("NULL p_reader(%p)\n", p_reader);
+        return;
+    }
+
+    if (p_reader->b_alloc_read_buffer) {
+        if (p_reader->p_read_buffer_base) {
+            free(p_reader->p_read_buffer_base);
+            p_reader->b_alloc_read_buffer = 0;
+        } else {
+            printf("NULL p_reader->p_read_buffer_base\n");
+        }
+    }
+
+    return;
 }
 
-void file_reader_reset(_t_file_reader* p_reader)
+void file_reader_reset(_t_file_reader *p_reader)
 {
-	p_reader->p_read_buffer_cur_start = p_reader->p_read_buffer_cur_end = p_reader->p_read_buffer_base;
-	p_reader->data_remainning_size_in_buffer = 0;
-	p_reader->file_remainning_size = p_reader->file_total_size;
+    p_reader->p_read_buffer_cur_start = p_reader->p_read_buffer_cur_end = p_reader->p_read_buffer_base;
+    p_reader->data_remainning_size_in_buffer = 0;
+    p_reader->file_remainning_size = p_reader->file_total_size;
 
-	fseek(p_reader->fd, 0L, SEEK_SET);
+    fseek(p_reader->fd, 0L, SEEK_SET);
 }
 
-int file_reader_read_trunk(_t_file_reader* p_reader)
+int file_reader_read_trunk(_t_file_reader *p_reader)
 {
-	unsigned long size = 0;
-
-	size = (unsigned long)(p_reader->p_read_buffer_end - p_reader->p_read_buffer_cur_end);
-
-	if (p_reader->file_remainning_size <= size) {
-		size = p_reader->file_remainning_size;
-		fread(p_reader->p_read_buffer_cur_end, 1, size, p_reader->fd);
-		p_reader->file_remainning_size -= size;
-		p_reader->data_remainning_size_in_buffer += size;
-		p_reader->p_read_buffer_cur_end += size;
-		return 1;//file read done
-	} else {
-		memmove(p_reader->p_read_buffer_base, p_reader->p_read_buffer_cur_start, p_reader->data_remainning_size_in_buffer);
-		p_reader->p_read_buffer_cur_start = p_reader->p_read_buffer_base;
-		p_reader->p_read_buffer_cur_end = p_reader->p_read_buffer_cur_start + p_reader->data_remainning_size_in_buffer;
-		size = p_reader->p_read_buffer_end - p_reader->p_read_buffer_cur_end;
-
-		if (p_reader->file_remainning_size <= size) {
-			size = p_reader->file_remainning_size;
-			fread(p_reader->p_read_buffer_cur_end, 1, size, p_reader->fd);
-			p_reader->file_remainning_size -= size;
-			p_reader->data_remainning_size_in_buffer += size;
-			p_reader->p_read_buffer_cur_end += size;
-			return 1;//file read done
-		}
-
-		fread(p_reader->p_read_buffer_cur_end, 1, size, p_reader->fd);
-		p_reader->file_remainning_size -= size;
-		p_reader->data_remainning_size_in_buffer += size;
-		p_reader->p_read_buffer_cur_end += size;
-	}
-
-	return 0;
+    unsigned long size = 0;
+
+    size = (unsigned long)(p_reader->p_read_buffer_end - p_reader->p_read_buffer_cur_end);
+
+    if (p_reader->file_remainning_size <= size) {
+        size = p_reader->file_remainning_size;
+        fread(p_reader->p_read_buffer_cur_end, 1, size, p_reader->fd);
+        p_reader->file_remainning_size -= size;
+        p_reader->data_remainning_size_in_buffer += size;
+        p_reader->p_read_buffer_cur_end += size;
+        return 1;//file read done
+    } else {
+        memmove(p_reader->p_read_buffer_base, p_reader->p_read_buffer_cur_start, p_reader->data_remainning_size_in_buffer);
+        p_reader->p_read_buffer_cur_start = p_reader->p_read_buffer_base;
+        p_reader->p_read_buffer_cur_end = p_reader->p_read_buffer_cur_start + p_reader->data_remainning_size_in_buffer;
+        size = p_reader->p_read_buffer_end - p_reader->p_read_buffer_cur_end;
+
+        if (p_reader->file_remainning_size <= size) {
+            size = p_reader->file_remainning_size;
+            fread(p_reader->p_read_buffer_cur_end, 1, size, p_reader->fd);
+            p_reader->file_remainning_size -= size;
+            p_reader->data_remainning_size_in_buffer += size;
+            p_reader->p_read_buffer_cur_end += size;
+            return 1;//file read done
+        }
+
+        fread(p_reader->p_read_buffer_cur_end, 1, size, p_reader->fd);
+        p_reader->file_remainning_size -= size;
+        p_reader->data_remainning_size_in_buffer += size;
+        p_reader->p_read_buffer_cur_end += size;
+    }
+
+    return 0;
 }
 
 static fast_navi_gop *_new_fast_navi_gop()
 {
-	fast_navi_gop * p_gop = (fast_navi_gop *) malloc(sizeof(fast_navi_gop));
-	if (p_gop) {
-		memset(p_gop, 0x0, sizeof(fast_navi_gop));
-	} else {
-		printf("error: malloc fail\n");
-	}
-
-	return p_gop;
+    fast_navi_gop *p_gop = (fast_navi_gop *) malloc(sizeof(fast_navi_gop));
+    if (p_gop) {
+        memset(p_gop, 0x0, sizeof(fast_navi_gop));
+    } else {
+        printf("error: malloc fail\n");
+    }
+
+    return p_gop;
 }
 
-unsigned int get_next_frame(unsigned char* pstart, unsigned char* pend, unsigned char* p_nal_type, unsigned char* p_slice_type, unsigned char* need_more_data)
+unsigned int get_next_frame(unsigned char *pstart, unsigned char *pend, unsigned char *p_nal_type, unsigned char *p_slice_type, unsigned char *need_more_data)
 {
-	unsigned char* pcur = pstart;
-	unsigned int state = 0;
-	unsigned int is_header = 1;
-
-	unsigned char	nal_type;
-	unsigned char	first_mb_in_slice = 0;
-
-	*need_more_data = 0;
-	*p_slice_type = 0;
-	*p_nal_type = 0;
-
-	while (pcur < pend) {
-		switch (state) {
-			case 0:
-				if (*pcur++ == 0x0)
-					state = 1;
-				break;
-			case 1://0
-				if (*pcur++ == 0x0)
-					state = 2;
-				else
-					state = 0;
-				break;
-			case 2://0 0
-				if (*pcur == 0x1)
-					state = 3;
-				else if (*pcur != 0x0)
-					state = 0;
-				pcur ++;
-				break;
-			case 3://0 0 1
-				if ((*pcur) ==0x0A) {
-					//eos
-					if (is_header) {
-						printf("eos comes, pcur + 1 - pstart is %d\n", pcur + 1 - pstart);
-						*p_nal_type = 0x0A;
-						return pcur + 1 - pstart;
-					} else {
-						if ((pcur > (pstart + 4)) && (*(pcur - 4) == 0)) {
-							printf("before eos in bit-stream, pcur - 4 - pstart is %d\n", pcur - 4 - pstart);
-							return pcur - 4 - pstart;
-						} else {
-							printf("before eos in bit-stream, pcur - 3 - pstart is %d\n", pcur - 3 - pstart);
-							return pcur - 3 - pstart;
-						}
-					}
-				} else if ((*pcur)) { //nal uint type
-					nal_type = (*pcur) & 0x1F;
-					//*p_nal_type = nal_type;
-					if (nal_type >= 1 && nal_type <= 5) {
-						if (!is_header) {
-							if (pcur + 16 < pend) {
-								//printf("1 %p: %02x %02x %02x %02x, %02x %02x %02x %02x\n", pcur, *(pcur -3), *(pcur -2), *(pcur -1), *(pcur), *(pcur + 1), *(pcur + 2), *(pcur + 3), *(pcur + 4));
-								get_h264_slice_type_le(pcur + 1, &first_mb_in_slice);
-
-								if (!first_mb_in_slice) {
-									if ((pcur > (pstart + 4)) && (*(pcur - 4) == 0)) {
-										return pcur - 4 - pstart;
-									} else {
-										return pcur - 3 - pstart;
-									}
-								} else {
-									state = 0;
-								}
-							} else {
-								*need_more_data = 1;
-								return 0;
-							}
-						} else {
-							if (pcur + 16 < pend) {
-								//printf("%02x %02x %02x %02x %02x %02x %02x %02x\n", *(pcur - 4), *(pcur - 3), *(pcur - 2), *(pcur - 1), *(pcur), *(pcur + 1), *(pcur + 2), *(pcur + 3));
-								*p_slice_type = get_h264_slice_type_le(pcur + 1, &first_mb_in_slice);
-								*p_nal_type = nal_type;
-								state = 0;
-								is_header = 0;
-							} else {
-								printf("[error]: must not comes here!\n");
-								*need_more_data = 1;
-								return 0;
-							}
-						}
-					} else if (nal_type >= 6 && nal_type <= 8) {
-						if (!is_header) {
-							if ((pcur > (pstart + 4)) && (*(pcur - 4) == 0)) {
-								return pcur - 4 - pstart;
-							} else {
-								return pcur - 3 - pstart;
-							}
-						}
-						state = 0;
-					} else if (nal_type == 9) {
-						state = 0;
-					} else {
-						printf("[error]: why comes here? nal_type %d\n", nal_type);
-					}
-				} else {
-					state = 1;
-				}
-				pcur ++;
-				break;
-
-			default:
-				printf("[error]: must not comes here! state %d\n", state);
-				state = 0;
-				break;
-		}
-	}
-
-	*need_more_data = 1;
-	return 0;
+    unsigned char *pcur = pstart;
+    unsigned int state = 0;
+    unsigned int is_header = 1;
+
+    unsigned char   nal_type;
+    unsigned char   first_mb_in_slice = 0;
+
+    *need_more_data = 0;
+    *p_slice_type = 0;
+    *p_nal_type = 0;
+
+    while (pcur < pend) {
+        switch (state) {
+            case 0:
+                if (*pcur++ == 0x0)
+                { state = 1; }
+                break;
+            case 1://0
+                if (*pcur++ == 0x0)
+                { state = 2; }
+                else
+                { state = 0; }
+                break;
+            case 2://0 0
+                if (*pcur == 0x1)
+                { state = 3; }
+                else if (*pcur != 0x0)
+                { state = 0; }
+                pcur ++;
+                break;
+            case 3://0 0 1
+                if ((*pcur) == 0x0A) {
+                    //eos
+                    if (is_header) {
+                        printf("eos comes, pcur + 1 - pstart is %d\n", pcur + 1 - pstart);
+                        *p_nal_type = 0x0A;
+                        return pcur + 1 - pstart;
+                    } else {
+                        if ((pcur > (pstart + 4)) && (*(pcur - 4) == 0)) {
+                            printf("before eos in bit-stream, pcur - 4 - pstart is %d\n", pcur - 4 - pstart);
+                            return pcur - 4 - pstart;
+                        } else {
+                            printf("before eos in bit-stream, pcur - 3 - pstart is %d\n", pcur - 3 - pstart);
+                            return pcur - 3 - pstart;
+                        }
+                    }
+                } else if ((*pcur)) { //nal uint type
+                    nal_type = (*pcur) & 0x1F;
+                    //*p_nal_type = nal_type;
+                    if (nal_type >= 1 && nal_type <= 5) {
+                        if (!is_header) {
+                            if (pcur + 16 < pend) {
+                                //printf("1 %p: %02x %02x %02x %02x, %02x %02x %02x %02x\n", pcur, *(pcur -3), *(pcur -2), *(pcur -1), *(pcur), *(pcur + 1), *(pcur + 2), *(pcur + 3), *(pcur + 4));
+                                get_h264_slice_type_le(pcur + 1, &first_mb_in_slice);
+
+                                if (!first_mb_in_slice) {
+                                    if ((pcur > (pstart + 4)) && (*(pcur - 4) == 0)) {
+                                        return pcur - 4 - pstart;
+                                    } else {
+                                        return pcur - 3 - pstart;
+                                    }
+                                } else {
+                                    state = 0;
+                                }
+                            } else {
+                                *need_more_data = 1;
+                                return 0;
+                            }
+                        } else {
+                            if (pcur + 16 < pend) {
+                                //printf("%02x %02x %02x %02x %02x %02x %02x %02x\n", *(pcur - 4), *(pcur - 3), *(pcur - 2), *(pcur - 1), *(pcur), *(pcur + 1), *(pcur + 2), *(pcur + 3));
+                                *p_slice_type = get_h264_slice_type_le(pcur + 1, &first_mb_in_slice);
+                                *p_nal_type = nal_type;
+                                state = 0;
+                                is_header = 0;
+                            } else {
+                                printf("[error]: must not comes here!\n");
+                                *need_more_data = 1;
+                                return 0;
+                            }
+                        }
+                    } else if (nal_type >= 6 && nal_type <= 9) {
+                        if (!is_header) {
+                            if ((pcur > (pstart + 4)) && (*(pcur - 4) == 0)) {
+                                return pcur - 4 - pstart;
+                            } else {
+                                return pcur - 3 - pstart;
+                            }
+                        }
+                        state = 0;
+                    }/* else if (nal_type == 9) {
+                        state = 0;
+                    }*/ else {
+                        printf("[error]: why comes here? nal_type %d\n", nal_type);
+                    }
+                } else {
+                    state = 1;
+                }
+                pcur ++;
+                break;
+
+            default:
+                printf("[error]: must not comes here! state %d\n", state);
+                state = 0;
+                break;
+        }
+    }
+
+    *need_more_data = 1;
+    return 0;
 }
 
-static unsigned int __skip_delimter_size(unsigned char* p)
+static unsigned int __skip_delimter_size(unsigned char *p)
 {
     if ((0 == p[0]) && (0 == p[1]) && (0 == p[2]) && (1 == p[3]) && (0x09 == p[4])) {
         return 6;
@@ -290,174 +307,174 @@ static unsigned int __skip_delimter_size(unsigned char* p)
     return 0;
 }
 
-int build_fast_navi_tree(FILE* file_fd, fast_navi_file* navi_tree)
+int build_fast_navi_tree(FILE *file_fd, fast_navi_file *navi_tree)
 {
-	unsigned char *p_cur_ptr = NULL;
-	_file_size_t file_remain_data_size = 0;
-	_file_size_t buf_remain_data_size = 0;
-
-	if ((!file_fd) || (!navi_tree)) {
-		printf("NULL params file_fd %p, or navi_tree %p\n", file_fd, navi_tree);
-		return (-1);
-	}
-
-	navi_tree->file_fd = file_fd;
-	navi_tree->buf_size = 8 * 1024 * 1024;
-	navi_tree->p_buf_base = (unsigned char *) malloc(navi_tree->buf_size);
-	if (!navi_tree->p_buf_base) {
-		printf("[error]: no memory, request size %ld\n", navi_tree->buf_size);
-		return (-2);
-	}
-
-	fseek(file_fd, 0L, SEEK_END);
-	navi_tree->file_size = ftell(file_fd);
-	fseek(file_fd, 0L, SEEK_SET);
-	navi_tree->cur_file_offset = 0;
-
-	navi_tree->tot_frame_count = 0;
-	navi_tree->tot_gop_count = 0;
-	memset(&navi_tree->gop_list_header, 0x0, sizeof(fast_navi_gop));
-	navi_tree->gop_list_header.p_next = &navi_tree->gop_list_header;
-	navi_tree->gop_list_header.p_pre = &navi_tree->gop_list_header;
-
-	file_remain_data_size = navi_tree->file_size;
-	printf("[flow]: begin build navi tree from file, file size %ld, please wait a while ......\n", navi_tree->file_size);
-
-	//read first data chunk
-	if (file_remain_data_size > navi_tree->buf_size) {
-		fread(navi_tree->p_buf_base, 1, navi_tree->buf_size, file_fd);
-		buf_remain_data_size = navi_tree->buf_size;
-		file_remain_data_size -= navi_tree->buf_size;
-	} else {
-		fread(navi_tree->p_buf_base, 1, file_remain_data_size, file_fd);
-		buf_remain_data_size = file_remain_data_size;
-		file_remain_data_size = 0;
-	}
-
-	unsigned int frame_size = 0;
-	unsigned char nal_type = 0;
-	unsigned char slice_type = 0;
-	unsigned char need_more_data = 0;
-	unsigned char eos_reached = 0;
-	fast_navi_gop* new_gop = NULL;
-
-	//skip begining delimiter for some bitstream
-	unsigned int skip_size = __skip_delimter_size(navi_tree->p_buf_base);
-	if (skip_size) {
-		printf("skip delimiter in beginning!\n");
-		buf_remain_data_size -= skip_size;
-	}
-	p_cur_ptr = navi_tree->p_buf_base + skip_size;
-
-	while (1) {
-		frame_size = get_next_frame(p_cur_ptr, p_cur_ptr + buf_remain_data_size, &nal_type, &slice_type, &need_more_data);
-		if (!frame_size && need_more_data) {
-			if (!file_remain_data_size) {
-				printf("[flow]: file end reached, this is last frame\n");
-				frame_size = buf_remain_data_size;
-				eos_reached = 1;
-			} else {
-				if (navi_tree->p_buf_base == p_cur_ptr) {
-					printf("[error]: do not find start code in file, data corruption, or not h264 es file\n");
-					return (-7);
-				}
-				navi_tree->cur_file_offset += navi_tree->buf_size - buf_remain_data_size;
-				memmove(navi_tree->p_buf_base, p_cur_ptr, buf_remain_data_size);
-				p_cur_ptr = navi_tree->p_buf_base;
-
-				if ((file_remain_data_size + buf_remain_data_size) > navi_tree->buf_size) {
-					fread(navi_tree->p_buf_base + buf_remain_data_size, 1, navi_tree->buf_size - buf_remain_data_size, file_fd);
-					file_remain_data_size -= navi_tree->buf_size - buf_remain_data_size;
-					buf_remain_data_size = navi_tree->buf_size;
-				} else {
-					fread(navi_tree->p_buf_base + buf_remain_data_size, 1, file_remain_data_size, file_fd);
-					buf_remain_data_size += file_remain_data_size;
-					file_remain_data_size = 0;
-				}
-				continue;
-			}
-		}
-
-		if (AVC_NAL_TYPE_IDR == nal_type) {
-			new_gop = _new_fast_navi_gop();
-			if (!new_gop) {
-				printf("[error]: new gop fail\n");
-				return (-3);
-			}
-
-			//append to tail
-			new_gop->p_next = &navi_tree->gop_list_header;
-			new_gop->p_pre = navi_tree->gop_list_header.p_pre;
-			navi_tree->gop_list_header.p_pre->p_next = new_gop;
-			navi_tree->gop_list_header.p_pre = new_gop;
-
-			//printf("insert gop %p, its next is %p, header %p\n", new_gop, new_gop->p_next, &navi_tree->gop_list_header);
-
-			new_gop->gop_index = navi_tree->tot_gop_count;
-			new_gop->gop_offset = navi_tree->cur_file_offset + p_cur_ptr - navi_tree->p_buf_base;
-			new_gop->start_frame_index = navi_tree->tot_frame_count;
-
-			new_gop->frames[0].frame_offset = 0;
-			new_gop->frames[1].frame_offset = frame_size;
-			new_gop->frame_count = 1;
-
-			navi_tree->tot_gop_count ++;
-			navi_tree->tot_frame_count ++;
-		} else if (AVC_NAL_TYPE_IDR > nal_type) {
-			if (!new_gop) {
-				printf("[error]: file not start with IDR frame? skip..\n");
-				p_cur_ptr += frame_size;
-				buf_remain_data_size -= frame_size;
-				continue;
-			}
-			if (new_gop->frame_count > (DMAX_GOP_LENGTH - 2)) {
-				printf("[error]: exceed max gop length!\n");
-				return (-4);
-			}
-
-			new_gop->frames[new_gop->frame_count].frame_offset = navi_tree->cur_file_offset + p_cur_ptr - navi_tree->p_buf_base - new_gop->gop_offset;
-			new_gop->frames[new_gop->frame_count + 1].frame_offset = new_gop->frames[new_gop->frame_count].frame_offset + frame_size;
-			new_gop->frame_count ++;
-
-			navi_tree->tot_frame_count ++;
-		} else {
-			printf("[error]: unexpected nal type %d!\n", nal_type);
-			return (-5);
-		}
-
-		if (eos_reached) {
-			break;
-		}
-		p_cur_ptr += frame_size;
-		buf_remain_data_size -= frame_size;
-	}
-
-	printf("build navi tree done, total gop number %d, total frame number %d\n", navi_tree->tot_gop_count, navi_tree->tot_frame_count);
-
-	return 0;
+    unsigned char *p_cur_ptr = NULL;
+    _file_size_t file_remain_data_size = 0;
+    _file_size_t buf_remain_data_size = 0;
+
+    if ((!file_fd) || (!navi_tree)) {
+        printf("NULL params file_fd %p, or navi_tree %p\n", file_fd, navi_tree);
+        return (-1);
+    }
+
+    navi_tree->file_fd = file_fd;
+    navi_tree->buf_size = 8 * 1024 * 1024;
+    navi_tree->p_buf_base = (unsigned char *) malloc(navi_tree->buf_size);
+    if (!navi_tree->p_buf_base) {
+        printf("[error]: no memory, request size %ld\n", navi_tree->buf_size);
+        return (-2);
+    }
+
+    fseek(file_fd, 0L, SEEK_END);
+    navi_tree->file_size = ftell(file_fd);
+    fseek(file_fd, 0L, SEEK_SET);
+    navi_tree->cur_file_offset = 0;
+
+    navi_tree->tot_frame_count = 0;
+    navi_tree->tot_gop_count = 0;
+    memset(&navi_tree->gop_list_header, 0x0, sizeof(fast_navi_gop));
+    navi_tree->gop_list_header.p_next = &navi_tree->gop_list_header;
+    navi_tree->gop_list_header.p_pre = &navi_tree->gop_list_header;
+
+    file_remain_data_size = navi_tree->file_size;
+    printf("[flow]: begin build navi tree from file, file size %ld, please wait a while ......\n", navi_tree->file_size);
+
+    //read first data chunk
+    if (file_remain_data_size > navi_tree->buf_size) {
+        fread(navi_tree->p_buf_base, 1, navi_tree->buf_size, file_fd);
+        buf_remain_data_size = navi_tree->buf_size;
+        file_remain_data_size -= navi_tree->buf_size;
+    } else {
+        fread(navi_tree->p_buf_base, 1, file_remain_data_size, file_fd);
+        buf_remain_data_size = file_remain_data_size;
+        file_remain_data_size = 0;
+    }
+
+    unsigned int frame_size = 0;
+    unsigned char nal_type = 0;
+    unsigned char slice_type = 0;
+    unsigned char need_more_data = 0;
+    unsigned char eos_reached = 0;
+    fast_navi_gop *new_gop = NULL;
+
+    //skip begining delimiter for some bitstream
+    unsigned int skip_size = __skip_delimter_size(navi_tree->p_buf_base);
+    if (skip_size) {
+        printf("skip delimiter in beginning!\n");
+        buf_remain_data_size -= skip_size;
+    }
+    p_cur_ptr = navi_tree->p_buf_base + skip_size;
+
+    while (1) {
+        frame_size = get_next_frame(p_cur_ptr, p_cur_ptr + buf_remain_data_size, &nal_type, &slice_type, &need_more_data);
+        if (!frame_size && need_more_data) {
+            if (!file_remain_data_size) {
+                printf("[flow]: file end reached, this is last frame\n");
+                frame_size = buf_remain_data_size;
+                eos_reached = 1;
+            } else {
+                if (navi_tree->p_buf_base == p_cur_ptr) {
+                    printf("[error]: do not find start code in file, data corruption, or not h264 es file\n");
+                    return (-7);
+                }
+                navi_tree->cur_file_offset += navi_tree->buf_size - buf_remain_data_size;
+                memmove(navi_tree->p_buf_base, p_cur_ptr, buf_remain_data_size);
+                p_cur_ptr = navi_tree->p_buf_base;
+
+                if ((file_remain_data_size + buf_remain_data_size) > navi_tree->buf_size) {
+                    fread(navi_tree->p_buf_base + buf_remain_data_size, 1, navi_tree->buf_size - buf_remain_data_size, file_fd);
+                    file_remain_data_size -= navi_tree->buf_size - buf_remain_data_size;
+                    buf_remain_data_size = navi_tree->buf_size;
+                } else {
+                    fread(navi_tree->p_buf_base + buf_remain_data_size, 1, file_remain_data_size, file_fd);
+                    buf_remain_data_size += file_remain_data_size;
+                    file_remain_data_size = 0;
+                }
+                continue;
+            }
+        }
+
+        if (AVC_NAL_TYPE_IDR == nal_type) {
+            new_gop = _new_fast_navi_gop();
+            if (!new_gop) {
+                printf("[error]: new gop fail\n");
+                return (-3);
+            }
+
+            //append to tail
+            new_gop->p_next = &navi_tree->gop_list_header;
+            new_gop->p_pre = navi_tree->gop_list_header.p_pre;
+            navi_tree->gop_list_header.p_pre->p_next = new_gop;
+            navi_tree->gop_list_header.p_pre = new_gop;
+
+            //printf("insert gop %p, its next is %p, header %p\n", new_gop, new_gop->p_next, &navi_tree->gop_list_header);
+
+            new_gop->gop_index = navi_tree->tot_gop_count;
+            new_gop->gop_offset = navi_tree->cur_file_offset + p_cur_ptr - navi_tree->p_buf_base;
+            new_gop->start_frame_index = navi_tree->tot_frame_count;
+
+            new_gop->frames[0].frame_offset = 0;
+            new_gop->frames[1].frame_offset = frame_size;
+            new_gop->frame_count = 1;
+
+            navi_tree->tot_gop_count ++;
+            navi_tree->tot_frame_count ++;
+        } else if (AVC_NAL_TYPE_IDR > nal_type) {
+            if (!new_gop) {
+                printf("[error]: file not start with IDR frame? skip..\n");
+                p_cur_ptr += frame_size;
+                buf_remain_data_size -= frame_size;
+                continue;
+            }
+            if (new_gop->frame_count > (DMAX_GOP_LENGTH - 2)) {
+                printf("[error]: exceed max gop length!\n");
+                return (-4);
+            }
+
+            new_gop->frames[new_gop->frame_count].frame_offset = navi_tree->cur_file_offset + p_cur_ptr - navi_tree->p_buf_base - new_gop->gop_offset;
+            new_gop->frames[new_gop->frame_count + 1].frame_offset = new_gop->frames[new_gop->frame_count].frame_offset + frame_size;
+            new_gop->frame_count ++;
+
+            navi_tree->tot_frame_count ++;
+        } else {
+            printf("[error]: unexpected nal type %d!\n", nal_type);
+            return (-5);
+        }
+
+        if (eos_reached) {
+            break;
+        }
+        p_cur_ptr += frame_size;
+        buf_remain_data_size -= frame_size;
+    }
+
+    printf("build navi tree done, total gop number %d, total frame number %d\n", navi_tree->tot_gop_count, navi_tree->tot_frame_count);
+
+    return 0;
 }
 
-void delete_fast_navi_tree(fast_navi_file* navi_tree)
+void delete_fast_navi_tree(fast_navi_file *navi_tree)
 {
-	if (navi_tree) {
-		if (navi_tree->p_buf_base) {
-			free(navi_tree->p_buf_base);
-			navi_tree->p_buf_base = NULL;
-		}
-
-		fast_navi_gop* p_gop = navi_tree->gop_list_header.p_next;
-		fast_navi_gop* p_next = NULL;
-		while (p_gop != &navi_tree->gop_list_header) {
-			p_next = p_gop->p_next;
-			free(p_gop);
-			p_gop = p_next;
-		}
-		navi_tree->gop_list_header.p_next = &navi_tree->gop_list_header;
-		navi_tree->gop_list_header.p_pre = &navi_tree->gop_list_header;
-
-		navi_tree->tot_frame_count = 0;
-		navi_tree->tot_gop_count = 0;
-	}
+    if (navi_tree) {
+        if (navi_tree->p_buf_base) {
+            free(navi_tree->p_buf_base);
+            navi_tree->p_buf_base = NULL;
+        }
+
+        fast_navi_gop *p_gop = navi_tree->gop_list_header.p_next;
+        fast_navi_gop *p_next = NULL;
+        while (p_gop != &navi_tree->gop_list_header) {
+            p_next = p_gop->p_next;
+            free(p_gop);
+            p_gop = p_next;
+        }
+        navi_tree->gop_list_header.p_next = &navi_tree->gop_list_header;
+        navi_tree->gop_list_header.p_pre = &navi_tree->gop_list_header;
+
+        navi_tree->tot_frame_count = 0;
+        navi_tree->tot_gop_count = 0;
+    }
 
 }
 
diff --git a/iav_test/playback_helper.h b/iav_test/playback_helper.h
index 6aa79b2..7417ecb 100644
--- a/iav_test/playback_helper.h
+++ b/iav_test/playback_helper.h
@@ -2,92 +2,106 @@
  * playback_helper.h
  *
  * History:
- *	2015/02/10 - [Zhi He] create file
+ *  2015/02/10 - [Zhi He] create file
  *
- * Copyright (C) 2015 -2020, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
 enum {
-	AVC_NAL_TYPE_NON_IDR_BEGIN = 0x01,
-
-	AVC_NAL_TYPE_IDR = 0x05,
-	AVC_NAL_TYPE_SEI = 0x06,
-	AVC_NAL_TYPE_SPS = 0x07,
-	AVC_NAL_TYPE_PPS = 0x08,
-	AVC_NAL_TYPE_DELIMITER = 0x09,
-	AVC_NAL_TYPE_EOS = 0x0a,
+    AVC_NAL_TYPE_NON_IDR_BEGIN = 0x01,
+
+    AVC_NAL_TYPE_IDR = 0x05,
+    AVC_NAL_TYPE_SEI = 0x06,
+    AVC_NAL_TYPE_SPS = 0x07,
+    AVC_NAL_TYPE_PPS = 0x08,
+    AVC_NAL_TYPE_DELIMITER = 0x09,
+    AVC_NAL_TYPE_EOS = 0x0a,
 } AVC_NAL_TYPE;
 
 #define DMAX_GOP_LENGTH 264
 typedef unsigned long _file_size_t;
 
-typedef struct
-{
-	_file_size_t frame_offset;
+typedef struct {
+    _file_size_t frame_offset;
 } fast_navi_frame;
 
-typedef struct __s_fast_navi_gop
-{
-	_file_size_t gop_offset;
-	unsigned int gop_index;
-	unsigned int start_frame_index;
+typedef struct __s_fast_navi_gop {
+    _file_size_t gop_offset;
+    unsigned int gop_index;
+    unsigned int start_frame_index;
 
-	unsigned int frame_count;
-	fast_navi_frame frames[DMAX_GOP_LENGTH];
+    unsigned int frame_count;
+    fast_navi_frame frames[DMAX_GOP_LENGTH];
 
-	struct __s_fast_navi_gop *p_next;
-	struct __s_fast_navi_gop *p_pre;
+    struct __s_fast_navi_gop *p_next;
+    struct __s_fast_navi_gop *p_pre;
 } fast_navi_gop;
 
-typedef struct
-{
-	//gop, frame, tree
-	fast_navi_gop gop_list_header;
-	unsigned int tot_gop_count;
-	unsigned int tot_frame_count;
-
-	//file related
-	FILE* file_fd;
-	_file_size_t file_size;
-	unsigned char *p_buf_base;
-	_file_size_t buf_size;
-	_file_size_t cur_file_offset;
+typedef struct {
+    //gop, frame, tree
+    fast_navi_gop gop_list_header;
+    unsigned int tot_gop_count;
+    unsigned int tot_frame_count;
+
+    //file related
+    FILE *file_fd;
+    _file_size_t file_size;
+    unsigned char *p_buf_base;
+    _file_size_t buf_size;
+    _file_size_t cur_file_offset;
 
 } fast_navi_file;
 
 typedef struct {
-	FILE* fd;
+    FILE *fd;
 
-	unsigned long read_buffer_size;
-	unsigned long file_total_size;
-	unsigned long file_remainning_size;
-	unsigned long data_remainning_size_in_buffer;
+    unsigned long read_buffer_size;
+    unsigned long file_total_size;
+    unsigned long file_remainning_size;
+    unsigned long data_remainning_size_in_buffer;
 
-	unsigned char* p_read_buffer_base;
-	unsigned char* p_read_buffer_end;
+    unsigned char *p_read_buffer_base;
+    unsigned char *p_read_buffer_end;
 
-	unsigned char* p_read_buffer_cur_start;
-	unsigned char* p_read_buffer_cur_end;
+    unsigned char *p_read_buffer_cur_start;
+    unsigned char *p_read_buffer_cur_end;
 
-	unsigned char b_alloc_read_buffer;
-	unsigned char b_opened_file;
-	unsigned char reserved1;
-	unsigned char reserved2;
+    unsigned char b_alloc_read_buffer;
+    unsigned char b_opened_file;
+    unsigned char reserved1;
+    unsigned char reserved2;
 } _t_file_reader;
 
-int file_reader_init(_t_file_reader* p_reader, FILE* file_fd, unsigned long read_buffer_size, void* prealloc_file_buffer);
-void file_reader_deinit(_t_file_reader* p_reader);
-void file_reader_reset(_t_file_reader* p_reader);
-int file_reader_read_trunk(_t_file_reader* p_reader);
+int file_reader_init(_t_file_reader *p_reader, FILE *file_fd, unsigned long read_buffer_size, void *prealloc_file_buffer);
+void file_reader_deinit(_t_file_reader *p_reader);
+void file_reader_reset(_t_file_reader *p_reader);
+int file_reader_read_trunk(_t_file_reader *p_reader);
 
-unsigned int get_next_frame(unsigned char* pstart, unsigned char* pend, unsigned char* p_nal_type, unsigned char* p_slice_type, unsigned char* need_more_data);
+unsigned int get_next_frame(unsigned char *pstart, unsigned char *pend, unsigned char *p_nal_type, unsigned char *p_slice_type, unsigned char *need_more_data);
 
-int build_fast_navi_tree(FILE* file_fd, fast_navi_file* navi_tree);
-void delete_fast_navi_tree(fast_navi_file* navi_tree);
+int build_fast_navi_tree(FILE *file_fd, fast_navi_file *navi_tree);
+void delete_fast_navi_tree(fast_navi_file *navi_tree);
 
diff --git a/iav_test/test_bsreader.c b/iav_test/test_bsreader.c
index e8477ec..a0c795d 100644
--- a/iav_test/test_bsreader.c
+++ b/iav_test/test_bsreader.c
@@ -11,12 +11,29 @@
  * History:
  *	2010/5/17 - [Louis Sun] create to use "bsreader" to get encoded streams
  *
- * Copyright (C) 2007-2008, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 #include <unistd.h>
@@ -418,7 +435,7 @@ int is_new_session(bs_info_t * bs_info)
 //check session and update file handle for write when needed
 int check_session_file_handle(bs_info_t *bs_info,  int new_session)
 {
-	char write_file_name[1024];
+	char write_file_name[1024], write_file_name2[1024];
 	char time_str[256];
 	int stream_id = bs_info->stream_id;
 	char stream_name;
@@ -449,14 +466,14 @@ int check_session_file_handle(bs_info_t *bs_info,  int new_session)
 		}
 
 		if (frame_info_flag) {
-			sprintf(write_file_name, "%s.info", write_file_name);
+			sprintf(write_file_name2, "%s.info", write_file_name);
 			if ((encoding_states[stream_id].fd_info =
-				amba_transfer_open(write_file_name, transfer_method, (transfer_port+stream_id*2+1))) < 0) {
-				printf("create file for frame info failed %s \n", write_file_name);
+				amba_transfer_open(write_file_name2, transfer_method, (transfer_port+stream_id*2+1))) < 0) {
+				printf("create file for frame info failed %s \n", write_file_name2);
 				return -1;
 			}
 			if (write_frame_info_header(stream_id) < 0) {
-				printf("write h264 header info file [%s] failed.\n", write_file_name);
+				printf("write h264 header info file [%s] failed.\n", write_file_name2);
 				return -1;
 			}
 		}
diff --git a/iav_test/test_decode.c b/iav_test/test_decode.c
index 2ae96e4..cbd61e5 100644
--- a/iav_test/test_decode.c
+++ b/iav_test/test_decode.c
@@ -4,12 +4,29 @@
  * History:
  *	2015/01/27 - [Zhi He] create file for s2l
  *
- * Copyright (C) 2015 -2020, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
@@ -45,6 +62,9 @@
 #define u_printf_debug printf
 
 static int test_decode_running = 1;
+static int test_decode_feed_bitstream_done = 0;
+static int test_decode_1xfw_playback = 0;
+static unsigned long test_decode_last_timestamp = 0;
 
 #define M_MSG_KILL	0
 
@@ -187,7 +207,6 @@ void msg_queue_wait(msg_queue_t *q)
 }
 
 #define DAMBA_GOP_HEADER_LENGTH 22
-//for deliemiter, eos, etc
 #define DAMBA_RESERVED_SPACE 32
 
 void _fill_amba_gop_header(u8 *p_gop_header, u32 frame_tick, u32 time_scale, u32 pts, u8 gopsize, u8 m)
@@ -324,6 +343,10 @@ typedef struct {
 	u8 is_fastnavi_mode;
 	u8 dump_input_bitstream;
 	u8 debug_read_direct_to_bsb;
+	u8 debug_frames_per_interrupt;
+
+	u16 daemon_pause_time;
+	u8 daemon;
 	u8 enable_cvbs;
 
 	u8 enable_digital;
@@ -331,7 +354,19 @@ typedef struct {
 	u8 vout_num;
 	u8 enter_idle_flag; //timer mode
 
-	u32 bsb_base;
+	u8 debug_use_dproc;
+	u8 debug_return_idle;
+	u8 reserved1;
+	u8 reserved2;
+
+	u32 max_bitrate;
+	u32 gop_size;
+	u32 framerate_den; //fps = 90000/framerate_den
+
+	u16 max_width;
+	u16 max_height;
+
+	u8 *bsb_base;
 	u32 bsb_size;
 
 	vout_device_info vout_dev_info[DIAV_MAX_DECODE_VOUT_NUMBER];
@@ -369,71 +404,6 @@ static void __print_vout_info(int iav_fd)
 	return;
 }
 
-#if 0
-static int __vout_get_sink_id(int chan, int sink_type, int iav_fd)
-{
-	int					num;
-	int					i;
-	struct amba_vout_sink_info		sink_info;
-
-	num = 0;
-	if (ioctl(iav_fd, IAV_IOC_VOUT_GET_SINK_NUM, &num) < 0) {
-		perror("IAV_IOC_VOUT_GET_SINK_NUM");
-		return -1;
-	}
-	if (num < 1) {
-		u_printf("Please load vout driver!\n");
-		return -2;
-	}
-
-	for (i = num - 1; i >= 0; i--) {
-		sink_info.id = i;
-		if (ioctl(iav_fd, IAV_IOC_VOUT_GET_SINK_INFO, &sink_info) < 0) {
-			perror("IAV_IOC_VOUT_GET_SINK_INFO");
-			return -3;
-		}
-
-		if ((sink_info.sink_type == sink_type) && (sink_info.source_id == chan)) {
-			u_printf("find sink_type %x, source id %d\n", sink_info.sink_type, sink_info.source_id);
-			return sink_info.id;
-		}
-	}
-
-	return (-4);
-}
-
-static int get_single_vout_info(int index, int type, vout_device_info* voutinfo, int iav_fd)
-{
-	struct amba_vout_sink_info info;
-
-	memset(&info, 0, sizeof(info));
-	info.id = __vout_get_sink_id(index, type, iav_fd);
-	if (info.id < 0) {
-		return -1;
-	}
-
-	if (ioctl(iav_fd, IAV_IOC_VOUT_GET_SINK_INFO, &info) < 0) {
-		perror("IAV_IOC_VOUT_GET_SINK_INFO");
-		return -1;
-	}
-
-	if (voutinfo) {
-		voutinfo->sink_id = info.id;
-		voutinfo->source_id = info.source_id;
-		voutinfo->sink_type = info.sink_type;
-
-		voutinfo->width = info.sink_mode.video_size.vout_width;
-		voutinfo->height = info.sink_mode.video_size.vout_height;
-		voutinfo->offset_x = info.sink_mode.video_offset.offset_x;
-		voutinfo->offset_y = info.sink_mode.video_offset.offset_y;
-		voutinfo->rotate = info.sink_mode.video_rotate;
-		voutinfo->flip = info.sink_mode.video_flip;
-	}
-
-	return 0;
-}
-#else
-
 static int get_single_vout_info(int chan, int sink_type, vout_device_info* voutinfo, int iav_fd)
 {
 	int	num;
@@ -457,7 +427,7 @@ static int get_single_vout_info(int chan, int sink_type, vout_device_info* vouti
 			return -3;
 		}
 
-		if ((sink_info.sink_type == sink_type) && (sink_info.source_id == chan)) {
+		if ((sink_info.state == AMBA_VOUT_SINK_STATE_RUNNING) && (sink_info.sink_type == sink_type) && (sink_info.source_id == chan)) {
 			u_printf("find sink_type %x, source id %d\n", sink_info.sink_type, sink_info.source_id);
 			if (voutinfo) {
 				voutinfo->sink_id = sink_info.id;
@@ -480,8 +450,6 @@ static int get_single_vout_info(int chan, int sink_type, vout_device_info* vouti
 	return (-4);
 }
 
-#endif
-
 unsigned char* _find_h264_sps_header(unsigned char* p, unsigned int len)
 {
 	while (len) {
@@ -518,22 +486,81 @@ static void _print_memory(u8* p, u32 size)
 }
 #endif
 
-static int enter_decode_mode(test_decode_context* context)
+static void __print_first_and_last_8bytes(u8* p, u8* p_end, u8* buf_start, u8* buf_end, u32 size)
+{
+	u32 size1 = 0, size2 = 0;
+	u8* ptmp = NULL;
+
+	if ((p + 7) < buf_end) {
+		u_printf("begin(size %d): %02x %02x %02x %02x, %02x %02x %02x %02x\n", size, p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);
+	} else {
+		size1 = buf_end - p;
+		size2 = 8 - size1;
+
+		ptmp = p;
+		u_printf("begin(size %d):", size);
+		while (size1) {
+			u_printf(" %02x", ptmp[0]);
+			ptmp ++;
+			size1 --;
+		}
+
+		ptmp = buf_start;
+		while (size2) {
+			u_printf(" %02x", ptmp[0]);
+			ptmp ++;
+			size2 --;
+		}
+		u_printf("\n");
+	}
+
+	if (p_end > (buf_start + 7)) {
+		u_printf("end: %02x %02x %02x %02x, %02x %02x %02x %02x\n", p_end[-8], p_end[-7], p_end[-6], p_end[-5], p_end[-4], p_end[-3], p_end[-2], p_end[-1]);
+	} else {
+		size1 = p_end - buf_start;
+		size2 = 8 - size1;
+
+		ptmp = buf_end - size2;
+		u_printf("end:");
+		while (size2) {
+			u_printf(" %02x", ptmp[0]);
+			ptmp ++;
+			size2 --;
+		}
+
+		ptmp = buf_start;
+		while (size1) {
+			u_printf(" %02x", ptmp[0]);
+			ptmp ++;
+			size1 --;
+		}
+		u_printf("\n");
+	}
+
+}
+
+static int enter_decode_mode(test_decode_context* context, u16 max_width, u16 max_height, u32 max_bitrate, u8 support_ff_fb_bw, u8 use_dproc)
 {
 	struct iav_decode_mode_config *decode_mode = &context->mode_config;
 
 	decode_mode->num_decoder = 1;
-	decode_mode->decoder_configs[0].max_frm_num = 6;
-	decode_mode->decoder_configs[0].max_frm_width = 1920;
-	decode_mode->decoder_configs[0].max_frm_height = 1080;
+	decode_mode->debug_max_frame_per_interrupt = context->debug_frames_per_interrupt;
+	decode_mode->debug_use_dproc = use_dproc;
+	decode_mode->b_support_ff_fb_bw = support_ff_fb_bw;
+	decode_mode->max_frm_width = max_width;
+	decode_mode->max_frm_height = max_height;
 
-	u_printf("[flow]: before IAV_IOC_ENTER_DECODE_MODE\n");
+	u_printf("[flow]: before IAV_IOC_ENTER_DECODE_MODE, max_width %d, max_height %d, max_bitrate %d Mbps, support fast fwbw %d\n", max_width, max_height, max_bitrate, support_ff_fb_bw);
 	if (ioctl(context->iav_fd, IAV_IOC_ENTER_DECODE_MODE, decode_mode) < 0) {
-		perror("IAV_IOC_ENTER_UDEC_MODE");
-		u_printf("[error]: enter udec mode fail\n");
+		perror("IAV_IOC_ENTER_DECODE_MODE");
+		u_printf("[error]: enter decode mode fail\n");
 		return (-1);
 	}
 
+	if (decode_mode->debug_max_frame_per_interrupt) {
+		u_printf("[debug config]: max frames per interrupt %d\n", decode_mode->debug_max_frame_per_interrupt);
+	}
+
 	return 0;
 }
 
@@ -542,7 +569,7 @@ static int leave_decode_mode(test_decode_context* context)
 	u_printf("[flow]: before IAV_IOC_LEAVE_DECODE_MODE\n");
 	if (ioctl(context->iav_fd, IAV_IOC_LEAVE_DECODE_MODE) < 0) {
 		perror("IAV_IOC_LEAVE_DECODE_MODE");
-		u_printf("[error]: leave udec mode fail\n");
+		u_printf("[error]: leave decode mode fail\n");
 		return (-1);
 	}
 
@@ -595,8 +622,8 @@ static void __open_dump_file(test_decoder_instance_context* instance_content, co
 		instance_content->p_dump_input_file = NULL;
 	}
 
-	char dump_filename[DMAX_TEST_FILE_NAME_LENGTH] = {0};
-	snprintf(dump_filename, DMAX_TEST_FILE_NAME_LENGTH, "%s_%04d.%s", instance_content->filename, instance_content->trickplay_index, file_tail);
+	char dump_filename[DMAX_TEST_FILE_NAME_LENGTH + 128] = {0};
+	snprintf(dump_filename, sizeof(dump_filename), "%s_%08x.%s", instance_content->filename, instance_content->trickplay_index, file_tail);
 	instance_content->trickplay_index ++;
 
 	instance_content->p_dump_input_file = fopen(dump_filename, "wb+");
@@ -669,8 +696,8 @@ static int create_decoder(test_decode_context* context, u8 decoder_id, u8 decode
 		return (-4);
 	}
 
-	decoder_context->p_bsb_start = (u8*) context->bsb_base + decode_info->bsb_start_offset;
-	decoder_context->p_bsb_end = (u8*) decoder_context->p_bsb_start + decode_info->bsb_size;
+	decoder_context->p_bsb_start = context->bsb_base + decode_info->bsb_start_offset;
+	decoder_context->p_bsb_end = decoder_context->p_bsb_start + decode_info->bsb_size;
 
 	u_printf("[debug], create_decoder done: p_bsb_start %p, p_bsb_end %p, bsb_size %d\n", decoder_context->p_bsb_start, decoder_context->p_bsb_end, decode_info->bsb_size);
 
@@ -716,6 +743,25 @@ static void _print_ut_options()
 
 	u_printf("\t'--help': print help\n\n");
 	u_printf("\t'--idle': will enter idle state\n");
+	//u_printf("\t'--daemon': will run as daemon, no user interact from stdin for this mode\n");
+	u_printf("\t'--pausetime %%d': will pause for debug, after %%d seconds, for daemon mode only\n");
+
+	u_printf("\t'--cvbs': will use cvbs output\n");
+	u_printf("\t'--hdmi': will use HDMI output\n");
+	u_printf("\t'--digital': will use digital (LCD) output\n");
+
+	u_printf("\t'--returnidle': return idle mode for DSP after playback\n");
+	u_printf("\t'--notreturnidle': not return idle mode for DSP after playback, keep playback mode\n");
+
+	u_printf("\t'--fastnavi': will enable fast fw/bw and backwarrd playabck, with this mode, DSP will need more dram space\n");
+
+	u_printf("\t'--maxwidth %%d': specify max video wdith\n");
+	u_printf("\t'--maxheight %%d': specify max video height\n");
+	u_printf("\t'--maxbitrate %%d': specify max bitrate\n");
+	u_printf("\t'--gopsize %%d': specify gopsize\n");
+	u_printf("\t'--frden %%d': specify framerate den, FPS = 90000/frden, for example, frden = 3003, FPS = 90000/3003 = 29.97\n");
+	u_printf("\t'--prefetch %%d': prefetch %%d frames before start decode\n");
+	u_printf("\t'--frameperinterrupt %%d': specify max frames per DSP interrupt\n");
 }
 
 static void _print_ut_cmds()
@@ -731,11 +777,15 @@ static void _print_ut_cmds()
 static int init_test_decode_params(int argc, char **argv, test_decode_context* context)
 {
 	int i = 0;
+	int ret = 0;
 
 	for (i = 1; i < argc; i++) {
 		if (!strcmp("--idle", argv[i])) {
 			context->enter_idle_flag = 1;
 			u_printf("[input argument] --idle, enter idle.\n");
+		} else if (!strcmp("--daemon", argv[i])) {
+			context->daemon = 1;
+			u_printf("[input argument] --daemon, run as daemon.\n");
 		} else if (!strcmp("--fastnavi", argv[i])) {
 			context->is_fastnavi_mode = 1;
 			u_printf("[input argument] --fastnavi, fast navi, build navigation tree first.\n");
@@ -754,9 +804,80 @@ static int init_test_decode_params(int argc, char **argv, test_decode_context* c
 		} else if (!strcmp("--hdmi", argv[i])) {
 			context->enable_hdmi = 1;
 			u_printf("[input argument] --hdmi, try hdmi output.\n");
+		} else if (!strcmp("--returnidle", argv[i])) {
+			context->debug_return_idle = 1;
+			u_printf("[input argument] --returnidle, return idle after playabck.\n");
+		} else if (!strcmp("--notreturnidle", argv[i])) {
+			context->debug_return_idle = 0;
+			u_printf("[input argument] --notreturnidle, keep playback mode after playabck.\n");
+		} else if (!strcmp("--prefetch", argv[i])) {
+			if (((i + 1) < argc) && (1 == sscanf(argv[i + 1], "%d", &ret))) {
+				u_printf("[input argument] --prefetch, %d.\n", ret);
+				context->prefetch_count = ret;
+				context->enable_prefetch = 1;
+				i ++;
+			} else {
+				u_printf("'error: [input argument] --prefetch should follow prefetch frame count (integer)'\n");
+			}
+		} else if (!strcmp("--pausetime", argv[i])) {
+			if (((i + 1) < argc) && (1 == sscanf(argv[i + 1], "%d", &ret))) {
+				u_printf("[input argument] --pausetime, %d.\n", ret);
+				context->daemon_pause_time = ret;
+				i ++;
+			} else {
+				u_printf("'error: [input argument] --pausetime should follow pause time (seconds), daemon mode only'\n");
+			}
+		} else if (!strcmp("--maxwidth", argv[i])) {
+			if (((i + 1) < argc) && (1 == sscanf(argv[i + 1], "%d", &ret))) {
+				u_printf("[input argument] --maxwidth, %d.\n", ret);
+				context->max_width = ret;
+				i ++;
+			} else {
+				u_printf("'error: [input argument] --maxwidth should follow width (integer)'\n");
+			}
+		} else if (!strcmp("--maxheight", argv[i])) {
+			if (((i + 1) < argc) && (1 == sscanf(argv[i + 1], "%d", &ret))) {
+				u_printf("[input argument] --maxheight, %d.\n", ret);
+				context->max_height = ret;
+				i ++;
+			} else {
+				u_printf("'error: [input argument] --maxheight should follow height (integer)'\n");
+			}
+		} else if (!strcmp("--maxbitrate", argv[i])) {
+			if (((i + 1) < argc) && (1 == sscanf(argv[i + 1], "%d", &ret))) {
+				u_printf("[input argument] --maxbirate, %d.\n", ret);
+				context->max_bitrate = ret;
+				i ++;
+			} else {
+				u_printf("'error: [input argument] --maxbitrate should follow bitrate (integer)'\n");
+			}
+		} else if (!strcmp("--gopsize", argv[i])) {
+			if (((i + 1) < argc) && (1 == sscanf(argv[i + 1], "%d", &ret))) {
+				u_printf("[input argument] --gopsize, %d.\n", ret);
+				context->gop_size = ret;
+				i ++;
+			} else {
+				u_printf("'error: [input argument] --maxgopsize should follow gopsize (integer)'\n");
+			}
+		} else if (!strcmp("--frden", argv[i])) {
+			if (((i + 1) < argc) && (1 == sscanf(argv[i + 1], "%d", &ret))) {
+				u_printf("[input argument] --frden, %d.\n", ret);
+				context->framerate_den = ret;
+				i ++;
+			} else {
+				u_printf("'error: [input argument] --frden should follow framerate den (integer)'\n");
+			}
 		} else if (!strcmp("--debuglog", argv[i])) {
 			context->enable_debug_log = 1;
 			u_printf("[input argument] --debuglog, enable debug log.\n");
+		} else if (!strcmp("--frameperinterrupt", argv[i])) {
+			if (((i + 1) < argc) && (1 == sscanf(argv[i + 1], "%d", &ret))) {
+				u_printf("[input argument] --frameperinterrupt, %d.\n", ret);
+				context->debug_frames_per_interrupt = ret;
+				i ++;
+			} else {
+				u_printf("'error: [input argument] --frameperinterrupt should follow frames number (integer)'\n");
+			}
 		} else if (!strcmp("--help", argv[i])) {
 			_print_ut_options();
 			_print_ut_cmds();
@@ -858,7 +979,7 @@ static int ioctl_decode_stop(int iav_fd, u8 decoder_id, u8 stop_flag)
 
 	ret = ioctl(iav_fd, IAV_IOC_DECODE_STOP, &stop);
 	if (ret < 0) {
-		perror("IAV_IOC_UDEC_STOP");
+		perror("IAV_IOC_DECODE_STOP");
 		return ret;
 	}
 
@@ -972,13 +1093,13 @@ static int map_bitstream_buffer(test_decode_context* context)
 	}
 
 	context->bsb_size = querybuf.length;
-	context->bsb_base = (u32) mmap(NULL, context->bsb_size, PROT_WRITE, MAP_SHARED, context->iav_fd, querybuf.offset);
-	if (context->bsb_base == (u32) MAP_FAILED) {
-		perror("mmap (%d) failed: %s\n");
+	context->bsb_base = (u8 *) mmap(NULL, (size_t) context->bsb_size, PROT_WRITE, MAP_SHARED, context->iav_fd, (size_t) querybuf.offset);
+	if (context->bsb_base == MAP_FAILED) {
+		perror("mmap failed\n");
 		return -1;
 	}
 
-	u_printf("bsb_mem = 0x%x, size = 0x%x\n", (u32)context->bsb_base, context->bsb_size);
+	u_printf("bsb_mem = %p, size = %d\n", context->bsb_base, context->bsb_size);
 	return 0;
 }
 
@@ -987,29 +1108,44 @@ static void test_decode_sig_stop(int a)
 	test_decode_running = 0;
 }
 
+static int __get_current_timestamp(int iav_fd, u8 id, unsigned long *timestamp)
+{
+	struct iav_decode_status status;
+	int ret = 0;
+
+	memset(&status, 0x0, sizeof(status));
+	status.decoder_id = id;
+
+	ret = ioctl(iav_fd, IAV_IOC_QUERY_DECODE_STATUS, &status);
+	if (ret < 0) {
+		u_printf_error("error: IAV_IOC_QUERY_DECODE_STATUS fail, ret %d\n", ret);
+		perror("IAV_IOC_QUERY_DECODE_STATUS");
+		return ret;
+	}
+
+	*timestamp = status.last_pts;
+	return 0;
+}
+
 static void* decoder_instance_h264_es_file(void* param)
 {
 	test_decoder_instance_context* instance_content = (test_decoder_instance_context*) param;
-
 	test_decode_context* context = (test_decode_context*) instance_content->parent;
-
 	int ret = 0;
 	u32 sendsize = 0;
-
 	u8 *p_frame_start = NULL;
 	u8 *p_bsb_cur = instance_content->p_bsb_start;
-
 	u8 nal_type, slice_type, need_more_data, wait_next_key_frame = 0;
 	u8 file_eos = 0;
-
 	u32 target_prefetch_count = context->prefetch_count;
-
 	u32 current_prefetch_count = 0;
 	u32 in_prefetching = context->enable_prefetch;
-
 	u8* p_prefetching = NULL;
-
 	msg_t msg;
+	u32 frame_index = 0;
+	u32 last_pts = 0;
+
+	u8 amba_gop_header[DAMBA_GOP_HEADER_LENGTH] = {0};
 
 	_t_file_reader file_reader;
 	memset(&file_reader, 0x0, sizeof(file_reader));
@@ -1025,6 +1161,11 @@ static void* decoder_instance_h264_es_file(void* param)
 	file_reader_read_trunk(&file_reader);
 	p_bsb_cur = instance_content->p_bsb_start;
 
+	u_printf("[flow]: decoder_instance_h264_es_file begin, gopsize = %d, framerate den %d\n", context->gop_size, context->framerate_den);
+
+	_fill_amba_gop_header(amba_gop_header, context->framerate_den, 90000, 0, context->gop_size, 1);
+	frame_index = 0;
+
 	while (1) {
 
 		if (msg_queue_peek(&instance_content->cmd_queue, &msg)) {
@@ -1039,9 +1180,14 @@ static void* decoder_instance_h264_es_file(void* param)
 
 		if (!sendsize && need_more_data) {
 			if (!file_reader.file_remainning_size) {
-				u_printf("[flow]: file end, feed last frame\n");
 				sendsize = file_reader.p_read_buffer_cur_end - file_reader.p_read_buffer_cur_start;
 				file_eos = 1;
+				if (sendsize <= 6) {
+					u_printf("warning, discard last incomplete frame, size %d\n", sendsize);
+					break;
+				} else {
+					u_printf("[flow]: file end, feed last frame\n");
+				}
 			} else {
 				file_reader_read_trunk(&file_reader);
 				continue;
@@ -1053,6 +1199,11 @@ static void* decoder_instance_h264_es_file(void* param)
 			continue;
 		}
 
+		if (context->enable_debug_log) {
+			u_printf("frame index %d, nal type %d, slice type %d\n", frame_index, nal_type, slice_type);
+			//u_printf("sendsize %d, need_more_data %d\n", sendsize, need_more_data);
+		}
+
 		wait_next_key_frame = 0;
 		p_frame_start = p_bsb_cur;
 		//wrap case
@@ -1060,16 +1211,33 @@ static void* decoder_instance_h264_es_file(void* param)
 			p_frame_start = instance_content->p_bsb_start;
 		}
 
-		//printf("[loop flow]: before request_bits_fifo, sendsize %d\n", sendsize);
-		ret = request_bits_fifo(context->iav_fd, instance_content->index, sendsize, p_frame_start - instance_content->p_bsb_start);
-		//printf("[loop flow]: after request_bits_fifo\n");
+		if (5 == nal_type) {
+			//printf("key frame + gop header size %d\n", sendsize + DAMBA_GOP_HEADER_LENGTH);
+			ret = request_bits_fifo(context->iav_fd, instance_content->index, sendsize + DAMBA_GOP_HEADER_LENGTH + DAMBA_RESERVED_SPACE, p_frame_start - instance_content->p_bsb_start);
+			//printf("[loop flow]: after request_bits_fifo\n");
 
-		if (ret < 0) {
-			u_printf("[error]: request_bits_fifo() fail, ret %d\n", ret);
-			break;
+			if (ret < 0) {
+				u_printf("[error]: request_bits_fifo() fail, ret %d\n", ret);
+				break;
+			}
+
+			//printf("[debug], before copy_to_bsb, sendsize %d\n", sendsize);
+			_update_amba_gop_header(amba_gop_header, (u32) (3003 * frame_index));
+			p_bsb_cur = copy_to_bsb(p_bsb_cur, amba_gop_header, DAMBA_GOP_HEADER_LENGTH, instance_content->p_bsb_start, instance_content->p_bsb_end);
+		} else {
+			//printf("non-key frame size %d\n", sendsize);
+			ret = request_bits_fifo(context->iav_fd, instance_content->index, sendsize + DAMBA_RESERVED_SPACE, p_frame_start - instance_content->p_bsb_start);
+			//printf("[loop flow]: after request_bits_fifo\n");
+
+			if (ret < 0) {
+				u_printf("[error]: request_bits_fifo() fail, ret %d\n", ret);
+				break;
+			}
 		}
 
-		//printf("[debug], before copy_to_bsb, sendsize %d\n", sendsize);
+		last_pts = 3003 * frame_index;
+		frame_index ++;
+
 		p_bsb_cur = copy_to_bsb(p_bsb_cur, file_reader.p_read_buffer_cur_start, sendsize, instance_content->p_bsb_start, instance_content->p_bsb_end);
 		//printf("[debug], after copy_to_bsb\n");
 		file_reader.p_read_buffer_cur_start += sendsize;
@@ -1096,10 +1264,13 @@ static void* decoder_instance_h264_es_file(void* param)
 				decode_video.end_ptr_offset = p_bsb_cur - instance_content->p_bsb_start;
 
 				if ((ret = ioctl(context->iav_fd, IAV_IOC_DECODE_VIDEO, &decode_video)) < 0) {
-					u_printf_error("[ioctl error]: (udec_id %d) IAV_IOC_DECODE_VIDEO ret %d, exit loop\n", instance_content->index, ret);
+					u_printf_error("[ioctl error]: (decoder %d) IAV_IOC_DECODE_VIDEO ret %d, exit loop\n", instance_content->index, ret);
 					ret = -11;
 					break;
 				}
+				if (instance_content->p_dump_input_file) {
+					write_bsb_data(instance_content->p_dump_input_file, p_prefetching, p_bsb_cur, instance_content->p_bsb_start, instance_content->p_bsb_end);
+				}
 			}
 		} else {
 			struct iav_decode_video decode_video;
@@ -1110,14 +1281,26 @@ static void* decoder_instance_h264_es_file(void* param)
 			decode_video.start_ptr_offset = p_frame_start - instance_content->p_bsb_start;
 			decode_video.end_ptr_offset = p_bsb_cur - instance_content->p_bsb_start;
 
-			//printf("[loop flow]: before IAV_IOC_DECODE_VIDEO\n");
 			if ((ret = ioctl(context->iav_fd, IAV_IOC_DECODE_VIDEO, &decode_video)) < 0) {
-				u_printf_error("[ioctl error]: (udec_id %d) IAV_IOC_DECODE_VIDEO ret %d, exit loop\n", instance_content->index, ret);
+				u_printf_error("[ioctl error]: (decoder %d) IAV_IOC_DECODE_VIDEO ret %d, exit loop\n", instance_content->index, ret);
 				ret = -11;
 				break;
 			}
 			//printf("[loop flow]: after IAV_IOC_DECODE_VIDEO\n");
 
+			if (context->enable_debug_log) {
+				u32 data_size = 0;
+				if (p_bsb_cur > p_frame_start) {
+					data_size = (u32) (p_bsb_cur - p_frame_start);
+				} else {
+					data_size = (u32) (instance_content->p_bsb_end - p_frame_start) + (u32) (p_bsb_cur - instance_content->p_bsb_start);
+				}
+				__print_first_and_last_8bytes((u8*)p_frame_start, (u8*)p_bsb_cur, instance_content->p_bsb_start, instance_content->p_bsb_end, data_size);
+			}
+
+			if (instance_content->p_dump_input_file) {
+				write_bsb_data(instance_content->p_dump_input_file, p_frame_start, p_bsb_cur, instance_content->p_bsb_start, instance_content->p_bsb_end);
+			}
 		}
 
 		if (file_eos) {
@@ -1129,8 +1312,9 @@ static void* decoder_instance_h264_es_file(void* param)
 	}
 
 	file_reader_deinit(&file_reader);
-	u_printf("[feeding flow]: decoder_instance_h264_es_file end\n");
-	test_decode_running = 0;
+	test_decode_last_timestamp = last_pts;
+	test_decode_feed_bitstream_done = 1;
+	u_printf("[feeding flow]: decoder_instance_h264_es_file end, last timestamp %ld\n", test_decode_last_timestamp);
 
 	return NULL;
 }
@@ -1293,8 +1477,6 @@ static void* decoder_instance_h264_es_file_fast_navi(void* param)
 	msg_t msg;
 	int running = 1;
 	u8 h264_eos[] = {0x00, 0x00, 0x00, 0x01, 0x0A};
-	//u8 h264_delimiter_gop[] = {0x00, 0x00, 0x00, 0x01, 0x09, 0x10};
-	//u8 h264_delimiter_frame[] = {0x00, 0x00, 0x00, 0x01, 0x09, 0x30};
 
 	u32 gopsize = 15;
 	if (instance_content->fast_navi.gop_list_header.p_next) {
@@ -1302,9 +1484,9 @@ static void* decoder_instance_h264_es_file_fast_navi(void* param)
 			gopsize = instance_content->fast_navi.gop_list_header.p_next->frame_count;
 		}
 	}
-	u_printf("[flow]: decoder_instance_h264_es_file_fast_navi begin, gopsize = %d\n", gopsize);
+	u_printf("[flow]: decoder_instance_h264_es_file_fast_navi begin, gopsize = %d, framerate den %d\n", gopsize, context->framerate_den);
 
-	_fill_amba_gop_header(amba_gop_header, 3003, 90000, 0, gopsize, 1);// hard code to 29.97 fps
+	_fill_amba_gop_header(amba_gop_header, context->framerate_den, 90000, 0, gopsize, 1);// hard code to 29.97 fps
 
 	while (running) {
 
@@ -1360,7 +1542,6 @@ static void* decoder_instance_h264_es_file_fast_navi(void* param)
 							cur_file_offset = p_gop->gop_offset + sendsize;
 							p_bit_end = p_bsb_cur = copy_to_bsb(p_bsb_cur, p_file_read_buffer, sendsize, instance_content->p_bsb_start, instance_content->p_bsb_end);
 						}
-						//p_bsb_cur = copy_to_bsb(p_bsb_cur, h264_delimiter_gop, sizeof(h264_delimiter_gop), instance_content->p_bsb_start, instance_content->p_bsb_end);
 
 						decode_video.decoder_id = instance_content->index;
 						decode_video.num_frames = p_gop->frame_count;
@@ -1384,7 +1565,7 @@ static void* decoder_instance_h264_es_file_fast_navi(void* param)
 #endif
 
 						if ((ret = ioctl(context->iav_fd, IAV_IOC_DECODE_VIDEO, &decode_video)) < 0) {
-							u_printf_error("[ioctl error]: (udec_id %d) IAV_IOC_DECODE_VIDEO ret %d, exit loop\n", instance_content->index, ret);
+							u_printf_error("[ioctl error]: (decoder %d) IAV_IOC_DECODE_VIDEO ret %d, exit loop\n", instance_content->index, ret);
 							instance_content->navi_mode = PLAYBACK_ERROR;
 							running = 0;
 							break;
@@ -1444,7 +1625,6 @@ static void* decoder_instance_h264_es_file_fast_navi(void* param)
 							cur_file_offset = p_gop->gop_offset + sendsize;
 							p_bit_end = p_bsb_cur = copy_to_bsb(p_bsb_cur, p_file_read_buffer, sendsize, instance_content->p_bsb_start, instance_content->p_bsb_end);
 						}
-						//p_bsb_cur = copy_to_bsb(p_bsb_cur, h264_delimiter_frame, sizeof(h264_delimiter_frame), instance_content->p_bsb_start, instance_content->p_bsb_end);
 
 						if (instance_content->p_dump_input_file) {
 							write_bsb_data(instance_content->p_dump_input_file, p_bit_start, p_bit_end, instance_content->p_bsb_start, instance_content->p_bsb_end);
@@ -1468,7 +1648,7 @@ static void* decoder_instance_h264_es_file_fast_navi(void* param)
 #endif
 
 						if ((ret = ioctl(context->iav_fd, IAV_IOC_DECODE_VIDEO, &decode_video)) < 0) {
-							u_printf_error("[ioctl error]: (udec_id %d) IAV_IOC_DECODE_VIDEO ret %d, exit loop\n", instance_content->index, ret);
+							u_printf_error("[ioctl error]: (decoder %d) IAV_IOC_DECODE_VIDEO ret %d, exit loop\n", instance_content->index, ret);
 							instance_content->navi_mode = PLAYBACK_ERROR;
 							running = 0;
 							break;
@@ -1559,7 +1739,7 @@ static void* decoder_instance_h264_es_file_fast_navi(void* param)
 #endif
 
 						if ((ret = ioctl(context->iav_fd, IAV_IOC_DECODE_VIDEO, &decode_video)) < 0) {
-							u_printf_error("[ioctl error]: (udec_id %d) IAV_IOC_DECODE_VIDEO ret %d, exit loop\n", instance_content->index, ret);
+							u_printf_error("[ioctl error]: (decoder %d) IAV_IOC_DECODE_VIDEO ret %d, exit loop\n", instance_content->index, ret);
 							instance_content->navi_mode = PLAYBACK_ERROR;
 							running = 0;
 							break;
@@ -1643,7 +1823,7 @@ static void* decoder_instance_h264_es_file_fast_navi(void* param)
 #endif
 
 						if ((ret = ioctl(context->iav_fd, IAV_IOC_DECODE_VIDEO, &decode_video)) < 0) {
-							u_printf_error("[ioctl error]: (udec_id %d) IAV_IOC_DECODE_VIDEO ret %d, exit loop\n", instance_content->index, ret);
+							u_printf_error("[ioctl error]: (decoder %d) IAV_IOC_DECODE_VIDEO ret %d, exit loop\n", instance_content->index, ret);
 							instance_content->navi_mode = PLAYBACK_ERROR;
 							running = 0;
 							break;
@@ -1691,20 +1871,23 @@ static void* decoder_instance_h264_es_file_fast_navi(void* param)
 
 static int test_decode(test_decode_context* context)
 {
+	unsigned long cur_timestamp = 0;
+	unsigned long repeat_timestamp = 0;
+	unsigned int repeat_times = 0;
 	unsigned int i;
-
 	msg_t msg;
-	char buffer_old[128] = {0};
-	char buffer[128];
-	char* p_buffer = buffer;
 	void* pv;
 	int ret = 0;
 
-	ret = enter_decode_mode(context);
+	//disable fast fw, fast bw and backward playback
+	u_printf("[config]: max width %d, max height %d, max bitrate %d, disable fast fw/bw and backward playabck\n", context->max_width, context->max_height, context->max_bitrate);
+	ret = enter_decode_mode(context, context->max_width, context->max_height, context->max_bitrate, 0, 0);
 	if (0 > ret) {
 		return ret;
 	}
 
+	test_decode_1xfw_playback = 1;
+
 	for (i = 0; i < MAX_NUM_DECODER; i++) {
 		ret = create_decoder(context, i, IAV_DECODER_TYPE_H264);
 		if (0 > ret) {
@@ -1737,64 +1920,116 @@ static int test_decode(test_decode_context* context)
 		}
 	}
 
-	memset(buffer, 0x0, sizeof(buffer));
-	memset(buffer_old, 0x0, sizeof(buffer_old));
 
-	int flag_stdin = 0;
-	flag_stdin = fcntl(STDIN_FILENO, F_GETFL);
-	if (fcntl(STDIN_FILENO, F_SETFL, fcntl(STDIN_FILENO,F_GETFL) | O_NONBLOCK) == -1) {
-		u_printf("[error]: stdin_fileno set error.\n");
-	}
+	if (context->daemon) {
+		daemon(1, 0);
+		u32 wait_times = 10 * context->daemon_pause_time;
+		while (test_decode_running) {
+			usleep(100000);
+			if (context->daemon_pause_time) {
+				if (0 == wait_times) {
+					printf("pause at daemon mode\n");
+					context->decoder[0].current_trickplay = IAV_TRICK_PLAY_PAUSE;
+					ioctl_decode_trick_play(context->iav_fd, 0, IAV_TRICK_PLAY_PAUSE);
+				} else {
+					wait_times --;
+				}
+			}
+		}
+	} else {
+		char buffer_old[128] = {0};
+		char buffer[128];
+		char* p_buffer = buffer;
 
-	while (test_decode_running) {
-		usleep(100000);
 		memset(buffer, 0x0, sizeof(buffer));
-		if (read(STDIN_FILENO, buffer, sizeof(buffer)) < 0) {
-			continue;
-		}
+		memset(buffer_old, 0x0, sizeof(buffer_old));
 
-		if (buffer[0] == '\n') {
-			p_buffer = buffer_old;
-			u_printf("repeat last cmd:\n\t\t%s\n", buffer_old);
-		} else if (buffer[0] == 'l') {
-			u_printf("show last cmd:\n\t\t%s\n", buffer_old);
-			continue;
-		} else {
-			p_buffer = buffer;
-			//record last cmd
-			strncpy(buffer_old, buffer, sizeof(buffer_old) -1);
-			buffer_old[sizeof(buffer_old) -1] = 0x0;
+		int flag_stdin = 0;
+		flag_stdin = fcntl(STDIN_FILENO, F_GETFL);
+		if (fcntl(STDIN_FILENO, F_SETFL, fcntl(STDIN_FILENO,F_GETFL) | O_NONBLOCK) == -1) {
+			u_printf("[error]: stdin_fileno set error.\n");
 		}
 
-		if ('q' == p_buffer[0]) {
-			u_printf("Quit, 'q'\n");
-			test_decode_running = 0;
-		} else if ('p' == p_buffer[0]) {
-			if (0) {
-				query_bsb_and_print(context->iav_fd, 0);
-			} else {
-				query_decode_status_and_print(context->iav_fd, 0);
+		while (test_decode_running) {
+			usleep(100000);
+
+			memset(buffer, 0x0, sizeof(buffer));
+			if (read(STDIN_FILENO, buffer, sizeof(buffer)) < 0) {
+
+				//check if last frame is displayed
+				if (test_decode_feed_bitstream_done && test_decode_1xfw_playback) {
+					ret = __get_current_timestamp(context->iav_fd, 0, &cur_timestamp);
+					if (ret) {
+						test_decode_running = 0;
+						break;
+					}
+					if (((cur_timestamp + 6600) > test_decode_last_timestamp) && (cur_timestamp < (test_decode_last_timestamp + 6600))) {
+						u_printf("receive last time stamp %ld, target %ld\n", cur_timestamp, test_decode_last_timestamp);
+						test_decode_running = 0;
+						break;
+					}
+					if (repeat_timestamp == cur_timestamp) {
+						if (repeat_times > 1) {
+							u_printf("receive repeat timestamp, last %ld, target %ld, gap %ld\n", cur_timestamp, test_decode_last_timestamp, test_decode_last_timestamp - cur_timestamp);
+							test_decode_running = 0;
+							break;
+						}
+						repeat_times ++;
+					} else {
+						repeat_times = 0;
+					}
+					repeat_timestamp = cur_timestamp;
+				}
+
+				continue;
 			}
-		} else if (' ' == p_buffer[0]) {
-			if (IAV_TRICK_PLAY_RESUME == context->decoder[0].current_trickplay) {
-				context->decoder[0].current_trickplay = IAV_TRICK_PLAY_PAUSE;
-				ioctl_decode_trick_play(context->iav_fd, 0, IAV_TRICK_PLAY_PAUSE);
+
+			if (buffer[0] == '\n') {
+				p_buffer = buffer_old;
+				u_printf("repeat last cmd:\n\t\t%s\n", buffer_old);
+			} else if (buffer[0] == 'l') {
+				u_printf("show last cmd:\n\t\t%s\n", buffer_old);
+				continue;
 			} else {
-				context->decoder[0].current_trickplay = IAV_TRICK_PLAY_RESUME;
-				ioctl_decode_trick_play(context->iav_fd, 0, IAV_TRICK_PLAY_RESUME);
+				p_buffer = buffer;
+				//record last cmd
+				strncpy(buffer_old, buffer, sizeof(buffer_old) -1);
+				buffer_old[sizeof(buffer_old) -1] = 0x0;
+			}
+
+			if ('q' == p_buffer[0]) {
+				u_printf("Quit, 'q'\n");
+				test_decode_running = 0;
+			} else if ('p' == p_buffer[0]) {
+				if (0) {
+					query_bsb_and_print(context->iav_fd, 0);
+				} else {
+					query_decode_status_and_print(context->iav_fd, 0);
+				}
+			} else if (' ' == p_buffer[0]) {
+				if (IAV_TRICK_PLAY_RESUME == context->decoder[0].current_trickplay) {
+					context->decoder[0].current_trickplay = IAV_TRICK_PLAY_PAUSE;
+					ioctl_decode_trick_play(context->iav_fd, 0, IAV_TRICK_PLAY_PAUSE);
+					test_decode_1xfw_playback = 0;
+				} else {
+					context->decoder[0].current_trickplay = IAV_TRICK_PLAY_RESUME;
+					ioctl_decode_trick_play(context->iav_fd, 0, IAV_TRICK_PLAY_RESUME);
+					test_decode_1xfw_playback = 1;
+				}
+			} else if ('s' == p_buffer[0]) {
+				context->decoder[0].current_trickplay = IAV_TRICK_PLAY_STEP;
+				ioctl_decode_trick_play(context->iav_fd, 0, IAV_TRICK_PLAY_STEP);
+				test_decode_1xfw_playback = 0;
+			} else if ('f' == p_buffer[0]) {
+				u_printf("not support fast navigation, you need add '--fastnavi'\n");
+			} else if ('b' == p_buffer[0]) {
+				u_printf("not support fast navigation, you need add '--fastnavi'\n");
 			}
-		} else if ('s' == p_buffer[0]) {
-			context->decoder[0].current_trickplay = IAV_TRICK_PLAY_STEP;
-			ioctl_decode_trick_play(context->iav_fd, 0, IAV_TRICK_PLAY_STEP);
-		} else if ('f' == p_buffer[0]) {
-			u_printf("not support fast navigation, you need add '--fastnavi'\n");
-		} else if ('b' == p_buffer[0]) {
-			u_printf("not support fast navigation, you need add '--fastnavi'\n");
 		}
-	}
 
-	if (fcntl(STDIN_FILENO, F_SETFL, flag_stdin) == -1) {
-		u_printf("[error]: stdin_fileno set error");
+		if (fcntl(STDIN_FILENO, F_SETFL, flag_stdin) == -1) {
+			u_printf("[error]: stdin_fileno set error");
+		}
 	}
 
 	u_printf("[flow]: start exit\n");
@@ -1819,8 +2054,10 @@ _test_decode_fail_:
 		ret = destroy_decoder(context, (u8) i);
 	}
 
-	leave_decode_mode(context);
-	u_printf("[flow]: after leave decode mode\n");
+	if (context->debug_return_idle) {
+		leave_decode_mode(context);
+		u_printf("[flow]: after leave decode mode\n");
+	}
 
 	return ret;
 }
@@ -1828,15 +2065,12 @@ _test_decode_fail_:
 static int test_decode_fast_navi(test_decode_context* context)
 {
 	unsigned int i;
-
 	msg_t msg;
-	char buffer_old[128] = {0};
-	char buffer[128];
-	char* p_buffer = buffer;
 	void* pv;
 	int ret = 0;
 
-	ret = enter_decode_mode(context);
+	u_printf("[config]: max width %d, max height %d, max bitrate %d, enable fast fw/bw and backward playabck\n", context->max_width, context->max_height, context->max_bitrate);
+	ret = enter_decode_mode(context, context->max_width, context->max_height, context->max_bitrate, 1, 0);
 	if (0 > ret) {
 		return ret;
 	}
@@ -1865,112 +2099,133 @@ static int test_decode_fast_navi(test_decode_context* context)
 		pthread_create(&context->decoder[i].thread_id, NULL, decoder_instance_h264_es_file_fast_navi, (void*) &context->decoder[i]);
 	}
 
-	memset(buffer, 0x0, sizeof(buffer));
-	memset(buffer_old, 0x0, sizeof(buffer_old));
-
-	int flag_stdin = 0;
-	flag_stdin = fcntl(STDIN_FILENO, F_GETFL);
-	if (fcntl(STDIN_FILENO, F_SETFL, fcntl(STDIN_FILENO, F_GETFL) | O_NONBLOCK) == -1) {
-		u_printf("[error]: stdin_fileno set error.\n");
-	}
+	if (context->daemon) {
+		daemon(1, 0);
+		u32 wait_times = 10 * context->daemon_pause_time;
+		while (test_decode_running) {
+			usleep(100000);
+			if (context->daemon_pause_time) {
+				if (0 == wait_times) {
+					printf("pause at daemon mode\n");
+					context->decoder[0].current_trickplay = IAV_TRICK_PLAY_PAUSE;
+					ioctl_decode_trick_play(context->iav_fd, 0, IAV_TRICK_PLAY_PAUSE);
+				} else {
+					wait_times --;
+				}
+			}
+		}
+	} else {
+		char buffer_old[128] = {0};
+		char buffer[128];
+		char* p_buffer = buffer;
 
-	while (test_decode_running) {
-		usleep(100000);
 		memset(buffer, 0x0, sizeof(buffer));
-		if (read(STDIN_FILENO, buffer, sizeof(buffer)) < 0) {
-			continue;
-		}
+		memset(buffer_old, 0x0, sizeof(buffer_old));
 
-		if (buffer[0] == '\n') {
-			p_buffer = buffer_old;
-			u_printf("repeat last cmd:\n\t\t%s\n", buffer_old);
-		} else if (buffer[0] == 'l') {
-			u_printf("show last cmd:\n\t\t%s\n", buffer_old);
-			continue;
-		} else {
-			p_buffer = buffer;
-			//record last cmd
-			strncpy(buffer_old, buffer, sizeof(buffer_old) -1);
-			buffer_old[sizeof(buffer_old) -1] = 0x0;
+		int flag_stdin = 0;
+		flag_stdin = fcntl(STDIN_FILENO, F_GETFL);
+		if (fcntl(STDIN_FILENO, F_SETFL, fcntl(STDIN_FILENO, F_GETFL) | O_NONBLOCK) == -1) {
+			u_printf("[error]: stdin_fileno set error.\n");
 		}
 
-		if ('q' == p_buffer[0]) {
-			u_printf("Quit, 'q'\n");
-			test_decode_running = 0;
-		} else if ('p' == p_buffer[0]) {
-			if (0) {
-				query_bsb_and_print(context->iav_fd, 0);
-			} else {
-				query_decode_status_and_print(context->iav_fd, 0);
+		while (test_decode_running) {
+			usleep(100000);
+			memset(buffer, 0x0, sizeof(buffer));
+			if (read(STDIN_FILENO, buffer, sizeof(buffer)) < 0) {
+				continue;
 			}
-		} else if (' ' == p_buffer[0]) {
-			if (IAV_TRICK_PLAY_RESUME == context->decoder[0].current_trickplay) {
-				context->decoder[0].current_trickplay = IAV_TRICK_PLAY_PAUSE;
-				ioctl_decode_trick_play(context->iav_fd, 0, IAV_TRICK_PLAY_PAUSE);
+
+			if (buffer[0] == '\n') {
+				p_buffer = buffer_old;
+				u_printf("repeat last cmd:\n\t\t%s\n", buffer_old);
+			} else if (buffer[0] == 'l') {
+				u_printf("show last cmd:\n\t\t%s\n", buffer_old);
+				continue;
 			} else {
-				context->decoder[0].current_trickplay = IAV_TRICK_PLAY_RESUME;
-				ioctl_decode_trick_play(context->iav_fd, 0, IAV_TRICK_PLAY_RESUME);
-			}
-		} else if ('s' == p_buffer[0]) {
-			context->decoder[0].current_trickplay = IAV_TRICK_PLAY_STEP;
-			ioctl_decode_trick_play(context->iav_fd, 0, IAV_TRICK_PLAY_STEP);
-		} else if ('f' == p_buffer[0]) {
-			if ('1' == p_buffer[1]) {
-				msg_t msg;
-				msg.cmd = M_MSG_FW_FROM_BEGIN;
-				msg.arg1 = 1;
-				msg.arg2 = 0;
-				msg_queue_put(&context->decoder[0].cmd_queue, &msg);
-			} else if ('2' == p_buffer[1]) {
-				msg_t msg;
-				msg.cmd = M_MSG_FW_FROM_BEGIN;
-				msg.arg1 = 2;
-				msg.arg2 = 0;
-				msg_queue_put(&context->decoder[0].cmd_queue, &msg);
-			} else if ('4' == p_buffer[1]) {
-				msg_t msg;
-				msg.cmd = M_MSG_FW_FROM_BEGIN;
-				msg.arg1 = 4;
-				msg.arg2 = 0;
-				msg_queue_put(&context->decoder[0].cmd_queue, &msg);
-			} else if ('8' == p_buffer[1]) {
-				msg_t msg;
-				msg.cmd = M_MSG_FW_FROM_BEGIN;
-				msg.arg1 = 8;
-				msg.arg2 = 0;
-				msg_queue_put(&context->decoder[0].cmd_queue, &msg);
+				p_buffer = buffer;
+				//record last cmd
+				strncpy(buffer_old, buffer, sizeof(buffer_old) -1);
+				buffer_old[sizeof(buffer_old) -1] = 0x0;
 			}
-		} else if ('b' == p_buffer[0]) {
-			if ('1' == p_buffer[1]) {
-				msg_t msg;
-				msg.cmd = M_MSG_BW_FROM_END;
-				msg.arg1 = 1;
-				msg.arg2 = 0;
-				msg_queue_put(&context->decoder[0].cmd_queue, &msg);
-			} else if ('2' == p_buffer[1]) {
-				msg_t msg;
-				msg.cmd = M_MSG_BW_FROM_END;
-				msg.arg1 = 2;
-				msg.arg2 = 0;
-				msg_queue_put(&context->decoder[0].cmd_queue, &msg);
-			} else if ('4' == p_buffer[1]) {
-				msg_t msg;
-				msg.cmd = M_MSG_BW_FROM_END;
-				msg.arg1 = 4;
-				msg.arg2 = 0;
-				msg_queue_put(&context->decoder[0].cmd_queue, &msg);
-			} else if ('8' == p_buffer[1]) {
-				msg_t msg;
-				msg.cmd = M_MSG_BW_FROM_END;
-				msg.arg1 = 8;
-				msg.arg2 = 0;
-				msg_queue_put(&context->decoder[0].cmd_queue, &msg);
+
+			if ('q' == p_buffer[0]) {
+				u_printf("Quit, 'q'\n");
+				test_decode_running = 0;
+			} else if ('p' == p_buffer[0]) {
+				if (0) {
+					query_bsb_and_print(context->iav_fd, 0);
+				} else {
+					query_decode_status_and_print(context->iav_fd, 0);
+				}
+			} else if (' ' == p_buffer[0]) {
+				if (IAV_TRICK_PLAY_RESUME == context->decoder[0].current_trickplay) {
+					context->decoder[0].current_trickplay = IAV_TRICK_PLAY_PAUSE;
+					ioctl_decode_trick_play(context->iav_fd, 0, IAV_TRICK_PLAY_PAUSE);
+				} else {
+					context->decoder[0].current_trickplay = IAV_TRICK_PLAY_RESUME;
+					ioctl_decode_trick_play(context->iav_fd, 0, IAV_TRICK_PLAY_RESUME);
+				}
+			} else if ('s' == p_buffer[0]) {
+				context->decoder[0].current_trickplay = IAV_TRICK_PLAY_STEP;
+				ioctl_decode_trick_play(context->iav_fd, 0, IAV_TRICK_PLAY_STEP);
+			} else if ('f' == p_buffer[0]) {
+				if ('1' == p_buffer[1]) {
+					msg_t msg;
+					msg.cmd = M_MSG_FW_FROM_BEGIN;
+					msg.arg1 = 1;
+					msg.arg2 = 0;
+					msg_queue_put(&context->decoder[0].cmd_queue, &msg);
+				} else if ('2' == p_buffer[1]) {
+					msg_t msg;
+					msg.cmd = M_MSG_FW_FROM_BEGIN;
+					msg.arg1 = 2;
+					msg.arg2 = 0;
+					msg_queue_put(&context->decoder[0].cmd_queue, &msg);
+				} else if ('4' == p_buffer[1]) {
+					msg_t msg;
+					msg.cmd = M_MSG_FW_FROM_BEGIN;
+					msg.arg1 = 4;
+					msg.arg2 = 0;
+					msg_queue_put(&context->decoder[0].cmd_queue, &msg);
+				} else if ('8' == p_buffer[1]) {
+					msg_t msg;
+					msg.cmd = M_MSG_FW_FROM_BEGIN;
+					msg.arg1 = 8;
+					msg.arg2 = 0;
+					msg_queue_put(&context->decoder[0].cmd_queue, &msg);
+				}
+			} else if ('b' == p_buffer[0]) {
+				if ('1' == p_buffer[1]) {
+					msg_t msg;
+					msg.cmd = M_MSG_BW_FROM_END;
+					msg.arg1 = 1;
+					msg.arg2 = 0;
+					msg_queue_put(&context->decoder[0].cmd_queue, &msg);
+				} else if ('2' == p_buffer[1]) {
+					msg_t msg;
+					msg.cmd = M_MSG_BW_FROM_END;
+					msg.arg1 = 2;
+					msg.arg2 = 0;
+					msg_queue_put(&context->decoder[0].cmd_queue, &msg);
+				} else if ('4' == p_buffer[1]) {
+					msg_t msg;
+					msg.cmd = M_MSG_BW_FROM_END;
+					msg.arg1 = 4;
+					msg.arg2 = 0;
+					msg_queue_put(&context->decoder[0].cmd_queue, &msg);
+				} else if ('8' == p_buffer[1]) {
+					msg_t msg;
+					msg.cmd = M_MSG_BW_FROM_END;
+					msg.arg1 = 8;
+					msg.arg2 = 0;
+					msg_queue_put(&context->decoder[0].cmd_queue, &msg);
+				}
 			}
 		}
-	}
 
-	if (fcntl(STDIN_FILENO, F_SETFL, flag_stdin) == -1) {
-		u_printf("[error]: stdin_fileno set error");
+		if (fcntl(STDIN_FILENO, F_SETFL, flag_stdin) == -1) {
+			u_printf("[error]: stdin_fileno set error");
+		}
 	}
 
 	u_printf("[flow]: start exit\n");
@@ -1993,8 +2248,10 @@ static int test_decode_fast_navi(test_decode_context* context)
 		ret = destroy_decoder(context, (u8) i);
 	}
 
-	leave_decode_mode(context);
-	u_printf("[flow]: after leave decode mode\n");
+	if (context->debug_return_idle) {
+		leave_decode_mode(context);
+		u_printf("[flow]: after leave decode mode\n");
+	}
 
 	return ret;
 }
@@ -2019,13 +2276,23 @@ int main(int argc, char **argv)
 	memset(&context, 0x0, sizeof(context));
 	context.iav_fd = -1;
 
+	//default settings
 	context.debug_read_direct_to_bsb = 1;
+	context.max_width = 1920;
+	context.max_height = 1088;
+	context.gop_size = 30;
+	context.framerate_den = 3003;
 
 	if ((ret = init_test_decode_params(argc, argv, &context)) < 0) {
 		u_printf_error("[error]: init_test_decode_params() fail.\n");
 		return (-2);
 	}
 
+	if (!context.framerate_den) {
+		u_printf_error("zero frame den, use 3003 as default\n");
+		context.framerate_den = 3003;
+	}
+
 	context.iav_fd = open("/dev/iav", O_RDWR, 0);
 	if (context.iav_fd < 0) {
 		u_printf_error("[error]: open iav fail.\n");
@@ -2079,6 +2346,8 @@ int main(int argc, char **argv)
 		ret = get_single_vout_info(1, AMBA_VOUT_SINK_TYPE_HDMI, &context.vout_dev_info[0], context.iav_fd);
 		if (0 > ret) {
 			u_printf("[error]: HDMI is not enabled\n");
+			close(context.iav_fd);
+			return (-4);
 		} else {
 			if (context.vout_dev_info[0].width && context.vout_dev_info[0].height) {
 				u_printf("[vout info query]: HDMI width %d, height %d, offset_x %d, offset_y %d, rotate %d, flip %d\n", context.vout_dev_info[0].width, context.vout_dev_info[0].height, context.vout_dev_info[0].offset_x, context.vout_dev_info[0].offset_y, context.vout_dev_info[0].rotate, context.vout_dev_info[0].flip);
diff --git a/iav_test/test_dptz.c b/iav_test/test_dptz.c
index ca9f770..807a04f 100644
--- a/iav_test/test_dptz.c
+++ b/iav_test/test_dptz.c
@@ -5,12 +5,29 @@
  * History:
  *	2010/2/20 - [Louis Sun] created file
  *
- * Copyright (C) 2007-2010, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 #include <unistd.h>
@@ -232,7 +249,6 @@ int init_param(int argc, char **argv)
 					current_source);
 				return -1;
 			}
-			first = atoi(optarg);
 			dptz_format[current_source].dz_numer = first;
 			dptz_format[current_source].dz_denom = second;
 			dptz_format[current_source].dz_times_flag = 1;
@@ -737,7 +753,7 @@ static int digital_zoom_autorun_for_prev(int buffer_id)
 			y -= dy;
 			w += 2 * dx;
 			h += 2 * dy;
-			if (h > setup.size[0].height) {
+			if (h > setup.size[0].height || w > setup.size[0].width) {
 				w = setup.size[buffer_id].width;
 				h = setup.size[buffer_id].height;
 				x = y = zm_flag = 0;
diff --git a/iav_test/test_efm.c b/iav_test/test_efm.c
index a1b1cb7..f549d85 100644
--- a/iav_test/test_efm.c
+++ b/iav_test/test_efm.c
@@ -1,17 +1,34 @@
-/*******************************************************************************
+/*
  * test_efm.c
  *
  * History:
  *  2015/07/01 - [Zhaoyang Chen] created file
  *
- * Copyright (C) 2015-2019, Ambarella ShangHai Co,Ltd
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- ******************************************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 #include <stdio.h>
 #include <stdlib.h>
 #include <errno.h>
@@ -126,6 +143,7 @@ static sem_t read_sem;
 static u32 raw_buf_rd_idx;
 static u32 raw_buf_wr_idx;
 static pthread_t raw_thread_id;
+static u8 is_last_frame = 0;
 
 
 struct iav_efm_get_pool_info efm_pool_info;
@@ -141,11 +159,12 @@ static struct option long_options[] = {
 	{"frame-size",	HAS_ARG,	0,	's'},
 	{"frame-rate",	HAS_ARG,	0,	'r'},
 	{"copy-method",	HAS_ARG,	0,	'c'},
+	{"last-frame",	HAS_ARG,	0,	'l'},
 	{"verbose",	NO_ARG,	0,	'v'},
 	{0,	0,	0,	0},
 };
 
-static const char *short_options = "b:c:f:i:m:n:r:s:t:vy:";
+static const char *short_options = "b:c:f:i:m:n:r:s:t:vy:l:";
 
 struct hint_s {
 	const char *arg;
@@ -163,6 +182,7 @@ static const struct hint_s hint[] = {
 	{"resolution", "\tSpecify the frame resolution for YUV/RAW file"},
 	{"frame_rate", "\tSpecify the frame rate of YUV input file for YUV File"},
 	{"copy method", "\tSpecify the copy method for YUV Capture, 0: GDMA, 1: ARM"},
+	{"last-frame[0|1]", "\tSpecify is_last_frame flag when feeding the last frame(only for EFM type 0)"},
 	{"", "\t\t\tPrint more information\n"},
 };
 
@@ -470,6 +490,9 @@ int init_param(int argc, char **argv)
 		case 'c':
 			mem_cpy_type = atoi(optarg);
 			break;
+		case 'l':
+			is_last_frame = !!atoi(optarg);
+			break;
 		case 'v':
 			verbose = 1;
 			break;
@@ -489,7 +512,7 @@ static void sigstop(int sig)
 
 static int generate_me1_file(void)
 {
-	u32 pitch, height, luma_size, me1_size, result;
+	u32 width, height, luma_size, me1_size, result;
 	int i, j, k, l;
 	u8 *start;
 
@@ -501,16 +524,16 @@ static int generate_me1_file(void)
 	}
 
 	me1_from_file = 1;
-	pitch = efm_pool_info.yuv_pitch;
+	width = efm_pool_info.yuv_size.width;
 	height = efm_pool_info.yuv_size.height;
-	luma_size = pitch * height;
+	luma_size = width * height;
 	luma_buf = (u8 *)malloc(luma_size);
 	if (luma_buf == NULL) {
 		return -1;
 	}
-	pitch = efm_pool_info.me1_pitch;
+	width = efm_pool_info.me1_size.width;
 	height = efm_pool_info.me1_size.height;
-	me1_size = pitch * height;
+	me1_size = width * height;
 	me1_buf = (u8 *)malloc(me1_size);
 	if (me1_buf == NULL) {
 		if (luma_buf != NULL) {
@@ -520,29 +543,22 @@ static int generate_me1_file(void)
 	}
 
 	for (i = 0; i < frame_num; ++i) {
-		if (efm_pool_info.yuv_pitch == efm_pool_info.yuv_size.width) {
-			read(fd_yuv, luma_buf, luma_size);
-		} else {
-			// read to buffer line by line
-			for (j = 0; j < efm_pool_info.yuv_size.height; j++) {
-				read(fd_yuv, luma_buf + j * efm_pool_info.yuv_pitch,
-					frame_size.width);
-			}
-		}
+		read(fd_yuv, luma_buf, luma_size);
+
 		// ignore chroma;
 		lseek(fd_yuv, luma_size >> 1, SEEK_CUR);
-		pitch = efm_pool_info.yuv_pitch;
+		width = efm_pool_info.yuv_size.width;
 		for (j = 0; j < efm_pool_info.me1_size.height; j++) {
 			for (k = 0; k < efm_pool_info.me1_size.width; k++) {
 				result = 0;
-				start = luma_buf + j * 4 * pitch + k * 4;
+				start = luma_buf + j * 4 * width + k * 4;
 				for (l = 0; l < 4; l++) {
-					result += start[l * pitch] + start[l * pitch + 1] +
-						start[l * pitch + 2] + start[l * pitch + 3];
+					result += start[l * width] + start[l * width + 1] +
+						start[l * width + 2] + start[l * width + 3];
 				}
-				me1_buf[j * efm_pool_info.me1_pitch + k] = (result + 8) >> 4;
+				me1_buf[j * efm_pool_info.me1_size.width + k] = (result + 8) >> 4;
 			}
-			write(fd_me1, me1_buf + j * efm_pool_info.me1_pitch,
+			write(fd_me1, me1_buf + j * efm_pool_info.me1_size.width,
 				efm_pool_info.me1_size.width);
 		}
 	}
@@ -569,6 +585,7 @@ int prepare_yuv_params(void)
 	struct iav_srcbuf_setup setup;
 	u32 single_size, total_size, state;
 	int ret = 0;
+	struct stat statbuff;
 
 	AM_IOCTL(fd_iav, IAV_IOC_GET_IAV_STATE, &state);
 	if ((state != IAV_STATE_PREVIEW) &&
@@ -612,7 +629,11 @@ int prepare_yuv_params(void)
 		}
 		// Fix Me:  Assume YUV420 always
 		single_size = frame_size.width * frame_size.height * 3 >> 1;
-		total_size = lseek(fd_yuv, 0L, SEEK_END);
+		if (fstat(fd_yuv, &statbuff) < 0) {
+			perror("fstat");
+			return -1;
+		}
+		total_size = statbuff.st_size;
 		lseek(fd_yuv, 0L, SEEK_SET);
 		if (frame_num == -1) {
 			frame_num = total_size / single_size;
@@ -778,7 +799,7 @@ static int fill_yuv_from_file(struct iav_efm_request_frame *request)
 	} else {
 		luma_addr = dsp_efm_yuv_mem + request->yuv_luma_offset;
 		chroma_addr = dsp_efm_yuv_mem + request->yuv_chroma_offset;
-		me1_addr = dsp_efm_yuv_mem + request->me1_offset;
+		me1_addr = dsp_efm_me1_mem + request->me1_offset;
 	}
 	if (efm_pool_info.yuv_pitch == efm_pool_info.yuv_size.width) {
 		// just copy to dest buffer when pitch is the same as width
@@ -823,7 +844,7 @@ static int fill_yuv_from_file(struct iav_efm_request_frame *request)
 		} else {
 		// copy to dest buffer line by line
 			for (i = 0; i < efm_pool_info.me1_size.height; i++) {
-				read(fd_yuv, me1_addr + i * efm_pool_info.me1_pitch,
+				read(fd_me1, me1_addr + i * efm_pool_info.me1_pitch,
 					efm_pool_info.me1_size.width);
 			}
 		}
@@ -893,6 +914,10 @@ static int feed_yuv_loop(void)
 		printf("Check EFM for YUV parameters failed!\n");
 		return -1;
 	}
+	if ((type != EFM_TYPE_YUV_FILE) && is_last_frame) {
+		printf("last-frame is only valid for EFM type 0\n");
+		is_last_frame = 0;
+	}
 
 	printf("START feeding YUV frames:\n");
 	while(!exit_efm) {
@@ -915,10 +940,15 @@ static int feed_yuv_loop(void)
 			memset(&handshake, 0, sizeof(handshake));
 			handshake.frame_idx = request.frame_idx;
 			handshake.frame_pts = frame_pts;
-			while(ioctl(fd_iav, IAV_IOC_EFM_HANDSHAKE_FRAME, &handshake)) {
-				printf(".");
-				usleep(10 * 1000);
-			};
+			if (is_last_frame && (count == frame_num - 1)) {
+				handshake.is_last_frame = 1;
+			} else {
+				handshake.is_last_frame = 0;
+			}
+			if(ioctl(fd_iav, IAV_IOC_EFM_HANDSHAKE_FRAME, &handshake)) {
+				perror("IAV_IOC_EFM_HANDSHAKE_FRAME");
+				return -1;
+			}
 			printf("done!\n");
 
 			count++;
@@ -936,14 +966,8 @@ static int feed_yuv_loop(void)
 static int prepare_raw_params(void)
 {
 	//struct iav_system_resource resource;
-	u32 state, single_size, total_size;
+	u32 single_size, total_size;
 
-	AM_IOCTL(fd_iav, IAV_IOC_GET_IAV_STATE, &state);
-	if ((state != IAV_STATE_INIT) &&
-		(state != IAV_STATE_IDLE)) {
-		printf("IAV state should be INIT/IDLE for raw (YUV/RGB) encode!\n");
-		return -1;
-	}
 	if (!frame_size.width || !frame_size.height) {
 		printf("Incorrect frame size %ux%u!\n",
 			frame_size.width, frame_size.height);
diff --git a/iav_test/test_encode.c b/iav_test/test_encode.c
index cd9a9e4..073adfc 100644
--- a/iav_test/test_encode.c
+++ b/iav_test/test_encode.c
@@ -9,12 +9,29 @@
  *	2010/12/31 - [Louis Sun] create this file base on test2.c
  *	2011/10/31 - [Jian Tang] modified this file.
  *
- * Copyright (C) 2007-2012, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 #include <unistd.h>
@@ -35,6 +52,7 @@
 #include <assert.h>
 #include <basetypes.h>
 #include <iav_ioctl.h>
+#include <iav_ucode_ioctl.h>
 
 #include <signal.h>
 
@@ -122,6 +140,7 @@ typedef enum {
 	IAV_SHOW_DRAM_LAYOUT = 0x08,
 	IAV_SHOW_FEATURE_SET = 0x09,
 	IAV_SHOW_CMD_EXAMPPLES = 0x0A,
+	IAV_SHOW_QP_HIST = 0x0B,
 	IAV_SHOW_INFO_TOTAL_NUM,
 	IAV_SHOW_INFO_FIRST = 0,
 	IAV_SHOW_INFO_LAST = IAV_SHOW_INFO_TOTAL_NUM,
@@ -186,9 +205,6 @@ typedef struct encode_format_s {
 
 	u16 duration;
 	u16 duration_flag;
-
-	u16 snapshot_enable;
-	u16 snapshot_enable_flag;
 } encode_format_t;
 
 //source buffer type
@@ -213,6 +229,12 @@ typedef struct source_buffer_format_s {
 
 	int unwarp;
 	int unwarp_flag;
+
+	int dump_interval;
+	int dump_interval_flag;
+
+	int dump_duration;
+	int dump_duration_flag;
 }  source_buffer_format_t;
 
 //resolution
@@ -230,18 +252,28 @@ typedef struct qp_limit_params_s {
 	u8	qp_max_p;
 	u8	qp_min_b;
 	u8	qp_max_b;
+	u8	qp_min_q;
+	u8	qp_max_q;
 	u8	adapt_qp;
 	u8	i_qp_reduce;
 	u8	p_qp_reduce;
+	u8	q_qp_reduce;
+	u8	log_q_num_plus_1;
 	u8	skip_frame;
+	u16	max_i_size_KB;
 
 	u8	qp_i_flag;
 	u8	qp_p_flag;
 	u8	qp_b_flag;
+	u8	qp_q_flag;
 	u8	adapt_qp_flag;
 	u8	i_qp_reduce_flag;
 	u8	p_qp_reduce_flag;
+	u8	q_qp_reduce_flag;
+	u8	log_q_num_plus_1_flag;
 	u8	skip_frame_flag;
+	u8	max_i_size_KB_flag;
+	u8	reserved1;
 } qp_limit_params_t;
 
 // qp matrix delta value
@@ -289,15 +321,16 @@ typedef struct h264_param_s {
 	int h264_mv_threshold;
 	int h264_mv_threshold_flag;
 
-	int h264_enc_improve;
-	int h264_enc_improve_flag;
+	int h264_flat_area_improve;
+	int h264_flat_area_improve_flag;
 
-	int h264_long_term_intvl;
-	int h264_long_term_intvl_flag;
+	int h264_fast_seek_intvl;
+	int h264_fast_seek_intvl_flag;
 
 	int h264_multi_ref_p;
 	int h264_multi_ref_p_flag;
 
+	int h264_drop_frame_repeat_enable;
 	int h264_drop_frames;
 	int h264_drop_frames_flag;
 
@@ -332,6 +365,23 @@ typedef struct h264_param_s {
 	u8 fast_rc_idc;
 	u32 cpb_user_size;
 	int panic_mode_flag;
+
+	u16 h264_frame_crop_left_offset;
+	u16 h264_frame_crop_right_offset;
+	u16 h264_frame_crop_top_offset;
+	u16 h264_frame_crop_bottom_offset;
+
+	u16 h264_frame_crop_left_offset_flag;
+	u16 h264_frame_crop_right_offset_flag;
+	u16 h264_frame_crop_top_offset_flag;
+	u16 h264_frame_crop_bottom_offset_flag;
+
+	int h264_abs_br;
+	int h264_abs_br_flag;
+
+	int force_pskip_repeat_enable;
+	int force_pskip_repeat_num;
+	int force_pskip_flag;
 } h264_param_t;
 
 typedef struct jpeg_param_s{
@@ -367,6 +417,8 @@ typedef struct system_resource_setup_s {
 	int extra_dram_buf_changed_id;
 	int lens_warp;
 	int lens_warp_flag;
+	int max_enc_num;
+	int max_enc_num_flag;
 	int max_warp_input_width;
 	int max_warp_input_width_flag;
 	int max_warp_input_height;
@@ -393,6 +445,8 @@ typedef struct system_resource_setup_s {
 	int efm_buf_num_flag;
 	int enc_raw_yuv;
 	int enc_raw_yuv_flag;
+	int vin_overflow_protection;
+	int vin_overflow_protection_flag;
 
 	/* Intermediate buffer*/
 	int v_warped_main_max_width;
@@ -408,6 +462,9 @@ typedef struct system_resource_setup_s {
 	int dsp_partition_map;
 	int dsp_partition_map_flag;
 
+	int long_ref_b_frame;
+	int long_ref_b_frame_flag;
+
 	int stream_long_ref_enable[MAX_ENCODE_STREAM_NUM];
 	int stream_long_ref_enable_flag[MAX_ENCODE_STREAM_NUM];
 	int max_gop_M[MAX_ENCODE_STREAM_NUM];
@@ -419,6 +476,9 @@ typedef struct system_resource_setup_s {
 	int debug_iso_type_flag;
 	int debug_chip_id;
 	int debug_chip_id_flag;
+
+	int extra_top_row_buf;
+	int extra_top_row_buf_flag;
 }system_resource_setup_t;
 
 typedef struct debug_setup_s {
@@ -444,6 +504,7 @@ static int current_buffer = -1;	// -1 is a invalid buffer, for initialize data o
 //encode start/stop/format control variables
 static u32 start_stream_id = 0;
 static u32 stop_stream_id = 0;
+static u32 abort_stream_id = 0;
 
 //encoding settings
 static encode_format_t encode_format[MAX_ENCODE_STREAM_NUM];
@@ -471,6 +532,9 @@ static int system_resource_limit_changed_flag = 0;
 //force idr generation
 static u32 force_idr_id = 0;
 
+//long ref p generation
+static u32 long_ref_p_id = 0;
+
 //force fast seek frame
 static u32 force_fast_seek_id = 0;
 
@@ -504,6 +568,9 @@ static int dump_idsp_bin_flag = 0;
 static debug_setup_t debug_setup;
 static int debug_setup_flag = 0;
 
+static int dsp_clock_state_disable = 0;
+static int dsp_clock_state_disable_flag = 0;
+
 struct encode_resolution_s {
 	const char 	*name;
 	int		width;
@@ -598,8 +665,7 @@ struct hint_s {
 
 #define	STREAM_NUMVERIC_SHORT_OPTIONS				\
 	ENCODING_OFFSET_X_Y	=	STREAM_OPTIONS_BASE,	\
-	ENCODING_MAX_SIZE,		\
-	SPECIFY_STREAM_SNAPSHOT
+	ENCODING_MAX_SIZE
 
 #define	ENCODE_CONTROL_NUMVERIC_SHORT_OPTIONS				\
 	SPECIFY_MULTISTREAMS_START	=	ENCODE_CONTROL_OPTIONS_BASE,	\
@@ -609,7 +675,9 @@ struct hint_s {
 	FRAME_FACTOR,				\
 	FRAME_FACTOR_SYNC,			\
 	STREAM_ABS_FPS,			\
-	SPECIFY_STREAM_ABS_FPS
+	SPECIFY_STREAM_ABS_FPS,	\
+	SPECIFY_LONG_REF_P,		\
+	SPECIFY_STREAM_ABORT
 
 #define	H264ENC_NUMVERIC_SHORT_OPTIONS					\
 	SPECIFY_GOP_IDR				=	H264ENC_OPTIONS_BASE,	\
@@ -620,25 +688,34 @@ struct hint_s {
 	CHANGE_QP_LIMIT_I,			\
 	CHANGE_QP_LIMIT_P,			\
 	CHANGE_QP_LIMIT_B,			\
+	CHANGE_QP_LIMIT_Q,			\
 	CHANGE_ADAPT_QP,			\
 	CHANGE_I_QP_REDUCE,		\
 	CHANGE_P_QP_REDUCE,		\
+	CHANGE_Q_QP_REDUCE,		\
+	CHANGE_LOG_Q_NUM_PLUS_1,	\
 	CHANGE_SKIP_FRAME_MODE,	\
+	CHANGE_MAX_I_SIZE_KB,	\
 	CHANGE_INTRA_MB_ROWS,		\
 	CHANGE_QP_MATRIX_DELTA,	\
 	CHANGE_QP_MATRIX_MODE,		\
 	DEBLOCKING_ALPHA,			\
 	DEBLOCKING_BETA,			\
 	DEBLOCKING_ENABLE,			\
+	LEFT_FRAME_CROP,			\
+	RIGHT_FRAME_CROP,			\
+	TOP_FRAME_CROP,				\
+	BOTTOM_FRAME_CROP,			\
 	SPECIFY_PROFILE_LEVEL,		\
 	INTLC_IFRAME,				\
 	SPECIFY_MV_THRESHOLD,		\
-	SPECIFY_ENC_IMPROVE,		\
-	SPECIFY_LONG_TERM_INTVL,	\
+	SPECIFY_FLAT_AREA_IMPROVE,		\
+	SPECIFY_FAST_SEEK_INTVL,	\
 	SPECIFY_MULTI_REF_P,			\
 	SPECIFY_MAX_GOP_M,			\
 	SPECIFY_FORCE_FAST_SEEK,		\
 	SPECIFY_FRAME_DROP,			\
+	SPECIFY_FRAME_DROP_REPEAT_ENABLE,			\
 	SPECIFY_INTRABIAS_P,			\
 	SPECIFY_INTRABIAS_B,			\
 	SPECIFY_USER1_INTRABIAS,		\
@@ -647,7 +724,11 @@ struct hint_s {
 	SPECIFY_USER2_DIRECTBIAS,	\
 	SPECIFY_USER3_INTRABIAS,		\
 	SPECIFY_USER3_DIRECTBIAS,	\
-	SPECIFY_AU_TYPE
+	SPECIFY_AU_TYPE,			\
+	SPECIFY_ABS_BR_FLAG,		\
+	SPECIFY_FORCE_PSKIP_REPEAT,	\
+	SPECIFY_REPEAT_PSKIP_NUM
+
 
 #define	PANIC_NUMVERIC_SHORT_OPTIONS		\
 	CPB_BUF_IDC			=	PANIC_OPTIONS_BASE,	\
@@ -670,11 +751,13 @@ struct hint_s {
 	SPECIFY_RAW_CAPTURE,		\
 	SPECIFY_HDR_EXPOSURE_NUM,	\
 	SPECIFY_LENS_WARP,			\
+	SPECIFY_MAX_ENC_NUM,		\
 	SPECIFY_MAX_WARP_INPUT_HEIGHT,	\
 	SPECIFY_MAX_PADDING_WIDTH,		\
 	SPECIFY_INTERMEDIATE_BUF_SIZE,	\
 	SPECIFY_ENC_DUMMY_LATENCY,		\
 	SPECIFY_LONG_REF_ENABLE,		\
+	SPECIFY_LONG_REF_B_FRAME,		\
 	SPECIFY_DSP_PARTITION_MAP,		\
 	SPECIFY_IDSP_UPSAMPLE_TYPE,		\
 	SPECIFY_MCTF_PM,				\
@@ -688,7 +771,10 @@ struct hint_s {
 	SPECIFY_EFM_BUF_NUM,		\
 	SPECIFY_EFM_SIZE,			\
 	DUMP_IDSP_CONFIG,			\
-	SPECIFY_OSD_MIXER
+	SPECIFY_OSD_MIXER,			\
+	SPECIFY_OVERFLOW_PROTECTION,\
+	SPECIFY_DSP_CLCOK_STATE,	\
+	SPECIFY_EXTRA_TOP_RAW_BUF
 
 #define	SOURCE_BUFFER_NUMVERIC_SHORT_OPTIONS		\
 	SPECIFY_BUFFER_TYPE = SOURCE_BUFFER_OPTIONS_BASE,	\
@@ -697,7 +783,9 @@ struct hint_s {
 	SPECIFY_BUFFER_INPUT_SIZE,	\
 	SPECIFY_BUFFER_INPUT_OFFSET,	\
 	SPECIFY_BUFFER_PREWARP,		\
-	SPECIFY_EXTRA_DRAM_BUF
+	SPECIFY_EXTRA_DRAM_BUF,		\
+	SPECIFY_VCA_DUMP_INTERVAL,	\
+	SPECIFY_VCA_DUMP_DURATION
 
 #define	SHOW_NUMVERIC_SHORT_OPTIONS		\
 	SHOW_SYSTEM_STATE = MISC_OPTIONS_BASE,		\
@@ -711,6 +799,7 @@ struct hint_s {
 	SHOW_DRAM_LAYOUT,		\
 	SHOW_FEATURE_SET,		\
 	SHOW_CMD_EXAMPLES,		\
+	SHOW_QP_HIST,		\
 	SHOW_ALL_INFO
 
 #define	DEBUG_NUMVERIC_SHORT_OPTIONS		\
@@ -772,7 +861,7 @@ enum numeric_short_options {
 #define	STREAM_C_HINTS			{"",			"\t\tconfig for stream C"},
 
 #define	STREAM_D_OPTIONS			{"stream_D",	NO_ARG,		0,	'D'},
-#define	STREAM_D_HINTS			{"",			"\t\tconfig for stream D"},
+#define	STREAM_D_HINTS			{"",			"\t\tconfig for stream D\n"},
 
 #define	STREAM_H264_OPTIONS		{"h264", 		HAS_ARG,	0,	'h'},
 #define	STREAM_H264_HINTS			{"resolution",	"\tenter H.264 encoding resolution"},
@@ -785,7 +874,7 @@ enum numeric_short_options {
 
 // encode source buffer
 #define	STREAM_SRCBUF_OPTIONS	{"src-buf",	HAS_ARG,	0,	'b'},
-#define	STREAM_SRCBUF_HINTS		{"0|1|2|3|5","\tsource buffers 0~3, and efm buffer 5" },
+#define	STREAM_SRCBUF_HINTS		{"0|1|2|3|5","source buffers 0~3, and efm buffer 5" },
 
 #define	STREAM_DURATION_OPTIONS		\
 	{"duration",	HAS_ARG,	0,	'd'},
@@ -804,11 +893,6 @@ enum numeric_short_options {
 #define	STREAM_SMAXSIZE_HINTS		\
 	{"resolution",	"specify stream max size for system resouce limit"},
 
-//stream snap shot
-#define	STREAM_SNAPSHOT_OPTIONS	\
-	{"snap-shot",	HAS_ARG,	0,	SPECIFY_STREAM_SNAPSHOT},
-#define	STREAM_SNAPSHOT_HINTS		\
-			{"0|1",	"Disable/Enable stream snap shot\n"},
 
 
 #define	STREAM_LONG_OPTIONS()	\
@@ -823,7 +907,6 @@ enum numeric_short_options {
 	STREAM_DURATION_OPTIONS	\
 	STREAM_OFFSET_OPTIONS		\
 	STREAM_SMAXSIZE_OPTIONS	\
-	STREAM_SNAPSHOT_OPTIONS
 
 #define STREAM_PARAMETER_HINTS()	\
 	STREAM_A_HINTS	\
@@ -837,7 +920,6 @@ enum numeric_short_options {
 	STREAM_DURATION_HINTS	\
 	STREAM_OFFSET_HINTS		\
 	STREAM_SMAXSIZE_HINTS	\
-	STREAM_SNAPSHOT_HINTS
 
 #define	STREAM_INIT_PARAMETERS()		\
 	case 'A':\
@@ -913,17 +995,6 @@ enum numeric_short_options {
 			system_resource_setup.stream_max_size_changed_id |= (1 << current_stream);\
 			system_resource_limit_changed_flag = 1;\
 			break;\
-	case SPECIFY_STREAM_SNAPSHOT:	\
-			VERIFY_STREAMID(current_stream);\
-			min_value = atoi(optarg);\
-			if (min_value != 0 && min_value != 1) {\
-				printf("Invalid snap shot flag [%d], should be [0|1].\n", min_value);\
-				return -1;\
-			}\
-			encode_format[current_stream].snapshot_enable = min_value;\
-			encode_format[current_stream].snapshot_enable_flag = 1;\
-			encode_format_changed_id |= (1 << current_stream);\
-			break;
 
 /***************************************************************
 	ENCODE CONTROL command line options
@@ -934,6 +1005,11 @@ enum numeric_short_options {
 //stop encoding
 #define	ENCODE_STOP_OPTIONS		{"stop",		NO_ARG,		0,	's'},
 #define	ENCODE_STOP_HINTS		{"", 			"\t\tstop encoding for current stream"},
+//clear stream state
+#define	ENCODE_ABORT_OPTIONS			\
+	{"abort-encode",NO_ARG,	0,	SPECIFY_STREAM_ABORT},
+#define	ENCODE_ABORT_HINTS				\
+	{"",			"\tabort encoding for current stream."},
 
 #define	ENCODE_START_MULTI_OPTIONS			\
 	{"start-multi",	HAS_ARG,	0,	SPECIFY_MULTISTREAMS_START},
@@ -970,16 +1046,22 @@ enum numeric_short_options {
 #define	STREAM_ABS_FPS_OPTIONS	\
 	{"stream-abs-fps",	HAS_ARG,	0,	STREAM_ABS_FPS},
 #define	STREAM_ABS_FPS_HINTS	\
-	{"1~60",	"set abs frame rate for streams.\n"},
+	{"1~60",	"set abs frame rate for streams"},
 
 #define	SPECIFY_STREAM_ABS_FPS_OPTIONS	\
 	{"stream-abs-fps-enable",	HAS_ARG,	0,	SPECIFY_STREAM_ABS_FPS},
 #define	SPECIFY_STREAM_ABS_FPS_HINTS	\
-	{"0|1",	"Enable setting abs frame rate. Default is 0.\n"},
+	{"0|1",	"Enable setting abs frame rate. Default is 0\n"},
+
+#define	ENCODE_LONG_REF_P_OPTIONS			\
+	{"long-ref-p",		NO_ARG,		0,	SPECIFY_LONG_REF_P},
+#define	ENCODE_LONG_REF_P_HINTS				\
+	{"",				"\t\tInserted long term P frame will replace IDR and be referenced by later frames."},
 
 #define	ENCODE_CONTROL_LONG_OPTIONS()		\
 	ENCODE_START_OPTIONS			\
 	ENCODE_STOP_OPTIONS			\
+	ENCODE_ABORT_OPTIONS		\
 	ENCODE_START_MULTI_OPTIONS		\
 	ENCODE_STOP_MULTI_OPTIONS		\
 	ENCODE_FORCE_IDR_OPTIONS		\
@@ -987,11 +1069,13 @@ enum numeric_short_options {
 	ENCODE_FRAME_FACTOR_OPTIONS	\
 	ENCODE_FRAME_FACTOR_SYNC_OPTIONS	\
 	STREAM_ABS_FPS_OPTIONS	\
-	SPECIFY_STREAM_ABS_FPS_OPTIONS
+	SPECIFY_STREAM_ABS_FPS_OPTIONS	\
+	ENCODE_LONG_REF_P_OPTIONS
 
 #define	ENCODE_CONTROL_PARAMETER_HINTS()		\
 	ENCODE_START_HINTS		\
 	ENCODE_STOP_HINTS			\
+	ENCODE_ABORT_HINTS			\
 	ENCODE_START_MULTI_HINTS	\
 	ENCODE_STOP_MULTI_HINTS	\
 	ENCODE_FORCE_IDR_HINTS		\
@@ -999,7 +1083,8 @@ enum numeric_short_options {
 	ENCODE_FRAME_FACTOR_HINTS	\
 	ENCODE_FRAME_FACTOR_SYNC_HINTS	\
 	STREAM_ABS_FPS_HINTS	\
-	SPECIFY_STREAM_ABS_FPS_HINTS
+	SPECIFY_STREAM_ABS_FPS_HINTS	\
+	ENCODE_LONG_REF_P_HINTS
 
 #define	ENCODE_CONTROL_INIT_PARAMETERS()		\
 	case 'e':\
@@ -1010,6 +1095,10 @@ enum numeric_short_options {
 			VERIFY_STREAMID(current_stream);\
 			stop_stream_id |= (1 << current_stream);\
 			break;\
+	case SPECIFY_STREAM_ABORT:\
+			VERIFY_STREAMID(current_stream);\
+			abort_stream_id |= (1 << current_stream);\
+			break;\
 	case SPECIFY_MULTISTREAMS_START:\
 			if (get_two_unsigned_int(optarg, &min_value, &max_value, '~') < 0) {\
 				return -1;\
@@ -1079,7 +1168,12 @@ enum numeric_short_options {
 			}\
 			stream_abs_fps_enable[current_stream] = min_value;\
 			stream_abs_fps_enabled_id |= (1 << current_stream);\
+			break;\
+	case SPECIFY_LONG_REF_P:\
+			VERIFY_STREAMID(current_stream);\
+			long_ref_p_id |= (1 << current_stream);\
 			break;
+
 /***************************************************************
 	H264 ENCODE command line options
 ****************************************************************/
@@ -1128,6 +1222,11 @@ enum numeric_short_options {
 #define	H264ENC_QP_LIMIT_B_HINTS			\
 	{"0~51",		"\tset B-frame qp limit range, 0:auto 1~51:qp limit range"},
 
+#define	H264ENC_QP_LIMIT_Q_OPTIONS		\
+	{"qp-limit-q", HAS_ARG, 	0, 	CHANGE_QP_LIMIT_Q},
+#define	H264ENC_QP_LIMIT_Q_HINTS			\
+	{"0~51",		"\tset Q-frame qp limit range, 0:auto 1~51:qp limit range"},
+
 #define	H264ENC_ADAPT_QP_OPTIONS		\
 	{"adapt-qp",	HAS_ARG, 	0, 	CHANGE_ADAPT_QP},
 #define	H264ENC_ADAPT_QP_HINTS			\
@@ -1143,11 +1242,27 @@ enum numeric_short_options {
 #define	H264ENC_P_QP_REDUCE_HINTS		\
 	{"1~5", "\tset diff of P QP less than B QP"},
 
+#define	H264ENC_Q_QP_REDUCE_OPTIONS		\
+	{"q-qp-reduce",	HAS_ARG, 	0, 	CHANGE_Q_QP_REDUCE},
+#define	H264ENC_Q_QP_REDUCE_HINTS		\
+	{"1~10",			"\tset diff of Q QP less than P QP"},
+
+#define	H264ENC_LOG_Q_NUM_PLUS_1_OPTIONS		\
+	{"log-q-num-plus-1",	HAS_ARG, 	0, 	CHANGE_LOG_Q_NUM_PLUS_1},
+#define	H264ENC_LOG_Q_NUM_PLUS_1_HINTS		\
+		{"0~4", 		"set Q frame number for one GOP, 0: no Q frame, 1: 1 Q frame, 2: 3 Q frames,"\
+		"\n\t\t\t\t3: 7 Q frames, 4: 15 Q frames"},
+
 #define	H264ENC_SKIP_FRAME_OPTIONS		\
 	{"skip-frame-mode",	HAS_ARG, 	0, 	CHANGE_SKIP_FRAME_MODE},
 #define	H264ENC_SKIP_FRAME_HINTS			\
 	{"0|1|2",			"0: disable, 1: skip based on CPB size, 2: skip based on target bitrate and max QP"},
 
+#define	H264ENC_MAX_I_SIZE_KB_OPTIONS		\
+	{"max-i-size-KB",	HAS_ARG, 	0, 	CHANGE_MAX_I_SIZE_KB},
+#define	H264ENC_MAX_I_SIZE_KB_HINTS		\
+	{"0~8192",			"set max size for I frame in KB, 0: disable max I size, > 0: max size for I frame in KB"},
+
 #define	H264ENC_MB_ROWS_OPTIONS		\
 	{"intra-mb-rows",	HAS_ARG, 	0, 	CHANGE_INTRA_MB_ROWS},
 #define	H264ENC_MB_ROWS_HINTS			\
@@ -1161,7 +1276,7 @@ enum numeric_short_options {
 #define	H264ENC_QM_MODE_OPTIONS		\
 	{"qm-mode",	HAS_ARG,	0,	CHANGE_QP_MATRIX_MODE},
 #define	H264ENC_QM_MODE_HINTS			\
-	{"0~4",		"\tset QP Matrix mode, 0: default; 1: skip left region; 2: skip right; 3: skip top; 4: skip bottom\n"},
+	{"0~4",		"\tset QP Matrix mode, 0: default; 1: skip left region; 2: skip right; 3: skip top; 4: skip bottom"},
 
 #define	H264ENC_DEBLOCKING_ALPHA_OPTIONS		\
 	{"deblocking-alpha",	HAS_ARG,	0,	DEBLOCKING_ALPHA},
@@ -1178,6 +1293,26 @@ enum numeric_short_options {
 #define	H264ENC_DEBLOCKING_ENABLE_HINTS			\
 	{"0|1|2", 			"deblocking-enable, 2 is auto and default value"},
 
+#define	H264ENC_FRAME_CORP_LEFT_OPTIONS		\
+	{"left-frame-crop",	HAS_ARG,	0,	LEFT_FRAME_CROP},
+#define	H264ENC_FRAME_CORP_LEFT_HINTS			\
+	{"offset", 			"left offset of frame crop"},
+
+#define	H264ENC_FRAME_CORP_RIGHT_OPTIONS		\
+	{"right-frame-crop",	HAS_ARG,	0,	RIGHT_FRAME_CROP},
+#define	H264ENC_FRAME_CORP_RIGHT_HINTS			\
+	{"offset", 			"right offset of frame crop"},
+
+#define	H264ENC_FRAME_CORP_TOP_OPTIONS		\
+	{"top-frame-crop",	HAS_ARG,	0,	TOP_FRAME_CROP},
+#define	H264ENC_FRAME_CORP_TOP_HINTS			\
+	{"offset", 			"top offset of frame crop"},
+
+#define	H264ENC_FRAME_CORP_BOTTOM_OPTIONS		\
+	{"bottom-frame-crop",	HAS_ARG,	0,	BOTTOM_FRAME_CROP},
+#define	H264ENC_FRAME_CORP_BOTTOM_HINTS			\
+	{"offset", 			"bottom offset of frame crop"},
+
 #define	H264ENC_PROFILE_OPTIONS					\
 	{"profile",	HAS_ARG,	0,	SPECIFY_PROFILE_LEVEL},
 #define	H264ENC_PROFILE_HINTS						\
@@ -1191,17 +1326,17 @@ enum numeric_short_options {
 #define	H264ENC_MV_IMPROVE_OPTIONS				\
 	{"mv-threshold",	HAS_ARG, 	0, 	SPECIFY_MV_THRESHOLD},
 #define	H264ENC_MV_IMPROVE_HINTS				\
-	{"0~255",		"Set mv threshold of current stream, value 0 means disable this"},
+	{"0|1",		"\tdisable/enable zmv threshold roi for current stream, 0: disable, 1: enable, default 0"},
 
-#define	H264ENC_IMPROVE_OPTIONS					\
-	{"enc-improve",	HAS_ARG, 	0, 	SPECIFY_ENC_IMPROVE},
-#define	H264ENC_IMPROVE_HINTS					\
-	{"0|1",			"\tdisable/enable h264 encode improvement for flat area, default is 0, which means disable"},
+#define	H264ENC_FLAT_AREA_IMPROVE_OPTIONS					\
+	{"flat-area-improve",	HAS_ARG, 	0, 	SPECIFY_FLAT_AREA_IMPROVE},
+#define	H264ENC_FLAT_AREA_IMPROVE_HINTS					\
+	{"0|1",			"disable/enable h264 encode improvement for flat area, default is 0, which means disable"},
 
-#define	H264ENC_LTERM_INTVL_OPTIONS				\
-	{"long-term-intvl",	HAS_ARG, 	0, 	SPECIFY_LONG_TERM_INTVL},
-#define	H264ENC_LTERM_INTVL_HINTS				\
-	{"0~63",			"Specify long term reference P frame interval"},
+#define	H264ENC_FAST_SEEK_INTVL_OPTIONS				\
+	{"fast-seek-intvl",	HAS_ARG, 	0, 	SPECIFY_FAST_SEEK_INTVL},
+#define	H264ENC_FAST_SEEK_INTVL_HINTS				\
+	{"0~63",			"Specify fast seek P frame interval"},
 
 #define	H264ENC_MULTI_REFP_OPTIONS				\
 	{"multi-ref-p",	HAS_ARG, 	0, 	SPECIFY_MULTI_REF_P},
@@ -1223,6 +1358,11 @@ enum numeric_short_options {
 #define	H264ENC_FRAME_DROP_HINTS				\
 	{"0~255",			"\tSpecify how many frames encoder will drop, can update on the fly"},
 
+#define	H264ENC_FRAME_DROP_REPEAT_ENABLE_OPTIONS				\
+	{"frame-drop-repeat",		HAS_ARG,	0,	SPECIFY_FRAME_DROP_REPEAT_ENABLE},
+#define	H264ENC_FRAME_DROP_REPEAT_ENABLE_HINTS				\
+	{"0~1",			"\tdisable/enable frame drop repeat, default is 0, which means disable"},
+
 #define	H264ENC_INTRABIAS_P_OPTIONS				\
 	{"intrabias-p",		HAS_ARG,	0,	SPECIFY_INTRABIAS_P},
 #define	H264ENC_INTRABIAS_P_HINTS				\
@@ -1270,6 +1410,21 @@ enum numeric_short_options {
 	{"0~3",		"\t0: No AUD, No SEI; 1: AUD before SPS, PPS, with SEI; 2: AUD after SPS, "\
 	"PPS, with SEI; 3: No AUD, with SEI.\n"},
 
+#define	H264ENC_ABS_BR_OPTIONS				\
+	{"abs-br",			HAS_ARG,	0,	SPECIFY_ABS_BR_FLAG},
+#define	H264ENC_ABS_BR_HINTS				\
+	{"0|1",		"Enable absolute bitrate, 0: disable, 1: enable\n"},
+
+#define	H264ENC_REPEAT_PSKIP_OPTIONS			\
+	{"force-pskip-repeat",		HAS_ARG,	0,	SPECIFY_FORCE_PSKIP_REPEAT},
+#define	H264ENC_REPEAT_PSKIP_HINTS				\
+	{"0|1", 	"Repeatly generate P-skip or force pskip at once for current stream. 0: no-repeat, 1: repeat."},
+
+#define	H264ENC_REPEAT_PSKIP_NUM_OPTIONS			\
+	{"repeat-pskip-num",		HAS_ARG,	0,	SPECIFY_REPEAT_PSKIP_NUM},
+#define	H264ENC_REPEAT_PSKIP_NUM_HINTS				\
+	{"0~254",	"P-skip number when repeat pattern is ON."},
+
 #define	H264_ENCODE_LONG_OPTIONS()		\
 	H264ENC_M_OPTIONS				\
 	H264ENC_N_OPTIONS				\
@@ -1281,25 +1436,34 @@ enum numeric_short_options {
 	H264ENC_QP_LIMIT_I_OPTIONS		\
 	H264ENC_QP_LIMIT_P_OPTIONS		\
 	H264ENC_QP_LIMIT_B_OPTIONS		\
+	H264ENC_QP_LIMIT_Q_OPTIONS		\
 	H264ENC_ADAPT_QP_OPTIONS		\
 	H264ENC_I_QP_REDUCE_OPTIONS	\
 	H264ENC_P_QP_REDUCE_OPTIONS	\
+	H264ENC_Q_QP_REDUCE_OPTIONS	\
+	H264ENC_LOG_Q_NUM_PLUS_1_OPTIONS	\
 	H264ENC_SKIP_FRAME_OPTIONS		\
+	H264ENC_MAX_I_SIZE_KB_OPTIONS	\
 	H264ENC_MB_ROWS_OPTIONS		\
 	H264ENC_QM_DELTA_OPTIONS		\
 	H264ENC_QM_MODE_OPTIONS		\
 	H264ENC_DEBLOCKING_ALPHA_OPTIONS		\
 	H264ENC_DEBLOCKING_BETA_OPTIONS		\
 	H264ENC_DEBLOCKING_ENABLE_OPTIONS		\
+	H264ENC_FRAME_CORP_LEFT_OPTIONS		\
+	H264ENC_FRAME_CORP_RIGHT_OPTIONS		\
+	H264ENC_FRAME_CORP_TOP_OPTIONS		\
+	H264ENC_FRAME_CORP_BOTTOM_OPTIONS		\
 	H264ENC_PROFILE_OPTIONS					\
 	H264ENC_INTLC_IFRAME_OPTIONS			\
 	H264ENC_MV_IMPROVE_OPTIONS				\
-	H264ENC_IMPROVE_OPTIONS				\
-	H264ENC_LTERM_INTVL_OPTIONS			\
+	H264ENC_FLAT_AREA_IMPROVE_OPTIONS				\
+	H264ENC_FAST_SEEK_INTVL_OPTIONS			\
 	H264ENC_MULTI_REFP_OPTIONS				\
 	H264ENC_MAX_GOPM_OPTIONS				\
 	H264ENC_FORCE_SEEK_OPTIONS				\
 	H264ENC_FRAME_DROP_OPTIONS			\
+	H264ENC_FRAME_DROP_REPEAT_ENABLE_OPTIONS			\
 	H264ENC_INTRABIAS_P_OPTIONS			\
 	H264ENC_INTRABIAS_B_OPTIONS			\
 	H264ENC_USER1_INTRABIAS_OPTIONS		\
@@ -1308,7 +1472,10 @@ enum numeric_short_options {
 	H264ENC_USER2_DIRECTBIAS_OPTIONS		\
 	H264ENC_USER3_INTRABIAS_OPTIONS		\
 	H264ENC_USER3_DIRECTBIAS_OPTIONS		\
-	H264ENC_AU_TYPE_OPTIONS
+	H264ENC_AU_TYPE_OPTIONS				\
+	H264ENC_ABS_BR_OPTIONS				\
+	H264ENC_REPEAT_PSKIP_OPTIONS		\
+	H264ENC_REPEAT_PSKIP_NUM_OPTIONS
 
 #define	H264_ENCODE_PARAMETER_HINTS()		\
 	H264ENC_M_HINTS		\
@@ -1321,25 +1488,34 @@ enum numeric_short_options {
 	H264ENC_QP_LIMIT_I_HINTS	\
 	H264ENC_QP_LIMIT_P_HINTS	\
 	H264ENC_QP_LIMIT_B_HINTS	\
+	H264ENC_QP_LIMIT_Q_HINTS	\
 	H264ENC_ADAPT_QP_HINTS		\
 	H264ENC_I_QP_REDUCE_HINTS	\
 	H264ENC_P_QP_REDUCE_HINTS	\
+	H264ENC_Q_QP_REDUCE_HINTS	\
+	H264ENC_LOG_Q_NUM_PLUS_1_HINTS \
 	H264ENC_SKIP_FRAME_HINTS	\
+	H264ENC_MAX_I_SIZE_KB_HINTS	\
 	H264ENC_MB_ROWS_HINTS		\
 	H264ENC_QM_DELTA_HINTS		\
 	H264ENC_QM_MODE_HINTS		\
 	H264ENC_DEBLOCKING_ALPHA_HINTS		\
 	H264ENC_DEBLOCKING_BETA_HINTS		\
 	H264ENC_DEBLOCKING_ENABLE_HINTS	\
+	H264ENC_FRAME_CORP_LEFT_HINTS		\
+	H264ENC_FRAME_CORP_RIGHT_HINTS		\
+	H264ENC_FRAME_CORP_TOP_HINTS		\
+	H264ENC_FRAME_CORP_BOTTOM_HINTS		\
 	H264ENC_PROFILE_HINTS		\
 	H264ENC_INTLC_IFRAME_HINTS	\
 	H264ENC_MV_IMPROVE_HINTS	\
-	H264ENC_IMPROVE_HINTS		\
-	H264ENC_LTERM_INTVL_HINTS	\
+	H264ENC_FLAT_AREA_IMPROVE_HINTS		\
+	H264ENC_FAST_SEEK_INTVL_HINTS	\
 	H264ENC_MULTI_REFP_HINTS	\
 	H264ENC_MAX_GOPM_HINTS		\
 	H264ENC_FORCE_SEEK_HINTS	\
 	H264ENC_FRAME_DROP_HINTS	\
+	H264ENC_FRAME_DROP_REPEAT_ENABLE_HINTS	\
 	H264ENC_INTRABIAS_P_HINTS	\
 	H264ENC_INTRABIAS_B_HINTS	\
 	H264ENC_USER1_INTRABIAS_HINTS	\
@@ -1348,7 +1524,10 @@ enum numeric_short_options {
 	H264ENC_USER2_DIRECTBIAS_HINTS	\
 	H264ENC_USER3_INTRABIAS_HINTS	\
 	H264ENC_USER3_DIRECTBIAS_HINTS	\
-	H264ENC_AU_TYPE_HINTS
+	H264ENC_AU_TYPE_HINTS			\
+	H264ENC_ABS_BR_HINTS			\
+	H264ENC_REPEAT_PSKIP_HINTS		\
+	H264ENC_REPEAT_PSKIP_NUM_HINTS
 
 #define	H264_ENCODE_INIT_PARAMETERS()		\
 	case 'M':\
@@ -1430,6 +1609,16 @@ enum numeric_short_options {
 			qp_limit_param[current_stream].qp_max_b = max_value;\
 			qp_limit_param[current_stream].qp_b_flag = 1;\
 			break;\
+	case CHANGE_QP_LIMIT_Q:\
+			VERIFY_STREAMID(current_stream);\
+			if (get_two_unsigned_int(optarg, &min_value, &max_value, '~') < 0) {\
+				return -1;\
+			}\
+			qp_limit_changed_id |= (1 << current_stream);\
+			qp_limit_param[current_stream].qp_min_q = min_value;\
+			qp_limit_param[current_stream].qp_max_q = max_value;\
+			qp_limit_param[current_stream].qp_q_flag = 1;\
+			break;\
 	case CHANGE_ADAPT_QP:\
 			VERIFY_STREAMID(current_stream);\
 			qp_limit_changed_id |= (1 << current_stream);\
@@ -1448,12 +1637,30 @@ enum numeric_short_options {
 			qp_limit_param[current_stream].p_qp_reduce = atoi(optarg);\
 			qp_limit_param[current_stream].p_qp_reduce_flag = 1;\
 			break;\
+	case CHANGE_Q_QP_REDUCE:\
+			VERIFY_STREAMID(current_stream);\
+			qp_limit_changed_id |= (1 << current_stream);\
+			qp_limit_param[current_stream].q_qp_reduce = atoi(optarg);\
+			qp_limit_param[current_stream].q_qp_reduce_flag = 1;\
+			break;\
+	case CHANGE_LOG_Q_NUM_PLUS_1:\
+			VERIFY_STREAMID(current_stream);\
+			qp_limit_changed_id |= (1 << current_stream);\
+			qp_limit_param[current_stream].log_q_num_plus_1 = atoi(optarg);\
+			qp_limit_param[current_stream].log_q_num_plus_1_flag = 1;\
+			break;\
 	case CHANGE_SKIP_FRAME_MODE:\
 			VERIFY_STREAMID(current_stream);\
 			qp_limit_changed_id |= (1 << current_stream);\
 			qp_limit_param[current_stream].skip_frame = atoi(optarg);\
 			qp_limit_param[current_stream].skip_frame_flag = 1;\
 			break;\
+	case CHANGE_MAX_I_SIZE_KB:\
+			VERIFY_STREAMID(current_stream);\
+			qp_limit_changed_id |= (1 << current_stream);\
+			qp_limit_param[current_stream].max_i_size_KB = atoi(optarg);\
+			qp_limit_param[current_stream].max_i_size_KB_flag = 1;\
+			break;\
 	case CHANGE_INTRA_MB_ROWS:\
 			VERIFY_STREAMID(current_stream);\
 			intra_mb_rows[current_stream] = atoi(optarg);\
@@ -1482,22 +1689,63 @@ enum numeric_short_options {
 			break;\
 	case DEBLOCKING_ALPHA:\
 			VERIFY_STREAMID(current_stream);\
+			if (atoi(optarg) > 6 || atoi(optarg) < -6) {\
+				printf("Invalid param for alpha, range [-6~6].\n");\
+				return -1;\
+			}\
 			encode_param[current_stream].h264_param.h264_deblocking_filter_alpha = atoi(optarg);\
 			encode_param[current_stream].h264_param.h264_deblocking_filter_alpha_flag = 1;\
 			encode_param_changed_id |= (1 << current_stream);\
 			break;\
 	case DEBLOCKING_BETA:\
 			VERIFY_STREAMID(current_stream);\
+			if (atoi(optarg) > 6 || atoi(optarg) < -6) {\
+				printf("Invalid param for beta, range [-6~6].\n");\
+				return -1;\
+			}\
 			encode_param[current_stream].h264_param.h264_deblocking_filter_beta = atoi(optarg);\
 			encode_param[current_stream].h264_param.h264_deblocking_filter_beta_flag = 1;\
 			encode_param_changed_id |= (1 << current_stream);\
 			break;\
 	case DEBLOCKING_ENABLE:\
 			VERIFY_STREAMID(current_stream);\
-			encode_param[current_stream].h264_param.h264_deblocking_filter_enable = atoi(optarg);\
+			min_value = atoi(optarg);\
+			if (min_value > 2) {\
+				printf("Invalid param for loop filter, range [0|1|2].\n");\
+				return -1;\
+			}\
+			encode_param[current_stream].h264_param.h264_deblocking_filter_enable = min_value;\
 			encode_param[current_stream].h264_param.h264_deblocking_filter_enable_flag = 1;\
 			encode_param_changed_id |= (1 << current_stream);\
 			break;\
+	case LEFT_FRAME_CROP:\
+			VERIFY_STREAMID(current_stream);\
+			min_value = atoi(optarg);\
+			encode_param[current_stream].h264_param.h264_frame_crop_left_offset = min_value;\
+			encode_param[current_stream].h264_param.h264_frame_crop_left_offset_flag = 1;\
+			encode_param_changed_id |= (1 << current_stream);\
+			break;\
+	case RIGHT_FRAME_CROP:\
+			VERIFY_STREAMID(current_stream);\
+			min_value = atoi(optarg);\
+			encode_param[current_stream].h264_param.h264_frame_crop_right_offset = min_value;\
+			encode_param[current_stream].h264_param.h264_frame_crop_right_offset_flag = 1;\
+			encode_param_changed_id |= (1 << current_stream);\
+			break;\
+	case TOP_FRAME_CROP:\
+			VERIFY_STREAMID(current_stream);\
+			min_value = atoi(optarg);\
+			encode_param[current_stream].h264_param.h264_frame_crop_top_offset = min_value;\
+			encode_param[current_stream].h264_param.h264_frame_crop_top_offset_flag = 1;\
+			encode_param_changed_id |= (1 << current_stream);\
+			break;\
+	case BOTTOM_FRAME_CROP:\
+			VERIFY_STREAMID(current_stream);\
+			min_value = atoi(optarg);\
+			encode_param[current_stream].h264_param.h264_frame_crop_bottom_offset = min_value;\
+			encode_param[current_stream].h264_param.h264_frame_crop_bottom_offset_flag = 1;\
+			encode_param_changed_id |= (1 << current_stream);\
+			break;\
 	case SPECIFY_PROFILE_LEVEL:\
 			VERIFY_STREAMID(current_stream);\
 			encode_param[current_stream].h264_param.h264_profile_level = atoi(optarg);\
@@ -1514,25 +1762,25 @@ enum numeric_short_options {
 			break;\
 	case SPECIFY_MV_THRESHOLD:\
 			VERIFY_STREAMID(current_stream);\
-			encode_param[current_stream].h264_param.h264_mv_threshold = atoi(optarg);\
+			encode_param[current_stream].h264_param.h264_mv_threshold = !!(atoi(optarg));\
 			encode_param[current_stream].h264_param.h264_mv_threshold_flag = 1;\
 			encode_param_changed_id |= (1 << current_stream);\
 			break;\
-	case SPECIFY_ENC_IMPROVE:\
+	case SPECIFY_FLAT_AREA_IMPROVE:\
 			VERIFY_STREAMID(current_stream);\
 			min_value = atoi(optarg);\
 			if (min_value > 1) {\
 				printf("Invalid param for encode improve option [0|1].\n");\
 				return -1;\
 			}\
-			encode_param[current_stream].h264_param.h264_enc_improve = min_value;\
-			encode_param[current_stream].h264_param.h264_enc_improve_flag = 1;\
+			encode_param[current_stream].h264_param.h264_flat_area_improve = min_value;\
+			encode_param[current_stream].h264_param.h264_flat_area_improve_flag = 1;\
 			encode_param_changed_id |= (1 << current_stream);\
 			break;\
-	case SPECIFY_LONG_TERM_INTVL:\
+	case SPECIFY_FAST_SEEK_INTVL:\
 			VERIFY_STREAMID(current_stream);\
-			encode_param[current_stream].h264_param.h264_long_term_intvl = atoi(optarg);\
-			encode_param[current_stream].h264_param.h264_long_term_intvl_flag = 1;\
+			encode_param[current_stream].h264_param.h264_fast_seek_intvl = atoi(optarg);\
+			encode_param[current_stream].h264_param.h264_fast_seek_intvl_flag = 1;\
 			encode_param_changed_id |= (1 << current_stream);\
 			break;\
 	case SPECIFY_MULTI_REF_P:\
@@ -1567,6 +1815,12 @@ enum numeric_short_options {
 			encode_param[current_stream].h264_param.h264_drop_frames_flag = 1;\
 			encode_param_changed_id |= (1 << current_stream);\
 			break;\
+	case SPECIFY_FRAME_DROP_REPEAT_ENABLE:\
+			VERIFY_STREAMID(current_stream);\
+			encode_param[current_stream].h264_param.h264_drop_frame_repeat_enable = !!(atoi(optarg));\
+			encode_param[current_stream].h264_param.h264_drop_frames_flag = 1;\
+			encode_param_changed_id |= (1 << current_stream);\
+			break;\
 	case SPECIFY_INTRABIAS_P:\
 			VERIFY_STREAMID(current_stream);\
 			encode_param[current_stream].h264_param.h264_intrabias_p = atoi(optarg);\
@@ -1620,9 +1874,34 @@ enum numeric_short_options {
 			encode_param[current_stream].h264_param.au_type = atoi(optarg);\
 			encode_param[current_stream].h264_param.au_type_flag = 1;\
 			encode_param_changed_id |= (1 << current_stream);\
+			break;\
+	case SPECIFY_ABS_BR_FLAG:\
+			VERIFY_STREAMID(current_stream);\
+			min_value = atoi(optarg);\
+			if (min_value != 0 && min_value != 1) {\
+				printf("Invalid value [%d], must be in [0|1].\n", min_value);\
+				return -1;\
+			}\
+			encode_param[current_stream].h264_param.h264_abs_br = min_value;\
+			encode_param[current_stream].h264_param.h264_abs_br_flag = 1;\
+			encode_param_changed_id |= (1 << current_stream);\
+			break;\
+	case SPECIFY_FORCE_PSKIP_REPEAT:\
+			VERIFY_STREAMID(current_stream);\
+			encode_param[current_stream].h264_param.force_pskip_repeat_enable = !!(atoi(optarg));\
+			encode_param[current_stream].h264_param.force_pskip_flag = 1;\
+			encode_param_changed_id |= (1 << current_stream);\
+			break;\
+	case SPECIFY_REPEAT_PSKIP_NUM:\
+			VERIFY_STREAMID(current_stream);\
+			min_value = atoi(optarg);\
+			if (min_value < 0 || min_value > 254) {\
+				printf("Invalid value [%d], must be [0~254].\n", min_value);\
+				return -1;\
+			}\
+			encode_param[current_stream].h264_param.force_pskip_repeat_num = min_value;\
 			break;
 
-
 /***************************************************************
 	PANIC command line options
 ****************************************************************/
@@ -1789,7 +2068,7 @@ enum numeric_short_options {
 #define	SYSTEM_NOPREVIEW_OPTIONS	\
 	{"nopreview",	NO_ARG,		0,	NO_PREVIEW},
 #define	SYSTEM_NOPREVIEW_HINTS		\
-	{"",			"\t\tdo not enter preview\n"},
+	{"",			"\t\tdo not enter preview"},
 
 //put system to IDLE  (turn off all encoding )
 #define	SYSTEM_IDLE_OPTIONS			\
@@ -1805,7 +2084,7 @@ enum numeric_short_options {
 			"\n\t\t\t\t3: Single region warp mode, 4: Advanced ISO mode,"	\
 		"\n\t\t\t\t5: HDR line interleaved mode, 6: High MP (low delay) mode,"	\
 		"\n\t\t\t\t7: Full FPS (low delay) mode, 8: Multiple VIN mode,"			\
-			"\n\t\t\t\t9: HISO video mode\n"},
+			"\n\t\t\t\t9: HISO video mode"},
 
 #define	SYSTEM_ENC_ROTATE_OPTIONS	\
 	{"enc-rotate-possible",		HAS_ARG,	0,	SPECIFY_ROTATE_POSSIBLE},
@@ -1827,6 +2106,11 @@ enum numeric_short_options {
 #define	SYSTEM_LENS_WARP_HINTS		\
 	{"0|1",		"\tEnable Lens warp"},
 
+#define	SYSTEM_MAX_ENC_NUM_OPTIONS		\
+	{"max-enc-num",		HAS_ARG,	0,	SPECIFY_MAX_ENC_NUM},
+#define	SYSTEM_MAX_ENC_NUM_HINTS		\
+	{"2~4",		"\tSpecify max encode stream num for current mode"},
+
 #define	SYSTEM_WARP_IN_MAXWIDTH_OPTIONS		\
 	{"max-warp-in-width",		HAS_ARG,	0,	'w'},
 #define	SYSTEM_WARP_IN_MAXWIDTH_HINTS			\
@@ -1840,12 +2124,12 @@ enum numeric_short_options {
 #define	SYSTEM_WARP_OUT_MAXWIDTH_OPTIONS		\
 	{"max-warp-out-width",	HAS_ARG,	0,	'W'},
 #define	SYSTEM_WARP_OUT_MAXWIDTH_HINTS		\
-	{">0",					"Max warp output width\n"},
+	{">0",					"Max warp output width"},
 
 #define	SYSTEM_PADDING_MAXWIDTH_OPTIONS		\
 	{"max-padding-width",		HAS_ARG,	0,	SPECIFY_MAX_PADDING_WIDTH},
 #define	SYSTEM_PADDING_MAXWIDTH_HINTS			\
-	{">0",					"Max padding width\n"},
+	{">0",					"Max padding width"},
 
 #define	SYSTEM_INTERMEDIATE_OPTIONS				\
 	{"intermediate",	HAS_ARG,	0,	SPECIFY_INTERMEDIATE_BUF_SIZE},
@@ -1862,6 +2146,11 @@ enum numeric_short_options {
 #define	SYSTEM_LONG_REF_ENABLE_HINTS			\
 	{"0|1",					"Disable/Enable stream long term reference frame"},
 
+#define	SYSTEM_LONG_REF_B_FRAME_OPTIONS			\
+	{"long-ref-B-frame", 		HAS_ARG,	0,	SPECIFY_LONG_REF_B_FRAME},
+#define	SYSTEM_LONG_REF_B_FRAME_HINTS			\
+	{"0|1", 				"Disable/Enable B frame in long term reference case for all streams"},
+
 #define	SYSTEM_DSP_PARTITION_MAP_OPTIONS		\
 	{"dsp-partition-map", 		HAS_ARG,	0,	SPECIFY_DSP_PARTITION_MAP},
 #define	SYSTEM_DSP_PARTITION_MAP_HINTS			\
@@ -1889,7 +2178,7 @@ enum numeric_short_options {
 #define	SYSTEM_EIS_DELAY_COUNT_OPTIONS		\
 	{"eis-delay-count",HAS_ARG,	0,	SPECIFY_EIS_DELAY_COUNT},
 #define	SYSTEM_EIS_DELAY_COUNT_HINTS		\
-	{"0~2", 			"\tEIS delay count"},
+	{"0~2", 			"EIS delay count"},
 
 #define	SYSTEM_ME0_SCALE_OPTIONS	\
 	{"me0-scale", HAS_ARG,	0,	SPECIFY_ME0_SCALE},
@@ -1929,12 +2218,28 @@ enum numeric_short_options {
 #define	SYSTEM_IDSP_DUMP_CFG_OPTIONS	\
 	{"dump-idsp-cfg",	NO_ARG,		0,	DUMP_IDSP_CONFIG},
 #define	SYSTEM_IDSP_DUMP_CFG_HINTS		\
-	{"",				"\tdump iDSP config for debug purpose\n"},
+	{"",				"\tdump iDSP config for debug purpose"},
 
 #define	SYSTEM_OSD_MIXER_OPTIONS		\
 	{"osd-mixer",		HAS_ARG,	0,	SPECIFY_OSD_MIXER},
 #define	SYSTEM_OSD_MIXER_HINTS				\
-	{"off|a|b",		"OSD blending mixer, off: disable, a: select from VOUTA, b: select from VOUTB\n"},
+	{"off|a|b",		"OSD blending mixer, off: disable, a: select from VOUTA, b: select from VOUTB"},
+
+#define	SYSTEM_OVERFLOW_PROTECTION_OPTIONS	\
+	{"overflow-protection",		HAS_ARG,	0,	SPECIFY_OVERFLOW_PROTECTION},
+#define	SYSTEM_OVERFLOW_PROTECTION_HINTS		\
+	{"0|1",			"Disable/Enable vin overflow protection\n"},
+
+#define	SYSTEM_DSP_CLOCK_STATE_OPTIONS	\
+	{"disable-dsp-clock",		HAS_ARG,	0,	SPECIFY_DSP_CLCOK_STATE},
+#define	SYSTEM_DSP_CLOCK_STATE_HINTS		\
+	{"0|1",			"set DSP clock state. 0: Normal, 1: Off, Default is 0."},
+
+#define	SYSTEM_EXTRA_TOP_ROW_BUF_OPTIONS	\
+	{"top-row-buf",			HAS_ARG,	0,	SPECIFY_EXTRA_TOP_RAW_BUF},
+#define	SYSTEM_EXTRA_TOP_ROW_BUF_HINTS	\
+	{"0|1",	"\tAdd extra 16 lines buf in source buffer to improve encode efficiency for rotate case."	\
+	"\n\t\t\t\tDefault is 0. 0: disable, 1: enable."},
 
 #define	SYSTEM_LONG_OPTIONS()		\
 	SYSTEM_NOPREVIEW_OPTIONS			\
@@ -1944,6 +2249,7 @@ enum numeric_short_options {
 	SYSTEM_RAW_CAPTURE_OPTIONS			\
 	SYSTEM_HDR_EXPO_OPTIONS				\
 	SYSTEM_LENS_WARP_OPTIONS				\
+	SYSTEM_MAX_ENC_NUM_OPTIONS			\
 	SYSTEM_WARP_IN_MAXWIDTH_OPTIONS		\
 	SYSTEM_WARP_IN_MAXHEIGHT_OPTIONS		\
 	SYSTEM_WARP_OUT_MAXWIDTH_OPTIONS		\
@@ -1951,6 +2257,7 @@ enum numeric_short_options {
 	SYSTEM_INTERMEDIATE_OPTIONS			\
 	SYSTEM_ENC_DUMMY_LATENCY_OPTIONS		\
 	SYSTEM_LONG_REF_ENABLE_OPTIONS			\
+	SYSTEM_LONG_REF_B_FRAME_OPTIONS			\
 	SYSTEM_DSP_PARTITION_MAP_OPTIONS		\
 	SYSTEM_IDSP_UPSAMPLE_TYPE_OPTIONS		\
 	SYSTEM_MCTF_PM_OPTIONS					\
@@ -1964,7 +2271,10 @@ enum numeric_short_options {
 	SYSTEM_EFM_BUG_NUM_OPTIONS			\
 	SYSTEM_EFM_SIZE_OPTIONS					\
 	SYSTEM_IDSP_DUMP_CFG_OPTIONS			\
-	SYSTEM_OSD_MIXER_OPTIONS
+	SYSTEM_OSD_MIXER_OPTIONS				\
+	SYSTEM_OVERFLOW_PROTECTION_OPTIONS		\
+	SYSTEM_DSP_CLOCK_STATE_OPTIONS			\
+	SYSTEM_EXTRA_TOP_ROW_BUF_OPTIONS
 
 #define	SYSTEM_PARAMETER_HINTS()		\
 	SYSTEM_NOPREVIEW_HINTS		\
@@ -1974,6 +2284,7 @@ enum numeric_short_options {
 	SYSTEM_RAW_CAPTURE_HINTS	\
 	SYSTEM_HDR_EXPO_HINTS		\
 	SYSTEM_LENS_WARP_HINTS		\
+	SYSTEM_MAX_ENC_NUM_HINTS	\
 	SYSTEM_WARP_IN_MAXWIDTH_HINTS		\
 	SYSTEM_WARP_IN_MAXHEIGHT_HINTS	\
 	SYSTEM_WARP_OUT_MAXWIDTH_HINTS	\
@@ -1981,6 +2292,7 @@ enum numeric_short_options {
 	SYSTEM_INTERMEDIATE_HINTS			\
 	SYSTEM_ENC_DUMMY_LATENCY_HINTS	\
 	SYSTEM_LONG_REF_ENABLE_HINTS		\
+	SYSTEM_LONG_REF_B_FRAME_HINTS		\
 	SYSTEM_DSP_PARTITION_MAP_HINTS		\
 	SYSTEM_IDSP_UPSAMPLE_TYPE_HINTS	\
 	SYSTEM_MCTF_PM_HINTS		\
@@ -1994,7 +2306,10 @@ enum numeric_short_options {
 	SYSTEM_EFM_BUG_NUM_HINTS	\
 	SYSTEM_EFM_SIZE_HINTS		\
 	SYSTEM_IDSP_DUMP_CFG_HINTS	\
-	SYSTEM_OSD_MIXER_HINTS
+	SYSTEM_OSD_MIXER_HINTS		\
+	SYSTEM_OVERFLOW_PROTECTION_HINTS	\
+	SYSTEM_DSP_CLOCK_STATE_HINTS		\
+	SYSTEM_EXTRA_TOP_ROW_BUF_HINTS
 
 #define	SYSTEM_INIT_PARAMETERS()		\
 	case NO_PREVIEW:\
@@ -2055,6 +2370,16 @@ enum numeric_short_options {
 			system_resource_setup.lens_warp_flag = 1;\
 			system_resource_limit_changed_flag = 1;\
 			break;\
+	case SPECIFY_MAX_ENC_NUM:\
+			min_value = atoi(optarg);\
+			if (min_value > MAX_ENCODE_STREAM_NUM) {\
+				printf("Invalid param for max-enc-num option [2~4].\n");\
+				return -1;\
+			}\
+			system_resource_setup.max_enc_num = min_value;\
+			system_resource_setup.max_enc_num_flag = 1;\
+			system_resource_limit_changed_flag = 1;\
+			break;\
 	case 'w':\
 			min_value = atoi(optarg);\
 			system_resource_setup.max_warp_input_width = min_value;\
@@ -2105,6 +2430,17 @@ enum numeric_short_options {
 			system_resource_setup.stream_long_ref_enable_flag[current_stream] = 1;\
 			system_resource_limit_changed_flag = 1;\
 			break;\
+	case SPECIFY_LONG_REF_B_FRAME:\
+			min_value = atoi(optarg);\
+			if (min_value > 1) {\
+				printf("Invalid param for long ref B frame option [0|1].\n");\
+				return -1;\
+			}\
+			system_resource_setup.long_ref_b_frame\
+				= min_value;\
+			system_resource_setup.long_ref_b_frame_flag = 1;\
+			system_resource_limit_changed_flag = 1;\
+			break;\
 	case SPECIFY_DSP_PARTITION_MAP:\
 			min_value = get_u32_map_arg(optarg);\
 			if (min_value < 0 || min_value >= (1 << IAV_DSP_SUB_BUF_NUM)) {\
@@ -2227,6 +2563,36 @@ enum numeric_short_options {
 			if (system_resource_setup.osd_mixer < 0)\
 				return -1;\
 			system_resource_setup.osd_mixer_changed_flag = 1;\
+			system_resource_limit_changed_flag = 1;\
+			break;\
+	case SPECIFY_OVERFLOW_PROTECTION:\
+			min_value = atoi(optarg);\
+			if (min_value > 1) {\
+				printf("Invalid param for vin overflow protection [0|1].\n");\
+				return -1;\
+			}\
+			system_resource_setup.vin_overflow_protection= min_value;\
+			system_resource_setup.vin_overflow_protection_flag= 1;\
+			system_resource_limit_changed_flag = 1;\
+			break;\
+	case SPECIFY_DSP_CLCOK_STATE:\
+			min_value = atoi(optarg);\
+			if (min_value > 1) {\
+				printf("Invalid value [%d] for 'disable-dsp-clock' option.\n", min_value);\
+				return -1;\
+			}\
+			dsp_clock_state_disable = min_value;\
+			dsp_clock_state_disable_flag = 1;\
+			break;\
+	case SPECIFY_EXTRA_TOP_RAW_BUF:\
+			min_value = atoi(optarg);\
+			if (min_value > 1) {\
+				printf("Invalid param for extra top row buf option [0|1].\n");\
+				return -1;\
+			}\
+			system_resource_setup.extra_top_row_buf = min_value;\
+			system_resource_setup.extra_top_row_buf_flag = 1;\
+			system_resource_limit_changed_flag = 1;\
 			break;
 
 /***************************************************************
@@ -2261,7 +2627,7 @@ enum numeric_short_options {
 #define	SOURCE_BTYPE_OPTIONS			\
 	{"btype",			HAS_ARG,	0,	SPECIFY_BUFFER_TYPE},
 #define	SOURCE_BTYPE_HINTS			\
-	{"enc|prev",		"\tspecify source buffer type"},
+	{"enc|prev|off",		"\tspecify source buffer type"},
 
 #define	SOURCE_BSIZE_OPTIONS			\
 	{"bsize",			HAS_ARG,	0,	SPECIFY_BUFFER_SIZE},
@@ -2293,6 +2659,16 @@ enum numeric_short_options {
 	{"extra-buf",		HAS_ARG,	0,	SPECIFY_EXTRA_DRAM_BUF},
 #define	SOURCE_EXTRABUF_HINTS	{"0~3", "\tSet extra DRAM buffer number for extremely heavy load cases."},
 
+#define	SOURCE_DUMP_INTERVAL_OPTIONS		\
+	{"vca-dump-interval",		HAS_ARG,	0,	SPECIFY_VCA_DUMP_INTERVAL},
+#define	SOURCE_DUMP_INTERVAL_HINTS	{"0~N", "Capture one frame every N frame in VCA buffer. "	\
+	"0: off, 1: every frame, 2: half frame, N < VIN_FPS."},
+
+#define	SOURCE_DUMP_DURATION_OPTIONS		\
+	{"vca-dump-duration",		HAS_ARG,	0,	SPECIFY_VCA_DUMP_DURATION},
+#define	SOURCE_DUMP_DURATION_HINTS	{"0~32", "Set the duration of vca dump frames, "	\
+	"DSP will stop dumping after 'duration' frames. "},
+
 #define	SOURCE_BUFFER_LONG_OPTIONS()		\
 	SOURCE_PREMAIN_OPTIONS		\
 	SOURCE_MAINBUF_OPTIONS		\
@@ -2305,7 +2681,9 @@ enum numeric_short_options {
 	SOURCE_BINSIZE_OPTIONS		\
 	SOURCE_BINOFFSET_OPTIONS	\
 	SOURCE_PREWARP_OPTIONS	\
-	SOURCE_EXTRABUF_OPTIONS
+	SOURCE_EXTRABUF_OPTIONS	\
+	SOURCE_DUMP_INTERVAL_OPTIONS	\
+	SOURCE_DUMP_DURATION_OPTIONS
 
 #define	SOURCE_BUFFER_PARAMETER_HINTS()		\
 	SOURCE_PREMAIN_HINTS		\
@@ -2319,7 +2697,9 @@ enum numeric_short_options {
 	SOURCE_BINSIZE_HINTS		\
 	SOURCE_BINOFFSET_HINTS		\
 	SOURCE_PREWARP_HINTS		\
-	SOURCE_EXTRABUF_HINTS
+	SOURCE_EXTRABUF_HINTS		\
+	SOURCE_DUMP_INTERVAL_HINTS	\
+	SOURCE_DUMP_DURATION_HINTS
 
 #define	SOURCE_BUFFER_INIT_PARAMETERS()		\
 	case 'P':\
@@ -2400,6 +2780,25 @@ enum numeric_short_options {
 			system_resource_setup.extra_dram_buf[current_buffer] = min_value;\
 			system_resource_setup.extra_dram_buf_changed_id |= (1 << current_buffer);\
 			system_resource_limit_changed_flag = 1;\
+			break;\
+	case SPECIFY_VCA_DUMP_INTERVAL:\
+			VERIFY_BUFFERID(current_buffer);\
+			min_value = atoi(optarg);\
+			source_buffer_format[current_buffer].dump_interval = min_value;\
+			source_buffer_format[current_buffer].dump_interval_flag = 1;\
+			source_buffer_format_changed_id |= (1 << current_buffer);\
+			break;\
+	case SPECIFY_VCA_DUMP_DURATION:\
+			VERIFY_BUFFERID(current_buffer);\
+			min_value = atoi(optarg);\
+			if (min_value < 0 || min_value > MAX_NUM_VCA_DUMP_DURATION) {\
+				printf("Invalid value [%d], valid range [0~32].\n",\
+					min_value);\
+				return -1;\
+			}\
+			source_buffer_format[current_buffer].dump_duration = min_value;\
+			source_buffer_format[current_buffer].dump_duration_flag = 1;\
+			source_buffer_format_changed_id |= (1 << current_buffer);\
 			break;
 
 /***************************************************************
@@ -2461,6 +2860,11 @@ enum numeric_short_options {
 #define	SHOW_CMD_EXAM_HINTS				\
 	{"",						"\tShow example command info"},
 
+#define	SHOW_QP_HIST_OPTIONS			\
+	{"show-qp-hist",		NO_ARG,		0,	SHOW_QP_HIST},
+#define	SHOW_QP_HIST_HINTS				\
+	{"",						"\tShow QP histogram\n"},
+
 #define	SHOW_ALL_INFO_OPTIONS			\
 	{"show-all-info",			NO_ARG,		0,	SHOW_ALL_INFO},
 #define	SHOW_ALL_INFO_HINTS				\
@@ -2478,6 +2882,7 @@ enum numeric_short_options {
 	SHOW_DRAM_LAYOUT_OPTIONS		\
 	SHOW_FEATURE_SET_OPTIONS		\
 	SHOW_CMD_EXAM_OPTIONS			\
+	SHOW_QP_HIST_OPTIONS			\
 	SHOW_ALL_INFO_OPTIONS
 
 #define	SHOW_PARAMETER_HINTS()		\
@@ -2492,6 +2897,7 @@ enum numeric_short_options {
 	SHOW_DRAM_LAYOUT_HINTS		\
 	SHOW_FEATURE_SET_HINTS			\
 	SHOW_CMD_EXAM_HINTS			\
+	SHOW_QP_HIST_HINTS			\
 	SHOW_ALL_INFO_HINTS
 
 #define	SHOW_INIT_PARAMETERS()		\
@@ -2506,6 +2912,7 @@ enum numeric_short_options {
 	case SHOW_DRAM_LAYOUT:\
 	case SHOW_FEATURE_SET:\
 	case SHOW_CMD_EXAMPLES:\
+	case SHOW_QP_HIST:\
 			show_info_flag |= (1 << (ch - SHOW_SYSTEM_STATE));\
 			break;\
 	case SHOW_ALL_INFO:\
@@ -2534,8 +2941,8 @@ enum numeric_short_options {
 #define	DEBUG_CHIP_ID_OPTIONS		\
 	{"debug-chip-id",	HAS_ARG, 0,	SPECIFY_DEBUG_CHIP_ID},
 #define	DEBUG_CHIP_ID_HINTS			\
-	{"-1~8",			"Specify Chip ID in debug mode. 0: S2L22M, 1: S2L33M, 2: S2L55M, 3: S2L99M,"\
-	"\n\t\t\t\t4: S2L63, 5: S2L66, 6: S2L88, 7: S2L99, 8: Test, -1: disable this debug option"},
+	{"-1~11",			"Specify Chip ID in debug mode. 0: S2L22M, 1: S2L33M, 2: S2L55M, 3: S2L99M,"\
+	"\n\t\t\t\t4: S2L63, 5: S2L66, 6: S2L88, 7: S2L99, 8: Test, 9: S2L22, 10: S2L33MEX, 11: S2L33EX, -1: disable this debug option"},
 
 #define	DEBUG_WAIT_OPTIONS			\
 	{"wait",	NO_ARG, 0,	SPECIFY_DEBUG_WAIT_FRAME},
@@ -2715,13 +3122,13 @@ static const struct hint_s hint[] = {
 	DEBUG_PARAMETER_HINTS()
 };
 
-int get_arbitrary_resolution(const char *name, int *width, int *height)
+static int get_arbitrary_resolution(const char *name, int *width, int *height)
 {
 	sscanf(name, "%dx%d", width, height);
 	return 0;
 }
 
-int get_encode_resolution(const char *name, int *width, int *height)
+static int get_encode_resolution(const char *name, int *width, int *height)
 {
 	int i;
 
@@ -2814,7 +3221,7 @@ int get_gop_model(const char *name)
 	return -1;
 }
 
-int get_bitrate_control(const char *name)
+static int get_bitrate_control(const char *name)
 {
 	if (strcmp(name, "cbr") == 0)
 		return IAV_CBR;
@@ -2830,7 +3237,7 @@ int get_bitrate_control(const char *name)
 		return -1;
 }
 
-int get_chrome_format(const char *format, int encode_type)
+static int get_chrome_format(const char *format, int encode_type)
 {
 	int chrome = atoi(format);
 	if (chrome == 0) {
@@ -2847,10 +3254,12 @@ int get_chrome_format(const char *format, int encode_type)
 	}
 }
 
-int get_buffer_type(const char *name)
+static int get_buffer_type(const char *name)
 {
 	if (strcmp(name, "enc") == 0)
 		return IAV_SRCBUF_TYPE_ENCODE;
+	if (strcmp(name, "vca") == 0)
+		return IAV_SRCBUF_TYPE_VCA;
 	if (strcmp(name, "prev") == 0)
 		return IAV_SRCBUF_TYPE_PREVIEW;
 	if (strcmp(name, "off") == 0)
@@ -2860,7 +3269,7 @@ int get_buffer_type(const char *name)
 	return -1;
 }
 
-int get_osd_mixer_selection(const char *name)
+static int get_osd_mixer_selection(const char *name)
 {
 	if (strcmp(name, "off") == 0)
 		return OSD_BLENDING_OFF;
@@ -2873,7 +3282,7 @@ int get_osd_mixer_selection(const char *name)
 	return -1;
 }
 
-u32 get_dsp_partition_map(u32 in_map)
+static u32 get_dsp_partition_map(u32 in_map)
 {
 	u32 out_map = 0;
 
@@ -2915,7 +3324,7 @@ u32 get_dsp_partition_map(u32 in_map)
 	return out_map;
 }
 
-int check_encode_profile(int stream)
+static int check_encode_profile(int stream)
 {
 	int profile = encode_param[stream].h264_param.h264_profile_level;
 	if (profile < 0 || profile > H264_PROFILE_HIGH) {
@@ -2926,7 +3335,7 @@ int check_encode_profile(int stream)
 	return 0;
 }
 
-void usage(void)
+static void usage(void)
 {
 	int i;
 
@@ -3041,41 +3450,65 @@ static int init_param(int argc, char **argv)
 static void get_chip_id_str(u32 chip_id, char *chip_str)
 {
 	switch (chip_id) {
-		case IAV_CHIP_ID_S2L_22M:
-			strcpy(chip_str, "S2L22M");
-			break;
-		case IAV_CHIP_ID_S2L_33M:
-			strcpy(chip_str, "S2L33M");
-			break;
-		case IAV_CHIP_ID_S2L_55M:
-			strcpy(chip_str, "S2L55M");
-			break;
-		case IAV_CHIP_ID_S2L_99M:
-			strcpy(chip_str, "S2L99M");
-			break;
-		case IAV_CHIP_ID_S2L_63:
-			strcpy(chip_str, "S2L63");
-			break;
-		case IAV_CHIP_ID_S2L_66:
-			strcpy(chip_str, "S2L66");
-			break;
-		case IAV_CHIP_ID_S2L_88:
-			strcpy(chip_str, "S2L88");
-			break;
-		case IAV_CHIP_ID_S2L_99:
-			strcpy(chip_str, "S2L99");
-			break;
-		case IAV_CHIP_ID_S2L_TEST:
-			strcpy(chip_str, "S2LM_test");
-			break;
-		default:
-			strcpy(chip_str, "Unknown");
-			break;
+	case IAV_CHIP_ID_S2L_22M:
+		strcpy(chip_str, "S2L22M");
+		break;
+	case IAV_CHIP_ID_S2L_33M:
+		strcpy(chip_str, "S2L33M");
+		break;
+	case IAV_CHIP_ID_S2L_55M:
+		strcpy(chip_str, "S2L55M");
+		break;
+	case IAV_CHIP_ID_S2L_99M:
+		strcpy(chip_str, "S2L99M");
+		break;
+	case IAV_CHIP_ID_S2L_63:
+		strcpy(chip_str, "S2L63");
+		break;
+	case IAV_CHIP_ID_S2L_66:
+		strcpy(chip_str, "S2L66");
+		break;
+	case IAV_CHIP_ID_S2L_88:
+		strcpy(chip_str, "S2L88");
+		break;
+	case IAV_CHIP_ID_S2L_99:
+		strcpy(chip_str, "S2L99");
+		break;
+	case IAV_CHIP_ID_S2L_TEST:
+		strcpy(chip_str, "S2LM_test");
+		break;
+	case IAV_CHIP_ID_S2L_22:
+		strcpy(chip_str, "S2L22");
+		break;
+	case IAV_CHIP_ID_S2L_33MEX:
+		strcpy(chip_str, "S2L33MEX");
+		break;
+	case IAV_CHIP_ID_S2L_33EX:
+		strcpy(chip_str, "S2L33EX");
+		break;
+	default:
+		strcpy(chip_str, "Unknown");
+		break;
 	}
 
 	return ;
 }
 
+static void get_chip_arch_str(u32 chip_arch, char *chip_str)
+{
+	switch (chip_arch) {
+	case UCODE_ARCH_S2L:
+		strcpy(chip_str, "S2L");
+		break;
+	case UCODE_ARCH_S3L:
+		strcpy(chip_str, "S3L");
+		break;
+	default:
+		sprintf(chip_str, "Unknown(%d)", chip_arch);
+		break;
+	}
+}
+
 static int show_encode_stream_info(void)
 {
 	struct iav_stream_info info;
@@ -3159,7 +3592,11 @@ static int show_encode_stream_info(void)
 		BOLD_PRINT("\t        Format : %s\n", type_str);
 		if (format_configured) {
 			printf("\t         State : %s\n", state_str);
-			printf("\t        Source : %s source bufffer\n", source_str);
+			if (format.buf_id == IAV_SRCBUF_EFM) {
+				printf("\t        Source : EFM bufffer\n");
+			} else {
+				printf("\t        Source : %s source bufffer\n", source_str);
+			}
 			printf("\t      Duration : %d\n", format.duration);
 			printf("\t    Resolution : (%dx%d) \n",
 				format.enc_win.width,
@@ -3173,7 +3610,6 @@ static int show_encode_stream_info(void)
 				cfg.arg.fps.fps_multi, cfg.arg.fps.fps_div);
 			printf("\tAbs FPS enable : %d\n", cfg.arg.fps.abs_fps_enable);
 			printf("\t       Abs FPS : %d\n", cfg.arg.fps.abs_fps);
-			printf("\t     Snap Shot : %d\n", format.snapshot_enable);
 		}
 		printf("\n");
 	}
@@ -3192,10 +3628,11 @@ static int show_source_buffer_info(void)
 	char fps[32];
 	u32 fps_hz;
 	u32 input_width, input_height, input_offset_x, input_offset_y;
-	u32 width, height, buffer_type, i;
+	u32 width, height, buffer_type, i, dump_duration, dump_interval;
 	char state_str[16];
-	char *buffer_type_str[3] = {"off", "encode", "preview"};
+	char *buffer_type_str[4] = {"off", "encode", "preview", "vca"};
 	char *buffer_name[] = {"Main", "Second", "Third", "Fourth", "Pre-main"};
+	u32 state;
 
 	memset(&resource, 0, sizeof(resource));
 	resource.encode_mode = DSP_CURRENT_MODE;
@@ -3203,24 +3640,28 @@ static int show_source_buffer_info(void)
 	memset(&srcbuf_setup, 0, sizeof(srcbuf_setup));
 	AM_IOCTL(fd_iav, IAV_IOC_GET_SOURCE_BUFFER_SETUP, &srcbuf_setup);
 
-	memset(&video_info, 0, sizeof(video_info));
-	video_info.vsrc_id = 0;
-	video_info.info.mode = AMBA_VIDEO_MODE_CURRENT;
-	AM_IOCTL(fd_iav, IAV_IOC_VIN_GET_VIDEOINFO, &video_info);
-
-	printf("\n[VIN Capture info]:\n");
-	printf("  VIN Capture window : %dx%d\n", video_info.info.width, video_info.info.height);
-	vsrc_fps.vsrc_id = 0;
-	AM_IOCTL(fd_iav, IAV_IOC_VIN_GET_FPS, &vsrc_fps);
-	change_fps_to_hz(vsrc_fps.fps, &fps_hz, fps);
-	printf("  VIN Frame Rate : %s\n", fps);
-
-	vsrc_mode.vsrc_id = 0;
-	AM_IOCTL(fd_iav, IAV_IOC_VIN_GET_MODE, &vsrc_mode);
-	printf("  VIN Mode : %s\n", (vsrc_mode.hdr_mode == 0 ? "Linear mode" : "HDR Mode"));
-	if (vsrc_mode.hdr_mode > 0) {
-		printf("  VIN Max_act window : %dx%d\n",
-			video_info.info.max_act_width, video_info.info.max_act_height);
+	AM_IOCTL(fd_iav, IAV_IOC_GET_IAV_STATE, &state);
+	if (state != IAV_STATE_INIT) {
+		memset(&video_info, 0, sizeof(video_info));
+		video_info.vsrc_id = 0;
+		video_info.info.mode = AMBA_VIDEO_MODE_CURRENT;
+		AM_IOCTL(fd_iav, IAV_IOC_VIN_GET_VIDEOINFO, &video_info);
+
+		printf("\n[VIN Capture info]:\n");
+		printf("  VIN Capture window : %dx%d\n", video_info.info.width, video_info.info.height);
+
+		vsrc_fps.vsrc_id = 0;
+		AM_IOCTL(fd_iav, IAV_IOC_VIN_GET_FPS, &vsrc_fps);
+		change_fps_to_hz(vsrc_fps.fps, &fps_hz, fps);
+		printf("  VIN Frame Rate : %s\n", fps);
+
+		vsrc_mode.vsrc_id = 0;
+		AM_IOCTL(fd_iav, IAV_IOC_VIN_GET_MODE, &vsrc_mode);
+		printf("  VIN Mode : %s\n", (vsrc_mode.hdr_mode == 0 ? "Linear mode" : "HDR Mode"));
+		if (vsrc_mode.hdr_mode > 0) {
+			printf("  VIN Max_act window : %dx%d\n",
+				video_info.info.max_act_width, video_info.info.max_act_height);
+		}
 	}
 
 	printf("\n[Source buffer info]:\n");
@@ -3272,6 +3713,8 @@ static int show_source_buffer_info(void)
 		input_offset_y = srcbuf_setup.input[i].y;
 
 		buffer_type = srcbuf_setup.type[i];
+		dump_duration = srcbuf_setup.dump_duration[i];
+		dump_interval = srcbuf_setup.dump_interval[i];
 
 		COLOR_PRINT("%s source buffer: \n", buffer_name[i]);
 		printf("\ttype : %s \n", buffer_type_str[buffer_type]);
@@ -3280,6 +3723,11 @@ static int show_source_buffer_info(void)
 			printf("\tinput_format : %dx%d\n", input_width, input_height);
 			printf("\tinput_offset : %dx%d\n", input_offset_x, input_offset_y);
 			printf("\tstate        : %s\n", state_str);
+		} else if (buffer_type == IAV_SRCBUF_TYPE_VCA) {
+			printf("\tinput_format : %dx%d\n", input_width, input_height);
+			printf("\tinput_offset : %dx%d\n", input_offset_x, input_offset_y);
+			printf("\tvca_dump_duration : %d\n", dump_duration);
+			printf("\tvca_dump_interval : %d\n", dump_interval);
 		}
 		printf("\n");
 	}
@@ -3385,6 +3833,7 @@ static int show_resource_limit_info(void)
 			flag[resource.stream_long_ref_enable[i]]);
 	}
 
+	printf("      Long Ref B frame : %s\n", flag[resource.long_ref_b_frame]);
 	printf("             Sharpen-B : %s\n", flag[sharpen]);
 	printf("               Mixer-A : %s\n", flag[resource.mixer_a_enable]);
 	printf("               Mixer-B : %s\n", flag[resource.mixer_b_enable]);
@@ -3401,6 +3850,7 @@ static int show_resource_limit_info(void)
 	printf("        Encode RAW YUV : %s\n", flag[enc_raw_yuv]);
 	printf("             ME0 scale : %s\n", me0[resource.me0_scale]);
 	printf("     High MP stitching : %s\n", flag[resource.is_stitched]);
+	printf("   Overflow Protection : %s\n", flag[resource.vin_overflow_protection]);
 	if (enc_raw_rgb) {
 		printf("              RAW size : %dx%d\n",
 			resource.raw_size.width, resource.raw_size.height);
@@ -3434,6 +3884,7 @@ static int show_resource_limit_info(void)
 		printf("         Debug Chip ID : %s\n", chip_str);
 	}
 
+	printf("     extra top row buf : %s\n", flag[resource.extra_top_row_buf_enable]);
 	return 0;
 }
 
@@ -3441,17 +3892,39 @@ static int show_h264_encode_config(int stream_id)
 {
 	struct iav_h264_cfg h264cfg;
 	struct iav_stream_cfg streamcfg;
+	struct iav_bitrate h264_rc;
+	struct iav_h264_pskip h264_pskip;
+	struct iav_h264_frame_drop h264_frame_drop;
 	char tmp[32];
+	int tmp_abs_br_flag;
 
 	memset(tmp, 0, sizeof(tmp));
-
 	memset(&h264cfg, 0, sizeof(h264cfg));
 	h264cfg.id = stream_id;
-	AM_IOCTL(fd_iav, IAV_IOC_GET_H264_CONFIG, &h264cfg);
 	memset(&streamcfg, 0, sizeof(streamcfg));
 	streamcfg.id = stream_id;
+
+	strcpy(tmp, "H.264");
+	AM_IOCTL(fd_iav, IAV_IOC_GET_H264_CONFIG, &h264cfg);
+
+	streamcfg.cid = IAV_H264_CFG_RC_STRATEGY;
+	AM_IOCTL(fd_iav, IAV_IOC_GET_STREAM_CONFIG, &streamcfg);
+	tmp_abs_br_flag = streamcfg.arg.h264_rc_strategy.abs_br_flag;
+
 	streamcfg.cid = IAV_H264_CFG_BITRATE;
 	AM_IOCTL(fd_iav, IAV_IOC_GET_STREAM_CONFIG, &streamcfg);
+	h264_rc = streamcfg.arg.h264_rc;
+
+	streamcfg.cid = IAV_H264_CFG_FORCE_PSKIP;
+	AM_IOCTL(fd_iav, IAV_IOC_GET_STREAM_CONFIG, &streamcfg);
+	h264_pskip = streamcfg.arg.h264_pskip;
+
+	streamcfg.cid = IAV_H264_CFG_FRAME_DROP;
+	AM_IOCTL(fd_iav, IAV_IOC_GET_STREAM_CONFIG, &streamcfg);
+	h264_frame_drop = streamcfg.arg.h264_frame_drop;
+
+	BOLD_PRINT("\t%s\n", tmp);
+	memset(tmp, 0, sizeof(tmp));
 
 	switch (h264cfg.profile) {
 	case H264_PROFILE_BASELINE:
@@ -3467,31 +3940,53 @@ static int show_h264_encode_config(int stream_id)
 		strcpy(tmp, "Unknown");
 		break;
 	}
-	BOLD_PRINT0("\tH.264\n");
-	printf("\t         profile = %s\n", tmp);
-	printf("\t               M = %d\n", h264cfg.M);
-	printf("\t               N = %d\n", h264cfg.N);
-	printf("\t    idr interval = %d\n", h264cfg.idr_interval);
-	printf("\t       gop model = %s\n", (h264cfg.gop_structure == 0)? "simple":"advanced");
-	printf("\t   chrome format = %s\n", (h264cfg.chroma_format == H264_CHROMA_YUV420)?"YUV420":"MONO");
-	printf("\t    mv threshold = %d\n", h264cfg.mv_threshold);
-	printf("\t     enc improve = %d\n", h264cfg.enc_improve);
-	printf("\t long_term_intvl = %d\n", h264cfg.long_term_intvl);
-	printf("\t     multi_ref_p = %d\n", h264cfg.multi_ref_p);
-	printf("\t     intrabias_p = %d\n", h264cfg.intrabias_p);
-	printf("\t     intrabias_b = %d\n", h264cfg.intrabias_b);
-	printf("\t     vbr_setting = %d\n", streamcfg.arg.h264_rc.vbr_setting);
-	printf("\t average_bitrate = %d\n", streamcfg.arg.h264_rc.average_bitrate);
-	printf("\t        adapt_qp = %d\n", streamcfg.arg.h264_rc.adapt_qp);
-	printf("\t     i_qp_reduce = %d\n", streamcfg.arg.h264_rc.i_qp_reduce);
-	printf("\t     p_qp_reduce = %d\n", streamcfg.arg.h264_rc.p_qp_reduce);
-	printf("\t     qp_max_on_I = %d\n", streamcfg.arg.h264_rc.qp_max_on_I);
-	printf("\t     qp_min_on_I = %d\n", streamcfg.arg.h264_rc.qp_min_on_I);
-	printf("\t     qp_max_on_B = %d\n", streamcfg.arg.h264_rc.qp_max_on_B);
-	printf("\t     qp_min_on_B = %d\n", streamcfg.arg.h264_rc.qp_min_on_B);
-	printf("\t     qp_max_on_P = %d\n", streamcfg.arg.h264_rc.qp_max_on_P);
-	printf("\t     qp_min_on_P = %d\n", streamcfg.arg.h264_rc.qp_min_on_P);
-	printf("\t       skip_flag = %d\n", streamcfg.arg.h264_rc.skip_flag);
+	printf("\t             profile = %s\n", tmp);
+	printf("\t                   M = %d\n", h264cfg.M);
+	printf("\t                   N = %d\n", h264cfg.N);
+	printf("\t        idr interval = %d\n", h264cfg.idr_interval);
+	printf("\t           gop model = %s\n",
+		(h264cfg.gop_structure == 0) ? "simple":"advanced");
+	printf("\t       chrome format = %s\n",
+		(h264cfg.chroma_format == H264_CHROMA_YUV420) ? "YUV420" : "MONO");
+	printf("\t        mv threshold = %s\n", h264cfg.mv_threshold ? "Enable" : "Disable");
+	printf("\t   flat_area_improve = %d\n", h264cfg.flat_area_improve);
+	printf("\t     fast_seek_intvl = %d\n", h264cfg.fast_seek_intvl);
+	printf("\t         multi_ref_p = %d\n", h264cfg.multi_ref_p);
+	printf("\t         intrabias_p = %d\n", h264cfg.intrabias_p);
+	printf("\t         intrabias_b = %d\n", h264cfg.intrabias_b);
+	printf("\t               alpha = %d\n", h264cfg.deblocking_filter_alpha);
+	printf("\t                beta = %d\n", h264cfg.deblocking_filter_beta);
+	printf("\t         loop_filter = %d\n", h264cfg.deblocking_filter_enable);
+	printf("\t     left frame crop = %d\n", h264cfg.frame_crop_left_offset);
+	printf("\t    right frame crop = %d\n", h264cfg.frame_crop_right_offset);
+	printf("\t      top frame crop = %d\n", h264cfg.frame_crop_top_offset);
+	printf("\t   bottom frame crop = %d\n", h264cfg.frame_crop_bottom_offset);
+	printf("\t         vbr_setting = %d\n", h264_rc.vbr_setting);
+	printf("\t     average_bitrate = %d\n", h264_rc.average_bitrate);
+	printf("\t            adapt_qp = %d\n", h264_rc.adapt_qp);
+	printf("\t         i_qp_reduce = %d\n", h264_rc.i_qp_reduce);
+	printf("\t         p_qp_reduce = %d\n", h264_rc.p_qp_reduce);
+	printf("\t         q_qp_reduce = %d\n", h264_rc.q_qp_reduce);
+	printf("\t    log_q_num_plus_1 = %d\n", h264_rc.log_q_num_plus_1);
+	printf("\t         qp_max_on_I = %d\n", h264_rc.qp_max_on_I);
+	printf("\t         qp_min_on_I = %d\n", h264_rc.qp_min_on_I);
+	printf("\t         qp_max_on_B = %d\n", h264_rc.qp_max_on_B);
+	printf("\t         qp_min_on_B = %d\n", h264_rc.qp_min_on_B);
+	printf("\t         qp_max_on_P = %d\n", h264_rc.qp_max_on_P);
+	printf("\t         qp_min_on_P = %d\n", h264_rc.qp_min_on_P);
+	printf("\t         qp_max_on_Q = %d\n", h264_rc.qp_max_on_Q);
+	printf("\t         qp_min_on_Q = %d\n", h264_rc.qp_min_on_Q);
+	printf("\t           skip_flag = %d\n", h264_rc.skip_flag);
+	if (h264_rc.max_i_size_KB) {
+		printf("\t       max_i_size_KB = %d\n", h264_rc.max_i_size_KB);
+	} else {
+		printf("\t       max_i_size_KB = Disable\n");
+	}
+	printf("\t         abs_br_flag = %s\n", tmp_abs_br_flag ? "Enable" : "Disable");
+	printf("\t          pskip type = %s\n", h264_pskip.repeat_enable ? "Repeat Pskip" : "Force Pskip");
+	printf("\t    repeat pskip num = %d\n", h264_pskip.repeat_num);
+	printf("\t     frame drop type = %s\n", h264_frame_drop.repeat_enable ? "Repeat drop" : "Drop one-time");
+	printf("\t      frame drop num = %d\n", h264_frame_drop.drop_num);
 
 	return 0;
 }
@@ -3672,18 +4167,37 @@ static int show_iav_state(void)
 
 static int show_driver_info(void)
 {
+	int fd_ucode = -1;
+	ucode_version_t ucode_ver;
 	struct iav_driver_version iav_driver_info;
+	char chip_arch[16];
+
+	if ((fd_ucode = open("/dev/ucode", O_RDWR, 0)) < 0) {
+		perror("/dev/ucode");
+		return -1;
+	}
 
+	memset(&ucode_ver, 0, sizeof(ucode_ver));
+	AM_IOCTL(fd_ucode, IAV_IOC_GET_UCODE_VERSION, &ucode_ver);
 	AM_IOCTL(fd_iav, IAV_IOC_GET_DRIVER_INFO, &iav_driver_info);
 
+	get_chip_arch_str(ucode_ver.chip_arch, chip_arch);
+
 	printf("\n[IAV driver info]:\n");
 	printf("   IAV Driver Version : %s-%d.%d.%d (Last updated: %x)\n"
-		"   DSP Driver version : %d-%d\n",
+		"   DSP Driver version : %d-%d\n"
+		"        Ucode version : %s %d-%d (Last updated: %d%02d%02d)\n",
 		iav_driver_info.description, iav_driver_info.major,
 		iav_driver_info.minor, iav_driver_info.patch,
 		iav_driver_info.mod_time,
-		iav_driver_info.api_version, iav_driver_info.idsp_version);
+		iav_driver_info.api_version, iav_driver_info.idsp_version,
+		chip_arch, ucode_ver.edition_num, ucode_ver.edition_ver,
+		ucode_ver.year, ucode_ver.month, ucode_ver.day);
 
+	if (fd_ucode >= 0) {
+		close(fd_ucode);
+		fd_ucode = -1;
+	}
 
 	return 0;
 }
@@ -3724,6 +4238,12 @@ static int show_dram_layout(void)
 		buf.offset, (buf.length >> 10));
 
 	memset(&buf, 0, sizeof(buf));
+	buf.buf = IAV_BUFFER_MV;
+	AM_IOCTL(fd_iav, IAV_IOC_QUERY_BUF, &buf);
+	printf("         [MV] Base Address: [0x%08X], Size [%8d KB].\n",
+		buf.offset, (buf.length >> 10));
+
+	memset(&buf, 0, sizeof(buf));
 	buf.buf = IAV_BUFFER_OVERLAY;
 	AM_IOCTL(fd_iav, IAV_IOC_QUERY_BUF, &buf);
 	printf("    [OVERLAY] Base Address: [0x%08X], Size [%8d KB].\n",
@@ -3754,6 +4274,12 @@ static int show_dram_layout(void)
 		buf.offset, (buf.length >> 10));
 
 	memset(&buf, 0, sizeof(buf));
+	buf.buf = IAV_BUFFER_PM_MCTF;
+	AM_IOCTL(fd_iav, IAV_IOC_QUERY_BUF, &buf);
+	printf("    [PM_MCTF] Base Address: [0x%08X], Size [%8d KB].\n",
+		buf.offset, (buf.length >> 10));
+
+	memset(&buf, 0, sizeof(buf));
 	buf.buf = IAV_BUFFER_PM_BPC;
 	AM_IOCTL(fd_iav, IAV_IOC_QUERY_BUF, &buf);
 	printf("     [PM_BPC] Base Address: [0x%08X], Size [%8d KB].\n",
@@ -3772,9 +4298,9 @@ static int show_dram_layout(void)
 		buf.offset, (buf.length >> 10));
 
 	memset(&buf, 0, sizeof(buf));
-	buf.buf = IAV_BUFFER_PM_MCTF;
+	buf.buf = IAV_BUFFER_VCA;
 	AM_IOCTL(fd_iav, IAV_IOC_QUERY_BUF, &buf);
-	printf("    [PM_MCTF] Base Address: [0x%08X], Size [%8d KB].\n",
+	printf("        [VCA] Base Address: [0x%08X], Size [%8d KB].\n",
 		buf.offset, (buf.length >> 10));
 
 	memset(&buf, 0, sizeof(buf));
@@ -3870,6 +4396,14 @@ static int show_cmd_examples(void)
 		"--btype off -Y --btype enc --bsize 480p -K --btype enc --bsize 480p "
 		"-D --smaxsize 1080p --intermediate 2176x1088 ;\n\n");
 
+	COLOR_PRINT0("\nMode 2:\n");
+	printf("  (1) Basic 1080p30:\n");
+	printf("    # test_encode -i 1080p --hdr-mode 0 -V 480p --hdmi "
+		"--enc-mode 2 --hdr-expo 1 --mixer 0 -X --bsize 1080p --bmax 1080p ;\n\n");
+	printf("  (2) Advanced 1080p30 2X HDR\n");
+	printf("    # test_encode -i 1080p --hdr-mode 1 -V 480p --hdmi "
+		"--enc-mode 2 --hdr-expo 2 --mixer 0 -X --bsize 1080p --bmax 1080p ;\n\n");
+
 	COLOR_PRINT0("\nMode 4:\n");
 	printf("  (1) Advanced ISO 1080p30\n");
 	printf("    # test_encode -i 1080p --hdr-mode 0 -V 1080p --hdmi "
@@ -3898,7 +4432,49 @@ static int show_cmd_examples(void)
 	printf("  (1) Switching between HDR mode (basic HDR or advanced HDR) and "
 		"linear mode, sensor needs to do HW GPIO reset.\n");
 
-	printf("\n");
+	return 0;
+}
+
+static int print_qp_histogram(struct iav_qp_histogram *hist)
+{
+	const int entry_num = 4;
+	int i, j, index;
+	int mb_sum, qp_sum, mb_entry;
+
+	printf("====== stream [%d], PTS [%d].",
+		hist->id, hist->PTS);
+	printf("\n====== QP:MB \n");
+	mb_sum = qp_sum = 0;
+	for (i = 0; i < IAV_QP_HIST_BIN_MAX_NUM / entry_num; ++i) {
+		mb_entry = 0;
+		printf(" [Set %d] ", i);
+		for (j = 0; j < entry_num; ++j) {
+			index = i * entry_num + j;
+			printf("%2d:%-4d ", hist->qp[index], hist->mb[index]);
+			mb_entry += hist->mb[index];
+			mb_sum += hist->mb[index];
+			qp_sum += hist->qp[index] * hist->mb[index];
+		}
+		printf("[MBs: %d].\n", mb_entry);
+	}
+	printf("\n====== Total MB : %d.", mb_sum);
+	printf("\n====== Average QP : %d.\n\n", qp_sum / mb_sum);
+	return 0;
+}
+
+static int show_qp_hist(void)
+{
+	struct iav_querydesc query_desc;
+	int i;
+
+	memset(&query_desc, 0, sizeof(query_desc));
+	query_desc.qid = IAV_DESC_QP_HIST;
+
+	AM_IOCTL(fd_iav, IAV_IOC_QUERY_DESC, &query_desc);
+	printf("\nQP histogram for [%d] streams.\n\n", query_desc.arg.qphist.stream_num);
+	for (i = 0; i < query_desc.arg.qphist.stream_num; ++i) {
+		print_qp_histogram(&query_desc.arg.qphist.stream_qp_hist[i]);
+	}
 	return 0;
 }
 
@@ -3932,7 +4508,7 @@ static u32 rc_qp_for_vbr_lut[11][11] =
 	{21, 18, 17, 16, 15, 13, 12, 11, 10, 1,  1},	/* 10 Mbps */
 };
 
-int h264_calc_target_qp(u32 bitrate, u32 resolution)
+static int h264_calc_target_qp(u32 bitrate, u32 resolution)
 {
 	int i, j;
 
@@ -3959,19 +4535,22 @@ int h264_calc_target_qp(u32 bitrate, u32 resolution)
 	return rc_qp_for_vbr_lut[i][j];
 }
 
-int set_h264_encode_param(int stream)
+static int set_h264_encode_param(int stream, struct iav_stream_format *format)
 {
 	struct iav_h264_cfg h264cfg;
 	struct iav_stream_cfg cfg;
 	struct iav_bitrate bitrate;
 	struct iav_h264_gop gop;
-	struct iav_stream_format format;
+	enum iav_stream_type type = format->type;
 	u32 resolution, qp;
 	h264_param_t *param = &encode_param[stream].h264_param;
 
 	memset(&h264cfg, 0, sizeof(h264cfg));
 	h264cfg.id = stream;
-	AM_IOCTL(fd_iav, IAV_IOC_GET_H264_CONFIG, &h264cfg);
+
+	if (type == IAV_STREAM_TYPE_H264) {
+		AM_IOCTL(fd_iav, IAV_IOC_GET_H264_CONFIG, &h264cfg);
+	}
 
 	if (param->h264_M_flag)
 		h264cfg.M = param->h264_M;
@@ -3994,11 +4573,11 @@ int set_h264_encode_param(int stream)
 	if (param->h264_mv_threshold_flag)
 		h264cfg.mv_threshold = param->h264_mv_threshold;
 
-	if (param->h264_enc_improve_flag)
-		h264cfg.enc_improve = param->h264_enc_improve;
+	if (param->h264_flat_area_improve_flag)
+		h264cfg.flat_area_improve = param->h264_flat_area_improve;
 
-	if (param->h264_long_term_intvl_flag)
-		h264cfg.long_term_intvl= param->h264_long_term_intvl;
+	if (param->h264_fast_seek_intvl_flag)
+		h264cfg.fast_seek_intvl= param->h264_fast_seek_intvl;
 
 	if (param->h264_multi_ref_p_flag)
 		h264cfg.multi_ref_p = param->h264_multi_ref_p;
@@ -4040,29 +4619,74 @@ int set_h264_encode_param(int stream)
 	if (param->au_type_flag)
 		h264cfg.au_type = param->au_type;
 
-	AM_IOCTL(fd_iav, IAV_IOC_SET_H264_CONFIG, &h264cfg);
+	if (param->h264_deblocking_filter_alpha_flag) {
+		h264cfg.deblocking_filter_alpha = param->h264_deblocking_filter_alpha;
+	}
+
+	if (param->h264_deblocking_filter_beta_flag) {
+		h264cfg.deblocking_filter_beta = param->h264_deblocking_filter_beta;
+	}
+
+	if (param->h264_deblocking_filter_enable_flag) {
+		h264cfg.deblocking_filter_enable = param->h264_deblocking_filter_enable;
+	}
+
+	if (param->h264_frame_crop_left_offset_flag) {
+		h264cfg.frame_crop_left_offset = param->h264_frame_crop_left_offset;
+	}
+
+	if (param->h264_frame_crop_right_offset_flag) {
+		h264cfg.frame_crop_right_offset = param->h264_frame_crop_right_offset;
+	}
+
+	if (param->h264_frame_crop_top_offset_flag) {
+		h264cfg.frame_crop_top_offset = param->h264_frame_crop_top_offset;
+	}
+
+	if (param->h264_frame_crop_bottom_offset_flag) {
+		h264cfg.frame_crop_bottom_offset = param->h264_frame_crop_bottom_offset;
+	}
+
+	if (type == IAV_STREAM_TYPE_H264) {
+		AM_IOCTL(fd_iav, IAV_IOC_SET_H264_CONFIG, &h264cfg);
+	}
+
+	// bitrate auto sync settings
+	if (param->h264_abs_br_flag) {
+		if (type == IAV_STREAM_TYPE_H264) {
+			memset(&cfg, 0, sizeof(cfg));
+			cfg.id = stream;
+			cfg.cid = IAV_H264_CFG_RC_STRATEGY;
+			AM_IOCTL(fd_iav, IAV_IOC_GET_STREAM_CONFIG, &cfg);
+
+			cfg.arg.h264_rc_strategy.abs_br_flag = param->h264_abs_br;
+			AM_IOCTL(fd_iav, IAV_IOC_SET_STREAM_CONFIG, &cfg);
+		}
+	}
 
 	// bitrate control settings
 	memset(&cfg, 0, sizeof(cfg));
 	cfg.id = stream;
-	cfg.cid = IAV_H264_CFG_BITRATE;
-	AM_IOCTL(fd_iav, IAV_IOC_GET_STREAM_CONFIG, &cfg);
-	bitrate = cfg.arg.h264_rc;
+	if (type == IAV_STREAM_TYPE_H264) {
+		cfg.cid = IAV_H264_CFG_BITRATE;
+		AM_IOCTL(fd_iav, IAV_IOC_GET_STREAM_CONFIG, &cfg);
+		bitrate = cfg.arg.h264_rc;
+	}
 
-	format.id = stream;
-	AM_IOCTL(fd_iav, IAV_IOC_GET_STREAM_FORMAT, &format);
-	resolution = format.enc_win.width * format.enc_win.height;
+	resolution = format->enc_win.width * (format->enc_win.height);
 
 	switch (param->h264_bitrate_control) {
 	case IAV_CBR:
 		bitrate.vbr_setting = IAV_BRC_SCBR;
 		bitrate.average_bitrate = param->h264_cbr_avg_bitrate;
-		bitrate.qp_min_on_I = 1;
+		bitrate.qp_min_on_I = 14;
 		bitrate.qp_max_on_I = 51;
-		bitrate.qp_min_on_P = 1;
+		bitrate.qp_min_on_P = 17;
 		bitrate.qp_max_on_P = 51;
-		bitrate.qp_min_on_B = 1;
+		bitrate.qp_min_on_B = 21;
 		bitrate.qp_max_on_B = 51;
+		bitrate.qp_min_on_Q = 15;
+		bitrate.qp_max_on_Q = 51;
 		bitrate.skip_flag = 0;
 		break;
 
@@ -4078,6 +4702,8 @@ int set_h264_encode_param(int stream)
 		bitrate.qp_max_on_P = qp * 6 / 5;
 		bitrate.qp_min_on_B = 1;
 		bitrate.qp_max_on_B = qp * 6 / 5;
+		bitrate.qp_min_on_Q = 1;
+		bitrate.qp_max_on_Q = qp * 6 / 5;
 		bitrate.skip_flag = H264_WITH_FRAME_DROP; // enable frame dropping
 		break;
 
@@ -4093,6 +4719,8 @@ int set_h264_encode_param(int stream)
 		bitrate.qp_max_on_P = 51;
 		bitrate.qp_min_on_B = qp;
 		bitrate.qp_max_on_B = 51;
+		bitrate.qp_min_on_Q = qp;
+		bitrate.qp_max_on_Q = 51;
 		bitrate.skip_flag = 0;
 		break;
 
@@ -4108,6 +4736,8 @@ int set_h264_encode_param(int stream)
 		bitrate.qp_max_on_P = qp;
 		bitrate.qp_min_on_B = qp;
 		bitrate.qp_max_on_B = qp;
+		bitrate.qp_min_on_Q = qp;
+		bitrate.qp_max_on_Q = qp;
 		bitrate.skip_flag = H264_WITH_FRAME_DROP; // enable frame dropping
 		break;
 
@@ -4123,47 +4753,56 @@ int set_h264_encode_param(int stream)
 
 	memset(&cfg, 0, sizeof(cfg));
 	cfg.id = stream;
-	cfg.cid = IAV_H264_CFG_BITRATE;
-	cfg.arg.h264_rc = bitrate;
 	// Following configurations can be changed during encoding
 	if (param->h264_bitrate_control_flag
 		|| param->h264_cbr_bitrate_flag
 		|| param->h264_vbr_bitrate_flag) {
+		if (type == IAV_STREAM_TYPE_H264) {
+			cfg.cid = IAV_H264_CFG_BITRATE;
+			cfg.arg.h264_rc = bitrate;
+		}
 		AM_IOCTL(fd_iav, IAV_IOC_SET_STREAM_CONFIG, &cfg);
 	}
 
 	memset(&cfg, 0, sizeof(cfg));
 	cfg.id = stream;
-	cfg.cid = IAV_H264_CFG_GOP;
 	if (param->h264_N_flag || param->h264_idr_interval_flag) {
 		gop.id = stream;
 		gop.N = h264cfg.N;
 		gop.idr_interval = h264cfg.idr_interval;
-		cfg.arg.h264_gop = gop;
+
+		if (type == IAV_STREAM_TYPE_H264) {
+			cfg.cid = IAV_H264_CFG_GOP;
+			cfg.arg.h264_gop = gop;
+		}
 		AM_IOCTL(fd_iav, IAV_IOC_SET_STREAM_CONFIG, &cfg);
 	}
 
 	memset(&cfg, 0, sizeof(cfg));
 	cfg.id = stream;
-	cfg.cid = IAV_H264_CFG_ZMV_THRESHOLD;
 	if (param->h264_mv_threshold_flag) {
 		cfg.arg.mv_threshold = h264cfg.mv_threshold;
+		if (type == IAV_STREAM_TYPE_H264) {
+			cfg.cid = IAV_H264_CFG_ZMV_THRESHOLD;
+		}
 		AM_IOCTL(fd_iav, IAV_IOC_SET_STREAM_CONFIG, &cfg);
 	}
 
 	memset(&cfg, 0, sizeof(cfg));
 	cfg.id = stream;
-	cfg.cid = IAV_H264_CFG_ENC_IMPROVE;
-	if (param->h264_enc_improve_flag) {
-		cfg.arg.h264_enc_improve = h264cfg.enc_improve;
+	if (param->h264_flat_area_improve_flag) {
+		if (type == IAV_STREAM_TYPE_H264) {
+			cfg.cid = IAV_H264_CFG_FLAT_AREA_IMPROVE;
+			cfg.arg.h264_flat_area_improve = h264cfg.flat_area_improve;
+		}
 		AM_IOCTL(fd_iav, IAV_IOC_SET_STREAM_CONFIG, &cfg);
 	}
 
 	// on the fly update chrome format
 	memset(&cfg, 0, sizeof(cfg));
 	cfg.id = stream;
-	cfg.cid = IAV_STMCFG_CHROMA;
 	if (param->h264_chrome_format_flag) {
+		cfg.cid = IAV_STMCFG_CHROMA;
 		cfg.arg.chroma = h264cfg.chroma_format;
 		AM_IOCTL(fd_iav, IAV_IOC_SET_STREAM_CONFIG, &cfg);
 	}
@@ -4171,16 +4810,19 @@ int set_h264_encode_param(int stream)
 	// on the fly update frame drop
 	memset(&cfg, 0, sizeof(cfg));
 	cfg.id = stream;
-	cfg.cid = IAV_H264_CFG_FRAME_DROP;
 	if (param->h264_drop_frames_flag) {
-		cfg.arg.h264_drop_frames = param->h264_drop_frames;
+		if (type == IAV_STREAM_TYPE_H264) {
+			cfg.cid = IAV_H264_CFG_FRAME_DROP;
+			cfg.arg.h264_frame_drop.drop_num = param->h264_drop_frames;
+			cfg.arg.h264_frame_drop.repeat_enable =
+				param->h264_drop_frame_repeat_enable;
+		}
 		AM_IOCTL(fd_iav, IAV_IOC_SET_STREAM_CONFIG, &cfg);
 	}
 
 	// on the fly update enc param
 	memset(&cfg, 0, sizeof(cfg));
 	cfg.id = stream;
-	cfg.cid = IAV_H264_CFG_ENC_PARAM;
 	if (param->h264_intrabias_p_flag ||
 		param->h264_intrabias_b_flag ||
 		param->h264_user1_intra_bias_flag ||
@@ -4189,22 +4831,36 @@ int set_h264_encode_param(int stream)
 		param->h264_user2_direct_bias_flag ||
 		param->h264_user3_intra_bias_flag ||
 		param->h264_user3_direct_bias_flag) {
-		cfg.arg.h264_enc.id = stream;
-		cfg.arg.h264_enc.intrabias_p = h264cfg.intrabias_p;
-		cfg.arg.h264_enc.intrabias_b = h264cfg.intrabias_b;
-		cfg.arg.h264_enc.user1_intra_bias = h264cfg.user1_intra_bias;
-		cfg.arg.h264_enc.user1_direct_bias = h264cfg.user1_direct_bias;
-		cfg.arg.h264_enc.user2_intra_bias = h264cfg.user2_intra_bias;
-		cfg.arg.h264_enc.user2_direct_bias = h264cfg.user2_direct_bias;
-		cfg.arg.h264_enc.user3_intra_bias = h264cfg.user3_intra_bias;
-		cfg.arg.h264_enc.user3_direct_bias = h264cfg.user3_direct_bias;
+		if (type == IAV_STREAM_TYPE_H264) {
+			cfg.cid = IAV_H264_CFG_ENC_PARAM;
+			cfg.arg.h264_enc.id = stream;
+			cfg.arg.h264_enc.intrabias_p = h264cfg.intrabias_p;
+			cfg.arg.h264_enc.intrabias_b = h264cfg.intrabias_b;
+			cfg.arg.h264_enc.user1_intra_bias = h264cfg.user1_intra_bias;
+			cfg.arg.h264_enc.user1_direct_bias = h264cfg.user1_direct_bias;
+			cfg.arg.h264_enc.user2_intra_bias = h264cfg.user2_intra_bias;
+			cfg.arg.h264_enc.user2_direct_bias = h264cfg.user2_direct_bias;
+			cfg.arg.h264_enc.user3_intra_bias = h264cfg.user3_intra_bias;
+			cfg.arg.h264_enc.user3_direct_bias = h264cfg.user3_direct_bias;
+		}
+		AM_IOCTL(fd_iav, IAV_IOC_SET_STREAM_CONFIG, &cfg);
+	}
+
+	memset(&cfg, 0, sizeof(cfg));
+	cfg.id = stream;
+	cfg.cid = IAV_H264_CFG_FORCE_PSKIP;
+	if (param->force_pskip_flag) {
+		AM_IOCTL(fd_iav, IAV_IOC_SET_STREAM_CONFIG, &cfg);
+		cfg.arg.h264_pskip.repeat_enable = param->force_pskip_repeat_enable;
+		cfg.arg.h264_pskip.repeat_num =
+			(param->force_pskip_repeat_enable ? param->force_pskip_repeat_num : 0);
 		AM_IOCTL(fd_iav, IAV_IOC_SET_STREAM_CONFIG, &cfg);
 	}
 
 	return 0;
 }
 
-int set_mjpeg_encode_param(int stream)
+static int set_mjpeg_encode_param(int stream)
 {
 	struct iav_mjpeg_cfg mjpeg_cfg;
 	struct iav_stream_info info;
@@ -4245,7 +4901,7 @@ int set_mjpeg_encode_param(int stream)
 	return 0;
 }
 
-int set_encode_param(void)
+static int set_encode_param(void)
 {
 	struct iav_stream_format format;
 	int i;
@@ -4258,7 +4914,7 @@ int set_encode_param(void)
 		AM_IOCTL(fd_iav, IAV_IOC_GET_STREAM_FORMAT, &format);
 
 		if (format.type == IAV_STREAM_TYPE_H264)
-			set_h264_encode_param(i);
+			set_h264_encode_param(i, &format);
 		else if (format.type == IAV_STREAM_TYPE_MJPEG)
 			set_mjpeg_encode_param(i);
 		else {
@@ -4270,7 +4926,7 @@ int set_encode_param(void)
 	return 0;
 }
 
-int set_encode_format(void)
+static int set_encode_format(void)
 {
 	struct iav_stream_format format;
 	int i;
@@ -4309,29 +4965,26 @@ int set_encode_format(void)
 		if (encode_format[i].rotate_flag) {
 			format.rotate_cw = encode_format[i].rotate;
 		}
-		if (encode_format[i].snapshot_enable_flag) {
-			format.snapshot_enable = encode_format[i].snapshot_enable;
-		}
 		AM_IOCTL(fd_iav, IAV_IOC_SET_STREAM_FORMAT, &format);
 	}
 	return 0;
 }
 
-int goto_idle(void)
+static int goto_idle(void)
 {
 	AM_IOCTL(fd_iav, IAV_IOC_ENTER_IDLE, 0);
 	printf("IAVIOC_S_IDLE done\n");
 	return 0;
 }
 
-int enable_preview(void)
+static int enable_preview(void)
 {
 	AM_IOCTL(fd_iav, IAV_IOC_ENABLE_PREVIEW, 31);
 	printf("enable_preview done\n");
 	return 0;
 }
 
-int start_encode(u32 streamid)
+static int start_encode(u32 streamid)
 {
 	struct iav_stream_info streaminfo;
 	int i;
@@ -4357,26 +5010,49 @@ int start_encode(u32 streamid)
 }
 
 //this function will get encode state, if it's encoding, then stop it, otherwise, return 0 and do nothing
-int stop_encode(u32 streamid)
+static int stop_encode(u32 streamid)
 {
 	struct iav_stream_info streaminfo;
+	u32 stop_streamid = streamid;
+	u32 abort_streamid = streamid;
 	int i;
 
-	printf("Stop encoding for stream 0x%x \n", streamid);
-
 	for (i = 0; i < MAX_ENCODE_STREAM_NUM; ++i) {
-		if (streamid & (1 << i)) {
+		if (stop_streamid & (1 << i)) {
 			streaminfo.id = i;
 			AM_IOCTL(fd_iav, IAV_IOC_GET_STREAM_INFO, &streaminfo);
 			if (streaminfo.state != IAV_STREAM_STATE_ENCODING) {
-				streamid &= ~(1 << i);
+				stop_streamid &= ~(1 << i);
 			}
 		}
 	}
+	if (stop_streamid) {
+		printf("Stop encoding for stream 0x%x \n", stop_streamid);
+		AM_IOCTL(fd_iav, IAV_IOC_STOP_ENCODE, stop_streamid);
+	}
 
-	if (streamid == 0)
-		return 0;
-	AM_IOCTL(fd_iav, IAV_IOC_STOP_ENCODE, streamid);
+	for (i = 0; i < MAX_ENCODE_STREAM_NUM; ++i) {
+		if (abort_streamid & (1 << i)) {
+			streaminfo.id = i;
+			AM_IOCTL(fd_iav, IAV_IOC_GET_STREAM_INFO, &streaminfo);
+			if (streaminfo.state != IAV_STREAM_STATE_STARTING &&
+				streaminfo.state != IAV_STREAM_STATE_STOPPING) {
+				abort_streamid &= ~(1 << i);
+			}
+		}
+	}
+	if (abort_streamid) {
+		printf("Abort encoding for stream 0x%x \n", abort_streamid);
+		AM_IOCTL(fd_iav, IAV_IOC_ABORT_ENCODE, abort_streamid);
+	}
+
+	return 0;
+}
+
+static int abort_encode(u32 streamid)
+{
+	printf("abort encoding for stream 0x%x \n", streamid);
+	AM_IOCTL(fd_iav, IAV_IOC_ABORT_ENCODE, streamid);
 
 	return 0;
 }
@@ -4418,7 +5094,7 @@ int dump_idsp_bin(void)
 	return 0;
 }
 
-int change_frame_rate(void)
+static int change_frame_rate(void)
 {
 	struct iav_stream_cfg streamcfg;
 	struct vindev_fps vsrc_fps;
@@ -4478,7 +5154,7 @@ int change_frame_rate(void)
 	return 0;
 }
 
-int sync_frame_rate(void)
+static int sync_frame_rate(void)
 {
 	struct iav_stream_fps_sync fps_sync;
 	int i;
@@ -4505,7 +5181,7 @@ int sync_frame_rate(void)
 	return 0;
 }
 
-int setup_resource_limit(u32 source_buffer_id, u32 stream_id)
+static int setup_resource_limit(u32 source_buffer_id, u32 stream_id)
 {
 	int i;
 	struct iav_system_resource resource;
@@ -4547,6 +5223,10 @@ int setup_resource_limit(u32 source_buffer_id, u32 stream_id)
 		}
 	}
 
+	if (system_resource_setup.long_ref_b_frame_flag == 1) {
+		resource.long_ref_b_frame = system_resource_setup.long_ref_b_frame;
+	}
+
 	if (system_resource_setup.rotate_possible_flag) {
 		resource.rotate_enable = system_resource_setup.rotate_possible;
 	}
@@ -4563,6 +5243,10 @@ int setup_resource_limit(u32 source_buffer_id, u32 stream_id)
 		resource.lens_warp_enable = system_resource_setup.lens_warp;
 	}
 
+	if (system_resource_setup.max_enc_num_flag) {
+		resource.max_num_encode = system_resource_setup.max_enc_num;
+	}
+
 	if (system_resource_setup.enc_raw_rgb_flag) {
 		resource.enc_raw_rgb = system_resource_setup.enc_raw_rgb;
 	}
@@ -4656,6 +5340,10 @@ int setup_resource_limit(u32 source_buffer_id, u32 stream_id)
 		}
 	}
 
+	if (system_resource_setup.vin_overflow_protection_flag) {
+		resource.vin_overflow_protection= system_resource_setup.vin_overflow_protection;
+	}
+
 	/* Debug */
 	if (system_resource_setup.debug_iso_type_flag) {
 		if (system_resource_setup.debug_iso_type != -1) {
@@ -4682,6 +5370,10 @@ int setup_resource_limit(u32 source_buffer_id, u32 stream_id)
 		}
 	}
 
+	if (system_resource_setup.extra_top_row_buf_flag) {
+		resource.extra_top_row_buf_enable = system_resource_setup.extra_top_row_buf;
+	}
+
 	AM_IOCTL(fd_iav, IAV_IOC_SET_SYSTEM_RESOURCE, &resource);
 
 	return 0;
@@ -4720,7 +5412,7 @@ int setup_resource_limit_if_necessary(void)
 	return 0;
 }
 
-int setup_source_buffer()
+static int setup_source_buffer()
 {
 	struct iav_srcbuf_setup buf_setup;
 	int i;
@@ -4754,6 +5446,12 @@ int setup_source_buffer()
 				buf_setup.input[i].x = source_buffer_format[i].input_x;
 				buf_setup.input[i].y = source_buffer_format[i].input_y;
 			}
+			if (source_buffer_format[i].dump_interval_flag) {
+				buf_setup.dump_interval[i] = source_buffer_format[i].dump_interval;
+			}
+			if (source_buffer_format[i].dump_duration_flag) {
+				buf_setup.dump_duration[i] = source_buffer_format[i].dump_duration;
+			}
 			updated = 1;
 		}
 	}
@@ -4765,7 +5463,7 @@ int setup_source_buffer()
 	return 0;
 }
 
-int source_buffer_format_config()
+static int source_buffer_format_config()
 {
 	struct iav_srcbuf_format format;
 	int i;
@@ -4812,13 +5510,42 @@ static int force_idr_insertion(int stream)
 	return 0;
 }
 
+static int long_ref_p_insertion(int stream)
+{
+	struct iav_stream_cfg stream_cfg;
+
+	memset(&stream_cfg, 0, sizeof(stream_cfg));
+	stream_cfg.id = stream;
+	stream_cfg.cid = IAV_H264_CFG_LONG_REF_P;
+	AM_IOCTL(fd_iav, IAV_IOC_SET_STREAM_CONFIG, &stream_cfg);
+
+	return 0;
+}
+
 static int set_force_idr(void)
 {
 	int i;
 
 	for (i = 0; i < MAX_ENCODE_STREAM_NUM; i++) {
 		if (force_idr_id & (1 << i)) {
-			force_idr_insertion(i);
+			if (force_idr_insertion(i) < 0) {
+				return -1;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int set_long_ref_p(void)
+{
+	int i;
+
+	for (i = 0; i < MAX_ENCODE_STREAM_NUM; i++) {
+		if (long_ref_p_id & (1 << i)) {
+			if (long_ref_p_insertion(i) < 0) {
+				return -1;
+			}
 		}
 	}
 
@@ -4877,6 +5604,11 @@ static int change_qp_limit(int stream)
 		bitrate->qp_max_on_B = param->qp_max_b;
 	}
 
+	if (param->qp_q_flag) {
+		bitrate->qp_min_on_Q = param->qp_min_q;
+		bitrate->qp_max_on_Q = param->qp_max_q;
+	}
+
 	if (param->adapt_qp_flag)
 		bitrate->adapt_qp = param->adapt_qp;
 
@@ -4886,9 +5618,18 @@ static int change_qp_limit(int stream)
 	if (param->p_qp_reduce_flag)
 		bitrate->p_qp_reduce = param->p_qp_reduce;
 
+	if (param->q_qp_reduce_flag)
+		bitrate->q_qp_reduce = param->q_qp_reduce;
+
+	if (param->log_q_num_plus_1_flag)
+		bitrate->log_q_num_plus_1 = param->log_q_num_plus_1;
+
 	if (param->skip_frame_flag)
 		bitrate->skip_flag = param->skip_frame;
 
+	if (param->max_i_size_KB_flag)
+		bitrate->max_i_size_KB = param->max_i_size_KB;
+
 	stream_cfg.cid = IAV_H264_CFG_BITRATE;
 	AM_IOCTL(fd_iav, IAV_IOC_SET_STREAM_CONFIG, &stream_cfg);
 
@@ -5115,6 +5856,10 @@ static int do_show_status(void)
 		show_cmd_examples();
 	}
 
+	if (show_info_flag & (1 << IAV_SHOW_QP_HIST)) {
+		show_qp_hist();
+	}
+
 	return 0;
 }
 
@@ -5138,6 +5883,13 @@ static int do_stop_encoding(void)
 	return 0;
 }
 
+static int do_abort_encoding(void)
+{
+	if (abort_encode(abort_stream_id) < 0)
+		return -1;
+	return 0;
+}
+
 static int do_goto_idle(void)
 {
 	if (goto_idle() < 0)
@@ -5162,6 +5914,27 @@ static int do_vout_setup(void)
 	return 0;
 }
 
+static int reset_main_buffer_input()
+{
+	/* clear main buffer input size & offset in order to make them be equal to VIN size */
+	if (!source_buffer_format[IAV_SRCBUF_MN].input_size_changed_flag) {
+		source_buffer_format[IAV_SRCBUF_MN].input_width = 0;
+		source_buffer_format[IAV_SRCBUF_MN].input_height = 0;
+		source_buffer_format[IAV_SRCBUF_MN].input_size_changed_flag = 1;
+		source_buffer_format_changed_id |= (1 << IAV_SRCBUF_MN);
+		printf("set main buffer input size to vin size\n");
+	}
+	if (!source_buffer_format[IAV_SRCBUF_MN].input_offset_changed_flag) {
+		source_buffer_format[IAV_SRCBUF_MN].input_x = 0;
+		source_buffer_format[IAV_SRCBUF_MN].input_y = 0;
+		source_buffer_format[IAV_SRCBUF_MN].input_offset_changed_flag = 1;
+		source_buffer_format_changed_id |= (1 << IAV_SRCBUF_MN);
+		printf("set main buffer input offset to (0, 0)\n");
+	}
+
+	return 0;
+}
+
 static int do_vin_setup(void)
 {
 	// select channel: for multi channel VIN (initialize)
@@ -5173,6 +5946,8 @@ static int do_vin_setup(void)
 	if (init_vin(vin_mode, hdr_mode) < 0)
 		return -1;
 
+	reset_main_buffer_input();
+
 	return 0;
 }
 
@@ -5271,6 +6046,11 @@ static int do_real_time_change(void)
 			return -1;
 	}
 
+	if (long_ref_p_id) {
+		if (set_long_ref_p() < 0)
+			return -1;
+	}
+
 	return 0;
 }
 
@@ -5316,11 +6096,18 @@ static int do_debug_setup(void)
 	return 0;
 }
 
+static int do_dsp_clcok_set(void)
+{
+	AM_IOCTL(fd_iav, IAV_IOC_SET_DSP_CLOCK_STATE, dsp_clock_state_disable);
+	return 0;
+}
+
 int main(int argc, char **argv)
 {
 	int do_show_status_flag = 0;
 	int do_debug_dump_flag = 0;
 	int do_stop_encoding_flag = 0;
+	int do_abort_encoding_flag = 0;
 	int do_goto_idle_flag = 0;
 	int do_vout_setup_flag = 0;
 	int do_vin_setup_flag = 0;
@@ -5375,6 +6162,9 @@ int main(int argc, char **argv)
 	if (stop_stream_id)  {
 		do_stop_encoding_flag = 1;
 	}
+	if (abort_stream_id)  {
+		do_abort_encoding_flag = 1;
+	}
 
 	//go to idle (disable preview) flag
 	if (channel < 0) {
@@ -5435,7 +6225,8 @@ int main(int argc, char **argv)
 		force_fast_seek_id ||
 		qp_limit_changed_id ||
 		intra_mb_rows_changed_id ||
-		qp_matrix_changed_id) {
+		qp_matrix_changed_id ||
+		long_ref_p_id) {
 		do_real_time_change_flag = 1;
 	}
 
@@ -5475,6 +6266,11 @@ int main(int argc, char **argv)
 		if (do_stop_encoding() < 0)
 			return -1;
 	}
+	//abort encoding
+	if (do_abort_encoding_flag) {
+		if (do_abort_encoding() < 0)
+			return -1;
+	}
 
 	//disable preview (goto idle)
 	if (do_goto_idle_flag) {
@@ -5529,6 +6325,11 @@ int main(int argc, char **argv)
 			return -1;
 	}
 
+	if (dsp_clock_state_disable_flag) {
+		if (do_dsp_clcok_set() < 0)
+			return -1;
+	}
+
 	//start encoding
 	if (do_start_encoding_flag) {
 		if (do_start_encoding() < 0)
diff --git a/iav_test/test_fastosd.c b/iav_test/test_fastosd.c
index a31a308..605cd11 100644
--- a/iav_test/test_fastosd.c
+++ b/iav_test/test_fastosd.c
@@ -3,12 +3,29 @@
  *
  * History:
  * 2014/11/24  - [Zhi He] created for test fast osd
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
diff --git a/iav_test/test_frame_sync.c b/iav_test/test_frame_sync.c
index 095338b..c78d971 100644
--- a/iav_test/test_frame_sync.c
+++ b/iav_test/test_frame_sync.c
@@ -1,18 +1,34 @@
-/*
+/*******************************************************************************
  * test_frame_sync.c
  *
  * History:
- *	2015/02/11 - [Zhaoyang Chen] Created file
+ *    2015/02/11 - [Zhaoyang Chen] Created file
  *
- * Copyright (C) 2015-2019, Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ( "Software" ) are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- */
-
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+******************************************************************************/
 #include <unistd.h>
 #include <fcntl.h>
 #include <stdio.h>
@@ -55,6 +71,7 @@
 #endif
 
 #define MAX_ENCODE_STREAM_NUM		(IAV_STREAM_MAX_NUM_IMPL)
+#define QP_MATRIX_SINGLE_SIZE		(96 << 10)
 #define MAX_SRC_BUFFER_NUM			(IAV_SRCBUF_NUM)
 
 // the device file handle
@@ -63,7 +80,8 @@ static u8 *dsp_mem = NULL;
 static u32 dsp_size = 0;
 static u8 *qp_matrix_addr = NULL;
 static int stream_qp_matrix_size = 0;
-
+static int single_matrix_size = 0;
+static int stream_matrix_num = 0;
 
 
 #define VERIFY_STREAMID(x)   do {		\
@@ -73,6 +91,13 @@ static int stream_qp_matrix_size = 0;
 			}	\
 		} while (0)
 
+#define VERIFY_MATRIXID(x)   do {		\
+			if (((x) < 0) || ((x) >= QP_FRAME_TYPE_NUM)) {	\
+				printf ("matrix id wrong %d \n", (x));			\
+				return -1; 	\
+			}	\
+		} while (0)
+
 
 // h.264 config
 typedef struct h264_gop_param_s {
@@ -87,19 +112,23 @@ typedef struct h264_mv_threshold_param_s {
 	u8	mv_threshold_flag;
 } h264_mv_threshold_param_t;
 
-typedef struct h264_qproi_param_t {
-	int	type;
-	int	type_flag;
+typedef struct h264_roi_param_t {
+	int	qp_quality[QP_FRAME_TYPE_NUM];
+	int	qp_quality_flag[QP_FRAME_TYPE_NUM];
 
-	int	qp_quality;
-	int	qp_quality_flag;
+	int	qp_offset[QP_FRAME_TYPE_NUM];
+	int	qp_offset_flag[QP_FRAME_TYPE_NUM];
 
-	int qp_offset;
-	int qp_offset_flag;
+	int	zmv_threshold[QP_FRAME_TYPE_NUM];
+	int	zmv_threshold_flag[QP_FRAME_TYPE_NUM];
 
 	int	encode_width;
 	int	encode_height;
-} h264_qproi_param_t;
+
+	int	qp_offset_roi_map;
+	int	qp_quality_roi_map;
+	int	zmv_threshold_roi_map;
+} h264_roi_param_t;
 
 typedef struct h264_qp_limit_param_s {
 	u8	qp_min_i;
@@ -108,29 +137,32 @@ typedef struct h264_qp_limit_param_s {
 	u8	qp_max_p;
 	u8	qp_min_b;
 	u8	qp_max_b;
+	u8	qp_min_q;
+	u8	qp_max_q;
 	u8	adapt_qp;
 	u8	i_qp_reduce;
 	u8	p_qp_reduce;
+	u8	q_qp_reduce;
+	u8	log_q_num_plus_1;
 	u8	skip_frame;
 
 	u8	qp_i_flag;
 	u8	qp_p_flag;
 	u8	qp_b_flag;
+	u8	qp_q_flag;
 	u8	adapt_qp_flag;
 	u8	i_qp_reduce_flag;
 	u8	p_qp_reduce_flag;
+	u8	q_qp_reduce_flag;
+	u8	log_q_num_plus_1_flag;
 	u8	skip_frame_flag;
 } h264_qp_limit_param_t;
 
-typedef struct iav_qproi_data_s {
-	u8 qp_quality;
-	u8 qp_value;
-	u8 reserved[2];
-}  iav_qproi_data_t;
-
 typedef struct h264_frame_drop_param_s {
 	u8	frame_drop;
+	u8	frame_drop_repeat_enable;
 	u8	frame_drop_flag;
+	u8	reserved;
 } h264_frame_drop_param_t;
 
 typedef struct h264_enc_param_s {
@@ -154,22 +186,31 @@ typedef struct h264_enc_param_s {
 	u8	user3_direct_bias_flag;
 } h264_enc_param_t;
 
+typedef struct h264_force_pskip_param_s {
+	u8	repeat_enable;
+	u8	repeat_num;
+} h264_force_pskip_param_t;
 
 static int current_stream = -1;
+static int current_idx = 0;
 
 //encoding settings
 static u32 force_idr_id_map = 0;
 
 static u32 force_fast_seek_map = 0;
 
+static h264_force_pskip_param_t h264_force_pskip_param[MAX_ENCODE_STREAM_NUM];
+static u32 force_pskip_id_map = 0;
+
 static h264_gop_param_t h264_gop_param[MAX_ENCODE_STREAM_NUM];
 static u32 h264_gop_param_changed_map = 0;
 
 static h264_mv_threshold_param_t h264_mv_threshold_param[MAX_ENCODE_STREAM_NUM];
 static u32 h264_mv_threshold_changed_map = 0;
 
-static h264_qproi_param_t h264_qproi_param[MAX_ENCODE_STREAM_NUM];
-static u32 h264_qproi_changed_map = 0;
+static h264_roi_param_t h264_roi_param[MAX_ENCODE_STREAM_NUM];
+static u32 h264_roi_changed_map = 0;
+static u32 h264_ipb_matrix_changed_map = 0;
 
 static h264_qp_limit_param_t h264_qp_limit_param[MAX_ENCODE_STREAM_NUM];
 static u32 h264_qp_limit_changed_map = 0;
@@ -184,6 +225,9 @@ static u32 force_update_map = 0;
 
 static u32 show_params_map = 0;
 static int sleep_time = 1;
+static int roi_reset_flag = 0;
+
+static u32 long_ref_p_id_map = 0;
 
 #define	NO_ARG		0
 #define	HAS_ARG		1
@@ -195,20 +239,28 @@ enum numeric_short_options {
 
 	SPECIFY_MV_THRESHOLD,
 
-	SPECIFY_QP_ROI_TYPE,
-	SPECIFY_QP_ROI_QUALITY,
-	SPECIFY_QP_ROI_OFFSET,
+	SPECIFY_ROI_QP_MATRIX_IDX,
+	SPECIFY_ROI_QP_QUALITY,
+	SPECIFY_ROI_QP_OFFSET,
+	SPECIFY_ROI_ZMV_THRESHOLD,
+
+	SPECIFY_REGION_QP_QUALITY,
+	SPECIFY_REGION_QP_OFFSET,
+	SPECIFY_REGION_ZMV_THRESHOLD,
 
 	SPECIFY_QP_LIMIT_I,
 	SPECIFY_QP_LIMIT_P,
 	SPECIFY_QP_LIMIT_B,
+	SPECIFY_QP_LIMIT_Q,
 	SPECIFY_ADAPT_QP,
 	SPECIFY_I_QP_REDUCE,
 	SPECIFY_P_QP_REDUCE,
+	SPECIFY_Q_QP_REDUCE,
+	SPECIFY_LOG_Q_NUM_PLUS_1,
 	SPECIFY_SKIP_FRAME_MODE,
-
 	SPECIFY_FORCE_FAST_SEEK,
 	SPECIFY_FRAME_DROP,
+	SPECIFY_FRAME_DROP_REPEAT_ENABLE,
 	SPECIFY_INTRABIAS_P,
 	SPECIFY_INTRABIAS_B,
 	SPECIFY_USER1_INTRABIAS,
@@ -220,6 +272,11 @@ enum numeric_short_options {
 
 	SPECIFY_FORCE_UPDATE,
 
+	SPECIFY_LONG_REF_P,
+
+	SPECIFY_FORCE_PSKIP_REPEAT,
+	SPECIFY_REPEAT_PSKIP_NUM,
+
 	SHOW_PARAMETERS,
 };
 
@@ -240,21 +297,30 @@ static struct option long_options[] = {
 	{"idr",		HAS_ARG,			0,	SPECIFY_GOP_IDR},
 
 	// qp roi setting
-	{"qproi-type",	HAS_ARG,		0,	 SPECIFY_QP_ROI_TYPE},
-	{"qproi-quality",	HAS_ARG,	0,	 SPECIFY_QP_ROI_QUALITY},
-	{"qproi-offset",	HAS_ARG,	0,	 SPECIFY_QP_ROI_OFFSET},
+	{"qproi-matrix-idx", 	HAS_ARG,	0,	SPECIFY_ROI_QP_MATRIX_IDX},
+	{"qproi-quality",		HAS_ARG,	0,	SPECIFY_ROI_QP_QUALITY},
+	{"qproi-offset",		HAS_ARG,	0,	SPECIFY_ROI_QP_OFFSET},
+	{"zmvroi-threshold",	HAS_ARG,	0,	SPECIFY_ROI_ZMV_THRESHOLD},
+
+	{"qproi-quality-region",		HAS_ARG,	0,	SPECIFY_REGION_QP_QUALITY},
+	{"qproi-offset-region",		HAS_ARG,	0,	SPECIFY_REGION_QP_OFFSET},
+	{"zmvroi-threshold-region",	HAS_ARG,	0,	SPECIFY_REGION_ZMV_THRESHOLD},
 
 	// qp limit setting
 	{"qp-limit-i",	HAS_ARG,		0,	SPECIFY_QP_LIMIT_I},
 	{"qp-limit-p",	HAS_ARG,		0,	SPECIFY_QP_LIMIT_P},
 	{"qp-limit-b",	HAS_ARG,		0,	SPECIFY_QP_LIMIT_B},
+	{"qp-limit-q",	HAS_ARG,		0,	SPECIFY_QP_LIMIT_Q},
 	{"adapt-qp",	HAS_ARG,		0,	SPECIFY_ADAPT_QP},
 	{"i-qp-reduce",	HAS_ARG,		0,	SPECIFY_I_QP_REDUCE},
 	{"p-qp-reduce",	HAS_ARG,		0,	SPECIFY_P_QP_REDUCE},
+	{"q-qp-reduce", HAS_ARG,		0,	SPECIFY_Q_QP_REDUCE},
+	{"log-q-num-plus-1", HAS_ARG,	0,	SPECIFY_LOG_Q_NUM_PLUS_1},
 	{"skip-frame-mode",	HAS_ARG,	0,	SPECIFY_SKIP_FRAME_MODE},
 
 	{"force-fast-seek",	NO_ARG,		0,	SPECIFY_FORCE_FAST_SEEK},
 	{"frame-drop",	HAS_ARG, 		0,	SPECIFY_FRAME_DROP},
+	{"frame-drop-repeat",	HAS_ARG, 		0,	SPECIFY_FRAME_DROP_REPEAT_ENABLE},
 	{"intrabias-p",	HAS_ARG, 		0,	SPECIFY_INTRABIAS_P},
 	{"intrabias-b",	HAS_ARG, 		0,	SPECIFY_INTRABIAS_B},
 	{"user1-intrabias", HAS_ARG,	0,	SPECIFY_USER1_INTRABIAS},
@@ -267,13 +333,19 @@ static struct option long_options[] = {
 	// force update frame sync or not
 	{"force-update",	HAS_ARG,	0,	SPECIFY_FORCE_UPDATE},
 
+	{"long-ref-p",	NO_ARG,			0,	SPECIFY_LONG_REF_P},
+
+	{"force-pskip-repeat",	HAS_ARG,	0,	SPECIFY_FORCE_PSKIP_REPEAT},
+	{"repeat-pskip-num",	HAS_ARG,	0,	SPECIFY_REPEAT_PSKIP_NUM},
+
 	{"show-param",	NO_ARG,	0,	SHOW_PARAMETERS},
 	{"sleep",	HAS_ARG,	0,	's' },
+	{"reset-roi",	NO_ARG,	0,	'r'},
 
 	{0, 0, 0, 0}
 };
 
-static const char *short_options = "ABCDN:s:";
+static const char *short_options = "ABCDN:s:r";
 
 struct hint_s {
 	const char *arg;
@@ -289,39 +361,57 @@ static const struct hint_s hint[] = {
 	//immediate action, configure encode stream on the fly
 	{"", "\t\tforce IDR at once for current stream"},
 
-	{"0~255", "set zmv threshold for current stream, value 0 means disable it"},
+	{"0|1", "\tdisable/enable zmv threshold roi for current stream, 0: disable, 1: enable, default 0"},
 
 	//h264 gop encode configurations
 	{"1~4095", "\t\tH.264 GOP parameter N, must be multiple of M, can be changed during encoding"},
 	{"1~128", "\tthe number of GOP per an IDR picture, can be changed during encoding"},
-	{"0|1", "\tsetting qp roi type, 0:base type, 1: adv type, default 1"},
+	{"0~2", "\tsetting qproi matrix index, 0: idx for I, 1: idx for P, 2: idx for B, default 0"},
 	{"0~3", "setting qp quality level for qp roi"},
 	{"-51~51", "setting qp offset for qp roi"},
+	{"0~255", "setting zmv threshold for zmv roi"},
+	{"0~4", "setting the region of qp quality roi"	\
+		"\n\t\t\t\t0:top left, 1:top right, 2: down left, 3: down right, 4: all the screen"},
+	{"0~4", "setting the region of qp offset roi"		\
+		"\n\t\t\t\t0:top left, 1:top right, 2: down left, 3: down right, 4: all the screen"},
+	{"0~4", "\n\t\t\t\tsetting the region of zmv threshold roi"	\
+		"\n\t\t\t\t0:top left, 1:top right, 2: down left, 3: down right, 4: all the screen"},
 
 	{"0~51", "\tset I-frame qp limit range, 0:auto 1~51:qp limit range"},
 	{"0~51", "\tset P-frame qp limit range, 0:auto 1~51:qp limit range"},
 	{"0~51", "\tset B-frame qp limit range, 0:auto 1~51:qp limit range"},
+	{"0~51", "\tset Q-frame qp limit range, 0:auto 1~51:qp limit range"},
 	{"0~4", "\tset strength of adaptive qp"},
 	{"1~10", "\tset diff of I QP less than P QP"},
 	{"1~5", "\tset diff of P QP less than B QP"},
+	{"1~10", "\tset diff of Q QP less than P QP"},
+	{"0~4", "set Q frame number for one GOP"	\
+		"\n\t\t\t\t0: no Q frame, 1: 1 Q frame, 2: 3 Q frames, 3: 7 Q frames, 4: 15 Q frames"},
 	{"0|1|2", "0: disable, 1: skip based on CPB size, 2: skip based on target bitrate and max QP"},
 
 	//immediate action, configure encode stream on the fly
 	{"", "\tforce fast seek frame at once for current stream, used in gop 8"},
 	{"0~255", "\tSpecify how many frames encoder will drop, can update on the fly"},
+	{"0~1", "\tdisable/enable frame drop repeat, default is 0, which means disable"},
 	{"1~4000", "Specify intrabias for P frames of current stream"},
 	{"1~4000", "Specify intrabias for B frames of current stream"},
-	{"0~128", "Specify user1 intra bias strength, 0: no bias, 128: the strongest."},
-	{"0~128", "Specify user1 direct bias strength, 0: no bias, 128: the strongest."},
-	{"0~128", "Specify user2 intra bias strength, 0: no bias, 128: the strongest."},
-	{"0~128", "Specify user2 direct bias strength, 0: no bias, 128: the strongest."},
-	{"0~128", "Specify user3 intra bias strength, 0: no bias, 128: the strongest."},
-	{"0~128", "Specify user3 direct bias strength, 0: no bias, 128: the strongest."},
+	{"0~9", "Specify user1 intra bias strength, 0: no bias, 9: the strongest."},
+	{"0~9", "Specify user1 direct bias strength, 0: no bias, 9: the strongest."},
+	{"0~9", "Specify user2 intra bias strength, 0: no bias, 9: the strongest."},
+	{"0~9", "Specify user2 direct bias strength, 0: no bias, 9: the strongest."},
+	{"0~9", "Specify user3 intra bias strength, 0: no bias, 9: the strongest."},
+	{"0~9", "Specify user3 direct bias strength, 0: no bias, 9: the strongest."},
 
 	{"0|1", "\tSpecify force update encode parameters or not"},
 
+	{"", "\t\tInsert a long term reference P frame which will replace IDR and be referenced by later frames."},
+
+	{"0|1", "Repeatly generate P-skip or force pskip at once for current stream. 0: no-repeat, 1: repeat"},
+	{"0~254", "P-skip number when repeat pattern is ON"},
+
 	{"", "\t\tshow parameters.\n"},
 	{"", "\t\tSleep time, unit:ms\n"},
+	{"", "\t\tReset parameters in ROI buffer.\n"}
 
 };
 
@@ -343,8 +433,12 @@ static void usage(void)
 	printf("\nExamples:\n"
 			"  Add force idr for the frame in stream A:\n"
 			"    test_frame_sync -A --force-idr\n"
-			"  Set qp offset = -10 for the left top region in steam A:\n"
-			"    test_frame_sync -A --qproi-type 1 --qproi-offset -10\n"
+			"  Set qp offset = -10 to I/P/B frames for the left top region in steam A:\n"
+			"    test_frame_sync -A --qproi-offset -10 --qproi-offset-region 0\n"
+			"  Set qp offset = -10 to P frame for the left top region in stream A with IPB mode:\n"
+			"    test_frame_sync -A --qproi-matrix-idx 1 --qproi-offset -10 --qproi-offset-region 0\n"
+			"  Set zmv threshold = 32 to P frame for the top right region in stream A with IPB mode:\n"
+			"    test_frame_sync -A --mv-threshold 1 --qproi-matrix-idx 1 --zmvroi-threshold 32 --zmvroi-threshold-region 1\n"
 			"  Update qp limit p in stream A :\n"
 			"    test_frame_sync -A --qp-limit-p 20~20\n"
 			"  Add force fast seek frame in stream A:\n"
@@ -354,7 +448,16 @@ static void usage(void)
 			"  Set intra bias for P frame = 1000 in steam A:\n"
 			"    test_frame_sync -A --intrabias-p 1000\n"
 			"  Set adaptive qp to 4 in steam A, and update anyway:\n"
-			"    test_frame_sync -A --adapt-qp 4 --force-update 1\n");
+			"    test_frame_sync -A --adapt-qp 4 --force-update 1\n"
+			"  Set zmv threshold for all the screen in steam A:\n"
+			"    test_frame_sync -A --mv-threshold 1 --zmvroi-threshold 128 --zmvroi-threshold-region 4\n"
+			"  Reset P frame ROI buffer for stream A with IPB mode:\n"
+			"    test_frame_sync -A --qproi-matrix-idx 1 -r\n"
+			"  Add force p-skip frame in stream A:\n"
+			"    test_frame_sync -A --force-pskip-repeat 0\n"
+			"  Add repeat p-skip frame in stream A as IPPPPsssPsss:\n"
+			"    test_frame_sync -A --force-pskip-repeat 1 --repeat-pskip-num 3\n");
+
 	printf("\n");
 
 }
@@ -411,6 +514,8 @@ static int map_buffer(void)
 		return -1;
 	}
 	stream_qp_matrix_size = querybuf.length / MAX_ENCODE_STREAM_NUM;
+	stream_matrix_num = stream_qp_matrix_size / QP_MATRIX_SINGLE_SIZE;
+	single_matrix_size = stream_qp_matrix_size / stream_matrix_num;
 
 	return 0;
 }
@@ -448,13 +553,7 @@ int init_param(int argc, char **argv)
 
 			case SPECIFY_MV_THRESHOLD:
 				VERIFY_STREAMID(current_stream);
-				min_value = atoi(optarg);
-				if (min_value > 255 || min_value < 0) {
-					printf("Invalid zmv threshold value [%d], please choose from [%d~%d].\n",
-						min_value, 0, 255);
-					return -1;
-				}
-				h264_mv_threshold_param[current_stream].mv_threshold = min_value;
+				h264_mv_threshold_param[current_stream].mv_threshold = !!(atoi(optarg));
 				h264_mv_threshold_param[current_stream].mv_threshold_flag = 1;
 				h264_mv_threshold_changed_map |= (1 << current_stream);
 				break;
@@ -474,25 +573,86 @@ int init_param(int argc, char **argv)
 				h264_gop_param_changed_map |= (1 << current_stream);
 				break;
 
-			case SPECIFY_QP_ROI_TYPE:
+			case SPECIFY_ROI_QP_QUALITY:
 				VERIFY_STREAMID(current_stream);
-				h264_qproi_param[current_stream].type = atoi(optarg);
-				h264_qproi_param[current_stream].type_flag = 1;
-				h264_qproi_changed_map |= (1 << current_stream);
+				VERIFY_MATRIXID(current_idx);
+				h264_roi_param[current_stream].qp_quality[current_idx] = atoi(optarg);
+				h264_roi_param[current_stream].qp_quality_flag[current_idx] = 1;
+				h264_roi_changed_map |= (1 << current_stream);
+				h264_ipb_matrix_changed_map |= (1 << current_idx);
 				break;
 
-			case SPECIFY_QP_ROI_QUALITY:
+			case SPECIFY_ROI_QP_MATRIX_IDX:
 				VERIFY_STREAMID(current_stream);
-				h264_qproi_param[current_stream].qp_quality = atoi(optarg);
-				h264_qproi_param[current_stream].qp_quality_flag = 1;
-				h264_qproi_changed_map |= (1 << current_stream);
+				min_value = atoi(optarg);
+				VERIFY_MATRIXID(min_value);
+				current_idx = min_value;
 				break;
 
-			case SPECIFY_QP_ROI_OFFSET:
+			case SPECIFY_ROI_QP_OFFSET:
 				VERIFY_STREAMID(current_stream);
-				h264_qproi_param[current_stream].qp_offset = atoi(optarg);
-				h264_qproi_param[current_stream].qp_offset_flag = 1;
-				h264_qproi_changed_map |= (1 << current_stream);
+				VERIFY_MATRIXID(current_idx);
+				h264_roi_param[current_stream].qp_offset[current_idx] = atoi(optarg);
+				h264_roi_param[current_stream].qp_offset_flag[current_idx] = 1;
+				h264_roi_changed_map |= (1 << current_stream);
+				h264_ipb_matrix_changed_map |= (1 << current_idx);
+				break;
+
+			case SPECIFY_ROI_ZMV_THRESHOLD:
+				VERIFY_STREAMID(current_stream);
+				VERIFY_MATRIXID(current_idx);
+				min_value = atoi(optarg);
+				if (min_value > 255 || min_value < 0) {
+					printf("Invalid zmv threshold value [%d], please choose from [%d~%d].\n",
+						min_value, 0, 255);
+					return -1;
+				}
+				h264_roi_param[current_stream].zmv_threshold[current_idx] = min_value;
+				h264_roi_param[current_stream].zmv_threshold_flag[current_idx] = 1;
+				h264_roi_changed_map |= (1 << current_stream);
+				h264_ipb_matrix_changed_map |= (1 << current_idx);
+				break;
+
+			case SPECIFY_REGION_QP_QUALITY:
+				VERIFY_STREAMID(current_stream);
+				min_value = atoi(optarg);
+				if (min_value > 4 || min_value < 0) {
+					printf("Only support Region 0~4.\n");
+					return -1;
+				}
+				if (min_value == 4) {
+					h264_roi_param[current_stream].qp_quality_roi_map |= 0xff;
+				} else {
+					h264_roi_param[current_stream].qp_quality_roi_map |= (1 << min_value);
+				}
+				break;
+
+			case SPECIFY_REGION_QP_OFFSET:
+				VERIFY_STREAMID(current_stream);
+				min_value = atoi(optarg);
+				if (min_value > 4 || min_value < 0) {
+					printf("Only support Region 0~4.\n");
+					return -1;
+				}
+				if (min_value == 4) {
+					h264_roi_param[current_stream].qp_offset_roi_map |= 0xff;
+				} else {
+					h264_roi_param[current_stream].qp_offset_roi_map |= (1 << min_value);
+				}
+				break;
+
+			case SPECIFY_REGION_ZMV_THRESHOLD:
+				VERIFY_STREAMID(current_stream);
+				min_value = atoi(optarg);
+				if (min_value > 4 || min_value < 0) {
+					printf("Only support Region 0~4.\n");
+					return -1;
+				}
+				if (min_value == 4) {
+					h264_roi_param[current_stream].zmv_threshold_roi_map |= 0xff;
+				} else {
+					h264_roi_param[current_stream].zmv_threshold_roi_map |= (1 << min_value);
+				}
 				break;
 
 			case SPECIFY_QP_LIMIT_I:
@@ -528,6 +688,17 @@ int init_param(int argc, char **argv)
 				h264_qp_limit_changed_map |= (1 << current_stream);
 				break;
 
+			case SPECIFY_QP_LIMIT_Q:
+				VERIFY_STREAMID(current_stream);
+				if (get_two_unsigned_int(optarg, &min_value, &max_value, '~') < 0) {
+					return -1;
+				}
+				h264_qp_limit_param[current_stream].qp_min_q= min_value;
+				h264_qp_limit_param[current_stream].qp_max_q = max_value;
+				h264_qp_limit_param[current_stream].qp_q_flag = 1;
+				h264_qp_limit_changed_map |= (1 << current_stream);
+				break;
+
 			case SPECIFY_ADAPT_QP:
 				VERIFY_STREAMID(current_stream);
 				h264_qp_limit_param[current_stream].adapt_qp = atoi(optarg);
@@ -549,6 +720,20 @@ int init_param(int argc, char **argv)
 				h264_qp_limit_changed_map |= (1 << current_stream);
 				break;
 
+			case SPECIFY_Q_QP_REDUCE:
+				VERIFY_STREAMID(current_stream);
+				h264_qp_limit_param[current_stream].q_qp_reduce = atoi(optarg);
+				h264_qp_limit_param[current_stream].q_qp_reduce_flag = 1;
+				h264_qp_limit_changed_map |= (1 << current_stream);
+				break;
+
+			case SPECIFY_LOG_Q_NUM_PLUS_1:
+				VERIFY_STREAMID(current_stream);
+				h264_qp_limit_param[current_stream].log_q_num_plus_1 = atoi(optarg);
+				h264_qp_limit_param[current_stream].log_q_num_plus_1_flag = 1;
+				h264_qp_limit_changed_map |= (1 << current_stream);
+				break;
+
 			case SPECIFY_SKIP_FRAME_MODE:
 				VERIFY_STREAMID(current_stream);
 				h264_qp_limit_param[current_stream].skip_frame = atoi(optarg);
@@ -568,6 +753,12 @@ int init_param(int argc, char **argv)
 				h264_frame_drop_map |= (1 << current_stream);
 				break;
 
+			case SPECIFY_FRAME_DROP_REPEAT_ENABLE:
+				VERIFY_STREAMID(current_stream);
+				h264_frame_drop_param[current_stream].frame_drop_repeat_enable = !!(atoi(optarg));
+				h264_frame_drop_map |= (1 << current_stream);
+				break;
+
 			case SPECIFY_INTRABIAS_P:
 				VERIFY_STREAMID(current_stream);
 				h264_enc_param[current_stream].intrabias_p = atoi(optarg);
@@ -634,6 +825,23 @@ int init_param(int argc, char **argv)
 				force_update_map = (min_value << current_stream);
 				break;
 
+			case SPECIFY_LONG_REF_P:
+				VERIFY_STREAMID(current_stream);
+				//long ref p
+				long_ref_p_id_map |= (1 << current_stream);
+				break;
+
+			case SPECIFY_FORCE_PSKIP_REPEAT:
+				VERIFY_STREAMID(current_stream);
+				h264_force_pskip_param[current_stream].repeat_enable = !!(atoi(optarg));
+				force_pskip_id_map |= (1 << current_stream);
+				break;
+
+			case SPECIFY_REPEAT_PSKIP_NUM:
+				VERIFY_STREAMID(current_stream);
+				h264_force_pskip_param[current_stream].repeat_num = atoi(optarg);
+				break;
+
 			case SHOW_PARAMETERS:
 				VERIFY_STREAMID(current_stream);
 				show_params_map |= (1 << current_stream);
@@ -643,6 +851,14 @@ int init_param(int argc, char **argv)
 				sleep_time = atoi(optarg);
 				break;
 
+			case 'r':
+				VERIFY_STREAMID(current_stream);
+				VERIFY_MATRIXID(current_idx);
+				roi_reset_flag = 1;
+				h264_roi_changed_map |= (1 << current_stream);
+				h264_ipb_matrix_changed_map |= (1 << current_idx);
+				break;
+
 			default:
 				printf("unknown option found: %c\n", ch);
 				return -1;
@@ -696,13 +912,34 @@ static int cfg_sync_frame_mv_threshold_param(int stream)
 	return 0;
 }
 
-static int check_for_qp_roi(int stream_id)
+static int check_for_roi(int stream_id)
 {
 	struct iav_stream_info stream_info;
 	struct iav_stream_format stream_format;
 
 	VERIFY_STREAMID(stream_id);
 
+	if (h264_ipb_matrix_changed_map > 1 && stream_matrix_num == 1) {
+		printf("please enable CONFIG_AMBARELLA_IAV_ROI_IPB in menuconfig first.\n");
+		return -1;
+	}
+
+	// Only P frame setting is valid
+	if (stream_matrix_num == 3 &&
+		(h264_roi_param[stream_id].zmv_threshold_flag[QP_FRAME_I] ||
+		h264_roi_param[stream_id].zmv_threshold_flag[QP_FRAME_B])) {
+		printf("Only support P frame setting for ZMV.\n");
+		return -1;
+	}
+
+	// Always use I frame buffer no matter in IPB mode or not
+	if (stream_matrix_num == 3 &&
+		(h264_roi_param[stream_id].qp_quality_flag[QP_FRAME_P] ||
+		h264_roi_param[stream_id].qp_quality_flag[QP_FRAME_B])) {
+		printf("Always share I frame buffer for QP quality.\n");
+		return -1;
+	}
+
 	memset(&stream_info, 0, sizeof(stream_info));
 	stream_info.id = stream_id;
 	if (ioctl(fd_iav, IAV_IOC_GET_STREAM_INFO, &stream_info) < 0) {
@@ -724,8 +961,14 @@ static int check_for_qp_roi(int stream_id)
 		printf("Stream %c encode format shall be H.264.\n", 'A' + stream_id);
 		return -1;
 	}
-	h264_qproi_param[stream_id].encode_width = stream_format.enc_win.width;
-	h264_qproi_param[stream_id].encode_height = stream_format.enc_win.height;
+
+	if (stream_format.rotate_cw == 0) {
+		h264_roi_param[stream_id].encode_width = stream_format.enc_win.width;
+		h264_roi_param[stream_id].encode_height = stream_format.enc_win.height;
+	} else {
+		h264_roi_param[stream_id].encode_width = stream_format.enc_win.height;
+		h264_roi_param[stream_id].encode_height = stream_format.enc_win.width;
+	}
 
 	return 0;
 }
@@ -753,6 +996,10 @@ static int cfg_sync_frame_qp_limit_param(int stream)
 		h264_bitrate->qp_min_on_B = param->qp_min_b;
 		h264_bitrate->qp_max_on_B = param->qp_max_b;
 	}
+	if (param->qp_q_flag) {
+		h264_bitrate->qp_min_on_Q = param->qp_min_q;
+		h264_bitrate->qp_max_on_Q = param->qp_max_q;
+	}
 	if (param->adapt_qp_flag) {
 		h264_bitrate->adapt_qp = param->adapt_qp;
 	}
@@ -762,6 +1009,12 @@ static int cfg_sync_frame_qp_limit_param(int stream)
 	if (param->p_qp_reduce_flag) {
 		h264_bitrate->p_qp_reduce = param->p_qp_reduce;
 	}
+	if (param->q_qp_reduce_flag) {
+		h264_bitrate->q_qp_reduce = param->q_qp_reduce;
+	}
+	if (param->log_q_num_plus_1_flag) {
+		h264_bitrate->log_q_num_plus_1 = param->log_q_num_plus_1;
+	}
 	if (param->skip_frame_flag) {
 		h264_bitrate->skip_flag = param->skip_frame;
 	}
@@ -771,18 +1024,18 @@ static int cfg_sync_frame_qp_limit_param(int stream)
 	return 0;
 }
 
-static int cfg_sync_frame_qproi_param(int stream)
+static int cfg_sync_frame_roi_param(int stream)
 {
 	struct iav_stream_cfg sync_frame;
 	struct iav_qpmatrix *h264_qp_param = &sync_frame.arg.h264_roi;
 	struct iav_qproi_data *qproi_daddr = NULL;
 	u8 *daddr;
-	u32 size, i, j;
+	u32 size, i, j, k, region;
 	u32 buf_width, buf_pitch, buf_height;
 	u32 start_x, start_y, end_x, end_y;
 
-	if (check_for_qp_roi(stream) < 0) {
-		perror("check_for_qp_roi!\n");
+	if (check_for_roi(stream) < 0) {
+		perror("check_for_roi!\n");
 		return -1;
 	}
 
@@ -791,9 +1044,9 @@ static int cfg_sync_frame_qproi_param(int stream)
 	h264_qp_param->id = stream;
 
 	// QP matrix is MB level. One MB is 16x16 pixels.
-	buf_width = ROUND_UP(h264_qproi_param[stream].encode_width, 16) / 16;
+	buf_width = ROUND_UP(h264_roi_param[stream].encode_width, 16) / 16;
 	buf_pitch = ROUND_UP(buf_width, 8);
-	buf_height = ROUND_UP(h264_qproi_param[stream].encode_height, 16) / 16;
+	buf_height = ROUND_UP(h264_roi_param[stream].encode_height, 16) / 16;
 	size = buf_pitch * buf_height;
 
 	h264_qp_param->size = size * sizeof(struct iav_qproi_data);
@@ -801,46 +1054,69 @@ static int cfg_sync_frame_qproi_param(int stream)
 	h264_qp_param->qpm_no_update = 1;
 	AM_IOCTL(fd_iav, IAV_IOC_GET_FRAME_SYNC_PROC, &sync_frame);
 
-	/*	get the last qp roi setting	*/
-	daddr = qp_matrix_addr + h264_qp_param->data_offset;
-	qproi_daddr = (struct iav_qproi_data *)daddr;
-
-	/* clear buf for qp roi */
-	if (h264_qproi_param[stream].type == QPROI_TYPE_QP_OFFSET) {
-		for (i = 0; i < size; i++) {
-			qproi_daddr[i].qp_offset = 0;
-		}
-	} else if (h264_qproi_param[stream].type == QPROI_TYPE_QP_QUALITY) {
-		for (i = 0; i < size; i++) {
-			qproi_daddr[i].qp_quality = 0;
-		}
-	} else {
-		perror("Invalid QP type for qproi!\n");
-		return -1;
-	}
+	for (k = 0; k < QP_FRAME_TYPE_NUM; ++k) {
+		if (h264_ipb_matrix_changed_map & (1 << k)) {
+			/*	get the last qp roi setting	*/
+			if (stream_matrix_num == 3) {
+				daddr = qp_matrix_addr + h264_qp_param->data_offset +
+					k * single_matrix_size;
+			} else {
+				daddr = qp_matrix_addr + h264_qp_param->data_offset;
+			}
+			qproi_daddr = (struct iav_qproi_data *)daddr;
 
-	/* Just test with a fix area (left top)	*/
-	start_x = 0;
-	start_y = 0;
-	end_x = buf_width / 2 + start_x;
-	end_y =  buf_height / 2 + start_y;
-
-	if (h264_qproi_param[stream].type == QPROI_TYPE_QP_OFFSET) {
-		if (h264_qproi_param[stream].qp_offset_flag) {
-			for (i = start_y; i < end_y && i < buf_height; i++) {
-				for (j = start_x; j < end_x && j < buf_width; j++) {
-					/* bit 8~15 is used for setting qp offset directly */
-					qproi_daddr[i * buf_pitch + j].qp_offset =
-						h264_qproi_param[stream].qp_offset;
+			/* clear buf for qp roi */
+			if (h264_roi_param[stream].qp_offset_flag[k] || roi_reset_flag) {
+				for (i = 0; i < size; i++) {
+					qproi_daddr[i].qp_offset = 0;
 				}
 			}
-		}
-	} else {
-		// setting qp quality
-		for (i = start_y; i < end_y && i < buf_height; i++) {
-			for (j = start_x; j < end_x && j < buf_width; j++) {
-				qproi_daddr[i * buf_pitch + j].qp_quality =
-					h264_qproi_param[stream].qp_quality;
+			if (h264_roi_param[stream].qp_quality_flag[k] || roi_reset_flag) {
+				for (i = 0; i < size; i++) {
+					qproi_daddr[i].qp_quality = 0;
+				}
+			}
+			if (h264_roi_param[stream].zmv_threshold_flag[k] || roi_reset_flag) {
+				for (i = 0; i < size; i++) {
+					qproi_daddr[i].zmv_threshold = 0;
+				}
+			}
+
+			for (region = 0; region < 4; region++) {
+				start_x = (region % 2 == 1) ? (buf_width / 2): 0;
+				start_y = (region > 1) ? (buf_height / 2): 0;
+				end_x = (region % 2 == 1) ? buf_width: (buf_width / 2);
+				end_y = (region > 1) ? buf_height : (buf_height / 2);
+
+				if (h264_roi_param[stream].qp_offset_flag[k]
+					&& (h264_roi_param[stream].qp_offset_roi_map & (1 << region))) {
+					for (i = start_y; i < end_y; i++) {
+						for (j = start_x; j < end_x; j++) {
+							qproi_daddr[i * buf_pitch + j].qp_offset =
+								h264_roi_param[stream].qp_offset[k];
+						}
+					}
+				}
+
+				if (h264_roi_param[stream].qp_quality_flag[k]
+					&& (h264_roi_param[stream].qp_quality_roi_map & (1 << region))) {
+					for (i = start_y; i < end_y; i++) {
+						for (j = start_x; j < end_x; j++) {
+							qproi_daddr[i * buf_pitch + j].qp_quality =
+								h264_roi_param[stream].qp_quality[k];
+						}
+					}
+				}
+
+				if (h264_roi_param[stream].zmv_threshold_flag[k]
+					&& (h264_roi_param[stream].zmv_threshold_roi_map & (1 << region))) {
+					for (i = start_y; i < end_y; i++) {
+						for (j = start_x; j < end_x; j++) {
+							qproi_daddr[i * buf_pitch + j].zmv_threshold =
+								h264_roi_param[stream].zmv_threshold[k];
+						}
+					}
+				}
 			}
 		}
 	}
@@ -850,7 +1126,6 @@ static int cfg_sync_frame_qproi_param(int stream)
 	h264_qp_param->enable = 1;
 	h264_qp_param->qpm_no_check = 0;
 	h264_qp_param->qpm_no_update = 0;
-	h264_qp_param->type = h264_qproi_param[stream].type;
 
 	AM_IOCTL(fd_iav, IAV_IOC_CFG_FRAME_SYNC_PROC, &sync_frame);
 
@@ -871,6 +1146,19 @@ static int cfg_sync_frame_force_idr(int stream)
 	return 0;
 }
 
+static int cfg_sync_frame_long_ref_p(int stream)
+{
+	struct iav_stream_cfg sync_frame;
+	memset(&sync_frame, 0, sizeof(sync_frame));
+
+	sync_frame.id = stream;
+	sync_frame.cid = IAV_H264_CFG_LONG_REF_P;
+
+	AM_IOCTL(fd_iav, IAV_IOC_CFG_FRAME_SYNC_PROC, &sync_frame);
+
+	return 0;
+}
+
 static int cfg_sync_frame_force_fast_seek(int stream)
 {
 	struct iav_stream_cfg sync_frame;
@@ -893,7 +1181,9 @@ static int cfg_sync_frame_drop(int stream)
 	memset(&sync_frame, 0, sizeof(sync_frame));
 	sync_frame.id = stream;
 	sync_frame.cid = IAV_H264_CFG_FRAME_DROP;
-	sync_frame.arg.h264_drop_frames = param->frame_drop;
+	sync_frame.arg.h264_frame_drop.drop_num = param->frame_drop;
+	sync_frame.arg.h264_frame_drop.repeat_enable =
+		param->frame_drop_repeat_enable;
 
 	AM_IOCTL(fd_iav, IAV_IOC_CFG_FRAME_SYNC_PROC, &sync_frame);
 
@@ -943,14 +1233,29 @@ static int cfg_sync_frame_enc_param(int stream)
 	return 0;
 }
 
+static int cfg_sync_frame_force_pskip_param(int stream)
+{
+	struct iav_stream_cfg sync_frame;
+	h264_force_pskip_param_t *param = &h264_force_pskip_param[stream];
+
+	memset(&sync_frame, 0, sizeof(sync_frame));
+	sync_frame.id = stream;
+	sync_frame.cid = IAV_H264_CFG_FORCE_PSKIP;
+	sync_frame.arg.h264_pskip.repeat_enable = param->repeat_enable;
+	sync_frame.arg.h264_pskip.repeat_num =
+		(param->repeat_enable ? param->repeat_num : 0);
+	AM_IOCTL(fd_iav, IAV_IOC_CFG_FRAME_SYNC_PROC, &sync_frame);
+
+	return 0;
+}
+
 static int do_vca_on_yuv(struct iav_yuvbufdesc *info)
 {
 	struct iav_querydesc query_desc;
 	struct iav_yuvbufdesc *yuv;
 	u8* luma_addr;
-
 	int i;
-#define TEST_PATTERN	128
+
 
 	if (info == NULL) {
 		printf("The point is NULL\n");
@@ -968,8 +1273,8 @@ static int do_vca_on_yuv(struct iav_yuvbufdesc *info)
 
 	/*	To do,  run VCA algorithm here	*/
 	luma_addr = dsp_mem + yuv->y_addr_offset;
-	for (i = 0; i < TEST_PATTERN; i++) {
-		memset(luma_addr + (16 + i) * yuv->pitch, 0x0, TEST_PATTERN);
+	for (i = 0; i < yuv->height / 4; i++) {
+		memset(luma_addr + (16 + i) * yuv->pitch, 0x0, yuv->width / 4);
 	}
 	usleep(1000 * sleep_time);
 
@@ -1056,19 +1361,8 @@ static int do_iav_sync_frame(u32 sync_frame_map)
 				buffer_map |= 1 << format.buf_id;
 			}
 
-			if (h264_qproi_changed_map & (1 << info.id)) {
-				if (!h264_qproi_param[i].type_flag)
-					h264_qproi_param[i].type = QPROI_TYPE_QP_OFFSET;
-				if (h264_qproi_param[i].type == QPROI_TYPE_QP_OFFSET) {
-					if (!h264_qproi_param[i].qp_offset_flag) {
-						h264_qproi_param[i].qp_offset = 25;
-					}
-				} else {
-					if (!h264_qproi_param[i].qp_quality_flag) {
-						h264_qproi_param[i].qp_quality = 0;
-					}
-				}
-				if (cfg_sync_frame_qproi_param(i) < 0) {
+			if (h264_roi_changed_map & (1 << info.id)) {
+				if (cfg_sync_frame_roi_param(i) < 0) {
 					return -1;
 				}
 				apply_map |= 1 << info.id;
@@ -1115,6 +1409,18 @@ static int do_iav_sync_frame(u32 sync_frame_map)
 				}
 				apply_map |= 1 << info.id;
 			}
+			if (long_ref_p_id_map & (1 << info.id)) {
+				if (cfg_sync_frame_long_ref_p(i) < 0) {
+					return -1;
+				}
+				apply_map |= 1 << info.id;
+			}
+			if (force_pskip_id_map & (1 << info.id)) {
+				if (cfg_sync_frame_force_pskip_param(i) < 0) {
+					return -1;
+				}
+				apply_map |= 1 << info.id;
+			}
 		}
 
 		if (apply_map) {
@@ -1144,34 +1450,31 @@ static int show_iav_sync_frame(void)
 		sync_frame.id = i;
 		sync_frame.cid = IAV_H264_CFG_ZMV_THRESHOLD;
 		AM_IOCTL(fd_iav, IAV_IOC_GET_FRAME_SYNC_PROC, &sync_frame);
-		printf("\t mv_threshold:%d\n", sync_frame.arg.mv_threshold);
+		printf("\t mv_threshold: %s\n", sync_frame.arg.mv_threshold ? "Enable" : "Disable");
 
 		sync_frame.cid = IAV_H264_CFG_QP_ROI;
 		sync_frame.arg.h264_roi.id = ((1 << i) & show_params_map);
 
-		buf_width = ROUND_UP(h264_qproi_param[i].encode_width, 16) / 16;
+		buf_width = ROUND_UP(h264_roi_param[i].encode_width, 16) / 16;
 		buf_pitch = ROUND_UP(buf_width, 8);
-		buf_height = ROUND_UP(h264_qproi_param[i].encode_height, 16) / 16;
+		buf_height = ROUND_UP(h264_roi_param[i].encode_height, 16) / 16;
 
 		sync_frame.arg.h264_roi.size = buf_pitch * buf_height *
 			sizeof(struct iav_qproi_data);
 		sync_frame.arg.h264_roi.qpm_no_update = 1;
 		AM_IOCTL(fd_iav, IAV_IOC_GET_FRAME_SYNC_PROC, &sync_frame);
 		printf("\t qp roi: enable:%d\n", sync_frame.arg.h264_roi.enable);
-		printf("\t qp roi: type:%d\n", sync_frame.arg.h264_roi.type);
-		if (sync_frame.arg.h264_roi.type == QPROI_TYPE_QP_QUALITY) {
-			for (j = 0; j < 4; j++) {
-				printf("\t qp roi: qp delta of quality %d for I frame:%d\n",
-					j, sync_frame.arg.h264_roi.qp_delta[QP_FRAME_I][j]);
-			}
-			for (j = 0; j < 4; j++) {
-				printf("\t qp roi: qp delta of quality %d for P frame:%d\n",
-					j, sync_frame.arg.h264_roi.qp_delta[QP_FRAME_P][j]);
-			}
-			for (j = 0; j < 4; j++) {
-				printf("\t qp roi: qp delta of quality %d for B frame:%d\n",
-					j, sync_frame.arg.h264_roi.qp_delta[QP_FRAME_B][j]);
-			}
+		for (j = 0; j < 4; j++) {
+			printf("\t qp roi: qp delta of quality %d for I frame:%d\n",
+				j, sync_frame.arg.h264_roi.qp_delta[QP_FRAME_I][j]);
+		}
+		for (j = 0; j < 4; j++) {
+			printf("\t qp roi: qp delta of quality %d for P frame:%d\n",
+				j, sync_frame.arg.h264_roi.qp_delta[QP_FRAME_P][j]);
+		}
+		for (j = 0; j < 4; j++) {
+			printf("\t qp roi: qp delta of quality %d for B frame:%d\n",
+				j, sync_frame.arg.h264_roi.qp_delta[QP_FRAME_B][j]);
 		}
 
 		sync_frame.cid = IAV_H264_CFG_BITRATE;
@@ -1184,9 +1487,13 @@ static int show_iav_sync_frame(void)
 			h264_rc->qp_min_on_P, h264_rc->qp_max_on_P);
 		printf("\t qp limit: qp_limit_b:%d~%d\n",
 			h264_rc->qp_min_on_B, h264_rc->qp_max_on_B);
+		printf("\t qp limit: qp_limit_q:%d~%d\n",
+			h264_rc->qp_min_on_Q, h264_rc->qp_max_on_Q);
 		printf("\t qp limit: adapt_qp:%d\n", h264_rc->adapt_qp);
 		printf("\t qp limit: i_qp_reduce:%d\n", h264_rc->i_qp_reduce);
 		printf("\t qp limit: p_qp_reduce:%d\n", h264_rc->p_qp_reduce);
+		printf("\t qp limit: q_qp_reduce:%d\n", h264_rc->q_qp_reduce);
+		printf("\t qp limit: log_q_num_plus_1:%d\n", h264_rc->log_q_num_plus_1);
 		printf("\t qp limit: skip_flag:%d\n", h264_rc->skip_flag);
 
 		sync_frame.cid = IAV_H264_CFG_GOP;
@@ -1245,12 +1552,14 @@ int main(int argc, char **argv)
 	// updated streams
 	sync_frame_map = h264_mv_threshold_changed_map |
 		h264_gop_param_changed_map |
-		h264_qproi_changed_map |
+		h264_roi_changed_map |
 		h264_qp_limit_changed_map |
 		force_idr_id_map |
 		force_fast_seek_map |
 		h264_frame_drop_map |
-		h264_enc_param_map;
+		h264_enc_param_map |
+		long_ref_p_id_map |
+		force_pskip_id_map;
 
 /********************************************************
  *  execution base on flag
diff --git a/iav_test/test_loadbmp.c b/iav_test/test_loadbmp.c
index 8285865..e2d6859 100644
--- a/iav_test/test_loadbmp.c
+++ b/iav_test/test_loadbmp.c
@@ -6,12 +6,29 @@
  * 2010/4/15 - [Luo Fei] modified for multistream
  * 2010/7/28 - [Jian Tang] add 3 areas for each stream
  *
- * Copyright (C) 2007-2008, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 #include <unistd.h>
diff --git a/iav_test/test_mainpp.c b/iav_test/test_mainpp.c
index e1d9cde..0d4d792 100644
--- a/iav_test/test_mainpp.c
+++ b/iav_test/test_mainpp.c
@@ -1,17 +1,34 @@
-/*******************************************************************************
+/*
  * test_mainpp.c
  *
  * History:
  *  2015/04/02 - [Zhaoyang Chen] created file
  *
- * Copyright (C) 2015-2019, Ambarella ShangHai Co,Ltd
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- ******************************************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -52,7 +69,7 @@ enum {
 };
 
 static int exit_flag = 0;
-static int loglevel = LOG_INFO;
+static int loglevel = AMBA_LOG_INFO;
 static int run_mode = 0;
 static int autorun_interval = 3;
 static int autorun_size = 64;
diff --git a/iav_test/test_memcpy.c b/iav_test/test_memcpy.c
index 220d990..7980fee 100644
--- a/iav_test/test_memcpy.c
+++ b/iav_test/test_memcpy.c
@@ -4,12 +4,29 @@
  * History:
  *    2010/9/6 - [Louis Sun] create it to test memcpy by GDMA
  *
- * Copyright (C) 2007-2010, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
diff --git a/iav_test/test_mjpeg_filo.c b/iav_test/test_mjpeg_filo.c
index 6e27249..a32b47a 100644
--- a/iav_test/test_mjpeg_filo.c
+++ b/iav_test/test_mjpeg_filo.c
@@ -1,3 +1,35 @@
+/*
+ * test_mjpeg_filo.c
+ *
+ * History:
+ *    2010/9/6 - [Louis Sun] create it to test memcpy by GDMA
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include <unistd.h>
 #include <fcntl.h>
 #include <stdio.h>
@@ -336,7 +368,7 @@ static int  write_stream(void)
 			query_desc.qid = IAV_DESC_FRAME;
 			frame_desc->id = j;
 			frame_desc->time_ms = 0; // Non-Blocking way
-			frame_desc->instant_fetch = IAV_FETCH_MJPEG_INSTANT_ENABLE;
+			frame_desc->instant_fetch = 1;
 			current_stream_id = j;
 		} else {
 			continue;
diff --git a/iav_test/test_ndelay/network_utils.cpp b/iav_test/test_ndelay/network_utils.cpp
index d55da12..0ece246 100644
--- a/iav_test/test_ndelay/network_utils.cpp
+++ b/iav_test/test_ndelay/network_utils.cpp
@@ -4,12 +4,29 @@
  * History:
  *	2015/08/31 - [Zhi He] create file
  *
- * Copyright (C) 2015 -2020, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
diff --git a/iav_test/test_ndelay/network_utils.h b/iav_test/test_ndelay/network_utils.h
index e3b3d03..d29c5f3 100644
--- a/iav_test/test_ndelay/network_utils.h
+++ b/iav_test/test_ndelay/network_utils.h
@@ -4,12 +4,29 @@
  * History:
  *	2015/08/31 - [Zhi He] create file
  *
- * Copyright (C) 2015 -2020, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
diff --git a/iav_test/test_ndelay/simple_log.cpp b/iav_test/test_ndelay/simple_log.cpp
index 0924990..763a63d 100644
--- a/iav_test/test_ndelay/simple_log.cpp
+++ b/iav_test/test_ndelay/simple_log.cpp
@@ -4,12 +4,30 @@
  * History:
  *	2015/08/31 - [Zhi He] create file
  *
- * Copyright (C) 2014 - 2024, the Ambarella Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of the Ambarella Inc.
  */
 
 #include <stdlib.h>
diff --git a/iav_test/test_ndelay/simple_log.h b/iav_test/test_ndelay/simple_log.h
index ad0fc9f..1f239a9 100644
--- a/iav_test/test_ndelay/simple_log.h
+++ b/iav_test/test_ndelay/simple_log.h
@@ -4,12 +4,30 @@
  * History:
  *	2015/08/31 - [Zhi He] create file
  *
- * Copyright (C) 2014 - 2024, the Ambarella Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of the Ambarella Inc.
  */
 
 #ifndef __SIMPLE_LOG_H__
diff --git a/iav_test/test_ndelay/simple_queue.cpp b/iav_test/test_ndelay/simple_queue.cpp
index deb1f19..eec124c 100644
--- a/iav_test/test_ndelay/simple_queue.cpp
+++ b/iav_test/test_ndelay/simple_queue.cpp
@@ -4,12 +4,30 @@
  * History:
  *	2015/09/01 - [Zhi He] create file
  *
- * Copyright (C) 2014 - 2024, the Ambarella Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of the Ambarella Inc.
  */
 
 #include <stdlib.h>
diff --git a/iav_test/test_ndelay/simple_queue.h b/iav_test/test_ndelay/simple_queue.h
index 3411b1b..4aeecdf 100644
--- a/iav_test/test_ndelay/simple_queue.h
+++ b/iav_test/test_ndelay/simple_queue.h
@@ -4,12 +4,30 @@
  * History:
  *	2015/08/31 - [Zhi He] create file
  *
- * Copyright (C) 2014 - 2024, the Ambarella Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of the Ambarella Inc.
  */
 
 #ifndef __SIMPLE_QUEUE_H__
diff --git a/iav_test/test_ndelay/test_network_delay.cpp b/iav_test/test_ndelay/test_network_delay.cpp
index 7abca22..17522ae 100644
--- a/iav_test/test_ndelay/test_network_delay.cpp
+++ b/iav_test/test_ndelay/test_network_delay.cpp
@@ -4,12 +4,29 @@
  * History:
  *	2015/08/31 - [Zhi He] create file
  *
- * Copyright (C) 2015 -2020, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
diff --git a/iav_test/test_overlay.c b/iav_test/test_overlay.c
index 2465531..f510a3f 100644
--- a/iav_test/test_overlay.c
+++ b/iav_test/test_overlay.c
@@ -3,12 +3,29 @@
  *
  * History:
  * 2013/12/02  - [Jian Tang] created for S2L
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
@@ -112,6 +129,7 @@ typedef struct stream_info_s {
 	int win_width;
 	int win_height;
 	osd_info_t osd[MAX_OVERLAY_AREA_NUM];
+	int osd_insert_always;
 } stream_info_t;
 
 static int autorun_flag = 0;
@@ -504,6 +522,7 @@ static int prepare_overlay_config(void)
 		if (stream_info[i].enable == OSD_ENABLE) {
 			win_width = stream_info[i].win_width;
 			win_height = stream_info[i].win_height;
+			overlay_insert[i].osd_insert_always = stream_info[i].osd_insert_always;
 			for (j = 0, total_size = 0; j < MAX_OVERLAY_AREA_NUM; j++) {
 				osd = &stream_info[i].osd[j];
 				area = &overlay_insert[i].area[j];
@@ -656,6 +675,7 @@ static int autorun_overlay(void)
 
 		if (stream_info[i].enable == OSD_ENABLE) {
 			overlay_insert[i].enable = 1;
+			overlay_insert[i].osd_insert_always = stream_info[i].osd_insert_always;
 			total_size = 0;
 			spacing = ROUND_DOWN(stream_info[i].win_width /
 					MAX_OVERLAY_AREA_NUM, 2);
@@ -746,6 +766,7 @@ static struct option long_options[] = {
 	{"width", HAS_ARG, 0, 'w'},
 	{"height", HAS_ARG, 0, 'h'},
 	{"update", NO_ARG, 0, 'u'},
+	{"insert-always", HAS_ARG, 0, 'i'},
 
 	{"clut_file", HAS_ARG, 0, 'c'},
 	{"data_file", HAS_ARG, 0, 'd'},
@@ -760,7 +781,7 @@ static struct option long_options[] = {
 	{0, 0, 0, 0}
 };
 
-static const char *short_options = "ABCDa:x:y:w:h:uc:d:nsr:lv";
+static const char *short_options = "ABCDa:x:y:w:h:ui:c:d:nsr:lv";
 
 struct hint_s {
 	const char *arg;
@@ -779,6 +800,7 @@ static const struct hint_s hint[] = {
 	{"", "\t\tset width (must be larger than 32)"},
 	{"", "\t\tset height"},
 	{"", "\t\tupdate overlay data every second."},
+	{"", "\tAlways insert overlay including skipped frame; 0: disable, 1: enable, default is 0."},
 
 	{"filename", "read clut from file"},
 	{"filename", "read yuv index from file"},
@@ -820,6 +842,8 @@ void usage(void)
 			"    test_overlay -A -a0 -x0 -y100 -w64 -h128 -u\n"
 			"  Updata OSD every frame:\n"
 			"    test_overlay -r 1\n"
+			"  Always insert OSD including skipped frame:\n"
+			"    test_overlay -A -a0 -x0 -y100 -w64 -h128 -u -i 1\n"
 			"  Show current overlay area settings of streams:\n"
 			"    test_overlay -A -l\n");
 	printf("\n");
@@ -875,6 +899,10 @@ int init_param(int argc, char **argv)
 			stream_info[current_stream].osd[current_area].update = 1;
 			update_flag = 1;
 			break;
+		case 'i':
+			VERIFY_STREAMID(current_stream);
+			stream_info[current_stream].osd_insert_always = !!(atoi(optarg));
+			break;
 		case 'c':
 			VERIFY_STREAMID(current_stream);
 			VERIFY_AREAID(current_area);
@@ -938,6 +966,7 @@ static int show_overlay_config(int stream_id)
 				total_size += area->total_size;
 			}
 			printf("  Total Size : [%d].\n", total_size);
+			printf("  Always Insert : [%s].\n", overlay_insert[i].osd_insert_always ? "Enable" : "Disable");
 		}
 	}
 	return 0;
diff --git a/iav_test/test_privacymask.c b/iav_test/test_privacymask.c
index 7559cb8..744c12b 100644
--- a/iav_test/test_privacymask.c
+++ b/iav_test/test_privacymask.c
@@ -1,18 +1,35 @@
-/**********************************************************
+/*
  * test_privacymask.c
  *
  * History:
  *	2010/05/28 - [Louis Sun] created for A5s
  *	2011/07/04 - [Jian Tang] modified for A5s
  *
- * Copyright (C) 2007-2011, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- *********************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include <unistd.h>
 #include <fcntl.h>
@@ -59,9 +76,6 @@ static int mask_rect_remove = 0;
 static int mask_rect_set = 0;
 static privacy_mask_rect_t	mask_rect;
 
-static int hdr_x_offset = 0;
-static int hdr_y_offset = 0;
-
 #define NO_ARG		0
 #define HAS_ARG		1
 #define OPTIONS_BASE		0
@@ -216,14 +230,6 @@ static inline int get_vin_info(){
 
 	memcpy(&vin_info, &video_info.info, sizeof(struct amba_video_info));
 
-	if (video_info.info.hdr_mode >= AMBA_VIDEO_2X_HDR_MODE) {
-		vin_info.width = video_info.info.max_act_width;
-		vin_info.height = video_info.info.max_act_height;
-		// FIX ME! act win and max_act win may not have same center in the future.
-		hdr_x_offset = (video_info.info.max_act_width - video_info.info.width) / 2;
-		hdr_y_offset = (video_info.info.max_act_height - video_info.info.height) / 2;
-	}
-
 	vsrc_fps.vsrc_id = 0;
 	if (ioctl(fd_privacy_mask, IAV_IOC_VIN_GET_FPS, &vsrc_fps) < 0) {
 		perror("IAV_IOC_VIN_GET_FPS");
@@ -313,14 +319,12 @@ int fill_pm_mem(privacy_mask_rect_t pm_rect, int pm_remove)
 		row += pitch;
 	}
 
-
 	if (ioctl(fd_privacy_mask, IAV_IOC_SET_PRIVACY_MASK, &privacy_mask) < 0) {
 		perror("IAV_IOC_SET_PRIVACY_MASK");
 		return -1;
 	}
 
 	return 0;
-
 }
 
 int auto_run_test(int interval)
@@ -329,8 +333,8 @@ int auto_run_test(int interval)
 	privacy_mask_rect_t random_pm;
 	sleep_time = interval * 1000000 / (DIV_ROUND(512000000, vin_frame_time));
 
-	random_pm.start_x = rand() % vin_info.width + hdr_x_offset;
-	random_pm.start_y = rand() % vin_info.height + hdr_y_offset;
+	random_pm.start_x = rand() % vin_info.width;
+	random_pm.start_y = rand() % vin_info.height;
 	random_pm.width = rand() % vin_info.width;
 	random_pm.height = rand() % vin_info.height;
 
@@ -411,9 +415,6 @@ int main(int argc, char **argv)
 			return 0;
 		}
 
-		mask_rect.start_x += hdr_x_offset;
-		mask_rect.start_y += hdr_y_offset;
-
 		if (fill_pm_mem(mask_rect, mask_rect_remove) < 0){
 			perror("fill_pm_mem");
 		}
diff --git a/iav_test/test_qproi.c b/iav_test/test_qproi.c
index 7611ba0..6d6d09c 100644
--- a/iav_test/test_qproi.c
+++ b/iav_test/test_qproi.c
@@ -1,16 +1,34 @@
-/*
- * test_qproi.c
+/*******************************************************************************
+ *  test_qproi.c
  *
  * History:
- * 2014/11/28  - [Zhaoyang Chen] created for S2L
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ *    2014/11/28  - [Zhaoyang Chen] created for S2L
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
  *
- */
+ * This file and its contents ( "Software" ) are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+******************************************************************************/
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -28,6 +46,15 @@
 #include <basetypes.h>
 #include <iav_ioctl.h>
 
+#ifndef AM_IOCTL
+#define AM_IOCTL(_filp, _cmd, _arg)	\
+		do { 						\
+			if (ioctl(_filp, _cmd, _arg) < 0) {	\
+				perror(#_cmd);		\
+				return -1;			\
+			}						\
+		} while (0)
+#endif
 
 #define MAX_ENCODE_STREAM_NUM		(IAV_STREAM_MAX_NUM_IMPL)
 #define QP_MATRIX_SINGLE_SIZE		(96 << 10)
@@ -50,20 +77,25 @@
 		}	\
 	} while (0)
 
+typedef enum {
+	ROI_TYPE_QP_QUALITY = 0,
+	ROI_TYPE_QP_OFFSET,
+	ROI_TYPE_ZMV_THRESHOLD,
+} ROI_TYPE;
 
-typedef struct qp_roi_s {
+typedef struct h264_roi_s {
 	int quality;		// 0 means the ROI is in the default QP RC.
 	int qp_frame_type;
 	int qp_offset;
+	int zmv_threshold;
 	int start_x;
 	int start_y;
 	int width;
 	int height;
-} qp_roi_t;
+} h264_roi_t;
 
 typedef struct stream_roi_s {
 	int enable;
-	int qp_type;
 	int encode_width;
 	int encode_height;
 	s8 qp_delta[MAX_QP_DELTA_NUM];
@@ -78,7 +110,7 @@ static int single_matrix_size = 0;
 static int stream_matrix_num = 0;
 
 static stream_roi_t stream_roi[MAX_ENCODE_STREAM_NUM];
-static qp_roi_t qp_roi[MAX_ENCODE_STREAM_NUM];
+static h264_roi_t h264_roi[MAX_ENCODE_STREAM_NUM];
 
 static void usage(void)
 {
@@ -109,13 +141,19 @@ static int show_stream_menu(int stream_id)
 	VERIFY_STREAMID(stream_id);
 	printf("\n|-------------------------------|\n");
 	printf("| Stream %c                \t|\n", 'A' + stream_id);
-	printf("| 1 - Config QP ROI        \t|\n");
-	printf("| 2 - Add an ROI         \t|\n");
-	printf("| 3 - Remove an ROI      \t|\n");
-	printf("| 4 - Clear all ROIs     \t|\n");
-	printf("| 5 - View ROI           \t|\n");
-	printf("| 6 - Check ROI pattern	 \t|\n");
-	printf("| q - Back to Main menu  \t|\n");
+	printf("|  1 - Config QP Quality       \t|\n");
+	printf("|  2 - Add QP Quality          \t|\n");
+	printf("|  3 - View QP Quality         \t|\n");
+	printf("|  4 - Remove QP Quality       \t|\n");
+	printf("|  5 - Add QP Offset           \t|\n");
+	printf("|  6 - View QP Offset          \t|\n");
+	printf("|  7 - Remove QP Offset        \t|\n");
+	printf("|  8 - Config ZMV Threshold    \t|\n");
+	printf("|  9 - Add ZMV Threshold       \t|\n");
+	printf("|  a - View ZMV Threshold      \t|\n");
+	printf("|  b - Remove ZMV Threshold    \t|\n");
+	printf("|  c - Clear all ROI           \t|\n");
+	printf("|  q - Back to Main menu       \t|\n");
 	printf("|-------------------------------|\n");
 
 	return 0;
@@ -143,7 +181,7 @@ static int map_qp_matrix(void)
 	return 0;
 }
 
-static int check_for_qp_roi(int stream_id)
+static int check_for_roi(int stream_id)
 {
 	struct iav_stream_info stream_info;
 	struct iav_stream_format stream_format;
@@ -171,8 +209,14 @@ static int check_for_qp_roi(int stream_id)
 		printf("Stream %c encode format shall be H.264.\n", 'A' + stream_id);
 		return -1;
 	}
-	stream_roi[stream_id].encode_width = stream_format.enc_win.width;
-	stream_roi[stream_id].encode_height = stream_format.enc_win.height;
+
+	if (stream_format.rotate_cw == 0) {
+		stream_roi[stream_id].encode_width = stream_format.enc_win.width;
+		stream_roi[stream_id].encode_height = stream_format.enc_win.height;
+	} else {
+		stream_roi[stream_id].encode_width = stream_format.enc_win.height;
+		stream_roi[stream_id].encode_height = stream_format.enc_win.width;
+	}
 
 	return 0;
 }
@@ -196,7 +240,7 @@ static int get_qp_roi(int stream_id, struct iav_qpmatrix *matrix)
 	return 0;
 }
 
-static int set_qp_roi(int stream_id, int qp_type)
+static int set_qp_roi(int stream_id, int type)
 {
 	struct iav_stream_cfg stream_cfg;
 	struct iav_qpmatrix *qp_matrix;
@@ -221,33 +265,46 @@ static int set_qp_roi(int stream_id, int qp_type)
 	buf_pitch = ROUND_UP(buf_width, 8);
 	buf_height = ROUND_UP(stream_roi[stream_id].encode_height, 16) / 16;
 
-	start_x = ROUND_DOWN(qp_roi[stream_id].start_x, 16) / 16;
-	start_y = ROUND_DOWN(qp_roi[stream_id].start_y, 16) / 16;
-	end_x = ROUND_UP(qp_roi[stream_id].width, 16) / 16 + start_x;
-	end_y = ROUND_UP(qp_roi[stream_id].height, 16) / 16 + start_y;
+	start_x = ROUND_DOWN(h264_roi[stream_id].start_x, 16) / 16;
+	start_y = ROUND_DOWN(h264_roi[stream_id].start_y, 16) / 16;
+	end_x = ROUND_UP(h264_roi[stream_id].width, 16) / 16 + start_x;
+	end_y = ROUND_UP(h264_roi[stream_id].height, 16) / 16 + start_y;
 
-	if (qp_type == QPROI_TYPE_QP_QUALITY) {
+	if (type == ROI_TYPE_QP_QUALITY) {
+		// Always use I frame buffer no matter in IPB mode or not
 		addr = qp_matrix_addr + stream_qp_matrix_size * stream_id;
+	} else if (type == ROI_TYPE_ZMV_THRESHOLD) {
+		if (stream_matrix_num == 3) {
+			// Only P frame setting is valid
+			addr = qp_matrix_addr + stream_qp_matrix_size * stream_id +
+			single_matrix_size;
+		} else {
+			addr = qp_matrix_addr + stream_qp_matrix_size * stream_id;
+		}
 	} else {
 		addr = qp_matrix_addr + stream_qp_matrix_size * stream_id +
-			qp_roi[stream_id].qp_frame_type * single_matrix_size;
+			h264_roi[stream_id].qp_frame_type * single_matrix_size;
 	}
 	roi_addr = (struct iav_qproi_data *)addr;
-	if (qp_type == QPROI_TYPE_QP_QUALITY) {
+	if (type == ROI_TYPE_QP_QUALITY) {
+		for (i = start_y; i < end_y && i < buf_height; i++) {
+			for (j = start_x; j < end_x && j < buf_width; j++)
+				roi_addr[i * buf_pitch + j].qp_quality = h264_roi[stream_id].quality;
+		}
+	} else if (type == ROI_TYPE_QP_OFFSET){
 		for (i = start_y; i < end_y && i < buf_height; i++) {
 			for (j = start_x; j < end_x && j < buf_width; j++)
-				roi_addr[i * buf_pitch + j].qp_quality = qp_roi[stream_id].quality;
+				roi_addr[i * buf_pitch + j].qp_offset = h264_roi[stream_id].qp_offset;
 		}
 	} else {
 		for (i = start_y; i < end_y && i < buf_height; i++) {
 			for (j = start_x; j < end_x && j < buf_width; j++)
-				roi_addr[i * buf_pitch + j].qp_offset = qp_roi[stream_id].qp_offset;
+				roi_addr[i * buf_pitch + j].zmv_threshold = h264_roi[stream_id].zmv_threshold;
 		}
 	}
 
 	stream_cfg.id = stream_id;
 	stream_cfg.cid = IAV_H264_CFG_QP_ROI;
-	qp_matrix->type = qp_type;
 	qp_matrix->size = buf_pitch * buf_height * sizeof(struct iav_qproi_data);
 	if (ioctl(fd_iav, IAV_IOC_SET_STREAM_CONFIG, &stream_cfg) < 0) {
 		perror("IAV_IOC_SET_STREAM_CONFIG");
@@ -258,15 +315,15 @@ static int set_qp_roi(int stream_id, int qp_type)
 	return 0;
 }
 
-static int clear_qp_roi(int stream_id)
+static int clear_all_roi(int stream_id)
 {
 	struct iav_stream_cfg stream_cfg;
 	struct iav_qpmatrix *qp_matrix;
 	u32 *addr = (u32 *)(qp_matrix_addr + stream_qp_matrix_size * stream_id);
 
 	VERIFY_STREAMID(stream_id);
-	if (check_for_qp_roi(stream_id) < 0) {
-		perror("check_for_qp_roi\n");
+	if (check_for_roi(stream_id) < 0) {
+		perror("check_for_roi\n");
 		return -1;
 	}
 
@@ -287,12 +344,12 @@ static int clear_qp_roi(int stream_id)
 		return -1;
 	}
 	stream_roi[stream_id].enable = 0;
-	printf("\nClear all qp matrix for stream %c.\n", 'A' + stream_id);
+	printf("\nClear all roi matrix for stream %c.\n", 'A' + stream_id);
 
 	return 0;
 }
 
-static int display_qp_roi(int stream_id)
+static int display_roi(int stream_id, int type)
 {
 	int i, j, k;
 	struct iav_qpmatrix qp_matrix;
@@ -308,12 +365,13 @@ static int display_qp_roi(int stream_id)
 		return -1;
 
 	if (qp_matrix.enable) {
-		if (qp_matrix.type == QPROI_TYPE_QP_QUALITY) {
+		if (type == ROI_TYPE_QP_QUALITY) {
+			// Always use I frame buffer no matter in IPB mode or not
 			addr = qp_matrix_addr + stream_qp_matrix_size * stream_id;
 			roi_addr = (struct iav_qproi_data *)addr;
 			for (i = 0; i < QP_FRAME_TYPE_NUM; i++) {
 				printf("\n\n=============================================\n");
-				printf("QP ROI TYPE: QUALITY\n");
+				printf("QP QUALITY\n");
 				printf("Quality level: 0-[%d], 1-[%d], 2-[%d], 3-[%d]\n",
 				       qp_matrix.qp_delta[i][0], qp_matrix.qp_delta[i][1],
 				       qp_matrix.qp_delta[i][2],qp_matrix.qp_delta[i][3]);
@@ -322,12 +380,12 @@ static int display_qp_roi(int stream_id)
 			for (i = 0; i < buf_height; i++) {
 				printf("\n");
 				for (j = 0; j < buf_width; j++)
-					printf("%-2d", roi_addr[i * buf_pitch + j].qp_quality);
+					printf("%-3d", roi_addr[i * buf_pitch + j].qp_quality);
 			}
 			printf("\n");
-		} else if (qp_matrix.type == QPROI_TYPE_QP_OFFSET) {
+		} else if (type == ROI_TYPE_QP_OFFSET) {
 			printf("\n\n=============================================\n");
-			printf("QP ROI TYPE: QP offset\n");
+			printf("QP offset\n");
 			for (i = 0; i < stream_matrix_num; i++) {
 				addr = qp_matrix_addr + stream_qp_matrix_size * stream_id +
 					i * single_matrix_size;
@@ -354,12 +412,30 @@ static int display_qp_roi(int stream_id)
 				for (j = 0; j < buf_height; j++) {
 					printf("\n");
 					for (k = 0; k < buf_width; k++)
-						printf("%2d", roi_addr[j * buf_pitch + k].qp_offset);
+						printf("%3d", roi_addr[j * buf_pitch + k].qp_offset);
 				}
 				printf("\n");
 			}
+		} else if (type == ROI_TYPE_ZMV_THRESHOLD) {
+			if (stream_matrix_num == 3) {
+				// Only P frame setting is valid
+				addr = qp_matrix_addr + stream_qp_matrix_size * stream_id +
+				single_matrix_size;
+			} else {
+				addr = qp_matrix_addr + stream_qp_matrix_size * stream_id;
+			}
+			roi_addr = (struct iav_qproi_data *)addr;
+			printf("\n\n=============================================\n");
+			printf("ZMV THRESHOLD\n");
+			printf("=============================================\n");
+			for (i = 0; i < buf_height; i++) {
+				printf("\n");
+				for (j = 0; j < buf_width; j++)
+					printf("%-3d", roi_addr[i * buf_pitch + j].zmv_threshold);
+			}
+			printf("\n");
 		} else {
-			printf("Invalid qp roi type!\n");
+			printf("Invalid roi type!\n");
 			return -1;
 		}
 	}
@@ -367,20 +443,6 @@ static int display_qp_roi(int stream_id)
 	return 0;
 }
 
-static int get_qp_roi_type(int stream_id)
-{
-	struct iav_qpmatrix qp_matrix;
-
-	VERIFY_STREAMID(stream_id);
-	if (get_qp_roi(stream_id, &qp_matrix) < 0)
-		return -1;
-
-	stream_roi[stream_id].qp_type = qp_matrix.type;
-
-	return 0;
-}
-
-
 static int get_quality_level(int stream_id)
 {
 	struct iav_qpmatrix qp_matrix;
@@ -427,55 +489,6 @@ static int set_quality_level(int stream_id)
 	return 0;
 }
 
-static int fill_qp_offset(int stream_id)
-{
-	struct iav_stream_cfg stream_cfg;
-	struct iav_qpmatrix *qp_matrix;
-	int i, j, k;
-	u8 *addr;
-	struct iav_qproi_data *roi_addr;
-	u32 buf_width, buf_pitch, buf_height;
-
-	VERIFY_STREAMID(stream_id);
-	qp_matrix = &stream_cfg.arg.h264_roi;
-	if (get_qp_roi(stream_id, qp_matrix) < 0)
-		return -1;
-
-	qp_matrix->id = stream_id;
-	qp_matrix->enable = 1;
-	qp_matrix->qpm_no_update = 0;
-	qp_matrix->qpm_no_check = 1;
-
-	// QP matrix is MB level. One MB is 16x16 pixels.
-	buf_width = ROUND_UP(stream_roi[stream_id].encode_width, 16) / 16;
-	buf_pitch = ROUND_UP(buf_width, 8);
-	buf_height = ROUND_UP(stream_roi[stream_id].encode_height, 16) / 16;
-
-	for (i = 0; i < stream_matrix_num; i++) {
-		addr = qp_matrix_addr + stream_qp_matrix_size * stream_id +
-			i * single_matrix_size;
-		roi_addr = (struct iav_qproi_data *)addr;
-
-		for (j = 0; j < buf_height; j++)
-			for (k = 0; k < buf_width; k++) {
-				roi_addr[j * buf_pitch + k].qp_offset = k % 103 - 51;
-		}
-	}
-
-	stream_cfg.id = stream_id;
-	stream_cfg.cid = IAV_H264_CFG_QP_ROI;
-	qp_matrix->type = stream_roi[stream_id].qp_type;
-	qp_matrix->size = buf_pitch * buf_height * sizeof(struct iav_qproi_data);
-	if (ioctl(fd_iav, IAV_IOC_SET_STREAM_CONFIG, &stream_cfg) < 0) {
-		perror("IAV_IOC_SET_STREAM_CONFIG");
-		return -1;
-	}
-	stream_roi[stream_id].enable = 1;
-	printf("\nFilled qp matrix with qp offset for stream %c.\n", 'A' + stream_id);
-
-	return 0;
-}
-
 static int input_value(int min, int max)
 {
 	int retry, i, input = 0;
@@ -518,12 +531,50 @@ static int input_value(int min, int max)
 	return input;
 }
 
+static void input_roi_size(int stream_id)
+{
+	printf("\nInput ROI offset x (0~%d): ", stream_roi[stream_id].encode_width - 1);
+	h264_roi[stream_id].start_x = input_value(0, stream_roi[stream_id].encode_width - 1);
+	printf("Input ROI offset y (0~%d): ", stream_roi[stream_id].encode_height - 1);
+	h264_roi[stream_id].start_y = input_value(0, stream_roi[stream_id].encode_height -1);
+	printf("Input ROI width (1~%d): ", stream_roi[stream_id].encode_width
+	    - h264_roi[stream_id].start_x);
+	h264_roi[stream_id].width = input_value(1, stream_roi[stream_id].encode_width
+		- h264_roi[stream_id].start_x);
+	printf("Input ROI height (1~%d): ", stream_roi[stream_id].encode_height
+	    - h264_roi[stream_id].start_y);
+	h264_roi[stream_id].height = input_value(1, stream_roi[stream_id].encode_height
+		- h264_roi[stream_id].start_y);
+}
+
+static int get_mv_threshold_param(int stream)
+{
+	struct iav_h264_cfg h264cfg;
+
+	memset(&h264cfg, 0, sizeof(h264cfg));
+	h264cfg.id = stream;
+	AM_IOCTL(fd_iav, IAV_IOC_GET_H264_CONFIG, &h264cfg);
+
+	return h264cfg.mv_threshold;
+}
+
+static int set_mv_threshold_param(int stream, int enable)
+{
+	struct iav_h264_cfg h264cfg;
+
+	memset(&h264cfg, 0, sizeof(h264cfg));
+	h264cfg.id = stream;
+	AM_IOCTL(fd_iav, IAV_IOC_GET_H264_CONFIG, &h264cfg);
+	h264cfg.mv_threshold = enable;
+	AM_IOCTL(fd_iav, IAV_IOC_SET_H264_CONFIG, &h264cfg);
+
+	return 0;
+}
 
 static int config_stream_roi(int stream_id)
 {
 	int back2main = 0, i;
 	char opt, input[16];
-	char roi_type[2][32] = {"Quality Level", "QP offset"};
 	while (back2main == 0) {
 		show_stream_menu(stream_id);
 		printf("Your choice: ");
@@ -531,84 +582,102 @@ static int config_stream_roi(int stream_id)
 		opt = tolower(input[0]);
 		switch(opt) {
 		case '1':
-			if (check_for_qp_roi(stream_id) < 0)
+			if (check_for_roi(stream_id) < 0)
 				break;
-			get_qp_roi_type(stream_id);
-			printf("\nCurrent QP ROI type is: %s.\n",
-				roi_type[stream_roi[stream_id].qp_type]);
-			printf("Input QP ROI type (0 for Quality Level; 1 for QP offset): ");
-			stream_roi[stream_id].qp_type = input_value(0, 1);
-			if (stream_roi[stream_id].qp_type == QPROI_TYPE_QP_QUALITY) {
-				if (get_quality_level(stream_id) < 0)
-					break;
-				printf("\nCurrent quality level is 1:[%d], 2:[%d], 3:[%d].\n",
-						stream_roi[stream_id].qp_delta[0],
-						stream_roi[stream_id].qp_delta[1],
-						stream_roi[stream_id].qp_delta[2]);
-				i = 0;
-				do {
-					printf("Input QP delta (-51~51) for level %d: ", i+1);
-					stream_roi[stream_id].qp_delta[i] = input_value(-51, 51);
-				} while (++i < MAX_QP_DELTA_NUM);
-				set_quality_level(stream_id);
-			}
+			if (get_quality_level(stream_id) < 0)
+				break;
+			printf("\nCurrent quality level is 1:[%d], 2:[%d], 3:[%d].\n",
+					stream_roi[stream_id].qp_delta[0],
+					stream_roi[stream_id].qp_delta[1],
+					stream_roi[stream_id].qp_delta[2]);
+			i = 0;
+			do {
+				printf("Input QP delta (-51~51) for level %d: ", i+1);
+				stream_roi[stream_id].qp_delta[i] = input_value(-51, 51);
+			} while (++i < MAX_QP_DELTA_NUM);
+			set_quality_level(stream_id);
 			break;
 		case '2':
-		case '3':
-			if (check_for_qp_roi(stream_id) < 0)
+		case '4':
+			if (check_for_roi(stream_id) < 0)
 				break;
-			printf("\nInput ROI offset x (0~%d): ", stream_roi[stream_id].encode_width - 1);
-			qp_roi[stream_id].start_x = input_value(0, stream_roi[stream_id].encode_width - 1);
-			printf("Input ROI offset y (0~%d): ", stream_roi[stream_id].encode_height - 1);
-			qp_roi[stream_id].start_y = input_value(0, stream_roi[stream_id].encode_height -1);
-			printf("Input ROI width (1~%d): ", stream_roi[stream_id].encode_width
-		        - qp_roi[stream_id].start_x);
-			qp_roi[stream_id].width = input_value(1, stream_roi[stream_id].encode_width
-				- qp_roi[stream_id].start_x);
-			printf("Input ROI height (1~%d): ", stream_roi[stream_id].encode_height
-			    - qp_roi[stream_id].start_y);
-			qp_roi[stream_id].height = input_value(1, stream_roi[stream_id].encode_height
-				- qp_roi[stream_id].start_y);
-			if (stream_roi[stream_id].qp_type == QPROI_TYPE_QP_QUALITY) {
-				if (opt == '2') {
-					printf("Input ROI quality level (1~%d): ", MAX_QP_DELTA_NUM);
-					qp_roi[stream_id].quality = input_value(1, MAX_QP_DELTA_NUM);
-				} else {
-					qp_roi[stream_id].quality = 0;
-				}
+
+			input_roi_size(stream_id);
+
+			if (opt == '2') {
+				printf("Input ROI quality level (1~%d): ", MAX_QP_DELTA_NUM);
+				h264_roi[stream_id].quality = input_value(1, MAX_QP_DELTA_NUM);
 			} else {
-				if (stream_matrix_num == 3) {
-					printf("Input Frame type (0 for I frame; 1 for P frame; 2 for B frame): ");
-					qp_roi[stream_id].qp_frame_type = input_value(0, 2);
-				}
-				if (opt == '2') {
-					printf("Input ROI qp offset (-51~51): ");
-					qp_roi[stream_id].qp_offset = input_value(-51, 51);
-				} else {
-					qp_roi[stream_id].qp_offset = 0;
-				}
+				h264_roi[stream_id].quality = 0;
 			}
-			set_qp_roi(stream_id, stream_roi[stream_id].qp_type);
-			break;
-		case '4':
-			if (check_for_qp_roi(stream_id) < 0)
-				break;
-			clear_qp_roi(stream_id);
+
+			set_qp_roi(stream_id, ROI_TYPE_QP_QUALITY);
 			break;
 		case '5':
-			if (check_for_qp_roi(stream_id) < 0)
+		case '7':
+			if (check_for_roi(stream_id) < 0)
 				break;
-			display_qp_roi(stream_id);
+
+			input_roi_size(stream_id);
+
+			if (stream_matrix_num == 3) {
+				printf("Input Frame type (0 for I frame; 1 for P frame; 2 for B frame): ");
+				h264_roi[stream_id].qp_frame_type = input_value(0, 2);
+			}
+			if (opt == '5') {
+				printf("Input ROI qp offset (-51~51): ");
+				h264_roi[stream_id].qp_offset = input_value(-51, 51);
+			} else {
+				h264_roi[stream_id].qp_offset = 0;
+			}
+
+			set_qp_roi(stream_id, ROI_TYPE_QP_OFFSET);
 			break;
-		case '6':
-			if (check_for_qp_roi(stream_id) < 0)
+		case '8':
+			printf("\nConfig mv threshold: 0: Disable, 1: Enable; Current is %s.\n",
+				get_mv_threshold_param(stream_id) ? "Enable" : "Disable");
+			i = input_value(0, 1);
+			set_mv_threshold_param(stream_id, i);
+			break;
+		case '9':
+		case 'b':
+			if (check_for_roi(stream_id) < 0)
+				break;
+
+			if (get_mv_threshold_param(stream_id) == 0) {
+				printf("Please enable mv threshold in menu 8 first!\n");
 				break;
-			if (stream_roi[stream_id].qp_type != QPROI_TYPE_QP_OFFSET) {
-				printf("Invalid QP ROI type: %d!\n",
-					stream_roi[stream_id].qp_type);
+			}
+			input_roi_size(stream_id);
+
+			if (opt == '9') {
+				printf("Input ROI zmv threshold (0~255): ");
+				h264_roi[stream_id].zmv_threshold= input_value(0, 255);
 			} else {
-				fill_qp_offset(stream_id);
+				h264_roi[stream_id].zmv_threshold = 0;
 			}
+
+			set_qp_roi(stream_id, ROI_TYPE_ZMV_THRESHOLD);
+			break;
+		case '3':
+			if (check_for_roi(stream_id) < 0)
+				break;
+			display_roi(stream_id, ROI_TYPE_QP_QUALITY);
+			break;
+		case '6':
+			if (check_for_roi(stream_id) < 0)
+				break;
+			display_roi(stream_id, ROI_TYPE_QP_OFFSET);
+			break;
+		case 'a':
+			if (check_for_roi(stream_id) < 0)
+				break;
+			display_roi(stream_id, ROI_TYPE_ZMV_THRESHOLD);
+			break;
+		case 'c':
+			if (check_for_roi(stream_id) < 0)
+				break;
+			clear_all_roi(stream_id);
 			break;
 		case 'q':
 			back2main = 1;
@@ -621,13 +690,15 @@ static int config_stream_roi(int stream_id)
 	return 0;
 }
 
-static void quit_qp_roi()
+static void quit_roi()
 {
 	int i;
 	exit_flag = 1;
-	for (i = 0; i < MAX_ENCODE_STREAM_NUM; i++)
-		if (stream_roi[i].enable)
-			clear_qp_roi(i);
+	for (i = 0; i < MAX_ENCODE_STREAM_NUM; i++) {
+		if (stream_roi[i].enable) {
+			clear_all_roi(i);
+		}
+	}
 	exit(0);
 }
 
@@ -647,9 +718,9 @@ int main(int argc, char **argv)
 	if (map_qp_matrix() < 0)
 		return -1;
 
-	signal(SIGINT, quit_qp_roi);
-	signal(SIGTERM, quit_qp_roi);
-	signal(SIGQUIT, quit_qp_roi);
+	signal(SIGINT, quit_roi);
+	signal(SIGTERM, quit_roi);
+	signal(SIGQUIT, quit_roi);
 
 	while (exit_flag == 0) {
 		show_main_menu();
diff --git a/iav_test/test_statistics.c b/iav_test/test_statistics.c
index fd0b3c8..6062100 100644
--- a/iav_test/test_statistics.c
+++ b/iav_test/test_statistics.c
@@ -1,17 +1,34 @@
-/********************************************************************
+/*
  * test_statistics.c
  *
  * History:
  *	2012/08/09 - [Jian Tang] created file
  *
- * Copyright (C) 2007-2016, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- ********************************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include <unistd.h>
 #include <fcntl.h>
@@ -44,8 +61,16 @@
 
 #define MAX_MVDUMP_DIVISION_FACTOR		(30)
 
-#define MAX_NUM_ENCODE_STREAMS	(2)
+#define MAX_NUM_ENCODE_STREAMS	(1)
+
+typedef enum {
+	DUMP_NONE = 0,
+	DUMP_MV = 1,
+	DUMP_TOTAL_NUM,
 
+	DUMP_FIRST = DUMP_MV,
+	DUMP_LAST = DUMP_TOTAL_NUM,
+} DUMP_DATA_TYPE;
 
 #ifndef AM_IOCTL
 #define AM_IOCTL(_filp, _cmd, _arg)	\
@@ -74,19 +99,17 @@ struct hint_s {
 	const char *str;
 };
 
-static const char *short_opts = "ABCDEFGHm:v";
+static const char *short_opts = "ABCDb:cd:v";
 
 static struct option long_opts[] = {
 	{"stream-A",	NO_ARG, 0, 'A'},
 	{"stream-B",	NO_ARG, 0, 'B'},
 	{"stream-C",	NO_ARG, 0, 'C'},
 	{"stream-D",	NO_ARG, 0, 'D'},
-	{"stream-E",	NO_ARG, 0, 'E'},
-	{"stream-F",	NO_ARG, 0, 'F'},
-	{"stream-G",	NO_ARG, 0, 'G'},
-	{"stream-H",	NO_ARG, 0, 'H'},
-	{"mv-div",	HAS_ARG, 0, 'm'},
-	{"verbose",	NO_ARG, 0, 'v'},
+	{"non-block",	HAS_ARG, 0, 'b'},
+	{"non-stop",	NO_ARG,  0, 'c'},
+	{"dump",		HAS_ARG, 0, 'd'},
+	{"verbose",		NO_ARG, 0, 'v'},
 
 	{0, 0, 0, 0}
 };
@@ -96,19 +119,18 @@ static const struct hint_s hint[] = {
 	{"", "\tSet configuration for stream B"},
 	{"", "\tSet configuration for stream C"},
 	{"", "\tSet configuration for stream D"},
-	{"", "\tSet configuration for stream E"},
-	{"", "\tSet configuration for stream F"},
-	{"", "\tSet configuration for stream G"},
-	{"", "\tSet configuration for stream H"},
-	{"1~30", "\tSet the frequency of motion vectors dumped in DRAM, default is 3\n"},
-
-	{"", "\tprint more messages"},
+	{"0|1", "Select the read method, 0 is block call, 1 is non-block call. Default is block call."},
+	{"",	"\tContinuous mv dump."},
+	{"1~1", "\tDump data. 1: Dump MV statistics."},
+	{"", "\tPrint more messages"},
 };
 
 
 static int fd_iav = -1;
 static int current_stream = -1;
-static int mvdump_division_factor = 3;
+static int non_block_read = 0;
+static int non_stop = 0;
+static int dump_data_type = DUMP_NONE;
 static int verbose = 0;
 u8 *mvbuf_mem = NULL;
 u32 mvbuf_size;
@@ -130,8 +152,8 @@ static void usage(void)
 	}
 	printf("\n");
 	printf("Examples:\n");
-	printf("  Dump MV statistics data per 5 frames:\n");
-	printf("    test_statistics -A -m 5\n\n");
+	printf("  Dump MV statistics data with blocking way:\n");
+	printf("    test_statistics -A -d 1 -b 0 \n\n");
 }
 
 static int init_param(int argc, char **argv)
@@ -154,27 +176,25 @@ static int init_param(int argc, char **argv)
 		case 'D':
 			current_stream = 3;
 			break;
-		case 'E':
-			current_stream = 4;
-			break;
-		case 'F':
-			current_stream = 5;
-			break;
-		case 'G':
-			current_stream = 6;
+		case 'b':
+			value = atoi(optarg);
+			if (value < 0 || value > 1) {
+				printf("Read flag [%d] must be [0|1].\n", value);
+				return -1;
+			}
+			non_block_read = value;
 			break;
-		case 'H':
-			current_stream = 7;
+		case 'c':
+			non_stop = 1;
 			break;
-		case 'm':
-			VERIFY_STREAMID(current_stream);
+		case 'd':
 			value = atoi(optarg);
-			if (value < 1 || value > MAX_MVDUMP_DIVISION_FACTOR) {
-				printf("Please set the division factor [%d] from the range of [1~%d]\n",
-					value, MAX_MVDUMP_DIVISION_FACTOR);
+			if (value < DUMP_FIRST || value >= DUMP_LAST) {
+				printf("Dump data type %d must be in the range of [%d~%d].\n",
+					value, DUMP_FIRST, (DUMP_LAST - 1));
 				return -1;
 			}
-			mvdump_division_factor = value;
+			dump_data_type = value;
 			break;
 		case 'v':
 			verbose = 1;
@@ -197,44 +217,61 @@ static int map_buffer(void)
 		perror("IAV_IOC_QUERY_BUF");
 		return -1;
 	}
-
 	mvbuf_size = querybuf.length;
-	mvbuf_mem = mmap(NULL, mvbuf_size, PROT_READ, MAP_SHARED, fd_iav, querybuf.offset);
+	if (mvbuf_size == 0) {
+		printf("MV data mem size cannot be zero!\n");
+		return -1;
+	}
+	mvbuf_mem = mmap(NULL, mvbuf_size, PROT_READ, MAP_SHARED, fd_iav,
+		querybuf.offset);
 	if (mvbuf_mem == MAP_FAILED) {
 		perror("mmap (%d) failed: %s\n");
 		return -1;
 	}
+	if (verbose) {
+		printf("MV data mem base addr: 0x%x, size: 0x%x.\n",
+			(u32)mvbuf_mem, mvbuf_size);
+	}
 
 	return 0;
 }
 
-static int display_mv_statistics(struct iav_statisdesc *statisdesc)
+static int check_mv_statis(void)
 {
-	struct iav_motion_vector *mv_dump = NULL;
-	u32 stream_pitch, stream_height;
-	int i, j;
+	struct iav_stream_info info;
+
+	info.id = current_stream;
+	AM_IOCTL(fd_iav, IAV_IOC_GET_STREAM_INFO, &info);
+	if (info.state != IAV_STREAM_STATE_ENCODING) {
+		printf("The stream state should be encoding for MV statis!\n");
+		return -1;
+	}
 
-	stream_pitch = statisdesc->mvdump_pitch;
-	stream_height = statisdesc->mvdump_unit_sz / statisdesc->mvdump_pitch;
-	stream_pitch /= sizeof(struct iav_motion_vector);
+	return 0;
+}
 
-	printf("Motion vector for stream [%d], frame [%d], PTS [%lld], pitch [%d],"
-		" unit size [%d].\n", current_stream, statisdesc->frame_num,
-		statisdesc->dsp_pts, stream_pitch, stream_height);
+static int display_mv_statis(struct iav_statisdesc *desc)
+{
+	struct iav_mv *mv = NULL;
+	int i, j;
 
-	mv_dump = (struct iav_motion_vector *)(mvbuf_mem + statisdesc->data_addr_offset);
+	printf("Motion Vector for stream [%d], frame num [%u], dsp PTS [%u], "
+		"mono PTS [%llu], width [%u], pitch [%u], height [%u].\n",
+		current_stream, desc->frame_num, desc->dsp_pts, desc->arm_pts,
+		desc->width, desc->pitch, desc->height);
 
+	mv = (struct iav_mv *)(mvbuf_mem + desc->data_addr_offset);
 	printf("Motion Vector X Matrix : \n");
-	for (i = 0; i < stream_height; ++i) {
-		for (j = 0; j < stream_pitch; ++j) {
-			printf("%d ", mv_dump[i * stream_pitch + j].x);
+	for (i = 0; i < desc->height; ++i) {
+		for (j = 0; j < desc->width; ++j) {
+			printf("%d ", mv[i * desc->pitch + j].x);
 		}
 		printf("\n");
 	}
 	printf("Motion Vector Y Matrix : \n");
-	for (i = 0; i < stream_height; ++i) {
-		for (j = 0; j < stream_pitch; ++j) {
-			printf("%d ", mv_dump[i * stream_pitch + j].y);
+	for (i = 0; i < desc->height; ++i) {
+		for (j = 0; j <  desc->width; ++j) {
+			printf("%d ", mv[i * desc->pitch + j].y);
 		}
 		printf("\n");
 	}
@@ -242,32 +279,61 @@ static int display_mv_statistics(struct iav_statisdesc *statisdesc)
 	return 0;
 }
 
-static int get_mv_statistics(void)
+static int get_mv_statis(void)
 {
 	struct iav_querydesc query_desc;
-	//struct iav_statiscfg statiscfg;
-	struct iav_statisdesc *statis_desc;
-
-	//statiscfg.id = current_stream;
-	//statiscfg.enable = 1;
-	//statiscfg.mvdump_div = mvdump_division_factor;
-	//AM_IOCTL(fd_iav, IAVIOC_S_STATISCFG, &statiscfg);
+	struct iav_statisdesc *desc;
 
 	query_desc.qid = IAV_DESC_STATIS;
-	statis_desc = &query_desc.arg.statis;
-	statis_desc->id = current_stream;
-	AM_IOCTL(fd_iav, IAV_IOC_QUERY_DESC, &query_desc);
-	if (display_mv_statistics(statis_desc) < 0) {
-		printf("Failed to display motion vector!\n");
+	desc = &query_desc.arg.statis;
+	desc->id = current_stream;
+
+	if (non_block_read == 0) {
+		desc->time_ms = 0;
+		AM_IOCTL(fd_iav, IAV_IOC_QUERY_DESC, &query_desc);
+	} else {
+		desc->time_ms = -1;
+		// make sue valid MV statis for non blocking read
+		while (ioctl(fd_iav, IAV_IOC_QUERY_DESC, &query_desc) < 0) {
+			if (errno != EAGAIN) {
+				printf("Failed to query MV statis!\n");
+				return -1;
+			}
+		}
+	}
+	if (display_mv_statis(desc) < 0) {
+		printf("Failed to display Motion Vector!\n");
 		return -1;
 	}
 
-	//statiscfg.enable = 0;
-	//AM_IOCTL(fd_iav, IAVIOC_S_STATISCFG, &statiscfg);
+	return 0;
+}
+
+static int config_mv_statis(int enable)
+{
+	struct iav_stream_cfg cfg;
+	memset(&cfg, 0, sizeof(cfg));
+	cfg.id = current_stream;
+	cfg.cid = IAV_H264_CFG_STATIS;
+	cfg.arg.h264_statis = enable;
+	AM_IOCTL(fd_iav, IAV_IOC_SET_STREAM_CONFIG, &cfg);
 
 	return 0;
 }
 
+static void quit_statis()
+{
+	if (dump_data_type == DUMP_MV) {
+		if (config_mv_statis(0) < 0) {
+			printf("Disable MV statis failed!\n");
+		}
+	}
+	close(fd_iav);
+	fd_iav = -1;
+	exit(1);
+}
+
+
 int main(int argc, char **argv)
 {
 	if (argc < 2) {
@@ -289,8 +355,38 @@ int main(int argc, char **argv)
 		return -1;
 	}
 
-	if (get_mv_statistics() < 0)
-		return -1;
+	signal(SIGINT, quit_statis);
+	signal(SIGTERM, quit_statis);
+	signal(SIGQUIT, quit_statis);
+
+	switch(dump_data_type) {
+	case DUMP_MV:
+		if (check_mv_statis() < 0) {
+			printf("Check MV statis failed!\n");
+			return -1;
+		}
+		if (config_mv_statis(1) < 0) {
+			printf("Enable MV statis failed!\n");
+			return -1;
+		}
+		do {
+			if (get_mv_statis() < 0) {
+				printf("Get MV statis failed!\n");
+				return -1;
+			}
+		} while (non_stop);
+		if (config_mv_statis(0) < 0) {
+			printf("Disable MV statis failed!\n");
+			return -1;
+		}
+		break;
+	default:
+		printf("Invalid dump data type [%d].\n", dump_data_type);
+		break;
+	}
+
+	close(fd_iav);
+	fd_iav = -1;
 
 	return 0;
 }
diff --git a/iav_test/test_stream.c b/iav_test/test_stream.c
index 578b10d..8850dc9 100644
--- a/iav_test/test_stream.c
+++ b/iav_test/test_stream.c
@@ -12,12 +12,29 @@
  *	2009/12/31 - [Louis Sun] modify to use EX functions
  *	2012/01/11 - [Jian Tang] add different transfer method for streams
  *
- * Copyright (C) 2007-2012, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
@@ -36,14 +53,17 @@
 #include <sys/mman.h>
 #include <sys/time.h>
 #include <sys/wait.h>
+#include <sys/select.h>
 #include <time.h>
 #include <assert.h>
+#include <arpa/inet.h>
 
 #include <signal.h>
 #include <basetypes.h>
 #include <iav_ioctl.h>
 #include "datatx_lib.h"
 
+#include <pthread.h>
 
 #ifndef AM_IOCTL
 #define AM_IOCTL(_filp, _cmd, _arg)	\
@@ -60,7 +80,17 @@
 #define MAX_ENCODE_STREAM_NUM	(4)
 #define BASE_PORT			(2000)
 #define SVCT_PORT_OFFSET	(16)
+#define FAST_SEEK_PORT_OFFSET	(20)
+#define STATISTIC_PORT_OFFSET	(1)
 #define MAX_SVCT_LAYERS	(3)
+#define FAST_SEEK_INTVL_MAX	(63)
+#define MIN_SVCT_GOP_STRUCTURE	(2)
+#define MAX_SVCT_GOP_STRUCTURE	(3)
+
+//print and write file intervals
+#define DEFAUT_FPS_STATISTICS_INTERVAL		(300) //Bold fps print.(AVG FPS = ...)
+#define DEFAUT_PRINT_INTERVAL		(30) //(stream A:...)
+#define DEFAUT_WRITE_STATISTICS_INTERVAL	(900) //how often we refresh the statistics file
 
 #define DIV_ROUND(divident, divider)    ( ( (divident)+((divider)>>1)) / (divider) )
 #define COLOR_PRINT0(msg)		printf("\033[34m"msg"\033[39m")
@@ -74,8 +104,6 @@ static int md5_idr_number = -1;
 //debug options
 #undef DEBUG_PRINT_FRAME_INFO
 
-#define ACCURATE_FPS_CALC
-
 #define GET_STREAMID(x)	((((x) < 0) || ((x) >= MAX_ENCODE_STREAM_NUM)) ? -1: (x))
 
 typedef struct transfer_method {
@@ -99,9 +127,11 @@ static int file_size_flag = 0;
 static int file_size_mega_byte = 100;
 static int remove_time_string_flag = 0;
 static int split_svct_layer_flag = 0;
+static int split_fast_seek_flag = 0;
 
-static int fps_statistics_interval = 300;
-static int print_interval = 30;
+static int fps_statistics_interval = DEFAUT_FPS_STATISTICS_INTERVAL;
+static int print_interval = DEFAUT_PRINT_INTERVAL;
+static int write_statistics_interval = DEFAUT_WRITE_STATISTICS_INTERVAL;
 
 //create files for writing
 static int init_none, init_nfs, init_tcp, init_usb, init_stdout;
@@ -119,6 +149,9 @@ const char *default_host_ip_addr = "10.0.0.1";
 //verbose
 static int verbose_mode = 0;
 
+//statistics
+static int statistics_mode = 0;
+
 // options and usage
 #define NO_ARG		0
 #define HAS_ARG		1
@@ -127,6 +160,7 @@ static int verbose_mode = 0;
 #define INFO_OPTIONS_BASE			10
 #define TEST_OPTIONS_BASE			20
 #define MISC_OPTIONS_BASE			40
+#define PRINT_CHARACTER_AMOUNT		1024
 
 enum numeric_short_options {
 	FILENAME = TRANSFER_OPTIONS_BASE,
@@ -145,10 +179,13 @@ enum numeric_short_options {
 	DURATION_TEST = TEST_OPTIONS_BASE,
 	REMOVE_TIME_STRING,
 	SPLIT_SVCT_LAYER,
+	SPLIT_FAST_SEEK,
+	HOST_IP_ADDR,
 };
 
 static struct option long_options[] = {
 	{"filename",	HAS_ARG,	0,	'f'},
+	{"statistics",	HAS_ARG,	0,	's'},
 	{"tcp",		NO_ARG,		0,	't'},
 	{"usb",		NO_ARG,		0,	'u'},
 	{"stdout",	NO_ARG,		0,	'o'},
@@ -161,17 +198,19 @@ static struct option long_options[] = {
 	{"check-pts",	NO_ARG,		0,	CHECK_PTS_INFO},
 	{"rm-time",	NO_ARG,		0,	REMOVE_TIME_STRING},
 	{"split-svct",	NO_ARG,		0,	SPLIT_SVCT_LAYER},
+	{"split-fast-seek", NO_ARG,	0,	SPLIT_FAST_SEEK},
 	{"fps-intvl",	HAS_ARG,	0,	'i'},
 	{"frame-intvl",	HAS_ARG,	0,	'n'},
 	{"streamA",	NO_ARG,		0,	'A'},   // -A xxxxx	means all following configs will be applied to stream A
 	{"streamB",	NO_ARG,		0,	'B'},
 	{"streamC",	NO_ARG,		0,	'C'},
 	{"streamD",	NO_ARG,		0,	'D'},
+	{"host-ip-addr",	HAS_ARG,		0,	HOST_IP_ADDR},
 	{"verbose",	NO_ARG,		0,	'v'},
 	{0, 0, 0, 0}
 };
 
-static const char *short_options = "f:tuoi:n:ABCDv";
+static const char *short_options = "f:s:tuoi:n:ABCDv";
 
 struct hint_s {
 	const char *arg;
@@ -180,6 +219,7 @@ struct hint_s {
 
 static const struct hint_s hint[] = {
 	{"filename", "specify filename"},
+	{"", "\t\tspecify refresh statistics file interval (frames)"},
 	{"", "\t\tuse tcp (ps) to receive bitstream"},
 	{"", "\t\tuse usb (us_pc2) to receive bitstream"},
 	{"", "\t\treceive data from BSB buffer, and write to stdout"},
@@ -192,14 +232,15 @@ static const struct hint_s hint[] = {
 	{"", "\t\tcheck stream pts info"},
 	{"", "\t\tremove time string from the file name"},
 	{"", "\t\tsplit SVCT layers into different streams"},
+	{"", "\tsplit and write fast seek frames into a solo file"},
 	{"", "\t\tset fps statistics interval"},
 	{"", "\tset frame/field statistic interval"},
 	{"", "\t\tstream A"},
 	{"", "\t\tstream B"},
 	{"", "\t\tstream C"},
 	{"", "\t\tstream D"},
+	{"", "\tset the host ip address"},
 	{"", "\t\tprint more information"},
-
 };
 
 void usage(void)
@@ -216,35 +257,114 @@ void usage(void)
 			printf(" [%s]", hint[i].arg);
 		printf("\t%s\n", hint[i].str);
 	}
-	printf("\n");
+	printf("\nStatistics module usage: \n"
+		"\tIt has to run test_stream before enabling encoding stream \n"
+		"\tin order to get accurate statistics values. And when test \n"
+		"\tdone, please end streaming first. \n"
+
+		"\nExample: \n"
+		"\tSave stream file with file name beginning with 'video' under \n"
+		"\t/mnt folder and refresh statistics file every 900 frames.\n"
+		"\t\ttest_stream -f /mnt/video -s 900\n"
+		"\tSave no file and print statistics information every 900 frames.\n"
+		"\t\ttest_stream -s 900 --nofile\n");
 }
 
-
 typedef struct stream_encoding_state_s{
 	int session_id;	//stream encoding session
-	int fd;		//stream write file handle
-	int fd_info;	//info write file handle
-	u32 total_frames; // count how many frames encoded, help to divide for session before session id is implemented
+	u64 total_frames; // count how many frames encoded, help to divide for session before session id is implemented
 	u64 total_bytes;  //count how many bytes encoded
 	int pic_type;	  //picture type,  non changed during encoding, help to validate encoding state.
-	u32 pts;
+	u64 pts;
+	u64 pts_reverse_count;	//self increase 1 when dsp pts reverse
 	u64 monotonic_pts;
+	u64 enc_done_ts;
+	u64 enc_done_ts_diff_sum;
+	u64 i_num;	//record i frame's number
+	u64 total_frames_i;
+	u64 total_frames_p;
+	u64 total_frames_b;
+	u64 total_bytes_i;
+	u64 total_bytes_p;
+	u64 total_bytes_b;
 
 	struct timeval capture_start_time;	//for statistics only,  this "start" is captured start, may be later than actual start
+	struct timeval encoding_start_time;	//the time when encoding starts
 
-#ifdef ACCURATE_FPS_CALC
-	int 	 total_frames2;	//for statistics only
-	struct timeval time2;	//for statistics only
-#endif
+	u64 total_frames2;	//for fps measured every fps_statistics_interval frames
+	struct timeval time2;	//for fps measured every fps_statistics_interval frames
+
+	u64 total_bytes_gop;	//for bitrate measured within the scope of one gop
+	struct timeval time_gop;	//for bitrate measured within the scope of one gop
 
-	int fd_svct[MAX_SVCT_LAYERS];	//file descriptor for svct streams
-	int svct_layers;	//count how many svct layers
 } stream_encoding_state_t;
 
+typedef struct stream_files_s{
+	int session_id;	//stream encoding session
+	u64 total_bytes;  //count how many bytes encoded
+	int fd;		//stream write file handle
+	int fd_info;	//info write file handle
+	int fd_svct[MAX_SVCT_LAYERS];	//file descriptor for svct streams
+	int fd_fast_seek;	//file descriptor for fast seek streams
+	int gop_structure;	//store gop structure
+	int fast_seek_intvl;	//store fast seek intvl
+} stream_files_t;
+
+typedef struct stream_encoding_statistics_s{
+	int statistics_fd;	//file descriptor for statistics file
+	char write_file_name[1024];
+	u32 gop;		//previous gop value
+	u64 max_dsp_pts;
+	u64 min_dsp_pts;
+	u64 avg_dsp_pts;	//avg dsp pts diff from the beginning to the end
+	u64 max_arm_pts;
+	u64 min_arm_pts;
+	u64 avg_arm_pts;	//avg arm pts diff from the beginning to the end
+	u64 max_enc_done_pts;
+	u64 min_enc_done_pts;
+	u64 avg_enc_done_pts;	//avg enc done pts diff from the beginning to the end
+	char *gop_record;	//record different gop value
+	double max_fps;
+	double min_fps;
+	double rt_fps;		//real-time fps, calculated every print_interval frames
+	double avg_fps;		//avg fps measured from the beginning to the end
+	u32 rt_bitrate;		//real-time bitrate, measured every print_interval frames
+	u32 max_bitrate;
+	u32 min_bitrate;
+	u32 avg_bitrate;	//avg bitrate from the beginning to the end
+	u32 max_bitrate_gop;
+	u32 min_bitrate_gop;
+	u32 max_frame_size;
+	u32 min_frame_size;
+	u32 avg_frame_size;	//avg frame size from the beginning to the end
+	u32 max_i_frame;
+	u32 min_i_frame;
+	u32 avg_i_frame;	//avg i frame size from the beginning to the end
+	u32 max_p_frame;
+	u32 min_p_frame;
+	u32 avg_p_frame;	//avg p frame size from the beginning to the end
+	u32 max_b_frame;
+	u32 min_b_frame;
+	u32 avg_b_frame;	//avg b frame size from the beginning to the end
+} stream_encoding_statistics_t;
+
+typedef struct pipe_mesg_s {
+	struct iav_framedesc framedesc;
+	int new_session;
+	int stop;
+} pipe_mesg_t;
+
 static stream_encoding_state_t encoding_states[MAX_ENCODE_STREAM_NUM];
 static stream_encoding_state_t old_encoding_states[MAX_ENCODE_STREAM_NUM];  //old states for statistics only
+static stream_encoding_statistics_t encoding_statistics[MAX_ENCODE_STREAM_NUM]; //store statistics data
+static stream_files_t stream_files[MAX_ENCODE_STREAM_NUM];
+
+//pipe and thread for statistics module
+static int pipefd[2] = {-1, -1};
+static int statistics_run = 1;
+static int write_video_file_run = 1;
 
-int init_param(int argc, char **argv)
+static int init_param(int argc, char **argv)
 {
 	int i, ch;
 	int option_index = 0;
@@ -279,6 +399,10 @@ int init_param(int argc, char **argv)
 				strcpy(stream_transfer[current_stream].filename, optarg);
 			}
 			break;
+		case 's':
+			statistics_mode = 1;
+			write_statistics_interval = atoi(optarg);
+			break;
 		case 't':
 			current_stream = GET_STREAMID(current_stream);
 			if (current_stream >= 0) {
@@ -338,6 +462,16 @@ int init_param(int argc, char **argv)
 		case SPLIT_SVCT_LAYER:
 			split_svct_layer_flag = 1;
 			break;
+		case SPLIT_FAST_SEEK:
+			split_fast_seek_flag = 1;
+			break;
+		case HOST_IP_ADDR:
+			if (INADDR_NONE == inet_addr(optarg)) {
+				printf("ip address error!\n");
+				return -1;
+			}
+			setenv("HOST_IP_ADDR", optarg, 1);
+			break;
 		case 'v':
 			verbose_mode = 1;
 			break;
@@ -386,40 +520,141 @@ int init_param(int argc, char **argv)
 	return 0;
 }
 
-
-
-int init_encoding_states(void)
+static int init_encoding_states(void)
 {
-	int i,j;
-	//init all file hander and session id to invalid at start
+	int i;
+
 	for (i = 0; i < MAX_ENCODE_STREAM_NUM; i++) {
-		encoding_states[i].fd = -1;
-		encoding_states[i].fd_info = -1;
-		encoding_states[i].session_id = -1;
 		encoding_states[i].total_bytes = 0;
 		encoding_states[i].total_frames = 0;
 		encoding_states[i].pic_type = 0;
 		encoding_states[i].pts = 0;
-		encoding_states[i].svct_layers = 0;
+		encoding_states[i].i_num = 0;
+		encoding_states[i].enc_done_ts_diff_sum = 0;
+		encoding_states[i].pts_reverse_count = 0;
+	}
+	return 0;
+}
+
+static int init_stream_files(void)
+{
+	int i,j;
+
+	for(i = 0; i < MAX_ENCODE_STREAM_NUM; i++) {
+		stream_files[i].fd = -1;
+		stream_files[i].fd_info = -1;
+		stream_files[i].session_id = -1;
+		stream_files[i].gop_structure = 0;
+		stream_files[i].total_bytes = 0;
 		for (j = 0; j < MAX_SVCT_LAYERS; ++j) {
-			encoding_states[i].fd_svct[j] = -1;
+			stream_files[i].fd_svct[j] = -1;
 		}
+		stream_files[i].fd_fast_seek = -1;
+		stream_files[i].fast_seek_intvl = 0;
 	}
 	return 0;
 }
 
+static int init_encoding_statistics(void)
+{
+	int i;
+	int err = 0;
+
+	for (i = 0; i < MAX_ENCODE_STREAM_NUM; ++i) {
+		memset(&encoding_statistics[i], 0, sizeof(struct stream_encoding_statistics_s));
+		encoding_statistics[i].statistics_fd = -1;
+		encoding_statistics[i].gop_record = (char *)malloc(sizeof(char)*PRINT_CHARACTER_AMOUNT);
+		if (NULL == encoding_statistics[i].gop_record) {
+			printf("Can't malloc memory for gop_record!\n");
+			err = -1;
+			break;
+		}
+		memset(encoding_statistics[i].gop_record, 0, sizeof(char)*PRINT_CHARACTER_AMOUNT);
+	}
+	if (err < 0) {
+		for (i = 0; i< MAX_ENCODE_STREAM_NUM; ++i) {
+			if (encoding_statistics[i].gop_record) {
+				free(encoding_statistics[i].gop_record);
+				encoding_statistics[i].gop_record = NULL;
+			}
+		}
+	}
+	return err;
+}
+
+static int close_stream_files(int stream_id)
+{
+	int i;
+
+	if (stream_files[stream_id].fd > 0) {
+		amba_transfer_close(stream_files[stream_id].fd,
+			stream_transfer[stream_id].method);
+		stream_files[stream_id].fd = -1;
+	}
+	if (stream_files[stream_id].fd_info > 0) {
+		amba_transfer_close(stream_files[stream_id].fd,
+			stream_transfer[stream_id].method);
+		stream_files[stream_id].fd_info = -1;
+	}
+	if (split_svct_layer_flag) {
+		for (i = 0; i < MAX_SVCT_LAYERS; ++i) {
+			if (stream_files[stream_id].fd_svct[i] > 0) {
+				amba_transfer_close(stream_files[stream_id].fd_svct[i],
+					stream_transfer[stream_id].method);
+				stream_files[stream_id].fd_svct[i] = -1;
+			}
+		}
+		if (stream_files[stream_id].gop_structure > 0) {
+			stream_files[stream_id].gop_structure = 0;
+		}
+	}
+	if (split_fast_seek_flag) {
+		if (stream_files[stream_id].fd_fast_seek > 0) {
+			amba_transfer_close(stream_files[stream_id].fd_fast_seek,
+				stream_transfer[stream_id].method);
+			stream_files[stream_id].fd_fast_seek = -1;
+		}
+	}
+	return 0;
+}
+
+static int deinit_stream_files(int stream_id)
+{
+	int i;
+
+	if (stream_id == -1) {
+		for (i = 0; i < MAX_ENCODE_STREAM_NUM; ++i) {
+			close_stream_files(i);
+		}
+	} else {
+		close_stream_files(stream_id);
+	}
+	return 0;
+}
+
+static int init_data(void)
+{
+	int ret = 0;
+
+	init_encoding_states();
+	init_stream_files();
+	if (init_encoding_statistics() < 0) {
+		ret = -1;
+	}
+	return ret;
+}
 
 //return 0 if it's not new session,  return 1 if it is new session
-int is_new_session(struct iav_framedesc *framedesc)
+static int is_new_session(struct iav_framedesc *framedesc)
 {
 	int stream_id = framedesc->id;
 	int new_session = 0 ;
-	if  (framedesc ->session_id != encoding_states[stream_id].session_id) {
+	if  (framedesc ->session_id != stream_files[stream_id].session_id) {
 		//a new session
 		new_session = 1;
 	}
 	if (file_size_flag) {
-		if ((encoding_states[stream_id].total_bytes / 1024) > (file_size_mega_byte * 1024))
+		if ((stream_files[stream_id].total_bytes / 1024) > (file_size_mega_byte * 1024))
 			new_session = 1;
 	}
 
@@ -428,8 +663,7 @@ int is_new_session(struct iav_framedesc *framedesc)
 
 #include <time.h>
 
-
-int get_time_string( char * time_str,  int len)
+static int get_time_string( char * time_str,  int len)
 {
 	time_t  t;
 	struct tm * tmp;
@@ -446,12 +680,12 @@ int get_time_string( char * time_str,  int len)
 
 #define VERSION	0x00000005
 #define PTS_IN_ONE_SECOND		(90000)
-int write_frame_info_header(int stream_id)
+static int write_frame_info_header(int stream_id)
 {
 	char dummy_config[36];
 	int version = VERSION;
 	u32 size = sizeof(dummy_config);
-	int fd_info = encoding_states[stream_id].fd_info;
+	int fd_info = stream_files[stream_id].fd_info;
 	int method = stream_transfer[stream_id].method;
 
 	sprintf(dummy_config, "Here should contain H264 config\n");
@@ -466,7 +700,7 @@ int write_frame_info_header(int stream_id)
 	return 0;
 }
 
-int write_frame_info(struct iav_framedesc *framedesc)
+static int write_frame_info(struct iav_framedesc *framedesc)
 {
 	typedef struct video_frame_s {
 		u32     size;
@@ -479,7 +713,7 @@ int write_frame_info(struct iav_framedesc *framedesc)
 	frame_info.pts = (u32)framedesc->dsp_pts;
 	frame_info.size = framedesc->size;
 	int stream_id = framedesc->id;
-	int fd_info = encoding_states[stream_id].fd_info;
+	int fd_info = stream_files[stream_id].fd_info;
 	int method = stream_transfer[stream_id].method;
 
 	if (amba_transfer_write(fd_info, &frame_info, sizeof(frame_info), method) < 0) {
@@ -489,31 +723,142 @@ int write_frame_info(struct iav_framedesc *framedesc)
 	return 0;
 }
 
-static int calc_svct_layers(int stream_id)
+static int open_statistics_file(struct iav_framedesc *framedesc)
+{
+	int stream_id = framedesc->id;
+	int method = stream_transfer[stream_id].method;
+	int port = stream_transfer[stream_id].port;
+
+	if (encoding_statistics[stream_id].statistics_fd > 0) {
+		amba_transfer_close(encoding_statistics[stream_id].statistics_fd, method);
+		encoding_statistics[stream_id].statistics_fd = -1;
+	}
+	if ((encoding_statistics[stream_id].statistics_fd =
+		amba_transfer_open(encoding_statistics[stream_id].write_file_name,
+			method, port + STATISTIC_PORT_OFFSET)) < 0) {
+		printf("create file for statistics failed %s \n",
+			encoding_statistics[stream_id].write_file_name);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int write_statistics(struct iav_framedesc *framedesc, char *print_buffer)
+{
+	int stream_id = framedesc->id;
+	char stream_type_str[8];
+	int statistics_fd = encoding_statistics[stream_id].statistics_fd;
+	stream_encoding_statistics_t *statistics = &encoding_statistics[stream_id];
+	int method = stream_transfer[stream_id].method;
+	u64 total_msecond = (framedesc->arm_pts == 0) ?
+		(encoding_states[stream_id].monotonic_pts - old_encoding_states[stream_id].monotonic_pts)/90
+		: (framedesc->arm_pts - old_encoding_states[stream_id].monotonic_pts)/90;
+	int print_msecond = (int)total_msecond % 1000;
+	long int total_second = (long)total_msecond / 1000;
+	int print_hour = (int)total_second /3600;
+	int print_minute = (int)(total_second % 3600) / 60;
+	int print_second = (int)(total_second % 3600) % 60;
+
+	switch (framedesc->stream_type) {
+	case IAV_STREAM_TYPE_H264:
+		strcpy(stream_type_str, "H.264");
+		break;
+	case IAV_STREAM_TYPE_MJPEG:
+		strcpy(stream_type_str, "MJPEG");
+		break;
+	default:
+		strcpy(stream_type_str, "Unknown");
+		break;
+	}
+
+	sprintf(print_buffer,
+		"This statistics file is refreshed every %d frames.\n"
+		"***************************************\n"
+		"                             Stream ID:     stream %c\n"
+		"                        Encoding Codec:        %s\n"
+		"                    Total Frames Count:     %8llu\n"
+		"                            Resolution:    %4ux%4u\n"
+		"               Total Encoding Duration:  %d:%02d:%02d.%03d\n"
+		"    I Frame Size (Byte)(MAX, AVG, MIN):     %8u, %8u, %8u\n"
+		"    P Frame Size (Byte)(MAX, AVG, MIN):     %8u, %8u, %8u\n"
+		"    B Frame Size (Byte)(MAX, AVG, MIN):     %8u, %8u, %8u\n"
+		"    ARM PTS Diff       (MAX, AVG, MIN):     %8llu, %8llu, %8llu\n"
+		"    DSP PTS Diff       (MAX, AVG, MIN):     %8llu, %8llu, %8llu\n"
+		"    ENC PTS Diff       (MAX, AVG, MIN):     %8llu, %8llu, %8llu\n"
+		"             FPS       (MAX, AVG, MIN):       %6.2f,   %6.2f,   %6.2f\n"
+		"         Bitrate (Kbps)(MAX, AVG, MIN):     %8u, %8u, %8u\n"
+		"     Bitrate GOP (Kbps)     (MAX, MIN):     %8u, %8u\n"
+		"      Frame Size (Byte)(MAX, AVG, MIN):     %8u, %8u, %8u\n"
+		"      GOP Record      (Old --> Recent): ", write_statistics_interval,
+		'A' + framedesc->id, stream_type_str,
+		encoding_states[stream_id].total_frames,
+		framedesc->reso.width, framedesc->reso.height,
+		print_hour, print_minute, print_second, print_msecond,
+		statistics->max_i_frame, statistics->avg_i_frame, statistics->min_i_frame,
+		statistics->max_p_frame, statistics->avg_p_frame, statistics->min_p_frame,
+		statistics->max_b_frame, statistics->avg_b_frame, statistics->min_b_frame,
+		statistics->max_arm_pts, statistics->avg_arm_pts, statistics->min_arm_pts,
+		statistics->max_dsp_pts, statistics->avg_dsp_pts, statistics->min_dsp_pts,
+		statistics->max_enc_done_pts, statistics->avg_enc_done_pts, statistics->min_enc_done_pts,
+		statistics->max_fps, statistics->avg_fps, statistics->min_fps,
+		statistics->max_bitrate, statistics->avg_bitrate, statistics->min_bitrate,
+		statistics->max_bitrate_gop, statistics->min_bitrate_gop,
+		statistics->max_frame_size, statistics->avg_frame_size, statistics->min_frame_size);
+	sprintf(print_buffer+strlen(print_buffer), "%s\n", statistics->gop_record);
+	if (method == TRANS_METHOD_NONE) {
+		printf("%s\n", print_buffer);
+	} else {
+		if (amba_transfer_write(statistics_fd, print_buffer, strlen(print_buffer), method) < 0) {
+			perror("write_data(4)");
+			return (-1);
+		}
+	}
+
+	return 0;
+}
+
+static int check_h264_info(int stream_id)
 {
 	struct iav_h264_cfg h264;
+	int rval = 0;
 
 	memset(&h264, 0, sizeof(h264));
 	h264.id = stream_id;
 	AM_IOCTL(fd_iav, IAV_IOC_GET_H264_CONFIG, &h264);
 
+	if (split_fast_seek_flag && !h264.fast_seek_intvl) {
+		printf("Invalid fast seek intvl to split fast seek.\n");
+		return -1;
+	}
+	stream_files[stream_id].fast_seek_intvl = h264.fast_seek_intvl;
+
 	switch (h264.gop_structure) {
 	case IAV_GOP_SVCT_2:
-		encoding_states[stream_id].svct_layers = 2;
+		stream_files[stream_id].gop_structure = 2;
 		break;
 	case IAV_GOP_SVCT_3:
-		encoding_states[stream_id].svct_layers = 3;
+		stream_files[stream_id].gop_structure = 3;
+		break;
+	case IAV_GOP_LT_REF_P:
+		if (split_svct_layer_flag) {
+			printf("SVCT is not enabled when gop = %d\n", h264.gop_structure);
+			rval = -1;
+			break;
+		}
+		stream_files[stream_id].gop_structure = 8;
 		break;
 	default:
+		rval = -1;
 		printf("SCVT is not enabled when gop = %d.", h264.gop_structure);
 		break;
 	}
 
-	return 0;
+	return rval;
 }
 
 //check session and update file handle for write when needed
-int check_session_file_handle(struct iav_framedesc *framedesc, int new_session)
+static int check_session_file_handle(struct iav_framedesc *framedesc, int new_session)
 {
 	char write_file_name[1024];
 	char time_str[256];
@@ -523,24 +868,31 @@ int check_session_file_handle(struct iav_framedesc *framedesc, int new_session)
 	char stream_name;
 	int method = stream_transfer[stream_id].method;
 	int port = stream_transfer[stream_id].port;
+	enum iav_stream_type stream_type = framedesc->stream_type;
 
-   	if (new_session) {
-		is_h264 = (framedesc->stream_type != IAV_STREAM_TYPE_MJPEG);
+	if (new_session) {
+		is_h264 = (stream_type != IAV_STREAM_TYPE_MJPEG);
 		sprintf(file_type, "%s", is_h264 ? "h264" : "mjpeg");
 		//close old session if needed
-		if (encoding_states[stream_id].fd > 0) {
-			close(encoding_states[stream_id].fd);
-			encoding_states[stream_id].fd = -1;
+		if (stream_files[stream_id].fd > 0) {
+			amba_transfer_close(stream_files[stream_id].fd, method);
+			stream_files[stream_id].fd = -1;
 		}
 		//character based stream name
 		if (split_svct_layer_flag) {
 			for (i = 0; i < MAX_SVCT_LAYERS; ++i) {
-				if (encoding_states[stream_id].fd_svct[i] > 0) {
-					close(encoding_states[stream_id].fd_svct[i]);
-					encoding_states[stream_id].fd_svct[i] = -1;
+				if (stream_files[stream_id].fd_svct[i] > 0) {
+					amba_transfer_close(stream_files[stream_id].fd_svct[i], method);
+					stream_files[stream_id].fd_svct[i] = -1;
 				}
 			}
-			encoding_states[stream_id].svct_layers = 0;
+			stream_files[stream_id].gop_structure = 0;
+		}
+		if (split_fast_seek_flag) {
+			if (stream_files[stream_id].fd_fast_seek > 0) {
+				amba_transfer_close(stream_files[stream_id].fd_fast_seek, method);
+				stream_files[stream_id].fd_fast_seek = -1;
+			}
 		}
 
 		stream_name = 'A' + stream_id;
@@ -555,28 +907,34 @@ int check_session_file_handle(struct iav_framedesc *framedesc, int new_session)
 			sprintf(write_file_name, "%s_%c_%s_%x.%s",
 				stream_transfer[stream_id].filename, stream_name,
 				time_str, framedesc->session_id,
-				(framedesc->stream_type == IAV_STREAM_TYPE_MJPEG) ? "mjpeg" : "h264");
+				((stream_type == IAV_STREAM_TYPE_MJPEG) ? "mjpeg" : "h264"));
 		}
-		if ((encoding_states[stream_id].fd =
+		if ((stream_files[stream_id].fd =
 			amba_transfer_open(write_file_name, method, port)) < 0) {
 			printf("create file for write failed %s \n", write_file_name);
 			return -1;
 		} else {
 			if (!nofile_flag) {
 				printf("\nnew session file name [%s], fd [%d] \n", write_file_name,
-					encoding_states[stream_id].fd);
+					stream_files[stream_id].fd);
+			}
+		}
+
+		if (split_svct_layer_flag || split_fast_seek_flag) {
+			if (check_h264_info(stream_id) < 0) {
+				printf("check h264 info failed for split svct or fast seek!\n");
+				return -1;
 			}
 		}
 
 		if (split_svct_layer_flag && is_h264) {
-			calc_svct_layers(stream_id);
-			if (encoding_states[stream_id].svct_layers > 1) {
-				for (i = 0; i < encoding_states[stream_id].svct_layers; ++i) {
-					sprintf(filename, "%s.svct_%d.%s", write_file_name, i,
-						file_type);
-					encoding_states[stream_id].fd_svct[i] = amba_transfer_open(
+			if ((stream_files[stream_id].gop_structure >= MIN_SVCT_GOP_STRUCTURE) &&
+				(stream_files[stream_id].gop_structure <= MAX_SVCT_GOP_STRUCTURE)) {
+				for (i = 0; i < stream_files[stream_id].gop_structure; ++i) {
+					sprintf(filename, "%s.svct_%d.%s", write_file_name, i, file_type);
+					stream_files[stream_id].fd_svct[i] = amba_transfer_open(
 						filename, method, (port + i + SVCT_PORT_OFFSET));
-					if (encoding_states[stream_id].fd_svct[i] < 0) {
+					if (stream_files[stream_id].fd_svct[i] < 0) {
 						printf("create file for write SVCT layers failed %s.\n",
 							filename);
 						return -1;
@@ -584,9 +942,21 @@ int check_session_file_handle(struct iav_framedesc *framedesc, int new_session)
 				}
 			}
 		}
+
+		if (split_fast_seek_flag && is_h264) {
+			sprintf(filename, "%s.fast_seek.%s", write_file_name, file_type);
+			stream_files[stream_id].fd_fast_seek = amba_transfer_open(
+				filename, method, (port + FAST_SEEK_PORT_OFFSET));
+			if (stream_files[stream_id].fd_fast_seek < 0) {
+				printf("create file for write fast seek failed %s.\n",
+					filename);
+				return -1;
+			}
+		}
+
 		if (frame_info_flag) {
 			sprintf(write_file_name, "%s.info", write_file_name);
-			if ((encoding_states[stream_id].fd_info =
+			if ((stream_files[stream_id].fd_info =
 				amba_transfer_open(write_file_name, method, port)) < 0) {
 				printf("create file for frame info  failed %s \n", write_file_name);
 				return -1;
@@ -600,31 +970,565 @@ int check_session_file_handle(struct iav_framedesc *framedesc, int new_session)
 	return 0;
 }
 
-int update_session_data(struct iav_framedesc *framedesc, int new_session)
+static int update_session_data(struct iav_framedesc *framedesc, int new_session)
 {
 	int stream_id = framedesc->id;
+	char *gop_record_buffer = NULL;
+
 	//update pic type, session id on new session
 	if (new_session) {
-		encoding_states[stream_id].pic_type = framedesc->pic_type;
 		encoding_states[stream_id].session_id = framedesc->session_id;
 		encoding_states[stream_id].total_bytes = 0;
 		encoding_states[stream_id].total_frames = 0;
-		old_encoding_states[stream_id] = encoding_states[stream_id];	//for statistics data only
-
-#ifdef ACCURATE_FPS_CALC
+		encoding_states[stream_id].total_frames_i = 0;
+		encoding_states[stream_id].total_bytes_i = 0;
+		encoding_states[stream_id].total_frames_p = 0;
+		encoding_states[stream_id].total_bytes_p = 0;
+		encoding_states[stream_id].total_frames_b = 0;
+		encoding_states[stream_id].total_bytes_b = 0;
+		encoding_states[stream_id].i_num = 0;
+		encoding_states[stream_id].enc_done_ts_diff_sum = 0;
+		encoding_states[stream_id].pts_reverse_count = 0;
+
+		encoding_states[stream_id].monotonic_pts = 0;
+		encoding_states[stream_id].pts = 0;
+		encoding_states[stream_id].encoding_start_time = encoding_states[stream_id].capture_start_time;
+
+		//for statistics data only
+		old_encoding_states[stream_id].total_frames = 0;
+		old_encoding_states[stream_id].capture_start_time = encoding_states[stream_id].capture_start_time;
+		old_encoding_states[stream_id].total_bytes = 0;
 		old_encoding_states[stream_id].total_frames2 = 0;
-		old_encoding_states[stream_id].time2 = old_encoding_states[stream_id].capture_start_time;	//reset old counter
-#endif
+		old_encoding_states[stream_id].time2 = encoding_states[stream_id].capture_start_time;
+		old_encoding_states[stream_id].monotonic_pts = framedesc->arm_pts;
+		old_encoding_states[stream_id].pts = framedesc->dsp_pts;
+
+		//for biterate within the scope of gop
+		memset(&encoding_states[stream_id].time_gop, 0, sizeof(struct timeval));
+		encoding_states[stream_id].total_bytes_gop = 0;
+
+		//backup allocated memory pointer and reset statistic values
+		gop_record_buffer = encoding_statistics[stream_id].gop_record;
+		memset(&encoding_statistics[stream_id], 0, sizeof(struct stream_encoding_statistics_s));
+		encoding_statistics[stream_id].gop_record = gop_record_buffer;
+		gop_record_buffer = NULL;
+		memset(encoding_statistics[stream_id].gop_record, 0, sizeof(char)*PRINT_CHARACTER_AMOUNT);
 	}
 
 	//update statistics on all frame
+	encoding_states[stream_id].pic_type = framedesc->pic_type;
 	encoding_states[stream_id].total_bytes += framedesc->size;
 	encoding_states[stream_id].total_frames++;
-	encoding_states[stream_id].pts = (u32)framedesc->dsp_pts;
+	encoding_states[stream_id].enc_done_ts_diff_sum += framedesc->enc_done_ts - framedesc->arm_pts;
+
+	//update i p b frame count
+	if (framedesc->pic_type == IAV_PIC_TYPE_IDR_FRAME || framedesc->pic_type == IAV_PIC_TYPE_I_FRAME) {
+		encoding_states[stream_id].total_frames_i ++;
+		encoding_states[stream_id].total_bytes_i += framedesc->size;
+	}
+	if (framedesc->pic_type == IAV_PIC_TYPE_P_FRAME) {
+		encoding_states[stream_id].total_frames_p ++;
+		encoding_states[stream_id].total_bytes_p += framedesc->size;
+	}
+	if (framedesc->pic_type == IAV_PIC_TYPE_B_FRAME) {
+		encoding_states[stream_id].total_frames_b ++;
+		encoding_states[stream_id].total_bytes_b += framedesc->size;
+	}
 
 	return 0;
 }
 
+static int update_files_data(struct iav_framedesc *framedesc, int new_session)
+{
+	int stream_id = framedesc->id;
+
+	if (new_session) {
+		stream_files[stream_id].session_id = framedesc->session_id;
+		stream_files[stream_id].total_bytes = 0;
+	}
+
+	stream_files[stream_id].total_bytes += framedesc->size;
+
+	return 0;
+}
+
+static int statistics_gop(struct iav_framedesc *framedesc)
+{
+	int stream_id = framedesc->id;
+	stream_encoding_state_t *state = &encoding_states[stream_id];
+	stream_encoding_statistics_t *statistics = &encoding_statistics[stream_id];
+
+	if (framedesc->pic_type == IAV_PIC_TYPE_IDR_FRAME ||
+		framedesc->pic_type == IAV_PIC_TYPE_I_FRAME) {
+		if (state->i_num != 0) {
+			if (statistics->gop != (state->total_frames- state->i_num)) {
+				statistics->gop = state->total_frames- state->i_num;
+				if (strlen(statistics->gop_record) > (sizeof(char)*(PRINT_CHARACTER_AMOUNT - 5))) {
+					printf("Gop_record doesn't have enough space for new gop record!\n");
+					return -1;
+				}
+				sprintf(statistics->gop_record, "%s%4u ",
+					statistics->gop_record, statistics->gop);
+			}
+		}
+		state->i_num = state->total_frames;
+	}
+	return 0;
+}
+
+static void statistics_ipb_frame_size(struct iav_framedesc *framedesc)
+{
+	int stream_id = framedesc->id;
+	stream_encoding_statistics_t *statistics = &encoding_statistics[stream_id];
+
+	if (framedesc->pic_type == IAV_PIC_TYPE_IDR_FRAME ||
+		framedesc->pic_type == IAV_PIC_TYPE_I_FRAME) {
+		if (statistics->max_i_frame == 0 || statistics->min_i_frame == 0) {
+			statistics->max_i_frame = framedesc->size;
+			statistics->min_i_frame = framedesc->size;
+		} else if (framedesc->size > statistics->max_i_frame) {
+			statistics->max_i_frame = framedesc->size;
+		} else if (framedesc->size < statistics->min_i_frame) {
+			statistics->min_i_frame = framedesc->size;
+		}
+	}
+	if (framedesc->pic_type == IAV_PIC_TYPE_P_FRAME) {
+		if (statistics->max_p_frame == 0 || statistics->min_p_frame == 0) {
+			statistics->max_p_frame = framedesc->size;
+			statistics->min_p_frame = framedesc->size;
+		} else if (framedesc->size > statistics->max_p_frame) {
+			statistics->max_p_frame = framedesc->size;
+		} else if (framedesc->size < statistics->min_p_frame) {
+			statistics->min_p_frame = framedesc->size;
+		}
+	}
+	if (framedesc->pic_type == IAV_PIC_TYPE_B_FRAME) {
+		if (statistics->max_b_frame == 0 || statistics->min_b_frame == 0) {
+			statistics->max_b_frame = framedesc->size;
+			statistics->min_b_frame = framedesc->size;
+		} else if (framedesc->size > statistics->max_b_frame) {
+			statistics->max_b_frame = framedesc->size;
+		} else if (framedesc->size < statistics->min_b_frame) {
+			statistics->min_b_frame = framedesc->size;
+		}
+	}
+}
+
+static void statistics_pts(struct iav_framedesc *framedesc)
+{
+	int stream_id = framedesc->id;
+	stream_encoding_state_t *state = &encoding_states[stream_id];
+	stream_encoding_statistics_t *statistics = &encoding_statistics[stream_id];
+	u64 enc_done_pts_diff;
+	u64 dsp_pts_diff;
+
+	if (state->monotonic_pts != 0) {
+		if ((framedesc->arm_pts - state->monotonic_pts) > statistics->max_arm_pts)
+			statistics->max_arm_pts = framedesc->arm_pts - state->monotonic_pts;
+		if ((framedesc->arm_pts - state->monotonic_pts) < statistics->min_arm_pts)
+			statistics->min_arm_pts = framedesc->arm_pts - state->monotonic_pts;
+	} else {
+		statistics->max_arm_pts = 0;
+		statistics->min_arm_pts = framedesc->arm_pts - state->monotonic_pts;
+	}
+	state->monotonic_pts = framedesc->arm_pts;
+
+	if (state->pts != 0) {
+		if (framedesc->dsp_pts < state->pts) {
+			dsp_pts_diff = (1 << 30) + framedesc->dsp_pts - state->pts;
+			state->pts_reverse_count ++;
+		} else {
+			dsp_pts_diff = framedesc->dsp_pts - state->pts;
+		}
+		if (dsp_pts_diff > statistics->max_dsp_pts) {
+			statistics->max_dsp_pts = dsp_pts_diff;
+		} else if (dsp_pts_diff < statistics->min_dsp_pts) {
+			statistics->min_dsp_pts = dsp_pts_diff;
+		}
+	} else {
+		statistics->max_dsp_pts = 0;
+		statistics->min_dsp_pts = PTS_IN_ONE_SECOND;
+	}
+	state->pts = framedesc->dsp_pts;
+
+	enc_done_pts_diff = framedesc->enc_done_ts - framedesc->arm_pts;
+	if (statistics->max_enc_done_pts == 0 || statistics->min_enc_done_pts == 0) {
+		statistics->max_enc_done_pts = enc_done_pts_diff;
+		statistics->min_enc_done_pts = enc_done_pts_diff;
+	} else if (enc_done_pts_diff > statistics->max_enc_done_pts) {
+		statistics->max_enc_done_pts = enc_done_pts_diff;
+	} else if (enc_done_pts_diff < statistics->min_enc_done_pts) {
+		statistics->min_enc_done_pts = enc_done_pts_diff;
+	}
+}
+
+static void statistics_fps_bitrate(struct iav_framedesc *framedesc)
+{
+	int stream_id = framedesc->id;
+	int curr_frames, pre_frames, pre_frames2;
+	struct timeval curr_time, pre_time, pre_time2;
+	u64 time_interval_us, time_interval_us2;
+	u64 time_inter_i_frame;
+	u64 pre_bytes, curr_bytes;
+	u32 bitrate = 0;
+	double fps_average;
+	stream_encoding_state_t *state = &encoding_states[stream_id];
+	stream_encoding_statistics_t *statistics = &encoding_statistics[stream_id];
+
+	pre_frames2 = old_encoding_states[stream_id].total_frames2;
+	pre_time2 = old_encoding_states[stream_id].time2;
+	pre_time = old_encoding_states[stream_id].capture_start_time;
+	curr_time = encoding_states[stream_id].capture_start_time;
+	curr_frames = encoding_states[stream_id].total_frames;
+	pre_frames = old_encoding_states[stream_id].total_frames;
+	pre_bytes = old_encoding_states[stream_id].total_bytes;
+	curr_bytes = encoding_states[stream_id].total_bytes;
+
+	if (curr_frames % print_interval == 0) {
+		time_interval_us = (curr_time.tv_sec - pre_time.tv_sec) * 1000000ull +
+						curr_time.tv_usec - pre_time.tv_usec;
+		statistics->rt_fps = (curr_frames - pre_frames)* 1000000.0/(double)time_interval_us;
+
+		if (statistics->max_fps == 0 || statistics->min_fps  == 0) {
+			statistics->max_fps = statistics->rt_fps;
+			statistics->min_fps = statistics->rt_fps;
+		} else if (statistics->rt_fps > statistics->max_fps) {
+			statistics->max_fps = statistics->rt_fps;
+		} else if (statistics->rt_fps < statistics->min_fps) {
+			statistics->min_fps = statistics->rt_fps;
+		}
+
+		statistics->rt_bitrate= (int)((curr_bytes - pre_bytes) * 8000000LL /time_interval_us /1024);
+		if (statistics->max_bitrate == 0 || statistics->min_bitrate == 0) {
+			statistics->max_bitrate = statistics->rt_bitrate;
+			statistics->min_bitrate = statistics->rt_bitrate;
+		} else if (statistics->rt_bitrate > statistics->max_bitrate) {
+			statistics->max_bitrate = statistics->rt_bitrate;
+		} else if (statistics->rt_bitrate < statistics->min_bitrate) {
+			statistics->min_bitrate = statistics->rt_bitrate;
+		}
+
+		old_encoding_states[stream_id].total_frames = state->total_frames;
+		old_encoding_states[stream_id].total_bytes = state->total_bytes;
+		old_encoding_states[stream_id].capture_start_time = state->capture_start_time;
+	}
+
+	if (framedesc->pic_type == IAV_PIC_TYPE_IDR_FRAME || framedesc->pic_type == IAV_PIC_TYPE_I_FRAME) {
+		time_inter_i_frame = (state->capture_start_time.tv_sec - state->time_gop.tv_sec) * 1000000ull +
+						state->capture_start_time.tv_usec - state->time_gop.tv_usec;
+		bitrate = state->capture_start_time.tv_sec ?
+			(int)((state->total_bytes - state->total_bytes_gop) * 8000000LL / time_inter_i_frame/1024) : 0;
+		state->time_gop = state->capture_start_time;
+		state->total_bytes_gop = state->total_bytes;
+
+		if (state->total_frames_i > 1) {
+			if (statistics->max_bitrate_gop == 0 || statistics->min_bitrate_gop  == 0) {
+				statistics->max_bitrate_gop = bitrate;
+				statistics->min_bitrate_gop = bitrate;
+			} else if (bitrate > statistics->max_bitrate_gop) {
+				statistics->max_bitrate_gop = bitrate;
+			} else if (bitrate < statistics->min_bitrate_gop) {
+				statistics->min_bitrate_gop = bitrate;
+			}
+		}
+	}
+
+	if (curr_frames % fps_statistics_interval == 0) {
+		time_interval_us2 = (curr_time.tv_sec - pre_time2.tv_sec) * 1000000ull +
+					curr_time.tv_usec - pre_time2.tv_usec;
+		fps_average = (curr_frames - pre_frames2)* 1000000.0/(double)time_interval_us2;
+
+		BOLD_PRINT("AVG FPS = %4.2f\n", fps_average);
+
+		old_encoding_states[stream_id].total_frames2 = state->total_frames;
+		old_encoding_states[stream_id].time2 = state->capture_start_time;
+	}
+}
+
+static void statistics_frame_size(struct iav_framedesc *framedesc)
+{
+	int stream_id = framedesc->id;
+	stream_encoding_statistics_t *statistics = &encoding_statistics[stream_id];
+
+	if (statistics->max_frame_size == 0 || statistics->min_frame_size  == 0) {
+		statistics->max_frame_size = framedesc->size;
+		statistics->min_frame_size = framedesc->size;
+	} else if (framedesc->size > statistics->max_frame_size) {
+		statistics->max_frame_size = framedesc->size;
+	} else if (framedesc->size < statistics->min_frame_size) {
+		statistics->min_frame_size = framedesc->size;
+	}
+}
+
+static void statistics_average(struct iav_framedesc *framedesc)
+{
+	int stream_id = framedesc->id;
+	struct timeval curr_time, start_time;
+	u64 time_interval_us;
+	stream_encoding_state_t *state = &encoding_states[stream_id];
+	stream_encoding_statistics_t *statistics = &encoding_statistics[stream_id];
+
+	curr_time = state->capture_start_time;
+	start_time = state->encoding_start_time;
+
+	time_interval_us = (curr_time.tv_sec - start_time.tv_sec) * 1000000ull + curr_time.tv_usec - start_time.tv_usec;
+
+	//avrage i p b frame size
+	if (state->total_bytes_i && state->total_frames_i)
+		statistics->avg_i_frame =
+			(u32)(state->total_bytes_i/state->total_frames_i);
+	else
+		statistics->avg_i_frame = 0;
+	if (state->total_bytes_p && state->total_frames_p)
+		statistics->avg_p_frame =
+			(u32)(state->total_bytes_p/state->total_frames_p);
+	else
+		statistics->avg_p_frame = 0;
+	if (state->total_bytes_b && state->total_frames_b)
+		statistics->avg_b_frame =
+			(u32)(state->total_bytes_b/state->total_frames_b);
+	else
+		statistics->avg_b_frame = 0;
+
+	//average pts diff
+	statistics->avg_arm_pts =
+		(state->monotonic_pts - old_encoding_states[stream_id].monotonic_pts)/
+		(state->total_frames - 1);
+	statistics->avg_dsp_pts =
+		((state->pts_reverse_count << 30) + state->pts - old_encoding_states[stream_id].pts)/(state->total_frames -1);
+	statistics->avg_enc_done_pts =
+		state->enc_done_ts_diff_sum/state->total_frames;
+
+	//average fps
+	statistics->avg_fps = ((state->total_frames - 1) * 1000000.0)/(double)time_interval_us;
+
+	//average bitrate
+	statistics->avg_bitrate = (int)(state->total_bytes * 8000000LL /time_interval_us /1024);
+
+	//average frame size
+	statistics->avg_frame_size = (u32)(state->total_bytes/state->total_frames);
+}
+
+static void* do_statistics(void *arg)
+{
+	int i = 0;
+	u32 time_interval_us;
+	int stream_id;
+	struct timeval pre_time, curr_time;
+	u64 curr_frames;
+	u64 curr_bytes, curr_pts;
+	u32 curr_vin_fps;
+	char stream_name[128];
+	pipe_mesg_t pipe_mesg;
+	struct iav_framedesc *framedesc;
+	int new_session;
+	char *print_buffer;
+	char stream_num;
+	char time_str[256];
+	fd_set all_set;
+	fd_set set;
+
+	FD_ZERO(&all_set);
+	FD_SET(pipefd[0], &all_set);
+
+	print_buffer = (char *)malloc(sizeof(char)*PRINT_CHARACTER_AMOUNT*2);
+	if (NULL == print_buffer) {
+		printf("Malloc print buffer failed!\n");
+		statistics_run = 0;
+	}
+	if (print_buffer) {
+		memset(print_buffer, 0, sizeof(char)*PRINT_CHARACTER_AMOUNT*2);
+	}
+
+	while (statistics_run) {
+		set = all_set;
+		if(select(pipefd[0] + 1, &set, NULL, NULL, NULL) < 0) {
+			perror("Do_statistics select");
+		} else {
+			if (FD_ISSET(pipefd[0], &set)) {
+				u8 *buf = (u8*)&pipe_mesg;
+				int read_size = 0;
+				int count = 0;
+				do {
+					int read_ret = read(pipefd[0], buf + read_size,
+									sizeof(pipe_mesg) - read_size);
+					if (read_ret > 0) {
+						read_size += read_ret;
+					} else if (read_ret < 0) {
+						perror("read statistics pipe");
+					}
+				} while((read_size < sizeof(pipe_mesg)) && (++ count < 5));
+				if (read_size != sizeof(pipe_mesg)) {
+					printf("Failed to read message from main loop:\n"
+					  	  "expected message size: %u, received message size: %d\n",
+					  	  sizeof(pipe_mesg), read_size);
+					continue;
+				}
+			}
+		}
+
+		if (pipe_mesg.stop) {
+			printf("Received stop message, stop statistics!\n");
+			statistics_run = 0;
+			continue;
+		}
+		framedesc = &pipe_mesg.framedesc;
+		new_session = pipe_mesg.new_session;
+		stream_id = framedesc->id;
+
+		if (verbose_mode) {
+			printf("type=%d, dspPTS=%llu, size=%d, addr=0x%x, strm_id=%d,"
+				" sesn_id=%u, monotonic_pts=%llu, mono_diff=%llu,"
+				" enc_done_pts = %llu, enc_pipe_time = %llu,"
+				" reso=%dx%d\n",
+				framedesc->pic_type, framedesc->dsp_pts, framedesc->size,
+				framedesc->data_addr_offset, framedesc->id,
+				framedesc->session_id, framedesc->arm_pts,
+				framedesc->arm_pts - encoding_states[stream_id].monotonic_pts,
+				framedesc->enc_done_ts,
+				framedesc->enc_done_ts - framedesc->arm_pts,
+				framedesc->reso.width, framedesc->reso.height);
+		}
+
+		if (framedesc->stream_end) {
+			statistics_average(framedesc);
+			if (statistics_mode) {
+				if (encoding_statistics[stream_id].statistics_fd < 0) {
+					if (open_statistics_file(framedesc) < 0) {
+						printf("Open statistics file %s failed.\n",
+							encoding_statistics[stream_id].write_file_name);
+						break;
+					}
+				}
+				if (write_statistics(framedesc, print_buffer) < 0) {
+					printf("write statistics file %s failed.\n",
+						encoding_statistics[stream_id].write_file_name);
+					break;
+				}
+				amba_transfer_close(encoding_statistics[stream_id].statistics_fd,
+									stream_transfer[stream_id].method);
+				encoding_statistics[stream_id].statistics_fd = -1;
+			}
+			continue;
+		}
+
+		gettimeofday(&encoding_states[stream_id].capture_start_time, NULL);
+
+		if (update_session_data(framedesc, new_session) < 0) {
+			printf("update sessiondata failed \n");
+			break;
+		}
+
+		pre_time = old_encoding_states[stream_id].capture_start_time;
+		curr_time = encoding_states[stream_id].capture_start_time;
+		curr_frames = encoding_states[stream_id].total_frames;
+		curr_bytes = encoding_states[stream_id].total_bytes;
+		curr_pts = encoding_states[stream_id].pts;
+
+		if (show_pts_flag) {
+			struct vindev_fps vsrc_fps;
+			vsrc_fps.vsrc_id = 0;
+			if (ioctl(fd_iav, IAV_IOC_VIN_GET_FPS, &vsrc_fps) < 0) {
+				perror("IAV_IOC_VIN_GET_FPS\n");
+				break;
+			}
+			curr_vin_fps = vsrc_fps.fps;
+			time_interval_us = (curr_time.tv_sec - pre_time.tv_sec) * 1000000ull +
+				curr_time.tv_usec - pre_time.tv_usec;
+			sprintf(stream_name, "stream %c", 'A' + stream_id);
+			printf("%s: [%d]\tVIN: [%d], PTS: %llu, diff: %llu, frames NO: %llu, size: %d\n",
+				stream_name, time_interval_us, curr_vin_fps,
+				curr_pts, framedesc->dsp_pts  - encoding_states[stream_id].pts,
+				curr_frames, framedesc->size);
+		}
+
+		if (statistics_gop(framedesc) < 0) {
+			printf("Do statistics_gop failed!\n");
+			break;
+		}
+
+		statistics_ipb_frame_size(framedesc);
+
+		statistics_pts(framedesc);
+
+		statistics_fps_bitrate(framedesc);
+
+		statistics_frame_size(framedesc);
+
+		if (curr_frames % write_statistics_interval == 0) {
+			statistics_average(framedesc);
+		}
+
+		//print statistics
+		if (statistics_mode) {
+			if (new_session) {
+				stream_num = 'A' + stream_id;
+				get_time_string(time_str, sizeof(time_str));
+				sprintf(encoding_statistics[stream_id].write_file_name,
+					"%s_%c_%s_%x.stat", stream_transfer[stream_id].filename,
+					stream_num, time_str, framedesc->session_id);
+				//open statistcs file
+				if (open_statistics_file(framedesc) < 0) {
+					printf("Open statistics file %s failed.\n",
+						encoding_statistics[stream_id].write_file_name);
+					break;
+				}
+			}
+
+			//write file
+			if (curr_frames % write_statistics_interval == 0) {
+				if (encoding_statistics[stream_id].statistics_fd < 0) {
+					if (open_statistics_file(framedesc) < 0) {
+						printf("Open statistics file %s failed.\n",
+							encoding_statistics[stream_id].write_file_name);
+						break;
+					}
+				}
+				if (write_statistics(framedesc, print_buffer) < 0) {
+					printf("write statistics file %s failed.\n",
+						encoding_statistics[stream_id].write_file_name);
+					break;
+				}
+				amba_transfer_close(encoding_statistics[stream_id].statistics_fd,
+									stream_transfer[stream_id].method);
+				encoding_statistics[stream_id].statistics_fd = -1;
+			}
+		}
+
+		if (curr_frames %print_interval == 0) {
+			sprintf(stream_name, "stream %c",  'A'+ stream_id);
+			printf("%s:\t%llu %s, %4.2f fps, %18llu\tbytes, %5d kbps\n",
+				stream_name, curr_frames, nofile_flag ? "discard" : "frames",
+				encoding_statistics[stream_id].rt_fps, curr_bytes,
+				encoding_statistics[stream_id].rt_bitrate);
+		}
+	}
+	if (statistics_run) {
+		printf("Do statistics exited abnormally!\n");
+	}
+	if (pipefd[0] >= 0) {
+		close(pipefd[0]);
+		pipefd[0] = -1;
+	}
+	if (print_buffer) {
+		free(print_buffer);
+		print_buffer = NULL;
+	}
+	for(i = 0; i < MAX_ENCODE_STREAM_NUM; i++) {
+		if (encoding_statistics[i].gop_record) {
+			free(encoding_statistics[i].gop_record);
+			encoding_statistics[i].gop_record = NULL;
+		}
+		if (encoding_statistics[i].statistics_fd) {
+			amba_transfer_close(encoding_statistics[i].statistics_fd,
+								stream_transfer[i].method);
+			encoding_statistics[i].statistics_fd = -1;
+		}
+	}
+
+	return ((void *)0);
+}
+
 static int write_svct_file(int method, unsigned char *in, int len, int fd)
 {
 	if (amba_transfer_write(fd, in, len, method) < 0) {
@@ -634,46 +1538,107 @@ static int write_svct_file(int method, unsigned char *in, int len, int fd)
 	return 0;
 }
 
-static int find_svct_layer(unsigned char *in, int in_len)
+static int identify_nal_ref_idc(unsigned char *in, int in_len)
 {
 	const int header_magic_num = 0x00000001;
 	unsigned int header_mn = 0;
-	unsigned char nalu, layer = -1;
+	unsigned char nalu, nal_ref_idc = -1;
 	int i = 0;
-
 	do {
 		header_mn = (in[i] << 24 | in[i+1] << 16 | in[i+2] << 8 | in[i+3]);
 		if (header_mn == header_magic_num) {
-			nalu = in[i+4] & 0x1F;
+			i += 4;
+			nalu = in[i] & 0x1F;
 			if ((nalu == NT_IDR) || (nalu == NT_NON_IDR)) {
-				layer = (in[i+4] >> 5) & 0x3;
+				nal_ref_idc = (in[i] >> 5) & 0x3;
 				break;
 			}
 		}
-	} while (++i < in_len);
-	return layer;
+		++i;
+	} while (i < in_len);
+	return nal_ref_idc;
+}
+
+static int get_svct_layer(int stream_id, unsigned char *in,
+	int in_len, int *ret_layer)
+{
+	int gop = stream_files[stream_id].gop_structure;
+	int rval = 0;
+	int layer, nal_ref_idc;
+
+	if (!ret_layer) {
+		printf("Invalid return layer pointer!\n");
+		return -1;
+	}
+	nal_ref_idc = identify_nal_ref_idc(in, in_len);
+
+	switch (gop) {
+	case IAV_GOP_SVCT_3:
+		switch (nal_ref_idc) {
+		case 3:
+			layer = 0;
+			break;
+		case 2:
+			layer = 1;
+			break;
+		case 0:
+			layer = 2;
+			break;
+		default:
+			rval = -1;
+			printf("Invalid nal ref idc %d\n", nal_ref_idc);
+			break;
+		}
+		break;
+	case IAV_GOP_SVCT_2:
+		switch (nal_ref_idc) {
+		case 3:
+			layer = 0;
+			break;
+		case 0:
+			layer = 1;
+			break;
+		default:
+			rval = -1;
+			printf("Invalid nal ref idc %d\n", nal_ref_idc);
+			break;
+		}
+		break;
+	default:
+		rval = -1;
+		printf("Invalid SVCT gop structure %d, cannot be larger than 3.\n", gop);
+		break;
+	}
+
+	*ret_layer = layer;
+	return rval;
 }
 
 static int write_svct_files(int transfer_method, int stream_id,
 	unsigned char *in, int in_len)
 {
-	int layer = find_svct_layer(in, in_len);
-	int rval = 0;
+	int gop = stream_files[stream_id].gop_structure;
+	int layer = -1, rval = 0;
 
-	switch (encoding_states[stream_id].svct_layers) {
-	case 3:
+	if (get_svct_layer(stream_id, in, in_len, &layer) < 0) {
+		printf("get svct layer failed!\n");
+		return -1;
+	}
+
+	switch (gop) {
+	case IAV_GOP_SVCT_3:
 		switch (layer) {
-		case 3:
+		case 0:
 			write_svct_file(transfer_method, in, in_len,
-				encoding_states[stream_id].fd_svct[2]);
+				stream_files[stream_id].fd_svct[2]);
 			/* Fall through to write this frame into other layers */
-		case 2:
+		case 1:
 			write_svct_file(transfer_method, in, in_len,
-				encoding_states[stream_id].fd_svct[1]);
+				stream_files[stream_id].fd_svct[1]);
 			/* Fall through to write this frame into other layers */
-		case 0:
+		case 2:
 			write_svct_file(transfer_method, in, in_len,
-				encoding_states[stream_id].fd_svct[0]);
+				stream_files[stream_id].fd_svct[0]);
 			break;
 		default:
 			rval = -1;
@@ -681,15 +1646,15 @@ static int write_svct_files(int transfer_method, int stream_id,
 			break;
 		}
 		break;
-	case 2:
+	case IAV_GOP_SVCT_2:
 		switch (layer) {
-		case 3:
+		case 0:
 			write_svct_file(transfer_method, in, in_len,
-				encoding_states[stream_id].fd_svct[1]);
+				stream_files[stream_id].fd_svct[1]);
 			/* Fall through to write this frame into other layers */
-		case 0:
+		case 1:
 			write_svct_file(transfer_method, in, in_len,
-				encoding_states[stream_id].fd_svct[0]);
+				stream_files[stream_id].fd_svct[0]);
 			break;
 		default:
 			rval = -1;
@@ -699,7 +1664,7 @@ static int write_svct_files(int transfer_method, int stream_id,
 		break;
 	default:
 		rval = -1;
-		printf("Invalid SVCT layers. Cannot be larger than 4.\n");
+		printf("Invalid gop structure %d, cannot be larger than 3.\n", gop);
 		break;
 	}
 
@@ -710,11 +1675,43 @@ static int write_svct_files(int transfer_method, int stream_id,
 	return rval;
 }
 
-int write_video_file(struct iav_framedesc *framedesc)
+static int write_fast_seek_file(int transfer_method, int stream_id,
+	unsigned char *in, int in_len)
+{
+	int nal_ref_idc = identify_nal_ref_idc(in, in_len);
+	int fd = stream_files[stream_id].fd_fast_seek;
+	int gop = stream_files[stream_id].gop_structure;
+	int rval = 0;
+
+	switch (gop) {
+	case IAV_GOP_SVCT_2:
+	case IAV_GOP_SVCT_3:
+	case IAV_GOP_LT_REF_P:
+		if (nal_ref_idc == 3) {
+			if (amba_transfer_write(fd, in, in_len, transfer_method) < 0) {
+				perror("Failed to write fast seek frames into file.\n");
+				rval = -1;
+			}
+		}
+		break;
+	default:
+		rval = -1;
+		printf("Invalid gop structure %d for fast seek\n", gop);
+		break;
+	}
+
+	if ((rval >= 0) && verbose_mode) {
+		printf("Save fast seek frames into file.\n");
+	}
+
+	return rval;
+}
+
+static int write_video_file(struct iav_framedesc *framedesc)
 {
 	static unsigned int whole_pic_size=0;
 	u32 pic_size = framedesc->size;
-	int fd = encoding_states[framedesc->id].fd;
+	int fd = stream_files[framedesc->id].fd;
 	int stream_id = framedesc->id;
 
 	//remove align
@@ -746,37 +1743,37 @@ int write_video_file(struct iav_framedesc *framedesc)
 		perror("Failed to write streams into file!\n");
 		return -1;
 	}
-	if (split_svct_layer_flag && (encoding_states[stream_id].svct_layers > 1)) {
+	if (split_svct_layer_flag &&
+		(stream_files[stream_id].gop_structure >= MIN_SVCT_GOP_STRUCTURE) &&
+		(stream_files[stream_id].gop_structure <= MAX_SVCT_GOP_STRUCTURE)) {
 		if (write_svct_files(stream_transfer[stream_id].method, stream_id,
 			(unsigned char *)bsb_mem + framedesc->data_addr_offset, pic_size) < 0) {
 			perror("Failed to split and write SVCT layers into files!\n");
 			return -1;
 		}
 	}
+	if (split_fast_seek_flag) {
+		if (write_fast_seek_file(stream_transfer[stream_id].method, stream_id,
+			(unsigned char *)bsb_mem + framedesc->data_addr_offset, pic_size) < 0) {
+			perror("Failed to split and write fast seek frames into files!\n");
+			return -1;
+		}
+	}
 
 	return 0;
 }
 
-int write_stream(int *total_frames, u64 *total_bytes)
+static int write_stream(u64 *total_frames, u64 *total_bytes)
 {
 	int new_session; //0:  old session  1: new session
-	int print_frame = 1;
-	u32 time_interval_us;
-#ifdef ACCURATE_FPS_CALC
-	u32 time_interval_us2;
-#endif
 	int stream_id;
-	struct timeval pre_time, curr_time;
-	int pre_frames ,curr_frames;
-	u64 pre_bytes, curr_bytes;
-	u32 pre_pts, curr_pts, curr_vin_fps;
-	char stream_name[128];
 	static int init_flag = 0;
 	static int end_of_stream[MAX_ENCODE_STREAM_NUM];
 	struct iav_stream_info stream_info;
 	struct iav_querydesc query_desc;
 	struct iav_framedesc *frame_desc;
 	int i, stream_end_num;
+	pipe_mesg_t pipe_mesg;
 
 	if (init_flag == 0) {
 		for (i = 0; i < MAX_ENCODE_STREAM_NUM; ++i) {
@@ -795,68 +1792,57 @@ int write_stream(int *total_frames, u64 *total_bytes)
 	}
 
 	// There is no encoding stream, skip to next turn
-//	if (stream_end_num == MAX_ENCODE_STREAM_NUM)
-//		return -1;
+	//	if (stream_end_num == MAX_ENCODE_STREAM_NUM)
+	//		return -1;
 
 	memset(&query_desc, 0, sizeof(query_desc));
 	frame_desc = &query_desc.arg.frame;
 	query_desc.qid = IAV_DESC_FRAME;
 	frame_desc->id = -1;
 	if (ioctl(fd_iav, IAV_IOC_QUERY_DESC, &query_desc) < 0) {
-		perror("IAV_IOC_QUERY_DESC");
+		if (errno != EAGAIN) {
+			perror("IAV_IOC_QUERY_DESC");
+		}
 		return -1;
 	}
 
-	//update current frame encoding time
+	//check if it's new record session, since file name and recording control are based on session,
+	//session id and change are important data
 	stream_id = frame_desc->id;
-	gettimeofday(&encoding_states[stream_id].capture_start_time, NULL);
+	new_session = is_new_session(frame_desc);
+
+	memcpy(&pipe_mesg.framedesc, frame_desc, sizeof(struct iav_framedesc));
+	pipe_mesg.new_session = new_session;
+	pipe_mesg.stop = 0;
 
-	if (verbose_mode) {
-		printf("type=%d, dspPTS=%lld, size=%d, addr=0x%x, strm_id=%d,"
-			" sesn_id=%u, monotonic_pts=%lld, mono_diff=%lld, reso=%dx%d\n",
-		frame_desc->pic_type, frame_desc->dsp_pts, frame_desc->size,
-			frame_desc->data_addr_offset, frame_desc->id,
-			frame_desc->session_id, frame_desc->arm_pts,
-			(frame_desc->arm_pts - old_encoding_states[stream_id].monotonic_pts),
-			frame_desc->reso.width, frame_desc->reso.height);
-		old_encoding_states[stream_id].monotonic_pts = frame_desc->arm_pts;
+	u8 *buf = (u8*)&pipe_mesg;
+	int write_size = 0;
+	int count = 0;
+	do {
+		int write_ret = write(pipefd[1], buf + write_size,
+						sizeof(pipe_mesg) - write_size);
+		if (write_ret > 0) {
+			write_size += write_ret;
+		} else if (write_ret < 0) {
+			perror("write statistics pipe");
+		}
+	} while((write_size < sizeof(pipe_mesg)) && (++ count < 5));
+	if (write_size != sizeof(pipe_mesg)) {
+		printf("Failed to write message to statistics thread:\n"
+			  "expected message size: %u, writen message size: %d\n",
+			  sizeof(pipe_mesg), write_size);
+		return -1;
 	}
 
 	//check if it's a stream end null frame indicator
 	if (frame_desc->stream_end) {
 		end_of_stream[stream_id] = 1;
-		if (encoding_states[stream_id].fd > 0) {
-			amba_transfer_close(encoding_states[stream_id].fd,
-				stream_transfer[stream_id].method);
-			encoding_states[stream_id].fd = -1;
-		}
-		if (encoding_states[stream_id].fd_info > 0) {
-			amba_transfer_close(encoding_states[stream_id].fd,
-				stream_transfer[stream_id].method);
-			encoding_states[stream_id].fd_info = -1;
-		}
-		if (split_svct_layer_flag) {
-			for (i = 0; i < MAX_SVCT_LAYERS; ++i) {
-				if (encoding_states[stream_id].fd_svct[i] > 0) {
-					amba_transfer_close(encoding_states[stream_id].fd_svct[i],
-						stream_transfer[stream_id].method);
-					encoding_states[stream_id].fd_svct[i] = -1;
-				}
-			}
-			if (encoding_states[stream_id].svct_layers > 0) {
-				encoding_states[stream_id].svct_layers = 0;
-			}
-		}
-
+		deinit_stream_files(stream_id);
 		goto write_stream_exit;
 	}
 
-	//check if it's new record session, since file name and recording control are based on session,
-	//session id and change are important data
-	new_session = is_new_session(frame_desc);
-	//update session data
-	if (update_session_data(frame_desc, new_session) < 0) {
-		printf("update session data failed \n");
+	if (update_files_data(frame_desc, new_session) < 0) {
+		printf("update files data failed \n");
 		return -2;
 	}
 
@@ -887,69 +1873,13 @@ int write_stream(int *total_frames, u64 *total_bytes)
 	if (total_bytes)
 		*total_bytes = (*total_bytes) + frame_desc->size;
 
-	//print statistics
-	pre_time = old_encoding_states[stream_id].capture_start_time;
-	curr_time = encoding_states[stream_id].capture_start_time;
-	pre_frames = old_encoding_states[stream_id].total_frames;
-	curr_frames = encoding_states[stream_id].total_frames;
-	pre_bytes = old_encoding_states[stream_id].total_bytes;
-	curr_bytes = encoding_states[stream_id].total_bytes;
-	pre_pts = old_encoding_states[stream_id].pts;
-	curr_pts = encoding_states[stream_id].pts;
-	if (show_pts_flag) {
-		struct vindev_fps vsrc_fps;
-		vsrc_fps.vsrc_id = 0;
-		AM_IOCTL(fd_iav, IAV_IOC_VIN_GET_FPS, &vsrc_fps);
-		curr_vin_fps = vsrc_fps.fps;
-		time_interval_us = (curr_time.tv_sec - pre_time.tv_sec) * 1000000 +
-			curr_time.tv_usec - pre_time.tv_usec;
-		sprintf(stream_name, "stream %c", 'A' + stream_id);
-		printf("%s: [%d]\tVIN: [%d], PTS: %d, diff: %d, frames NO: %d, size: %d\n",
-			stream_name, time_interval_us, curr_vin_fps,
-			curr_pts, (curr_pts - pre_pts), curr_frames, frame_desc->size);
-		old_encoding_states[stream_id].pts = encoding_states[stream_id].pts;
-	}
-	if ((curr_frames % print_interval == 0) && (print_frame)) {
-		time_interval_us = (curr_time.tv_sec - pre_time.tv_sec) * 1000000 +
-						curr_time.tv_usec - pre_time.tv_usec;
-
-		sprintf(stream_name, "stream %c",  'A'+ stream_id);
-		printf("%s:\t%4d %s, %2d fps, %18lld\tbytes, %5d kbps\n", stream_name,
-			curr_frames, nofile_flag ? "discard" : "frames",
-			DIV_ROUND((curr_frames - pre_frames) * 1000000, time_interval_us), curr_bytes,
-			pre_time.tv_sec ? (int)((curr_bytes - pre_bytes) * 8000000LL /time_interval_us /1024) : 0);
-		//backup time and states
-		old_encoding_states[stream_id].session_id = encoding_states[stream_id].session_id;
-		old_encoding_states[stream_id].fd = encoding_states[stream_id].fd;
-		old_encoding_states[stream_id].total_frames = encoding_states[stream_id].total_frames;
-		old_encoding_states[stream_id].total_bytes = encoding_states[stream_id].total_bytes;
-		old_encoding_states[stream_id].pic_type = encoding_states[stream_id].pic_type;
-		old_encoding_states[stream_id].capture_start_time = encoding_states[stream_id].capture_start_time;
-	}
-	#ifdef ACCURATE_FPS_CALC
-	{
-		const int fps_statistics_interval = 900;
-		int pre_frames2;
-		struct timeval pre_time2;
-		pre_frames2 = old_encoding_states[stream_id].total_frames2;
-		pre_time2 = old_encoding_states[stream_id].time2;
-		if ((curr_frames % fps_statistics_interval ==0) &&(print_frame)) {
-			time_interval_us2 = (curr_time.tv_sec - pre_time2.tv_sec) * 1000000 +
-						curr_time.tv_usec - pre_time2.tv_usec;
-			double fps = (curr_frames - pre_frames2)* 1000000.0/(double)time_interval_us2;
-			BOLD_PRINT("AVG FPS = %4.2f\n",fps);
-			old_encoding_states[stream_id].total_frames2 = encoding_states[stream_id].total_frames;
-			old_encoding_states[stream_id].time2 = encoding_states[stream_id].capture_start_time;
-		}
-	}
-	#endif
-
 write_stream_exit:
 	return 0;
 }
 
+#if 0
 //return 1 is IAV is in encoding,  else, return 0
-int is_video_encoding(void)
+static int is_video_encoding(void)
 {
 	int state;
 
@@ -960,8 +1890,9 @@ int is_video_encoding(void)
 
 	return (state == IAV_STATE_ENCODING);
 }
+#endif
 
-int show_waiting(void)
+static int show_waiting(void)
 {
 	#define DOT_MAX_COUNT 10
 	static int dot_count = DOT_MAX_COUNT;
@@ -982,12 +1913,11 @@ int show_waiting(void)
 	return 0;
 }
 
-
-int capture_encoded_video()
+static int capture_encoded_video()
 {
 	int rval;
 	//open file handles to write to
-	int total_frames;
+	u64 total_frames;
 	u64 total_bytes;
 	total_frames = 0;
 	total_bytes =  0;
@@ -1001,7 +1931,7 @@ int capture_encoded_video()
 	}
 #endif
 
-	while (1) {
+	while (write_video_file_run) {
 		if ((rval = write_stream(&total_frames, &total_bytes)) < 0) {
 			if (rval == -1) {
 				usleep(100 * 1000);
@@ -1010,16 +1940,17 @@ int capture_encoded_video()
 				printf("write_stream err code %d \n", rval);
 			}
 			continue;
-                }
-                if(md5_idr_number == 0) {
-                        md5_idr_number = -1;
-                        break;
-                }
+		}
+		if(md5_idr_number == 0) {
+			md5_idr_number = -1;
+			statistics_run = 0;
+			break;
+		}
 	}
 
 	printf("stop encoded stream capture\n");
 
-	printf("total_frames = %d\n", total_frames);
+	printf("total_frames = %lld\n", total_frames);
 	printf("total_bytes = %lld\n", total_bytes);
 
 	return 0;
@@ -1081,12 +2012,27 @@ static int deinit_transfer(void)
 
 static void sigstop()
 {
-	deinit_transfer();
-	exit(1);
+	statistics_run = 0;
+	write_video_file_run = 0;
 }
 
+static void stop_statistics()
+{
+	pipe_mesg_t msg;
+
+	memset(&msg, 0, sizeof(msg));
+	msg.stop = 1;
+	printf("Sending stop statistics message!\n");
+	if (write(pipefd[1], &msg, sizeof(msg)) != sizeof(msg)) {
+		printf("Failed to send stop message to statistics thread: %s!\n", strerror(errno));
+	}
+	if (pipefd[1] >= 0) {
+		close(pipefd[1]);
+		pipefd[1] = -1;
+	}
+}
 
-int map_bsb(void)
+static int map_bsb(void)
 {
 	struct iav_querybuf querybuf;
 
@@ -1109,48 +2055,89 @@ int map_bsb(void)
 
 int main(int argc, char **argv)
 {
+	int ret = 0;
+	int err = 0;
+	pthread_t tid;
+
 	//register signal handler for Ctrl+C,  Ctrl+'\'  ,  and "kill" sys cmd
-	signal(SIGINT, 	sigstop);
-	signal(SIGQUIT,	sigstop);
-	signal(SIGTERM,	sigstop);
+	signal(SIGINT, sigstop);
+	signal(SIGQUIT, sigstop);
+	signal(SIGTERM, sigstop);
 
-	if ((fd_iav = open("/dev/iav", O_RDWR, 0)) < 0) {
-		perror("/dev/iav");
-		return -1;
-	}
+	do {
+		if ((fd_iav = open("/dev/iav", O_RDWR, 0)) < 0) {
+			perror("/dev/iav");
+			ret = -1;
+			break;
+		}
 
-	if (argc < 2) {
-		usage();
-		return -1;
-	}
+		if (argc < 2) {
+			usage();
+			ret = -1;
+			break;
+		}
 
-	if (init_param(argc, argv) < 0) {
-		printf("init param failed \n");
-		return -1;
-	}
+		if (init_param(argc, argv) < 0) {
+			printf("init param failed \n");
+			ret = -1;
+			break;
+		}
 
-	if (map_bsb() < 0) {
-		printf("map bsb failed\n");
-		return -1;
-	}
+		if (map_bsb() < 0) {
+			printf("map bsb failed\n");
+			ret = -1;
+			break;
+		}
 
-	init_encoding_states();
+		if (init_data() < 0) {
+			printf("data initiation failed!\n");
+			ret = -1;
+			break;
+		}
 
-	if (init_transfer() < 0) {
-		return -1;
-	}
+		if (init_transfer() < 0) {
+			ret = -1;
+			break;
+		}
 
-	if (capture_encoded_video() < 0) {
-		printf("capture encoded video failed \n");
-		return -1;
+		if (pipe(pipefd) < 0) {
+			printf("Pipe create error!\n");
+			ret = -1;
+			break;
+		}
+
+		fcntl(pipefd[1], F_SETFL, O_NONBLOCK);
+
+		err = pthread_create(&tid, NULL, do_statistics, NULL);
+		if (err != 0) {
+			printf("can't create do statistics thread: %s\n", strerror(err));
+			ret = -1;
+			break;
+		}
+	}while (0);
+
+	if (ret == 0) {
+		if (capture_encoded_video() < 0) {
+			printf("capture encoded video failed \n");
+			ret = -1;
+		}
+		stop_statistics();
+		pthread_join(tid, NULL);
 	}
 
 	if (deinit_transfer() < 0) {
-		return -1;
+		printf("deinit_transfer failed.\n");
+		ret = -1;
 	}
 
-	close(fd_iav);
-	return 0;
+	deinit_stream_files(-1);
+
+	if (fd_iav) {
+		close(fd_iav);
+		fd_iav = -1;
+	}
+
+	return ret;
 }
 
 
diff --git a/iav_test/test_sw_encoding.c b/iav_test/test_sw_encoding.c
index ef08523..4f2bf20 100644
--- a/iav_test/test_sw_encoding.c
+++ b/iav_test/test_sw_encoding.c
@@ -4,12 +4,29 @@
  * History:
  *	2014/12/16 - [Zhi He] created file
  *
- * Copyright (C) 2014, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
diff --git a/iav_test/test_vin_cap.c b/iav_test/test_vin_cap.c
new file mode 100644
index 0000000..e7fc1a2
--- /dev/null
+++ b/iav_test/test_vin_cap.c
@@ -0,0 +1,525 @@
+/*******************************************************************************
+ * test_vin_cap.c
+ *
+ * History:
+ *    2017/02/07 - [Zhaoyang Chen] create this file
+ *
+ * Copyright (c) 2017 Ambarella, Inc.
+ *
+ * This file and its contents ( "Software" ) are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+******************************************************************************/
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <errno.h>
+#include <getopt.h>
+#include <sched.h>
+
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <linux/netlink.h>
+#include <signal.h>
+#include <basetypes.h>
+
+#include "iav_ioctl.h"
+#include "iav_netlink.h"
+
+// vin
+#include "../vin_test/vin_init.c"
+
+struct nl_vsync_config {
+	s32 fd_nl;
+	s32 nl_connected;
+	struct nl_msg_data msg;
+	char nl_send_buf[MAX_NL_MSG_LEN];
+	char nl_recv_buf[MAX_NL_MSG_LEN];
+};
+
+static int recover_vin_cap(void);
+
+int fd_iav;
+static struct nl_vsync_config vsync_config;
+
+enum VIN_CAP_OP {
+	VIN_CAP_OP_SUSPEND = 0,
+	VIN_CAP_OP_RESUME = 1,
+	VIN_CAP_OP_AUTO = 2,
+};
+
+#define	NO_ARG		0
+#define	HAS_ARG		1
+static struct option long_options[] = {
+	{"suspend",			NO_ARG,		0,		's' },
+	{"resume",			HAS_ARG,	0,		'r' },
+	{"auto",			NO_ARG,		0,		'a' },
+	{0, 0, 0, 0}
+};
+
+static const char *short_options = "asr:";
+
+struct hint_s {
+	const char *arg;
+	const char *str;
+};
+
+static const struct hint_s hint[] = {
+	{"", "\t\tSuspend DSP VIN capture"},
+	{"0|1", "\tResume DSP VIN capture, 0: Don't reset input (Sensor or YUV), "
+		"1: Reset input (Sensor or YUV)"},
+	{"", "\t\tAutomatically resume VIN capture for vsync loss case"},
+};
+
+static void usage(void)
+{
+	int i;
+
+	printf("test_vin_cap usage:\n");
+	for (i = 0; i < sizeof(long_options) / sizeof(long_options[0]) - 1; i++) {
+		if (isalpha(long_options[i].val))
+			printf("-%c ", long_options[i].val);
+		else
+			printf("   ");
+		printf("--%s", long_options[i].name);
+		if (hint[i].arg[0] != 0)
+			printf(" [%s]", hint[i].arg);
+		printf("\t%s\n", hint[i].str);
+	}
+	printf("\nExamples:\n"
+		"  Suspend VIN capture:\n"
+		"    test_vin_cap -s\n"
+		"  Resume VIN capture without input reset:\n"
+		"    test_vin_cap -r 0\n"
+		"  Resume VIN capture, including input reset:\n"
+		"    test_vin_cap -r 1\n"
+		"  Automatically resume VIN capture for vsync loss case:\n"
+		"    test_vin_cap -a\n");
+	printf("\n");
+
+}
+
+static int init_netlink()
+{
+	u32 pid;
+	struct sockaddr_nl saddr;
+
+	vsync_config.fd_nl = socket(AF_NETLINK, SOCK_RAW, NL_PORT_VSYNC);
+	memset(&saddr, 0, sizeof(saddr));
+	pid = getpid();
+	saddr.nl_family = AF_NETLINK;
+	saddr.nl_pid = pid;
+	saddr.nl_groups = 0;
+	saddr.nl_pad = 0;
+	bind(vsync_config.fd_nl, (struct sockaddr *)&saddr, sizeof(saddr));
+
+	vsync_config.nl_connected = 0;
+
+	return 0;
+}
+
+static int send_vsync_msg_to_kernel(struct nl_msg_data vsync_msg)
+{
+	struct sockaddr_nl daddr;
+	struct msghdr msg;
+	struct nlmsghdr *nlhdr = NULL;
+	struct iovec iov;
+
+	memset(&daddr, 0, sizeof(daddr));
+	daddr.nl_family = AF_NETLINK;
+	daddr.nl_pid = 0;
+	daddr.nl_groups = 0;
+	daddr.nl_pad = 0;
+
+	nlhdr = (struct nlmsghdr *)vsync_config.nl_send_buf;
+	nlhdr->nlmsg_pid = getpid();
+	nlhdr->nlmsg_len = NLMSG_LENGTH(sizeof(vsync_msg));
+	nlhdr->nlmsg_flags = 0;
+	memcpy(NLMSG_DATA(nlhdr), &vsync_msg, sizeof(vsync_msg));
+
+	memset(&msg, 0, sizeof(struct msghdr));
+	iov.iov_base = (void *)nlhdr;
+	iov.iov_len = nlhdr->nlmsg_len;
+	msg.msg_name = (void *)&daddr;
+	msg.msg_namelen = sizeof(daddr);
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+
+	sendmsg(vsync_config.fd_nl, &msg, 0);
+
+	return 0;
+}
+
+static int recv_vsync_msg_from_kernel()
+{
+	struct sockaddr_nl sa;
+	struct nlmsghdr *nlhdr = NULL;
+	struct msghdr msg;
+	struct iovec iov;
+
+	int ret = 0;
+
+	nlhdr = (struct nlmsghdr *)vsync_config.nl_recv_buf;
+	iov.iov_base = (void *)nlhdr;
+	iov.iov_len = MAX_NL_MSG_LEN;
+
+	memset(&sa, 0, sizeof(sa));
+	memset(&msg, 0, sizeof(msg));
+	msg.msg_name = (void *)&(sa);
+	msg.msg_namelen = sizeof(sa);
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+
+	if (vsync_config.fd_nl > 0) {
+		ret = recvmsg(vsync_config.fd_nl, &msg, 0);
+	} else {
+		printf("Netlink socket is not opened to receive message!\n");
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static int check_recv_vsync_msg()
+{
+	struct nlmsghdr *nlhdr = NULL;
+	int msg_len;
+
+	nlhdr = (struct nlmsghdr *)vsync_config.nl_recv_buf;
+	if (nlhdr->nlmsg_len <  sizeof(struct nlmsghdr)) {
+		printf("Corruptted kernel message!\n");
+		return -1;
+	}
+	msg_len = nlhdr->nlmsg_len - NLMSG_LENGTH(0);
+	if (msg_len < sizeof(struct nl_msg_data)) {
+		printf("Unknown kernel message!!\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int process_vsync_req(int vsync_req)
+{
+	int ret = 0;
+
+	if (vsync_req == NL_REQ_VSYNC_RESTORE) {
+		ret = recover_vin_cap();
+		vsync_config.msg.pid = getpid();
+		vsync_config.msg.port = NL_PORT_VSYNC;
+		vsync_config.msg.type = NL_MSG_TYPE_REQUEST;
+		vsync_config.msg.dir = NL_MSG_DIR_STATUS;
+		vsync_config.msg.cmd = NL_REQ_VSYNC_RESTORE;
+		if (ret < 0) {
+			vsync_config.msg.status = NL_CMD_STATUS_FAIL;
+			send_vsync_msg_to_kernel(vsync_config.msg);
+		} else {
+			vsync_config.msg.status = NL_CMD_STATUS_SUCCESS;
+			send_vsync_msg_to_kernel(vsync_config.msg);
+		}
+	} else {
+		printf("Unrecognized kernel message!\n");
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static int process_vsync_session_status(struct nl_msg_data *kernel_msg)
+{
+	int ret = 0;
+
+	if (kernel_msg->type != NL_MSG_TYPE_SESSION ||
+		kernel_msg->dir != NL_MSG_DIR_STATUS) {
+		return -1;
+	}
+
+	switch (kernel_msg->cmd) {
+	case NL_SESS_CMD_CONNECT:
+		if (kernel_msg->status == NL_CMD_STATUS_SUCCESS) {
+			vsync_config.nl_connected = 1;
+			printf("Connection established with kernel.\n");
+		} else {
+			vsync_config.nl_connected = 0;
+			printf("Failed to establish connection with kernel!\n");
+		}
+		break;
+	case NL_SESS_CMD_DISCONNECT:
+		vsync_config.nl_connected = 0;
+		if (kernel_msg->status == NL_CMD_STATUS_SUCCESS) {
+			printf("Connection removed with kernel.\n");
+		} else {
+			printf("Failed to remove connection with kernel!\n");
+		}
+		break;
+	default:
+		printf("Unrecognized session cmd from kernel!\n");
+		ret = -1;
+		break;
+	}
+
+	return ret;
+}
+
+static int process_vsync_msg()
+{
+	struct nlmsghdr *nlhdr = NULL;
+	struct nl_msg_data *kernel_msg;
+	int ret = 0;
+
+	if (check_recv_vsync_msg() < 0) {
+		return -1;
+	}
+
+	nlhdr = (struct nlmsghdr *)vsync_config.nl_recv_buf;
+	kernel_msg = (struct nl_msg_data *)NLMSG_DATA(nlhdr);
+
+	if(kernel_msg->type == NL_MSG_TYPE_REQUEST &&
+		kernel_msg->dir == NL_MSG_DIR_CMD) {
+		if (process_vsync_req(kernel_msg->cmd) < 0) {
+			ret = -1;
+		}
+	} else if (kernel_msg->type == NL_MSG_TYPE_SESSION &&
+				kernel_msg->dir == NL_MSG_DIR_STATUS) {
+		if (process_vsync_session_status(kernel_msg) < 0) {
+			ret = -1;
+		}
+	} else {
+		printf("Incorrect message from kernel!\n");
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static int nl_send_vsync_session_cmd(int cmd)
+{
+	int ret = 0;
+
+	vsync_config.msg.pid = getpid();
+	vsync_config.msg.port = NL_PORT_VSYNC;
+	vsync_config.msg.type = NL_MSG_TYPE_SESSION;
+	vsync_config.msg.dir = NL_MSG_DIR_CMD;
+	vsync_config.msg.cmd = cmd;
+	vsync_config.msg.status = 0;
+	send_vsync_msg_to_kernel(vsync_config.msg);
+
+	ret = recv_vsync_msg_from_kernel();
+
+	if (ret > 0) {
+		ret = process_vsync_msg();
+		if (ret < 0) {
+			printf("Failed to process session status!\n");
+		}
+	} else {
+		printf("Error for getting session status!\n");
+	}
+
+	return ret;
+}
+
+static void * netlink_loop(void * data)
+{
+	int ret;
+	int count = 100;
+
+	while (count && !vsync_config.nl_connected) {
+		if (nl_send_vsync_session_cmd(NL_SESS_CMD_CONNECT) < 0) {
+			printf("Failed to establish connection with kernel!\n");
+		}
+		sleep(1);
+		count--;
+	}
+
+	if (!vsync_config.nl_connected) {
+		printf("Please enable kernel vsync loss guard mechanism!!!\n");
+		return NULL;
+	}
+
+	while (vsync_config.nl_connected) {
+		ret = recv_vsync_msg_from_kernel();
+		if (ret > 0) {
+			ret = process_vsync_msg();
+			if (ret < 0) {
+				printf("Failed to process the msg from kernel!\n");
+			}
+		}
+		else {
+			printf("Error for getting msg from kernel!\n");
+		}
+	}
+
+	return NULL;
+}
+
+static int vin_cap_resume(int enable)
+{
+	struct iav_vcap_cfg cfg;
+	int ret = 0;
+
+	cfg.cid = IAV_VCAP_CFG_STATE;
+	cfg.arg.state = enable ? IAV_VCAP_STATE_ACTIVE : IAV_VCAP_STATE_IDLE;
+	ret = ioctl(fd_iav, IAV_IOC_SET_VCAP_CFG, &cfg);
+
+	return ret;
+}
+
+static int reset_input(void)
+{
+	struct vindev_mode video_info;
+	struct vindev_fps vsrc_fps;
+	// select channel: for multi channel VIN (initialize)
+	if (channel >= 0) {
+		if (select_channel() < 0)
+			return -1;
+	}
+
+	memset(&video_info, 0, sizeof(video_info));
+	video_info.vsrc_id = 0;
+	if(ioctl(fd_iav, IAV_IOC_VIN_GET_MODE, &video_info) < 0) {
+		return -1;
+	} else {
+		printf("Start to restore vin_mode 0x%x and hdr_mode %d.\n",
+			video_info.video_mode, video_info.hdr_mode);
+	}
+
+	vsrc_fps.vsrc_id = 0;
+	if(ioctl(fd_iav, IAV_IOC_VIN_GET_FPS, &vsrc_fps) < 0) {
+		return -1;
+	} else {
+		printf("Start to restore vin frame rate %d.\n", vsrc_fps.fps);
+	}
+
+	if(ioctl(fd_iav, IAV_IOC_VIN_SET_MODE, &video_info) < 0) {
+		return -1;
+	} else {
+		printf("Succeed to restore vin_mode 0x%x and hdr_mode %d.\n",
+			video_info.video_mode, video_info.hdr_mode);
+	}
+
+	if (ioctl(fd_iav, IAV_IOC_VIN_SET_FPS, &vsrc_fps) < 0) {
+		perror("IAV_IOC_VIN_SET_FPS");
+		return -1;
+	} else {
+		printf("Succeed to restore vin frame rate %d.\n", vsrc_fps.fps);
+	}
+
+	return 0;
+}
+
+static int recover_vin_cap(void)
+{
+	int ret = 0;
+
+	ret = vin_cap_resume(0);
+	if (ret) {
+		return ret;
+	}
+	ret = reset_input();
+	if (ret) {
+		return ret;
+	}
+	ret = vin_cap_resume(1);
+	if (ret) {
+		return ret;
+	}
+
+	return ret;
+}
+
+static void vin_cap_auto(void)
+{
+	init_netlink();
+	netlink_loop(NULL);
+}
+
+static void sigstop()
+{
+	nl_send_vsync_session_cmd(NL_SESS_CMD_DISCONNECT);
+	exit(1);
+}
+
+int vin_vcap_param(int argc, char **argv)
+{
+	int ch, reset_input_flag;
+	int option_index = 0;
+
+	opterr = 0;
+	while ((ch = getopt_long(argc, argv, short_options, long_options,
+		&option_index)) != -1) {
+		switch (ch) {
+		case 's':
+			vin_cap_resume(0);
+			break;
+		case 'r':
+			reset_input_flag = atoi(optarg);
+			if (reset_input_flag != 0 && reset_input_flag != 1) {
+				printf("Invalid resume param %d, should be 0|1!\n",
+					reset_input_flag);
+				return -1;
+			} else if (reset_input_flag) {
+				reset_input();
+			}
+			vin_cap_resume(1);
+			break;
+		case 'a':
+			vin_cap_auto();
+			break;
+		default:
+			printf("unknown option found: %c\n", ch);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+int main(int argc, char **argv)
+{
+	//register signal handler for Ctrl+C, Ctrl+'\', and "kill" sys cmd
+	signal(SIGINT, 	sigstop);
+	signal(SIGQUIT,	sigstop);
+	signal(SIGTERM,	sigstop);
+
+	if (argc < 2) {
+		usage();
+		return -1;
+	}
+
+	// open the device
+	if ((fd_iav = open("/dev/iav", O_RDWR, 0)) < 0) {
+		perror("/dev/iav");
+		return -1;
+	}
+
+	if (vin_vcap_param(argc, argv) < 0) {
+		return -1;
+	}
+
+	return 0;
+}
+
diff --git a/iav_test/test_warp.c b/iav_test/test_warp.c
index 99eae33..b5cf5ad 100644
--- a/iav_test/test_warp.c
+++ b/iav_test/test_warp.c
@@ -1,17 +1,34 @@
-/*******************************************************************************
+/*
  * test_warp.c
  *
  * History:
  *  Feb 11, 2014 - [qianshen] created file
  *
- * Copyright (C) 2012-2016, Ambarella ShangHai Co,Ltd
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- ******************************************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include <unistd.h>
 #include <fcntl.h>
diff --git a/iav_test/test_yuvcap.c b/iav_test/test_yuvcap.c
index fdcb5ce..eae9a10 100644
--- a/iav_test/test_yuvcap.c
+++ b/iav_test/test_yuvcap.c
@@ -1,18 +1,35 @@
-/*
+/*******************************************************************************
  * test_yuvcap.c
  *
  * History:
- *	2012/02/09 - [Jian Tang] created file
+ *  2012/02/09 - [Jian Tang] created file
  *	2014/04/25 - [Zhaoyang Chen] modified file
  *
- * Copyright (C) 2007-2012, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ( "Software" ) are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- */
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+******************************************************************************/
 
 #include <unistd.h>
 #include <fcntl.h>
@@ -38,11 +55,9 @@
 #include <signal.h>
 
 
-#define	MAX_SOURCE_BUFFER_NUM	(4)
-
 #ifndef VERIFY_BUFFERID
 #define VERIFY_BUFFERID(x)	do {		\
-			if ((x) < 0 || ((x) >= MAX_SOURCE_BUFFER_NUM)) {	\
+			if ((x) < 0 || ((x) >= IAV_SRCBUF_PMN)) {	\
 				printf("Invalid buffer id %d.\n", (x));	\
 				return -1;	\
 			}	\
@@ -74,6 +89,7 @@ typedef enum {
 	YUV420_NV12 = 2,	// Pattern: YYYYYYYYUVUV
 	YUV422_YU16 = 3,	// Pattern: YYYYYYYYUUUUVVVV
 	YUV422_YV16 = 4,	// Pattern: YYYYYYYYVVVVUUUU
+	YUV422_NV16 = 5,	// Pattern: YYYYYYYYUVUVUVUV
 	YUV_FORMAT_TOTAL_NUM,
 	YUV_FORMAT_FIRST = YUV420_IYUV,
 	YUV_FORMAT_LAST = YUV_FORMAT_TOTAL_NUM,
@@ -113,8 +129,8 @@ const char *default_filename_tcp = "media/test";
 const char *default_host_ip_addr = "10.0.0.1";
 const char *default_filename;
 static char filename[256];
-static int fd_yuv[MAX_SOURCE_BUFFER_NUM];
-static int fd_me[MAX_SOURCE_BUFFER_NUM];
+static int fd_yuv[IAV_SRCBUF_PMN];
+static int fd_me[IAV_SRCBUF_PMN];
 static int fd_raw = -1;
 
 static u8 *dsp_mem = NULL;
@@ -338,6 +354,13 @@ static int save_yuv_chroma_buffer(u8* output, struct iav_yuvbufdesc *yuv_desc)
 		if (yuv_format == YUV422_YU16) {
 			yuv.u = output;
 			yuv.v = output + width * height;
+			chrome_convert(&yuv);
+		} else if (yuv_format == YUV422_NV16){
+			// NV16 format (YYYYYYYYUVUVUVUV)
+			input = base + yuv_desc->uv_addr_offset;
+			for (i = 0; i < height; ++i) {
+				memcpy(output + i * width * 2, input + i * pitch * 2, width * 2);
+			}
 		} else {
 			if (yuv_format != YUV422_YV16) {
 				printf("Change output format back to YV16 for preview!\n");
@@ -345,8 +368,8 @@ static int save_yuv_chroma_buffer(u8* output, struct iav_yuvbufdesc *yuv_desc)
 			}
 			yuv.u = output + width * height;
 			yuv.v = output;
+			chrome_convert(&yuv);
 		}
-		chrome_convert(&yuv);
 	} else {
 		printf("Error: Unsupported YUV input format!\n");
 		ret = -1;
@@ -420,8 +443,8 @@ static int save_yuv_data(int fd, int buffer, struct iav_yuvbufdesc *yuv_desc,
 
 static int capture_yuv(int buff_id, int count)
 {
-	int i, buf, save[MAX_SOURCE_BUFFER_NUM];
-	int write_flag[MAX_SOURCE_BUFFER_NUM];
+	int i, buf, save[IAV_SRCBUF_PMN];
+	int write_flag[IAV_SRCBUF_PMN];
 	char yuv_file[256];
 	int non_stop = 0;
 	u8 * luma = NULL;
@@ -431,164 +454,172 @@ static int capture_yuv(int buff_id, int count)
 	struct iav_querydesc query_desc;
 	struct iav_srcbuf_format buf_format;
 	struct iav_yuv_cap *yuv_cap;
+	int rval = 0;
 
-	luma = malloc(MAX_YUV_BUFFER_SIZE);
-	if (luma == NULL) {
-		printf("Not enough memory for preview capture !\n");
-		goto yuv_error_exit;
-	}
-	chroma = malloc(MAX_YUV_BUFFER_SIZE);
-	if (chroma == NULL) {
-		printf("Not enough memory for preivew capture !\n");
-		goto yuv_error_exit;
-	}
-	memset(save, 0, sizeof(save));
-	memset(write_flag, 0, sizeof(write_flag));
-	memset(luma, 1, MAX_YUV_BUFFER_SIZE);
-	memset(chroma, 1, MAX_YUV_BUFFER_SIZE);
+	do {
+		luma = malloc(MAX_YUV_BUFFER_SIZE);
+		if (luma == NULL) {
+			printf("Not enough memory for preview capture !\n");
+			rval = -1;
+			break;
+		}
+		chroma = malloc(MAX_YUV_BUFFER_SIZE);
+		if (chroma == NULL) {
+			printf("Not enough memory for preivew capture !\n");
+			rval = -1;
+			break;
+		}
+		memset(save, 0, sizeof(save));
+		memset(write_flag, 0, sizeof(write_flag));
+		memset(luma, 1, MAX_YUV_BUFFER_SIZE);
+		memset(chroma, 1, MAX_YUV_BUFFER_SIZE);
 
-	if (count == 0) {
-		non_stop = 1;
-	}
+		if (count == 0) {
+			non_stop = 1;
+		}
 
-	for (i = 0; ((i < count || non_stop) && !quit_capture); ++i) {
-		for (buf = IAV_SRCBUF_FIRST;
-			buf < IAV_SRCBUF_LAST; ++buf) {
-			if (buff_id & (1 << buf)) {
-				if (fd_yuv[buf] < 0) {
-					memset(&buf_format, 0, sizeof(buf_format));
-					buf_format.buf_id = buf;
-					if (ioctl(fd_iav, IAV_IOC_GET_SOURCE_BUFFER_FORMAT, &buf_format) < 0) {
-						perror("IAV_IOC_GET_SOURCE_BUFFER_FORMAT");
-						continue;
-					}
-					memset(yuv_file, 0, sizeof(yuv_file));
-					sprintf(yuv_file, "%s_prev_%c_%dx%d.yuv", filename,
-						(buf == IAV_SRCBUF_MN) ? 'M' :
-						('a' + IAV_SRCBUF_PA - buf),
-						buf_format.size.width, buf_format.size.height);
+		for (i = 0; ((i < count || non_stop) && !quit_capture); ++i) {
+			for (buf = IAV_SRCBUF_FIRST;
+				buf < IAV_SRCBUF_LAST; ++buf) {
+				if (buff_id & (1 << buf)) {
 					if (fd_yuv[buf] < 0) {
-						fd_yuv[buf] = amba_transfer_open(yuv_file,
-							transfer_method, port++);
-					}
-					if (fd_yuv[buf] < 0) {
-						printf("Cannot open file [%s].\n", yuv_file);
-						continue;
+						memset(&buf_format, 0, sizeof(buf_format));
+						buf_format.buf_id = buf;
+						if (ioctl(fd_iav, IAV_IOC_GET_SOURCE_BUFFER_FORMAT, &buf_format) < 0) {
+							perror("IAV_IOC_GET_SOURCE_BUFFER_FORMAT");
+							continue;
+						}
+						memset(yuv_file, 0, sizeof(yuv_file));
+						sprintf(yuv_file, "%s_prev_%c_%dx%d.yuv", filename,
+							(buf == IAV_SRCBUF_MN) ? 'M' :
+							('a' + IAV_SRCBUF_PA - buf),
+							buf_format.size.width, buf_format.size.height);
+						if (fd_yuv[buf] < 0) {
+							fd_yuv[buf] = amba_transfer_open(yuv_file,
+								transfer_method, port++);
+						}
+						if (fd_yuv[buf] < 0) {
+							printf("Cannot open file [%s].\n", yuv_file);
+							continue;
+						}
 					}
-				}
 
-				memset(&query_desc, 0, sizeof(query_desc));
-				if (!non_block_read) {
-					query_desc.qid = IAV_DESC_YUV;
-					query_desc.arg.yuv.buf_id = buf;
-					query_desc.arg.yuv.flag &= ~IAV_BUFCAP_NONBLOCK;
-				} else {
-					/* It's also supported to use 'IAV_DESC_YUV' here. */
-					query_desc.qid = IAV_DESC_BUFCAP;
-					query_desc.arg.bufcap.flag |= IAV_BUFCAP_NONBLOCK;
-				}
-
-				if (verbose) {
-					gettimeofday(&curr, NULL);
-					pre = curr;
-				}
-				if (ioctl(fd_iav, IAV_IOC_QUERY_DESC, &query_desc) < 0) {
-					if (errno == EINTR) {
-						continue;		/* back to for() */
+					memset(&query_desc, 0, sizeof(query_desc));
+					if (!non_block_read) {
+						query_desc.qid = IAV_DESC_YUV;
+						query_desc.arg.yuv.buf_id = buf;
+						query_desc.arg.yuv.flag &= ~IAV_BUFCAP_NONBLOCK;
 					} else {
-						perror("IAV_IOC_QUERY_DESC");
-						goto yuv_error_exit;
+						/* It's also supported to use 'IAV_DESC_YUV' here. */
+						query_desc.qid = IAV_DESC_BUFCAP;
+						query_desc.arg.bufcap.flag |= IAV_BUFCAP_NONBLOCK;
 					}
-				}
-				if (verbose) {
-					gettimeofday(&curr, NULL);
-					printf("11. Query DESC [%06ld us].\n", 1000000 *
-						(curr.tv_sec - pre.tv_sec)  + (curr.tv_usec - pre.tv_usec));
-				}
-				memset(&yuv_desc, 0, sizeof(yuv_desc));
-				if (!non_block_read) {
-					yuv_desc = query_desc.arg.yuv;
-				} else {
-					yuv_cap = &query_desc.arg.bufcap.yuv[buf];
-					yuv_desc.y_addr_offset = yuv_cap->y_addr_offset;
-					yuv_desc.uv_addr_offset = yuv_cap->uv_addr_offset;
-					yuv_desc.width = yuv_cap->width;
-					yuv_desc.height = yuv_cap->height;
-					yuv_desc.pitch = yuv_cap->pitch;
-					yuv_desc.seq_num = yuv_cap->seq_num;
-					yuv_desc.format = yuv_cap->format;
-					yuv_desc.mono_pts = yuv_cap->mono_pts;
-				}
 
-				if (((u8 *)yuv_desc.y_addr_offset == NULL) || ((u8 *)yuv_desc.uv_addr_offset == NULL)) {
-					printf("YUV buffer [%d] address is NULL! Skip to next!\n", buf);
-					continue;
-				}
-				if (delay_frame_cap_data) {
-					if (write_flag[buf] == 0) {
-						write_flag[buf] = 1;
-						yuv_desc_cache = yuv_desc;
-					} else {
-						write_flag[buf] = 0;
-						if (save_yuv_data(fd_yuv[buf], buf, &yuv_desc_cache, luma, chroma) < 0) {
-							printf("Failed to save YUV data of buf [%d].\n", buf);
-							goto yuv_error_exit;
+					if (verbose) {
+						gettimeofday(&curr, NULL);
+						pre = curr;
+					}
+					if (ioctl(fd_iav, IAV_IOC_QUERY_DESC, &query_desc) < 0) {
+						if (errno == EINTR) {
+							continue;		/* back to for() */
+						} else {
+							perror("IAV_IOC_QUERY_DESC");
+							rval = -1;
+							break;
 						}
 					}
-				} else {
-					if (save_yuv_data(fd_yuv[buf], buf, &yuv_desc, luma, chroma) < 0) {
-						printf("Failed to save YUV data of buf [%d].\n", buf);
-						goto yuv_error_exit;
+					if (verbose) {
+						gettimeofday(&curr, NULL);
+						printf("11. Query DESC [%06ld us].\n", 1000000 *
+							(curr.tv_sec - pre.tv_sec)  + (curr.tv_usec - pre.tv_usec));
+					}
+					memset(&yuv_desc, 0, sizeof(yuv_desc));
+					if (!non_block_read) {
+						yuv_desc = query_desc.arg.yuv;
+					} else {
+						yuv_cap = &query_desc.arg.bufcap.yuv[buf];
+						yuv_desc.y_addr_offset = yuv_cap->y_addr_offset;
+						yuv_desc.uv_addr_offset = yuv_cap->uv_addr_offset;
+						yuv_desc.width = yuv_cap->width;
+						yuv_desc.height = yuv_cap->height;
+						yuv_desc.pitch = yuv_cap->pitch;
+						yuv_desc.seq_num = yuv_cap->seq_num;
+						yuv_desc.format = yuv_cap->format;
+						yuv_desc.mono_pts = yuv_cap->mono_pts;
 					}
-				}
 
-				if (save[buf] == 0) {
-					save[buf] = 1;
-					if (yuv_desc.format == IAV_YUV_FORMAT_YUV422) {
-						if (yuv_format == YUV422_YU16) {
-							sprintf(format,"YU16");
-						} else if (yuv_format == YUV422_YV16) {
-							sprintf(format, "YV16");
+					if (((u8 *)yuv_desc.y_addr_offset == NULL) || ((u8 *)yuv_desc.uv_addr_offset == NULL)) {
+						printf("YUV buffer [%d] address is NULL! Skip to next!\n", buf);
+						continue;
+					}
+					if (delay_frame_cap_data) {
+						if (write_flag[buf] == 0) {
+							write_flag[buf] = 1;
+							yuv_desc_cache = yuv_desc;
 						} else {
-							printf("Error: Unsupported YUV 422 format!\n");
-							return -1;
+							write_flag[buf] = 0;
+							if (save_yuv_data(fd_yuv[buf], buf, &yuv_desc_cache, luma, chroma) < 0) {
+								printf("Failed to save YUV data of buf [%d].\n", buf);
+								rval = -1;
+								break;
+							}
 						}
-					} else if (yuv_desc.format == IAV_YUV_FORMAT_YUV420) {
-						switch (yuv_format) {
-						case YUV420_YV12:
-							sprintf(format, "YV12");
-							break;
-						case YUV420_NV12:
-							sprintf(format, "NV12");
-							break;
-						case YUV420_IYUV:
-							sprintf(format, "IYUV");
-							break;
-						default:
-							sprintf(format, "IYUV");
+					} else {
+						if (save_yuv_data(fd_yuv[buf], buf, &yuv_desc, luma, chroma) < 0) {
+							printf("Failed to save YUV data of buf [%d].\n", buf);
+							rval = -1;
 							break;
 						}
-					} else {
-						sprintf(format, "Unknown [%d]", yuv_desc.format);
 					}
-					printf("Delay %d frame capture yuv data.\n", delay_frame_cap_data);
-					printf("Capture_yuv_buffer: resolution %dx%d in %s format\n",
-						yuv_desc.width, yuv_desc.height, format);
+
+					if (save[buf] == 0) {
+						save[buf] = 1;
+						if (yuv_desc.format == IAV_YUV_FORMAT_YUV422) {
+							if (yuv_format == YUV422_YU16) {
+								sprintf(format,"YU16");
+							} else if (yuv_format == YUV422_YV16) {
+								sprintf(format, "YV16");
+							} else if (yuv_format == YUV422_NV16) {
+								sprintf(format, "NV16");
+							} else {
+								printf("Error: Unsupported YUV 422 format!\n");
+								return -1;
+							}
+						} else if (yuv_desc.format == IAV_YUV_FORMAT_YUV420) {
+							switch (yuv_format) {
+							case YUV420_YV12:
+								sprintf(format, "YV12");
+								break;
+							case YUV420_NV12:
+								sprintf(format, "NV12");
+								break;
+							case YUV420_IYUV:
+								sprintf(format, "IYUV");
+								break;
+							default:
+								sprintf(format, "IYUV");
+								break;
+							}
+						} else {
+							sprintf(format, "Unknown [%d]", yuv_desc.format);
+						}
+						printf("Delay %d frame capture yuv data.\n", delay_frame_cap_data);
+						printf("Capture_yuv_buffer: resolution %dx%d in %s format\n",
+							yuv_desc.width, yuv_desc.height, format);
+					}
 				}
 			}
+			if (rval < 0) {
+				break;
+			}
 		}
-	}
-
-	free(luma);
-	free(chroma);
-	return 0;
+	} while (0);
 
-yuv_error_exit:
 	if (luma)
 		free(luma);
 	if (chroma)
 		free(chroma);
-	return -1;
+	return rval;
 }
 
 static int save_me_luma_buffer(u8* output, struct iav_mebufdesc *me_desc)
@@ -701,8 +732,8 @@ static void get_me_size(struct iav_srcbuf_format *buf_format, int is_me1,
 
 static int capture_me(int buff_id, int count, int is_me1)
 {
-	int i, buf, save[MAX_SOURCE_BUFFER_NUM];
-	int write_flag[MAX_SOURCE_BUFFER_NUM];
+	int i, buf, save[IAV_SRCBUF_PMN];
+	int write_flag[IAV_SRCBUF_PMN];
 	char me_file[256];
 	int non_stop = 0;
 	u32 width, height;
@@ -713,6 +744,7 @@ static int capture_me(int buff_id, int count, int is_me1)
 	struct iav_srcbuf_format buf_format;
 	struct iav_me_cap *me_cap;
 	struct iav_mebufdesc *me_desc_ptr;
+	struct iav_system_resource resource;
 
 	luma = malloc(MAX_ME_BUFFER_SIZE);
 	if (luma == NULL) {
@@ -739,6 +771,14 @@ static int capture_me(int buff_id, int count, int is_me1)
 	if (is_me1) {
 		me_desc_ptr = &query_desc.arg.me1;
 	} else {
+		memset(&resource, 0, sizeof(resource));
+		resource.encode_mode = DSP_CURRENT_MODE;
+		ioctl(fd_iav, IAV_IOC_GET_SYSTEM_RESOURCE, &resource);
+		if (resource.me0_scale == 0) {
+			printf("Please turn me0 scale on first!\n");
+			goto me_error_exit;
+		}
+
 		me_desc_ptr = &query_desc.arg.me0;
 	}
 
@@ -915,7 +955,7 @@ static int capture_raw(void)
 			raw_desc->width, raw_desc->height, raw_desc->pitch);
 		goto raw_error_exit;
 	}
-	memcpy(raw_buffer, (u8 *)dsp_mem + raw_desc->raw_addr_offset, buffer_size);
+	memcpy(raw_buffer, (u8 *)base + raw_desc->raw_addr_offset, buffer_size);
 	if (amba_transfer_write(fd_raw, raw_buffer, buffer_size,
 		transfer_method) < 0) {
 		perror("Failed to save RAW data into file !\n");
@@ -976,7 +1016,7 @@ static const struct hint_s hint[] = {
 	{"",	"\tcapture me0 data from source buffer"},
 	{"",	"\tcapture raw data"},
 	{"?.yuv",	"filename to store output yuv"},
-	{"0|1|2|3|4",	"YUV420 data format for encode buffer, 0: IYUV(I420), 1: YV12, 2: NV12, 3:YU16, 4:YV16. Default is IYUV format"},
+	{"0~5",	"YUV420 data format for encode buffer, 0: IYUV(I420), 1: YV12, 2: NV12, 3:YU16, 4:YV16, 5:NV16. Default is IYUV format"},
 	{"",	"\tuse tcp to send data to PC"},
 	{"",	"\tuse usb to send data to PC"},
 	{"1~n",	"frame counts to capture"},
@@ -1022,9 +1062,9 @@ static void usage(void)
 		 "\t\tYYYYYYYYYYYYYYYYYYYYYYYYYYYY\n"
 		 "\t\tYYYYYYYYYYYYYYYYYYYYYYYYYYYY\n"
 		 "\t\tUVUVUVUVUVUVUV\n"
- 		 "\t\tUVUVUVUVUVUVUV\n"
-	 	 "\t\tUVUVUVUVUVUVUV\n"
- 	 	 "\t\tUVUVUVUVUVUVUV\n");
+		 "\t\tUVUVUVUVUVUVUV\n"
+		 "\t\tUVUVUVUVUVUVUV\n"
+		 "\t\tUVUVUVUVUVUVUV\n");
 
 	printf("\n\nThis program captures YUV buffer in YUV422 format for preview buffer, and save as YU16 or YV16.\n");
 	printf("  YU16 format (U and V are planar buffers) is like :\n"
@@ -1045,7 +1085,15 @@ static void usage(void)
 		 "\t\tVVVVVVVVVVVVVVVVVVVVVVVVVVVV\n"
 		 "\t\tUUUUUUUUUUUUUUUUUUUUUUUUUUUU\n"
 		 "\t\tUUUUUUUUUUUUUUUUUUUUUUUUUUUU\n");
-
+	printf("  NV16 format (U and V are interleaved buffers) is like :\n"
+		 "\t\tYYYYYYYYYYYYYYYYYYYYYYYYYYYY\n"
+		 "\t\tYYYYYYYYYYYYYYYYYYYYYYYYYYYY\n"
+		 "\t\tYYYYYYYYYYYYYYYYYYYYYYYYYYYY\n"
+		 "\t\tYYYYYYYYYYYYYYYYYYYYYYYYYYYY\n"
+		 "\t\tUVUVUVUVUVUVUVUVUVUVUVUVUVUV\n"
+		 "\t\tUVUVUVUVUVUVUVUVUVUVUVUVUVUV\n"
+		 "\t\tUVUVUVUVUVUVUVUVUVUVUVUVUVUV\n"
+		 "\t\tUVUVUVUVUVUVUVUVUVUVUVUVUVUV\n");
 
 	printf("\neg: To get one single preview frame of IYUV format\n");
 	printf("    > test_yuvcap -b 1 -Y -f 1.yuv -F 0 -r 1 --tcp\n\n");
@@ -1058,7 +1106,9 @@ static void usage(void)
 	printf("    To get continuous frames of me1 data as .yuv file\n");
 	printf("    > test_yuvcap -b 0 -m -b 1 -m -f 2.me1 -r 0 --tcp\n\n");
 	printf("    To get raw data from RGB sensor input, please enter \n");
-	printf("    > test_yuvcap -R -f cap_raw --tcp\n");
+	printf("    > test_yuvcap -R -f cap_raw --tcp\n\n");
+	printf("    To get 30 frames of yuv data as .yuv file of NV16 format\n");
+	printf("    > test_yuvcap -b 2 -Y -f 1.yuv -F 5 -r 30 --tcp\n");
 }
 
 static int init_param(int argc, char **argv)
diff --git a/iav_test/types.h b/iav_test/types.h
index 5beb2f1..6b41e6c 100644
--- a/iav_test/types.h
+++ b/iav_test/types.h
@@ -1,3 +1,34 @@
+/*
+ * types.c
+ *
+ * History:
+ *    2010/9/6 - [Louis Sun]
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #ifndef __TYPES_H
 #define __TYPES_H
diff --git a/idsp_test/arch_s2l/adj_container_map.c b/idsp_test/arch_s2l/adj_container_map.c
index e30a145..45e5410 100644
--- a/idsp_test/arch_s2l/adj_container_map.c
+++ b/idsp_test/arch_s2l/adj_container_map.c
@@ -1,4 +1,4 @@
-/**********************************************************************
+/*
  *
  * adj_container_map.c
  *
@@ -8,14 +8,31 @@
  * Description :
  *	Load the tuned file which generated by Img tuning tool.
  *
- * Copyright (C) 2012 - 2016, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- *********************************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 typedef enum {
 	MAP_TO_U32 = 0,
diff --git a/idsp_test/arch_s2l/ae_shutter_table.c b/idsp_test/arch_s2l/ae_shutter_table.c
index da65add..a1df45b 100644
--- a/idsp_test/arch_s2l/ae_shutter_table.c
+++ b/idsp_test/arch_s2l/ae_shutter_table.c
@@ -1,6 +1,38 @@
 /*
-	define shutter table 128 steps
-*/
+ *
+ * idsp_test
+ *
+ * History:
+ *	2015/09/10 - [Jingyang Qiu] Created this file
+ *
+ * Description :
+ *	Load the tuned file which generated by Img tuning tool.
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include "basetypes.h"
 #include "img_adv_struct_arch.h"
diff --git a/idsp_test/arch_s2l/ae_timing.c b/idsp_test/arch_s2l/ae_timing.c
index 32720bb..42f1a28 100644
--- a/idsp_test/arch_s2l/ae_timing.c
+++ b/idsp_test/arch_s2l/ae_timing.c
@@ -1,3 +1,39 @@
+/*
+ *
+ * idsp_test
+ *
+ * History:
+ *	2015/09/10 - [Jingyang Qiu] Created this file
+ *
+ * Description :
+ *	Load the tuned file which generated by Img tuning tool.
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
diff --git a/idsp_test/arch_s2l/cfg_dict.c b/idsp_test/arch_s2l/cfg_dict.c
index a9b8c84..1ddf246 100644
--- a/idsp_test/arch_s2l/cfg_dict.c
+++ b/idsp_test/arch_s2l/cfg_dict.c
@@ -1,3 +1,39 @@
+/*
+ *
+ * idsp_test
+ *
+ * History:
+ *	2015/09/10 - [Jingyang Qiu] Created this file
+ *
+ * Description :
+ *	Load the tuned file which generated by Img tuning tool.
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 //dict for vin
 
 //[0] is main key, followed by sub keys
diff --git a/idsp_test/arch_s2l/cfg_parser.c b/idsp_test/arch_s2l/cfg_parser.c
index a583088..93d9f73 100644
--- a/idsp_test/arch_s2l/cfg_parser.c
+++ b/idsp_test/arch_s2l/cfg_parser.c
@@ -1,3 +1,39 @@
+/*
+ *
+ * idsp_test
+ *
+ * History:
+ *	2015/09/10 - [Jingyang Qiu] Created this file
+ *
+ * Description :
+ *	Load the tuned file which generated by Img tuning tool.
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include <string.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -73,7 +109,7 @@ int cp_add_key(char* main_key, char* sub_key, char* value)
 	strcpy(pair[i].value, value);
 
 	return 0;
-	
+
 }
 
 int cp_get_key(char* main_key, char* sub_key, char* value)
@@ -131,7 +167,7 @@ int cp_parse_file(char* file_name)
 		memset(sk, 0, CP_CHAR_NUMBER);
 		memset(v, 0, CP_CHAR_NUMBER);
 		dot_pos = space_pos = -1;
-		
+
 		if(line[0]=='#' || line[0]=='\r' || line[0]=='\t' ||
 			line[0]=='\n' || line[0]==' ')
 			continue;
diff --git a/idsp_test/arch_s2l/cfg_parser.h b/idsp_test/arch_s2l/cfg_parser.h
index d04758b..93147e3 100644
--- a/idsp_test/arch_s2l/cfg_parser.h
+++ b/idsp_test/arch_s2l/cfg_parser.h
@@ -1,3 +1,39 @@
+/*
+ *
+ * idsp_test
+ *
+ * History:
+ *	2015/09/10 - [Jingyang Qiu] Created this file
+ *
+ * Description :
+ *	Load the tuned file which generated by Img tuning tool.
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #ifndef CFG_PARSER_H
 #define CFG_PARSER_H
 
diff --git a/idsp_test/arch_s2l/cfg_srv.c b/idsp_test/arch_s2l/cfg_srv.c
index e242ece..e536c13 100644
--- a/idsp_test/arch_s2l/cfg_srv.c
+++ b/idsp_test/arch_s2l/cfg_srv.c
@@ -1,3 +1,39 @@
+/*
+ *
+ * idsp_test
+ *
+ * History:
+ *	2015/09/10 - [Jingyang Qiu] Created this file
+ *
+ * Description :
+ *	Load the tuned file which generated by Img tuning tool.
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include <unistd.h>
 #include <fcntl.h>
 #include <stdio.h>
diff --git a/idsp_test/arch_s2l/cfg_srv.h b/idsp_test/arch_s2l/cfg_srv.h
index d48167f..3767a0f 100644
--- a/idsp_test/arch_s2l/cfg_srv.h
+++ b/idsp_test/arch_s2l/cfg_srv.h
@@ -1,3 +1,39 @@
+/*
+ *
+ * idsp_test
+ *
+ * History:
+ *	2015/09/10 - [Jingyang Qiu] Created this file
+ *
+ * Description :
+ *	Load the tuned file which generated by Img tuning tool.
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #ifndef CFG_SRV_H
 #define CFG_SRV_H
 
diff --git a/idsp_test/arch_s2l/customer_loop.c b/idsp_test/arch_s2l/customer_loop.c
index fc9e4df..a34eac4 100644
--- a/idsp_test/arch_s2l/customer_loop.c
+++ b/idsp_test/arch_s2l/customer_loop.c
@@ -1,3 +1,39 @@
+/*
+ *
+ * idsp_test
+ *
+ * History:
+ *	2015/09/10 - [Jingyang Qiu] Created this file
+ *
+ * Description :
+ *	Load the tuned file which generated by Img tuning tool.
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include <unistd.h>
 #include <fcntl.h>
 #include <stdio.h>
@@ -41,9 +77,15 @@
 #ifndef AWB_UNIT_GAIN
 #define AWB_UNIT_GAIN	1024
 #endif
+
 #ifndef ABS
 #define ABS(a)	   (((a) < 0) ? -(a) : (a))
 #endif
+
+#ifndef	DELAY_BUF_NUM
+#define	DELAY_BUF_NUM	(4)
+#endif
+
 #define ROUND_UP(size, align) (((size) + ((align) - 1)) & ~((align) - 1))
 static pthread_t nl_thread;
 static int fd_iav =-1;
@@ -53,13 +95,16 @@ static img_aaa_stat_t aaa_stat_info[MAX_HDR_EXPOSURE_NUM];
 static awb_gain_t awb_gain[MAX_HDR_EXPOSURE_NUM];
 static ae_output_t ae_output[MAX_HDR_EXPOSURE_NUM];
 static img_awb_param_t is_awb_param;
+static u32 cus_global_dgain=WB_DGAIN_UNIT;
 
 static struct rgb_aaa_stat rgb_stat[4];
 static struct cfa_aaa_stat cfa_stat[4];
 static struct cfa_pre_hdr_stat hdr_cfa_pre_stat[MAX_PRE_HDR_STAT_BLK_NUM];
+static u8 sensor_hist_stat[SENSOR_HIST_DATA_BLOCK];
 static u8 rgb_stat_valid;
 static u8 cfa_stat_valid;
 static u8 hdr_cfa_pre_valid;
+static u8 sensor_hist_valid;
 
 static aaa_tile_report_t act_tile;
 amba_img_dsp_ae_stat_info_t ae_tile_config;
@@ -69,12 +114,254 @@ static amba_img_dsp_hdr_stat_info_t hdr_stat_config;
 static amba_img_dsp_hist_stat_info_t hist_stat_config;
 
 static pthread_t id;
+static pthread_t cus_vin_id;
+pthread_mutex_t cus_aaa_mutex =PTHREAD_MUTEX_INITIALIZER;
 static img_config_info_t cus_work_info;
 static raw_offset_config_t cus_offset_cfg;
 static hdr_proc_data_t cus_hdr_proc_pipe;
 static u8 exit_flag =0;
+static u8 cus_vin_exit_flag = 0;
 static amba_img_dsp_tone_curve_t cus_dyn_tone;
+static amba_img_dsp_local_exposure_t cus_dyn_le;
+
+sensor_config_t cus_sensor_config_info;
+u32 cus_agc_step = 0;
+
 extern int coll_transmit_filter(void* filter, void* cmd, void* usr1, void* usr2);
+extern int hal_init_vin_tick();
+extern int hal_get_vin_tick();
+extern int hal_deinit_vin_tick();
+
+static void cus_set_sensor_hdr_cmd(int fd_iav, ae_output_t *ae_video)
+{
+	int i = 0, idx = 0;
+	u8 sht_update = 0;
+	u8 agc_update = 0;
+
+	hdr_sensor_gp_t sensor_gp;
+
+	hdr_shutter_gp_t cur_sht_gp;
+	hdr_shutter_gp_t next_sht_gp;
+	static hdr_shutter_gp_t sht_buf[DELAY_BUF_NUM];
+	u8 sht_dly[MAX_HDR_EXPOSURE_NUM] = {0};
+
+	hdr_gain_gp_t cur_agc_gp;
+	hdr_gain_gp_t next_agc_gp;
+	static hdr_gain_gp_t agc_buf[DELAY_BUF_NUM];
+	u8 agc_dly[MAX_HDR_EXPOSURE_NUM] = {0};
+
+	static u8 first_flag = 1;
+	u8 expo_num = cus_work_info.hdr_config.expo_num;
+	hdr_method_t hdr_method = cus_work_info.hdr_config.method;
+	sensor_config_t* p_sensor_cfg = &cus_sensor_config_info;
+
+	if(first_flag){
+		for(i = 0; i < DELAY_BUF_NUM; ++i){
+			for(idx = 0; idx < expo_num; ++idx){
+				sht_buf[i].shutter_info[idx] = 16;
+				agc_buf[i].gain_info[idx] = 65536;
+			}
+		}
+		first_flag = 0;
+	}
+	memset(&cur_sht_gp, 0, sizeof(cur_sht_gp));
+	memset(&next_sht_gp, 0, sizeof(next_sht_gp));
+	memset(&cur_agc_gp, 0, sizeof(cur_agc_gp));
+	memset(&next_agc_gp, 0, sizeof(next_agc_gp));
+
+	for(idx = 0; idx < expo_num; ++idx)
+		ae_video[idx].iris_update = 0;
+
+	for(idx = 0; idx < expo_num; ++idx){
+		if (ae_video[idx].shutter_index == 0) {
+			return;
+		}
+		/* next shutter, agc */
+		next_sht_gp.shutter_info[idx] = ae_video[idx].shutter_index;
+		ae_video[idx].shutter_update = 0;
+		next_agc_gp.gain_info[idx] = ae_video[idx].agc_index;
+		ae_video[idx].agc_update = 0;
+		/* shutter, agc delay */
+		sht_dly[idx] = p_sensor_cfg->hdr_delay.sht_delay.delay[idx];
+		agc_dly[idx] = p_sensor_cfg->hdr_delay.agc_delay.delay[idx];
+		/* fetch current sht, agc that have taken effect */
+		cur_sht_gp.shutter_info[idx] = sht_buf[sht_dly[idx]].shutter_info[idx];
+		cur_agc_gp.gain_info[idx] = agc_buf[agc_dly[idx]].gain_info[idx];
+	}
+
+	for(idx = 0; idx < expo_num; ++idx){
+		// save the next shutter to buffer
+		for(i = sht_dly[idx]; i > 0; -- i){
+			sht_buf[i].shutter_info[idx] = sht_buf[i - 1].shutter_info[idx];
+		}
+		sht_buf[0].shutter_info[idx] = next_sht_gp.shutter_info[idx];
+
+		// save the next agc to buffer
+		for(i = agc_dly[idx]; i > 0; -- i){
+			agc_buf[i].gain_info[idx] = agc_buf[i - 1].gain_info[idx];
+		}
+		agc_buf[0].gain_info[idx] = next_agc_gp.gain_info[idx];
+	}
+
+	// fetch next sht, agc that will be sent to sensor registers
+	for(idx = 0; idx < expo_num; ++ idx){
+		next_sht_gp.shutter_info[idx] = sht_buf[sht_dly[idx]].shutter_info[idx];
+		next_agc_gp.gain_info[idx] = agc_buf[agc_dly[idx]].gain_info[idx];
+
+		if(next_sht_gp.shutter_info[idx] != cur_sht_gp.shutter_info[idx]){
+			sht_update = 1;
+		}
+		if(next_agc_gp.gain_info[idx] != cur_agc_gp.gain_info[idx]){
+			agc_update = 1;
+		}
+	}
+
+	switch(hdr_method){
+		case HDR_RATIO_VARY_LINE_METHOD:
+		case HDR_RATIO_FIX_LINE_METHOD:
+		case HDR_DUAL_GAIN_METHOD:
+			if (sht_update || agc_update) {
+				sensor_gp.shutter_gp = next_sht_gp;
+				sensor_gp.agc_gp = next_agc_gp;
+				img_set_hdr_sensor_shutter_agc_group( fd_iav, &sensor_gp);
+			}
+			break;
+		default:
+			break;
+	}
+}
+
+void cus_set_wbgain_hdr_cmd(int fd_iav, amba_img_dsp_mode_cfg_t*  ik_mode, awb_gain_t* awb_gain)
+{
+	amba_img_dsp_wb_gain_t wb_only_dgain;
+
+	int idx = 0;
+	static u8 first_flag = 1;
+	u8 dgain_update = 0;
+	u16 cur_dgain;
+	u16 next_dgain;
+	static u16 dgain_buf[DELAY_BUF_NUM];
+	u8 dg_dly[MAX_HDR_EXPOSURE_NUM] = {0};
+	sensor_config_t* p_sensor_cfg = &cus_sensor_config_info;
+
+	u8 expo_num = cus_work_info.hdr_config.expo_num;
+
+	if(first_flag){
+		for(idx = 0; idx < DELAY_BUF_NUM; ++idx){
+			dgain_buf[idx] = 4096;
+		}
+		first_flag = 0;
+	}
+
+	for(idx = 0; idx < expo_num; ++idx){
+		// update flag
+		ae_output[idx].dgain_update = 0;
+		// hdr dgain delay
+		dg_dly[idx] = p_sensor_cfg->hdr_delay.dgain_delay.delay[idx];
+	}
+
+	cur_dgain = dgain_buf[dg_dly[0]];
+	next_dgain = ae_output[0].dgain;
+	for(idx = dg_dly[0]; idx > 0; --idx){
+		dgain_buf[idx] = dgain_buf[idx - 1];
+	}
+	dgain_buf[0] = next_dgain;
+
+	next_dgain = dgain_buf[dg_dly[0]];
+	if(cur_dgain != next_dgain){
+		dgain_update = 1;
+	}
+
+	if(dgain_update){
+		wb_only_dgain.GainR = 4096;
+		wb_only_dgain.GainG = 4096;
+		wb_only_dgain.GainB = 4096;
+		wb_only_dgain.AeGain = next_dgain;
+		wb_only_dgain.GlobalDGain = 4096;
+
+		amba_img_dsp_set_wb_gain( fd_iav, ik_mode, &wb_only_dgain);
+
+		cus_global_dgain = (wb_only_dgain.AeGain * wb_only_dgain.GlobalDGain) >> 12;
+		config_parser_dgain(cus_global_dgain);
+	}
+}
+
+void cus_vin_loop(void* arg)
+{
+	hdr_pipeline_t hdr_pipeline = cus_work_info.hdr_config.pipeline;
+
+	while (!cus_vin_exit_flag) {
+		if ( hdr_pipeline == HDR_PIPELINE_OFF) {
+			sleep(5);
+		} else {
+			hal_get_vin_tick();
+			pthread_mutex_lock (&cus_aaa_mutex);
+			cus_set_sensor_hdr_cmd(fd_iav, ae_output);
+			if (sync_hdr_raw_offset(ae_output, &cus_hdr_proc_pipe.raw_offset)) {
+				cus_hdr_proc_pipe.raw_offset_update = 1;
+			}
+			img_set_hdr_batch(fd_iav, &ik_mode, &cus_work_info, &cus_hdr_proc_pipe);
+			pthread_mutex_unlock (&cus_aaa_mutex);
+		}
+	}
+}
+
+void cus_ae_algo()
+{
+	static u8 frames_skip = 4;
+
+	hdr_pipeline_t hdr_pipeline = cus_work_info.hdr_config.pipeline;
+	u8 expo_num = cus_work_info.hdr_config.expo_num;
+	hdr_blend_info_t bld_info;
+	u16 expo_ratio = 0;
+	float sht_ratio = 0.0;
+	int i = 0;
+
+	if (frames_skip > 0) {
+		-- frames_skip;
+		return;
+	}
+
+	get_hdr_blend_config(&bld_info);
+	expo_ratio = bld_info.expo_ratio;
+	sht_ratio = (float)expo_ratio / HDR_EXPOSURE_RATIO_UNIT;
+
+	if (hdr_pipeline == HDR_PIPELINE_OFF) {
+		ae_output[0].shutter_index = 512;
+		ae_output[0].agc_index = 0;
+		ae_output[0].dgain = 4096;
+	} else {
+		if (ae_output[0].shutter_index > 63) {
+			ae_output[0].shutter_index -= 4;
+		} else {
+			ae_output[0].shutter_index = 1024;
+		}
+		ae_output[0].agc_index = 0;
+		ae_output[0].dgain = 4096;
+
+		for (i = 1; i < expo_num; ++ i) {
+			ae_output[i].shutter_index = (u32)((float)ae_output[i - 1].shutter_index / sht_ratio);
+			ae_output[i].agc_index = ae_output[i - 1].agc_index;
+			ae_output[i].dgain = \
+				(u32)((float)ae_output[0].shutter_index * ae_output[i - 1].dgain) / (ae_output[i].shutter_index * sht_ratio);
+		}
+
+		for (i = 0; i < expo_num; ++ i) {
+			ae_output[i].shutter_update = 1;
+			ae_output[i].agc_update = 1;
+			ae_output[i].dgain_update = 1;
+		}
+
+		for (i = 0; i < expo_num; ++ i) {
+			if (ae_output[i].shutter_update ||
+				ae_output[i].agc_update ||
+				ae_output[i].dgain_update ) {
+				frames_skip = 3;
+			}
+		}
+	}
+}
+
 void cus_main_loop(void* arg)
 {
 	int fd_iav;
@@ -83,6 +370,7 @@ void cus_main_loop(void* arg)
 	isp_pipeline_t isp_pipeline = cus_work_info.isp_pipeline;
 
 	int adj_index =0;
+	u32 g_dgain = 0;
 
 	/* enable dynamic tone curve control or not */
 	/*dynamic_tone_curve_enable(1);
@@ -100,46 +388,41 @@ void cus_main_loop(void* arg)
 			continue;
 		}
 
+		if (hdr_pipeline != HDR_PIPELINE_OFF) {
+			pthread_mutex_lock (&cus_aaa_mutex);
+		}
+
 		//*******awb algo********//
 		awb_flow_control(aaa_stat_info,awb_gain); //awb algo
-		static amba_img_dsp_wb_gain_t wb_gain={WB_DGAIN_UNIT,WB_DGAIN_UNIT,WB_DGAIN_UNIT,WB_DGAIN_UNIT,WB_DGAIN_UNIT};
+		static amba_img_dsp_wb_gain_t wb_gain= \
+			{WB_DGAIN_UNIT, WB_DGAIN_UNIT, WB_DGAIN_UNIT, WB_DGAIN_UNIT, WB_DGAIN_UNIT};
+
 		if(awb_gain[0].video_gain_update ==1){
-			if(hdr_pipeline == HDR_PIPELINE_OFF){
+			if (hdr_pipeline == HDR_PIPELINE_OFF) {
 				wb_gain.GainR =awb_gain[0].video_wb_gain.r_gain<<2; //dsp wb unit =4096, while wb algo is 1024
 				wb_gain.GainG =awb_gain[0].video_wb_gain.g_gain<<2;
 				wb_gain.GainB =awb_gain[0].video_wb_gain.b_gain<<2;
+				g_dgain =wb_gain.AeGain*wb_gain.GlobalDGain/WB_DGAIN_UNIT;
 				amba_img_dsp_set_wb_gain(fd_iav,&ik_mode,&wb_gain);
-				awb_gain->video_gain_update=0;
-			}else{
+				config_parser_dgain(g_dgain);
+				awb_gain[0].video_gain_update = 0;
+			} else {
 				// in HDR pipeline, wb gain are left to HDR block
 				wb_gain.GainR = WB_DGAIN_UNIT;
 				wb_gain.GainG = WB_DGAIN_UNIT;
 				wb_gain.GainB = WB_DGAIN_UNIT;
 				amba_img_dsp_set_wb_gain(fd_iav,&ik_mode,&wb_gain);
+				cus_set_wbgain_hdr_cmd(fd_iav, &ik_mode, awb_gain);
 			}
 		}
 
 		//*****ae_algo********//
-		//ae algo output gain_db and shutter_time
-		//adj_index = gain_db*128/6;//sensor gain table to 128 unit.
-
-	/*	int expo_id = 0;
-		if(hdr_pipeline == HDR_PIPELINE_OFF){
-			ae_output[0].shutter = ???;
-			ae_output[0].agc = ???;
-			ae_output[0].dgain = ???;
-		}else{
-			for(expo_id = 0; expo_id < expo_num; ++ expo_id){
-				ae_output[expo_id].shutter = ???;
-				ae_output[expo_id].agc = ???;
-				ae_output[expo_id].dgain = ???;
-			}
-		}	*/
+		cus_ae_algo();
+		adj_index = ((ae_output[0].agc_index * cus_agc_step / 6) >> 17) + 256;
 
 		img_runtime_adj(fd_iav, &ik_mode, adj_index, &awb_gain[0].video_wb_gain); //include all ISP filter but set_wb_gain
-		u32 g_dgain =wb_gain.AeGain*wb_gain.GlobalDGain/WB_DGAIN_UNIT;
-		config_parser_dgain(g_dgain);
 
+		/* auto color contrast */
 		if(dynamic_tone_curve_get_status()){
 			u8 tone_update = 0;
 			tone_update = dynamic_tone_curve_control(&cus_dyn_tone, &aaa_stat_info[0]);
@@ -149,16 +432,31 @@ void cus_main_loop(void* arg)
 				coll_transmit_filter((void*)&f_header, (void*)&cus_dyn_tone, (void *)fd_iav, (void*)&ik_mode);
 			}
 		}
+		/* LE based digital WDR */
+		if (light_optimise_get_enable()) {
+			u8 le_update = 0;
+			le_update = light_optimise_control(&cus_dyn_le, &aaa_stat_info[0]);
+			if (le_update) {
+				filter_header_t f_header;
+				f_header.filter_id = ADJ_LE;
+				coll_transmit_filter((void*)&f_header, (void*)&cus_dyn_le, (void *)fd_iav, (void*)&ik_mode);
+			}
+		}
+		/* HDR parameters calculation */
 		if(hdr_pipeline != HDR_PIPELINE_OFF){
 			hdr_proc_control(&cus_hdr_proc_pipe, awb_gain, ae_output);
-			img_set_hdr_batch(fd_iav, &ik_mode, &cus_work_info, &cus_hdr_proc_pipe);
 		}
 
 		if((isp_pipeline== ISP_PIPELINE_B_LISO ||isp_pipeline ==ISP_PIPELINE_ADV_LISO)) {
 			amba_img_dsp_post_exe_cfg(fd_iav, &ik_mode, AMBA_DSP_IMG_CFG_EXE_PARTIALCOPY, 0);
-			ik_mode.ConfigId ^= 1;
+			ik_mode.ConfigId++;
+			ik_mode.ConfigId%=4;
 			amba_img_dsp_post_exe_cfg(fd_iav, &ik_mode, AMBA_DSP_IMG_CFG_EXE_FULLCOPY, 0);
 		}
+
+		if (hdr_pipeline != HDR_PIPELINE_OFF) {
+			pthread_mutex_unlock (&cus_aaa_mutex);
+		}
 	}
 	awb_flow_deinit();
 }
@@ -170,6 +468,7 @@ int load_containers(char* sensor_name)
 	isp_pipeline_t isp_pipeline = cus_work_info.isp_pipeline;
 	hdr_pipeline_t hdr_pipeline = cus_work_info.hdr_config.pipeline;
 	u8 expo_num = cus_work_info.hdr_config.expo_num;
+
 	printf("mn34220pl\n");
 	if(isp_pipeline ==ISP_PIPELINE_LISO){
 		fcc.fc_ae_target = &mn34220pl_liso_fc_ae_target;
@@ -428,6 +727,7 @@ static int start_aaa_init(int fd_iav)
 	#define	PIXEL_IN_MB			(16)
 	hdr_blend_info_t cus_hdr_blend;
 	img_config_info_t* p_img_config = &cus_work_info;
+	int i = 0;
 	int sensor_id = 0x0;
 	struct vindev_video_info video_info;
 	struct iav_enc_mode_cap mode_cap;
@@ -467,7 +767,6 @@ static int start_aaa_init(int fd_iav)
 	p_img_config->hdr_config.pipeline = system_resource.hdr_type;
 	p_img_config->isp_pipeline = system_resource.iso_type;
 	p_img_config->raw_pitch =system_resource.raw_pitch_in_bytes;
-//	printf("expo_n %d,hdr pipe %d,isp pipe %d\n",p_img_config->hdr_config.expo_num,p_img_config->hdr_config.pipeline,p_img_config->isp_pipeline);
 
 	// source buffer setup
 	memset(&srcbuf_setup, 0, sizeof(srcbuf_setup));
@@ -486,7 +785,9 @@ static int start_aaa_init(int fd_iav)
 		perror("IAV_IOC_VIN_GET_AAAINFO error\n");
 		return -1;
 	}
+	cus_sensor_config_info = mn34220pl_aeb_sensor_config.sensor_config;
 
+	cus_agc_step = vin_aaa_info.agc_step;
 	p_img_config->raw_bayer = vin_aaa_info.bayer_pattern;
 	sensor_id = vin_aaa_info.sensor_id;
 	if(vin_aaa_info.dual_gain_mode){
@@ -542,17 +843,14 @@ static int start_aaa_init(int fd_iav)
 	amba_img_dsp_set_variable_range(&ik_mode, &dsp_variable_range);
 
 	// hdr sensor offsets configuration
-	cus_offset_cfg.offset_coef = mn34220pl_aeb_sensor_config.sensor_config.hdr_offset_coef;
+	cus_offset_cfg.offset_coef = cus_sensor_config_info.hdr_offset_coef;
 	cus_offset_cfg.offset_tbl.offset[0] = vin_aaa_info.hdr_long_offset;
 	cus_offset_cfg.offset_tbl.offset[1] = vin_aaa_info.hdr_short1_offset;
 	cus_offset_cfg.offset_tbl.offset[2] = vin_aaa_info.hdr_short2_offset;
 	cus_offset_cfg.offset_tbl.offset[3] = vin_aaa_info.hdr_short3_offset;
 	cus_offset_cfg.mode = \
 		(cus_offset_cfg.offset_coef.long_padding < 0 || cus_offset_cfg.offset_coef.short_padding < 0 )? 0 : 1;
-	cus_offset_cfg.offset_delay.delay[0] = 0;
-	cus_offset_cfg.offset_delay.delay[1] = 0;
-	cus_offset_cfg.offset_delay.delay[2] = 0;
-	cus_offset_cfg.offset_delay.delay[3] = 0;
+	cus_offset_cfg.offset_delay = cus_sensor_config_info.hdr_delay.offset_delay;
 
 	//  awb param
 	memcpy(&is_awb_param,&mn34220pl_aeb_wb_param.wb_param,sizeof(is_awb_param));
@@ -568,16 +866,31 @@ static int start_aaa_init(int fd_iav)
 	config_stat_tiles(&mn34220pl_aeb_tile_config.tile_config);
 	hdr_proc_init(p_img_config, &cus_offset_cfg, &cus_hdr_proc_pipe);
 
+
 	if(p_img_config->hdr_config.pipeline !=HDR_PIPELINE_OFF){
 		get_hdr_blend_config(&cus_hdr_blend);
-		cus_hdr_blend.expo_ratio = 32;	// set exposure ratio at initialization, 32x is an example
+		cus_hdr_blend.expo_ratio = 32 * HDR_EXPOSURE_RATIO_UNIT;	// set exposure ratio at initialization, 32x is an example
 		set_hdr_blend_config(&cus_hdr_blend);
 	}
+
+	for (i = 0; i < p_img_config->hdr_config.expo_num; ++ i) {
+		ae_output[i].shutter_index = \
+			(i == 0)? 1024 : ae_output[i - 1].shutter_index / 8;
+		ae_output[i].agc_index = 0;
+		ae_output[i].dgain = 4096;
+
+		awb_gain[i].video_wb_gain.r_gain = 1024;
+		awb_gain[i].video_wb_gain.g_gain = 1024;
+		awb_gain[i].video_wb_gain.b_gain = 1024;
+
+	}
 	return 0;
 }
+
 //////////////////////////////////////////////
 //img adj usage for cus_loop mode
 /////////////////////////////////////////////
+
 #if 0
 static void process_key(char key)//not work,just show how to use
 {
@@ -641,6 +954,19 @@ static void process_key(char key)//not work,just show how to use
 		dynamic_tone_curve_set_alpha(dynamic_alpha);
 		img_adj_reset_filter(ADJ_TONE);
 		break;
+	case 'C': // wdr enable
+		u8 enable = 0;	// or 1;
+		s8 mode = (enable)? -1 : 0;
+		light_optimise_set_enable(enable);
+		img_adj_set_filter_adj_argu(mode, ADJ_LE);
+		img_adj_pick_up_single_filter(&cus_dyn_le, sizeof(cus_dyn_le), ADJ_LE);
+		img_adj_reset_filter(ADJ_LE);
+		break;
+	case 'D'; // wdr strength
+		u8 strength =64;
+		light_optimise_set_strength(strength);
+		img_adj_reset_filter(ADJ_LE);
+		break;
         }
 }
 #endif
@@ -659,6 +985,13 @@ int check_iav_work(void)
 	return 0;
 }
 
+void wait_irq_count(int num)
+{
+	do {
+		ioctl(fd_iav, IAV_IOC_WAIT_NEXT_FRAME, 0);
+	} while (--num);
+}
+
 int do_init_netlink(void)
 {
 	init_netlink();
@@ -676,22 +1009,32 @@ int do_init_netlink(void)
 int do_start_aaa(void)
 {
 	printf("do_start_aaa\n");
+
+	hal_init_vin_tick();
+
 	hdr_pipeline_t hdr_pipeline = cus_work_info.hdr_config.pipeline;
 	isp_pipeline_t isp_pipeline = cus_work_info.isp_pipeline;
+	hdr_method_t	 hdr_method =cus_work_info.hdr_config.method;
 	//prepare for get 3A statistics
 	memset(rgb_stat, 0, sizeof(struct rgb_aaa_stat)*4);
 	memset(cfa_stat, 0, sizeof(struct cfa_aaa_stat)*4);
 	memset(hdr_cfa_pre_stat, 0, sizeof(struct cfa_pre_hdr_stat) * MAX_PRE_HDR_STAT_BLK_NUM);
+	memset(sensor_hist_stat, 0, SENSOR_HIST_DATA_BLOCK);
 	rgb_stat_valid = 0;
 	cfa_stat_valid = 0;
 	hdr_cfa_pre_valid = 0;
+	sensor_hist_valid =0;
+
 	memset(&g_stat, 0, sizeof(amba_dsp_aaa_statistic_data_t));
 	g_stat.CfaAaaDataAddr = (u32)cfa_stat;
 	g_stat.RgbAaaDataAddr = (u32)rgb_stat;
 	g_stat.CfaPreHdrDataAddr = (u32)hdr_cfa_pre_stat;
+	g_stat.SensorDataAddr = (hdr_method == HDR_BUILD_IN_METHOD)? (u32)sensor_hist_stat : 0;
+
 	g_stat.CfaDataValid = (u32)&cfa_stat_valid;
 	g_stat.RgbDataValid = (u32)&rgb_stat_valid;
 	g_stat.CfaPreHdrDataValid = (u32)&rgb_stat_valid;
+	g_stat.SensorDataValid = (hdr_method == HDR_BUILD_IN_METHOD)? (u32)&sensor_hist_valid : 0;
 	//end prepare
 	// the operations within brace must be done after entering preview
 	amba_img_dsp_3a_config_aaa_stat(fd_iav, 1, &ik_mode, &ae_tile_config, &awb_tile_config, &af_tile_config);
@@ -710,7 +1053,12 @@ int do_start_aaa(void)
 		img_adj_init_misc(fd_iav, &ik_mode,&cus_work_info);
 		img_adj_retrieve_filters(fd_iav, &ik_mode);
 	}
+	exit_flag = 0;
+	id = 0;
 	pthread_create(&id, NULL, (void*)cus_main_loop, (void*)fd_iav);
+	cus_vin_exit_flag = 0;
+	cus_vin_id = 0;
+	pthread_create(&cus_vin_id, NULL, (void*)cus_vin_loop, (void*)fd_iav);
 
 	return 0;
 }
@@ -743,8 +1091,15 @@ int do_prepare_aaa(void)
 }
 int do_stop_aaa(void)
 {
-	exit_flag =1;
-	pthread_join(id, NULL);
+	if (id != 0) {
+		exit_flag =1;
+		pthread_join(id, NULL);
+	}
+	if (cus_vin_id != 0) {
+		cus_vin_exit_flag = 1;
+		pthread_join(cus_vin_id, NULL);
+	}
+	hal_deinit_vin_tick();
 	if (img_lib_deinit() < 0) {
 		printf("img_lib_deinit error!\n");
 		return -1;
@@ -759,6 +1114,7 @@ int main(int argc, char **argv)
 		perror("open /dev/iav");
 		return -1;
 	}
+
 	sem_t sem;
 	if (do_init_netlink() < 0) {
 		return -1;
diff --git a/idsp_test/arch_s2l/idsp_netlink.c b/idsp_test/arch_s2l/idsp_netlink.c
index cfaa9ae..14620f5 100644
--- a/idsp_test/arch_s2l/idsp_netlink.c
+++ b/idsp_test/arch_s2l/idsp_netlink.c
@@ -1,18 +1,34 @@
-
-/*******************************************************************************
+/*
  * mw_netlink.c
  *
  * Histroy:
  *  2014/09/02 2014 - [jingyang qiu] created file
  *
- * Copyright (C) 2012 - 2016, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- ******************************************************************************/
+ */
 #include <unistd.h>
 #include <stdio.h>
 #include <stdlib.h>
diff --git a/idsp_test/arch_s2l/idsp_netlink.h b/idsp_test/arch_s2l/idsp_netlink.h
index dce00fd..30430b9 100644
--- a/idsp_test/arch_s2l/idsp_netlink.h
+++ b/idsp_test/arch_s2l/idsp_netlink.h
@@ -1,17 +1,34 @@
-/********************************************************************
+/*
  * idsp_netlink.h
  *
  * History:
  *	2014/09/25 - [Jing-yang Qiu] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- ********************************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 
 int init_netlink(void);
diff --git a/idsp_test/arch_s2l/load_param.c b/idsp_test/arch_s2l/load_param.c
index 7937db7..07a3279 100644
--- a/idsp_test/arch_s2l/load_param.c
+++ b/idsp_test/arch_s2l/load_param.c
@@ -1,3 +1,39 @@
+/*
+ *
+ * idsp_test
+ *
+ * History:
+ *	2015/09/10 - [Jingyang Qiu] Created this file
+ *
+ * Description :
+ *	Load the tuned file which generated by Img tuning tool.
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include <unistd.h>
 #include <fcntl.h>
 #include <stdio.h>
@@ -29,6 +65,11 @@
 #include "ov9715_mliso_adj_param.c"
 #include "ov9715_aeb_param.c"
 
+#include "ov2718_liso_adj_param.c"
+#include "ov2718_aliso_adj_param.c"
+#include "ov2718_mliso_adj_param.c"
+#include "ov2718_aeb_param.c"
+
 #include "ov9750_liso_adj_param.c"
 #include "ov9750_aliso_adj_param.c"
 #include "ov9750_mliso_adj_param.c"
@@ -38,6 +79,7 @@
 #include "ov4689_mliso_adj_param.c"
 #include "ov4689_mliso_adj_param_hdr.c"
 #include "ov4689_aliso_adj_param.c"
+#include "ov4689_bliso_adj_param.c"
 #include "ov4689_aeb_param.c"
 
 #include "ov5658_liso_adj_param.c"
@@ -45,6 +87,11 @@
 #include "ov5658_aliso_adj_param.c"
 #include "ov5658_aeb_param.c"
 
+#include "ov2735_liso_adj_param.c"
+#include "ov2735_mliso_adj_param.c"
+#include "ov2735_aliso_adj_param.c"
+#include "ov2735_aeb_param.c"
+
 #include "mn34220pl_liso_adj_param.c"
 #include "mn34220pl_mliso_adj_param.c"
 #include "mn34220pl_aliso_adj_param.c"
@@ -92,10 +139,28 @@
 #include "imx290_bliso_adj_param.c"
 #include "imx290_aeb_param.c"
 
+#include "imx185_liso_adj_param.c"
+#include "imx185_mliso_adj_param.c"
+#include "imx185_aliso_adj_param.c"
+#include "imx185_bliso_adj_param.c"
+#include "imx185_aeb_param.c"
+
 #include "imx322_liso_adj_param.c"
 #include "imx322_mliso_adj_param.c"
 #include "imx322_aliso_adj_param.c"
+#include "imx322_bliso_adj_param.c"
 #include "imx322_aeb_param.c"
+#include "imx326_liso_adj_param.c"
+#include "imx326_mliso_adj_param.c"
+#include "imx326_aliso_adj_param.c"
+#include "imx326_bliso_adj_param.c"
+#include "imx326_aeb_param.c"
+
+#include "imx377_liso_adj_param.c"
+#include "imx377_mliso_adj_param.c"
+#include "imx377_aliso_adj_param.c"
+#include "imx377_bliso_adj_param.c"
+#include "imx377_aeb_param.c"
 
 #include "ar0130_liso_adj_param.c"
 #include "ar0130_aliso_adj_param.c"
@@ -124,6 +189,10 @@
 #include "ar0237_bliso_adj_param.c"
 #include "ar0237_aeb_param.c"
 
+#include "ar0521_mliso_adj_param.c"
+#include "ar0521_aliso_adj_param.c"
+#include "ar0521_aeb_param.c"
+
 #include "m13vp288ir_piris_param.c"
 #include "mz128bp2810icr_piris_param.c"
 
@@ -205,6 +274,70 @@ int enable_cc(int fd_iav, char* sensor_name, amba_img_dsp_mode_cfg_t* ik_mode)
 	return 0;
 }
 
+int load_dynamic_expo_lines(int fd_iav,
+			struct vindev_aaa_info* vin_aaa_info,
+			img_config_info_t *p_img_cfg)
+{
+	line_t expo_lines[MAX_HDR_EXPOSURE_NUM * MAX_AE_LINES_NUM];
+	u16 line_num[MAX_HDR_EXPOSURE_NUM];
+	u16 line_belt[MAX_HDR_EXPOSURE_NUM];
+	u8 tbl_num = 0;
+	u8 total_line_num = 0;
+	int expo_id = 0;
+	img_aeb_expo_lines_t sensor_expo_lines;
+	u8 expo_num = p_img_cfg->hdr_config.expo_num;
+	hdr_mask_t hdr_mask = p_img_cfg->hdr_config.mask;
+
+	line_t *p_lines = NULL;
+
+	switch(vin_aaa_info->sensor_id) {
+		case SENSOR_IMX123:
+			if (expo_num == HDR_2X && hdr_mask ==MASK_FULL_HDR) {
+				sensor_expo_lines = imx123_aeb_expo_lines_2x_hdr;
+			} else if (expo_num == HDR_2X && hdr_mask ==MASK_LINEAR_IN_HDR) {
+				sensor_expo_lines = imx123_aeb_expo_lines_fake_linear_2x_hdr;
+			} else if (expo_num == HDR_3X && hdr_mask ==MASK_FULL_HDR) {
+				sensor_expo_lines = imx123_aeb_expo_lines_3x_hdr;
+			} else if (expo_num == HDR_3X && hdr_mask ==MASK_LINEAR_IN_HDR) {
+				sensor_expo_lines = imx123_aeb_expo_lines_fake_linear_3x_hdr;
+			} else {
+				sensor_expo_lines = imx123_aeb_expo_lines;
+			}
+			break;
+		case SENSOR_IMX290:
+		default:
+			if (expo_num == HDR_2X && hdr_mask ==MASK_FULL_HDR) {
+				sensor_expo_lines = imx290_aeb_expo_lines_2x_hdr;
+			} else if (expo_num == HDR_2X && hdr_mask ==MASK_LINEAR_IN_HDR) {
+				sensor_expo_lines = imx290_aeb_expo_lines_fake_linear_2x_hdr;
+			} else if (expo_num == HDR_3X && hdr_mask ==MASK_FULL_HDR) {
+				sensor_expo_lines = imx290_aeb_expo_lines_3x_hdr;
+			} else if (expo_num == HDR_3X && hdr_mask ==MASK_LINEAR_IN_HDR) {
+				sensor_expo_lines = imx290_aeb_expo_lines_fake_linear_3x_hdr;
+			} else {
+				sensor_expo_lines = imx290_aeb_expo_lines;
+			}
+			break;
+	}
+
+	tbl_num = sensor_expo_lines.header.total_tbl_num;
+	p_lines = &expo_lines[0];
+	total_line_num = 0;
+	for (expo_id = 0; expo_id < tbl_num; ++ expo_id) {
+		line_num[expo_id] = sensor_expo_lines.header.item_per_tbl[expo_id];
+		line_belt[expo_id] = sensor_expo_lines.header.item_per_tbl[expo_id];
+
+		memcpy(p_lines + total_line_num, sensor_expo_lines.expo_tables[expo_id].expo_lines,
+				line_num[expo_id] * sizeof(line_t));
+		total_line_num += line_num[expo_id];
+	}
+
+	img_format_ae_line(fd_iav, &expo_lines[0], total_line_num, vin_aaa_info->agc_step);
+	img_set_ae_exp_lines(&expo_lines[0], line_num, line_belt);
+
+	return 0;
+}
+
 int load_containers(u32 sensor_id,char* sensor_name, img_config_info_t *p_img_cfg)
 {
 	fc_collection_t fcc;
@@ -267,7 +400,7 @@ int load_containers(u32 sensor_id,char* sensor_name, img_config_info_t *p_img_cf
 				fcc.fc_demosaic = &mn34220pl_aliso_fc_demosaic;
 				fcc.fc_cc = &mn34220pl_aliso_fc_cc;
 				fcc.fc_tone = (hdr_pipeline == HDR_PIPELINE_OFF)? &mn34220pl_aliso_fc_tone : \
-					((expo_num = HDR_2X)? &mn34220pl_aliso_fc_2x_hdr_tone : &mn34220pl_aliso_fc_3x_hdr_tone);
+					((expo_num == HDR_2X)? &mn34220pl_aliso_fc_2x_hdr_tone : &mn34220pl_aliso_fc_3x_hdr_tone);
 				fcc.fc_rgb2yuv = &mn34220pl_aliso_fc_rgb2yuv;
 				fcc.fc_chroma_scale = &mn34220pl_aliso_fc_chroma_scale;
 				fcc.fc_chroma_median = &mn34220pl_aliso_fc_chroma_median;
@@ -347,11 +480,12 @@ int load_containers(u32 sensor_id,char* sensor_name, img_config_info_t *p_img_cf
 				fcc.fc_dpc = &mn34220pl_bliso_fc_dpc;
 				fcc.fc_cfanf_low = &mn34220pl_bliso_fc_cfanf;
 				fcc.fc_cfanf_high = NULL;
-				fcc.fc_le = &mn34220pl_bliso_le;
+				fcc.fc_le = (hdr_pipeline == HDR_PIPELINE_OFF)? &mn34220pl_bliso_fc_le : \
+					((expo_num == HDR_2X)? &mn34220pl_bliso_fc_2x_hdr_le : &mn34220pl_bliso_fc_3x_hdr_le);
 				fcc.fc_demosaic = &mn34220pl_bliso_fc_demosaic;
 				fcc.fc_cc = &mn34220pl_bliso_fc_cc;
 				fcc.fc_tone = (hdr_pipeline == HDR_PIPELINE_OFF)? &mn34220pl_bliso_fc_tone : \
-					((expo_num = HDR_2X)? &mn34220pl_bliso_fc_2x_hdr_tone : &mn34220pl_bliso_fc_3x_hdr_tone);
+					((expo_num == HDR_2X)? &mn34220pl_bliso_fc_2x_hdr_tone : &mn34220pl_bliso_fc_3x_hdr_tone);
 				fcc.fc_rgb2yuv = &mn34220pl_bliso_fc_rgb2yuv;
 				fcc.fc_chroma_scale = &mn34220pl_bliso_fc_chroma_scale;
 				fcc.fc_chroma_median = &mn34220pl_bliso_fc_chroma_median;
@@ -699,6 +833,131 @@ int load_containers(u32 sensor_id,char* sensor_name, img_config_info_t *p_img_cf
 				}
 			sprintf(sensor_name, "ov9750");
 			break;
+		case SENSOR_OV2718:
+			printf("ov2718\n");
+			if (isp_pipeline == ISP_PIPELINE_LISO) {
+				fcc.fc_ae_target = &ov2718_liso_fc_ae_target;
+				fcc.fc_wb_ratio = &ov2718_liso_fc_wb_ratio;
+				fcc.fc_blc = &ov2718_liso_fc_blc;
+				fcc.fc_antialiasing = &ov2718_liso_fc_antialiasing;
+				fcc.fc_grgbmismatch = &ov2718_liso_fc_grgbmismatch;
+				fcc.fc_dpc = &ov2718_liso_fc_dpc;
+				fcc.fc_cfanf_low = &ov2718_liso_fc_cfanf;
+				fcc.fc_cfanf_high = NULL;
+				fcc.fc_le = (hdr_pipeline == HDR_PIPELINE_OFF)? NULL : \
+					((expo_num == HDR_2X)? &ov2718_liso_fc_2x_hdr_le : &ov2718_liso_fc_3x_hdr_le);
+				fcc.fc_demosaic = &ov2718_liso_fc_demosaic;
+				fcc.fc_cc = &ov2718_liso_fc_cc;
+				fcc.fc_tone = (hdr_pipeline == HDR_PIPELINE_OFF)? &ov2718_liso_fc_tone : \
+					((expo_num == HDR_2X)? &ov2718_liso_fc_2x_hdr_tone : &ov2718_liso_fc_3x_hdr_tone);
+				fcc.fc_rgb2yuv = &ov2718_liso_fc_rgb2yuv;
+				fcc.fc_chroma_scale = &ov2718_liso_fc_chroma_scale;
+				fcc.fc_chroma_median = &ov2718_liso_fc_chroma_median;
+				fcc.fc_chroma_nf = &ov2718_liso_fc_chroma_nf;
+				fcc.fc_cdnr = &ov2718_liso_fc_cdnr;
+				fcc.fc_1stmode_sel = &ov2718_liso_fc_1stmode_sel;
+				fcc.fc_asf = &ov2718_liso_fc_asf;
+				fcc.fc_1st_shpboth = &ov2718_liso_fc_1st_shpboth;
+				fcc.fc_1st_shpnoise = &ov2718_liso_fc_1st_shpnoise;
+				fcc.fc_1st_shpfir = &ov2718_liso_fc_1st_shpfir;
+				fcc.fc_1st_shpcoring = &ov2718_liso_fc_1st_shpcoring;
+				fcc.fc_1st_shpcoring_idx_scale = &ov2718_liso_fc_1st_shpcoring_idx_scale;
+				fcc.fc_1st_shpcoring_min = &ov2718_liso_fc_1st_shpcoring_min;
+				fcc.fc_1st_shpcoring_scale_coring = &ov2718_liso_fc_1st_shpcoring_scale_coring;
+				fcc.fc_video_mctf = &ov2718_liso_fc_video_mctf;
+				fcc.fc_hdr_alpha = \
+					(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &ov2718_liso_fc_hdr_alpha;
+				fcc.fc_hdr_threshold = \
+					(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &ov2718_liso_fc_hdr_threshold;
+				fcc.fc_hdr_ce = \
+					(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &ov2718_liso_fc_hdr_ce;
+			} else if (isp_pipeline ==ISP_PIPELINE_ADV_LISO){
+				fcc.fc_ae_target = &ov2718_aliso_fc_ae_target;
+				fcc.fc_wb_ratio = &ov2718_aliso_fc_wb_ratio;
+				fcc.fc_blc = &ov2718_aliso_fc_blc;
+				fcc.fc_antialiasing = &ov2718_aliso_fc_antialiasing;
+				fcc.fc_grgbmismatch = &ov2718_aliso_fc_grgbmismatch;
+				fcc.fc_dpc = &ov2718_aliso_fc_dpc;
+				fcc.fc_cfanf_low = &ov2718_aliso_fc_cfanf;
+				fcc.fc_cfanf_high = NULL;
+				fcc.fc_le = (hdr_pipeline == HDR_PIPELINE_OFF)? NULL : \
+					((expo_num == HDR_2X)? &ov2718_aliso_fc_2x_hdr_le : &ov2718_aliso_fc_3x_hdr_le);
+				fcc.fc_demosaic = &ov2718_aliso_fc_demosaic;
+				fcc.fc_cc = &ov2718_aliso_fc_cc;
+				fcc.fc_tone = (hdr_pipeline == HDR_PIPELINE_OFF)? &ov2718_aliso_fc_tone : \
+					((expo_num == HDR_2X)? &ov2718_aliso_fc_2x_hdr_tone : &ov2718_aliso_fc_3x_hdr_tone);
+				fcc.fc_rgb2yuv = &ov2718_aliso_fc_rgb2yuv;
+				fcc.fc_chroma_scale = &ov2718_aliso_fc_chroma_scale;
+				fcc.fc_chroma_median = &ov2718_aliso_fc_chroma_median;
+				fcc.fc_chroma_nf = &ov2718_aliso_fc_chroma_nf;
+				fcc.fc_cdnr = &ov2718_aliso_fc_cdnr;
+				fcc.fc_1stmode_sel = &ov2718_aliso_fc_1stmode_sel;
+				fcc.fc_asf = &ov2718_aliso_fc_asf;
+				fcc.fc_1st_shpboth = &ov2718_aliso_fc_1st_shpboth;
+				fcc.fc_1st_shpnoise = &ov2718_aliso_fc_1st_shpnoise;
+				fcc.fc_1st_shpfir = &ov2718_aliso_fc_1st_shpfir;
+				fcc.fc_1st_shpcoring = &ov2718_aliso_fc_1st_shpcoring;
+				fcc.fc_1st_shpcoring_idx_scale = &ov2718_aliso_fc_1st_shpcoring_idx_scale;
+				fcc.fc_1st_shpcoring_min = &ov2718_aliso_fc_1st_shpcoring_min;
+				fcc.fc_1st_shpcoring_scale_coring = &ov2718_aliso_fc_1st_shpcoring_scale_coring;
+				fcc.fc_final_shpboth = &ov2718_aliso_fc_final_shpboth;
+				fcc.fc_final_shpnoise = &ov2718_aliso_fc_final_shpnoise;
+				fcc.fc_final_shpfir = &ov2718_aliso_fc_final_shpfir;
+				fcc.fc_final_shpcoring = &ov2718_aliso_fc_final_shpcoring;
+				fcc.fc_final_shpcoring_idx_scale = &ov2718_aliso_fc_final_shpcoring_idx_scale;
+				fcc.fc_final_shpcoring_min = &ov2718_aliso_fc_final_shpcoring_min;
+				fcc.fc_final_shpcoring_scale_coring = &ov2718_aliso_fc_final_shpcoring_scale_coring;
+				fcc.fc_wide_chroma_filter =&ov2718_aliso_fc_wide_chroma_filter;
+				fcc.fc_wide_chroma_filter_combine =&ov2718_aliso_fc_wide_chroma_filter_combine;
+				fcc.fc_video_mctf = &ov2718_aliso_fc_video_mctf;
+				fcc.fc_video_mctf_temporal_adjust =&ov2718_aliso_fc_video_mctf_temporal_adjust;
+				fcc.fc_hdr_alpha = \
+					(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &ov2718_aliso_fc_hdr_alpha;
+				fcc.fc_hdr_threshold = \
+					(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &ov2718_aliso_fc_hdr_threshold;
+				fcc.fc_hdr_ce = \
+					(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &ov2718_aliso_fc_hdr_ce;
+				}
+			else if(isp_pipeline ==ISP_PIPELINE_MID_LISO){
+				fcc.fc_ae_target = &ov2718_mliso_fc_ae_target;
+				fcc.fc_wb_ratio = &ov2718_mliso_fc_wb_ratio;
+				fcc.fc_blc = &ov2718_mliso_fc_blc;
+				fcc.fc_antialiasing = &ov2718_mliso_fc_antialiasing;
+				fcc.fc_grgbmismatch = &ov2718_mliso_fc_grgbmismatch;
+				fcc.fc_dpc = &ov2718_mliso_fc_dpc;
+				fcc.fc_cfanf_low = &ov2718_mliso_fc_cfanf;
+				fcc.fc_cfanf_high = NULL;
+				fcc.fc_le = (hdr_pipeline == HDR_PIPELINE_OFF)? NULL : \
+					((expo_num == HDR_2X)? &ov2718_mliso_fc_2x_hdr_le : &ov2718_mliso_fc_3x_hdr_le);
+				fcc.fc_demosaic = &ov2718_mliso_fc_demosaic;
+				fcc.fc_cc = &ov2718_mliso_fc_cc;
+				fcc.fc_tone = (hdr_pipeline == HDR_PIPELINE_OFF)? &ov2718_mliso_fc_tone : \
+					((expo_num == HDR_2X)? &ov2718_mliso_fc_2x_hdr_tone : &ov2718_mliso_fc_3x_hdr_tone);
+				fcc.fc_rgb2yuv = &ov2718_mliso_fc_rgb2yuv;
+				fcc.fc_chroma_scale = &ov2718_mliso_fc_chroma_scale;
+				fcc.fc_chroma_median = &ov2718_mliso_fc_chroma_median;
+				fcc.fc_chroma_nf = &ov2718_mliso_fc_chroma_nf;
+				fcc.fc_cdnr = &ov2718_mliso_fc_cdnr;
+				fcc.fc_1stmode_sel = &ov2718_mliso_fc_1stmode_sel;
+				fcc.fc_asf = &ov2718_mliso_fc_asf;
+				fcc.fc_1st_shpboth = &ov2718_mliso_fc_1st_shpboth;
+				fcc.fc_1st_shpnoise = &ov2718_mliso_fc_1st_shpnoise;
+				fcc.fc_1st_shpfir = &ov2718_mliso_fc_1st_shpfir;
+				fcc.fc_1st_shpcoring = &ov2718_mliso_fc_1st_shpcoring;
+				fcc.fc_1st_shpcoring_idx_scale = &ov2718_mliso_fc_1st_shpcoring_idx_scale;
+				fcc.fc_1st_shpcoring_min = &ov2718_mliso_fc_1st_shpcoring_min;
+				fcc.fc_1st_shpcoring_scale_coring = &ov2718_mliso_fc_1st_shpcoring_scale_coring;
+				fcc.fc_video_mctf = &ov2718_mliso_fc_video_mctf;
+				fcc.fc_video_mctf_temporal_adjust =&ov2718_mliso_fc_video_mctf_temporal_adjust;
+				fcc.fc_hdr_alpha = \
+					(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &ov2718_mliso_fc_hdr_alpha;
+				fcc.fc_hdr_threshold = \
+					(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &ov2718_mliso_fc_hdr_threshold;
+				fcc.fc_hdr_ce = \
+					(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &ov2718_mliso_fc_hdr_ce;
+				}
+			sprintf(sensor_name, "ov2718");
+			break;
 		case SENSOR_OV4689:
 			printf("ov4689\n");
 			if(isp_pipeline ==ISP_PIPELINE_LISO){
@@ -861,8 +1120,152 @@ int load_containers(u32 sensor_id,char* sensor_name, img_config_info_t *p_img_cf
 						(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &ov4689_mliso_fc_hdr_ce;
 					}
 				}
+			else if(isp_pipeline ==ISP_PIPELINE_B_LISO){
+				fcc.fc_ae_target = &ov4689_bliso_fc_ae_target;
+				fcc.fc_wb_ratio = &ov4689_bliso_fc_wb_ratio;
+				fcc.fc_blc = &ov4689_bliso_fc_blc;
+				fcc.fc_antialiasing = &ov4689_bliso_fc_antialiasing;
+				fcc.fc_grgbmismatch = &ov4689_bliso_fc_grgbmismatch;
+				fcc.fc_dpc = &ov4689_bliso_fc_dpc;
+				fcc.fc_cfanf_low = &ov4689_bliso_fc_cfanf;
+				fcc.fc_cfanf_high = NULL;
+				fcc.fc_le = (hdr_pipeline == HDR_PIPELINE_OFF)? &ov4689_bliso_fc_le : \
+					((expo_num == HDR_2X)? &ov4689_bliso_fc_2x_hdr_le : &ov4689_bliso_fc_3x_hdr_le);
+				fcc.fc_demosaic = &ov4689_bliso_fc_demosaic;
+				fcc.fc_cc = &ov4689_bliso_fc_cc;
+				fcc.fc_tone = (hdr_pipeline == HDR_PIPELINE_OFF)? &ov4689_bliso_fc_tone : \
+					((expo_num == HDR_2X)? &ov4689_bliso_fc_2x_hdr_tone : &ov4689_bliso_fc_3x_hdr_tone);
+				fcc.fc_rgb2yuv = &ov4689_bliso_fc_rgb2yuv;
+				fcc.fc_chroma_scale = &ov4689_bliso_fc_chroma_scale;
+				fcc.fc_chroma_median = &ov4689_bliso_fc_chroma_median;
+				fcc.fc_chroma_nf = &ov4689_bliso_fc_chroma_nf;
+				fcc.fc_1stmode_sel = &ov4689_bliso_fc_1stmode_sel;
+				fcc.fc_asf = &ov4689_bliso_fc_asf;
+				fcc.fc_1st_shpboth = &ov4689_bliso_fc_1st_shpboth;
+				fcc.fc_1st_shpnoise = &ov4689_bliso_fc_1st_shpnoise;
+				fcc.fc_1st_shpfir = &ov4689_bliso_fc_1st_shpfir;
+				fcc.fc_1st_shpcoring = &ov4689_bliso_fc_1st_shpcoring;
+				fcc.fc_1st_shpcoring_idx_scale = &ov4689_bliso_fc_1st_shpcoring_idx_scale;
+				fcc.fc_1st_shpcoring_min = &ov4689_bliso_fc_1st_shpcoring_min;
+				fcc.fc_1st_shpcoring_scale_coring = &ov4689_bliso_fc_1st_shpcoring_scale_coring;
+
+				fcc.fc_video_mctf = &ov4689_bliso_fc_video_mctf;
+				fcc.fc_video_mctf_temporal_adjust =&ov4689_bliso_fc_video_mctf_temporal_adjust;
+				fcc.fc_hdr_alpha = \
+					(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &ov4689_bliso_fc_hdr_alpha;
+				fcc.fc_hdr_threshold = \
+					(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &ov4689_bliso_fc_hdr_threshold;
+				fcc.fc_hdr_ce = \
+					(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &ov4689_bliso_fc_hdr_ce;
+				fcc.fc_mo_antialiasing = &ov4689_bliso_fc_mo_antialiasing;
+				fcc.fc_mo_grgbmismatch = &ov4689_bliso_fc_mo_grgbmismatch;
+				fcc.fc_mo_dpc = &ov4689_bliso_fc_mo_dpc;
+				fcc.fc_mo_cfanf = &ov4689_bliso_fc_mo_cfanf;
+				fcc.fc_mo_demosaic = &ov4689_bliso_fc_mo_demosaic;
+				fcc.fc_mo_chroma_median = &ov4689_bliso_fc_mo_chroma_median;
+				fcc.fc_mo_chroma_nf = &ov4689_bliso_fc_mo_chroma_nf;
+				fcc.fc_mo_1stmode_sel = &ov4689_bliso_fc_mo_1stmode_sel;
+				fcc.fc_mo_asf = &ov4689_bliso_fc_mo_asf;
+				fcc.fc_mo_1st_shpboth = &ov4689_bliso_fc_mo_1st_shpboth;
+				fcc.fc_mo_1st_shpnoise = &ov4689_bliso_fc_mo_1st_shpnoise;
+				fcc.fc_mo_1st_shpfir = &ov4689_bliso_fc_mo_1st_shpfir;
+				fcc.fc_mo_1st_shpcoring = &ov4689_bliso_fc_mo_1st_shpcoring;
+				fcc.fc_mo_1st_shpcoring_idx_scale = &ov4689_bliso_fc_mo_1st_shpcoring_idx_scale;
+				fcc.fc_mo_1st_shpcoring_min = &ov4689_bliso_fc_mo_1st_shpcoring_min;
+				fcc.fc_mo_1st_shpcoring_scale_coring = &ov4689_bliso_fc_mo_1st_shpcoring_scale_coring;
+				}
 			sprintf(sensor_name, "ov4689");
 			break;
+		case SENSOR_AR0521:
+			printf("ar0521\n");
+			if(isp_pipeline ==ISP_PIPELINE_ADV_LISO){
+				fcc.fc_ae_target = &ar0521_aliso_fc_ae_target;
+				fcc.fc_wb_ratio = &ar0521_aliso_fc_wb_ratio;
+				fcc.fc_blc = &ar0521_aliso_fc_blc;
+				fcc.fc_antialiasing = &ar0521_aliso_fc_antialiasing;
+				fcc.fc_grgbmismatch = &ar0521_aliso_fc_grgbmismatch;
+				fcc.fc_dpc = &ar0521_aliso_fc_dpc;
+				fcc.fc_cfanf_low = &ar0521_aliso_fc_cfanf;
+				fcc.fc_cfanf_high = NULL;
+				fcc.fc_le = (hdr_pipeline == HDR_PIPELINE_OFF)? NULL : \
+					((expo_num == HDR_2X)? &ar0521_aliso_fc_2x_hdr_le : &ar0521_aliso_fc_3x_hdr_le);
+				fcc.fc_demosaic = &ar0521_aliso_fc_demosaic;
+				fcc.fc_cc = &ar0521_aliso_fc_cc;
+				fcc.fc_tone = (hdr_pipeline == HDR_PIPELINE_OFF)? &ar0521_aliso_fc_tone : \
+					((expo_num == HDR_2X)? &ar0521_aliso_fc_2x_hdr_tone : &ar0521_aliso_fc_3x_hdr_tone);
+				fcc.fc_rgb2yuv = &ar0521_aliso_fc_rgb2yuv;
+				fcc.fc_chroma_scale = &ar0521_aliso_fc_chroma_scale;
+				fcc.fc_chroma_median = &ar0521_aliso_fc_chroma_median;
+				fcc.fc_chroma_nf = &ar0521_aliso_fc_chroma_nf;
+				fcc.fc_cdnr = &ar0521_aliso_fc_cdnr;
+				fcc.fc_1stmode_sel = &ar0521_aliso_fc_1stmode_sel;
+				fcc.fc_asf = &ar0521_aliso_fc_asf;
+				fcc.fc_1st_shpboth = &ar0521_aliso_fc_1st_shpboth;
+				fcc.fc_1st_shpnoise = &ar0521_aliso_fc_1st_shpnoise;
+				fcc.fc_1st_shpfir = &ar0521_aliso_fc_1st_shpfir;
+				fcc.fc_1st_shpcoring = &ar0521_aliso_fc_1st_shpcoring;
+				fcc.fc_1st_shpcoring_idx_scale = &ar0521_aliso_fc_1st_shpcoring_idx_scale;
+				fcc.fc_1st_shpcoring_min = &ar0521_aliso_fc_1st_shpcoring_min;
+				fcc.fc_1st_shpcoring_scale_coring = &ar0521_aliso_fc_1st_shpcoring_scale_coring;
+				fcc.fc_final_shpboth = &ar0521_aliso_fc_final_shpboth;
+				fcc.fc_final_shpnoise = &ar0521_aliso_fc_final_shpnoise;
+				fcc.fc_final_shpfir = &ar0521_aliso_fc_final_shpfir;
+				fcc.fc_final_shpcoring = &ar0521_aliso_fc_final_shpcoring;
+				fcc.fc_final_shpcoring_idx_scale = &ar0521_aliso_fc_final_shpcoring_idx_scale;
+				fcc.fc_final_shpcoring_min = &ar0521_aliso_fc_final_shpcoring_min;
+				fcc.fc_final_shpcoring_scale_coring = &ar0521_aliso_fc_final_shpcoring_scale_coring;
+				fcc.fc_wide_chroma_filter =&ar0521_aliso_fc_wide_chroma_filter;
+				fcc.fc_wide_chroma_filter_combine =&ar0521_aliso_fc_wide_chroma_filter_combine;
+				fcc.fc_video_mctf = &ar0521_aliso_fc_video_mctf;
+				fcc.fc_video_mctf_temporal_adjust =&ar0521_aliso_fc_video_mctf_temporal_adjust;
+				fcc.fc_hdr_alpha = \
+					(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &ar0521_aliso_fc_hdr_alpha;
+				fcc.fc_hdr_threshold = \
+					(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &ar0521_aliso_fc_hdr_threshold;
+				fcc.fc_hdr_ce = \
+					(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &ar0521_aliso_fc_hdr_ce;
+				}
+			else if(isp_pipeline ==ISP_PIPELINE_MID_LISO){
+					fcc.fc_ae_target = &ar0521_mliso_fc_ae_target;
+					fcc.fc_wb_ratio = &ar0521_mliso_fc_wb_ratio;
+					fcc.fc_blc = &ar0521_mliso_fc_blc;
+					fcc.fc_antialiasing = &ar0521_mliso_fc_antialiasing;
+					fcc.fc_grgbmismatch = &ar0521_mliso_fc_grgbmismatch;
+					fcc.fc_dpc = &ar0521_mliso_fc_dpc;
+					fcc.fc_cfanf_low = &ar0521_mliso_fc_cfanf;
+					fcc.fc_cfanf_high = NULL;
+					fcc.fc_le = (hdr_pipeline == HDR_PIPELINE_OFF)? NULL : \
+						((expo_num == HDR_2X)? &ar0521_mliso_fc_2x_hdr_le : &ar0521_mliso_fc_3x_hdr_le);
+					fcc.fc_demosaic = &ar0521_mliso_fc_demosaic;
+					fcc.fc_cc = &ar0521_mliso_fc_cc;
+					fcc.fc_tone = (hdr_pipeline == HDR_PIPELINE_OFF)? &ar0521_mliso_fc_tone : \
+						((expo_num == HDR_2X)? &ar0521_mliso_fc_2x_hdr_tone : &ar0521_mliso_fc_3x_hdr_tone);
+					fcc.fc_rgb2yuv = &ar0521_mliso_fc_rgb2yuv;
+					fcc.fc_chroma_scale = &ar0521_mliso_fc_chroma_scale;
+					fcc.fc_chroma_median = &ar0521_mliso_fc_chroma_median;
+					fcc.fc_chroma_nf = &ar0521_mliso_fc_chroma_nf;
+					fcc.fc_cdnr = &ar0521_mliso_fc_cdnr;
+					fcc.fc_1stmode_sel = &ar0521_mliso_fc_1stmode_sel;
+					fcc.fc_asf = &ar0521_mliso_fc_asf;
+					fcc.fc_1st_shpboth = &ar0521_mliso_fc_1st_shpboth;
+					fcc.fc_1st_shpnoise = &ar0521_mliso_fc_1st_shpnoise;
+					fcc.fc_1st_shpfir = &ar0521_mliso_fc_1st_shpfir;
+					fcc.fc_1st_shpcoring = &ar0521_mliso_fc_1st_shpcoring;
+					fcc.fc_1st_shpcoring_idx_scale = &ar0521_mliso_fc_1st_shpcoring_idx_scale;
+					fcc.fc_1st_shpcoring_min = &ar0521_mliso_fc_1st_shpcoring_min;
+					fcc.fc_1st_shpcoring_scale_coring = &ar0521_mliso_fc_1st_shpcoring_scale_coring;
+					fcc.fc_video_mctf = &ar0521_mliso_fc_video_mctf;
+					fcc.fc_video_mctf_temporal_adjust =&ar0521_mliso_fc_video_mctf_temporal_adjust;
+					fcc.fc_hdr_alpha = \
+						(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &ar0521_mliso_fc_hdr_alpha;
+					fcc.fc_hdr_threshold = \
+						(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &ar0521_mliso_fc_hdr_threshold;
+					fcc.fc_hdr_ce = \
+						(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &ar0521_mliso_fc_hdr_ce;
+					}
+			sprintf(sensor_name, "ar0521");
+			break;
+
 		case SENSOR_OV5658:
 			printf("ov5658\n");
 			if(isp_pipeline ==ISP_PIPELINE_LISO){
@@ -965,6 +1368,108 @@ int load_containers(u32 sensor_id,char* sensor_name, img_config_info_t *p_img_cf
 				}
 			sprintf(sensor_name, "ov5658");
 			break;
+		case SENSOR_OV2735:
+			printf("ov2735\n");
+			if(isp_pipeline ==ISP_PIPELINE_LISO){
+				fcc.fc_ae_target = &ov2735_liso_fc_ae_target;
+				fcc.fc_wb_ratio = &ov2735_liso_fc_wb_ratio;
+				fcc.fc_blc = &ov2735_liso_fc_blc;
+				fcc.fc_antialiasing = &ov2735_liso_fc_antialiasing;
+				fcc.fc_grgbmismatch = &ov2735_liso_fc_grgbmismatch;
+				fcc.fc_dpc = &ov2735_liso_fc_dpc;
+				fcc.fc_cfanf_low = &ov2735_liso_fc_cfanf;
+				fcc.fc_cfanf_high = NULL;
+				fcc.fc_le = NULL;
+				fcc.fc_demosaic = &ov2735_liso_fc_demosaic;
+				fcc.fc_cc = &ov2735_liso_fc_cc;
+				fcc.fc_tone =&ov2735_liso_fc_tone;
+				fcc.fc_rgb2yuv = &ov2735_liso_fc_rgb2yuv;
+				fcc.fc_chroma_scale = &ov2735_liso_fc_chroma_scale;
+				fcc.fc_chroma_median = &ov2735_liso_fc_chroma_median;
+				fcc.fc_chroma_nf = &ov2735_liso_fc_chroma_nf;
+				fcc.fc_cdnr = &ov2735_liso_fc_cdnr;
+				fcc.fc_1stmode_sel = &ov2735_liso_fc_1stmode_sel;
+				fcc.fc_asf = &ov2735_liso_fc_asf;
+				fcc.fc_1st_shpboth = &ov2735_liso_fc_1st_shpboth;
+				fcc.fc_1st_shpnoise = &ov2735_liso_fc_1st_shpnoise;
+				fcc.fc_1st_shpfir = &ov2735_liso_fc_1st_shpfir;
+				fcc.fc_1st_shpcoring = &ov2735_liso_fc_1st_shpcoring;
+				fcc.fc_1st_shpcoring_idx_scale = &ov2735_liso_fc_1st_shpcoring_idx_scale;
+				fcc.fc_1st_shpcoring_min = &ov2735_liso_fc_1st_shpcoring_min;
+				fcc.fc_1st_shpcoring_scale_coring = &ov2735_liso_fc_1st_shpcoring_scale_coring;
+				fcc.fc_video_mctf = &ov2735_liso_fc_video_mctf;
+				}
+			else if(isp_pipeline ==ISP_PIPELINE_ADV_LISO){
+				fcc.fc_ae_target = &ov2735_aliso_fc_ae_target;
+				fcc.fc_wb_ratio = &ov2735_aliso_fc_wb_ratio;
+				fcc.fc_blc = &ov2735_aliso_fc_blc;
+				fcc.fc_antialiasing = &ov2735_aliso_fc_antialiasing;
+				fcc.fc_grgbmismatch = &ov2735_aliso_fc_grgbmismatch;
+				fcc.fc_dpc = &ov2735_aliso_fc_dpc;
+				fcc.fc_cfanf_low = &ov2735_aliso_fc_cfanf;
+				fcc.fc_cfanf_high = NULL;
+				fcc.fc_le = NULL;
+				fcc.fc_demosaic = &ov2735_aliso_fc_demosaic;
+				fcc.fc_cc = &ov2735_aliso_fc_cc;
+				fcc.fc_tone = &ov2735_aliso_fc_tone;
+				fcc.fc_rgb2yuv = &ov2735_aliso_fc_rgb2yuv;
+				fcc.fc_chroma_scale = &ov2735_aliso_fc_chroma_scale;
+				fcc.fc_chroma_median = &ov2735_aliso_fc_chroma_median;
+				fcc.fc_chroma_nf = &ov2735_aliso_fc_chroma_nf;
+				fcc.fc_cdnr = &ov2735_aliso_fc_cdnr;
+				fcc.fc_1stmode_sel = &ov2735_aliso_fc_1stmode_sel;
+				fcc.fc_asf = &ov2735_aliso_fc_asf;
+				fcc.fc_1st_shpboth = &ov2735_aliso_fc_1st_shpboth;
+				fcc.fc_1st_shpnoise = &ov2735_aliso_fc_1st_shpnoise;
+				fcc.fc_1st_shpfir = &ov2735_aliso_fc_1st_shpfir;
+				fcc.fc_1st_shpcoring = &ov2735_aliso_fc_1st_shpcoring;
+				fcc.fc_1st_shpcoring_idx_scale = &ov2735_aliso_fc_1st_shpcoring_idx_scale;
+				fcc.fc_1st_shpcoring_min = &ov2735_aliso_fc_1st_shpcoring_min;
+				fcc.fc_1st_shpcoring_scale_coring = &ov2735_aliso_fc_1st_shpcoring_scale_coring;
+				fcc.fc_final_shpboth = &ov2735_aliso_fc_final_shpboth;
+				fcc.fc_final_shpnoise = &ov2735_aliso_fc_final_shpnoise;
+				fcc.fc_final_shpfir = &ov2735_aliso_fc_final_shpfir;
+				fcc.fc_final_shpcoring = &ov2735_aliso_fc_final_shpcoring;
+				fcc.fc_final_shpcoring_idx_scale = &ov2735_aliso_fc_final_shpcoring_idx_scale;
+				fcc.fc_final_shpcoring_min = &ov2735_aliso_fc_final_shpcoring_min;
+				fcc.fc_final_shpcoring_scale_coring = &ov2735_aliso_fc_final_shpcoring_scale_coring;
+				fcc.fc_wide_chroma_filter =&ov2735_aliso_fc_wide_chroma_filter;
+				fcc.fc_wide_chroma_filter_combine =&ov2735_aliso_fc_wide_chroma_filter_combine;
+				fcc.fc_video_mctf = &ov2735_aliso_fc_video_mctf;
+				fcc.fc_video_mctf_temporal_adjust =&ov2735_aliso_fc_video_mctf_temporal_adjust;
+				}
+			else if(isp_pipeline ==ISP_PIPELINE_MID_LISO){
+				fcc.fc_ae_target = &ov2735_mliso_fc_ae_target;
+				fcc.fc_wb_ratio = &ov2735_mliso_fc_wb_ratio;
+				fcc.fc_blc = &ov2735_mliso_fc_blc;
+				fcc.fc_antialiasing = &ov2735_mliso_fc_antialiasing;
+				fcc.fc_grgbmismatch = &ov2735_mliso_fc_grgbmismatch;
+				fcc.fc_dpc = &ov2735_mliso_fc_dpc;
+				fcc.fc_cfanf_low = &ov2735_mliso_fc_cfanf;
+				fcc.fc_cfanf_high = NULL;
+				fcc.fc_le = NULL;
+				fcc.fc_demosaic = &ov2735_mliso_fc_demosaic;
+				fcc.fc_cc = &ov2735_mliso_fc_cc;
+				fcc.fc_tone = &ov2735_mliso_fc_tone;
+				fcc.fc_rgb2yuv = &ov2735_mliso_fc_rgb2yuv;
+				fcc.fc_chroma_scale = &ov2735_mliso_fc_chroma_scale;
+				fcc.fc_chroma_median = &ov2735_mliso_fc_chroma_median;
+				fcc.fc_chroma_nf = &ov2735_mliso_fc_chroma_nf;
+				fcc.fc_cdnr = &ov2735_mliso_fc_cdnr;
+				fcc.fc_1stmode_sel = &ov2735_mliso_fc_1stmode_sel;
+				fcc.fc_asf = &ov2735_mliso_fc_asf;
+				fcc.fc_1st_shpboth = &ov2735_mliso_fc_1st_shpboth;
+				fcc.fc_1st_shpnoise = &ov2735_mliso_fc_1st_shpnoise;
+				fcc.fc_1st_shpfir = &ov2735_mliso_fc_1st_shpfir;
+				fcc.fc_1st_shpcoring = &ov2735_mliso_fc_1st_shpcoring;
+				fcc.fc_1st_shpcoring_idx_scale = &ov2735_mliso_fc_1st_shpcoring_idx_scale;
+				fcc.fc_1st_shpcoring_min = &ov2735_mliso_fc_1st_shpcoring_min;
+				fcc.fc_1st_shpcoring_scale_coring = &ov2735_mliso_fc_1st_shpcoring_scale_coring;
+				fcc.fc_video_mctf = &ov2735_mliso_fc_video_mctf;
+				fcc.fc_video_mctf_temporal_adjust =&ov2735_mliso_fc_video_mctf_temporal_adjust;
+				}
+			sprintf(sensor_name, "ov2735");
+			break;
 		case SENSOR_IMX123:
 			printf("imx123\n");
 			if(isp_pipeline ==ISP_PIPELINE_LISO){
@@ -1718,6 +2223,185 @@ int load_containers(u32 sensor_id,char* sensor_name, img_config_info_t *p_img_cf
 				}
 			sprintf(sensor_name, "imx291");
 			break;
+		case SENSOR_IMX185:
+			printf("imx185\n");
+			if(isp_pipeline ==ISP_PIPELINE_LISO){
+				fcc.fc_ae_target = &imx185_liso_fc_ae_target;
+				fcc.fc_wb_ratio = &imx185_liso_fc_wb_ratio;
+				fcc.fc_blc = &imx185_liso_fc_blc;
+				fcc.fc_antialiasing = &imx185_liso_fc_antialiasing;
+				fcc.fc_grgbmismatch = &imx185_liso_fc_grgbmismatch;
+				fcc.fc_dpc = &imx185_liso_fc_dpc;
+				fcc.fc_cfanf_low = &imx185_liso_fc_cfanf;
+				fcc.fc_cfanf_high = NULL;
+				fcc.fc_le = (hdr_pipeline == HDR_PIPELINE_OFF)? NULL : \
+					((expo_num == HDR_2X)? &imx185_liso_fc_2x_hdr_le : &imx185_liso_fc_3x_hdr_le);
+				fcc.fc_demosaic = &imx185_liso_fc_demosaic;
+				fcc.fc_cc = &imx185_liso_fc_cc;
+				fcc.fc_tone = (hdr_pipeline == HDR_PIPELINE_OFF)? &imx185_liso_fc_tone : \
+					((expo_num == HDR_2X)? &imx185_liso_fc_2x_hdr_tone : &imx185_liso_fc_3x_hdr_tone);
+				fcc.fc_rgb2yuv = &imx185_liso_fc_rgb2yuv;
+				fcc.fc_chroma_scale = &imx185_liso_fc_chroma_scale;
+				fcc.fc_chroma_median = &imx185_liso_fc_chroma_median;
+				fcc.fc_chroma_nf = &imx185_liso_fc_chroma_nf;
+				fcc.fc_cdnr = &imx185_liso_fc_cdnr;
+				fcc.fc_1stmode_sel = &imx185_liso_fc_1stmode_sel;
+				fcc.fc_asf = &imx185_liso_fc_asf;
+				fcc.fc_1st_shpboth = &imx185_liso_fc_1st_shpboth;
+				fcc.fc_1st_shpnoise = &imx185_liso_fc_1st_shpnoise;
+				fcc.fc_1st_shpfir = &imx185_liso_fc_1st_shpfir;
+				fcc.fc_1st_shpcoring = &imx185_liso_fc_1st_shpcoring;
+				fcc.fc_1st_shpcoring_idx_scale = &imx185_liso_fc_1st_shpcoring_idx_scale;
+				fcc.fc_1st_shpcoring_min = &imx185_liso_fc_1st_shpcoring_min;
+				fcc.fc_1st_shpcoring_scale_coring = &imx185_liso_fc_1st_shpcoring_scale_coring;
+				fcc.fc_video_mctf = &imx185_liso_fc_video_mctf;
+				fcc.fc_hdr_alpha = (hdr_pipeline == HDR_PIPELINE_OFF)? \
+					NULL : &imx185_liso_fc_hdr_alpha;
+				fcc.fc_hdr_threshold = (hdr_pipeline == HDR_PIPELINE_OFF)? \
+					NULL : &imx185_liso_fc_hdr_threshold;
+				fcc.fc_hdr_ce = (hdr_pipeline == HDR_PIPELINE_OFF)? \
+					NULL : &imx185_liso_fc_hdr_ce;
+				}
+			else if(isp_pipeline ==ISP_PIPELINE_ADV_LISO){
+				fcc.fc_ae_target = &imx185_aliso_fc_ae_target;
+				fcc.fc_wb_ratio = &imx185_aliso_fc_wb_ratio;
+				fcc.fc_blc = &imx185_aliso_fc_blc;
+				fcc.fc_antialiasing = &imx185_aliso_fc_antialiasing;
+				fcc.fc_grgbmismatch = &imx185_aliso_fc_grgbmismatch;
+				fcc.fc_dpc = &imx185_aliso_fc_dpc;
+				fcc.fc_cfanf_low = &imx185_aliso_fc_cfanf;
+				fcc.fc_cfanf_high = NULL;
+				fcc.fc_le = (hdr_pipeline == HDR_PIPELINE_OFF)? NULL : \
+					((expo_num == HDR_2X)? &imx185_aliso_fc_2x_hdr_le : &imx185_aliso_fc_3x_hdr_le);
+				fcc.fc_demosaic = &imx185_aliso_fc_demosaic;
+				fcc.fc_cc = &imx185_aliso_fc_cc;
+				fcc.fc_tone = (hdr_pipeline == HDR_PIPELINE_OFF)? &imx185_aliso_fc_tone : \
+					((expo_num == HDR_2X)? &imx185_aliso_fc_2x_hdr_tone : &imx185_aliso_fc_3x_hdr_tone);
+				fcc.fc_rgb2yuv = &imx185_aliso_fc_rgb2yuv;
+				fcc.fc_chroma_scale = &imx185_aliso_fc_chroma_scale;
+				fcc.fc_chroma_median = &imx185_aliso_fc_chroma_median;
+				fcc.fc_chroma_nf = &imx185_aliso_fc_chroma_nf;
+				fcc.fc_cdnr = &imx185_aliso_fc_cdnr;
+				fcc.fc_1stmode_sel = &imx185_aliso_fc_1stmode_sel;
+				fcc.fc_asf = &imx185_aliso_fc_asf;
+				fcc.fc_1st_shpboth = &imx185_aliso_fc_1st_shpboth;
+				fcc.fc_1st_shpnoise = &imx185_aliso_fc_1st_shpnoise;
+				fcc.fc_1st_shpfir = &imx185_aliso_fc_1st_shpfir;
+				fcc.fc_1st_shpcoring = &imx185_aliso_fc_1st_shpcoring;
+				fcc.fc_1st_shpcoring_idx_scale = &imx185_aliso_fc_1st_shpcoring_idx_scale;
+				fcc.fc_1st_shpcoring_min = &imx185_aliso_fc_1st_shpcoring_min;
+				fcc.fc_1st_shpcoring_scale_coring = &imx185_aliso_fc_1st_shpcoring_scale_coring;
+				fcc.fc_final_shpboth = &imx185_aliso_fc_final_shpboth;
+				fcc.fc_final_shpnoise = &imx185_aliso_fc_final_shpnoise;
+				fcc.fc_final_shpfir = &imx185_aliso_fc_final_shpfir;
+				fcc.fc_final_shpcoring = &imx185_aliso_fc_final_shpcoring;
+				fcc.fc_final_shpcoring_idx_scale = &imx185_aliso_fc_final_shpcoring_idx_scale;
+				fcc.fc_final_shpcoring_min = &imx185_aliso_fc_final_shpcoring_min;
+				fcc.fc_final_shpcoring_scale_coring = &imx185_aliso_fc_final_shpcoring_scale_coring;
+				fcc.fc_wide_chroma_filter =&imx185_aliso_fc_wide_chroma_filter;
+				fcc.fc_wide_chroma_filter_combine =&imx185_aliso_fc_wide_chroma_filter_combine;
+				fcc.fc_video_mctf = &imx185_aliso_fc_video_mctf;
+				fcc.fc_video_mctf_temporal_adjust =&imx185_aliso_fc_video_mctf_temporal_adjust;
+				fcc.fc_hdr_alpha = (hdr_pipeline == HDR_PIPELINE_OFF)? \
+					NULL : &imx185_aliso_fc_hdr_alpha;
+				fcc.fc_hdr_threshold = (hdr_pipeline == HDR_PIPELINE_OFF)? \
+					NULL : &imx185_aliso_fc_hdr_threshold;
+				fcc.fc_hdr_ce = (hdr_pipeline == HDR_PIPELINE_OFF)? \
+					NULL : &imx185_aliso_fc_hdr_ce;
+				}
+			else if(isp_pipeline ==ISP_PIPELINE_MID_LISO){
+				fcc.fc_ae_target = &imx185_mliso_fc_ae_target;
+				fcc.fc_wb_ratio = &imx185_mliso_fc_wb_ratio;
+				fcc.fc_blc = &imx185_mliso_fc_blc;
+				fcc.fc_antialiasing = &imx185_mliso_fc_antialiasing;
+				fcc.fc_grgbmismatch = &imx185_mliso_fc_grgbmismatch;
+				fcc.fc_dpc = &imx185_mliso_fc_dpc;
+				fcc.fc_cfanf_low = &imx185_mliso_fc_cfanf;
+				fcc.fc_cfanf_high = NULL;
+				fcc.fc_le = (hdr_pipeline == HDR_PIPELINE_OFF)? NULL : \
+					((expo_num == HDR_2X)? &imx185_mliso_fc_2x_hdr_le : &imx185_mliso_fc_3x_hdr_le);
+				fcc.fc_demosaic = &imx185_mliso_fc_demosaic;
+				fcc.fc_cc = &imx185_mliso_fc_cc;
+				fcc.fc_tone = (hdr_pipeline == HDR_PIPELINE_OFF)? &imx185_mliso_fc_tone : \
+					((expo_num == HDR_2X)? &imx185_mliso_fc_2x_hdr_tone : &imx185_mliso_fc_3x_hdr_tone);
+				fcc.fc_rgb2yuv = &imx185_mliso_fc_rgb2yuv;
+				fcc.fc_chroma_scale = &imx185_mliso_fc_chroma_scale;
+				fcc.fc_chroma_median = &imx185_mliso_fc_chroma_median;
+				fcc.fc_chroma_nf = &imx185_mliso_fc_chroma_nf;
+				fcc.fc_cdnr = &imx185_mliso_fc_cdnr;
+				fcc.fc_1stmode_sel = &imx185_mliso_fc_1stmode_sel;
+				fcc.fc_asf = &imx185_mliso_fc_asf;
+				fcc.fc_1st_shpboth = &imx185_mliso_fc_1st_shpboth;
+				fcc.fc_1st_shpnoise = &imx185_mliso_fc_1st_shpnoise;
+				fcc.fc_1st_shpfir = &imx185_mliso_fc_1st_shpfir;
+				fcc.fc_1st_shpcoring = &imx185_mliso_fc_1st_shpcoring;
+				fcc.fc_1st_shpcoring_idx_scale = &imx185_mliso_fc_1st_shpcoring_idx_scale;
+				fcc.fc_1st_shpcoring_min = &imx185_mliso_fc_1st_shpcoring_min;
+				fcc.fc_1st_shpcoring_scale_coring = &imx185_mliso_fc_1st_shpcoring_scale_coring;
+				fcc.fc_video_mctf = &imx185_mliso_fc_video_mctf;
+				fcc.fc_video_mctf_temporal_adjust =&imx185_mliso_fc_video_mctf_temporal_adjust;
+				fcc.fc_hdr_alpha = (hdr_pipeline == HDR_PIPELINE_OFF)? \
+					NULL : &imx185_mliso_fc_hdr_alpha;
+				fcc.fc_hdr_threshold = (hdr_pipeline == HDR_PIPELINE_OFF)? \
+					NULL : &imx185_mliso_fc_hdr_threshold;
+				fcc.fc_hdr_ce = (hdr_pipeline == HDR_PIPELINE_OFF)? \
+					NULL : &imx185_mliso_fc_hdr_ce;
+				}
+			else if(isp_pipeline ==ISP_PIPELINE_B_LISO){
+				fcc.fc_ae_target = &imx185_bliso_fc_ae_target;
+				fcc.fc_wb_ratio = &imx185_bliso_fc_wb_ratio;
+				fcc.fc_blc = &imx185_bliso_fc_blc;
+				fcc.fc_antialiasing = &imx185_bliso_fc_antialiasing;
+				fcc.fc_grgbmismatch = &imx185_bliso_fc_grgbmismatch;
+				fcc.fc_dpc = &imx185_bliso_fc_dpc;
+				fcc.fc_cfanf_low = &imx185_bliso_fc_cfanf;
+				fcc.fc_cfanf_high = NULL;
+				fcc.fc_le = &imx185_bliso_le;
+				fcc.fc_demosaic = &imx185_bliso_fc_demosaic;
+				fcc.fc_cc = &imx185_bliso_fc_cc;
+				fcc.fc_tone = (hdr_pipeline == HDR_PIPELINE_OFF)? &imx185_bliso_fc_tone : \
+					((expo_num == HDR_2X)? &imx185_bliso_fc_2x_hdr_tone : &imx185_bliso_fc_3x_hdr_tone);
+				fcc.fc_rgb2yuv = &imx185_bliso_fc_rgb2yuv;
+				fcc.fc_chroma_scale = &imx185_bliso_fc_chroma_scale;
+				fcc.fc_chroma_median = &imx185_bliso_fc_chroma_median;
+				fcc.fc_chroma_nf = &imx185_bliso_fc_chroma_nf;
+				fcc.fc_1stmode_sel = &imx185_bliso_fc_1stmode_sel;
+				fcc.fc_asf = &imx185_bliso_fc_asf;
+				fcc.fc_1st_shpboth = &imx185_bliso_fc_1st_shpboth;
+				fcc.fc_1st_shpnoise = &imx185_bliso_fc_1st_shpnoise;
+				fcc.fc_1st_shpfir = &imx185_bliso_fc_1st_shpfir;
+				fcc.fc_1st_shpcoring = &imx185_bliso_fc_1st_shpcoring;
+				fcc.fc_1st_shpcoring_idx_scale = &imx185_bliso_fc_1st_shpcoring_idx_scale;
+				fcc.fc_1st_shpcoring_min = &imx185_bliso_fc_1st_shpcoring_min;
+				fcc.fc_1st_shpcoring_scale_coring = &imx185_bliso_fc_1st_shpcoring_scale_coring;
+
+				fcc.fc_video_mctf = &imx185_bliso_fc_video_mctf;
+				fcc.fc_video_mctf_temporal_adjust =&imx185_bliso_fc_video_mctf_temporal_adjust;
+				fcc.fc_hdr_alpha = \
+					(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &imx185_bliso_fc_hdr_alpha;
+				fcc.fc_hdr_threshold = \
+					(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &imx185_bliso_fc_hdr_threshold;
+				fcc.fc_hdr_ce = \
+					(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &imx185_bliso_fc_hdr_ce;
+				fcc.fc_mo_antialiasing = &imx185_bliso_fc_mo_antialiasing;
+				fcc.fc_mo_grgbmismatch = &imx185_bliso_fc_mo_grgbmismatch;
+				fcc.fc_mo_dpc = &imx185_bliso_fc_mo_dpc;
+				fcc.fc_mo_cfanf = &imx185_bliso_fc_mo_cfanf;
+				fcc.fc_mo_demosaic = &imx185_bliso_fc_mo_demosaic;
+				fcc.fc_mo_chroma_median = &imx185_bliso_fc_mo_chroma_median;
+				fcc.fc_mo_chroma_nf = &imx185_bliso_fc_mo_chroma_nf;
+				fcc.fc_mo_1stmode_sel = &imx185_bliso_fc_mo_1stmode_sel;
+				fcc.fc_mo_asf = &imx185_bliso_fc_mo_asf;
+				fcc.fc_mo_1st_shpboth = &imx185_bliso_fc_mo_1st_shpboth;
+				fcc.fc_mo_1st_shpnoise = &imx185_bliso_fc_mo_1st_shpnoise;
+				fcc.fc_mo_1st_shpfir = &imx185_bliso_fc_mo_1st_shpfir;
+				fcc.fc_mo_1st_shpcoring = &imx185_bliso_fc_mo_1st_shpcoring;
+				fcc.fc_mo_1st_shpcoring_idx_scale = &imx185_bliso_fc_mo_1st_shpcoring_idx_scale;
+				fcc.fc_mo_1st_shpcoring_min = &imx185_bliso_fc_mo_1st_shpcoring_min;
+				fcc.fc_mo_1st_shpcoring_scale_coring = &imx185_bliso_fc_mo_1st_shpcoring_scale_coring;
+				}
+			sprintf(sensor_name, "imx185");
+			break;
 		case SENSOR_IMX290:
 			printf("imx290\n");
 			if(isp_pipeline ==ISP_PIPELINE_LISO){
@@ -1855,7 +2539,7 @@ int load_containers(u32 sensor_id,char* sensor_name, img_config_info_t *p_img_cf
 				fcc.fc_demosaic = &imx290_bliso_fc_demosaic;
 				fcc.fc_cc = &imx290_bliso_fc_cc;
 				fcc.fc_tone = (hdr_pipeline == HDR_PIPELINE_OFF)? &imx290_bliso_fc_tone : \
-					((expo_num = HDR_2X)? &imx290_bliso_fc_2x_hdr_tone : &imx290_bliso_fc_3x_hdr_tone);
+					((expo_num == HDR_2X)? &imx290_bliso_fc_2x_hdr_tone : &imx290_bliso_fc_3x_hdr_tone);
 				fcc.fc_rgb2yuv = &imx290_bliso_fc_rgb2yuv;
 				fcc.fc_chroma_scale = &imx290_bliso_fc_chroma_scale;
 				fcc.fc_chroma_median = &imx290_bliso_fc_chroma_median;
@@ -1997,8 +2681,419 @@ int load_containers(u32 sensor_id,char* sensor_name, img_config_info_t *p_img_cf
 				fcc.fc_video_mctf = &imx322_mliso_fc_video_mctf;
 				fcc.fc_video_mctf_temporal_adjust =&imx322_mliso_fc_video_mctf_temporal_adjust;
 				}
+			else if(isp_pipeline ==ISP_PIPELINE_B_LISO){
+				fcc.fc_ae_target = &imx322_bliso_fc_ae_target;
+				fcc.fc_wb_ratio = &imx322_bliso_fc_wb_ratio;
+				fcc.fc_blc = &imx322_bliso_fc_blc;
+				fcc.fc_antialiasing = &imx322_bliso_fc_antialiasing;
+				fcc.fc_grgbmismatch = &imx322_bliso_fc_grgbmismatch;
+				fcc.fc_dpc = &imx322_bliso_fc_dpc;
+				fcc.fc_cfanf_low = &imx322_bliso_fc_cfanf;
+				fcc.fc_cfanf_high = NULL;
+				fcc.fc_le = &imx322_bliso_le;
+				fcc.fc_demosaic = &imx322_bliso_fc_demosaic;
+				fcc.fc_cc = &imx322_bliso_fc_cc;
+				fcc.fc_tone = (hdr_pipeline == HDR_PIPELINE_OFF)? &imx322_bliso_fc_tone : \
+					((expo_num == HDR_2X)? &imx322_bliso_fc_2x_hdr_tone : &imx322_bliso_fc_3x_hdr_tone);
+				fcc.fc_rgb2yuv = &imx322_bliso_fc_rgb2yuv;
+				fcc.fc_chroma_scale = &imx322_bliso_fc_chroma_scale;
+				fcc.fc_chroma_median = &imx322_bliso_fc_chroma_median;
+				fcc.fc_chroma_nf = &imx322_bliso_fc_chroma_nf;
+				fcc.fc_1stmode_sel = &imx322_bliso_fc_1stmode_sel;
+				fcc.fc_asf = &imx322_bliso_fc_asf;
+				fcc.fc_1st_shpboth = &imx322_bliso_fc_1st_shpboth;
+				fcc.fc_1st_shpnoise = &imx322_bliso_fc_1st_shpnoise;
+				fcc.fc_1st_shpfir = &imx322_bliso_fc_1st_shpfir;
+				fcc.fc_1st_shpcoring = &imx322_bliso_fc_1st_shpcoring;
+				fcc.fc_1st_shpcoring_idx_scale = &imx322_bliso_fc_1st_shpcoring_idx_scale;
+				fcc.fc_1st_shpcoring_min = &imx322_bliso_fc_1st_shpcoring_min;
+				fcc.fc_1st_shpcoring_scale_coring = &imx322_bliso_fc_1st_shpcoring_scale_coring;
+
+				fcc.fc_video_mctf = &imx322_bliso_fc_video_mctf;
+				fcc.fc_video_mctf_temporal_adjust =&imx322_bliso_fc_video_mctf_temporal_adjust;
+				fcc.fc_hdr_alpha = \
+					(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &imx322_bliso_fc_hdr_alpha;
+				fcc.fc_hdr_threshold = \
+					(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &imx322_bliso_fc_hdr_threshold;
+				fcc.fc_hdr_ce = \
+					(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &imx322_bliso_fc_hdr_ce;
+				fcc.fc_mo_antialiasing = &imx322_bliso_fc_mo_antialiasing;
+				fcc.fc_mo_grgbmismatch = &imx322_bliso_fc_mo_grgbmismatch;
+				fcc.fc_mo_dpc = &imx322_bliso_fc_mo_dpc;
+				fcc.fc_mo_cfanf = &imx322_bliso_fc_mo_cfanf;
+				fcc.fc_mo_demosaic = &imx322_bliso_fc_mo_demosaic;
+				fcc.fc_mo_chroma_median = &imx322_bliso_fc_mo_chroma_median;
+				fcc.fc_mo_chroma_nf = &imx322_bliso_fc_mo_chroma_nf;
+				fcc.fc_mo_1stmode_sel = &imx322_bliso_fc_mo_1stmode_sel;
+				fcc.fc_mo_asf = &imx322_bliso_fc_mo_asf;
+				fcc.fc_mo_1st_shpboth = &imx322_bliso_fc_mo_1st_shpboth;
+				fcc.fc_mo_1st_shpnoise = &imx322_bliso_fc_mo_1st_shpnoise;
+				fcc.fc_mo_1st_shpfir = &imx322_bliso_fc_mo_1st_shpfir;
+				fcc.fc_mo_1st_shpcoring = &imx322_bliso_fc_mo_1st_shpcoring;
+				fcc.fc_mo_1st_shpcoring_idx_scale = &imx322_bliso_fc_mo_1st_shpcoring_idx_scale;
+				fcc.fc_mo_1st_shpcoring_min = &imx322_bliso_fc_mo_1st_shpcoring_min;
+				fcc.fc_mo_1st_shpcoring_scale_coring = &imx322_bliso_fc_mo_1st_shpcoring_scale_coring;
+				}
 			sprintf(sensor_name, "imx322");
 			break;
+			case SENSOR_IMX326:
+			printf("imx326\n");
+			if(isp_pipeline ==ISP_PIPELINE_LISO){
+				fcc.fc_ae_target = &imx326_liso_fc_ae_target;
+				fcc.fc_wb_ratio = &imx326_liso_fc_wb_ratio;
+				fcc.fc_blc = &imx326_liso_fc_blc;
+				fcc.fc_antialiasing = &imx326_liso_fc_antialiasing;
+				fcc.fc_grgbmismatch = &imx326_liso_fc_grgbmismatch;
+				fcc.fc_dpc = &imx326_liso_fc_dpc;
+				fcc.fc_cfanf_low = &imx326_liso_fc_cfanf;
+				fcc.fc_cfanf_high = NULL;
+				fcc.fc_le = (hdr_pipeline == HDR_PIPELINE_OFF)? NULL : \
+					((expo_num == HDR_2X)? &imx326_liso_fc_2x_hdr_le : &imx326_liso_fc_3x_hdr_le);
+				fcc.fc_demosaic = &imx326_liso_fc_demosaic;
+				fcc.fc_cc = &imx326_liso_fc_cc;
+				fcc.fc_tone = (hdr_pipeline == HDR_PIPELINE_OFF)? &imx326_liso_fc_tone : \
+					((expo_num == HDR_2X)? &imx326_liso_fc_2x_hdr_tone : &imx326_liso_fc_3x_hdr_tone);
+				fcc.fc_rgb2yuv = &imx326_liso_fc_rgb2yuv;
+				fcc.fc_chroma_scale = &imx326_liso_fc_chroma_scale;
+				fcc.fc_chroma_median = &imx326_liso_fc_chroma_median;
+				fcc.fc_chroma_nf = &imx326_liso_fc_chroma_nf;
+				fcc.fc_cdnr = &imx326_liso_fc_cdnr;
+				fcc.fc_1stmode_sel = &imx326_liso_fc_1stmode_sel;
+				fcc.fc_asf = &imx326_liso_fc_asf;
+				fcc.fc_1st_shpboth = &imx326_liso_fc_1st_shpboth;
+				fcc.fc_1st_shpnoise = &imx326_liso_fc_1st_shpnoise;
+				fcc.fc_1st_shpfir = &imx326_liso_fc_1st_shpfir;
+				fcc.fc_1st_shpcoring = &imx326_liso_fc_1st_shpcoring;
+				fcc.fc_1st_shpcoring_idx_scale = &imx326_liso_fc_1st_shpcoring_idx_scale;
+				fcc.fc_1st_shpcoring_min = &imx326_liso_fc_1st_shpcoring_min;
+				fcc.fc_1st_shpcoring_scale_coring = &imx326_liso_fc_1st_shpcoring_scale_coring;
+				fcc.fc_video_mctf = &imx326_liso_fc_video_mctf;
+				fcc.fc_hdr_alpha = (hdr_pipeline == HDR_PIPELINE_OFF)? \
+					NULL : &imx326_liso_fc_hdr_alpha;
+				fcc.fc_hdr_threshold = (hdr_pipeline == HDR_PIPELINE_OFF)? \
+					NULL : &imx326_liso_fc_hdr_threshold;
+				fcc.fc_hdr_ce = (hdr_pipeline == HDR_PIPELINE_OFF)? \
+					NULL : &imx326_liso_fc_hdr_ce;
+				}
+			else if(isp_pipeline ==ISP_PIPELINE_ADV_LISO){
+				fcc.fc_ae_target = &imx326_aliso_fc_ae_target;
+				fcc.fc_wb_ratio = &imx326_aliso_fc_wb_ratio;
+				fcc.fc_blc = &imx326_aliso_fc_blc;
+				fcc.fc_antialiasing = &imx326_aliso_fc_antialiasing;
+				fcc.fc_grgbmismatch = &imx326_aliso_fc_grgbmismatch;
+				fcc.fc_dpc = &imx326_aliso_fc_dpc;
+				fcc.fc_cfanf_low = &imx326_aliso_fc_cfanf;
+				fcc.fc_cfanf_high = NULL;
+				fcc.fc_le = (hdr_pipeline == HDR_PIPELINE_OFF)? NULL : \
+					((expo_num == HDR_2X)? &imx326_aliso_fc_2x_hdr_le : &imx326_aliso_fc_3x_hdr_le);
+				fcc.fc_demosaic = &imx326_aliso_fc_demosaic;
+				fcc.fc_cc = &imx326_aliso_fc_cc;
+				fcc.fc_tone = (hdr_pipeline == HDR_PIPELINE_OFF)? &imx326_aliso_fc_tone : \
+					((expo_num == HDR_2X)? &imx326_aliso_fc_2x_hdr_tone : &imx326_aliso_fc_3x_hdr_tone);
+				fcc.fc_rgb2yuv = &imx326_aliso_fc_rgb2yuv;
+				fcc.fc_chroma_scale = &imx326_aliso_fc_chroma_scale;
+				fcc.fc_chroma_median = &imx326_aliso_fc_chroma_median;
+				fcc.fc_chroma_nf = &imx326_aliso_fc_chroma_nf;
+				fcc.fc_cdnr = &imx326_aliso_fc_cdnr;
+				fcc.fc_1stmode_sel = &imx326_aliso_fc_1stmode_sel;
+				fcc.fc_asf = &imx326_aliso_fc_asf;
+				fcc.fc_1st_shpboth = &imx326_aliso_fc_1st_shpboth;
+				fcc.fc_1st_shpnoise = &imx326_aliso_fc_1st_shpnoise;
+				fcc.fc_1st_shpfir = &imx326_aliso_fc_1st_shpfir;
+				fcc.fc_1st_shpcoring = &imx326_aliso_fc_1st_shpcoring;
+				fcc.fc_1st_shpcoring_idx_scale = &imx326_aliso_fc_1st_shpcoring_idx_scale;
+				fcc.fc_1st_shpcoring_min = &imx326_aliso_fc_1st_shpcoring_min;
+				fcc.fc_1st_shpcoring_scale_coring = &imx326_aliso_fc_1st_shpcoring_scale_coring;
+				fcc.fc_final_shpboth = &imx326_aliso_fc_final_shpboth;
+				fcc.fc_final_shpnoise = &imx326_aliso_fc_final_shpnoise;
+				fcc.fc_final_shpfir = &imx326_aliso_fc_final_shpfir;
+				fcc.fc_final_shpcoring = &imx326_aliso_fc_final_shpcoring;
+				fcc.fc_final_shpcoring_idx_scale = &imx326_aliso_fc_final_shpcoring_idx_scale;
+				fcc.fc_final_shpcoring_min = &imx326_aliso_fc_final_shpcoring_min;
+				fcc.fc_final_shpcoring_scale_coring = &imx326_aliso_fc_final_shpcoring_scale_coring;
+				fcc.fc_wide_chroma_filter =&imx326_aliso_fc_wide_chroma_filter;
+				fcc.fc_wide_chroma_filter_combine =&imx326_aliso_fc_wide_chroma_filter_combine;
+				fcc.fc_video_mctf = &imx326_aliso_fc_video_mctf;
+				fcc.fc_video_mctf_temporal_adjust =&imx326_aliso_fc_video_mctf_temporal_adjust;
+				fcc.fc_hdr_alpha = (hdr_pipeline == HDR_PIPELINE_OFF)? \
+					NULL : &imx326_aliso_fc_hdr_alpha;
+				fcc.fc_hdr_threshold = (hdr_pipeline == HDR_PIPELINE_OFF)? \
+					NULL : &imx326_aliso_fc_hdr_threshold;
+				fcc.fc_hdr_ce = (hdr_pipeline == HDR_PIPELINE_OFF)? \
+					NULL : &imx326_aliso_fc_hdr_ce;
+				}
+			else if(isp_pipeline ==ISP_PIPELINE_MID_LISO){
+				fcc.fc_ae_target = &imx326_mliso_fc_ae_target;
+				fcc.fc_wb_ratio = &imx326_mliso_fc_wb_ratio;
+				fcc.fc_blc = &imx326_mliso_fc_blc;
+				fcc.fc_antialiasing = &imx326_mliso_fc_antialiasing;
+				fcc.fc_grgbmismatch = &imx326_mliso_fc_grgbmismatch;
+				fcc.fc_dpc = &imx326_mliso_fc_dpc;
+				fcc.fc_cfanf_low = &imx326_mliso_fc_cfanf;
+				fcc.fc_cfanf_high = NULL;
+				fcc.fc_le = (hdr_pipeline == HDR_PIPELINE_OFF)? NULL : \
+					((expo_num == HDR_2X)? &imx326_mliso_fc_2x_hdr_le : &imx326_mliso_fc_3x_hdr_le);
+				fcc.fc_demosaic = &imx326_mliso_fc_demosaic;
+				fcc.fc_cc = &imx326_mliso_fc_cc;
+				fcc.fc_tone = (hdr_pipeline == HDR_PIPELINE_OFF)? &imx326_mliso_fc_tone : \
+					((expo_num == HDR_2X)? &imx326_mliso_fc_2x_hdr_tone : &imx326_mliso_fc_3x_hdr_tone);
+				fcc.fc_rgb2yuv = &imx326_mliso_fc_rgb2yuv;
+				fcc.fc_chroma_scale = &imx326_mliso_fc_chroma_scale;
+				fcc.fc_chroma_median = &imx326_mliso_fc_chroma_median;
+				fcc.fc_chroma_nf = &imx326_mliso_fc_chroma_nf;
+				fcc.fc_cdnr = &imx326_mliso_fc_cdnr;
+				fcc.fc_1stmode_sel = &imx326_mliso_fc_1stmode_sel;
+				fcc.fc_asf = &imx326_mliso_fc_asf;
+				fcc.fc_1st_shpboth = &imx326_mliso_fc_1st_shpboth;
+				fcc.fc_1st_shpnoise = &imx326_mliso_fc_1st_shpnoise;
+				fcc.fc_1st_shpfir = &imx326_mliso_fc_1st_shpfir;
+				fcc.fc_1st_shpcoring = &imx326_mliso_fc_1st_shpcoring;
+				fcc.fc_1st_shpcoring_idx_scale = &imx326_mliso_fc_1st_shpcoring_idx_scale;
+				fcc.fc_1st_shpcoring_min = &imx326_mliso_fc_1st_shpcoring_min;
+				fcc.fc_1st_shpcoring_scale_coring = &imx326_mliso_fc_1st_shpcoring_scale_coring;
+				fcc.fc_video_mctf = &imx326_mliso_fc_video_mctf;
+				fcc.fc_video_mctf_temporal_adjust =&imx326_mliso_fc_video_mctf_temporal_adjust;
+				fcc.fc_hdr_alpha = (hdr_pipeline == HDR_PIPELINE_OFF)? \
+					NULL : &imx326_mliso_fc_hdr_alpha;
+				fcc.fc_hdr_threshold = (hdr_pipeline == HDR_PIPELINE_OFF)? \
+					NULL : &imx326_mliso_fc_hdr_threshold;
+				fcc.fc_hdr_ce = (hdr_pipeline == HDR_PIPELINE_OFF)? \
+					NULL : &imx326_mliso_fc_hdr_ce;
+				}
+			else if(isp_pipeline ==ISP_PIPELINE_B_LISO){
+				fcc.fc_ae_target = &imx326_bliso_fc_ae_target;
+				fcc.fc_wb_ratio = &imx326_bliso_fc_wb_ratio;
+				fcc.fc_blc = &imx326_bliso_fc_blc;
+				fcc.fc_antialiasing = &imx326_bliso_fc_antialiasing;
+				fcc.fc_grgbmismatch = &imx326_bliso_fc_grgbmismatch;
+				fcc.fc_dpc = &imx326_bliso_fc_dpc;
+				fcc.fc_cfanf_low = &imx326_bliso_fc_cfanf;
+				fcc.fc_cfanf_high = NULL;
+				fcc.fc_le = &imx326_bliso_le;
+				fcc.fc_demosaic = &imx326_bliso_fc_demosaic;
+				fcc.fc_cc = &imx326_bliso_fc_cc;
+				fcc.fc_tone = (hdr_pipeline == HDR_PIPELINE_OFF)? &imx326_bliso_fc_tone : \
+					((expo_num == HDR_2X)? &imx326_bliso_fc_2x_hdr_tone : &imx326_bliso_fc_3x_hdr_tone);
+				fcc.fc_rgb2yuv = &imx326_bliso_fc_rgb2yuv;
+				fcc.fc_chroma_scale = &imx326_bliso_fc_chroma_scale;
+				fcc.fc_chroma_median = &imx326_bliso_fc_chroma_median;
+				fcc.fc_chroma_nf = &imx326_bliso_fc_chroma_nf;
+				fcc.fc_1stmode_sel = &imx326_bliso_fc_1stmode_sel;
+				fcc.fc_asf = &imx326_bliso_fc_asf;
+				fcc.fc_1st_shpboth = &imx326_bliso_fc_1st_shpboth;
+				fcc.fc_1st_shpnoise = &imx326_bliso_fc_1st_shpnoise;
+				fcc.fc_1st_shpfir = &imx326_bliso_fc_1st_shpfir;
+				fcc.fc_1st_shpcoring = &imx326_bliso_fc_1st_shpcoring;
+				fcc.fc_1st_shpcoring_idx_scale = &imx326_bliso_fc_1st_shpcoring_idx_scale;
+				fcc.fc_1st_shpcoring_min = &imx326_bliso_fc_1st_shpcoring_min;
+				fcc.fc_1st_shpcoring_scale_coring = &imx326_bliso_fc_1st_shpcoring_scale_coring;
+
+				fcc.fc_video_mctf = &imx326_bliso_fc_video_mctf;
+				fcc.fc_video_mctf_temporal_adjust =&imx326_bliso_fc_video_mctf_temporal_adjust;
+				fcc.fc_hdr_alpha = \
+					(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &imx326_bliso_fc_hdr_alpha;
+				fcc.fc_hdr_threshold = \
+					(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &imx326_bliso_fc_hdr_threshold;
+				fcc.fc_hdr_ce = \
+					(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &imx326_bliso_fc_hdr_ce;
+				fcc.fc_mo_antialiasing = &imx326_bliso_fc_mo_antialiasing;
+				fcc.fc_mo_grgbmismatch = &imx326_bliso_fc_mo_grgbmismatch;
+				fcc.fc_mo_dpc = &imx326_bliso_fc_mo_dpc;
+				fcc.fc_mo_cfanf = &imx326_bliso_fc_mo_cfanf;
+				fcc.fc_mo_demosaic = &imx326_bliso_fc_mo_demosaic;
+				fcc.fc_mo_chroma_median = &imx326_bliso_fc_mo_chroma_median;
+				fcc.fc_mo_chroma_nf = &imx326_bliso_fc_mo_chroma_nf;
+				fcc.fc_mo_1stmode_sel = &imx326_bliso_fc_mo_1stmode_sel;
+				fcc.fc_mo_asf = &imx326_bliso_fc_mo_asf;
+				fcc.fc_mo_1st_shpboth = &imx326_bliso_fc_mo_1st_shpboth;
+				fcc.fc_mo_1st_shpnoise = &imx326_bliso_fc_mo_1st_shpnoise;
+				fcc.fc_mo_1st_shpfir = &imx326_bliso_fc_mo_1st_shpfir;
+				fcc.fc_mo_1st_shpcoring = &imx326_bliso_fc_mo_1st_shpcoring;
+				fcc.fc_mo_1st_shpcoring_idx_scale = &imx326_bliso_fc_mo_1st_shpcoring_idx_scale;
+				fcc.fc_mo_1st_shpcoring_min = &imx326_bliso_fc_mo_1st_shpcoring_min;
+				fcc.fc_mo_1st_shpcoring_scale_coring = &imx326_bliso_fc_mo_1st_shpcoring_scale_coring;
+				}
+			sprintf(sensor_name, "imx326");
+			break;
+		case SENSOR_IMX377:
+			printf("imx377\n");
+			if(isp_pipeline ==ISP_PIPELINE_LISO){
+				fcc.fc_ae_target = &imx377_liso_fc_ae_target;
+				fcc.fc_wb_ratio = &imx377_liso_fc_wb_ratio;
+				fcc.fc_blc = &imx377_liso_fc_blc;
+				fcc.fc_antialiasing = &imx377_liso_fc_antialiasing;
+				fcc.fc_grgbmismatch = &imx377_liso_fc_grgbmismatch;
+				fcc.fc_dpc = &imx377_liso_fc_dpc;
+				fcc.fc_cfanf_low = &imx377_liso_fc_cfanf;
+				fcc.fc_cfanf_high = NULL;
+				fcc.fc_le = (hdr_pipeline == HDR_PIPELINE_OFF)? NULL : \
+					((expo_num == HDR_2X)? &imx377_liso_fc_2x_hdr_le : &imx377_liso_fc_3x_hdr_le);
+				fcc.fc_demosaic = &imx377_liso_fc_demosaic;
+				fcc.fc_cc = &imx377_liso_fc_cc;
+				fcc.fc_tone = (hdr_pipeline == HDR_PIPELINE_OFF)? &imx377_liso_fc_tone : \
+					((expo_num == HDR_2X)? &imx377_liso_fc_2x_hdr_tone : &imx377_liso_fc_3x_hdr_tone);
+				fcc.fc_rgb2yuv = &imx377_liso_fc_rgb2yuv;
+				fcc.fc_chroma_scale = &imx377_liso_fc_chroma_scale;
+				fcc.fc_chroma_median = &imx377_liso_fc_chroma_median;
+				fcc.fc_chroma_nf = &imx377_liso_fc_chroma_nf;
+				fcc.fc_cdnr = &imx377_liso_fc_cdnr;
+				fcc.fc_1stmode_sel = &imx377_liso_fc_1stmode_sel;
+				fcc.fc_asf = &imx377_liso_fc_asf;
+				fcc.fc_1st_shpboth = &imx377_liso_fc_1st_shpboth;
+				fcc.fc_1st_shpnoise = &imx377_liso_fc_1st_shpnoise;
+				fcc.fc_1st_shpfir = &imx377_liso_fc_1st_shpfir;
+				fcc.fc_1st_shpcoring = &imx377_liso_fc_1st_shpcoring;
+				fcc.fc_1st_shpcoring_idx_scale = &imx377_liso_fc_1st_shpcoring_idx_scale;
+				fcc.fc_1st_shpcoring_min = &imx377_liso_fc_1st_shpcoring_min;
+				fcc.fc_1st_shpcoring_scale_coring = &imx377_liso_fc_1st_shpcoring_scale_coring;
+				fcc.fc_video_mctf = &imx377_liso_fc_video_mctf;
+				fcc.fc_hdr_alpha = (hdr_pipeline == HDR_PIPELINE_OFF)? \
+					NULL : &imx377_liso_fc_hdr_alpha;
+				fcc.fc_hdr_threshold = (hdr_pipeline == HDR_PIPELINE_OFF)? \
+					NULL : &imx377_liso_fc_hdr_threshold;
+				fcc.fc_hdr_ce = (hdr_pipeline == HDR_PIPELINE_OFF)? \
+					NULL : &imx377_liso_fc_hdr_ce;
+				}
+			else if(isp_pipeline ==ISP_PIPELINE_ADV_LISO){
+				fcc.fc_ae_target = &imx377_aliso_fc_ae_target;
+				fcc.fc_wb_ratio = &imx377_aliso_fc_wb_ratio;
+				fcc.fc_blc = &imx377_aliso_fc_blc;
+				fcc.fc_antialiasing = &imx377_aliso_fc_antialiasing;
+				fcc.fc_grgbmismatch = &imx377_aliso_fc_grgbmismatch;
+				fcc.fc_dpc = &imx377_aliso_fc_dpc;
+				fcc.fc_cfanf_low = &imx377_aliso_fc_cfanf;
+				fcc.fc_cfanf_high = NULL;
+				fcc.fc_le = (hdr_pipeline == HDR_PIPELINE_OFF)? NULL : \
+					((expo_num == HDR_2X)? &imx377_aliso_fc_2x_hdr_le : &imx377_aliso_fc_3x_hdr_le);
+				fcc.fc_demosaic = &imx377_aliso_fc_demosaic;
+				fcc.fc_cc = &imx377_aliso_fc_cc;
+				fcc.fc_tone = (hdr_pipeline == HDR_PIPELINE_OFF)? &imx377_aliso_fc_tone : \
+					((expo_num == HDR_2X)? &imx377_aliso_fc_2x_hdr_tone : &imx377_aliso_fc_3x_hdr_tone);
+				fcc.fc_rgb2yuv = &imx377_aliso_fc_rgb2yuv;
+				fcc.fc_chroma_scale = &imx377_aliso_fc_chroma_scale;
+				fcc.fc_chroma_median = &imx377_aliso_fc_chroma_median;
+				fcc.fc_chroma_nf = &imx377_aliso_fc_chroma_nf;
+				fcc.fc_cdnr = &imx377_aliso_fc_cdnr;
+				fcc.fc_1stmode_sel = &imx377_aliso_fc_1stmode_sel;
+				fcc.fc_asf = &imx377_aliso_fc_asf;
+				fcc.fc_1st_shpboth = &imx377_aliso_fc_1st_shpboth;
+				fcc.fc_1st_shpnoise = &imx377_aliso_fc_1st_shpnoise;
+				fcc.fc_1st_shpfir = &imx377_aliso_fc_1st_shpfir;
+				fcc.fc_1st_shpcoring = &imx377_aliso_fc_1st_shpcoring;
+				fcc.fc_1st_shpcoring_idx_scale = &imx377_aliso_fc_1st_shpcoring_idx_scale;
+				fcc.fc_1st_shpcoring_min = &imx377_aliso_fc_1st_shpcoring_min;
+				fcc.fc_1st_shpcoring_scale_coring = &imx377_aliso_fc_1st_shpcoring_scale_coring;
+				fcc.fc_final_shpboth = &imx377_aliso_fc_final_shpboth;
+				fcc.fc_final_shpnoise = &imx377_aliso_fc_final_shpnoise;
+				fcc.fc_final_shpfir = &imx377_aliso_fc_final_shpfir;
+				fcc.fc_final_shpcoring = &imx377_aliso_fc_final_shpcoring;
+				fcc.fc_final_shpcoring_idx_scale = &imx377_aliso_fc_final_shpcoring_idx_scale;
+				fcc.fc_final_shpcoring_min = &imx377_aliso_fc_final_shpcoring_min;
+				fcc.fc_final_shpcoring_scale_coring = &imx377_aliso_fc_final_shpcoring_scale_coring;
+				fcc.fc_wide_chroma_filter =&imx377_aliso_fc_wide_chroma_filter;
+				fcc.fc_wide_chroma_filter_combine =&imx377_aliso_fc_wide_chroma_filter_combine;
+				fcc.fc_video_mctf = &imx377_aliso_fc_video_mctf;
+				fcc.fc_video_mctf_temporal_adjust =&imx377_aliso_fc_video_mctf_temporal_adjust;
+				fcc.fc_hdr_alpha = (hdr_pipeline == HDR_PIPELINE_OFF)? \
+					NULL : &imx377_aliso_fc_hdr_alpha;
+				fcc.fc_hdr_threshold = (hdr_pipeline == HDR_PIPELINE_OFF)? \
+					NULL : &imx377_aliso_fc_hdr_threshold;
+				fcc.fc_hdr_ce = (hdr_pipeline == HDR_PIPELINE_OFF)? \
+					NULL : &imx377_aliso_fc_hdr_ce;
+				}
+			else if(isp_pipeline ==ISP_PIPELINE_MID_LISO){
+				fcc.fc_ae_target = &imx377_mliso_fc_ae_target;
+				fcc.fc_wb_ratio = &imx377_mliso_fc_wb_ratio;
+				fcc.fc_blc = &imx377_mliso_fc_blc;
+				fcc.fc_antialiasing = &imx377_mliso_fc_antialiasing;
+				fcc.fc_grgbmismatch = &imx377_mliso_fc_grgbmismatch;
+				fcc.fc_dpc = &imx377_mliso_fc_dpc;
+				fcc.fc_cfanf_low = &imx377_mliso_fc_cfanf;
+				fcc.fc_cfanf_high = NULL;
+				fcc.fc_le = (hdr_pipeline == HDR_PIPELINE_OFF)? NULL : \
+					((expo_num == HDR_2X)? &imx377_mliso_fc_2x_hdr_le : &imx377_mliso_fc_3x_hdr_le);
+				fcc.fc_demosaic = &imx377_mliso_fc_demosaic;
+				fcc.fc_cc = &imx377_mliso_fc_cc;
+				fcc.fc_tone = (hdr_pipeline == HDR_PIPELINE_OFF)? &imx377_mliso_fc_tone : \
+					((expo_num == HDR_2X)? &imx377_mliso_fc_2x_hdr_tone : &imx377_mliso_fc_3x_hdr_tone);
+				fcc.fc_rgb2yuv = &imx377_mliso_fc_rgb2yuv;
+				fcc.fc_chroma_scale = &imx377_mliso_fc_chroma_scale;
+				fcc.fc_chroma_median = &imx377_mliso_fc_chroma_median;
+				fcc.fc_chroma_nf = &imx377_mliso_fc_chroma_nf;
+				fcc.fc_cdnr = &imx377_mliso_fc_cdnr;
+				fcc.fc_1stmode_sel = &imx377_mliso_fc_1stmode_sel;
+				fcc.fc_asf = &imx377_mliso_fc_asf;
+				fcc.fc_1st_shpboth = &imx377_mliso_fc_1st_shpboth;
+				fcc.fc_1st_shpnoise = &imx377_mliso_fc_1st_shpnoise;
+				fcc.fc_1st_shpfir = &imx377_mliso_fc_1st_shpfir;
+				fcc.fc_1st_shpcoring = &imx377_mliso_fc_1st_shpcoring;
+				fcc.fc_1st_shpcoring_idx_scale = &imx377_mliso_fc_1st_shpcoring_idx_scale;
+				fcc.fc_1st_shpcoring_min = &imx377_mliso_fc_1st_shpcoring_min;
+				fcc.fc_1st_shpcoring_scale_coring = &imx377_mliso_fc_1st_shpcoring_scale_coring;
+				fcc.fc_video_mctf = &imx377_mliso_fc_video_mctf;
+				fcc.fc_video_mctf_temporal_adjust =&imx377_mliso_fc_video_mctf_temporal_adjust;
+				fcc.fc_hdr_alpha = (hdr_pipeline == HDR_PIPELINE_OFF)? \
+					NULL : &imx377_mliso_fc_hdr_alpha;
+				fcc.fc_hdr_threshold = (hdr_pipeline == HDR_PIPELINE_OFF)? \
+					NULL : &imx377_mliso_fc_hdr_threshold;
+				fcc.fc_hdr_ce = (hdr_pipeline == HDR_PIPELINE_OFF)? \
+					NULL : &imx377_mliso_fc_hdr_ce;
+				}
+			else if(isp_pipeline ==ISP_PIPELINE_B_LISO){
+				fcc.fc_ae_target = &imx377_bliso_fc_ae_target;
+				fcc.fc_wb_ratio = &imx377_bliso_fc_wb_ratio;
+				fcc.fc_blc = &imx377_bliso_fc_blc;
+				fcc.fc_antialiasing = &imx377_bliso_fc_antialiasing;
+				fcc.fc_grgbmismatch = &imx377_bliso_fc_grgbmismatch;
+				fcc.fc_dpc = &imx377_bliso_fc_dpc;
+				fcc.fc_cfanf_low = &imx377_bliso_fc_cfanf;
+				fcc.fc_cfanf_high = NULL;
+				fcc.fc_le = &imx377_bliso_le;
+				fcc.fc_demosaic = &imx377_bliso_fc_demosaic;
+				fcc.fc_cc = &imx377_bliso_fc_cc;
+				fcc.fc_tone = (hdr_pipeline == HDR_PIPELINE_OFF)? &imx377_bliso_fc_tone : \
+					((expo_num == HDR_2X)? &imx377_bliso_fc_2x_hdr_tone : &imx377_bliso_fc_3x_hdr_tone);
+				fcc.fc_rgb2yuv = &imx377_bliso_fc_rgb2yuv;
+				fcc.fc_chroma_scale = &imx377_bliso_fc_chroma_scale;
+				fcc.fc_chroma_median = &imx377_bliso_fc_chroma_median;
+				fcc.fc_chroma_nf = &imx377_bliso_fc_chroma_nf;
+				fcc.fc_1stmode_sel = &imx377_bliso_fc_1stmode_sel;
+				fcc.fc_asf = &imx377_bliso_fc_asf;
+				fcc.fc_1st_shpboth = &imx377_bliso_fc_1st_shpboth;
+				fcc.fc_1st_shpnoise = &imx377_bliso_fc_1st_shpnoise;
+				fcc.fc_1st_shpfir = &imx377_bliso_fc_1st_shpfir;
+				fcc.fc_1st_shpcoring = &imx377_bliso_fc_1st_shpcoring;
+				fcc.fc_1st_shpcoring_idx_scale = &imx377_bliso_fc_1st_shpcoring_idx_scale;
+				fcc.fc_1st_shpcoring_min = &imx377_bliso_fc_1st_shpcoring_min;
+				fcc.fc_1st_shpcoring_scale_coring = &imx377_bliso_fc_1st_shpcoring_scale_coring;
+
+				fcc.fc_video_mctf = &imx377_bliso_fc_video_mctf;
+				fcc.fc_video_mctf_temporal_adjust =&imx377_bliso_fc_video_mctf_temporal_adjust;
+				fcc.fc_hdr_alpha = \
+					(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &imx377_bliso_fc_hdr_alpha;
+				fcc.fc_hdr_threshold = \
+					(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &imx377_bliso_fc_hdr_threshold;
+				fcc.fc_hdr_ce = \
+					(hdr_pipeline == HDR_PIPELINE_OFF)? NULL : &imx377_bliso_fc_hdr_ce;
+				fcc.fc_mo_antialiasing = &imx377_bliso_fc_mo_antialiasing;
+				fcc.fc_mo_grgbmismatch = &imx377_bliso_fc_mo_grgbmismatch;
+				fcc.fc_mo_dpc = &imx377_bliso_fc_mo_dpc;
+				fcc.fc_mo_cfanf = &imx377_bliso_fc_mo_cfanf;
+				fcc.fc_mo_demosaic = &imx377_bliso_fc_mo_demosaic;
+				fcc.fc_mo_chroma_median = &imx377_bliso_fc_mo_chroma_median;
+				fcc.fc_mo_chroma_nf = &imx377_bliso_fc_mo_chroma_nf;
+				fcc.fc_mo_1stmode_sel = &imx377_bliso_fc_mo_1stmode_sel;
+				fcc.fc_mo_asf = &imx377_bliso_fc_mo_asf;
+				fcc.fc_mo_1st_shpboth = &imx377_bliso_fc_mo_1st_shpboth;
+				fcc.fc_mo_1st_shpnoise = &imx377_bliso_fc_mo_1st_shpnoise;
+				fcc.fc_mo_1st_shpfir = &imx377_bliso_fc_mo_1st_shpfir;
+				fcc.fc_mo_1st_shpcoring = &imx377_bliso_fc_mo_1st_shpcoring;
+				fcc.fc_mo_1st_shpcoring_idx_scale = &imx377_bliso_fc_mo_1st_shpcoring_idx_scale;
+				fcc.fc_mo_1st_shpcoring_min = &imx377_bliso_fc_mo_1st_shpcoring_min;
+				fcc.fc_mo_1st_shpcoring_scale_coring = &imx377_bliso_fc_mo_1st_shpcoring_scale_coring;
+				}
+			sprintf(sensor_name, "imx377");
+			break;
 		case SENSOR_AR0130:
 			printf("ar0130\n");
 			if(isp_pipeline ==ISP_PIPELINE_LISO){
@@ -2442,7 +3537,7 @@ int load_containers(u32 sensor_id,char* sensor_name, img_config_info_t *p_img_cf
 				fcc.fc_demosaic = &ar0230_bliso_fc_demosaic;
 				fcc.fc_cc = &ar0230_bliso_fc_cc;
 				fcc.fc_tone = (hdr_pipeline == HDR_PIPELINE_OFF)? &ar0230_bliso_fc_tone : \
-					((expo_num = HDR_2X)? &ar0230_bliso_fc_2x_hdr_tone : &ar0230_bliso_fc_3x_hdr_tone);
+					((expo_num == HDR_2X)? &ar0230_bliso_fc_2x_hdr_tone : &ar0230_bliso_fc_3x_hdr_tone);
 				fcc.fc_rgb2yuv = &ar0230_bliso_fc_rgb2yuv;
 				fcc.fc_chroma_scale = &ar0230_bliso_fc_chroma_scale;
 				fcc.fc_chroma_median = &ar0230_bliso_fc_chroma_median;
@@ -2618,7 +3713,7 @@ int load_containers(u32 sensor_id,char* sensor_name, img_config_info_t *p_img_cf
 				fcc.fc_demosaic = &ar0237_bliso_fc_demosaic;
 				fcc.fc_cc = &ar0237_bliso_fc_cc;
 				fcc.fc_tone = (hdr_pipeline == HDR_PIPELINE_OFF)? &ar0237_bliso_fc_tone : \
-					((expo_num = HDR_2X)? &ar0237_bliso_fc_2x_hdr_tone : &ar0237_bliso_fc_3x_hdr_tone);
+					((expo_num == HDR_2X)? &ar0237_bliso_fc_2x_hdr_tone : &ar0237_bliso_fc_3x_hdr_tone);
 				fcc.fc_rgb2yuv = &ar0237_bliso_fc_rgb2yuv;
 				fcc.fc_chroma_scale = &ar0237_bliso_fc_chroma_scale;
 				fcc.fc_chroma_median = &ar0237_bliso_fc_chroma_median;
@@ -2681,6 +3776,8 @@ int img_aaa_config(int fd_iav, struct vindev_aaa_info* vin_aaa_info, img_config_
 
 	hdr_pipeline_t hdr_pipeline = p_img_cfg->hdr_config.pipeline;
 	hdr_method_t hdr_method = p_img_cfg->hdr_config.method;
+	hdr_mask_t hdr_mask = p_img_cfg->hdr_config.mask;
+	u8 fake_linear = (hdr_mask == MASK_LINEAR_IN_HDR && hdr_pipeline != HDR_PIPELINE_OFF);
 	u8 expo_num = p_img_cfg->hdr_config.expo_num;
 
 	img_aeb_sensor_config_t * p_sensor_cfg = NULL;
@@ -2689,7 +3786,8 @@ int img_aaa_config(int fd_iav, struct vindev_aaa_info* vin_aaa_info, img_config_
 	img_aeb_gain_table_t* p_gain_tbl = NULL;
 	img_aeb_sht_nl_table_t* p_sht_nl_tbl = NULL;
 	img_aeb_wb_param_t* p_wb_param = NULL;
-	img_auto_knee_config_info_t* p_auto_knee_cfg =NULL;
+	img_aeb_auto_knee_param_t* p_auto_knee_param =NULL;
+	img_aeb_digit_wdr_param_t* p_digit_wdr_param = NULL;
 	switch(vin_aaa_info->sensor_id){
 		case SENSOR_MN34220PL:
 			p_sensor_cfg = &mn34220pl_aeb_sensor_config;
@@ -2697,14 +3795,17 @@ int img_aaa_config(int fd_iav, struct vindev_aaa_info* vin_aaa_info, img_config_
 			p_gain_tbl = &mn34220pl_aeb_gain_table;
 			p_sht_nl_tbl = &mn34220pl_aeb_sht_nl_table;
 			p_wb_param = &mn34220pl_aeb_wb_param;
-			p_auto_knee_cfg =&mn34220pl_auto_knee_config;
+			p_auto_knee_param =&mn34220pl_aeb_auto_knee_config;
 
 			if(hdr_pipeline == HDR_PIPELINE_OFF){
 				p_ae_lines = &mn34220pl_aeb_expo_lines;
+				p_digit_wdr_param = &mn34220pl_aeb_digit_wdr_config;
 			}else if(hdr_pipeline != HDR_PIPELINE_OFF && expo_num == HDR_2X){
 				p_ae_lines = &mn34220pl_aeb_expo_lines_2x_hdr;
+				p_digit_wdr_param = &mn34220pl_aeb_digit_wdr_config_2x_hdr;
 			}else if(hdr_pipeline != HDR_PIPELINE_OFF && expo_num == HDR_3X){
 				p_ae_lines = &mn34220pl_aeb_expo_lines_3x_hdr;
+				p_digit_wdr_param = &mn34220pl_aeb_digit_wdr_config_3x_hdr;
 			}else{
 				printf("error: can't find the proper ae lines for mode %d, expo num %d\n", \
 					hdr_pipeline, expo_num);
@@ -2727,6 +3828,24 @@ int img_aaa_config(int fd_iav, struct vindev_aaa_info* vin_aaa_info, img_config_
 			p_wb_param = &ov9715_aeb_wb_param;
 			p_ae_lines = &ov9715_aeb_expo_lines;
 			break;
+		case SENSOR_OV2718:
+			p_tile_cfg = &ov2718_aeb_tile_config;
+			p_gain_tbl = &ov2718_aeb_gain_table;
+			p_sht_nl_tbl = &ov2718_aeb_sht_nl_table;
+			p_wb_param = &ov2718_aeb_wb_param;
+			p_sensor_cfg = &ov2718_aeb_sensor_config;
+			if(HDR_PIPELINE_OFF == hdr_pipeline &&
+				HDR_NONE_METHOD == hdr_method){
+				p_ae_lines = &ov2718_aeb_expo_lines;
+			} else if (hdr_pipeline != HDR_PIPELINE_OFF &&
+				hdr_method == HDR_RATIO_VARY_LINE_METHOD &&
+				expo_num == HDR_2X) {
+				p_ae_lines = &ov2718_aeb_expo_lines_2x_vs_hdr;
+			} else {
+				printf("error: can't find the proper ae lines for mode %d, expo num %d\n", hdr_pipeline, expo_num);
+				return - 1;
+			}
+			break;
 		case SENSOR_OV9750:
 			p_sensor_cfg = &ov9750_aeb_sensor_config;
 			p_tile_cfg = &ov9750_aeb_tile_config;
@@ -2758,16 +3877,53 @@ int img_aaa_config(int fd_iav, struct vindev_aaa_info* vin_aaa_info, img_config_
 				} else {
 					p_ae_lines = &ov4689_aeb_expo_lines;
 				}
+				p_digit_wdr_param = &ov4689_aeb_digit_wdr_config;
 			}else if(hdr_pipeline != HDR_PIPELINE_OFF && expo_num == HDR_2X){
-				p_ae_lines = &ov4689_aeb_expo_lines_2x_hdr;
+				if(lens_mount_id==LENS_MZ128BP2810ICR_ID) {
+				//	lens_param_info.piris_std.dgain = &MZ128BP2810ICR_PIRIS_DGAIN;	//not need for S2L AE
+					lens_param_info.piris_std.scope = MZ128BP2810ICR_PIRIS_SCOPE.table;
+					lens_param_info.piris_std.table = MZ128BP2810ICR_PIRIS_STEP.table;
+					lens_param_info.piris_std.tbl_size = MZ128BP2810ICR_PIRIS_STEP.header.array_size;
+					p_ae_lines = &ov4689_aeb_expo_lines_2x_hdr_mz128bp2810icr;
+				} else {
+					p_ae_lines = &ov4689_aeb_expo_lines_2x_hdr;
+				}
+				p_digit_wdr_param = &ov4689_aeb_digit_wdr_config_2x_hdr;
 			}else if(hdr_pipeline != HDR_PIPELINE_OFF && expo_num == HDR_3X){
-				p_ae_lines = &ov4689_aeb_expo_lines_3x_hdr;
+				if(lens_mount_id==LENS_MZ128BP2810ICR_ID) {
+				//	lens_param_info.piris_std.dgain = &MZ128BP2810ICR_PIRIS_DGAIN;	//not need for S2L AE
+					lens_param_info.piris_std.scope = MZ128BP2810ICR_PIRIS_SCOPE.table;
+					lens_param_info.piris_std.table = MZ128BP2810ICR_PIRIS_STEP.table;
+					lens_param_info.piris_std.tbl_size = MZ128BP2810ICR_PIRIS_STEP.header.array_size;
+					p_ae_lines = &ov4689_aeb_expo_lines_3x_hdr_mz128bp2810icr;
+				} else {
+					p_ae_lines = &ov4689_aeb_expo_lines_3x_hdr;
+				}
+				p_digit_wdr_param = &ov4689_aeb_digit_wdr_config_3x_hdr;
+			}else{
+				printf("error: can't find the proper ae lines for mode %d, expo num %d\n", \
+					hdr_pipeline, expo_num);
+				return -1;
+			}
+			break;
+		case SENSOR_AR0521:
+			p_sensor_cfg = &ar0521_aeb_sensor_config;
+			p_tile_cfg = &ar0521_aeb_tile_config;
+			p_gain_tbl = &ar0521_aeb_gain_table;
+			p_sht_nl_tbl = &ar0521_aeb_sht_nl_table;
+			p_wb_param = &ar0521_aeb_wb_param;
+
+			if(hdr_pipeline == HDR_PIPELINE_OFF){
+				p_ae_lines = &ar0521_aeb_expo_lines;
+			}else if(hdr_pipeline != HDR_PIPELINE_OFF && expo_num == HDR_2X){
+				p_ae_lines = &ar0521_aeb_expo_lines_2x_hdr;
 			}else{
 				printf("error: can't find the proper ae lines for mode %d, expo num %d\n", \
 					hdr_pipeline, expo_num);
 				return -1;
 			}
 			break;
+
 		case SENSOR_OV5658:
 			p_sensor_cfg = &ov5658_aeb_sensor_config;
 			p_tile_cfg = &ov5658_aeb_tile_config;
@@ -2776,6 +3932,14 @@ int img_aaa_config(int fd_iav, struct vindev_aaa_info* vin_aaa_info, img_config_
 			p_wb_param = &ov5658_aeb_wb_param;
 			p_ae_lines = &ov5658_aeb_expo_lines;
 			break;
+		case SENSOR_OV2735:
+			p_sensor_cfg = &ov2735_aeb_sensor_config;
+			p_tile_cfg = &ov2735_aeb_tile_config;
+			p_gain_tbl = &ov2735_aeb_gain_table;
+			p_sht_nl_tbl = &ov2735_aeb_sht_nl_table;
+			p_wb_param = &ov2735_aeb_wb_param;
+			p_ae_lines = &ov2735_aeb_expo_lines;
+			break;
 		case SENSOR_IMX123:
 			p_sensor_cfg = &imx123_aeb_sensor_config;
 			p_tile_cfg = &imx123_aeb_tile_config;
@@ -2786,9 +3950,11 @@ int img_aaa_config(int fd_iav, struct vindev_aaa_info* vin_aaa_info, img_config_
 			if(hdr_pipeline == HDR_PIPELINE_OFF){
 				p_ae_lines = &imx123_aeb_expo_lines;
 			}else if(hdr_pipeline != HDR_PIPELINE_OFF && expo_num == HDR_2X){
-				p_ae_lines = &imx123_aeb_expo_lines_2x_hdr;
+				p_ae_lines = fake_linear? &imx123_aeb_expo_lines_fake_linear_2x_hdr : \
+					&imx123_aeb_expo_lines_2x_hdr;
 			}else if(hdr_pipeline != HDR_PIPELINE_OFF && expo_num == HDR_3X){
-				p_ae_lines = &imx123_aeb_expo_lines_3x_hdr;
+				p_ae_lines = fake_linear? &imx123_aeb_expo_lines_fake_linear_3x_hdr : \
+					&imx123_aeb_expo_lines_3x_hdr;
 			}else{
 				printf("error: can't find the proper ae lines for mode %d, expo num %d\n", \
 					hdr_pipeline, expo_num);
@@ -2853,6 +4019,14 @@ int img_aaa_config(int fd_iav, struct vindev_aaa_info* vin_aaa_info, img_config_
 				return -1;
 			}
 			break;
+		case SENSOR_IMX185:
+			p_sensor_cfg = &imx185_aeb_sensor_config;
+			p_tile_cfg = &imx185_aeb_tile_config;
+			p_gain_tbl = &imx185_aeb_gain_table;
+			p_sht_nl_tbl = &imx185_aeb_sht_nl_table;
+			p_wb_param = &imx185_aeb_wb_param;
+			p_ae_lines = &imx185_aeb_expo_lines;
+			break;
 		case SENSOR_IMX291:
 			p_sensor_cfg = &imx291_aeb_sensor_config;
 			p_tile_cfg = &imx291_aeb_tile_config;
@@ -2871,9 +4045,45 @@ int img_aaa_config(int fd_iav, struct vindev_aaa_info* vin_aaa_info, img_config_
 			if(hdr_pipeline == HDR_PIPELINE_OFF){
 				p_ae_lines = &imx290_aeb_expo_lines;
 			}else if(hdr_pipeline != HDR_PIPELINE_OFF && expo_num == HDR_2X){
-				p_ae_lines = &imx290_aeb_expo_lines_2x_hdr;
+				p_ae_lines = (fake_linear)? &imx290_aeb_expo_lines_fake_linear_2x_hdr : \
+					&imx290_aeb_expo_lines_2x_hdr;
 			}else if(hdr_pipeline != HDR_PIPELINE_OFF && expo_num == HDR_3X){
-				p_ae_lines = &imx290_aeb_expo_lines_3x_hdr;
+				p_ae_lines = (fake_linear)? &imx290_aeb_expo_lines_fake_linear_3x_hdr : \
+					&imx290_aeb_expo_lines_3x_hdr;
+			}else{
+				printf("error: can't find the proper ae lines for mode %d, expo num %d\n", \
+					hdr_pipeline, expo_num);
+				return -1;
+			}
+			break;
+		case SENSOR_IMX326:
+			p_sensor_cfg = &imx326_aeb_sensor_config;
+			p_tile_cfg = &imx326_aeb_tile_config;
+			p_gain_tbl = &imx326_aeb_gain_table;
+			p_sht_nl_tbl = &imx326_aeb_sht_nl_table;
+			p_wb_param = &imx326_aeb_wb_param;
+
+			if(hdr_pipeline == HDR_PIPELINE_OFF){
+				p_ae_lines = &imx326_aeb_expo_lines;
+			}else if(hdr_pipeline != HDR_PIPELINE_OFF && expo_num == HDR_2X){
+				p_ae_lines = &imx326_aeb_expo_lines_2x_hdr;
+			}else{
+				printf("error: can't find the proper ae lines for mode %d, expo num %d\n", \
+					hdr_pipeline, expo_num);
+				return -1;
+			}
+			break;
+		case SENSOR_IMX377:
+			p_sensor_cfg = &imx377_aeb_sensor_config;
+			p_tile_cfg = &imx377_aeb_tile_config;
+			p_gain_tbl = &imx377_aeb_gain_table;
+			p_sht_nl_tbl = &imx377_aeb_sht_nl_table;
+			p_wb_param = &imx377_aeb_wb_param;
+
+			if(hdr_pipeline == HDR_PIPELINE_OFF){
+				p_ae_lines = &imx377_aeb_expo_lines;
+			}else if(hdr_pipeline != HDR_PIPELINE_OFF && expo_num == HDR_2X){
+				p_ae_lines = &imx377_aeb_expo_lines_2x_hdr;
 			}else{
 				printf("error: can't find the proper ae lines for mode %d, expo num %d\n", \
 					hdr_pipeline, expo_num);
@@ -2919,6 +4129,7 @@ int img_aaa_config(int fd_iav, struct vindev_aaa_info* vin_aaa_info, img_config_
 			p_gain_tbl = &ar0230_aeb_gain_table;
 			p_sht_nl_tbl = &ar0230_aeb_sht_nl_table;
 			p_wb_param = &ar0230_aeb_wb_param;
+			p_auto_knee_param =&ar0230_aeb_auto_knee_config;
 
 			if(hdr_pipeline == HDR_PIPELINE_OFF){
 				p_ae_lines = (hdr_method == HDR_BUILD_IN_METHOD)? \
@@ -2983,8 +4194,11 @@ int img_aaa_config(int fd_iav, struct vindev_aaa_info* vin_aaa_info, img_config_
 	if(img_lens_init() < 0) {
 			return -1;
 	}
-	if(p_auto_knee_cfg){
-		img_config_auto_knee_info(p_auto_knee_cfg);
+	if(p_auto_knee_param){
+		img_config_auto_knee_info(p_auto_knee_param);
+	}
+	if (p_digit_wdr_param) {
+		img_config_digit_wdr_info(p_digit_wdr_param);
 	}
 	return 0;
 }
diff --git a/idsp_test/arch_s2l/make.inc b/idsp_test/arch_s2l/make.inc
index 7031292..9e82287 100644
--- a/idsp_test/arch_s2l/make.inc
+++ b/idsp_test/arch_s2l/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/05 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 LOCAL_PATH	:= $(call my-dir)
@@ -144,6 +161,34 @@ $(LOCAL_TARGET): $(LOCAL_MODULE)
 $(call add-target-into-build, $(LOCAL_TARGET))
 
 ###
+include $(CLEAR_VARS)
+
+LOCAL_TARGET	:= test_yuv_af
+LOCAL_SRCS	:= $(LOCAL_PATH)/test_yuv_af.c $(LOCAL_PATH)/idsp_netlink.c
+LOCAL_LDFLAGS	:= -lpthread -lm
+LOCAL_LIBS	:=
+ifeq ($(BUILD_AMBARELLA_PACKAGES_PROPRIETARY_SOURCES), y)
+ifeq ($(CONFIG_IMGPROC_PACKAGE_DYNAMIC_LIB), y)
+LOCAL_LIBS	+= libimg_algo_s2l.so
+else
+LOCAL_LDFLAGS	+= -L$(AMB_TOPDIR)/prebuild/imgproc/img_lib -limg_algo_s2l
+endif
+else
+LOCAL_LDFLAGS	+= -L$(AMB_TOPDIR)/prebuild/imgproc/img_lib -limg_algo_s2l
+endif
+
+include $(BUILD_APP)
+
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(UNIT_TEST_PATH)/
+	@cp -dpRf $< $(UNIT_TEST_PATH)/
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+
+###
 ifeq ($(BUILD_AMBARELLA_DATATX_PACKAGE), y)
 
 include $(CLEAR_VARS)
diff --git a/idsp_test/arch_s2l/test_af.c b/idsp_test/arch_s2l/test_af.c
index f3bbc0b..f5b08d6 100644
--- a/idsp_test/arch_s2l/test_af.c
+++ b/idsp_test/arch_s2l/test_af.c
@@ -1,16 +1,34 @@
-/**
+/*
  * unit_test/private/idsp_test/arch/test_af.c
  *
  * History:
  *    2015/03/02 - [Peter Jiao] created file
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
- *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
- */
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 
 #include <unistd.h>
diff --git a/idsp_test/arch_s2l/test_raw_seq.c b/idsp_test/arch_s2l/test_raw_seq.c
index 230e136..6f6c297 100644
--- a/idsp_test/arch_s2l/test_raw_seq.c
+++ b/idsp_test/arch_s2l/test_raw_seq.c
@@ -1,3 +1,39 @@
+/*
+ *
+ * idsp_test
+ *
+ * History:
+ *	2015/09/10 - [Jingyang Qiu] Created this file
+ *
+ * Description :
+ *	Load the tuned file which generated by Img tuning tool.
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include <unistd.h>
 #include <stdio.h>
 #include <stdlib.h>
diff --git a/idsp_test/arch_s2l/test_tuning.c b/idsp_test/arch_s2l/test_tuning.c
index d9cf2ee..bbcd397 100644
--- a/idsp_test/arch_s2l/test_tuning.c
+++ b/idsp_test/arch_s2l/test_tuning.c
@@ -1,3 +1,39 @@
+/*
+ *
+ * idsp_test
+ *
+ * History:
+ *	2015/09/10 - [Jingyang Qiu] Created this file
+ *
+ * Description :
+ *	Load the tuned file which generated by Img tuning tool.
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include <unistd.h>
 #include <fcntl.h>
 #include <stdio.h>
@@ -51,6 +87,7 @@ static amba_img_dsp_cfa_leakage_filter_t cfa_leakage_filter;
 static amba_img_dsp_chroma_scale_t cs;
 static aaa_cntl_t aaa_cntl_station;
 static amba_img_dsp_mode_cfg_t ik_mode;
+struct vindev_aaa_info vin_aaa_info;
 static img_config_info_t img_config;
 static hdr_proc_data_t hdr_proc_data;
 static BATCH_CMD_PKG batch_cmd_pkg;
@@ -595,7 +632,7 @@ static void process_apply(int sock_fd,TUNING_ID* p_tuning_id)
 			CfgInfo.Pipe = AMBA_DSP_IMG_PIPE_VIDEO;
 			CfgInfo.CfgId =ik_mode.ConfigId;
 
-			AmbaDSP_ImgLowIsoDumpCfg(CfgInfo, "/mnt/tuning_cfg");
+			AmbaDSP_ImgLowIsoDumpCfg(CfgInfo, "/mnt");
 			AmbaDSP_ImgLowIsoPrintCfg(CfgInfo);
 #endif
 			cfg_id ^= 0x1;
@@ -943,7 +980,8 @@ static void process_apply(int sock_fd,TUNING_ID* p_tuning_id)
 			if((fd_bpc = open("apply_tmp.txt", O_CREAT | O_TRUNC | O_WRONLY, 0777)) < 0) {
 						printf("map file open error!\n");
 			}
-			write(fd_bpc, ituner_buf, size);
+			if(write(fd_bpc, ituner_buf, size)<0)
+				perror("write");
 			close(fd_bpc);*/
 
 			AmbaTUNE_apply_ituner_stream(ituner_buf,size);
@@ -1084,16 +1122,14 @@ int do_init_netlink(void)
 	return 0;
 }
 
-int do_prepare_aaa(void)
+static int get_img_config_and_vin_aaa_info(img_config_info_t* p_img_config,
+	struct vindev_aaa_info*  p_vin_aaa_info)
 {
-	#define	PIXEL_IN_MB			(16)
+	#define PIXEL_IN_MB 		(16)
 	struct vindev_video_info video_info;
-	struct iav_enc_mode_cap mode_cap;
 	struct iav_system_resource system_resource;
 	struct iav_srcbuf_setup	srcbuf_setup;
-	struct vindev_aaa_info vin_aaa_info;
 	int sensor_id = 0x0;
-	img_config_info_t* p_img_config = &img_config;
 
 	memset(p_img_config, 0, sizeof(img_config_info_t));
 
@@ -1109,14 +1145,6 @@ int do_prepare_aaa(void)
 	p_img_config->raw_height = ROUND_UP(video_info.info.height, PIXEL_IN_MB);
 	p_img_config->raw_resolution =video_info.info.bits;
 
-	// encode mode capability
-	memset(&mode_cap, 0, sizeof(mode_cap));
-	mode_cap.encode_mode = DSP_CURRENT_MODE;
-	if (ioctl(fd_iav, IAV_IOC_QUERY_ENC_MODE_CAP, &mode_cap)) {
-		perror("IAV_IOC_QUERY_ENC_MODE_CAP");
-		return -1;
-	}
-
 	// system resource
 	memset(&system_resource, 0, sizeof(system_resource));
 	system_resource.encode_mode = DSP_CURRENT_MODE;
@@ -1151,6 +1179,8 @@ int do_prepare_aaa(void)
 
 	p_img_config->raw_bayer = vin_aaa_info.bayer_pattern;
 	sensor_id = vin_aaa_info.sensor_id;
+	p_img_config->hdr_config.mask = \
+		(vin_aaa_info.ll_mode == 0)? MASK_FULL_HDR : MASK_LINEAR_IN_HDR;
 	if(vin_aaa_info.dual_gain_mode){
 		p_img_config->hdr_config.method = HDR_DUAL_GAIN_METHOD;
 	}else{
@@ -1176,6 +1206,25 @@ int do_prepare_aaa(void)
 		}
 	}
 
+	return 0;
+}
+
+int do_prepare_aaa(void)
+{
+	img_config_info_t* p_img_config = &img_config;
+
+	struct iav_enc_mode_cap mode_cap;
+
+	// encode mode capability
+	memset(&mode_cap, 0, sizeof(mode_cap));
+	mode_cap.encode_mode = DSP_CURRENT_MODE;
+	if (ioctl(fd_iav, IAV_IOC_QUERY_ENC_MODE_CAP, &mode_cap)) {
+		perror("IAV_IOC_QUERY_ENC_MODE_CAP");
+		return -1;
+	}
+
+	get_img_config_and_vin_aaa_info(p_img_config, &vin_aaa_info);
+
 	img_lib_init(fd_iav, p_img_config->defblc_enable, p_img_config->sharpen_b_enable);
 	img_config_pipeline(fd_iav, p_img_config);
 	init_ik_mode(p_img_config, &ik_mode, &mode_cap);
@@ -1287,11 +1336,14 @@ static int show_cmd_menu(void)
 	printf("  r  -- test_ituner -r\n");
 	printf("  t  -- test_ae timing\n");
 	printf("  q -- Return to upper level\n");
+	printf("  m -- quick switch between HDR and Fake linear \n");
 	printf("\n================================================\n\n");
 	printf("G > ");
 	return 0;
 }
 
+extern int img_adj_reset_filter(int index);
+
 void menucmd_thread_proc()
 {
 	char ch;
@@ -1309,7 +1361,7 @@ void menucmd_thread_proc()
 			debug.Step = debug_step;
 			debug.Mode = debug_mode;
 			debug.PicNum =0xFFFFFFFF;
-			//   printf("mode =%d,step=%d,frame =%d\n",debug_mode,debug_step,debug_frame);
+			printf("mode =%d,step=%d,frame =%d\n",debug_mode,debug_step,0);
 			amba_img_dsp_set_debug_mode(&ik_mode, &debug);
 			cfg_id ^= 0x1;
 			ik_mode.ConfigId = cfg_id;
@@ -1326,15 +1378,23 @@ void menucmd_thread_proc()
 			#ifdef DSP_DEBUG
 
 				AMBA_DSP_IMG_DEBUG_MODE_s debug = {0};
-				debug.Step = 0;
-				debug.Mode = 0;
+				printf("pls input lisocfg dump step,mode\n");
+				if(scanf("%d %d",&debug_step,&debug_mode)<0){
+					perror("scanf");
+					break;
+				}
+				debug.Step = debug_step;
+				debug.Mode = debug_mode;
+				debug.PicNum = 3;
+				printf("step =%d, mode = %d, frame =%d\n",debug_step, debug_mode, 3);
 				amba_img_dsp_set_debug_mode(&ik_mode, &debug);
+				amba_img_dsp_post_exe_cfg(fd_iav, &ik_mode, AMBA_DSP_IMG_CFG_EXE_PARTIALCOPY, 1);
 				usleep(1000*1000);
 				static amba_img_dsp_cfg_info_t CfgInfo;
 				CfgInfo.Pipe = AMBA_DSP_IMG_PIPE_VIDEO;
 				CfgInfo.CfgId =ik_mode.ConfigId;
 
-				AmbaDSP_ImgLowIsoDumpCfg(CfgInfo, "/mnt/tuning_cfg");
+				AmbaDSP_ImgLowIsoDumpCfg(CfgInfo, "/mnt");
 				AmbaDSP_ImgLowIsoPrintCfg(CfgInfo);
 			#endif
 			break;
@@ -1345,6 +1405,50 @@ void menucmd_thread_proc()
 		case 't':
 			calc_ae_timing(fd_iav);
 			break;
+		case 'm':
+		{
+			hdr_pipeline_t hdr_pipeline = img_config.hdr_config.pipeline;
+			if (hdr_pipeline != HDR_PIPELINE_OFF) {
+				u8 expo_id = 0;
+				hdr_mask_t mask;
+				u8 meter_mode = AE_CENTER_METERING;
+				hdr_alpha_value_t alp_val;
+				hdr_blend_info_t bld_info;
+
+				printf("set hdr mask (0 : full hdr; 1: fake linear): ");
+				scanf("%d", (int*)&mask);
+				if ((mask == MASK_FULL_HDR) || (mask == MASK_LINEAR_IN_HDR)) {
+					img_get_hdr_alpha_value(&alp_val);
+					img_get_hdr_blend_config(&bld_info);
+					meter_mode = (mask == MASK_LINEAR_IN_HDR)? \
+						AE_CENTER_METERING : AE_EXTERN_DESIGN_METERING;
+					for (expo_id = HDR_2X - 1; expo_id < MAX_HDR_EXPOSURE_NUM; ++ expo_id) {
+						alp_val.value[expo_id] = (mask == MASK_LINEAR_IN_HDR)? 0 : 128;
+					}
+					bld_info.expo_ratio = 24 * HDR_EXPOSURE_RATIO_UNIT;
+					bld_info.boost_factor = (mask == MASK_LINEAR_IN_HDR)? 0 : 128;
+					/* disable ADJ but enable HDR auto-run*/
+					img_enable_adj(0);
+					img_set_hdr_enable((hdr_pipeline != HDR_PIPELINE_OFF));
+					img_set_hdr_alpha_value(&alp_val);
+					img_set_hdr_blend_config(&bld_info);
+					img_set_hdr_quick_switch(fd_iav, &mask);
+					get_img_config_and_vin_aaa_info(&img_config, &vin_aaa_info);
+					img_config.hdr_config.mask = mask;
+					img_config_pipeline(fd_iav, &img_config);
+					load_dynamic_expo_lines(fd_iav, &vin_aaa_info, &img_config);
+					img_set_ae_meter_mode(&meter_mode);
+					img_adj_reset_filter(ADJ_HDR_ALPHA);
+					img_adj_reset_filter(ADJ_HDR_THRESHOLD);
+					/* enable AE/AWB/ADJ/HDR auto-run */
+					img_enable_ae(1);
+					img_enable_awb(1);
+					img_enable_adj(1);
+					img_set_hdr_enable((hdr_pipeline != HDR_PIPELINE_OFF));
+				}
+			}
+			break;
+		}
 		default:
 			error_opt = 1;
 			break;
diff --git a/idsp_test/arch_s2l/test_tuning.h b/idsp_test/arch_s2l/test_tuning.h
index 6e315b9..a915665 100644
--- a/idsp_test/arch_s2l/test_tuning.h
+++ b/idsp_test/arch_s2l/test_tuning.h
@@ -1,19 +1,34 @@
-/********************************************************************
+/*
  * test_tuning.h
  *
  * History:
  *	2012/06/23 - [Teng Huang] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- ********************************************************************/
-
-
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include "ambas_imgproc_arch.h"
 #include "ambas_imgproc_ioctl_arch.h"
@@ -187,8 +202,8 @@ enum ITEM_ID
 	MoDemosaic = '7',
 	MoMisMatchGr_Gb = '8',
 	MoBadPixelCorrection = '9',
-	
-	
+
+
 
 };
 
diff --git a/idsp_test/arch_s2l/test_yuv_af.c b/idsp_test/arch_s2l/test_yuv_af.c
new file mode 100644
index 0000000..b06c2cd
--- /dev/null
+++ b/idsp_test/arch_s2l/test_yuv_af.c
@@ -0,0 +1,532 @@
+/*******************************************************************************
+ * unit_test/private/idsp_test/arch/test_yuv_af.c
+ *
+ * History:
+ *    2017/04/24 - [Peter Jiao] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ( "Software" ) are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+******************************************************************************/
+
+
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <errno.h>
+#include <pthread.h>
+#include <semaphore.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/time.h>
+#include <sys/wait.h>
+#include <time.h>
+#include <assert.h>
+#include <getopt.h>
+#include <sched.h>
+#include <signal.h>
+
+#include "basetypes.h"
+#include "iav_ioctl.h"
+#include "ambas_imgproc_arch.h"
+#include "AmbaDSP_Img3aStatistics.h"
+#include "AmbaDSP_ImgUtility.h"
+
+#include "img_adv_struct_arch.h"
+#include "img_api_adv_arch.h"
+#include "img_customer_interface_arch.h"
+#include <pthread.h>
+#include "idsp_netlink.h"
+
+
+#define ROUND_UP(size, align) (((size) + ((align) - 1)) & ~((align) - 1))
+static pthread_t nl_thread;
+static int fd_iav =-1;
+static amba_img_dsp_mode_cfg_t ik_mode;
+static amba_dsp_aaa_statistic_data_t g_stat;
+static img_aaa_stat_t aaa_stat_info[MAX_HDR_EXPOSURE_NUM];
+
+static struct rgb_aaa_stat rgb_stat[4];
+static struct cfa_aaa_stat cfa_stat[4];
+static struct cfa_pre_hdr_stat hdr_cfa_pre_stat[MAX_PRE_HDR_STAT_BLK_NUM];
+static u8 sensor_hist_stat[SENSOR_HIST_DATA_BLOCK];
+static u8 rgb_stat_valid;
+static u8 cfa_stat_valid;
+static u8 hdr_cfa_pre_valid;
+static u8 sensor_hist_valid;
+
+static aaa_tile_report_t act_tile;
+amba_img_dsp_ae_stat_info_t ae_tile_config;
+amba_img_dsp_awb_stat_info_t awb_tile_config;
+amba_img_dsp_af_stat_info_t af_tile_config;
+static amba_img_dsp_hdr_stat_info_t hdr_stat_config;
+static amba_img_dsp_hist_stat_info_t hist_stat_config;
+
+static pthread_t id;
+static img_config_info_t yuv_work_info;
+static raw_offset_config_t cus_offset_cfg;
+static hdr_proc_data_t cus_hdr_proc_pipe;
+static u8 exit_flag =0;
+
+static statistics_config_t yuv_tile_config ={
+                1,
+                1,
+
+                32,
+                32,
+                0,
+                0,
+                128,
+                128,
+                128,
+                128,
+                0,
+                0x3fff,
+
+                12,
+                8,
+                0,
+                0,
+                340,
+                512,
+
+                12,
+                8,
+                128,
+                8,
+                320,
+                510,
+                320,
+                510,
+
+                0,
+                16383,
+};
+
+static struct aaa_statistics_ex af_eng_cof = {
+	0,					// af_horizontal_filter1_mode;
+	0,					// af_horizontal_filter1_stage1_enb;
+	1,					// af_horizontal_filter1_stage2_enb;
+	0,					// af_horizontal_filter1_stage3_enb;
+	{200, 0, 0, 0, -55, 0, 0},		// af_horizontal_filter1_gain[7];
+	{6, 0, 0, 0},		// af_horizontal_filter1_shift[4];
+	0,					// af_horizontal_filter1_bias_off;
+	0,					// af_horizontal_filter1_thresh;
+	0,					// af_vertical_filter1_thresh;
+	8,					// af_tile_fv1_horizontal_shift;
+	8,					// af_tile_fv1_vertical_shift;
+	168,				// af_tile_fv1_horizontal_weight;
+	87,					// af_tile_fv1_vertical_weight;
+	0,					// af_horizontal_filter2_mode;
+	1,					// af_horizontal_filter2_stage1_enb;
+	1,					// af_horizontal_filter2_stage2_enb;
+	1,					// af_horizontal_filter2_stage3_enb;
+	{188, 467, -235, 375, -184, 276, -206},		// af_horizontal_filter2_gain[7];
+	{7, 2, 2, 0},		// af_horizontal_filter2_shift[4];
+	0,					// af_horizontal_filter2_bias_off;
+	0,					// af_horizontal_filter2_thresh;
+	0,					// af_vertical_filter2_thresh;
+	8,					// af_tile_fv2_horizontal_shift;
+	8,					// af_tile_fv2_vertical_shift;
+	123,				// af_tile_fv2_horizontal_weight;
+	132					// af_tile_fv2_vertical_weight;
+};
+
+
+void yuv_af_loop(void* arg)
+{
+	int fd_iav = (int)arg;
+	int i = 0, tile_cnt = 0;
+	hdr_pipeline_t hdr_pipeline = yuv_work_info.hdr_config.pipeline;
+	isp_pipeline_t isp_pipeline = yuv_work_info.isp_pipeline;
+
+	usleep(200000);
+	while(!exit_flag){
+		if(amba_img_dsp_3a_get_aaa_stat(fd_iav,&ik_mode,&g_stat)<0){
+			printf("amba_img_dsp_3a_get_aaa_stat fail\n");
+			continue;
+		}
+		if(parse_aaa_data(&g_stat, hdr_pipeline, aaa_stat_info, &act_tile)<0){
+			printf("parse_aaa_data fail\n");
+			continue;
+		}
+#if 1
+		printf("\nYUV_INPUT_AF:");
+		tile_cnt = aaa_stat_info[0].rgb_tile_info.af_tile_num_col * aaa_stat_info[0].rgb_tile_info.af_tile_num_row;
+		printf("\nFV1:");
+		for(i=0; i<tile_cnt; i++) {
+			if(i % aaa_stat_info[0].rgb_tile_info.af_tile_num_col == 0)
+				printf("\n");
+			printf("%d,", aaa_stat_info[0].rgb_af_info[i].sum_fv1);
+		}
+		printf("\nFV2:");
+		for(i=0; i<tile_cnt; i++) {
+			if(i % aaa_stat_info[0].rgb_tile_info.af_tile_num_col == 0)
+				printf("\n");
+			printf("%d,", aaa_stat_info[0].rgb_af_info[i].sum_fv2);
+		}
+		printf("\nFY:");
+		for(i=0; i<tile_cnt; i++) {
+			if(i % aaa_stat_info[0].rgb_tile_info.af_tile_num_col == 0)
+				printf("\n");
+			printf("%d,", aaa_stat_info[0].rgb_af_info[i].sum_fy);
+		}
+		printf("\n");
+		sleep(1);
+#endif
+		if((isp_pipeline== ISP_PIPELINE_B_LISO ||isp_pipeline ==ISP_PIPELINE_ADV_LISO)) {
+			amba_img_dsp_post_exe_cfg(fd_iav, &ik_mode, AMBA_DSP_IMG_CFG_EXE_PARTIALCOPY, 0);
+			ik_mode.ConfigId++;
+			ik_mode.ConfigId%=4;
+			amba_img_dsp_post_exe_cfg(fd_iav, &ik_mode, AMBA_DSP_IMG_CFG_EXE_FULLCOPY, 0);
+		}
+	}
+}
+
+void config_stat_tiles(statistics_config_t* tile_cfg)
+{
+	hdr_pipeline_t hdr_pipeline = yuv_work_info.hdr_config.pipeline;
+	u8 expo_num = yuv_work_info.hdr_config.expo_num;
+	int i = 0;
+
+	ae_tile_config.AeTileNumCol   = tile_cfg->ae_tile_num_col;
+	ae_tile_config.AeTileNumRow   = tile_cfg->ae_tile_num_row;
+	ae_tile_config.AeTileColStart = tile_cfg->ae_tile_col_start;
+	ae_tile_config.AeTileRowStart = tile_cfg->ae_tile_row_start;
+	ae_tile_config.AeTileWidth    = tile_cfg->ae_tile_width;
+	ae_tile_config.AeTileHeight   = tile_cfg->ae_tile_height;
+	ae_tile_config.AePixMinValue = tile_cfg->ae_pix_min_value;
+	ae_tile_config.AePixMaxValue = tile_cfg->ae_pix_max_value;
+
+	awb_tile_config.AwbTileNumCol = tile_cfg->awb_tile_num_col;
+	awb_tile_config.AwbTileNumRow = tile_cfg->awb_tile_num_row;
+	awb_tile_config.AwbTileColStart = tile_cfg->awb_tile_col_start;
+	awb_tile_config.AwbTileRowStart = tile_cfg->awb_tile_row_start;
+	awb_tile_config.AwbTileWidth = tile_cfg->awb_tile_width;
+	awb_tile_config.AwbTileHeight = tile_cfg->awb_tile_height;
+	awb_tile_config.AwbTileActiveWidth = tile_cfg->awb_tile_active_width;
+	awb_tile_config.AwbTileActiveHeight = tile_cfg->awb_tile_active_height;
+	awb_tile_config.AwbPixMinValue = tile_cfg->awb_pix_min_value;
+	awb_tile_config.AwbPixMaxValue = tile_cfg->awb_pix_max_value;
+
+	af_tile_config.AfTileNumCol = tile_cfg->af_tile_num_col;
+	af_tile_config.AfTileNumRow = tile_cfg->af_tile_num_row;
+	af_tile_config.AfTileColStart = tile_cfg->af_tile_col_start;
+	af_tile_config.AfTileRowStart = tile_cfg->af_tile_row_start;
+	af_tile_config.AfTileWidth = tile_cfg->af_tile_width;
+	af_tile_config.AfTileHeight = tile_cfg->af_tile_height;
+	af_tile_config.AfTileActiveWidth = tile_cfg->af_tile_active_width;
+	af_tile_config.AfTileActiveHeight = tile_cfg->af_tile_active_height;
+	config_parser_stat_tiles(tile_cfg);
+
+	if(hdr_pipeline != HDR_PIPELINE_OFF){
+		hdr_stat_config.VinStatsMainOn =1;
+		hdr_stat_config.VinStatsHdrOn = 1;
+		hdr_stat_config.TotalExposures = expo_num;
+		hdr_stat_config.TotalSliceInX = 1;
+	}
+
+	hist_stat_config.HistMode = 2;
+	for (i = 0; i < 8; ++i) {
+		hist_stat_config.TileMask[i] = 0xFFF;
+	}
+}
+
+static int start_aaa_init(int fd_iav)
+{
+	#define	PIXEL_IN_MB			(16)
+	img_config_info_t* p_img_config = &yuv_work_info;
+	struct vindev_video_info video_info;
+	struct iav_enc_mode_cap mode_cap;
+	struct iav_system_resource system_resource;
+	struct iav_srcbuf_setup	srcbuf_setup;
+	struct vindev_aaa_info vin_aaa_info;
+	amba_img_dsp_variable_range_t dsp_variable_range;
+
+	// video info
+	memset(&video_info, 0, sizeof(video_info));
+	video_info.vsrc_id = 0;
+	video_info.info.mode = AMBA_VIDEO_MODE_CURRENT;
+	if (ioctl(fd_iav, IAV_IOC_VIN_GET_VIDEOINFO, &video_info) < 0) {
+		perror("IAV_IOC_VIN_GET_VIDEOINFO");
+		return 0;
+	}
+	p_img_config->raw_width = ROUND_UP(video_info.info.width, PIXEL_IN_MB);
+	p_img_config->raw_height = ROUND_UP(video_info.info.height, PIXEL_IN_MB);
+	p_img_config->raw_resolution =video_info.info.bits;
+
+	// encode mode capability
+	memset(&mode_cap, 0, sizeof(mode_cap));
+	mode_cap.encode_mode = DSP_CURRENT_MODE;
+	if (ioctl(fd_iav, IAV_IOC_QUERY_ENC_MODE_CAP, &mode_cap)) {
+		perror("IAV_IOC_QUERY_ENC_MODE_CAP");
+		return -1;
+	}
+
+	// system resource
+	memset(&system_resource, 0, sizeof(system_resource));
+	system_resource.encode_mode = DSP_CURRENT_MODE;
+	if (ioctl(fd_iav, IAV_IOC_GET_SYSTEM_RESOURCE, &system_resource) < 0) {
+		perror("IAV_IOC_GET_SYSTEM_RESOURCE\n");
+		return -1;
+	}
+	p_img_config->hdr_config.expo_num = system_resource.exposure_num;
+	p_img_config->hdr_config.pipeline = system_resource.hdr_type;
+	p_img_config->isp_pipeline = system_resource.iso_type;
+	p_img_config->raw_pitch =system_resource.raw_pitch_in_bytes;
+
+	// source buffer setup
+	memset(&srcbuf_setup, 0, sizeof(srcbuf_setup));
+	if (ioctl(fd_iav, IAV_IOC_GET_SOURCE_BUFFER_SETUP, &srcbuf_setup) < 0) {
+			printf("IAV_IOC_GET_SOURCE_BUFFER_SETUP error\n");
+			return -1;
+	}
+	p_img_config->main_width = ROUND_UP(
+		srcbuf_setup.size[IAV_SRCBUF_MN].width, PIXEL_IN_MB);
+	p_img_config->main_height = ROUND_UP(
+		srcbuf_setup.size[IAV_SRCBUF_MN].height, PIXEL_IN_MB);
+
+	// vin aaa info
+	vin_aaa_info.vsrc_id = 0;
+	if (ioctl(fd_iav, IAV_IOC_VIN_GET_AAAINFO, &vin_aaa_info) < 0) {
+		perror("IAV_IOC_VIN_GET_AAAINFO error\n");
+		return -1;
+	}
+
+	p_img_config->raw_bayer = vin_aaa_info.bayer_pattern;
+	if(vin_aaa_info.dual_gain_mode){
+		p_img_config->hdr_config.method = HDR_DUAL_GAIN_METHOD;
+	}else{
+		switch (vin_aaa_info.hdr_mode){
+			case AMBA_VIDEO_LINEAR_MODE:
+				p_img_config->hdr_config.method = HDR_NONE_METHOD;
+				break;
+			case AMBA_VIDEO_2X_HDR_MODE:
+			case AMBA_VIDEO_3X_HDR_MODE:
+			case AMBA_VIDEO_4X_HDR_MODE:
+				break;
+			case AMBA_VIDEO_INT_HDR_MODE:
+				p_img_config->hdr_config.method = HDR_BUILD_IN_METHOD;
+				break;
+			default:
+				printf("error: invalid vin HDR sensor info.\n");
+				return -1;
+		}
+	}
+
+	// ik mode configuration
+	memset(&ik_mode, 0, sizeof(ik_mode));
+	ik_mode.ConfigId = 0;
+	ik_mode.Pipe = AMBA_DSP_IMG_PIPE_VIDEO;
+	if (p_img_config->hdr_config.pipeline !=HDR_PIPELINE_OFF) {
+		ik_mode.FuncMode = AMBA_DSP_IMG_FUNC_MODE_HDR;
+	}
+	if(p_img_config->isp_pipeline  ==ISP_PIPELINE_B_LISO){
+		ik_mode.AlgoMode = AMBA_DSP_IMG_ALGO_MODE_LISO;
+		ik_mode.BatchId = 0xff;
+		ik_mode.Reserved1 = 0xAA;
+	}
+	else if(p_img_config->isp_pipeline  ==ISP_PIPELINE_LISO){
+		ik_mode.AlgoMode = AMBA_DSP_IMG_ALGO_MODE_FAST;
+	}
+	else if(p_img_config->isp_pipeline  ==ISP_PIPELINE_ADV_LISO||
+		p_img_config->isp_pipeline  ==ISP_PIPELINE_MID_LISO){
+		ik_mode.AlgoMode = AMBA_DSP_IMG_ALGO_MODE_LISO;
+		ik_mode.BatchId = 0xff;
+		ik_mode.Reserved1 = 0xAA;
+	}
+	dsp_variable_range.max_chroma_radius = (1 << (5 + mode_cap.max_chroma_radius));
+	dsp_variable_range.max_wide_chroma_radius = (1 << (5 + mode_cap.max_wide_chroma_radius));
+	dsp_variable_range.inside_fpn_flag = 0;
+	dsp_variable_range.wide_chroma_noise_filter_enable = mode_cap.wcr_possible;
+	amba_img_dsp_set_variable_range(&ik_mode, &dsp_variable_range);
+
+	// init functions
+	adj_config_work_info(p_img_config);		//for img_runtime_adj
+
+	config_stat_tiles(&yuv_tile_config);
+	amba_img_dsp_set_af_statistics_ex(fd_iav, &ik_mode, &af_eng_cof, 1);
+
+	hdr_proc_init(p_img_config, &cus_offset_cfg, &cus_hdr_proc_pipe);
+
+	return 0;
+}
+
+int check_iav_work(void)
+{
+	u32 state;
+	memset(&state, 0, sizeof(state));
+	if (ioctl(fd_iav, IAV_IOC_GET_IAV_STATE, &state) < 0) {
+		perror("IAV_IOC_GET_IAV_STATE");
+		return -1;
+	}
+	if (state == IAV_STATE_PREVIEW || state == IAV_STATE_ENCODING) {
+		return 1;
+	}
+
+	return 0;
+}
+
+void wait_irq_count(int num)
+{
+	do {
+		ioctl(fd_iav, IAV_IOC_WAIT_NEXT_FRAME, 0);
+	} while (--num);
+}
+
+static int do_init_netlink(void)
+{
+	init_netlink();
+	pthread_create(&nl_thread, NULL, (void *)netlink_loop, (void *)NULL);
+
+	while (1) {
+		if (check_iav_work() > 0) {
+			break;
+		}
+		usleep(10000);
+	}
+
+	return 0;
+}
+int do_start_aaa(void)
+{
+	hdr_pipeline_t hdr_pipeline = yuv_work_info.hdr_config.pipeline;
+	isp_pipeline_t isp_pipeline = yuv_work_info.isp_pipeline;
+	hdr_method_t	 hdr_method =yuv_work_info.hdr_config.method;
+	//prepare for get 3A statistics
+	memset(rgb_stat, 0, sizeof(struct rgb_aaa_stat)*4);
+	memset(cfa_stat, 0, sizeof(struct cfa_aaa_stat)*4);
+	memset(hdr_cfa_pre_stat, 0, sizeof(struct cfa_pre_hdr_stat) * MAX_PRE_HDR_STAT_BLK_NUM);
+	memset(sensor_hist_stat, 0, SENSOR_HIST_DATA_BLOCK);
+	rgb_stat_valid = 0;
+	cfa_stat_valid = 0;
+	hdr_cfa_pre_valid = 0;
+	sensor_hist_valid =0;
+
+	memset(&g_stat, 0, sizeof(amba_dsp_aaa_statistic_data_t));
+	g_stat.CfaAaaDataAddr = (u32)cfa_stat;
+	g_stat.RgbAaaDataAddr = (u32)rgb_stat;
+	g_stat.CfaPreHdrDataAddr = (u32)hdr_cfa_pre_stat;
+	g_stat.SensorDataAddr = (hdr_method == HDR_BUILD_IN_METHOD)? (u32)sensor_hist_stat : 0;
+
+	g_stat.CfaDataValid = (u32)&cfa_stat_valid;
+	g_stat.RgbDataValid = (u32)&rgb_stat_valid;
+	g_stat.CfaPreHdrDataValid = (u32)&hdr_cfa_pre_valid;
+	g_stat.SensorDataValid = (hdr_method == HDR_BUILD_IN_METHOD)? (u32)&sensor_hist_valid : 0;
+	//end prepare
+	// the operations within brace must be done after entering preview
+	amba_img_dsp_3a_config_aaa_stat(fd_iav, 1, &ik_mode, &ae_tile_config, &awb_tile_config, &af_tile_config);
+	amba_img_dsp_3a_config_histogram( fd_iav, &ik_mode, &hist_stat_config);
+	if(hdr_pipeline != HDR_PIPELINE_OFF){
+		amba_img_dsp_3a_config_hdr_stat(fd_iav, &ik_mode, &hdr_stat_config);
+	}
+
+	if(isp_pipeline == ISP_PIPELINE_B_LISO||
+	isp_pipeline ==ISP_PIPELINE_ADV_LISO||
+	isp_pipeline ==ISP_PIPELINE_MID_LISO){
+		amba_img_dsp_post_exe_cfg(fd_iav, &ik_mode, AMBA_DSP_IMG_CFG_EXE_PARTIALCOPY, 0);
+		ik_mode.ConfigId ^= 1;
+		amba_img_dsp_post_exe_cfg(fd_iav, &ik_mode, AMBA_DSP_IMG_CFG_EXE_FULLCOPY, 0);
+	}else{
+		img_adj_init_misc(fd_iav, &ik_mode,&yuv_work_info);
+		img_adj_retrieve_filters(fd_iav, &ik_mode);
+	}
+	exit_flag = 0;
+	id = 0;
+	pthread_create(&id, NULL, (void*)yuv_af_loop, (void*)fd_iav);
+
+	printf("YUV_Input_AF Start\n");
+
+	return 0;
+}
+
+int do_prepare_aaa(void)
+{
+	isp_pipeline_t isp_pipeline = yuv_work_info.isp_pipeline;
+	img_lib_init(fd_iav,0,0);
+	start_aaa_init(fd_iav);
+	ik_mode.ConfigId = 0;
+	img_adj_reset_filters();
+
+	printf("YUV_Input_AF Prepare\n");
+
+	if(isp_pipeline ==ISP_PIPELINE_LISO){
+		return 0;
+	}
+
+	img_adj_init_misc(fd_iav, &ik_mode,&yuv_work_info);
+	img_adj_retrieve_filters(fd_iav, &ik_mode);
+	if(isp_pipeline == ISP_PIPELINE_B_LISO||
+		isp_pipeline ==ISP_PIPELINE_ADV_LISO||
+		isp_pipeline ==ISP_PIPELINE_MID_LISO) {
+		if(amba_img_dsp_post_exe_cfg(fd_iav, &ik_mode, AMBA_DSP_IMG_CFG_EXE_PARTIALCOPY, 1)<0)
+			return -1;
+		ik_mode.ConfigId ^= 1;
+		if(amba_img_dsp_post_exe_cfg(fd_iav, &ik_mode, AMBA_DSP_IMG_CFG_EXE_FULLCOPY, 0)<0)
+			return -1;
+		ik_mode.Reserved1 = 0x0;
+	}
+
+	return 0;
+}
+
+int do_stop_aaa(void)
+{
+	if (id != 0) {
+		exit_flag =1;
+		pthread_join(id, NULL);
+	}
+
+	if (img_lib_deinit() < 0) {
+		printf("img_lib_deinit error!\n");
+		return -1;
+	}
+
+	printf("YUV_Input_AF Stop\n");
+
+	return 0;
+}
+
+int main(int argc, char **argv)
+{
+	if ((fd_iav = open("/dev/iav", O_RDWR, 0)) < 0) {
+		perror("open /dev/iav");
+		return -1;
+	}
+
+	if (do_init_netlink() < 0) {
+		return -1;
+	}
+
+	sem_t sem;
+	sem_init(&sem, 0, 0);
+	sem_wait(&sem);
+
+	return 0;
+}
+
diff --git a/idsp_test/arch_s2l/testcase_adj_param.c b/idsp_test/arch_s2l/testcase_adj_param.c
index 340bcab..135dce8 100644
--- a/idsp_test/arch_s2l/testcase_adj_param.c
+++ b/idsp_test/arch_s2l/testcase_adj_param.c
@@ -1,3 +1,39 @@
+/*
+ *
+ * idsp_test
+ *
+ * History:
+ *	2015/09/10 - [Jingyang Qiu] Created this file
+ *
+ * Description :
+ *	Load the tuned file which generated by Img tuning tool.
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include "img_abs_filter.h"
 
 //######LISO ADJ SET
diff --git a/idsp_test/arch_s2l/types.h b/idsp_test/arch_s2l/types.h
index 5beb2f1..0308e4e 100644
--- a/idsp_test/arch_s2l/types.h
+++ b/idsp_test/arch_s2l/types.h
@@ -1,3 +1,38 @@
+/*
+ *
+ * idsp_test
+ *
+ * History:
+ *	2015/09/10 - [Jingyang Qiu] Created this file
+ *
+ * Description :
+ *	Load the tuned file which generated by Img tuning tool.
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #ifndef __TYPES_H
 #define __TYPES_H
diff --git a/idsp_test/arch_s2l/upgrade_adj_bin.c b/idsp_test/arch_s2l/upgrade_adj_bin.c
index 3a28ff4..5d1127a 100644
--- a/idsp_test/arch_s2l/upgrade_adj_bin.c
+++ b/idsp_test/arch_s2l/upgrade_adj_bin.c
@@ -1,4 +1,4 @@
-/**********************************************************************
+/*
  *
  * upgrade_adj_bin.c
  *
@@ -8,14 +8,31 @@
  * Description :
  *	Generate new adj param binary based on input adj param file and tuned file.
  *
- * Copyright (C) 2012 - 2016, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- *********************************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include <unistd.h>
 #include <fcntl.h>
diff --git a/idsp_test/make.inc b/idsp_test/make.inc
index c99d467..fd5776a 100644
--- a/idsp_test/make.inc
+++ b/idsp_test/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/05 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2011-2015, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_UNIT_TESTS_IDSP), y)
diff --git a/make.inc b/make.inc
index 69c0230..5ab2261 100644
--- a/make.inc
+++ b/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/01 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_PRIVATE_LINUX_UNIT_TESTS),y)
diff --git a/mw_test/arch_s2l/fb_image.c b/mw_test/arch_s2l/fb_image.c
index 29b72f9..ac4e3ed 100644
--- a/mw_test/arch_s2l/fb_image.c
+++ b/mw_test/arch_s2l/fb_image.c
@@ -5,14 +5,31 @@
  * History:
  *	2013/08/02 - [Jy Qiu] created file
  *
- * Copyright (C) 2008-2012, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- ***********************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include <wchar.h>
 #include <linux/fb.h>
diff --git a/mw_test/arch_s2l/fb_image.h b/mw_test/arch_s2l/fb_image.h
index 3a50a5a..bea75b3 100644
--- a/mw_test/arch_s2l/fb_image.h
+++ b/mw_test/arch_s2l/fb_image.h
@@ -3,7 +3,30 @@
  * History:
  *	2013/08/06 - [Jingyang Qiu] created file
  *
- * Copyright (C) 2004-2012, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
  */
 #include <unistd.h>
 #include <stdio.h>
diff --git a/mw_test/arch_s2l/make.inc b/mw_test/arch_s2l/make.inc
index ba53924..2fe204e 100644
--- a/mw_test/arch_s2l/make.inc
+++ b/mw_test/arch_s2l/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/06/05 - [HuaiShun Hu] Created file
 ##
-## Copyright (C) 2011-2015, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 
diff --git a/mw_test/make.inc b/mw_test/make.inc
index c1402f5..4784281 100644
--- a/mw_test/make.inc
+++ b/mw_test/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/06/13 - [HuaiShun Hu] Created file
 ##
-## Copyright (C) 2011-2015, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_UNIT_TESTS_MW), y)
diff --git a/package_test/test_convert_openssl_key.cpp b/package_test/test_convert_openssl_key.cpp
new file mode 100644
index 0000000..1717791
--- /dev/null
+++ b/package_test/test_convert_openssl_key.cpp
@@ -0,0 +1,388 @@
+/*******************************************************************************
+ * test_convert_openssl_key.cpp
+ *
+ * History:
+ *  2016/12/01 - [Zhi He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <openssl/bio.h>
+#include <openssl/err.h>
+#include <openssl/evp.h>
+#include <openssl/objects.h>
+#include <openssl/x509.h>
+#include <openssl/pem.h>
+#include <openssl/hmac.h>
+#include <openssl/engine.h>
+
+typedef struct
+{
+    unsigned char convert_public_key;
+    unsigned char convert_private_key;
+    unsigned char reserved1;
+    unsigned char reserved2;
+
+    char *input_file;
+    char *output_file;
+} tcok_context;
+
+static char * __remove_heading_zerozero(char *p, int length)
+{
+    char * t = p;
+    while (2 < length) {
+        if ((t[0] == '0') && t[1] == '0') {
+            t += 2;
+            length -= 2;
+            continue;
+        }
+        break;
+    }
+    return t;
+}
+
+static int __dump_bignumber(char *hex_text, int max_string_buffer_length, BIGNUM *big_num)
+{
+    const char hex_text_table[] = "0123456789ABCDEF";
+    int i = big_num->dmax - 1;
+    BN_ULONG value = 0;
+    char *p_cur = hex_text;
+    int string_length = 0;
+
+#if __WORDSIZE == 64
+    i = big_num->dmax - 1;
+    while (0 <= i) {
+        value = big_num->d[i];
+        p_cur[0] = hex_text_table[(value >> 60) & 0x0f];
+        p_cur[1] = hex_text_table[(value >> 56) & 0x0f];
+        p_cur[2] = hex_text_table[(value >> 52) & 0x0f];
+        p_cur[3] = hex_text_table[(value >> 48) & 0x0f];
+        p_cur[4] = hex_text_table[(value >> 44) & 0x0f];
+        p_cur[5] = hex_text_table[(value >> 40) & 0x0f];
+        p_cur[6] = hex_text_table[(value >> 36) & 0x0f];
+        p_cur[7] = hex_text_table[(value >> 32) & 0x0f];
+        p_cur[8] = hex_text_table[(value >> 28) & 0x0f];
+        p_cur[9] = hex_text_table[(value >> 24) & 0x0f];
+        p_cur[10] = hex_text_table[(value >> 20) & 0x0f];
+        p_cur[11] = hex_text_table[(value >> 16) & 0x0f];
+        p_cur[12] = hex_text_table[(value >> 12) & 0x0f];
+        p_cur[13] = hex_text_table[(value >> 8) & 0x0f];
+        p_cur[14] = hex_text_table[(value >> 4) & 0x0f];
+        p_cur[15] = hex_text_table[(value) & 0x0f];
+        p_cur += 16;
+        string_length += 16;
+        i --;
+        if ((string_length + 16) > max_string_buffer_length) {
+            printf("must have errors, the length exceed!\n");
+            break;
+        }
+    }
+#else
+    i = big_num->dmax - 1;
+    while (0 <= i) {
+        value = big_num->d[i];
+        p_cur[0] = hex_text_table[(value >> 28) & 0x0f];
+        p_cur[1] = hex_text_table[(value >> 24) & 0x0f];
+        p_cur[2] = hex_text_table[(value >> 20) & 0x0f];
+        p_cur[3] = hex_text_table[(value >> 16) & 0x0f];
+        p_cur[4] = hex_text_table[(value >> 12) & 0x0f];
+        p_cur[5] = hex_text_table[(value >> 8) & 0x0f];
+        p_cur[6] = hex_text_table[(value >> 4) & 0x0f];
+        p_cur[7] = hex_text_table[(value) & 0x0f];
+        p_cur += 8;
+        string_length += 8;
+        i --;
+        if ((string_length + 8) > max_string_buffer_length) {
+            printf("must have errors, the length exceed!\n");
+            break;
+        }
+    }
+#endif
+
+    return string_length;
+}
+
+static int dump_rsa_pem_privkey(const char *file, const char *output_file)
+{
+    int ret = 0;
+    BIO *key = NULL;
+    EVP_PKEY *pkey = NULL;
+
+    if ((file == NULL) || (output_file == NULL)) {
+        printf("[error]: no keyfile specified\n");
+        return (-1);
+    }
+
+    key = BIO_new(BIO_s_file());
+    if (key == NULL) {
+        printf("[error]: no memory, BIO_new fail\n");
+        return (-2);
+    }
+
+    ret = BIO_read_filename(key, file);
+    if (ret <= 0) {
+        printf("[error]: BIO_read_filename fail\n");
+        return (-3);
+    }
+
+    pkey = PEM_read_bio_PrivateKey(key, NULL, NULL, NULL);
+
+    BIO_free(key);
+
+    if (pkey) {
+        char max_string_buffer[2048 + 2] = {0};
+        int string_length = 0;
+        char *p_num = NULL;
+
+        FILE *p_out_file = fopen(output_file, "wt+");
+        if (p_out_file) {
+            fprintf(p_out_file, "N = ");
+            string_length = __dump_bignumber((char *)max_string_buffer, 2048, pkey->pkey.rsa->n);
+            max_string_buffer[string_length] = 0x0;
+            p_num = __remove_heading_zerozero(max_string_buffer, string_length);
+            fprintf(p_out_file, "%s", p_num);
+            fprintf(p_out_file, "\r\n");
+
+            fprintf(p_out_file, "E = ");
+            string_length = __dump_bignumber((char *)max_string_buffer, 2048, pkey->pkey.rsa->e);
+            max_string_buffer[string_length] = 0x0;
+            p_num = __remove_heading_zerozero(max_string_buffer, string_length);
+            fprintf(p_out_file, "%s", p_num);
+            fprintf(p_out_file, "\r\n");
+
+            fprintf(p_out_file, "D = ");
+            string_length = __dump_bignumber((char *)max_string_buffer, 2048, pkey->pkey.rsa->d);
+            max_string_buffer[string_length] = 0x0;
+            p_num = __remove_heading_zerozero(max_string_buffer, string_length);
+            fprintf(p_out_file, "%s", p_num);
+            fprintf(p_out_file, "\r\n");
+
+            fprintf(p_out_file, "P = ");
+            string_length = __dump_bignumber((char *)max_string_buffer, 2048, pkey->pkey.rsa->p);
+            max_string_buffer[string_length] = 0x0;
+            p_num = __remove_heading_zerozero(max_string_buffer, string_length);
+            fprintf(p_out_file, "%s", p_num);
+            fprintf(p_out_file, "\r\n");
+
+            fprintf(p_out_file, "Q = ");
+            string_length = __dump_bignumber((char *)max_string_buffer, 2048, pkey->pkey.rsa->q);
+            max_string_buffer[string_length] = 0x0;
+            p_num = __remove_heading_zerozero(max_string_buffer, string_length);
+            fprintf(p_out_file, "%s", p_num);
+            fprintf(p_out_file, "\r\n");
+
+            fprintf(p_out_file, "DP = ");
+            string_length = __dump_bignumber((char *)max_string_buffer, 2048, pkey->pkey.rsa->dmp1);
+            max_string_buffer[string_length] = 0x0;
+            p_num = __remove_heading_zerozero(max_string_buffer, string_length);
+            fprintf(p_out_file, "%s", p_num);
+            fprintf(p_out_file, "\r\n");
+
+            fprintf(p_out_file, "DQ = ");
+            string_length = __dump_bignumber((char *)max_string_buffer, 2048, pkey->pkey.rsa->dmq1);
+            max_string_buffer[string_length] = 0x0;
+            p_num = __remove_heading_zerozero(max_string_buffer, string_length);
+            fprintf(p_out_file, "%s", p_num);
+            fprintf(p_out_file, "\r\n");
+
+            fprintf(p_out_file, "QP = ");
+            string_length = __dump_bignumber((char *)max_string_buffer, 2048, pkey->pkey.rsa->iqmp);
+            max_string_buffer[string_length] = 0x0;
+            p_num = __remove_heading_zerozero(max_string_buffer, string_length);
+            fprintf(p_out_file, "%s", p_num);
+            fprintf(p_out_file, "\r\n");
+
+            fflush(p_out_file);
+            fclose(p_out_file);
+            p_out_file = NULL;
+        }
+
+        EVP_PKEY_free(pkey);
+        pkey = NULL;
+    } else {
+        printf("[error]: PEM_read_bio_PrivateKey fail\n");
+        return (-4);
+    }
+
+    return 0;
+}
+
+static int dump_rsa_pem_pubkey(const char *file, const char *output_file)
+{
+    int ret = 0;
+    BIO *key = NULL;
+    EVP_PKEY *pkey = NULL;
+
+    if ((file == NULL) || (output_file == NULL)) {
+        printf("[error]: no keyfile specified\n");
+        return (-1);
+    }
+
+    key = BIO_new(BIO_s_file());
+    if (key == NULL) {
+        printf("[error]: no memory, BIO_new fail\n");
+        return (-2);
+    }
+
+    ret = BIO_read_filename(key, file);
+    if (ret <= 0) {
+        printf("[error]: BIO_read_filename fail\n");
+        return (-3);
+    }
+
+    pkey = PEM_read_bio_PUBKEY(key, NULL, NULL, NULL);
+
+    BIO_free(key);
+
+    if (pkey) {
+        char max_string_buffer[2048 + 2] = {0};
+        int string_length = 0;
+        char *p_num = NULL;
+
+        FILE *p_out_file = fopen(output_file, "wt+");
+        if (p_out_file) {
+            fprintf(p_out_file, "N = ");
+            string_length = __dump_bignumber((char *)max_string_buffer, 2048, pkey->pkey.rsa->n);
+            max_string_buffer[string_length] = 0x0;
+            p_num = __remove_heading_zerozero(max_string_buffer, string_length);
+            fprintf(p_out_file, "%s", p_num);
+            fprintf(p_out_file, "\r\n");
+
+            fprintf(p_out_file, "E = ");
+            string_length = __dump_bignumber((char *)max_string_buffer, 2048, pkey->pkey.rsa->e);
+            max_string_buffer[string_length] = 0x0;
+            p_num = __remove_heading_zerozero(max_string_buffer, string_length);
+            fprintf(p_out_file, "%s", p_num);
+            fprintf(p_out_file, "\r\n");
+
+            fflush(p_out_file);
+            fclose(p_out_file);
+            p_out_file = NULL;
+        }
+
+        EVP_PKEY_free(pkey);
+        pkey = NULL;
+    } else {
+        printf("[error]: PEM_read_bio_PUBKEY fail\n");
+        return (-4);
+    }
+
+    return 0;
+}
+
+static void __tcok_show_usage()
+{
+    printf("test_convert_openssl_key usage:\n");
+    printf("\t--convert-private convert private key\n");
+    printf("\t--convert-public convert public key\n");
+    printf("\t-i [file name] input file name, (pem)\n");
+    printf("\t-o [file name] output file name, plaint text\n");
+
+    printf("\t--help: show usage\n");
+}
+
+static int __tcok_init_params(int argc, char **argv, tcok_context* context)
+{
+    int i = 0;
+
+    for (i = 1; i < argc; i ++) {
+        if (!strcmp("-i", argv[i])) {
+            if ((i + 1) < argc) {
+                context->input_file = argv[i + 1];
+                printf("[input file]: %s.\n", context->input_file);
+            } else {
+                printf("[input argument error]: '-i', should follow with input file name, argc %d, i %d.\n", argc, i);
+                return (-1);
+            }
+            i ++;
+        } else if (!strcmp("-o", argv[i])) {
+            if ((i + 1) < argc) {
+                context->output_file = argv[i + 1];
+                printf("[output file]: %s.\n", context->output_file);
+            } else {
+                printf("[input argument error]: '-o', should follow with output file name, argc %d, i %d.\n", argc, i);
+                return (-2);
+            }
+            i ++;
+        } else if (!strcmp("--convert-private", argv[i])) {
+            context->convert_private_key = 1;
+        } else if (!strcmp("--convert-public", argv[i])) {
+            context->convert_public_key = 1;
+        } else if (!strcmp("--help", argv[i])) {
+            __tcok_show_usage();
+            return 1;
+        } else {
+            printf("[input argument error]: unknwon input params, [%d][%s]\n", i, argv[i]);
+            return (-20);
+        }
+    }
+
+    return 0;
+}
+
+int main(int argc, char** argv)
+{
+    tcok_context context;
+    memset(&context, 0x0, sizeof(context));
+
+    if (argc < 2) {
+        __tcok_show_usage();
+        return 1;
+    }
+
+    int ret = __tcok_init_params(argc, argv, &context);
+    if (0 > ret) {
+        return ret;
+    }
+
+    if ((!context.input_file) || (!context.output_file)) {
+        printf("input or output file not specidied\n");
+        return (-1);
+    }
+
+    if (1 == context.convert_private_key) {
+        ret = dump_rsa_pem_privkey(context.input_file, context.output_file);
+        if (ret) {
+            printf("[error]: dump_rsa_pem_privkey fail, ret %d\n", ret);
+            return ret;
+        }
+    } else if (1 == context.convert_public_key) {
+        ret = dump_rsa_pem_pubkey(context.input_file, context.output_file);
+        if (ret) {
+            printf("[error]: dump_rsa_pem_pubkey fail, ret %d\n", ret);
+            return ret;
+        }
+    } else {
+        printf("[error]: should set mode, either convert private key, or convert public key\n");
+        return (-10);
+    }
+
+    return 0;
+}
+
diff --git a/package_test/test_cypher.cpp b/package_test/test_cypher.cpp
index d1148a3..cc3dca0 100644
--- a/package_test/test_cypher.cpp
+++ b/package_test/test_cypher.cpp
@@ -4,12 +4,30 @@
  * History:
  *	2015/04/17 - [Zhi He] create file
  *
- * Copyright (C) 2014 - 2024, the Ambarella Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of the Ambarella Inc.
  */
 
 #include <stdio.h>
@@ -48,6 +66,8 @@ static void show_usage()
     printf("\t--iv [iv]\n");
     printf("\t--passphrase [passphrase]\n");
     printf("\t--salt [salt]\n");
+    printf("\t--mode-cbc: CBC mode\n");
+    printf("\t--mode-ctr: CTR mode\n");
 
     printf("\t--help: show usage\n");
 }
@@ -117,6 +137,12 @@ static int init_params(int argc, char **argv, tcypher_context* context)
                 return (-1);
             }
             i ++;
+        } else if (!strcmp("--mode-cbc", argv[i])) {
+            context->cypher_mode = BLOCK_CYPHER_MODE_CBC;
+            printf("[input argument]: '--mode-cbc': CBC mode.\n");
+        } else if (!strcmp("--mode-ctr", argv[i])) {
+            context->cypher_mode = BLOCK_CYPHER_MODE_CTR;
+            printf("[input argument]: '--mode-ctr': CTR mode.\n");
         } else if (!strcmp("--help", argv[i])) {
             show_usage();
             return 1;
@@ -145,7 +171,10 @@ int main(int argc, char** argv)
     memset(&context, 0x0, sizeof(context));
 
     context.cypher_type = CYPHER_TYPE_AES128;
-    context.cypher_mode = BLOCK_CYPHER_MODE_CTR;
+    if (BLOCK_CYPHER_MODE_NONE == context.cypher_type) {
+        context.cypher_mode = BLOCK_CYPHER_MODE_CTR;
+        printf("use CTR mode as default.\n");
+    }
     context.key_len_in_bytes = 16;
 
     if (argc < 2) {
diff --git a/package_test/test_dewarp.c b/package_test/test_dewarp.c
index 903fda6..49c9724 100644
--- a/package_test/test_dewarp.c
+++ b/package_test/test_dewarp.c
@@ -1,17 +1,34 @@
-/********************************************************************
+/*
  * test_dewarp.c
  *
  * History:
  *	2014/03/11 - [Qian Shen] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- ********************************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include <unistd.h>
 #include <fcntl.h>
@@ -42,7 +59,8 @@
 #define HAS_ARG         1
 #define MODE_STRING_LENGTH		(64)
 #define FILENAME_LENGTH			(256)
-#define MAX_PIT_YAW_ANGLE			(90)
+#define MAX_FOV_DEG				(360)
+
 #define BOLD_PRINT(msg, arg...)		printf("\033[1m"msg"\033[22m", arg)
 #define BOLD_PRINT0(msg, arg...)		printf("\033[1m"msg"\033[22m")
 
@@ -92,7 +110,7 @@ static int fd_iav = -1;
 static int current_buffer = -1;
 static int clear_flag = 0;
 static int verbose = 0;
-static int log_level = LOG_INFO;
+static int log_level = AMBA_LOG_INFO;
 static int current_region = -1;
 static int file_flag = 0;
 static int keep_dptz_flag = 0;
@@ -173,6 +191,7 @@ enum numeric_short_options {
 	SPECIFY_MAX_WARP_INPUT_HEIGHT,
 	SPECIFY_MAX_WARP_OUTPUT_WIDTH,
 	SPECIFY_LAZY_MODE,
+	SPECIFY_ROTATE_ANGLE,
 };
 
 static const char *short_opts = "M:R:F:L:C:a:m:s:o:z:h:p:t:r:G:NSWEcf:b:k:vl:Zi:P:Y:";
@@ -187,6 +206,7 @@ static struct option long_opts[] = {
 	{ "mode", HAS_ARG, 0, 'm' },
 	{ "pitch", HAS_ARG, 0, 'P' },
 	{ "yaw", HAS_ARG, 0, 'Y' },
+	{ "rotate", HAS_ARG, 0, SPECIFY_ROTATE_ANGLE },
 	{ "output-size", HAS_ARG, 0, 's' },
 	{ "output-offset", HAS_ARG, 0, 'o' },
 	{ "inter-offset", HAS_ARG, 0, 'i' },
@@ -242,6 +262,7 @@ static const struct hint_s hint[] =
 	{ "0~3", "\t\t0: No transform, 1: Normal, 2: Panorama, 3: Subregion" },
 	{ "-90~90", "\tLens Pitch in degree" },
 	{ "-90~90", "\tLens Yaw in degree" },
+	{ "-10~10", "\tLens Rotate in degree" },
 	{ "axb", "\tOutput size in main source buffer" },
 	{ "axb", "Output offset to the main buffer, default is 0x0" },
 	{ "axb", "Intermediate offset to the intermediate buffer, default is 0x0" },
@@ -498,6 +519,10 @@ static int init_param(int argc, char **argv)
 				break;
 			case 'F':
 				value = atoi(optarg);
+				if (value > MAX_FOV_DEG|| value < 0) {
+					ERROR("Rotate should be within [0~%d]\n", MAX_FOV_DEG);
+					return -1;
+				}
 				dewarp_init_param.max_fov = value;
 				break;
 			case 'L':
@@ -520,22 +545,31 @@ static int init_param(int argc, char **argv)
 				break;
 			case 'P':
 				value = atoi(optarg);
-				if (value > MAX_PIT_YAW_ANGLE || value < -MAX_PIT_YAW_ANGLE) {
-					ERROR("Pitch should be within [%d~%d]\n", -MAX_PIT_YAW_ANGLE,
-						MAX_PIT_YAW_ANGLE);
+				if (value > MAX_PITCH_DEGREE || value < -MAX_PITCH_DEGREE) {
+					ERROR("Pitch should be within [%d~%d]\n", -MAX_PITCH_DEGREE,
+						MAX_PITCH_DEGREE);
 					return -1;
 				}
 				fisheye_region[current_region].pitch = value;
 				break;
 			case 'Y':
 				value = atoi(optarg);
-				if (value > MAX_PIT_YAW_ANGLE || value < -MAX_PIT_YAW_ANGLE) {
-					ERROR("Yaw should be within [%d~%d]\n", -MAX_PIT_YAW_ANGLE,
-						MAX_PIT_YAW_ANGLE);
+				if (value > MAX_YAW_DEGREE || value < -MAX_YAW_DEGREE) {
+					ERROR("Yaw should be within [%d~%d]\n", -MAX_YAW_DEGREE,
+						MAX_YAW_DEGREE);
 					return -1;
 				}
 				fisheye_region[current_region].yaw = value;
 				break;
+			case SPECIFY_ROTATE_ANGLE:
+				value = atoi(optarg);
+				if (value > MAX_ROTATE_DEGREE|| value < -MAX_ROTATE_DEGREE) {
+					ERROR("Rotate should be within [%d~%d]\n", -MAX_ROTATE_DEGREE,
+						MAX_ROTATE_DEGREE);
+					return -1;
+				}
+				fisheye_region[current_region].rotate = value;
+				break;
 			case 's':
 				VERIFY_AREAID(current_region);
 				if (get_two_int(optarg, &first, &second, 'x') < 0)
diff --git a/package_test/test_digital_signature.cpp b/package_test/test_digital_signature.cpp
index 057f915..9212b2c 100644
--- a/package_test/test_digital_signature.cpp
+++ b/package_test/test_digital_signature.cpp
@@ -4,12 +4,29 @@
  * History:
  *	2015/04/03 - [Zhi He] created file
  *
- * Copyright (C) 2015 - 2025, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
diff --git a/package_test/test_eis_warp.c b/package_test/test_eis_warp.c
index 90a6d8d..84b26b9 100644
--- a/package_test/test_eis_warp.c
+++ b/package_test/test_eis_warp.c
@@ -1,17 +1,34 @@
-/*******************************************************************************
+/*
  * test_eis_warp.c
  *
  * History:
  *  Oct 25, 2013 - [qianshen] created file
  *
- * Copyright (C) 2012-2016, Ambarella ShangHai Co,Ltd
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- ******************************************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -43,7 +60,7 @@ static int fd_iav = -1;
 static int fd_eis = -1;
 static int fd_hwtimer = -1;
 static int cali_num = 3000;
-static int debug_level = LOG_INFO;
+static int debug_level = AMBA_LOG_INFO;
 static char save_file[FILENAME_LENGTH] = {0};
 static int save_file_flag = 0;
 static FILE *fd_save_file = NULL;
@@ -185,7 +202,7 @@ static int init_param(int argc, char** argv)
 	return 0;
 }
 
-inline int set_eis_warp(const struct iav_warp_main* warp_main)
+int set_eis_warp(const struct iav_warp_main* warp_main)
 {
 	struct iav_warp_ctrl warp_control;
 	u32 flags = (1 << IAV_WARP_CTRL_MAIN);
@@ -222,7 +239,7 @@ inline int set_eis_warp(const struct iav_warp_main* warp_main)
 	return 0;
 }
 
-inline int get_eis_stat(amba_eis_stat_t* eis_stat)
+int get_eis_stat(amba_eis_stat_t* eis_stat)
 {
 	int i = 0;
 	u64 hw_pts = 0;
@@ -329,7 +346,7 @@ static int prepare(void)
 	EIS_SETUP.vin_cell_width_in_um = (float) vin_eis_info.sensor_cell_width / 100.0;
 	EIS_SETUP.vin_cell_height_in_um = (float) vin_eis_info.sensor_cell_height / 100.0;
 	EIS_SETUP.vin_frame_rate_in_hz = change_fps_to_hz(vsrc_fps.fps);
-	EIS_SETUP.vin_vblank_in_ms = vin_eis_info.row_time * vin_eis_info.vb_lines / 1000000.0;
+	EIS_SETUP.vin_vblank_in_ms = vin_eis_info.vb_time / 1000000.0;
 
 	EIS_SETUP.premain_input_width = vin_info.info.width;
 	EIS_SETUP.premain_input_height = vin_info.info.height;
@@ -444,6 +461,7 @@ static void* fps_monitor_func(void* arg)
 int main(int argc,  char* argv[])
 {
 	version_t version;
+	int eis_selection = 0;
 
 	if (init_param(argc, argv) < 0) {
 		usage();
@@ -482,15 +500,29 @@ int main(int argc,  char* argv[])
 	}
 
 	while (1) {
-		printf(" enable (1: pitch, disable (0):");
+		printf("enable (5: eis_full, 4: rotate + pitch, 3: yaw, 2: rotate, 1: pitch), disable (0):");
 		scanf("%s", input);
-		if (atoi(input)) {
+		eis_selection = atoi(input);
+
+		switch (eis_selection) {
+		case 0:
+			eis_close();
+			break;
+		case 3:
+		case 5:
+			printf("Unsupported option.\n");
+			break;
+		case 1:
+		case 2:
+		case 4:
 			if (eis_open() < 0) {
 				return -1;
 			}
-			eis_enable(atoi(input));
-		} else {
-			eis_close();
+			eis_enable(eis_selection);
+			break;
+		default:
+			printf("Invalid param.\n");
+			break;
 		}
 	}
 
diff --git a/package_test/test_image.c b/package_test/test_image.c
index eefa7e5..5f4cf7e 100644
--- a/package_test/test_image.c
+++ b/package_test/test_image.c
@@ -1,17 +1,34 @@
-/***********************************************************
+/*
  * test_image.c
  *
  * History:
  *	2010/03/25 - [Jian Tang] created file
  *
- * Copyright (C) 2010-2018, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- ***********************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 
 #include <unistd.h>
@@ -50,10 +67,29 @@
 #include "img_customer_interface_arch.h"
 #include "img_api_adv_arch.h"
 
+#define WDR_LUMA_RADIUS_MIN			(0)
+#define WDR_LUMA_RADIUS_MAX			(6)
+#define WDR_LUMA_WEIGHT_MIN			(0)
+#define WDR_LUMA_WEIGHT_MAX			(31)
+
 #define	DIV_ROUND(divident, divider)    (((divident) + ((divider) >> 1)) / (divider))
 #define	SENSOR_STEPS_PER_DB		6
 #define	DEFAULT_CFG_FILE		"/etc/idsp/cfg/test_image.cfg"
 
+#define SCANF_INT(addr)		do {	\
+			if (scanf("%d", addr) < 0) {	\
+				printf("input error.\n");	\
+				return -1;					\
+			}							\
+		} while (0)
+
+#define SCANF_STR(addr)		do {	\
+			if (scanf("%s", addr) < 0) {	\
+				printf("input error.\n");	\
+				return -1;					\
+			}							\
+		} while (0)
+
 typedef enum {
 	FETCH_AAA_STATISTICS = 0,
 } TEST_OPTION;
@@ -109,6 +145,8 @@ static u32	dc_iris_enable		= 0;
 static mw_dc_iris_pid_coef	pid_coef = {2500, 2, 5000};
 static int	load_mctf_flag = 0;
 
+static int auto_dump_cfg_flag = 0;
+
 static int	G_lens_id = LENS_CMOUNT_ID;
 static int	load_file_flag[FILE_TYPE_TOTAL_NUM] = {0};
 static char	G_file_name[FILE_TYPE_TOTAL_NUM][FILE_NAME_LENGTH] = {""};
@@ -314,7 +352,7 @@ static int input_value(int min, int max)
 
 	do {
 		retry = 0;
-		scanf("%s", tmp);
+		SCANF_STR(tmp);
 		for (i = 0; i < MAX_LENGTH; i++) {
 			if ((i == 0) && (tmp[i] == '-')) {
 				continue;
@@ -430,7 +468,10 @@ static int set_sensor_fps(u32 fps)
 		}
 		init_flag = 1;
 	}
-	read(fd_vin, vin_arr, 8);
+	if (read(fd_vin, vin_arr, 8) < 0) {
+		printf("read error.\n");
+		return -1;
+	}
 	if (ioctl(fd_iav, IAV_IOC_VIN_SET_FPS, &vsrc_fps) < 0) {
 		perror("IAV_IOC_VIN_SET_FPS");
 		return -1;
@@ -456,7 +497,7 @@ static int show_global_setting_menu(void)
 	return 0;
 }
 
-static int global_setting(int imgproc_running)
+static int global_setting(int *imgproc_running)
 {
 	int i, exit_flag, error_opt;
 	char ch;
@@ -469,18 +510,18 @@ static int global_setting(int imgproc_running)
 		switch (ch) {
 		case 's':
 			printf("Imgproc library is %srunning.\n",
-				imgproc_running ? "" : "not ");
+				*imgproc_running ? "" : "not ");
 			printf("0 - Stop 3A library, 1 - Start 3A library\n> ");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			if (i == 0) {
-				if (imgproc_running == 1) {
+				if (*imgproc_running == 1) {
 					mw_stop_aaa();
-					imgproc_running = 0;
+					*imgproc_running = 0;
 				}
 			} else if (i == 1) {
-				if (imgproc_running == 0) {
+				if (*imgproc_running == 0) {
 					mw_start_aaa(fd_iav);
-					imgproc_running = 1;
+					*imgproc_running = 1;
 				}
 			} else {
 				printf("Invalid input for this option!\n");
@@ -488,7 +529,7 @@ static int global_setting(int imgproc_running)
 			break;
 		case 'f':
 			printf("Set sensor frame rate : 0 - 29.97, 1 - 30, 2 - 15, 3 - 7.5\n");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			set_sensor_fps(i);
 			update_sensor_fps();
 			break;
@@ -533,11 +574,16 @@ static int show_exposure_setting_menu(void)
 		printf("  g -- Sensor gain max\n");
 		printf("  m -- Set AE metering mode\n");
 		printf("  l -- Get AE current lines\n");
-		printf("  L -- Set AE customer lines\n");
+		//printf("  L -- Set AE customer lines\n");
 		printf("  p -- Set AE switch point\n");
 		printf("  C -- Setting ae area following pre-main input buffer enable and disable\n");
 		printf("  y -- Get Luma value\n");
 		printf("  P -- Piris lens aperture range\n");
+	} else {
+		printf("  x -- Set HDR blend exposure ratio\n");
+		printf("  b -- Set HDR blend boost factor\n");
+		printf("  X -- Get HDR blend exposure ratio and boost factor\n");
+		printf("  c -- Tone Curve enable and disable\n");
 	}
 	printf("  q -- Return to upper level\n");
 	printf("\n================================================\n\n");
@@ -551,6 +597,7 @@ static int exposure_setting(void)
 	char ch;
 	mw_dc_iris_pid_coef pid;
 	mw_ir_led_control_param ir_led_param;
+	mw_hdr_blend_info hdr_blend_cfg;
 
 	mw_ae_metering_table	custom_ae_metering_table[2] = {
 		{	//Left half window as ROI
@@ -593,7 +640,7 @@ static int exposure_setting(void)
 		switch (ch) {
 		case 'E':
 			printf("0 - AE disable  1 - AE enable\n> ");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			if (mw_enable_ae(i) < 0) {
 				printf("mw_enable_ae error\n");
 			}
@@ -606,18 +653,18 @@ static int exposure_setting(void)
 			}
 			if (G_mw_info.res.hdr_expo_num <= MIN_HDR_EXPOSURE_NUM) {
 				printf("Input new exposure level: (range 25 ~ 400)\n> ");
-				scanf("%d", value);
+				SCANF_INT(value);
 			} else {
 				printf("Select the exposure frame index[0~%d]:\n> ",
 					G_mw_info.res.hdr_expo_num -1);
-				scanf("%d", &i);
+				SCANF_INT(&i);
 				if (i >= G_mw_info.res.hdr_expo_num) {
 					printf("Error:The value must be [0~%d]!\n",
 						G_mw_info.res.hdr_expo_num -1);
 					break;
 				}
 				printf("Input new exposure level for exposure frame index %d (25~400)\n> ", i);
-				scanf("%d", &value[i]);
+				SCANF_INT(&value[i]);
 			}
 			if (mw_set_exposure_level(value) < 0) {
 				printf("mw_set_exposure_level error\n");
@@ -625,7 +672,7 @@ static int exposure_setting(void)
 			break;
 		case 'a':
 			printf("Anti-flicker mode? 0 - 50Hz  1 - 60Hz\n> ");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			mw_get_ae_param(&ae_param);
 			ae_param.anti_flicker_mode = i;
 			if (mw_set_ae_param(&ae_param) < 0) {
@@ -633,32 +680,34 @@ static int exposure_setting(void)
 			}
 			break;
 		case 's':
+			if (mw_get_shutter_time(fd_iav, value) < 0) {
+				printf("mw_get_shutter_time error\n");
+				return -1;
+			}
 			if (G_mw_info.res.hdr_expo_num <= MIN_HDR_EXPOSURE_NUM) {
-				mw_get_shutter_time(fd_iav, value);
 				printf("Current shutter time is 1/%d sec.\n",
 					DIV_ROUND(512000000, value[0]));
 				printf("Input new shutter time in 1/n sec format: (range 1 ~ 8000)\n> ");
-				scanf("%d", &value[0]);
+				SCANF_INT(&value[0]);
 				value[0] = DIV_ROUND(512000000, value[0]);
 				if (mw_set_shutter_time(fd_iav, value) < 0) {
 					printf("mw_set_shutter_time error\n");
 				}
 			} else {
 				printf("Current Row hdr shutter mode:\n");
-				mw_get_shutter_time(fd_iav, value);
 				for (i = 0; i < G_mw_info.res.hdr_expo_num; i++) {
 					printf("[%d]: %8d\t", i, DIV_ROUND(512000000, value[i]));
 				}
 				printf("\nInput the new Shutter Frame index[0~%d]:\n> ",
 					G_mw_info.res.hdr_expo_num -1);
-				scanf("%d", &i);
+				SCANF_INT(&i);
 				if (i >= G_mw_info.res.hdr_expo_num) {
 					printf("Error:The value must be [0~%d]!\n",
 						G_mw_info.res.hdr_expo_num -1);
 					break;
 				}
 				printf("Input new Shutter for Frame index %d\n> ", i);
-				scanf("%d", &value[i]);
+				SCANF_INT(&value[i]);
 				value[i] = DIV_ROUND(512000000, value[i]);
 				if  (mw_set_shutter_time(fd_iav, value) < 0) {
 					printf("mw_set_shutter_time error\n");
@@ -670,7 +719,7 @@ static int exposure_setting(void)
 			printf("Current shutter time max is 1/%d sec\n",
 				DIV_ROUND(512000000, ae_param.shutter_time_max));
 			printf("Input new shutter time max in 1/n sec fomat? (Ex, 6, 10, 15...)(slow shutter)\n> ");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			ae_param.shutter_time_max = DIV_ROUND(512000000, i);
 			if (mw_set_ae_param(&ae_param) < 0) {
 				printf("mw_set_ae_param error\n");
@@ -681,7 +730,7 @@ static int exposure_setting(void)
 			printf("Current shutter time min is 1/%d sec\n",
 				DIV_ROUND(512000000, ae_param.shutter_time_min));
 			printf("Input new shutter time min in 1/n sec fomat? (Ex, 120, 200, 400 ...)\n> ");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			ae_param.shutter_time_min = DIV_ROUND(512000000, i);
 			if (mw_set_ae_param(&ae_param) < 0) {
 				printf("mw_set_ae_param error\n");
@@ -692,7 +741,7 @@ static int exposure_setting(void)
 			printf("Current slow shutter mode is %s.\n",
 				ae_param.slow_shutter_enable ? "enabled" : "disabled");
 			printf("Input slow shutter mode? (0 - disable, 1 - enable)\n> ");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			ae_param.slow_shutter_enable = !!i;
 			if (mw_set_ae_param(&ae_param) < 0) {
 				printf("mw_set_ae_param error\n");
@@ -704,11 +753,11 @@ static int exposure_setting(void)
 				printf("Current IR led mode is %d. (0 - off, 1 - on, 2 -- auto)\n",
 					ae_param.ir_led_mode);
 				printf("Input IR led mode? (0 - off, 1 - on, 2 -- auto)\n> ");
-				scanf("%d", &i);
+				SCANF_INT(&i);
 				ae_param.ir_led_mode = i;
 				if (ae_param.ir_led_mode == 1) {
 					printf("Input IR led brightness? (1 ~ 99, 99 - max brightness)\n> ");
-					scanf("%d", &i);
+					SCANF_INT(&i);
 					if (mw_set_ir_led_brightness(i) < 0) {
 						printf("mw_set_ir_led_brightness error\n");
 						break;
@@ -733,19 +782,19 @@ static int exposure_setting(void)
 						ir_led_param.threshold_3X,
 						ir_led_param.open_delay, ir_led_param.close_delay);
 				printf("Input new open_threshold\n> ");
-				scanf("%d", &ir_led_param.open_threshold);
+				SCANF_INT(&ir_led_param.open_threshold);
 				printf("Input new close_threshold\n> ");
-				scanf("%d", &ir_led_param.close_threshold);
+				SCANF_INT(&ir_led_param.close_threshold);
 				printf("Input new threshold_1X\n> ");
-				scanf("%d", &ir_led_param.threshold_1X);
+				SCANF_INT(&ir_led_param.threshold_1X);
 				printf("Input new threshold_2X\n> ");
-				scanf("%d", &ir_led_param.threshold_2X);
+				SCANF_INT(&ir_led_param.threshold_2X);
 				printf("Input new threshold_3X\n> ");
-				scanf("%d", &ir_led_param.threshold_3X);
+				SCANF_INT(&ir_led_param.threshold_3X);
 				printf("Input new open_delay\n> ");
-				scanf("%d", &ir_led_param.open_delay);
+				SCANF_INT(&ir_led_param.open_delay);
 				printf("Input new close_delay\n> ");
-				scanf("%d", &ir_led_param.close_delay);
+				SCANF_INT(&ir_led_param.close_delay);
 				if (mw_set_ir_led_param(&ir_led_param) < 0) {
 					printf("mw_set_ir_led_param error\n");
 				}
@@ -758,7 +807,7 @@ static int exposure_setting(void)
 			printf("Current sensor gain max is %d dB\n",
 				ae_param.sensor_gain_max);
 			printf("Input new sensor gain max in dB? (Ex, 24, 36, 48 ...)\n> ");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			ae_param.sensor_gain_max = i;
 			if (mw_set_ae_param(&ae_param) < 0) {
 				printf("mw_set_ae_param error\n");
@@ -772,7 +821,7 @@ static int exposure_setting(void)
 			if (G_mw_info.res.hdr_expo_num <= MIN_HDR_EXPOSURE_NUM) {
 				printf("Current sensor gain is %d dB\n", value[0] >> 24);
 				printf("Input new sensor gain in dB: (range 0 ~ 36)\n> ");
-				scanf("%d", &value[0]);
+				SCANF_INT(&value[0]);
 				value[0] = value[0] << 24;
 				if  (mw_set_sensor_gain(fd_iav, &value[0]) < 0) {
 					printf("mw_set_sensor_gain error\n");
@@ -785,14 +834,14 @@ static int exposure_setting(void)
 				}
 				printf("\nInput the new AGC Frame index [0~%d]:\n> ",
 					G_mw_info.res.hdr_expo_num -1);
-				scanf("%d", &i);
+				SCANF_INT(&i);
 				if (i >= G_mw_info.res.hdr_expo_num) {
 					printf("Error:The value must be [0~%d]!\n",
 						G_mw_info.res.hdr_expo_num -1);
 					break;
 				}
 				printf("Input new AGC for Frame index %d\n> ", i);
-				scanf("%d", &value[i]);
+				SCANF_INT(&value[i]);
 				value[i] = (value[i] << 24) / G_mw_info.sensor.step;
 				if  (mw_set_sensor_gain(fd_iav, value) < 0) {
 					printf("mw_set_sensor_gain error\n");
@@ -804,13 +853,13 @@ static int exposure_setting(void)
 			mw_get_ae_metering_mode(&ae_param.ae_metering_mode);
 			printf("Current ae metering mode is %d\n", ae_param.ae_metering_mode);
 			printf("Input new ae metering mode:\n> ");
-			scanf("%d", (int *)&ae_param.ae_metering_mode);
+			SCANF_INT((int *)&ae_param.ae_metering_mode);
 			mw_set_ae_metering_mode(ae_param.ae_metering_mode);
 			if (ae_param.ae_metering_mode != MW_AE_CUSTOM_METERING)
 				break;
 			printf("Please choose the AE window:\n");
 			printf("0 - left half window, 1 - right half window\n> ");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			if (mw_set_ae_metering_table(&custom_ae_metering_table[i]) < 0) {
 				printf("mw_set_ae_metering_table error\n");
 			}
@@ -821,7 +870,7 @@ static int exposure_setting(void)
 			break;
 		case 'L':
 			printf("Set customer AE lines: (0: 60Hz, 1: 50Hz, 2: customize)\n> ");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			if ((i != 0) && (i != 1) && (i != 2)) {
 				printf("Invalid input : %d.\n", i);
 				break;
@@ -843,13 +892,13 @@ static int exposure_setting(void)
 		case 'p':
 			printf("Please set switch point in AE lines :\n");
 			printf("Input shutter time in 1/n sec format: (range 30 ~ 120)\n> ");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			switch_point.factor[MW_SHUTTER] = DIV_ROUND(512000000, i);
 			printf("Input switch point of AE line: (0 - start point; 1 - end point)\n> ");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			switch_point.pos = i;
 			printf("Input sensor gain in dB: (range 0 ~ 36)\n> ");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			switch_point.factor[MW_DGAIN] = i;
 			if (mw_set_ae_points(&switch_point, 1) < 0) {
 				printf("mw_set_ae_points error\n");
@@ -860,11 +909,11 @@ static int exposure_setting(void)
 			printf("Current PID coefficients are: p_coef=%d,i_coef=%d,d_coef=%d\n",
 					pid.p_coef, pid.i_coef, pid.d_coef);
 			printf("Input new p_coef\n> ");
-			scanf("%d", &pid.p_coef);
+			SCANF_INT(&pid.p_coef);
 			printf("Input new i_coef\n> ");
-			scanf("%d", &pid.i_coef);
+			SCANF_INT(&pid.i_coef);
 			printf("Input new d_coef\n> ");
-			scanf("%d", &pid.d_coef);
+			SCANF_INT(&pid.d_coef);
 			if (mw_set_dc_iris_pid_coef(&pid) < 0) {
 				printf("mw_set_dc_iris_pid_coef error\n");
 			}
@@ -872,7 +921,7 @@ static int exposure_setting(void)
 		case 'D':
 			if (mw_is_dc_iris_supported()) {
 				printf("DC iris control? 0 - disable  1 - enable\n> ");
-				scanf("%d", &i);
+				SCANF_INT(&i);
 				if (mw_enable_dc_iris_control(i) < 0) {
 					printf("mw_enable_dc_iris_control error\n");
 				}
@@ -885,14 +934,16 @@ static int exposure_setting(void)
 			printf("Current rgb luma value = %d, cfa_luma_value = %d\n", luma.rgb_luma, luma.cfa_luma);
 			break;
 		case 'r':
+			if (mw_get_shutter_time(fd_iav, value) < 0) {
+				printf("mw_get_shutter_time error\n");
+				return -1;
+			}
 			if (G_mw_info.res.hdr_expo_num <= MIN_HDR_EXPOSURE_NUM) {
-				mw_get_shutter_time(fd_iav, value);
 				printf("Current shutter time is 1/%d sec.\n",
 					DIV_ROUND(512000000, value[0]));
 				mw_get_sensor_gain(fd_iav, value);
 				printf("Current sensor gain is %d dB.\n", (value[0] >> 24));
 			} else {
-				mw_get_shutter_time(fd_iav, value);
 				printf("HDR shutter time:\n");
 				for (i = 0; i < G_mw_info.res.hdr_expo_num; i++) {
 					printf("[%d]: 1/%ds\t", i, DIV_ROUND(512000000, value[i]));
@@ -920,7 +971,10 @@ static int exposure_setting(void)
 				(float)(ae_param.lens_aperture.FNO_max) / LENS_FNO_UNIT);
 			printf("Input the new range:(E.x, 1.2, 2.0)\n> ");
 
-			scanf("%f,%f", &lens_aperture[0], &lens_aperture[1]);
+			if (scanf("%f,%f", &lens_aperture[0], &lens_aperture[1]) < 0) {
+				printf("input error.\n");
+				return -1;
+			}
 
 			ae_param.lens_aperture.aperture_min = (u32)(lens_aperture[0] * LENS_FNO_UNIT);
 			ae_param.lens_aperture.aperture_max = (u32)(lens_aperture[1] * LENS_FNO_UNIT);
@@ -930,6 +984,57 @@ static int exposure_setting(void)
 				return -1;
 			}
 			break;
+		case 'x':
+			if (mw_get_hdr_blend_config(&hdr_blend_cfg) < 0) {
+				printf("mw_get_hdr_blend_config failed!\n");
+				return -1;
+			}
+			printf("The current exposure ratio is %d\n", hdr_blend_cfg.expo_ratio);
+			printf("Please input new exposure ratio:\n>");
+			if (scanf("%hu", &hdr_blend_cfg.expo_ratio) < 0) {
+				printf("input error.\n");
+				return -1;
+			}
+			if (mw_set_hdr_blend_config(&hdr_blend_cfg) < 0) {
+				printf("mw_set_hdr_blend_config failed!\n");
+				return -1;
+			}
+			break;
+		case 'b':
+			if (mw_get_hdr_blend_config(&hdr_blend_cfg) < 0) {
+				printf("mw_get_hdr_blend_config failed!\n");
+				return -1;
+			}
+			printf("The current exposure boost is %d\n", hdr_blend_cfg.boost_factor);
+			printf("Please input new boost factor: 0 ~ 256, 0 means no boost\n>");
+			if (scanf("%hu", &hdr_blend_cfg.boost_factor) < 0) {
+				printf("input error.\n");
+				return -1;
+			}
+			if (mw_set_hdr_blend_config(&hdr_blend_cfg) < 0) {
+				printf("mw_set_hdr_blend_config failed!\n");
+				return -1;
+			}
+			break;
+		case 'X':
+			if (mw_get_hdr_blend_config(&hdr_blend_cfg) < 0) {
+				printf("mw_get_hdr_blend_config failed!\n");
+				return -1;
+			}
+			printf("The current exposure ratio is %d, boost factor is %d\n",
+					hdr_blend_cfg.expo_ratio, hdr_blend_cfg.boost_factor);
+			break;
+		case 'c':
+			mw_get_ae_param(&ae_param);
+			printf("Current tone curver duration is %d.\n",
+				ae_param.tone_curve_duration);
+			printf("Input tone curver duration? (1~30 - Update tone curver every n frames)\n> ");
+			SCANF_INT(&i);
+			ae_param.tone_curve_duration = i;
+			if (mw_set_ae_param(&ae_param) < 0) {
+				printf("mw_set_ae_param error\n");
+			}
+			break;
 		case 'q':
 			exit_flag = 1;
 			break;
@@ -976,7 +1081,7 @@ static int white_balance_setting(void)
 		switch (ch) {
 		case 'W':
 			printf("0 - AWB disable  1 - AWB enable\n> ");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			mw_enable_awb(i);
 			break;
 		case 'm':
@@ -989,7 +1094,7 @@ static int white_balance_setting(void)
 				MW_WB_AUTO, MW_WB_MODE_NUMBER -1);
 			printf("0 - auto 1 - 2800K 2 - 4000K 3 - 5000K 4 - 6500K 5 - 7500K");
 			printf(" ... 10 - custom\n> ");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			if (mw_set_white_balance_mode(i) < 0) {
 				printf("mw_set_white_balance_mode error\n");
 			}
@@ -998,7 +1103,7 @@ static int white_balance_setting(void)
 			mw_get_awb_method(&wb_method);
 			printf("Current AWB method is [%d].\n", wb_method);
 			printf("Choose AWB method (0 - Normal, 1 - Custom, 2 - Grey world)\n> ");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			if (mw_set_awb_method(i) < 0) {
 				printf("mw_set_awb_method error\n");
 			}
@@ -1015,7 +1120,11 @@ static int white_balance_setting(void)
 				wb_gain[0].g_gain, wb_gain[0].b_gain);
 			printf("Input new RGB gain for normal method - custom mode \n");
 			printf("(Ex, 1500,1024,1400) \n > ");
-			scanf("%d,%d,%d", &wb_gain[0].r_gain, &wb_gain[0].g_gain, &wb_gain[0].b_gain);
+			if (scanf("%d,%d,%d", &wb_gain[0].r_gain, &wb_gain[0].g_gain,
+				&wb_gain[0].b_gain) < 0) {
+				printf("input error.\n");
+				return -1;
+			}
 
 			printf("Enter normal method:custom mode \n");
 			if (mw_set_awb_method(MW_WB_NORMAL_METHOD) < 0) {
@@ -1177,7 +1286,7 @@ static int adjustment_setting(void)
 			mw_get_saturation(&i);
 			printf("Current saturation is %d\n", i);
 			printf("Input new saturation: (range 0 ~ 255)\n> ");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			if (mw_set_saturation(i) < 0) {
 				printf("mw_set_saturation error\n");
 			}
@@ -1186,7 +1295,7 @@ static int adjustment_setting(void)
 			mw_get_brightness(&i);
 			printf("Current brightness is %d\n", i);
 			printf("Input new brightness: (range -255 ~ 255)\n> ");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			if (mw_set_brightness(i) < 0) {
 				printf("mw_set_brightness error\n");
 			}
@@ -1195,7 +1304,7 @@ static int adjustment_setting(void)
 			mw_get_contrast(&i);
 			printf("Current contrast is %d\n", i);
 			printf("Input new contrast: (range 0 ~ 128)\n> ");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			if (mw_set_contrast(i) < 0) {
 				printf("mw_set_contrast error\n");
 			}
@@ -1204,7 +1313,7 @@ static int adjustment_setting(void)
 			mw_get_sharpness(&i);
 			printf("Current sharpness is %d\n", i);
 			printf("Input new sharpness: (range 0 ~ 11)\n> ");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			if (mw_set_sharpness(i) < 0) {
 				printf("mw_set_sharpness error\n");
 			}
@@ -1212,7 +1321,7 @@ static int adjustment_setting(void)
 		case 'p':
 			printf("Input new sharpness property ratio Index (range 0 ~ %d)\n> ",
 				SHARPEN_PROPERTY_MAX_NUM - 1);
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			if (i  >= SHARPEN_PROPERTY_MAX_NUM || i < 0) {
 				printf("The value must be(0 ~ %d)\n> ",
 					SHARPEN_PROPERTY_MAX_NUM - 1);
@@ -1238,12 +1347,12 @@ static int adjustment_setting(void)
 			break;
 		case 'L':
 			printf("Input the filename of adj param bin:\n> ");
-			scanf("%s", str);
+			SCANF_STR(str);
 			reload_adj_bin_file(str);
 			break;
 		case 'x':
 			printf("Input the filename of adj param bin:\n> ");
-			scanf("%s", str);
+			SCANF_STR(str);
 			save_adj_bin_file(str);
 			break;
 		case 'q':
@@ -1268,7 +1377,6 @@ static int show_enhancement_menu(void)
 	printf("\n================ Image Enhancement Settings ================\n");
 	printf("  m -- Set MCTF 3D noise filter strength\n");
 	if (G_mw_info.res.hdr_expo_num <= MIN_HDR_EXPOSURE_NUM) {
-		printf("  L -- Set auto local exposure mode\n");
 		printf("  l -- Load custom local exposure curve from file\n");
 		printf("  b -- Enable backlight compensation\n");
 		printf("  d -- Enable day and night mode\n");
@@ -1277,6 +1385,7 @@ static int show_enhancement_menu(void)
 		printf("  n -- Set chroma noise filter strength\n");
 		printf("  w -- Set auto wdr strength\n");
 	}
+	printf("  u -- Set wdr luma\n");
 	printf("  j -- ADJ enable and disable\n");
 	printf("  q -- Return to upper level\n");
 	printf("\n================================================\n\n");
@@ -1291,6 +1400,7 @@ static int enhancement_setting(void)
 	u32 value;
 	char str[64];
 	mw_local_exposure_curve local_exposure_curve;
+	mw_wdr_luma_info wdr_luma_info;
 
 	show_enhancement_menu();
 	ch = getchar();
@@ -1302,21 +1412,14 @@ static int enhancement_setting(void)
 			mw_get_mctf_strength(&value);
 			printf("Current mctf strength is %d\n", value);
 			printf("Input new mctf strength: (range 0 ~ 11)\n> ");
-			scanf("%d", &value);
+			SCANF_INT(&value);
 			if (mw_set_mctf_strength(value) < 0) {
 				printf("mw_set_mctf_strength error\n");
 			}
 			break;
-		case 'L':
-			printf("Auto local exposure: 0 - Stop, 1 - Auto, 64~128 - weakest~strongest\n> ");
-			scanf("%d", &i);
-			if (mw_set_auto_local_exposure_mode(i) < 0) {
-				printf("mw_set_auto_local_exposure_mode error\n");
-			}
-			break;
 		case 'l':
 			printf("Input the filename of local exposure curve: (Ex, le_2x.txt)\n> ");
-			scanf("%s", str);
+			SCANF_STR(str);
 			if (load_local_exposure_curve(str, &local_exposure_curve) < 0) {
 				printf("The curve file %s is either found or corrupted!\n", str);
 				return -1;
@@ -1327,14 +1430,14 @@ static int enhancement_setting(void)
 			break;
 		case 'b':
 			printf("Backlight compensation: 0 - disable  1 - enable\n> ");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			if (mw_enable_backlight_compensation(i) < 0) {
 				printf("mw_enable_backlight_compensation error\n");
 			}
 			break;
 		case 'd':
 			printf("Day and night mode: 0 - disable  1 - enable\n> ");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			if (mw_enable_day_night_mode(i) < 0) {
 				printf("mw_enable_day_night_mode error\n");
 			}
@@ -1343,14 +1446,14 @@ static int enhancement_setting(void)
 			mw_get_auto_color_contrast(&value);
 			printf("Current auto contrast control mode is %s\n", value ? "enabled" : "disabled");
 			printf("Auto contrast control mode: 0 - disable  1 - enable\n> ");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			if (mw_set_auto_color_contrast(i) < 0) {
 				printf("mw_set_auto_color_contrast error\n");
 			}
 			break;
 		case 't':
 			printf("Set auto contrast control strength: 0~128, 0: no effect, 128: full effect\n> ");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			if (mw_set_auto_color_contrast_strength(i) < 0) {
 				printf("mw_set_auto_color_contrast_strength error\n");
 			}
@@ -1359,7 +1462,7 @@ static int enhancement_setting(void)
 			mw_get_adj_status(&i);
 			printf("Current ADJ is %s\n", i ? "enabled" : "disabled");
 			printf("Change ADJ mode: 0 - disable  1 - enable\n> ");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			if (mw_enable_adj(i) < 0) {
 				printf("mw_enable_adj error\n");
 			}
@@ -1371,7 +1474,7 @@ static int enhancement_setting(void)
 			}
 			printf("Current chroma_noise_filter strength is %d\n", i);
 			printf("Change chroma_noise_filter strength: 0~256)\n> ");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			if (mw_set_chroma_noise_strength(i) < 0) {
 				printf("mw_set_chroma_noise_strength error");
 			}
@@ -1383,11 +1486,74 @@ static int enhancement_setting(void)
 			}
 			printf("Current auto wdr strength is %d\n", i);
 			printf("Change auto wdr strength: 0~128)\n> ");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			if (mw_set_auto_wdr_strength(i) < 0) {
 				printf("mw_set_auto_wdr_strength error");
 			}
 			break;
+		case 'u':
+			if (mw_get_wdr_luma_config(&wdr_luma_info) < 0) {
+				printf("mw_get_wdr_luma_config error");
+				break;
+			}
+			printf("Current wdr luma config: radius = %d\n", wdr_luma_info.radius);
+			printf("Current wdr luma config: luma_weight_red = %d\n", wdr_luma_info.luma_weight_red);
+			printf("Current wdr luma config: luma_weight_green = %d\n", wdr_luma_info.luma_weight_green);
+			printf("Current wdr luma config: luma_weight_blue = %d\n", wdr_luma_info.luma_weight_blue);
+			printf("Current wdr luma config: luma_weight_shift = %d\n\n\n", wdr_luma_info.luma_weight_shift);
+
+			printf("Now input new wdr luma config:\n");
+			printf("Radius: (%d~%d)\n> ", WDR_LUMA_RADIUS_MIN, WDR_LUMA_RADIUS_MAX);
+			SCANF_INT(&i);
+			if ((i >= WDR_LUMA_RADIUS_MIN) && (i <= WDR_LUMA_RADIUS_MAX)) {
+				wdr_luma_info.radius = i;
+			} else {
+				printf("invalid radius: %d, keep unchanged\n", i);
+			}
+			printf("luma_weight_red: (%d~%d)\n> ", WDR_LUMA_WEIGHT_MIN, WDR_LUMA_WEIGHT_MAX);
+			SCANF_INT(&i);
+			if ((i >= WDR_LUMA_WEIGHT_MIN) && (i <= WDR_LUMA_WEIGHT_MAX)) {
+				wdr_luma_info.luma_weight_red = i;
+			} else {
+				printf("invalid luma_weight_red: %d, keep unchanged\n", i);
+			}
+			printf("luma_weight_green: (%d~%d)\n> ", WDR_LUMA_WEIGHT_MIN, WDR_LUMA_WEIGHT_MAX);
+			SCANF_INT(&i);
+			if ((i >= WDR_LUMA_WEIGHT_MIN) && (i <= WDR_LUMA_WEIGHT_MAX)) {
+				wdr_luma_info.luma_weight_green = i;
+			} else {
+				printf("invalid luma_weight_green: %d, keep unchanged\n", i);
+			}
+			printf("luma_weight_blue: (%d~%d)\n> ", WDR_LUMA_WEIGHT_MIN, WDR_LUMA_WEIGHT_MAX);
+			SCANF_INT(&i);
+			if ((i >= WDR_LUMA_WEIGHT_MIN) && (i <= WDR_LUMA_WEIGHT_MAX)) {
+				wdr_luma_info.luma_weight_blue = i;
+			} else {
+				printf("invalid luma_weight_blue: %d, keep unchanged\n", i);
+			}
+			printf("luma_weight_shift: (%d~%d)\n> ", WDR_LUMA_WEIGHT_MIN, WDR_LUMA_WEIGHT_MAX);
+			SCANF_INT(&i);
+			if ((i >= WDR_LUMA_WEIGHT_MIN) && (i <= WDR_LUMA_WEIGHT_MAX)) {
+				wdr_luma_info.luma_weight_shift = i;
+			} else {
+				printf("invalid luma_weight_shift: %d, keep unchanged\n", i);
+			}
+			if (mw_set_wdr_luma_config(&wdr_luma_info) < 0) {
+				printf("mw_set_wdr_luma_config error");
+			}
+			break;
+		case 'k':
+			if (mw_get_auto_knee_strength(&i) < 0) {
+				printf("mw_get_auto_knee_strength error");
+				break;
+			}
+			printf("Current auto knee strength is %d\n", i);
+			printf("Change auto knee strength: 0~255)\n> ");
+			SCANF_INT(&i);
+			if (mw_set_auto_knee_strength(i) < 0) {
+				printf("mw_set_ae_auto_knee_strenght error\n");
+			}
+			break;
 		case 'q':
 			exit_flag = 1;
 			break;
@@ -1469,7 +1635,7 @@ static int misc_setting(void)
 		switch (ch) {
 		case 'v':
 			printf("Input log level: (0~2)\n> ");
-			scanf("%d", &i);
+			SCANF_INT(&i);
 			mw_set_log_level(i);
 			break;
 		case 'V':
@@ -1600,7 +1766,7 @@ static int display_hist_data(cfa_histogram_stat_t *cfa,
 
 	while (1) {
 		printf("  Please choose the bin number (range 0~63) : ");
-		scanf("%d", &bin_num);
+		SCANF_INT(&bin_num);
 		if ((bin_num >= 0) && (bin_num < total_bin_num))
 			break;
 		printf("  Invalid bin number [%d], choose again!\n", bin_num);
@@ -1930,8 +2096,9 @@ static void sigstop(int signo)
 #define NO_ARG	0
 #define HAS_ARG	1
 
-static const char* short_options = "d:e:i:lt:m:f:L:p:";
+static const char* short_options = "ad:e:i:lt:m:f:L:p:";
 static struct option long_options[] = {
+	{"auto-dump", NO_ARG, 0, 'a'},
 	{"mode", HAS_ARG, 0, 'i'},
 	{"load", NO_ARG, 0, 'l'},
 	{"aeb", HAS_ARG, 0, 'e'},
@@ -1951,6 +2118,7 @@ struct hint_s {
 };
 
 static const struct hint_s hint[] = {
+	{"", "\tauto dump idsp cfg file into /tmp directory when stop AAA under mode 4 in fastboot"},
 	{"0|1|2", "0: background mode, 1:interactive mode, 2: auto test start/stop 3A mode"},
 	{"", "\tload filter binary"},
 	{"", "\tload aeb binary file for 3A params"},
@@ -2031,6 +2199,9 @@ int init_param(int argc, char **argv)
 			G_file_name[FILE_TYPE_CONFIG][sizeof(G_file_name[FILE_TYPE_CONFIG]) - 1] = '\0';
 			load_file_flag[FILE_TYPE_CONFIG] = 1;
 			break;
+		case 'a':
+			auto_dump_cfg_flag = 1;
+			break;
 		default:
 			printf("unknown option %c\n", ch);
 			return -1;
@@ -2079,7 +2250,7 @@ int run_interactive_mode()
 		error_opt = 0;
 		switch (ch) {
 		case 'g':
-			global_setting(imgproc_running_flag);
+			global_setting(&imgproc_running_flag);
 			break;
 		case 'e':
 			exposure_setting();
@@ -2206,6 +2377,9 @@ int main(int argc, char ** argv)
 		}
 	}
 
+	if (auto_dump_cfg_flag) {
+		mw_enable_auto_dump_cfg(auto_dump_cfg_flag);
+	}
 	if (load_mctf_flag) {
 		if (mw_init_mctf(fd_iav) < 0) {
 			perror("mw_load_mctf");
diff --git a/package_test/test_lbr.c b/package_test/test_lbr.c
index 17ac2c4..aba75f5 100644
--- a/package_test/test_lbr.c
+++ b/package_test/test_lbr.c
@@ -5,12 +5,29 @@
  *	2014/02/17 - [Louis Sun] created file
  *	2014/08/18 - [Bin Wang] modified this file and added LBR auto control demo
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
diff --git a/package_test/test_ldc.c b/package_test/test_ldc.c
index b23f85a..f3a3062 100644
--- a/package_test/test_ldc.c
+++ b/package_test/test_ldc.c
@@ -1,17 +1,34 @@
-/********************************************************************
+/*
  * test_dewarp_lens.c
  *
  * History:
  *	2014/02/25 - [Qian Shen] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- ********************************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include <unistd.h>
 #include <fcntl.h>
@@ -37,12 +54,14 @@
 
 #include "lib_dewarp_header.h"
 #include "lib_dewarp.h"
+#include "lens_data.h"
 
 #define NO_ARG          0
 #define HAS_ARG         1
 #define MODE_STRING_LENGTH		(64)
 #define FILENAME_LENGTH			(256)
-#define MAX_PIT_YAW_ANGLE		(90)
+#define MAX_FOV_DEG				(360)
+
 #define BOLD_PRINT(msg, arg...)		printf("\033[1m"msg"\033[22m", arg)
 #define BOLD_PRINT0(msg, arg...)		printf("\033[1m"msg"\033[22m")
 
@@ -61,6 +80,8 @@ enum {
 	WARP_NORMAL = 1,
 	WARP_PANOR = 2,
 	WARP_SUBREGION = 3,
+	WARP_VER_PANOR = 4,
+	WARP_TRANSVERSE_MERCATOR = 5,
 };
 
 typedef struct point_mapping_s {
@@ -78,7 +99,7 @@ typedef struct warp_debug_s {
 static int fd_iav = -1;
 static int clear_flag = 0;
 static int verbose = 0;
-static int log_level = LOG_INFO;
+static int log_level = AMBA_LOG_INFO;
 static int file_flag = 0;
 static char file[FILENAME_LENGTH] = "lens";
 
@@ -94,6 +115,9 @@ rect_in_main_t notrans;
 // Panorama
 static degree_t hor_panor_range;
 
+// [Vertical Panorama / Transverse Mercator]
+static degree_t ver_panor_range;
+
 
 // [Wall] Subregion]
 static pantilt_angle_t pantilt;
@@ -121,6 +145,12 @@ enum numeric_short_options {
 	SPECIFY_FORCE_ZERO = 130,
 	SPECIFY_H_DISABLE,
 	SPECIFY_V_DISABLE,
+	SPECIFY_H_ZOOM,
+	SPECIFY_V_ZOOM,
+	SPECIFY_ROTATE_ANGLE,
+	SPECIFY_VER_PANOR_RANGE,
+	SPECIFY_DEBUG_NOCHECK,
+	SPECIFY_LENS_DATA_BIN_FILE,
 };
 
 static const char *short_opts = "R:F:L:C:m:z:h:p:t:r:cf:vl:P:Y:";
@@ -133,8 +163,12 @@ static struct option long_opts[] = {
 	{ "mode", HAS_ARG, 0, 'm' },
 	{ "pitch", HAS_ARG, 0, 'P' },
 	{ "yaw", HAS_ARG, 0, 'Y' },
+	{ "rotate", HAS_ARG, 0, SPECIFY_ROTATE_ANGLE},
 	{ "zoom", HAS_ARG, 0, 'z' },
+	{ "zh", HAS_ARG, 0, SPECIFY_H_ZOOM },
+	{ "zv", HAS_ARG, 0, SPECIFY_V_ZOOM },
 	{ "hor-range", HAS_ARG, 0, 'h' },
+	{ "ver-range", HAS_ARG, 0, SPECIFY_VER_PANOR_RANGE},
 	{ "pan", HAS_ARG, 0, 'p' },
 	{ "tilt", HAS_ARG, 0, 't' },
 	{ "roi", HAS_ARG, 0, 'r' },
@@ -149,6 +183,8 @@ static struct option long_opts[] = {
 	{ "zero", NO_ARG, 0, SPECIFY_FORCE_ZERO },
 	{ "h-disable", NO_ARG, 0, SPECIFY_H_DISABLE },
 	{ "v-disable", NO_ARG, 0, SPECIFY_V_DISABLE },
+	{ "check-disable", HAS_ARG, 0, SPECIFY_DEBUG_NOCHECK },
+	{ "lens-data", HAS_ARG, 0, SPECIFY_LENS_DATA_BIN_FILE },
 	{ 0, 0, 0, 0 }
 };
 
@@ -158,12 +194,16 @@ static const struct hint_s hint[] =
 	{ "0~360", "\tLens full FOV in degree" },
 	{ "0|1|2", "\tLens projection mode. 0: equidistant (Linear scaled, r = f * theta), 1: Stereographic (conform, r = 2 * f * tan(theta/2), 2: Look up table for r and theta" },
 	{ "axb", "\tLens circle center in pre main." },
-	{ "0~3", "\t\t0: No transform, 1: Normal, 2: Panorama, 3: Subregion" },
+	{ "0~5", "\t\t0: No transform, 1: Normal, 2: Panorama, 3: Subregion, 4: Vertical Panorama, 5: Transverse Mercator" },
 	{ "-90~90", "\tLens Pitch in degree" },
 	{ "-90~90", "\tLens Yaw in degree" },
+	{ "-25~25", "\tLens Rotate in degree" },
 	{ "a/b", "\t\tZoom factor. a<b: zoom out (Wall/Ceiling Normal, Wall Panorama), a>b: zoom in (for all mode expect no transform" },
+	{ "a/b", "\t\tSpecify Horizontal Zoom" },
+	{ "a/b", "\t\tSpecify Vertical Zoom" },
 
 	{ "0~180", "\t(Wall panorama)Panorama horizontal angle." },
+	{ "0~180", "\t(Wall vertical panorama / transverse mercator)Vertical range angle." },
 	{ "-90~90", "\t(Wall Subregion)Pan angle. -90~90 for wall mount." },
 	{ "-90~90", "\t(Wall Subregion)Tilt angle. -90~90 for wall mount." },
 	{ "axb", "\t\t(Wall Subregion) ROI center offset to the circle center. Negative is left/top and positive is right/bottom" },
@@ -180,6 +220,8 @@ static const struct hint_s hint[] =
 	{ "", "\t\tForce warp table content as zero" },
 	{ "", "\t\tDisable H warp" },
 	{ "", "\t\tDisable V warp" },
+	{ "0|1", "Disable dewarp param check"},
+	{ "file", "\tLens data binary file loaded for LUT." },
 };
 
 // first and second values must be in format of "AxB"
@@ -236,8 +278,8 @@ static void usage_examples(char * program_self)
 	printf("Example:\n");
 	BOLD_PRINT0("  Sensor: ov4689\n");
 	BOLD_PRINT0("  Prepare Work:\n");
-	BOLD_PRINT0("    test_encode -i0 -f 30 -V480p --hdmi --enc-mode 4 -X --bsize 2688x1512 --bmaxsize 2688x1512 --lens-warp 1 --max-padding-width 256 -A --smaxsize 2688x1512\n");
 	BOLD_PRINT0("    test_tuning -a\n");
+	BOLD_PRINT0("    test_encode -i0 -f 30 -V480p --hdmi --enc-mode 4 -X --bsize 1920x1080 --bmaxsize 1920x1080 --lens-warp 1 --max-padding-width 256 -A --smaxsize 1920x1080\n");
 
 	printf("\n");
 	printf("0. Clear warping effect\n");
@@ -248,8 +290,21 @@ static void usage_examples(char * program_self)
 	printf("    %s  -F 185 -R 736 -h180 -m %d\n\n", program_self, WARP_PANOR);
 	printf("3.[Wall Lens Pitch/Yaw]  \n");
 	printf("    %s -F 185 -R 736 -m %d -P 10 -Y 10\n\n", program_self, WARP_NORMAL);
-	printf("4.[Panorama Lens Pitch/Yaw]  \n");
-	printf("    %s -F 185 -R 736 -h180 -m %d -P 10 -Y 10\n\n", program_self, WARP_PANOR);
+	printf("4.[Panorama Lens Pitch]  \n");
+	printf("    %s -F 185 -R 736 -h180 -m %d -P 10 \n\n", program_self, WARP_PANOR);
+	printf("5.[Wall Normal]  Do vertical zoom and horizontal zoom separately\n");
+	printf("    %s -F 185 -R 736 -m %d --zh 3/2 --zv 2/1\n\n", program_self, WARP_NORMAL);
+
+	BOLD_PRINT0("  Sensor: ov4689\n");
+	BOLD_PRINT0("  Prepare Work:\n");
+	BOLD_PRINT0("    test_tuning -a\n");
+	BOLD_PRINT0("    test_encode -i0 -f 30 --enc-mode 4 -X --bsize 768x1520 --bmaxsize 768x1520 --lens-warp 1 --max-padding-width 256 -A --smaxsize 768x1520 -J --bmax 768x1520 --btype off\n");
+
+	printf("\n");
+	printf("6.[Wall Vertical Panorama]  Correct horizontal line\n");
+	printf("    %s -F 185 -R 736 -m %d --ver-range 140\n\n", program_self, WARP_VER_PANOR);
+	printf("7.[Wall Transverse Mercator]  Correct horizontal line\n");
+	printf("    %s -F 185 -R 736 -m %d --ver-range 140\n\n", program_self, WARP_TRANSVERSE_MERCATOR);
 }
 
 static void usage(char* program_self)
@@ -269,6 +324,68 @@ static void usage(char* program_self)
 	usage_examples(program_self);
 }
 
+static int load_lens_data_binary_file(const char* file)
+{
+	FILE* fp = NULL;
+	struct amba_lens_info_header_s lens_info_header;
+	struct amba_lens_info_s lens_info;
+	struct iav_srcbuf_setup srcbuf_setup;
+	u16 i, size;
+	int* param = NULL;
+
+	memset(&lens_info_header, 0, sizeof(struct amba_lens_info_header_s));
+	memset(&lens_info, 0, sizeof(struct amba_lens_info_s));
+
+	if ((fp = fopen(file, "rb")) == NULL) {
+		printf("Failed to open file [%s].\n", file);
+		return -1;
+	}
+
+	size = fread(&lens_info_header, 1, sizeof(struct amba_lens_info_header_s), fp);
+	if (size != sizeof(struct amba_lens_info_header_s)) {
+		ERROR("Read size %d is not equal to header size %d\n",
+			size, sizeof(struct amba_lens_info_header_s));
+		fclose(fp);
+		return -1;
+	}
+	if (lens_info_header.magic_number != LENS_DATA_MAGIC_NUM) {
+		ERROR("Magic Number %c\n", LENS_DATA_MAGIC_NUM);
+		fclose(fp);
+		return -1;
+	}
+	if (verbose) {
+		printf("Magic Number: %c\nVersion: %X\n",
+			lens_info_header.magic_number, lens_info_header.version);
+	}
+
+	size = fread(&lens_info, 1, lens_info_header.size, fp);
+	if (size != lens_info_header.size) {
+		ERROR("Read size %d is not equal to lens info size %d\n",
+			size, lens_info_header.size);
+		fclose(fp);
+		return -1;
+	}
+	fclose(fp);
+
+	param = malloc(lens_info.lut_num * sizeof(int));
+	if (!param) {
+		printf("Failed to malloc %d.\n", lens_info.lut_num);
+		return -1;
+	}
+
+	memset(&srcbuf_setup, 0, sizeof(srcbuf_setup));
+	ioctl(fd_iav, IAV_IOC_GET_SOURCE_BUFFER_SETUP, &srcbuf_setup);
+
+	for (i = 0; i < lens_info.lut_num; i++) {
+		param[i] = (int)(lens_info.lut[i] * srcbuf_setup.size[IAV_SRCBUF_PMN].width);
+	}
+
+	dewarp_init_param.lut_radius = param;
+	dewarp_init_param.lut_num = lens_info.lut_num;
+
+	return 0;
+}
+
 static int get_multi_arg_in_premain(char *input_str, int *argarr, int *argcnt, int maxcnt)
 {
 	int i = 0;
@@ -327,7 +444,7 @@ static int get_lut_data_from_file(const char* file)
 	fclose(fp);
 
 	if (left > 0) {
-		printf("Need %d elements in file [%s].\n", num, file);
+		printf("Check elements number and step of degree in lut file [%s]\n", file);
 		return -1;
 	}
 
@@ -339,7 +456,8 @@ static int init_param(int argc, char **argv)
 	int ch, value, first, second;
 	float first_f, second_f;
 	int option_index = 0;
-	char lut_file[FILENAME_LENGTH];
+	char lut_file[FILENAME_LENGTH] = {0};
+	char lens_data_file[FILENAME_LENGTH] = {0};
 
 	opterr = 0;
 
@@ -348,6 +466,10 @@ static int init_param(int argc, char **argv)
 		switch (ch) {
 			case 'F':
 				value = atoi(optarg);
+				if (value > MAX_FOV_DEG || value < 0) {
+					ERROR("Rotate should be within [0, %d]\n", MAX_FOV_DEG);
+					return -1;
+				}
 				dewarp_init_param.max_fov = value;
 				break;
 			case 'L':
@@ -372,25 +494,36 @@ static int init_param(int argc, char **argv)
 					return -1;
 				lens_warp_region.zoom.denom = second;
 				lens_warp_region.zoom.num = first;
+				lens_warp_region.hor_zoom = lens_warp_region.zoom;
+				lens_warp_region.vert_zoom = lens_warp_region.zoom;
 				break;
 			case 'P':
 				value = atoi(optarg);
-				if (value > MAX_PIT_YAW_ANGLE || value < -MAX_PIT_YAW_ANGLE) {
-					ERROR("Pitch should be within [%d~%d]\n", -MAX_PIT_YAW_ANGLE,
-						MAX_PIT_YAW_ANGLE);
+				if (value > MAX_PITCH_DEGREE || value < -MAX_PITCH_DEGREE) {
+					ERROR("Pitch should be within [%d, %d]\n", -MAX_PITCH_DEGREE,
+						MAX_PITCH_DEGREE);
 					return -1;
 				}
 				lens_warp_region.pitch = value;
 				break;
 			case 'Y':
 				value = atoi(optarg);
-				if (value > MAX_PIT_YAW_ANGLE || value < -MAX_PIT_YAW_ANGLE) {
-					ERROR("Yaw should be within [%d~%d]\n", -MAX_PIT_YAW_ANGLE,
-						MAX_PIT_YAW_ANGLE);
+				if (value > MAX_YAW_DEGREE || value < -MAX_YAW_DEGREE) {
+					ERROR("Yaw should be within [%d, %d]\n", -MAX_YAW_DEGREE,
+						MAX_YAW_DEGREE);
 					return -1;
 				}
 				lens_warp_region.yaw = value;
 				break;
+			case SPECIFY_ROTATE_ANGLE:
+				value = atoi(optarg);
+				if (value > MAX_ROTATE_DEGREE || value < -MAX_ROTATE_DEGREE) {
+					ERROR("Rotate should be within [%d, %d]\n", -MAX_ROTATE_DEGREE,
+						MAX_ROTATE_DEGREE);
+					return -1;
+				}
+				lens_warp_region.rotate = value;
+				break;
 			case 'f':
 				value = strlen(optarg);
 				if (value >= FILENAME_LENGTH) {
@@ -404,6 +537,9 @@ static int init_param(int argc, char **argv)
 			case 'h':
 				hor_panor_range = (degree_t) atof(optarg);
 				break;
+			case SPECIFY_VER_PANOR_RANGE:
+				ver_panor_range = (degree_t) atof(optarg);
+				break;
 			case 'p':
 				pantilt.pan = (degree_t) atof(optarg);
 				pantilt_flag = 1;
@@ -430,7 +566,9 @@ static int init_param(int argc, char **argv)
 				notrans.width = first;
 				notrans.height = second;
 				break;
-
+			case SPECIFY_LENS_DATA_BIN_FILE:
+				snprintf(lens_data_file, FILENAME_LENGTH, "%s", optarg);
+				break;
 			case SPECIFY_LUT_EFL:
 				dewarp_init_param.lut_focal_length = atoi(optarg);
 				break;
@@ -456,6 +594,22 @@ static int init_param(int argc, char **argv)
 			case SPECIFY_V_DISABLE:
 				debug_info.v_disable = 1;
 				break;
+			case SPECIFY_DEBUG_NOCHECK:
+				value = atoi(optarg);
+				dewarp_init_param.debug_nocheck_enable = !!value;
+				break;
+			case SPECIFY_H_ZOOM:
+				if (get_two_int(optarg, &first, &second, '/') < 0)
+					return -1;
+				lens_warp_region.hor_zoom.denom = second;
+				lens_warp_region.hor_zoom.num = first;
+				break;
+			case SPECIFY_V_ZOOM:
+				if (get_two_int(optarg, &first, &second, '/') < 0)
+					return -1;
+				lens_warp_region.vert_zoom.denom = second;
+				lens_warp_region.vert_zoom.num = first;
+				break;
 			default:
 				printf("unknown option found: %d\n", ch);
 				return -1;
@@ -464,14 +618,21 @@ static int init_param(int argc, char **argv)
 	}
 
 	if (dewarp_init_param.projection_mode == PROJECTION_LOOKUPTABLE) {
-		if (strlen(lut_file) <= 0) {
-			printf("No look up table file!\n");
-			return -1;
-		}
-		if (get_lut_data_from_file(lut_file) < 0) {
-			printf("Failed to load lens degree-radius table from file [%s].\n",
-			    lut_file);
-			return -1;
+		if (strlen(lens_data_file) > 0) {
+			if (load_lens_data_binary_file(lens_data_file) < 0) {
+				printf("Failed to load lens data file [%s].\n", lens_data_file);
+				return -1;
+			}
+		} else {
+			if (strlen(lut_file) <= 0) {
+				printf("No look up table file!\n");
+				return -1;
+			}
+			if (get_lut_data_from_file(lut_file) < 0) {
+				printf("Failed to load lens degree-radius table from file [%s].\n",
+				    lut_file);
+				return -1;
+			}
 		}
 	}
 
@@ -687,25 +848,44 @@ static int create_lens_warp_vector(void)
 	lens_warp_region.output.height = main_buffer.size.height;
 	lens_warp_region.output.upper_left.x = 0;
 	lens_warp_region.output.upper_left.y = 0;
+
 	switch (lens_warp_mode) {
 		case WARP_NO_TRANSFORM:
 			snprintf(mode_str, MODE_STRING_LENGTH, "No Transform");
 			if (lens_no_transform(&lens_warp_region,
-			    &notrans, &lens_warp_vector) <= 0) {
+				&notrans, &lens_warp_vector) <= 0) {
 				return -1;
 			}
 			break;
 		case WARP_NORMAL:
 			snprintf(mode_str, MODE_STRING_LENGTH, "Wall Normal");
-			if (lens_wall_normal(&lens_warp_region, &lens_warp_vector) <= 0)
+			if (lens_wall_normal(&lens_warp_region, &lens_warp_vector) <= 0) {
 				return -1;
+			}
 			break;
 
 		case WARP_PANOR:
 			snprintf(mode_str, MODE_STRING_LENGTH, "Wall Panorama");
 			if (lens_wall_panorama(&lens_warp_region, hor_panor_range,
-			    &lens_warp_vector) <= 0)
+			    &lens_warp_vector) <= 0) {
 				return -1;
+			}
+			break;
+
+		case WARP_VER_PANOR:
+			snprintf(mode_str, MODE_STRING_LENGTH, "Wall Vertical Panorama");
+			if (lens_wall_vertical_panorama(&lens_warp_region, ver_panor_range,
+				&lens_warp_vector) <= 0) {
+				return -1;
+			}
+			break;
+
+		case WARP_TRANSVERSE_MERCATOR:
+			snprintf(mode_str, MODE_STRING_LENGTH, "Wall Transverse Mercator");
+			if (lens_wall_transverse_mercator(&lens_warp_region, ver_panor_range,
+				&lens_warp_vector) <= 0) {
+				return -1;
+			}
 			break;
 
 		case WARP_SUBREGION:
diff --git a/package_test/test_md5.cpp b/package_test/test_md5.cpp
index c226f97..cb0fd1d 100644
--- a/package_test/test_md5.cpp
+++ b/package_test/test_md5.cpp
@@ -4,12 +4,30 @@
  * History:
  *	2015/07/22 - [Zhi He] create file
  *
- * Copyright (C) 2014 - 2024, the Ambarella Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of the Ambarella Inc.
  */
 
 #include <stdio.h>
diff --git a/package_test/test_md_motbuf.c b/package_test/test_md_motbuf.c
index 679e241..13dda8d 100644
--- a/package_test/test_md_motbuf.c
+++ b/package_test/test_md_motbuf.c
@@ -1,3 +1,35 @@
+/*
+ * test_md_motbuf.cpp
+ *
+ * History:
+ *	2015/07/22 - [Zhi He] create file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
diff --git a/package_test/test_media.cpp b/package_test/test_media.cpp
index cd1a375..3518a17 100644
--- a/package_test/test_media.cpp
+++ b/package_test/test_media.cpp
@@ -5,12 +5,30 @@
  * History:
  *    2015/07/29 - [Zhi He] create file
  *
- * Copyright (C) 2014 - 2024, the Ambarella Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of the Ambarella Inc.
  */
 
 #include <unistd.h>
diff --git a/package_test/test_sha256.cpp b/package_test/test_sha256.cpp
index 697caf4..036a688 100644
--- a/package_test/test_sha256.cpp
+++ b/package_test/test_sha256.cpp
@@ -4,12 +4,30 @@
  * History:
  *	2015/07/22 - [Zhi He] create file
  *
- * Copyright (C) 2014 - 2024, the Ambarella Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of the Ambarella Inc.
  */
 
 #include <stdio.h>
diff --git a/package_test/test_smartrc.c b/package_test/test_smartrc.c
new file mode 100644
index 0000000..860ffbf
--- /dev/null
+++ b/package_test/test_smartrc.c
@@ -0,0 +1,2182 @@
+/*******************************************************************************
+ * test_smartrc.c
+ *
+ * History:
+ *   2015/11/23 - [Victor Xu] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <errno.h>
+#include <getopt.h>
+#include <sched.h>
+#include <pthread.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/time.h>
+#include <sys/wait.h>
+#include <time.h>
+#include <assert.h>
+#include <basetypes.h>
+#include <arm_neon.h>
+#include "config.h"
+#include "lib_smartrc.h"
+#include "lib_smartrc_common.h"
+#include "mdet_diff.h"
+#include "datatx_lib.h"
+
+#define NO_ARG (0)
+#define HAS_ARG (1)
+#define MM_DUMP_BASE (2020)
+#define PC_DUMP_BASE (2025)
+#define PC_DUMP_SIZE (128*30)
+#define ADAPTIVE_STUDY_TIME (3600)
+#define ADAPTIVE_MOTION_HIGH_THRESHOLD (120)
+#define SHIFT_BIT (4)
+#define MB_SIZE (16)
+
+struct hint_s
+{
+	const char *arg;
+	const char *str;
+};
+
+typedef struct smartrc_param_s {
+	u32 stream_quality[SMARTRC_MAX_STREAM_NUM];
+	u32 stream_quality_flag[SMARTRC_MAX_STREAM_NUM];
+
+	u32 bitrate_ceiling[SMARTRC_MAX_STREAM_NUM];
+	u32 bitrate_ceiling_flag[SMARTRC_MAX_STREAM_NUM];
+
+	u32 style[SMARTRC_MAX_STREAM_NUM];
+	u32 style_flag[SMARTRC_MAX_STREAM_NUM];
+
+	u32 motion_level[SMARTRC_MAX_STREAM_NUM];
+	u32 motion_level_flag[SMARTRC_MAX_STREAM_NUM];
+
+	u32 noise_level[SMARTRC_MAX_STREAM_NUM];
+	u32 noise_level_flag[SMARTRC_MAX_STREAM_NUM];
+
+	u32 bitrate_gap_adjust[SMARTRC_MAX_STREAM_NUM];
+	u32 bitrate_gap_adjust_flag[SMARTRC_MAX_STREAM_NUM];
+
+	u32 dump_mot_mat[SMARTRC_MAX_STREAM_NUM];
+	u32 dump_mot_mat_flag[SMARTRC_MAX_STREAM_NUM];
+
+	u32 dump_para_cfg[SMARTRC_MAX_STREAM_NUM];
+	u32 dump_para_cfg_flag[SMARTRC_MAX_STREAM_NUM];
+
+	u32 adaptive_scenario[SMARTRC_MAX_STREAM_NUM];
+	u32 adaptive_scenario_flag[SMARTRC_MAX_STREAM_NUM];
+
+	u32 roi_interval[SMARTRC_MAX_STREAM_NUM];
+	u32 roi_interval_flag[SMARTRC_MAX_STREAM_NUM];
+
+	u32 param_set_flag;
+
+	u32 vca_on_yuv;
+	u32 vca_on_yuv_flag;
+
+	u32 log_level;
+	u32 log_level_flag;
+} smartrc_param_t;
+
+typedef struct file_dump_s {
+	char file[128];
+	s32 fd;
+	u32 size;
+	char *buffer;
+} file_dump_t;
+
+base_param_t base_param;
+
+typedef struct me_buf_s {
+	u32 size;
+	u8 *buffer;
+} me_buf_t;
+
+static s32 fd_iav = -1;
+static u8 *dsp_mem;
+static u32 dsp_size;
+static u32 mem_mapped = 0;
+
+const char default_mt_mat_file[128] = "/tmp/mt_mat";
+static file_dump_t g_mt_mat[SMARTRC_MAX_STREAM_NUM];
+const char default_param_file[128] = "/tmp/param";
+static file_dump_t g_param_cfg[SMARTRC_MAX_STREAM_NUM];
+
+static s32 current_stream_id = -1;
+static u32 stream_selection = 0;
+
+static smartrc_param_t smartrc_params = {
+	.log_level = 1,
+};
+static me_buf_t me_buf[SMARTRC_MAX_STREAM_NUM];
+static encode_config_t g_enc_cfg[SMARTRC_MAX_STREAM_NUM];
+static roi_session_t g_smartrc_session[SMARTRC_MAX_STREAM_NUM];
+
+static mdet_session_t g_ms[SMARTRC_MAX_STREAM_NUM];
+static mdet_cfg g_mdet_cfg[SMARTRC_MAX_STREAM_NUM];
+
+static pthread_t smartrc_thread_id = 0;
+static s32 smartrc_exit_flag = 0;
+
+static u32 motion_value[SMARTRC_MAX_STREAM_NUM] = {0};
+static u32 noise_value[SMARTRC_MAX_STREAM_NUM] = {0};
+static u32 motion_high_cnt[SMARTRC_MAX_STREAM_NUM] = {0};
+
+typedef enum {
+	BUF_ME1_4 = 0,		// ME1 with 1/4 width/height of source buffer
+	BUF_ME1_16 = 1,		// ME1 with 1/16 width/height of source buffer
+	BUF_ME0_8 = 2,		// ME0 with 1/8 width/height of source buffer
+	BUF_ME0_16 = 3,		// ME0 with 1/16 width/height of source buffer
+	BUF_ME0_32 = 4,		// BUF_ME0_32 is 1/4 compression of BUF_ME0_8 for HEVC, since our CTB is 32x32
+} buf_type_t;
+
+static threshold_t g_threshold = {
+	.motion_low = 700,
+	.motion_mid = 10000,
+	.motion_high = 50000,
+	.noise_low = 18,
+	.noise_high = 24,
+};
+
+static delay_t g_delay = {
+	.motion_indicator = 1000000,
+	.motion_none = 10,
+	.motion_low = 10,
+	.motion_mid = 10,
+	.motion_high = 0,
+	.noise_none = 120,
+	.noise_low = 60,
+	.noise_high = 0,
+};
+static const char *short_options = "q:b:m:n:g:t:l:d:f:c:F:a:v:i:sABCD";
+
+static const struct option long_options[] = {
+	{"quality",	HAS_ARG, 0, 'q'}, /*stream quality*/
+	{"bitrate",	HAS_ARG, 0, 'b'}, /*bitrate ceiling*/
+	{"motion",	HAS_ARG, 0, 'm'}, /*inject motion, with a value to indicate the motion level*/
+	{"noise",	HAS_ARG, 0, 'n'}, /*inject noise, with a value to indicate the noise level*/
+	{"gap",		HAS_ARG, 0, 'g'}, /*bitrate gap adjustment*/
+	{"style",	HAS_ARG, 0, 't'}, /*style*/
+	{"log",		HAS_ARG, 0, 'l'}, /*log level*/
+	{"dumpmm",	HAS_ARG, 0, 'd'}, /*dump motion matrix*/
+	{"mmfile",	HAS_ARG, 0, 'f'}, /*specify dump file name*/
+	{"dumpcfg",	HAS_ARG, 0, 'c'}, /*dump stream config*/
+	{"cfgfile",	HAS_ARG, 0, 'F'}, /*specify dump para cfg file*/
+	{"adaptive",HAS_ARG, 0, 'a'}, /*adaptive scenario*/
+	{"vca",		HAS_ARG, 0, 'v'}, /*do vca on yuv to display the motion on the fly*/
+	{"interval",HAS_ARG, 0, 'i'}, /*specify the interval of implementing ROI*/
+	{"base-param-set",NO_ARG, 0, 's'}, /*enable base param setting interface*/
+	{"stream0",	NO_ARG, 0, 'A'}, /*switch current config context to stream A*/
+	{"stream1",	NO_ARG, 0, 'B'}, /*switch current config context to stream B*/
+	{"stream2",	NO_ARG, 0, 'C'}, /*switch current config context to stream C*/
+	{"stream3",	NO_ARG, 0, 'D'}, /*switch current config context to stream D*/
+	{0, 0, 0, 0}
+};
+
+static const struct hint_s hint[] = {
+	{"0~3", "stream quality, 0:low, 1:medium, 2:high, 3:ultimate, default: 0"},
+	{"64000~n", "set bitrate ceiling (per GOP)"},
+	{"0~3", "0:no motion, 1:small motion, 2:middle motion, 3:big motion, default: 3"},
+	{"0~2", "0:no noise, 1:low noise, 2:high noise, default: 2"},
+	{"0~1", "\tbitrate gap adjustment, 1:enable, 0:disable"},
+	{"0~2", "0:full fps auto bitrate, 1:enable fps drop 2:security IPCAM style CBR, default: 0"},
+	{"0~3", "\t0:err, 1:msg, 2:info, 3:dbg, default: 1"},
+	{"0~1", "dump motion matrix, 1:enable, 0:disable, default: 0"},
+	{"*.dat", "file name to store motion matrix, default:/tmp/mt_mat.dat"},
+	{"0~1", "dump param config, 1:enable, 0:disable, default: 0"},
+	{"*.cfg", "file name to store param cfg, default:/tmp/param.cfg"},
+	{"0~1", "adaptive scenario, 1:enable, 0:disable, default: 0"},
+	{"0~1", "\tdo vca on yuv to show motion on the fly, default: 0"},
+	{"1~30", "specify the interval of implementing ROI, default: 1"},
+	{"", "enable base param setting interface"},
+	{"", "\tswitch current config context to stream A"},
+	{"", "\tswitch current config context to stream B"},
+	{"", "\tswitch current config context to stream C"},
+	{"", "\tswitch current config context to stream D"},
+};
+
+static void usage(void)
+{
+	u32 i;
+	for (i = 0; i < sizeof(long_options) / sizeof(long_options[0]) - 1; i++) {
+		if (isalpha(long_options[i].val)) {
+			printf("-%c ", long_options[i].val);
+		} else {
+			printf("	");
+		}
+		printf("--%s", long_options[i].name);
+		if (hint[i].arg[0] != 0) {
+			printf(" [%s]", hint[i].arg);
+		}
+		printf("\t%s\n", hint[i].str);
+	}
+	printf("\nExamples:\n"
+		"  Set stream quality = 2 in stream A:\n"
+		"    test_smartrc -A -q 2\n\n"
+		"  Set bitrate ceiling (bps per GOP) = 1000000 in steam A:\n"
+		"    test_smartrc -A -b 1000000\n\n"
+		"  Set initial motion = 2, initial noise = 1 in stream A :\n"
+		"    test_smartrc -A -m 2 -n 1\n\n"
+		"  Check MDET performance in stream A:\n"
+		"    test_smartrc -A -v 1\n\n"
+		"  Dump parameter configuration in stream A:\n"
+		"    test_smartrc -A -c 1 -F /mnt/param_stream_A.cfg\n\n"
+		"  Specify the interval of implementing ROI = 5 in stream A:\n"
+		"    test_smartrc -A -i 5\n\n"
+		"  Enable smartrc for multi-streams: A, B, C:\n"
+		"    test_smartrc -A -q0 -t0 -B -q0 -t0 -C -q0 -t0 -l1\n\n");
+	printf("\n");
+}
+
+static int init_param(int argc, char **argv)
+{
+	int ch, tmp;
+	int option_index = 0;
+
+	opterr = 0;
+	while ((ch = getopt_long(argc, argv, short_options, long_options, &option_index)) != -1) {
+		switch (ch) {
+		case 'q':
+			VERIFY_STREAM_ID(current_stream_id);
+			tmp = atoi(optarg);
+			if (tmp < QUALITY_FIRST || tmp >= QUALITY_LAST) {
+				printf("Invalid smartrc stream quality!\n");
+				return -1;
+			}
+			smartrc_params.stream_quality[current_stream_id] = tmp;
+			smartrc_params.stream_quality_flag[current_stream_id] = 1;
+			break;
+		case 'b':
+			VERIFY_STREAM_ID(current_stream_id);
+			tmp = atoi(optarg);
+			if ((tmp < 6400) || (tmp > 20 * 1024 * 1024)) {
+				printf("lbr bitrate ceiling setting is wrong \n");
+				return -1;
+			}
+			smartrc_params.bitrate_ceiling[current_stream_id] = tmp;
+			smartrc_params.bitrate_ceiling_flag[current_stream_id] = 1;
+			break;
+		case 'm':
+			VERIFY_STREAM_ID(current_stream_id);
+			tmp = atoi(optarg);
+			if (tmp < MOTION_FIRST || tmp >= MOTION_LAST) {
+				printf("Invalid motion level.\n");
+				return -1;
+			}
+			smartrc_params.motion_level[current_stream_id] = tmp;
+			smartrc_params.motion_level_flag[current_stream_id] = 1;
+			break;
+		case 'n':
+			VERIFY_STREAM_ID(current_stream_id);
+			tmp = atoi(optarg);
+			if (tmp < NOISE_FIRST || tmp >= NOISE_LAST) {
+				printf("Invalid noise level.\n");
+				return -1;
+			}
+			smartrc_params.noise_level[current_stream_id] = tmp;
+			smartrc_params.noise_level_flag[current_stream_id] = 1;
+			break;
+		case 'g':
+			VERIFY_STREAM_ID(current_stream_id);
+			tmp = atoi(optarg);
+			if (tmp < 0 || tmp > 1) {
+				printf("Invalid bitrate gap adjust value.\n");
+				return -1;
+			}
+			smartrc_params.bitrate_gap_adjust[current_stream_id] = tmp;
+			smartrc_params.bitrate_gap_adjust_flag[current_stream_id] = 1;
+			break;
+		case 't':
+			VERIFY_STREAM_ID(current_stream_id);
+			tmp = atoi(optarg);
+			if (tmp < STYLE_FIRST || tmp >= STYLE_LAST) {
+				printf("Invalid smartrc style.\n");
+				return -1;
+			}
+			smartrc_params.style[current_stream_id] = tmp;
+			smartrc_params.style_flag[current_stream_id] = 1;
+			break;
+		case 'l':
+			tmp = atoi(optarg);
+			if (tmp < 0 || tmp > 3) {
+				printf("Invalid log level \n");
+				return -1;
+			}
+			smartrc_params.log_level = tmp;
+			smartrc_params.log_level_flag = 1;
+			break;
+		case 'd':
+			VERIFY_STREAM_ID(current_stream_id);
+			tmp = atoi(optarg);
+			if (tmp < 0 || tmp > 1) {
+				printf("Invalid motion matrix value.\n");
+				return -1;
+			}
+			smartrc_params.dump_mot_mat[current_stream_id] = tmp;
+			smartrc_params.dump_mot_mat_flag[current_stream_id] = 1;
+			break;
+		case 'f':
+			VERIFY_STREAM_ID(current_stream_id);
+			strcpy(g_mt_mat[current_stream_id].file, optarg);
+			break;
+		case 'c':
+			VERIFY_STREAM_ID(current_stream_id);
+			tmp = atoi(optarg);
+			if (tmp < 0 || tmp > 1) {
+				printf("Invalid dump para config value.\n");
+				return -1;
+			}
+			smartrc_params.dump_para_cfg[current_stream_id] = tmp;
+			smartrc_params.dump_para_cfg_flag[current_stream_id] = 1;
+			break;
+		case 'F':
+			VERIFY_STREAM_ID(current_stream_id);
+			strcpy(g_param_cfg[current_stream_id].file, optarg);
+			break;
+		case 'a':
+			VERIFY_STREAM_ID(current_stream_id);
+			tmp = atoi(optarg);
+			if (tmp < 0 || tmp > 1) {
+				printf("Invalid adaptive scenario value.\n");
+				return -1;
+			}
+			smartrc_params.adaptive_scenario[current_stream_id] = tmp;
+			smartrc_params.adaptive_scenario_flag[current_stream_id] = 1;
+			break;
+		case 'v':
+			tmp = atoi(optarg);
+			if (tmp < 0 || tmp > 1) {
+				printf("Invalid vca on yuv value.\n");
+				return -1;
+			}
+			smartrc_params.vca_on_yuv = tmp;
+			smartrc_params.vca_on_yuv_flag = 1;
+			break;
+		case 'i':
+			VERIFY_STREAM_ID(current_stream_id);
+			tmp = atoi(optarg);
+			if (tmp < 1 || tmp > 30) {
+				printf("Invalid interval value.\n");
+				return -1;
+			}
+			smartrc_params.roi_interval[current_stream_id] = tmp;
+			smartrc_params.roi_interval_flag[current_stream_id] = 1;
+			break;
+		case 's':
+			smartrc_params.param_set_flag = 1;
+			break;
+		case 'A':
+			current_stream_id = 0;
+			stream_selection |= (1<<current_stream_id);
+			break;
+		case 'B':
+			current_stream_id = 1;
+			stream_selection |= (1<<current_stream_id);
+			break;
+		case 'C':
+			current_stream_id = 2;
+			stream_selection |= (1<<current_stream_id);
+			break;
+		case 'D':
+			current_stream_id = 3;
+			stream_selection |= (1<<current_stream_id);
+			break;
+		default:
+			printf("Unknown option found: %c\n", ch);
+			return -1;
+		}
+	}
+	return 0;
+}
+
+static void show_param_setting(void)
+{
+	motion_level_t motion;
+	noise_level_t noise;
+	quality_level_t quality;
+	u32 log_level;
+
+	printf("Current stream_id is %c\n", current_stream_id + 'A');
+	smartrc_get_stream_quality(&quality, current_stream_id);
+	printf("Current stream %c's stream quality is ", current_stream_id + 'A');
+	switch (quality) {
+	case 0:
+		printf("Low Quality");
+		break;
+	case 1:
+		printf("Medium Quality");
+		break;
+	case 2:
+		printf("High Quality");
+		break;
+	case 3:
+		printf("Ultimate Quality");
+		break;
+	default:
+		printf("Invalid Value");
+		break;
+	}
+	printf("\n");
+
+	smartrc_get_motion_level(&motion, current_stream_id);
+	printf("Current stream %c's motion level is ", current_stream_id + 'A');
+	switch (motion) {
+	case 0:
+		printf("No Motion");
+		break;
+	case 1:
+		printf("Small Motion");
+		break;
+	case 2:
+		printf("Middle Motion");
+		break;
+	case 3:
+		printf("Big Motion");
+		break;
+	default:
+		printf("Invalid Value\n");
+		break;
+	}
+	printf("\n");
+
+	smartrc_get_noise_level(&noise, current_stream_id);
+	printf("Current stream %c's noise level is ", current_stream_id + 'A');
+	switch (noise) {
+	case 0:
+		printf("No Noise");
+		break;
+	case 1:
+		printf("Low Noise");
+		break;
+	case 2:
+		printf("High Noise");
+		break;
+	default:
+		printf("Invalid Value\n");
+		break;
+	}
+	printf("\n");
+
+	smartrc_get_log_level(&log_level);
+	printf("Current log level is %d\n", log_level);
+}
+
+static int show_menu(void)
+{
+	printf("\n================================================\n");
+	printf("	s -- Show parameters\n");
+	printf("	q -- Quit");
+	printf("\n================================================\n");
+	printf("> ");
+	return 0;
+}
+
+static int show_set_control_table_menu(void)
+{
+	printf("\n================================================\n");
+	printf(">>parameter setting List\n\n");
+	printf("	a. bitrate_target\n");
+	printf("	b. gop\n");
+	printf("	c. qp_params\n");
+	printf("	d. roi_params\n\n");
+	printf("	q -- Quit");
+	printf("\n================================================\n");
+	printf("> ");
+
+	return 0;
+}
+
+static int show_quality()
+{
+	printf("\n================================================\n");
+	printf(">>Quality List\n\n");
+	printf("	a. quality low\n");
+	printf("	b. quality medium\n");
+	printf("	c. quality high\n");
+	printf("	d. quality ultimate\n");
+	printf("	e. quality reserved_1\n");
+	printf("	f. quality reserved_2\n");
+	printf("	g. quality reserved_3\n");
+	printf("	h. quality reserved_4\n");
+	printf("	i. quality reserved_5\n");
+	printf("	j. quality reserved_6\n\n");
+	printf("	q -- Quit");
+	printf("\n================================================\n");
+
+	return 0;
+}
+
+static int show_profile()
+{
+	printf("\n================================================\n");
+	printf(">>Profile List\n\n");
+	printf("	a. static\n");
+	printf("	b. small motion\n");
+	printf("	c. mid motion\n");
+	printf("	d. big motion\n");
+	printf("	e. low light\n");
+	printf("	f. big motion with frame drop\n");
+	printf("	g. security ipcam cbr\n\n");
+	printf("	q -- Quit");
+	printf("\n================================================\n");
+	printf("> ");
+
+	return 0;
+}
+
+static int show_bitrate_list()
+{
+	printf("\n================================================\n");
+	printf(">>Bitrate_per_MB_ref\n\n");
+	printf("	No.0: STATIC profile\n");
+	printf("	No.1: SMALL MOTION profile\n");
+	printf("	No.2: MID MOTION profile\n");
+	printf("	No.3: BIG MOTION profile\n");
+	printf("	No.4: LOW LIGHT profile\n");
+	printf("	No.5: BIG MOTION WITH FRAME DROP profile\n");
+	printf("	No.6: SECURITY IPCAM CBR profile\n\n");
+	printf("	q -- Quit");
+	printf("\n================================================\n");
+
+	return 0;
+}
+
+static int show_qp_list()
+{
+	printf("\n================================================\n");
+	printf(">>QP List\n\n");
+	printf("	No.0: I_qp_limit_min(1~51)\n");
+	printf("	No.1: I_qp_limit_max(1~51)\n");
+	printf("	No.2: P_qp_limit_min(1~51)\n");
+	printf("	No.3: P_qp_limit_max(1~51)\n");
+	printf("	No.4: B_qp_limit_min(1~51)\n");
+	printf("	No.5: B_qp_limit_max(1~51)\n");
+	printf("	No.6: Q_qp_limit_min(1~51)\n");
+	printf("	No.7: Q_qp_limit_max(1~51)\n");
+	printf("	No.8: I_qp_reduce\n");
+	printf("	No.9: P_qp_reduce\n");
+	printf("	No.10: Q_qp_reduce\n");
+	printf("	NO.11: adapt_qp\n\n");
+	printf("	q -- Quit");
+	printf("\n================================================\n");
+	return 0;
+}
+
+static int show_gop_type()
+{
+	printf("\n================================================\n");
+	printf(">>Gop type List\n\n");
+	printf("	a. IPPP GOP\n");
+	printf("	b. IBBP GOP\n\n");
+	printf("	q -- Quit");
+	printf("\n================================================\n");
+
+	return 0;
+}
+
+static int show_roi_param()
+{
+	printf("\n================================================\n");
+	printf(">>Roi param List\n\n");
+	printf("	NO.0: static_qp_adjust\n");
+	printf("	NO.1: dynamic_qp_adjust\n\n");
+	printf("	q -- Quit");
+	printf("\n================================================\n");
+
+	return 0;
+}
+
+static int show_default_base_bitrate(bitrate_param_case_target_t *default_bitrate_param) {
+
+	printf(">>Bitrate per MB\n");
+	printf("PROFILE_STATIC: %d\n",
+			default_bitrate_param[PROFILE_STATIC].bitrate_per_MB_ref);
+	printf("PROFILE_SMALL_MOTION: %d\n",
+			default_bitrate_param[PROFILE_SMALL_MOTION].bitrate_per_MB_ref);
+	printf("PROFILE_MID_MOTION: %d\n",
+			default_bitrate_param[PROFILE_MID_MOTION].bitrate_per_MB_ref);
+	printf("PROFILE_BIG_MOTION: %d\n",
+			default_bitrate_param[PROFILE_BIG_MOTION].bitrate_per_MB_ref);
+	printf("PROFILE_LOW_LIGHT: %d\n",
+			default_bitrate_param[PROFILE_LOW_LIGHT].bitrate_per_MB_ref);
+	printf("PROFILE_BIT_MOTION_WITH: %d\n",
+			default_bitrate_param[PROFILE_BIG_MOTION_WITH_FRAME_DROP].bitrate_per_MB_ref);
+	printf("PROFILE_SECURITY_IPCAM_CBR: %d\n",
+			default_bitrate_param[PROFILE_SECURITY_IPCAM_CBR].bitrate_per_MB_ref);
+
+	return 0;
+}
+
+static int show_default_base_qp(qp_param_t *default_qp_param) {
+
+	printf(">>QP parameters\n");
+	printf("I_qp_limit : %d ~ %d\n", default_qp_param->I_qp_limit_min,
+		default_qp_param->I_qp_limit_max);
+	printf("P_qp_limit : %d ~ %d\n", default_qp_param->P_qp_limit_min,
+		default_qp_param->P_qp_limit_max);
+	printf("B_qp_limit : %d ~ %d\n", default_qp_param->B_qp_limit_min,
+		default_qp_param->B_qp_limit_max);
+	printf("Q_qp_limit : %d ~ %d\n", default_qp_param->Q_qp_limit_min,
+		default_qp_param->Q_qp_limit_max);
+	printf("I_qp_reduce : %d\n", default_qp_param->I_qp_reduce);
+	printf("P_qp_reduce : %d\n", default_qp_param->P_qp_reduce);
+	printf("Q_qp_reduce : %d\n", default_qp_param->Q_qp_reduce);
+	printf("adapt_qp : %d\n", default_qp_param->adapt_qp);
+
+	return 0;
+}
+
+static int set_bitrate(u32 param_map, quality_level_t quality_level, u32 gop_type)
+{
+	bitrate_param_case_target_t *bitrate_param, *default_bitrate_param;
+	base_param_t default_base_param;
+	int i = 0, bitrate = 0;
+	u32 profile_map = 0;
+	u32 quality_map = 0;
+
+	memset(&default_base_param, 0, sizeof(base_param_t));
+	default_bitrate_param = &default_base_param.bitrate_t[quality_level][PROFILE_FIRST];
+
+	bitrate_param = &base_param.bitrate_t[quality_level][PROFILE_FIRST];
+	quality_map |= (1 << quality_level);
+
+	show_bitrate_list();
+
+	smartrc_get_base_param(gop_type, &default_base_param, quality_map, param_map,
+		profile_map);
+	show_default_base_bitrate(default_bitrate_param);
+
+	printf("Please input array of bitrate_per_MB_ref\n");
+	while (i < PROFILE_NUM) {
+		printf("No.%d: \n>", i);
+		scanf("%d", &bitrate);
+		bitrate_param[i].bitrate_per_MB_ref = (u32)bitrate;
+		i++;
+	}
+
+	return 0;
+}
+
+static u32 set_quality(u32 param_map, u32 gop_type)
+{
+	char quality_ch;
+	int exit_flag, error_opt;
+	u32 quality_map;
+
+	quality_map = 0;
+	show_quality();
+	quality_ch = getchar();
+	while (quality_ch) {
+		exit_flag = 0;
+		error_opt = 0;
+		switch (quality_ch) {
+		case 'a':
+			quality_map |= (1 << QUALITY_LOW);
+			set_bitrate(param_map, QUALITY_LOW, gop_type);
+			break;
+		case 'b':
+			quality_map |= (1 << QUALITY_MEDIUM);
+			set_bitrate(param_map, QUALITY_MEDIUM, gop_type);
+			break;
+		case 'c':
+			quality_map |= (1 << QUALITY_HIGH);
+			set_bitrate(param_map, QUALITY_HIGH, gop_type);
+			break;
+		case 'd':
+			quality_map |= (1 << QUALITY_ULTIMATE);
+			set_bitrate(param_map, QUALITY_ULTIMATE, gop_type);
+			break;
+		case 'e':
+			quality_map |= (1 << QUALITY_RESERVED_1);
+			set_bitrate(param_map, QUALITY_RESERVED_1, gop_type);
+			break;
+		case 'f':
+			quality_map |= (1 << QUALITY_RESERVED_2);
+			set_bitrate(param_map, QUALITY_RESERVED_2, gop_type);
+			break;
+		case 'g':
+			quality_map |= (1 << QUALITY_RESERVED_3);
+			set_bitrate(param_map, QUALITY_RESERVED_3, gop_type);
+			break;
+		case 'h':
+			quality_map |= (1 << QUALITY_RESERVED_4);
+			set_bitrate(param_map, QUALITY_RESERVED_4, gop_type);
+			break;
+		case 'i':
+			quality_map |= (1 << QUALITY_RESERVED_5);
+			set_bitrate(param_map, QUALITY_RESERVED_5, gop_type);
+			break;
+		case 'j':
+			quality_map |= (1 << QUALITY_RESERVED_6);
+			set_bitrate(param_map, QUALITY_RESERVED_6, gop_type);
+			break;
+		case 'q':
+			exit_flag = 1;
+			break;
+		default:
+			error_opt = 1;
+			break;
+		}
+		if (exit_flag)
+			break;
+		if (error_opt == 0) {
+			show_quality();
+		}
+		quality_ch = getchar();
+	}
+	return quality_map;
+}
+
+static int set_qp_param(profile_t profile, u32 gop_type, u32 param_map)
+{
+	u32 *qp_param = NULL;
+	int i = 0, qp_value = 0;
+	u32 profile_map = 0;
+	u32 quality_map = 0;
+	base_param_t default_base_param;
+	qp_param_t *default_qp_param;
+
+	memset(&default_base_param, 0, sizeof(base_param_t));
+	default_qp_param = &default_base_param.qp_param[profile];
+
+	qp_param = (u32*)&base_param.qp_param[profile];
+	profile_map = (1 << profile);
+
+	show_qp_list();
+	smartrc_get_base_param(gop_type, &default_base_param, quality_map, param_map,
+		profile_map);
+	show_default_base_qp(default_qp_param);
+
+	printf("Please input array of qp parameters\n>");
+	while (i < QP_PARAM_NUM) {
+		printf("No.%d: \n>", i);
+		scanf("%d", &qp_value);
+		qp_param[i++] = qp_value;
+	}
+
+	return 0;
+}
+
+static int set_gop_param(profile_t profile, u32 gop_type, u32 param_map)
+{
+	u32 *gop = NULL;
+	int gop_N = 0;
+	u32 profile_map = 0;
+	u32 quality_map = 0;
+	base_param_t default_base_param;
+	u32 *default_gop_N;;
+
+	memset(&default_base_param, 0, sizeof(base_param_t));
+	default_gop_N = &default_base_param.gop_N[profile];
+
+	gop = &base_param.gop_N[profile];
+	profile_map = (1 << profile);
+
+	smartrc_get_base_param(gop_type, &default_base_param, quality_map, param_map,
+		profile_map);
+	printf(">>Gop N %d\n", *default_gop_N);
+
+	printf("Please input GOP length\n>");
+	scanf("%d", &gop_N);
+	*gop = (u32)gop_N;
+
+	return 0;
+}
+
+static int set_roi_param(profile_t profile, u32 gop_type, u32 param_map)
+{
+	s8 *roi_param = NULL;
+	int qp_adjust = 0, i = 0;
+	u32 profile_map = 0;
+	u32 quality_map = 0;
+	base_param_t default_base_param;
+	roi_t *default_roi;;
+
+	memset(&default_base_param, 0, sizeof(base_param_t));
+	default_roi = &default_base_param.roi_params[profile];
+
+	roi_param = (s8*)&base_param.roi_params[profile];
+	profile_map |= (1 << profile);
+
+	show_roi_param();
+
+	smartrc_get_base_param(gop_type, &default_base_param, quality_map, param_map,
+		profile_map);
+	printf(">>ROI parameters\n");
+	printf("Static qp adjust %d\n", default_roi->static_qp_adjust);
+	printf("Dynamic qp adjust %d\n", default_roi->dynamic_qp_adjust);
+
+	printf("Please input qp adjust\n>");
+	while (i < ROI_FLAG_NUM) {
+		printf("No.%d: \n>", i);
+		scanf("%d", &qp_adjust);
+		roi_param[i++] = (0xFF & (((qp_adjust & 0x8000) >> 8) | (qp_adjust & 0x007F)));
+	}
+
+	return 0;
+}
+
+static int set_profile_param(u32 param_map, profile_t profile, u32 gop_type)
+{
+	int i;
+
+	for (i = 0; i < PARAM_FLAG_NUM; i++) {
+		if (param_map & (1 << i)) {
+			switch (i) {
+			case BITRATE_FLAG:
+				break;
+			case GOP_FLAG:
+				set_gop_param(profile, gop_type, param_map);
+				break;
+			case QP_FLAG:
+				set_qp_param(profile, gop_type, param_map);
+				break;
+			case ROI_PARAM:
+				set_roi_param(profile, gop_type, param_map);
+				break;
+			default:
+				break;
+			}
+		}
+	}
+
+	return 0;
+}
+
+
+static u32 set_profile(u32 param_map, u32 gop_type)
+{
+	char profile_ch;
+	int exit_flag, error_opt;
+	u32 profile_map;
+
+	profile_map = 0;
+	show_profile();
+	profile_ch = getchar();
+	while (profile_ch) {
+		exit_flag = 0;
+		error_opt = 0;
+		switch (profile_ch) {
+		case 'a':
+			profile_map |= (1 << PROFILE_STATIC);
+			set_profile_param(param_map, PROFILE_STATIC, gop_type);
+			break;
+		case 'b':
+			profile_map |= (1 << PROFILE_SMALL_MOTION);
+			set_profile_param(param_map, PROFILE_SMALL_MOTION, gop_type);
+			break;
+		case 'c':
+			profile_map |= (1 << PROFILE_MID_MOTION);
+			set_profile_param(param_map, PROFILE_MID_MOTION, gop_type);
+			break;
+		case 'd':
+			profile_map |= (1 << PROFILE_BIG_MOTION);
+			set_profile_param(param_map, PROFILE_BIG_MOTION, gop_type);
+			break;
+		case 'e':
+			profile_map |= (1 << PROFILE_LOW_LIGHT);
+			set_profile_param(param_map, PROFILE_LOW_LIGHT, gop_type);
+			break;
+		case 'f':
+			profile_map |= (1 << PROFILE_BIG_MOTION_WITH_FRAME_DROP);
+			set_profile_param(param_map, PROFILE_BIG_MOTION_WITH_FRAME_DROP, gop_type);
+			break;
+		case 'g':
+			profile_map |= (1 << PROFILE_SECURITY_IPCAM_CBR);
+			set_profile_param(param_map, PROFILE_SECURITY_IPCAM_CBR, gop_type);
+			break;
+		case 'q':
+			exit_flag = 1;
+			break;
+		default:
+			error_opt = 1;
+			break;
+		}
+		if (exit_flag)
+			break;
+		if (error_opt == 0) {
+			show_profile();
+		}
+		profile_ch = getchar();
+	}
+
+	return profile_map;
+}
+
+static int set_param(u32 gop_type)
+{
+	char param_ch;
+	u32 param_map, profile_map, quality_map;
+	int exit_flag, error_opt;
+
+	show_set_control_table_menu();
+	param_ch = getchar();
+	while (param_ch) {
+		exit_flag = 0;
+		error_opt = 0;
+		param_map = 0;
+		profile_map = 0;
+		quality_map = 0;
+		switch (param_ch) {
+		case 'a':
+			param_map |= (1 << BITRATE_FLAG);
+			quality_map = set_quality(param_map, gop_type);
+			smartrc_set_base_param(gop_type, &base_param, quality_map, param_map,
+				profile_map);
+			break;
+		case 'b':
+			param_map |= (1 << GOP_FLAG);
+			profile_map = set_profile(param_map, gop_type);
+			smartrc_set_base_param(gop_type, &base_param, quality_map, param_map,
+				profile_map);
+			break;
+		case 'c':
+			param_map |= (1 << QP_FLAG);
+			profile_map = set_profile(param_map, gop_type);
+			smartrc_set_base_param(gop_type, &base_param, quality_map, param_map,
+				profile_map);
+			break;
+		case 'd':
+			param_map |= (1 << ROI_PARAM);
+			profile_map = set_profile(param_map, gop_type);
+			smartrc_set_base_param(gop_type, &base_param, quality_map, param_map,
+				profile_map);
+			break;
+		case 'q':
+			exit_flag = 1;
+			break;
+		default:
+			error_opt = 1;
+			break;
+		}
+		if (exit_flag)
+			break;
+		if (error_opt == 0) {
+			show_set_control_table_menu();
+		}
+		param_ch = getchar();
+	}
+
+	return 0;
+}
+
+static int set_base_param()
+{
+	u32 gop_type = 0;
+	int exit_flag, error_opt;
+	char g_type;
+
+	show_gop_type();
+	g_type = getchar();
+	while (g_type) {
+		exit_flag = 0;
+		error_opt = 0;
+		switch (g_type) {
+		case 'a':
+			gop_type = IPPP;
+			set_param(gop_type);
+			break;
+		case 'b':
+			gop_type = IBBP;
+			set_param(gop_type);
+			break;
+		case 'q':
+			exit_flag = 1;
+			break;
+		default:
+			error_opt = 1;
+			break;
+		}
+		if (exit_flag)
+			break;
+		if (error_opt == 0) {
+			show_gop_type();
+		}
+		g_type = getchar();
+	}
+
+	return 0;
+}
+
+
+static int init_iav(void)
+{
+	struct iav_querybuf querybuf;
+
+	//open the device
+	if ((fd_iav = open("/dev/iav", O_RDWR, 0)) < 0) {
+		perror("/dev/iav");
+		return -1;
+	}
+
+	querybuf.buf = IAV_BUFFER_DSP;
+	if (ioctl(fd_iav, IAV_IOC_QUERY_BUF, &querybuf) < 0) {
+		perror("IAV_IOC_QUERY_BUF");
+		return -1;
+	}
+
+	dsp_size = querybuf.length;
+	dsp_mem = (u8 *)mmap(NULL, dsp_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd_iav, querybuf.offset);
+	if (dsp_mem == MAP_FAILED) {
+		perror("mmap (%d) failed: %s\n");
+		return -1;
+	} else {
+		mem_mapped = 1;
+	}
+
+	return 0;
+}
+
+static int exit_iav(void)
+{
+	if (fd_iav >= 0) {
+		close(fd_iav);
+	}
+	if (!mem_mapped) {
+		return 0;
+	}
+	if (munmap(dsp_mem, dsp_size) < 0) {
+		printf("munmap failed!\n");
+		return -1;
+	} else {
+		mem_mapped = 0;
+	}
+
+	return 0;
+}
+
+static int check_state(void)
+{
+	int state;
+
+	if (ioctl(fd_iav, IAV_IOC_GET_IAV_STATE, &state) < 0) {
+		perror("IAV_IOC_GET_STATE");
+		return -1;
+	}
+
+	if ((state != IAV_STATE_ENCODING) && (state != IAV_STATE_PREVIEW)) {
+		printf("IAV is not in encoding or pewview status, cannot control Smartrc!\n");
+		return -1;
+	}
+	return 0;
+}
+
+static u32 get_ratio(u32 dividend, u32 divisor, u32 shift)
+{
+	return dividend / (divisor >> shift);
+}
+
+static u32 multiply_ratio(u32 value, u32 ratio, u32 shift)
+{
+	return (value * ratio) >> shift;
+}
+
+static int update_delay_param(u32 fps)
+{
+	int ratio;
+
+	ratio = get_ratio(AMBA_VIDEO_FPS_29_97, fps, SHIFT_BIT);
+	g_delay.motion_none = multiply_ratio(g_delay.motion_none, ratio, SHIFT_BIT);
+	g_delay.motion_low = multiply_ratio(g_delay.motion_low, ratio, SHIFT_BIT);
+	g_delay.motion_mid = multiply_ratio(g_delay.motion_mid, ratio, SHIFT_BIT);
+	g_delay.motion_high = multiply_ratio(g_delay.motion_high, ratio, SHIFT_BIT);
+
+	return 0;
+}
+
+static int get_transfer_ratio(buf_type_t type_in, buf_type_t type_out)
+{
+	u32 ratio;
+
+	if (type_in == BUF_ME1_4 && type_out == BUF_ME0_8) {
+		ratio = 2;
+	} else if (type_in == BUF_ME1_4 && type_out == BUF_ME1_16) {
+		ratio = 4;
+	} else if (type_in == BUF_ME0_8 && type_out == BUF_ME0_16) {
+		ratio = 2;
+	} else if (type_in == BUF_ME0_8 && type_out == BUF_ME0_32) {
+		ratio = 4;
+	} else {
+		printf("Invalid buffer type!\n");
+		return -1;
+	}
+	return ratio;
+}
+
+static buf_type_t get_buf_type(u32 buf_id)
+{
+	int buf_type;
+
+	if (buf_id < IAV_SRCBUF_1 || buf_id > IAV_SRCBUF_4) {
+		printf("Invalid buffer id!\n");
+		return -1;
+	}
+
+	//always use ME1 4x4 down-scaled data to do MDET
+	//buf_type = BUF_ME0_16;
+	buf_type = BUF_ME1_4;
+
+	return buf_type;
+}
+
+static int get_me_buf_desc(struct iav_querydesc *query_desc, u32 buf_id)
+{
+	enum iav_srcbuf_id srcbuf_id;
+	buf_type_t buf_type;
+
+	if (!query_desc) {
+		printf("Invalid query_desc ptr!\n");
+		return -1;
+	}
+
+	srcbuf_id = (enum iav_srcbuf_id) buf_id;
+	buf_type = get_buf_type(buf_id);
+	switch (buf_type) {
+		case BUF_ME1_4:
+			query_desc->qid = IAV_DESC_ME1;
+			query_desc->arg.me1.buf_id = srcbuf_id;
+			query_desc->arg.me1.flag |= IAV_BUFCAP_NONBLOCK;
+			break;
+		case BUF_ME0_8:
+		case BUF_ME0_16:
+			query_desc->qid = IAV_DESC_ME0;
+			query_desc->arg.me0.buf_id = srcbuf_id;
+			query_desc->arg.me0.flag |= IAV_BUFCAP_NONBLOCK;
+			break;
+		default:
+			printf("Buffer type %d not supported!\n", buf_type);
+			break;
+	}
+	if (ioctl(fd_iav, IAV_IOC_QUERY_DESC, query_desc) < 0) {
+		perror("IAV_IOC_QUERY_DESC");
+		return -1;
+	}
+	return 0;
+}
+
+static int get_roi_size(unsigned int *p, unsigned int *w, unsigned int *h, u32 stream_id)
+{
+	struct iav_querydesc query_desc;
+	struct iav_mebufdesc *me = NULL;
+	buf_type_t buf_type;
+	u32 trans_ratio = 1, buf_id;
+	s32 tmp;
+
+	if (!p || !w || !h) {
+		printf("Invalid ptr for p or w or h!\n");
+		return -1;
+	}
+	VERIFY_STREAM_ID(stream_id);
+	if (!g_enc_cfg[stream_id].param_inited) {
+		printf("smartrc has not been initialized!\n");
+		return -1;
+	}
+	buf_id = g_enc_cfg[stream_id].src_buf_id;
+
+	buf_type = get_buf_type(buf_id);
+
+	memset(&query_desc, 0, sizeof(query_desc));
+	get_me_buf_desc(&query_desc, buf_id);
+	switch (buf_type) {
+	case BUF_ME1_4:
+		tmp = get_transfer_ratio(BUF_ME1_4, BUF_ME1_16);
+		if (tmp < 0)
+			break;
+		trans_ratio = tmp;
+		me = &query_desc.arg.me1;
+		break;
+	case BUF_ME0_8:
+		tmp = get_transfer_ratio(BUF_ME0_8, BUF_ME0_16);
+		if (tmp < 0)
+			break;
+		trans_ratio = tmp;
+		me = &query_desc.arg.me0;
+		break;
+	case BUF_ME0_16:
+		trans_ratio = 1;
+		me = &query_desc.arg.me0;
+		break;
+	default:
+		printf("Buffer type %d not supported!\n", buf_type);
+		break;
+	}
+
+	*p = ROUND_UP(me->pitch, trans_ratio) / trans_ratio;
+	*h = g_enc_cfg[stream_id].roi_height;
+	*w = g_enc_cfg[stream_id].roi_width;
+
+	return 0;
+}
+
+static inline int transfer_me_buf(u8 *buf_in, u32 pitch_in, u32 height_in, u32 width_in,
+	u32 offset_w_in, u32 offset_h_in, u8 *buf_out, u32 pitch_out, u32 ratio)
+{
+	u32 add_num, shift;
+	u32 i, j;
+	int k;
+
+	if (!buf_in || !buf_out) {
+		printf("Invalid buf ptr!\n");
+		return -1;
+	}
+
+	switch (ratio) {
+	case 2:
+		shift = 1;
+		add_num = 2;
+		for (j = 0; j < height_in; j += 2) {
+			for (i = 0; i < width_in; i += 16) {
+				uint16x4_t line00 = vpaddl_u8(vld1_u8(buf_in + (j + 0) * pitch_in + i + 0));
+				uint16x4_t line01 = vpaddl_u8(vld1_u8(buf_in + (j + 0) * pitch_in + i + 8));
+
+				uint16x4_t line10 = vpaddl_u8(vld1_u8(buf_in + (j + 1) * pitch_in + i + 0));
+				uint16x4_t line11 = vpaddl_u8(vld1_u8(buf_in + (j + 1) * pitch_in + i + 8));
+
+				uint16x4x2_t line = {{vadd_u16(line00, line10), vadd_u16(line01, line11)}};
+#if defined(BUILD_AMBARELLA_APP_DEBUG)
+				buf_out[(j >> shift) * pitch_out + (i >> shift) + 0] =
+					(vget_lane_u16(line.val[0], 0) + add_num) >> ratio;
+				buf_out[(j >> shift) * pitch_out + (i >> shift) + 1] =
+					(vget_lane_u16(line.val[0], 1) + add_num) >> ratio;
+				buf_out[(j >> shift) * pitch_out + (i >> shift) + 2] =
+					(vget_lane_u16(line.val[0], 2) + add_num) >> ratio;
+				buf_out[(j >> shift) * pitch_out + (i >> shift) + 3] =
+					(vget_lane_u16(line.val[0], 3) + add_num) >> ratio;
+				buf_out[(j >> shift) * pitch_out + (i >> shift) + 4] =
+					(vget_lane_u16(line.val[1], 0) + add_num) >> ratio;
+				buf_out[(j >> shift) * pitch_out + (i >> shift) + 5] =
+					(vget_lane_u16(line.val[1], 1) + add_num) >> ratio;
+				buf_out[(j >> shift) * pitch_out + (i >> shift) + 6] =
+					(vget_lane_u16(line.val[1], 2) + add_num) >> ratio;
+				buf_out[(j >> shift) * pitch_out + (i >> shift) + 7] =
+					(vget_lane_u16(line.val[1], 3) + add_num) >> ratio;
+#else
+				for (k = 0; k < 8; ++ k) {
+					buf_out[(j >> shift) * pitch_out + (i >> shift)+ k] =
+						(vget_lane_u16(line.val[k / 4], (const int)k % 4) + add_num) >> ratio;
+				}
+#endif
+			}
+		}
+		break;
+	case 4:
+		shift = 2;
+		add_num = 8;
+		for (j = 0; j < height_in; j += 4) {
+			for (i = 0; i < width_in; i += 16) {
+				uint16x4_t line00 = vpaddl_u8(vld1_u8(buf_in + j * pitch_in + i + 0));
+				uint16x4_t line01 = vpaddl_u8(vld1_u8(buf_in + j * pitch_in + i + 8));
+				uint16x4_t line0  = vpadd_u16(line00, line01);
+
+				uint16x4_t line10 = vpaddl_u8(vld1_u8(buf_in + (j + 1) * pitch_in + i + 0));
+				uint16x4_t line11 = vpaddl_u8(vld1_u8(buf_in + (j + 1) * pitch_in + i + 8));
+				uint16x4_t line1  = vpadd_u16(line10, line11);
+
+				uint16x4_t line20 = vpaddl_u8(vld1_u8(buf_in + (j + 2) * pitch_in + i + 0));
+				uint16x4_t line21 = vpaddl_u8(vld1_u8(buf_in + (j + 2) * pitch_in + i + 8));
+				uint16x4_t line2  = vpadd_u16(line20, line21);
+
+				uint16x4_t line30 = vpaddl_u8(vld1_u8(buf_in + (j + 3) * pitch_in + i + 0));
+				uint16x4_t line31 = vpaddl_u8(vld1_u8(buf_in + (j + 3) * pitch_in + i + 8));
+				uint16x4_t line3  = vpadd_u16(line30, line31);
+
+				uint16x4_t line = vadd_u16(vadd_u16(vadd_u16(line0, line1), line2), line3);
+#if defined(BUILD_AMBARELLA_APP_DEBUG)
+				buf_out[(j >> shift) * pitch_out + (i >> shift) + 0] =
+						(vget_lane_u16(line, 0) + add_num) >> ratio;
+				buf_out[(j >> shift) * pitch_out + (i >> shift) + 1] =
+						(vget_lane_u16(line, 1) + add_num) >> ratio;
+				buf_out[(j >> shift) * pitch_out + (i >> shift) + 2] =
+						(vget_lane_u16(line, 2) + add_num) >> ratio;
+				buf_out[(j >> shift) * pitch_out + (i >> shift) + 3] =
+						(vget_lane_u16(line, 3) + add_num) >> ratio;
+#else
+				for (k = 0; k < 4; ++k) {
+					buf_out[(j >> shift) * pitch_out + (i >> shift) + k] =
+						(vget_lane_u16(line, (const int)k) + add_num) >> ratio;
+				}
+#endif
+			}
+		}
+		break;
+	default:
+		printf("Incorrect ratio for me buffer!\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static u8 *get_roi_addr(u32 stream_id)
+{
+	struct iav_querydesc query_desc;
+	struct iav_mebufdesc *me = NULL;
+	buf_type_t buf_type;
+	u8 *data_addr = NULL, *buf_in = NULL, *buf_out = NULL;
+	u32 pitch_in, width_in, height_in, offset_w_in, offset_h_in, pitch_out;
+	u32 trans_ratio = 1, me_ratio = 1, buf_id, tmp_width, tmp_height;
+	s32 tmp;
+
+	if (stream_id < 0 || stream_id >= SMARTRC_MAX_STREAM_NUM) {
+		printf("invalid stream id!\n");
+		goto err;
+	}
+	if (!g_enc_cfg[stream_id].param_inited) {
+		printf("smartrc has not been initialized!\n");
+		goto err;
+	}
+	buf_id = g_enc_cfg[stream_id].src_buf_id;
+	if (!me_buf[stream_id].buffer) {
+		printf("Invalid me buffer!\n");
+		goto err;
+	}
+	buf_type = get_buf_type(buf_id);
+
+	memset(&query_desc, 0, sizeof(query_desc));
+	get_me_buf_desc(&query_desc, buf_id);
+	switch (buf_type) {
+	case BUF_ME1_4:
+		me_ratio = 4;
+		tmp = get_transfer_ratio(BUF_ME1_4, BUF_ME1_16);
+		if (tmp < 0)
+			break;
+		trans_ratio = tmp;
+		me = &query_desc.arg.me1;
+		break;
+	case BUF_ME0_8:
+		me_ratio = 8;
+		tmp = get_transfer_ratio(BUF_ME0_8, BUF_ME0_16);
+		if (tmp < 0)
+			break;
+		trans_ratio = tmp;
+		me = &query_desc.arg.me0;
+		break;
+	case BUF_ME0_16:
+		trans_ratio = 1;
+		me = &query_desc.arg.me0;
+		break;
+	default:
+		printf("Buffer type %d not supported!\n", buf_type);
+		break;
+	}
+
+	//resolution is aligned to 16bit
+	tmp_width = ROUND_UP(g_enc_cfg[stream_id].width, 16);
+	tmp_height = ROUND_UP(g_enc_cfg[stream_id].height, 16);
+	buf_in = (u8 *)(dsp_mem + me->data_addr_offset);
+	pitch_in = me->pitch;
+	height_in = ROUND_UP(tmp_height, me_ratio) / me_ratio;
+	width_in = ROUND_UP(tmp_width, me_ratio) / me_ratio;
+	offset_w_in = ROUND_UP(g_enc_cfg[stream_id].x, me_ratio) / me_ratio;
+	offset_h_in = ROUND_UP(g_enc_cfg[stream_id].y, me_ratio) / me_ratio;
+	buf_out = me_buf[stream_id].buffer;
+	pitch_out = ROUND_UP(pitch_in, trans_ratio) / trans_ratio;
+
+	transfer_me_buf(buf_in, pitch_in, height_in, width_in,
+		offset_w_in, offset_h_in, buf_out, pitch_out, trans_ratio);
+	data_addr = buf_out;
+
+err:
+	return data_addr;
+}
+
+static u32 get_iav_dsp_pts(void)
+{
+	struct iav_querydesc sync_desc;
+
+	memset(&sync_desc, 0, sizeof(sync_desc));
+	sync_desc.qid = IAV_DESC_YUV;
+	sync_desc.arg.yuv.buf_id = IAV_SRCBUF_MN;
+	sync_desc.arg.yuv.flag &= ~IAV_BUFCAP_NONBLOCK;
+
+	if (ioctl(fd_iav, IAV_IOC_QUERY_DESC, &sync_desc) < 0) {
+		perror("IAV_IOC_QUERY_DESC");
+		return -1;
+	}
+
+	return (sync_desc.arg.yuv.dsp_pts);
+}
+
+static int do_vca_on_yuv(u32 stream_id)
+{
+	struct iav_querydesc sync_desc;
+	struct iav_yuvbufdesc *yuv = NULL;
+	u8 *luma_addr = NULL, *start = NULL;
+	int i, j, k, ratio = MB_SIZE;
+	u8 *matrix = NULL;
+	u32 w, h, start_x, start_y;
+
+	VERIFY_STREAM_ID(stream_id);
+	if (!g_enc_cfg[stream_id].param_inited) {
+		printf("smartrc has not been initialized!\n");
+		return -1;
+	}
+	matrix = g_smartrc_session[stream_id].motion_matrix;
+
+	w = ROUND_UP(g_enc_cfg[stream_id].width, ratio);
+	h = ROUND_UP(g_enc_cfg[stream_id].height, ratio);
+	//x and y have already been a multiple of ratio, otherwise it cannot use smartrc
+	start_x = g_enc_cfg[stream_id].x;
+	start_y = g_enc_cfg[stream_id].y;
+
+	memset(&sync_desc, 0, sizeof(sync_desc));
+	yuv = &sync_desc.arg.yuv;
+	sync_desc.qid = IAV_DESC_YUV;
+	yuv->flag |= IAV_BUFCAP_NONBLOCK;
+	yuv->buf_id = g_enc_cfg[stream_id].src_buf_id;
+
+	if (ioctl(fd_iav, IAV_IOC_QUERY_DESC, &sync_desc) < 0) {
+		perror("IAV_IOC_QUERY_DESC");
+		return -1;
+	}
+
+	luma_addr = dsp_mem + yuv->y_addr_offset;
+	for (i = start_y; i < start_y + h; i += ratio) {
+		for (j = start_x; j < start_x + w; j += ratio, matrix++) {
+			start = luma_addr + i * yuv->pitch + j;
+			if (*matrix == 1) {
+				for (k = 0; k < ratio; k++) {
+					memset(start + k * yuv->pitch, 0xff, ratio);
+				}
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int dump_mot_mat(u32 stream_id)
+{
+	u8 *motion_matrix = NULL;
+	u32 w, h, i, j;
+	char *ch;
+
+	VERIFY_STREAM_ID(stream_id);
+	if (g_mt_mat[stream_id].fd < 0 ||
+		!g_mt_mat[stream_id].buffer ||
+		!g_mt_mat[stream_id].size) {
+		printf("invalid dump fd or buffer or size!\n");
+		return -1;
+	}
+	if (!g_enc_cfg[stream_id].param_inited) {
+		printf("smartrc has not been initialized!\n");
+		return -1;
+	}
+
+	motion_matrix = g_smartrc_session[stream_id].motion_matrix;
+	w = g_enc_cfg[stream_id].roi_width;
+	h = g_enc_cfg[stream_id].roi_height;
+
+	ch = g_mt_mat[stream_id].buffer;
+	// QP matrix is MB level. One MB is 16x16 pixels.
+	for (i = 0; i < h; i++) {
+		for (j = 0; j < w; j++, motion_matrix++, ch++) {
+			if (*motion_matrix == 1) {
+				*ch = '*'; // '*' for '1'
+			} else {
+				*ch = ' '; // space for '0'
+			}
+		}
+		*ch = '\n';
+		ch++;
+	}
+	*ch = '\n';
+	ch++;
+	if (amba_transfer_write(g_mt_mat[stream_id].fd, g_mt_mat[stream_id].buffer,
+		g_mt_mat[stream_id].size, TRANS_METHOD_NFS) < 0) {
+		perror("Failed to dump motion matrix into file!\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int get_noise_value(void)
+{
+	struct vindev_agc vsrc_agc;
+
+	vsrc_agc.vsrc_id = 0;
+	if (ioctl(fd_iav, IAV_IOC_VIN_GET_AGC, &vsrc_agc) < 0) {
+		perror("IAV_IOC_VIN_GET_AGC");
+		return -1;
+	}
+
+	return (vsrc_agc.agc >> 24);
+}
+
+static int get_motion_value_start(u32 stream_id)
+{
+	int ret = 0;
+	u32 p, w, h;
+	mdet_cfg *mdet_cfg = NULL;
+	mdet_session_t *ms = NULL;
+
+	VERIFY_STREAM_ID(stream_id);
+	do {
+		if (get_roi_size(&p, &w, &h, stream_id) < 0) {
+			printf("get roi size failed!\n");
+			ret = -1;
+			break;
+		}
+		printf("stream: %c p %d w %d h %d\n", 'A' + stream_id, p, w, h);
+
+		mdet_cfg = &g_mdet_cfg[stream_id];
+		mdet_cfg->threshold = 2; //64->2
+		mdet_cfg->fm_dim.pitch = p;
+		mdet_cfg->fm_dim.width = w;
+		mdet_cfg->fm_dim.height = h;
+		// config one ROI0 to cover the whole buffer
+		mdet_cfg->roi_info.num_roi = 1;
+		mdet_cfg->roi_info.roi[0].num_points = 4;
+		mdet_cfg->roi_info.roi[0].points[0].x = 0;
+		mdet_cfg->roi_info.roi[0].points[0].y = 0;
+		mdet_cfg->roi_info.roi[0].points[1].x = w - 1;
+		mdet_cfg->roi_info.roi[0].points[1].y = 0;
+		mdet_cfg->roi_info.roi[0].points[2].x = w - 1;
+		mdet_cfg->roi_info.roi[0].points[2].y = h - 1;
+		mdet_cfg->roi_info.roi[0].points[3].x = 0;
+		mdet_cfg->roi_info.roi[0].points[3].y = h - 1;
+
+		ms = &g_ms[stream_id];
+		//start motion detection
+		if (mdet_start_diff(mdet_cfg, ms) < 0) {
+			printf("md_start failed!\n");
+			ret = -1;
+			break;
+		}
+	} while (0);
+
+	return ret;
+}
+
+static int get_motion_value_stop(u32 stream_id)
+{
+	mdet_cfg *mdet_cfg = NULL;
+	mdet_session_t *ms = NULL;
+	VERIFY_STREAM_ID(stream_id);
+
+	mdet_cfg = &g_mdet_cfg[stream_id];
+	ms = &g_ms[stream_id];
+	mdet_stop_diff(mdet_cfg, ms);
+
+	return 0;
+}
+
+static int smartrc_thread_stop(void)
+{
+	int ret;
+
+	if (smartrc_thread_id == 0) {
+		ret = 0;
+	} else {
+		smartrc_exit_flag = 1;
+		ret = pthread_join(smartrc_thread_id, NULL);
+		smartrc_thread_id = 0;
+	}
+	return ret;
+}
+
+static void *smartrc_mainloop(void *arg)
+{
+	u64 total_frames = 0;
+	u8 *data = NULL;
+	u32 i0_motion[SMARTRC_MAX_STREAM_NUM] = {0}, i1_motion[SMARTRC_MAX_STREAM_NUM] = {0};
+	u32 i2_motion[SMARTRC_MAX_STREAM_NUM] = {0}, i3_motion[SMARTRC_MAX_STREAM_NUM] = {0};
+	u32 i0_light[SMARTRC_MAX_STREAM_NUM] = {0}, i1_light[SMARTRC_MAX_STREAM_NUM] = {0};
+	u32 i2_light[SMARTRC_MAX_STREAM_NUM] = {0};
+	motion_level_t motion_level[SMARTRC_MAX_STREAM_NUM] = {MOTION_LOW};
+	noise_level_t noise_level[SMARTRC_MAX_STREAM_NUM] = {NOISE_LOW};
+	motion_level_t real_motion_level[SMARTRC_MAX_STREAM_NUM];
+	noise_level_t real_noise_level[SMARTRC_MAX_STREAM_NUM];
+	quality_level_t quality_level[SMARTRC_MAX_STREAM_NUM];
+	struct timeval prev = {0, 0}, curr = {0, 0};
+	u32 tmp, dsp_pts, quality_level_flag[SMARTRC_MAX_STREAM_NUM] = {0};
+	int i;
+
+	while (smartrc_exit_flag == 0) {
+		//blocking IO for getting dsp pts, other IOs are all non-blocking
+		dsp_pts = get_iav_dsp_pts();
+		tmp = get_noise_value();
+		total_frames++;
+		for (i = 0; i < SMARTRC_MAX_STREAM_NUM; i++) {
+			if (!(stream_selection & (1 << i)))
+				continue;
+
+			if (smartrc_params.adaptive_scenario_flag[i]
+					&& smartrc_params.adaptive_scenario[i]) {
+				gettimeofday(&curr, NULL);
+				prev = curr;
+			}
+
+			noise_value[i] = tmp;
+			data = get_roi_addr(i);
+			mdet_update_frame_diff(&g_mdet_cfg[i], &g_ms[i], data, g_mdet_cfg[i].threshold);
+			motion_value[i] = (int) ((double) g_ms[i].motion[0] * (double) g_delay.motion_indicator);
+
+			//printf("motion[0]: %f, fg_pxls[0]: %d, pixels[0]: %d, motion_value: %d, noise_value: %d\n",
+			//	g_ms.motion[0], g_ms.fg_pxls[0], g_ms.pixels[0], motion_value, noise_value);
+			if (motion_value[i] < g_threshold.motion_low) { // no motion
+				i0_motion[i]++;
+				i1_motion[i] = 0;
+				i2_motion[i] = 0;
+				i3_motion[i] = 0;
+				if (i0_motion[i] >= g_delay.motion_none) {
+					if (motion_level[i] == MOTION_HIGH) {
+						motion_level[i] = MOTION_MID;
+					} else if (motion_level[i] == MOTION_MID) {
+						motion_level[i] = MOTION_LOW;
+					} else {
+						motion_level[i] = MOTION_NONE;
+					}
+					i0_motion[i] = 0;
+				}
+			} else if (motion_value[i] < g_threshold.motion_mid) { // small motion
+				i0_motion[i] = 0;
+				i1_motion[i]++;
+				i2_motion[i] = 0;
+				i3_motion[i] = 0;
+				if (i1_motion[i] >= g_delay.motion_low) {
+					motion_level[i] = MOTION_LOW;
+					i1_motion[i] = 0;
+				}
+			} else if (motion_value[i] < g_threshold.motion_high) { // middle motion
+				i0_motion[i] = 0;
+				i1_motion[i] = 0;
+				i2_motion[i]++;
+				i3_motion[i] = 0;
+				if (i2_motion[i] >= g_delay.motion_mid) {
+					motion_level[i] = MOTION_MID;
+					i2_motion[i] = 0;
+				}
+			} else { // big motion
+				i0_motion[i] = 0;
+				i1_motion[i] = 0;
+				i2_motion[i] = 0;
+				i3_motion[i]++;
+				if (i3_motion[i] >= g_delay.motion_high) {
+					motion_level[i] = MOTION_HIGH;
+					i3_motion[i] = 0;
+					if (smartrc_params.adaptive_scenario_flag[i]
+							&& smartrc_params.adaptive_scenario[i])
+						motion_high_cnt[i]++;
+				}
+			}
+
+			if (noise_value[i] < g_threshold.noise_low) {
+				i0_light[i]++;
+				i1_light[i] = 0;
+				i2_light[i] = 0;
+				if (i0_light[i] >= g_delay.noise_none) {
+					noise_level[i] = NOISE_NONE;
+					i0_light[i] = 0;
+				}
+			} else if (noise_value[i] < g_threshold.noise_high) {
+				i0_light[i] = 0;
+				i1_light[i]++;
+				i2_light[i] = 0;
+				if (i1_light[i] >= g_delay.noise_low) {
+					noise_level[i] = NOISE_LOW;
+					i1_light[i] = 0;
+				}
+			} else {
+				i0_light[i] = 0;
+				i1_light[i] = 0;
+				i2_light[i]++;
+				if (i2_light[i] >= g_delay.noise_high) {
+					noise_level[i] = NOISE_HIGH;
+					i2_light[i] = 0;
+				}
+			}
+
+			if (smartrc_params.adaptive_scenario_flag[i]
+					&& smartrc_params.adaptive_scenario[i]) {
+				gettimeofday(&curr, NULL);
+				if ((curr.tv_sec - prev.tv_sec) >= ADAPTIVE_STUDY_TIME) {
+					if (motion_high_cnt[i] >= ADAPTIVE_MOTION_HIGH_THRESHOLD) {
+						if (!quality_level_flag[i]) {
+							smartrc_get_stream_quality(&quality_level[i], i);
+							if (quality_level[i] < QUALITY_LAST - 1) {
+								quality_level[i] += 1;
+							}
+							quality_level_flag[i] = 1;
+							smartrc_set_stream_quality(quality_level[i], i);
+							printf("update to quality %d.\n", quality_level[i]);
+						}
+					} else {
+						if (quality_level_flag[i]) {
+							smartrc_get_stream_quality(&quality_level[i], i);
+							if (quality_level[i] > QUALITY_FIRST) {
+								quality_level[i] -= 1;
+							}
+							quality_level_flag[i] = 0;
+							smartrc_set_stream_quality(quality_level[i], i);
+							printf("return to quality %d.\n", quality_level[i]);
+						}
+					}
+					motion_high_cnt[i] = 0;
+					prev = curr;
+				}
+			}
+			//printf("current motion level = %d, current noise level = %d\n", motion_level, noise_level);
+			smartrc_get_motion_level(&real_motion_level[i], i);
+			smartrc_get_noise_level(&real_noise_level[i], i);
+			if (motion_level[i] != real_motion_level[i]) {
+				smartrc_set_motion_level(motion_level[i], i);
+			}
+			if (noise_level[i] != real_noise_level[i]) {
+				smartrc_set_noise_level(noise_level[i], i);
+			}
+
+			//ROI
+			roi_session_t *session;
+			session = &g_smartrc_session[i];
+			session->motion_matrix = g_ms[i].fg;
+			session->dsp_pts = dsp_pts;
+			if (smartrc_params.roi_interval_flag[i]) {
+				if (total_frames % smartrc_params.roi_interval[i] == 0) {
+					smartrc_update_roi(session, i);
+				}
+			} else {
+				smartrc_update_roi(session, i);
+			}
+
+			if (smartrc_params.vca_on_yuv_flag &&
+					smartrc_params.vca_on_yuv) {
+				do_vca_on_yuv(i);
+			}
+			if (smartrc_params.dump_mot_mat_flag[i] &&
+					smartrc_params.dump_mot_mat[i]) {
+				dump_mot_mat(i);
+			}
+			if (smartrc_params.dump_para_cfg_flag[i] &&
+					smartrc_params.dump_para_cfg[i]) {
+				if (smartrc_get_para_cfg(g_param_cfg[i].buffer, g_param_cfg[i].size,
+					dsp_pts, i) < 0) {
+					printf("Failed to get parameter config!\n");
+					return NULL;
+				}
+				if (amba_transfer_write(g_param_cfg[i].fd, g_param_cfg[i].buffer,
+					g_param_cfg[i].size, TRANS_METHOD_NFS) < 0) {
+					printf("Failed to dump para cfg into file!\n");
+					return NULL;
+				}
+			}
+		}
+
+		if (smartrc_apply_sync_frame(dsp_pts) < 0) {
+			perror("apply_sync_frame");
+			return NULL;
+		}
+	}
+	return NULL;
+}
+
+static int smartrc_thread_start(void)
+{
+	int ret = 0;
+	smartrc_exit_flag = 0;
+
+	if (smartrc_thread_id == 0) {
+		ret = pthread_create(&smartrc_thread_id, NULL, smartrc_mainloop, NULL);
+		if (ret) {
+			perror("smartrc_control pthread create failed!\n");
+		}
+	}
+	return ret;
+}
+
+static int smartrc_auto_run_test()
+{
+	int i;
+	printf("Start smartrc auto control, do not manually set noise/motion level!\n");
+	for (i = 0; i < SMARTRC_MAX_STREAM_NUM; i++) {
+		if (!(stream_selection & (1<<i)))
+			continue;
+
+		if (get_motion_value_start(i) < 0) {
+			printf("Smartrc: get motion level start failed!\n");
+			return -1;
+		}
+	}
+	if (smartrc_thread_start() < 0) {
+		printf("Smartrc: control thread start failed!\n");
+		return -1;
+	}
+	return 0;
+}
+
+static int init_smartrc_lib(void)
+{
+	int i;
+	char file_name[256];
+	version_t version;
+	init_t init_param;
+	param_config_t config;
+	bitrate_target_t target;
+	roi_session_t *session = NULL;
+	struct iav_system_resource resource;
+	struct iav_stream_info info;
+	struct iav_stream_format format;
+	struct iav_h264_cfg h26x_config;
+	struct vindev_fps vsrc_fps;
+	u32 roi_w, roi_h, roi_p;
+
+	if (check_state() < 0) {
+		return -1;
+	}
+	if (smartrc_get_version(&version) < 0) {
+		return -1;
+	} else {
+		printf("\nSmart Rate Control Library Version: %s-%d.%d.%d (Last updated: %x)\n\n",
+			version.description, version.major, version.minor, version.patch, version.mod_time);
+	}
+
+	memset(&init_param, 0, sizeof(init_param));
+	init_param.fd_iav = fd_iav;
+	if (smartrc_init(&init_param) < 0) {
+		printf("Smartrc: init failed!\n");
+		return -1;
+	}
+
+	memset(&config, 0, sizeof(param_config_t));
+	for (i = 0; i < SMARTRC_MAX_STREAM_NUM; i++) {
+		if (!(stream_selection & (1<<i)))
+			continue;
+
+		//do basic check on the stream
+		memset(&resource, 0, sizeof(resource));
+		resource.encode_mode = DSP_CURRENT_MODE;
+		AM_IOCTL(fd_iav, IAV_IOC_GET_SYSTEM_RESOURCE, &resource);
+		if (!resource.enc_dummy_latency) {
+			printf("Please configure encode dummy latency with test_encode first,"
+				"and the value should be in range of 2 ~ 5\n");
+			return -1;
+		}
+
+		//check the input stream id to see whether it's in encoding state
+		info.id = i;
+		AM_IOCTL(fd_iav, IAV_IOC_GET_STREAM_INFO, &info);
+		if (info.state != IAV_STREAM_STATE_ENCODING) {
+			printf("stream %d state invalid\n", i);
+			return -1;
+		}
+		format.id = i;
+		AM_IOCTL(fd_iav, IAV_IOC_GET_STREAM_FORMAT, &format);
+		if (format.type != IAV_STREAM_TYPE_H264) {
+			printf("stream %d is not H.264\n", i);
+			return -1;
+		}
+		if (format.type == IAV_STREAM_TYPE_H264) {
+			if ((format.enc_win.x & 0x0F) || (format.enc_win.y & 0x0F)) {
+				printf("stream offset x: %d, y: %d must be a mutiple of 16 for smartrc\n",
+					format.enc_win.x, format.enc_win.y);
+				return -1;
+			}
+		}
+		config.enc_cfg.codec_type = format.type;
+
+		//check encode width/height valid
+		VERIFY_ENCODE_RESOLUTION(format.enc_win.width, format.enc_win.height);
+		config.stream_id = i;
+		if (format.rotate_cw == 0) {
+			config.enc_cfg.width = format.enc_win.width;
+			config.enc_cfg.height = format.enc_win.height;
+			config.enc_cfg.x = format.enc_win.x;
+			config.enc_cfg.y = format.enc_win.y;
+		} else {
+			config.enc_cfg.width = format.enc_win.height;
+			config.enc_cfg.height = format.enc_win.width;
+			config.enc_cfg.x = format.enc_win.y;
+			config.enc_cfg.y = format.enc_win.x;
+		}
+		config.enc_cfg.roi_width = ROUND_UP(config.enc_cfg.width, MB_SIZE) / MB_SIZE;
+		config.enc_cfg.roi_height = ROUND_UP(config.enc_cfg.height, MB_SIZE) / MB_SIZE;
+
+
+		g_enc_cfg[i].codec_type = format.type;
+		g_enc_cfg[i].src_buf_id = format.buf_id;
+		g_enc_cfg[i].width = config.enc_cfg.width;
+		g_enc_cfg[i].height = config.enc_cfg.height;
+		g_enc_cfg[i].x = config.enc_cfg.x;
+		g_enc_cfg[i].y = config.enc_cfg.y;
+		g_enc_cfg[i].roi_width = config.enc_cfg.roi_width;
+		g_enc_cfg[i].roi_height = config.enc_cfg.roi_height;
+		g_enc_cfg[i].param_inited = 1;
+
+		//cfg sync frame roi param
+		memset(&h26x_config, 0, sizeof(h26x_config));
+		h26x_config.id = i;
+		AM_IOCTL(fd_iav, IAV_IOC_GET_H264_CONFIG, &h26x_config);
+		config.enc_cfg.M = h26x_config.M;
+		config.enc_cfg.N = h26x_config.N;
+
+		if (smartrc_params.bitrate_gap_adjust_flag[i]) {
+			config.bitrate_gap_adj = smartrc_params.bitrate_gap_adjust[i];
+		}
+
+		vsrc_fps.vsrc_id = 0;
+		AM_IOCTL(fd_iav, IAV_IOC_VIN_GET_FPS, &vsrc_fps);
+		config.enc_cfg.fps = vsrc_fps.fps;
+
+		if (update_delay_param(vsrc_fps.fps) < 0) {
+			printf("Update delay param failed!\n");
+			return -1;
+		}
+
+		if (smartrc_param_config(&config) < 0) {
+			printf("Smartrc: init param failed!\n");
+			return -1;
+		}
+
+		//ROI
+		session = &g_smartrc_session[i];
+		if (smartrc_start_roi(session, i) < 0) {
+			printf("Smartrc: session start failed!\n");
+			return -1;
+		}
+
+		if (get_roi_size(&roi_p, &roi_w, &roi_h, i) < 0) {
+			printf("get roi size failed!\n");
+			return -1;
+		}
+		me_buf[i].size = roi_p * roi_h * sizeof(u8);
+		me_buf[i].buffer = malloc(me_buf[i].size);
+		if (me_buf[i].buffer == NULL) {
+			printf("me1 buffer malloc failed!\n");
+			return -1;
+		}
+
+		// dump motion matrix
+		if (smartrc_params.dump_mot_mat_flag[i] &&
+			smartrc_params.dump_mot_mat[i]) {
+			if (g_mt_mat[i].file[0] == '\0') {
+				sprintf(file_name, "%s_stream_%c.dat",
+					default_mt_mat_file, 'A' + i);
+				strcpy(g_mt_mat[i].file, file_name);
+			}
+			g_mt_mat[i].fd = amba_transfer_open(g_mt_mat[i].file, TRANS_METHOD_NFS, MM_DUMP_BASE + i);
+			if (g_mt_mat[i].fd < 0) {
+				printf("Cannot open file [%s].\n", g_mt_mat[i].file);
+				return -1;
+			}
+			g_mt_mat[i].size = (roi_w + 1) * (roi_h + 1); // extra 1 row and column for '\n'
+			g_mt_mat[i].buffer = (char *)malloc(g_mt_mat[i].size * sizeof(char));
+			if (!g_mt_mat[i].buffer) {
+				printf("Not enough memory for dump buffer!\n");
+				return -1;
+			} else {
+				memset(g_mt_mat[i].buffer, 0, g_mt_mat[i].size*sizeof(char));
+			}
+		}
+
+		//dump parameter configuration
+		if (smartrc_params.dump_para_cfg_flag[i] &&
+				smartrc_params.dump_para_cfg[i]) {
+			if (g_param_cfg[i].file[0] == '\0') {
+				sprintf(file_name, "%s_stream_%c.cfg",
+					default_param_file, 'A' + i);
+				strcpy(g_param_cfg[i].file, file_name);
+			}
+			g_param_cfg[i].fd = amba_transfer_open(g_param_cfg[i].file, TRANS_METHOD_NFS, PC_DUMP_BASE + i);
+			if (g_param_cfg[i].fd < 0) {
+				printf("Cannot open file [%s].\n", g_param_cfg[i].file);
+				return -1;
+			}
+			g_param_cfg[i].size = PC_DUMP_SIZE;
+			g_param_cfg[i].buffer = (char *) malloc(g_param_cfg[i].size * sizeof(char));
+			if (!g_param_cfg[i].buffer) {
+				printf("Not enough memory for dump buffer!\n");
+				return -1;
+			} else {
+				memset(g_param_cfg[i].buffer, 0, g_param_cfg[i].size * sizeof(char));
+			}
+		}
+
+		//apply initial cmdline setting here
+		if (smartrc_params.stream_quality_flag[i]) {
+			if (smartrc_set_stream_quality(smartrc_params.stream_quality[i], i) < 0) {
+				printf("Smartrc: set stream quality %d for stream %d failed!\n",
+					smartrc_params.stream_quality[i], i);
+			}
+		}
+		if (smartrc_params.bitrate_ceiling_flag[i]) {
+			target.auto_target = 0;
+			target.bitrate_ceiling = smartrc_params.bitrate_ceiling[i];
+			if (smartrc_set_bitrate_target(&target, i) < 0) {
+				printf("Smartrc: set bitrate ceiling %d for stream %d failed\n",
+					smartrc_params.bitrate_ceiling[i], i);
+			}
+		}
+
+		if (smartrc_params.style_flag[i]) {
+			if (smartrc_set_style(smartrc_params.style[i], i) < 0) {
+				printf("Smartrc: set style %d for stream %d failed\n",
+					smartrc_params.style[i], i);
+			}
+		}
+		if (smartrc_params.motion_level_flag[i]) {
+			if (smartrc_set_motion_level(smartrc_params.motion_level[i], i) < 0) {
+				printf("Smartrc: set motion level %d for stream %d failed!\n",
+					smartrc_params.motion_level[i], i);
+			}
+		}
+		if (smartrc_params.noise_level_flag[i]) {
+			if (smartrc_set_noise_level(smartrc_params.noise_level[i], i) < 0) {
+				printf("Smartrc: set noise level %d for stream %d failed!\n",
+					smartrc_params.noise_level[i], i);
+			}
+		}
+	}
+	return 0;
+}
+
+static int deinit_smartrc_lib(void)
+{
+	int i;
+	roi_session_t *session = NULL;
+
+	smartrc_thread_stop();
+	for (i = 0; i < SMARTRC_MAX_STREAM_NUM; i++) {
+		if (!(stream_selection & (1<<i)))
+			continue;
+
+		session = &g_smartrc_session[i];
+		smartrc_stop_roi(session, i);
+		get_motion_value_stop(i);
+		if (me_buf[i].buffer) {
+			free(me_buf[i].buffer);
+			me_buf[i].buffer = NULL;
+		}
+		if (smartrc_params.dump_para_cfg[i]) {
+			amba_transfer_close(g_param_cfg[i].fd, TRANS_METHOD_NFS);
+			if (g_param_cfg[i].buffer) {
+				free(g_param_cfg[i].buffer);
+				g_param_cfg[i].buffer = NULL;
+			}
+		}
+		if (smartrc_params.dump_mot_mat[i]) {
+			amba_transfer_close(g_mt_mat[i].fd, TRANS_METHOD_NFS);
+			if (g_mt_mat[i].buffer) {
+				free(g_mt_mat[i].buffer);
+				g_mt_mat[i].buffer = NULL;
+			}
+		}
+		g_enc_cfg[i].param_inited = 0;
+		smartrc_set_motion_level(MOTION_HIGH, i);
+		smartrc_set_noise_level(NOISE_NONE, i);
+	}
+	smartrc_deinit();
+	exit_iav();
+	printf("Quit test smartrc\n");
+
+	return 0;
+}
+
+static void sigstop(int signo)
+{
+	deinit_smartrc_lib();
+	exit(0);
+}
+
+int main(int argc, char **argv)
+{
+	char ch, error_opt;
+	int quit_flag;
+
+	signal(SIGINT, sigstop);
+	signal(SIGTERM, sigstop);
+	signal(SIGQUIT, sigstop);
+
+	if (argc < 2) {
+		usage();
+		return -1;
+	}
+
+	if (init_param(argc, argv) < 0) {
+		return -1;
+	}
+
+	if (smartrc_params.param_set_flag) {
+		set_base_param();
+	}
+
+	if (init_iav() < 0) {
+		return -1;
+	}
+
+	if (smartrc_params.log_level_flag) {
+		if (smartrc_set_log_level(smartrc_params.log_level) < 0) {
+			printf("Set log level failed!\n");
+		}
+	}
+
+	if (init_smartrc_lib() < 0 ) {
+		return -1;
+	}
+
+	if (smartrc_auto_run_test() < 0) {
+		return -1;
+	}
+
+	//interactive
+	show_menu();
+	ch = getchar();
+	while (ch) {
+		quit_flag = 0;
+		error_opt = 0;
+		switch (ch) {
+		case 's':
+			show_param_setting();
+			break;
+		case 'q':
+			quit_flag = 1;
+			break;
+		default:
+			error_opt = 1;
+			break;
+		}
+		if (quit_flag)
+			break;
+		if (error_opt == 0)
+			show_menu();
+		ch = getchar();
+	}
+
+	if (deinit_smartrc_lib() < 0) {
+		return -1;
+	}
+
+	return 0;
+}
diff --git a/package_test/test_textinsert.c b/package_test/test_textinsert.c
index e1a8427..985761a 100644
--- a/package_test/test_textinsert.c
+++ b/package_test/test_textinsert.c
@@ -3,12 +3,29 @@
  *
  * History:
  *  2014/03/19 - [ywang] created file
- * Copyrigt (C) 2007-2011, Ambarella, Inc
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- *  All rights reserved. No Part of this file may be reproduced, stored in a
- *  retrieval system, or transmitterd, in any form, or any means,
- *  electronic, mechanical, photocopying, recording, or otherwise, without the
- *  prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 #include <stdio.h>
@@ -30,6 +47,7 @@
 
 #include <basetypes.h>
 #include <iav_ioctl.h>
+#include <locale.h>
 #include "text_insert.h"
 
 #define MAX_ENCODE_STREAM_NUM	(4)
@@ -169,8 +187,13 @@ wchar_t wText[][STRING_SIZE] = {
 	L"(Chinese)"
 };
 
-#define FONTTYPE_NUM		4
-char font_type[][MAX_BYTE_SIZE] = {
+enum font_type {
+	FONT_TYPE_ENGLISH		= 0,
+	FONT_TYPE_CHINESE		= 1,
+	FONT_TYPE_NUM
+};
+
+char font_type[FONT_TYPE_NUM][MAX_BYTE_SIZE] = {
 	"/usr/share/fonts/DroidSans.ttf",
 	"/usr/share/fonts/DroidSansFallbackFull.ttf"
 };
@@ -278,8 +301,20 @@ static void get_time_string(char *str)
 	        (1 + p->tm_mon), p->tm_mday, p->tm_hour, p->tm_min, p->tm_sec);
 }
 
-static int char_to_wchar(const char* orig_str, wchar_t *wtext, int max_length)
+static int char_to_wchar(int font_type, const char* orig_str, wchar_t *wtext, int max_length)
 {
+	switch (font_type) {
+	case FONT_TYPE_ENGLISH:
+		setlocale(LC_ALL,"");
+		break;
+	case FONT_TYPE_CHINESE:
+		setlocale(LC_ALL,"zh_CN.utf8");
+		break;
+	default:
+		setlocale(LC_ALL,"");
+		break;
+	}
+
 	if (-1 == mbstowcs(wtext, orig_str, max_length - 1))
 		return -1;
 	if (wcscat(wtext, L"") == NULL)
@@ -393,7 +428,7 @@ static int init_param(int argc, char **argv)
 		case SPECIFY_STRING:
 			VERIFY_STREAMID(stream_id);
 			VERIFY_AREAID(area_id);
-			if (char_to_wchar(optarg,
+			if (char_to_wchar(stream_text_info[stream_id].textbox[area_id].font_type, optarg,
 				stream_text_info[stream_id].textbox[area_id].content,
 				sizeof(stream_text_info[stream_id].textbox[area_id].content)) < 0) {
 				printf("Convert to wchar failed. Use default string.\n");
@@ -501,7 +536,8 @@ static int map_overlay(void)
 
 static int check_param(void)
 {
-	int i, j, win_width, win_height;
+	u8 i, j;
+	int win_width, win_height;
 	textbox_t *box;
 	char str[STRING_SIZE];
 	static int default_fontsize = 16;
@@ -514,7 +550,7 @@ static int check_param(void)
 				box = &stream_text_info[i].textbox[j];
 				if (box->enable) {
 					sprintf(str, "Stream %c Textbox %d", 'A' + i, j);
-					if (box->font_type < 0 || box->font_type >= FONTTYPE_NUM)
+					if (box->font_type < 0 || box->font_type >= FONT_TYPE_NUM)
 						box->font_type = 0;
 					if (box->font_size <= 0)
 						box->font_size = default_fontsize;
@@ -560,10 +596,10 @@ static int check_param(void)
 							box->italic = 0;
 						}
 						get_time_string(box->time.time_string);
-						char_to_wchar(box->time.time_string, box->content,
-						              sizeof(box->content));
-						memset(box->time.osd_x, NOT_CONVERTED, STRING_SIZE);
-						memset(box->time.osd_y, NOT_CONVERTED, STRING_SIZE);
+						char_to_wchar(box->font_type, box->time.time_string, box->content,
+							sizeof(box->content));
+						memset(box->time.osd_x, NOT_CONVERTED, STRING_SIZE * sizeof(int));
+						memset(box->time.osd_y, NOT_CONVERTED, STRING_SIZE * sizeof(int));
 						box->time.digit_height = LINE_SPACING(box->font_size);
 						box->time.digit_width = FIXED_DIGIT_WIDTH(box->font_size);
 					}
diff --git a/shmoo_test/make.inc b/shmoo_test/make.inc
index 583c4f6..db2b9d1 100644
--- a/shmoo_test/make.inc
+++ b/shmoo_test/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2013/12/20 - [BingLiang Hu] Created file
 ##
-## Copyright (C) 2011-2015, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_UNIT_TESTS_SHMOO), y)
diff --git a/shmoo_test/shmoo.sh b/shmoo_test/shmoo.sh
index 46aafbe..3196165 100644
--- a/shmoo_test/shmoo.sh
+++ b/shmoo_test/shmoo.sh
@@ -1,4 +1,32 @@
 #!/bin/sh
+## History:
+##
+## 2016/12/30 - [JianTang] Created file
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
 export PATH="$PATH:/bin:/sbin"
 echo "wait ethernet connect" > /dev/ttyS0
 while true;do
diff --git a/shmoo_test/shmoo_memtester.sh b/shmoo_test/shmoo_memtester.sh
index 68a01f7..74e5478 100644
--- a/shmoo_test/shmoo_memtester.sh
+++ b/shmoo_test/shmoo_memtester.sh
@@ -1,8 +1,33 @@
 #!/bin/sh
-# Program:
-#	shmoo DLL
-# History:
-#
+## History:
+##
+## 2016/12/30 - [JianTang] Created file
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
 #HowTo
 #	build memster in unit_test->linux->benchmark
 #	edit your start value dll_start, shmoo_step, memtester lengh and confirm your preview frequency
diff --git a/shmoo_test/test_shmoo.c b/shmoo_test/test_shmoo.c
index 4c6a624..46644cb 100644
--- a/shmoo_test/test_shmoo.c
+++ b/shmoo_test/test_shmoo.c
@@ -5,12 +5,29 @@
  *	2013/12/17 - [Bingliang Hu] modified file
  *	2010/11/30 - [Jian Tang] created file
  *
- * Copyright (C) 2013-2015, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
diff --git a/vin_test/decoder/rn6243.c b/vin_test/decoder/rn6243.c
index 2ffee3c..0a3c2de 100644
--- a/vin_test/decoder/rn6243.c
+++ b/vin_test/decoder/rn6243.c
@@ -4,12 +4,29 @@
  * History:
  *	2010/12/05 - [Louis Sun] create
  *
- * Copyright (C) 2007-2010, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
diff --git a/vin_test/make.inc b/vin_test/make.inc
index f3d0c05..478d305 100644
--- a/vin_test/make.inc
+++ b/vin_test/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/05 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2011-2015, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_UNIT_TESTS_VIN), y)
diff --git a/vin_test/test_vin.c b/vin_test/test_vin.c
index a7fa702..cc4b987 100644
--- a/vin_test/test_vin.c
+++ b/vin_test/test_vin.c
@@ -4,12 +4,29 @@
  * History:
  *	2009/08/05 - [Qiao Wang] create
  *
- * Copyright (C) 2007-2009, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 #include <unistd.h>
@@ -47,6 +64,7 @@ static int test_vin_shutter_flag = 0;
 static int shutter_time = 0;
 static int test_agc_index_flag = 0;
 static int agc_index = -1;
+static int test_vin_stop_stream_flag = 0;
 static u32 reg_op = 0;	/* 0: nothing; 1: read; 2: write  */
 static u32 reg_addr = 0;
 static u32 reg_data = 0;
@@ -61,9 +79,9 @@ static u32 reg_count = 1;
 static struct option long_options[] = {
 	{"vin", HAS_ARG, 0, 'i'},
 	{"src", HAS_ARG, 0, 'S'},
-	{"frame-rate", HAS_ARG, 0, 'F'},
-	{"mirror_pattern", HAS_ARG, 0, 42},
-	{"bayer_pattern", HAS_ARG, 0, 44},
+	{"frame-rate", HAS_ARG, 0, 'f'},
+	{"mirror_pattern", HAS_ARG, 0, 'm'},
+	{"bayer_pattern", HAS_ARG, 0, 'b'},
 	{"anti_flicker", HAS_ARG, 0, 45},
 	{"test-rn6243",   HAS_ARG,  0, 'R'},
 	{"test-fps", NO_ARG, 0, 't'},
@@ -73,10 +91,11 @@ static struct option long_options[] = {
 	{"reg-count", NO_ARG, 0, 'n'},
 	{"shutter", HAS_ARG, 0, 's'},
 	{"agc-index", HAS_ARG, 0, 'g'},
+	{"stop-stream", NO_ARG, 0, 'e'},
 	{0, 0, 0, 0}
 };
 
-static const char *short_options = "i:S:F:r:tr:w:d:n:s:g:";
+static const char *short_options = "i:S:f:m:b:R:tr:w:d:n:s:g:e";
 
 struct hint_s {
 	const char *arg;
@@ -98,6 +117,7 @@ static const struct hint_s hint[] = {
 	{"count", "register count to read/write"},
 	{"1-8000", "set shutter time in 1/n sec format"},
 	{"0-agc max index", "set agc index, -n for index count"},
+	{"", "\tstop vin device streaming"},
 };
 
 int init_param(int argc, char **argv)
@@ -120,21 +140,29 @@ int init_param(int argc, char **argv)
 			source = atoi(optarg);
 			break;
 
-		case 'F':
+		case 'f':
 			vin_framerate_flag = 1;
 			vin_framerate = atoi(optarg);
+			switch (vin_framerate) {
+			case 0:
+				vin_framerate = AMBA_VIDEO_FPS_AUTO;
+				break;
+			default:
+				vin_framerate = DIV_ROUND(512000000, vin_framerate);
+				break;
+			}
 			break;
 
-		case 42:
+		case 'm':
 			mirror_pattern = atoi(optarg);
-			if(mirror_pattern<0)
+			if (mirror_pattern < 0)
 				return -1;
 			mirror_mode.pattern = mirror_pattern;
 			break;
 
-		case 44:
+		case 'b':
 			bayer_pattern = atoi(optarg);
-			if(bayer_pattern<0)
+			if (bayer_pattern < 0)
 				return -1;
 			mirror_mode.bayer_pattern = bayer_pattern;
 			break;
@@ -181,6 +209,10 @@ int init_param(int argc, char **argv)
 				return -1;
 			break;
 
+		case 'e':
+			test_vin_stop_stream_flag = 1;
+			break;
+
 		default:
 			printf("unknown option found: %c\n", ch);
 			return -1;
@@ -307,6 +339,19 @@ int test_agc_index()
 	return 0;
 }
 
+int test_vin_stop_stream()
+{
+	int rval;
+
+	rval = ioctl(fd_iav, IAV_IOC_VIN_STOP_STREAM, &source);
+	if (rval < 0) {
+		perror("IAV_IOC_VIN_STOP_STREAM\n");
+		return rval;
+	}
+
+	return 0;
+}
+
 static int vin_reg(void)
 {
 	struct vindev_reg reg;
@@ -405,6 +450,11 @@ int main(int argc, char **argv)
 			return -1;
 	}
 
+	if (vin_framerate_flag) {
+		if (set_vin_frame_rate()< 0)
+			return -1;
+	}
+
 	//test vin fps
 	if (test_vin_fps_flag) {
 		if(test_vin_fps() < 0)
@@ -421,6 +471,11 @@ int main(int argc, char **argv)
 			return -1;
 	}
 
+	if (test_vin_stop_stream_flag) {
+		if(test_vin_stop_stream() < 0)
+			return -1;
+	}
+
 	return 0;
 }
 
diff --git a/vin_test/vin_init.c b/vin_test/vin_init.c
index 466353b..5a660d4 100644
--- a/vin_test/vin_init.c
+++ b/vin_test/vin_init.c
@@ -4,12 +4,29 @@
  * History:
  *	2009/11/17 - [Qiao Wang] create
  *
- * Copyright (C) 2007-2009, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
@@ -105,6 +122,14 @@ struct vin_mode_s __vin_modes[] = {
 	{"2560x2048",	AMBA_VIDEO_MODE_2560_2048	},
 	{"848x480",	AMBA_VIDEO_MODE_848_480	},
 	{"3072x1728",	AMBA_VIDEO_MODE_3072_1728	},
+	{"2048x2048",	AMBA_VIDEO_MODE_2048_2048	},
+	{"7680x4320",	AMBA_VIDEO_MODE_7680_4320	},
+	{"5472x3648",	AMBA_VIDEO_MODE_5472_3648	},
+	{"2688x1944",	AMBA_VIDEO_MODE_2688_1944	},
+	{"640x512",	AMBA_VIDEO_MODE_640_512	},
+	{"1920x1920",	AMBA_VIDEO_MODE_1920_1920	},
+	{"1600x1600",	AMBA_VIDEO_MODE_1600_1600	},
+	{"1632x1632",	AMBA_VIDEO_MODE_1632_1632	},
 	{"poweroff",	AMBA_VIDEO_MODE_OFF	},
 
 
@@ -397,7 +422,7 @@ void test_print_video_info( const struct amba_video_info *pvinfo, int active_fla
 		break;
 	case AMBA_VIDEO_LINEAR_MODE:
 	default:
-		snprintf(hdrmode, 32, "%s", "");
+		snprintf(hdrmode, 32, "%s", "(Linear)");
 		break;
 	}
 
@@ -493,7 +518,7 @@ void test_print_video_info( const struct amba_video_info *pvinfo, int active_fla
 void check_source_info(void)
 {
 	char					format[32];
-	u32					i, j, k;
+	int					i, j, k;
 	struct vindev_devinfo			vsrc_info;
 	struct vindev_video_info		video_info;
 
@@ -510,33 +535,37 @@ void check_source_info(void)
 
 	if (vsrc_info.dev_type == VINDEV_TYPE_SENSOR) {
 		printf("it supports:\n");
+		printf("Default mode:\n");
+		memset(&video_info, 0, sizeof(video_info));
+		video_info.info.mode = AMBA_VIDEO_MODE_AUTO;
+		video_info.info.hdr_mode = AMBA_VIDEO_LINEAR_MODE;
+		video_info.info.bits = AMBA_VIDEO_BITS_AUTO;
+		if (ioctl(fd_iav, IAV_IOC_VIN_GET_VIDEOINFO, &video_info) < 0) {
+			perror("IAV_IOC_VIN_GET_VIDEOINFO");
+			return;
+		}
+		test_print_video_info(&video_info.info, 0);
+		printf("------------:\n");
 
 		for (i = 0; i < AMBA_VIDEO_MODE_NUM; i++) {
+			if (i == AMBA_VIDEO_MODE_AUTO)
+				continue;
 			for (j = AMBA_VIDEO_MODE_FIRST; j < AMBA_VIDEO_MODE_LAST; j++) {
-				video_info.vsrc_id = 0;
-				video_info.info.hdr_mode = j;
-				video_info.info.mode = amba_video_mode_index2mode(i);
 				for (k = AMBA_VIDEO_BITS_8; k <= AMBA_VIDEO_BITS_16; k += 2) {
-					if (i == AMBA_VIDEO_MODE_AUTO)
-						video_info.info.bits = AMBA_VIDEO_BITS_AUTO;
-					else
-						video_info.info.bits = k;
-
+					memset(&video_info, 0, sizeof(video_info));
+					video_info.info.mode = amba_video_mode_index2mode(i);
+					video_info.info.hdr_mode = j;
+					video_info.info.bits = k;
 					if (ioctl(fd_iav, IAV_IOC_VIN_GET_VIDEOINFO, &video_info) < 0) {
-						if (errno == EINVAL)
+						if (errno == EINVAL) {
+							errno = 0;
 							continue;
-
+						}
 						perror("IAV_IOC_VIN_GET_VIDEOINFO");
 						break;
 					}
-
 					test_print_video_info(&video_info.info, 0);
-
-					if (i == AMBA_VIDEO_MODE_AUTO)
-						break;
 				}
-				if (i == AMBA_VIDEO_MODE_AUTO)
-					break;
 			}
 		}
 	} else {
@@ -562,8 +591,8 @@ void check_source_info(void)
 		}
 		printf("Channel[%s]'s type is %s\n", vsrc_info.name, format);
 
+		memset(&video_info, 0, sizeof(video_info));
 		video_info.info.mode = AMBA_VIDEO_MODE_AUTO;
-		video_info.vsrc_id = 0;
 		if (ioctl(fd_iav, IAV_IOC_VIN_GET_VIDEOINFO, &video_info) < 0) {
 			perror("IAV_IOC_VIN_GET_VIDEOINFO");
 			return;
diff --git a/vout_test/lcd/lcd_api.h b/vout_test/lcd/lcd_api.h
index 9e6d10b..b0a53e2 100644
--- a/vout_test/lcd/lcd_api.h
+++ b/vout_test/lcd/lcd_api.h
@@ -4,190 +4,39 @@
  * History:
  *	2009/05/20 - [Anthony Ginger] created file
  *
- * Copyright (C) 2007-2009, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
 #ifndef __LCD_API_H__
 #define __LCD_API_H__
 
-#include <unistd.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <sys/ioctl.h>
-#include <linux/types.h>
-#include <linux/spi/spidev.h>
-
-#include "basetypes.h"
-
 #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
-#define GPIO(x)				(x)
 
 /******************************************/
 typedef int (*LCD_SETMODE_FUNC)(int mode, struct amba_video_sink_mode *pcfg);
 typedef int (*LCD_POST_SETMODE_FUNC)(int mode);
 
-
-/* ========================================================================== */
-static void gpio_set(u8 gpio_id)
-{
-	int _export, direction, unexport;
-	char buf[128];
-
-	_export = open("/sys/class/gpio/export", O_WRONLY);
-	if (_export < 0) {
-		printf("%s: Can't open export sys file!\n", __func__);
-		goto gpio_set_exit;
-	}
-	sprintf(buf, "%d", gpio_id);
-	write(_export, buf, sizeof(buf));
-	close(_export);
-
-	sprintf(buf, "/sys/class/gpio/gpio%d/direction", gpio_id);
-	direction = open(buf, O_WRONLY);
-	if (direction < 0) {
-		printf("%s: Can't open direction sys file!\n", __func__);
-		goto gpio_set_exit;
-	}
-	sprintf(buf, "high");
-	write(direction, buf, sizeof(buf));
-	close(direction);
-
-	unexport = open("/sys/class/gpio/unexport", O_WRONLY);
-	if (unexport < 0) {
-		printf("%s: Can't open unexport sys file!\n", __func__);
-		goto gpio_set_exit;
-	}
-	sprintf(buf, "%d", gpio_id);
-	write(unexport, buf, sizeof(buf));
-	close(unexport);
-
-gpio_set_exit:
-	return;
-}
-
-static void gpio_clr(u8 gpio_id)
-{
-	int _export, direction, unexport;
-	char buf[128];
-
-	_export = open("/sys/class/gpio/export", O_WRONLY);
-	if (_export < 0) {
-		printf("%s: Can't open export sys file!\n", __func__);
-		goto gpio_clr_exit;
-	}
-	sprintf(buf, "%d", gpio_id);
-	write(_export, buf, sizeof(buf));
-	close(_export);
-
-	sprintf(buf, "/sys/class/gpio/gpio%d/direction", gpio_id);
-	direction = open(buf, O_WRONLY);
-	if (direction < 0) {
-		printf("%s: Can't open direction sys file!\n", __func__);
-		goto gpio_clr_exit;
-	}
-	sprintf(buf, "low");
-	write(direction, buf, sizeof(buf));
-	close(direction);
-
-	unexport = open("/sys/class/gpio/unexport", O_WRONLY);
-	if (unexport < 0) {
-		printf("%s: Can't open unexport sys file!\n", __func__);
-		goto gpio_clr_exit;
-	}
-	sprintf(buf, "%d", gpio_id);
-	write(unexport, buf, sizeof(buf));
-	close(unexport);
-
-gpio_clr_exit:
-	return;
-}
-
-#define	PARAMETERS_PATH1(param)	"/sys/module/ambarella_config/parameters/"param
-#define	PARAMETERS_PATH2(param)	"/sys/module/board/parameters/"param
-#define MAX_STR_LEN		64
-
-typedef struct {
-	int	fd;
-	int	value;
-} lcd_parameter_t;
-
-static void lcd_power_on(void)
-{
-	lcd_parameter_t		gpio, level, delay;
-	char			buf[MAX_STR_LEN];
-	int			size;
-
-	gpio.fd = open(PARAMETERS_PATH1("board_lcd_power_gpio_id"), O_RDONLY);
-	if (gpio.fd < 0) {
-		gpio.fd = open(PARAMETERS_PATH2("board_lcd_power_gpio_id"), O_RDONLY);
-	}
-	if (gpio.fd < 0) {
-		perror("Unable to read lcd power gpio id");
-		goto lcd_power_on_exit;
-	}
-	size = read(gpio.fd, buf, MAX_STR_LEN);
-	if (size <= 0) {
-		perror("Unable to read lcd power gpio id");
-		goto lcd_power_on_exit;
-	}
-	buf[size] = '\0';
-	gpio.value = atoi(buf);
-
-	level.fd = open(PARAMETERS_PATH1("board_lcd_power_active_level"), O_RDONLY);
-	if (level.fd < 0) {
-		level.fd = open(PARAMETERS_PATH2("board_lcd_power_active_level"), O_RDONLY);
-	}
-	if (level.fd < 0) {
-		perror("Unable to read lcd power active level");
-		goto lcd_power_on_exit;
-	}
-	size = read(level.fd, buf, MAX_STR_LEN);
-	if (size <= 0) {
-		perror("Unable to read lcd power active level");
-		goto lcd_power_on_exit;
-	}
-	buf[size] = '\0';
-	level.value = atoi(buf);
-
-	delay.fd = open(PARAMETERS_PATH1("board_lcd_power_active_delay"), O_RDONLY);
-	if (delay.fd < 0) {
-		delay.fd = open(PARAMETERS_PATH2("board_lcd_power_active_delay"), O_RDONLY);
-	}
-	if (delay.fd < 0) {
-		perror("Unable to read lcd power active delay");
-		goto lcd_power_on_exit;
-	}
-	size = read(delay.fd, buf, MAX_STR_LEN);
-	if (size <= 0) {
-		perror("Unable to read lcd power active delay");
-		goto lcd_power_on_exit;
-	}
-	buf[size] = '\0';
-	delay.value = atoi(buf);
-
-	if (gpio.value < 0 || level.value < 0 || delay.value < 0) {
-		goto lcd_power_on_exit;
-	}
-
-	if (level.value) {
-		gpio_set(gpio.value);
-		usleep(delay.value << 10);
-	} else {
-		gpio_clr(gpio.value);
-		usleep(delay.value << 10);
-	}
-
-lcd_power_on_exit:
-	return;
-}
-
 #endif //__LCD_API_H__
diff --git a/vout_test/lcd/lcd_digital.c b/vout_test/lcd/lcd_digital.c
index b175e03..d2cfa4c 100644
--- a/vout_test/lcd/lcd_digital.c
+++ b/vout_test/lcd/lcd_digital.c
@@ -4,12 +4,29 @@
  * History:
  *	2009/05/20 - [Anthony Ginger] created file
  *
- * Copyright (C) 2007-2009, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
@@ -19,7 +36,7 @@ static int lcd_digital_init(struct amba_video_sink_mode *pvout_cfg, int mode)
 	pvout_cfg->mode = mode;
 	pvout_cfg->ratio = AMBA_VIDEO_RATIO_AUTO;
 	pvout_cfg->bits = AMBA_VIDEO_BITS_AUTO;
-	pvout_cfg->type = AMBA_VIDEO_TYPE_AUTO;
+	pvout_cfg->type = AMBA_VIDEO_TYPE_YUV_656;
 	pvout_cfg->format = AMBA_VIDEO_FORMAT_AUTO;
 	pvout_cfg->sink_type = AMBA_VOUT_SINK_TYPE_DIGITAL;
 
diff --git a/vout_test/lcd/lcd_digital601.c b/vout_test/lcd/lcd_digital601.c
index e790e65..674ff12 100644
--- a/vout_test/lcd/lcd_digital601.c
+++ b/vout_test/lcd/lcd_digital601.c
@@ -4,12 +4,29 @@
  * History:
  *	2009/05/20 - [Anthony Ginger] created file
  *
- * Copyright (C) 2007-2009, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
diff --git a/vout_test/lcd/lcd_ili8961.c b/vout_test/lcd/lcd_ili8961.c
new file mode 100644
index 0000000..b4157e7
--- /dev/null
+++ b/vout_test/lcd/lcd_ili8961.c
@@ -0,0 +1,173 @@
+/*******************************************************************************
+ * lcd_ili8961.c
+ *
+ * History:
+ *    2010/09/28 - [Zhenwu Xue] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ( "Software" ) are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *******************************************************************************/
+/* ========================================================================== */
+#include <linux/spi/spidev.h>
+
+/* ========================================================================== */
+static void lcd_ili8961_config_960x240()
+{
+	int status = 0;
+	int spi_fd,ret = 0,size;
+	int mode = 0, bits = 16, speed = 1200 * 1000;
+
+	status = system("/usr/local/bin/amba_debug -g 9 -d 0x1");// workaround to  open backlight
+
+	if (WEXITSTATUS(status)) {
+		printf("result verify: %s failed!\n", "amba_debug");
+	}
+
+#if 1   // config registers
+
+	spi_fd = open("/dev/spidev0.0", O_RDWR, 0);
+
+	if(spi_fd<0){
+		perror("can't open spi node!\n");
+		goto lcd_ili8961_config_960x240_exit;
+	}
+
+
+	ret = ioctl(spi_fd, SPI_IOC_WR_MODE, &mode);
+	if (ret < 0) {
+		perror("can't set spi mode!\n");
+		goto lcd_ili8961_config_960x240_exit;
+	}
+
+	ret = ioctl(spi_fd, SPI_IOC_WR_BITS_PER_WORD, &bits);
+	if (ret < 0) {
+		perror("can't set bits per word!\n");
+		goto lcd_ili8961_config_960x240_exit;
+	}
+
+	ret = ioctl(spi_fd, SPI_IOC_WR_MAX_SPEED_HZ, &speed);
+	if (ret < 0) {
+		perror("can't set max speed hz!\n");
+		goto lcd_ili8961_config_960x240_exit;
+	}
+
+	{
+		/*
+			wr_cmd(0x05,0x5F);
+			Delayms(5);
+			wr_cmd(0x05,0x1F);//reset
+			Delayms(10);
+			wr_cmd(0x05,0x5F);
+			Delayms(50);
+			wr_cmd(0x2B,0x01);//exit standby mode
+			wr_cmd(0x00,0x09);//VCOMAC
+			wr_cmd(0x01,0x9F);//VCOMDC
+			wr_cmd(0x04,0x09);//8-bit RGB interface
+			wr_cmd(0x16,0x04);//Default Gamma setting  2.2
+		*/
+
+		#define REG_NUM 8
+
+		u8   dly[REG_NUM]={5,10,50,0,0,0,0,0},cnt;
+		u16  reg[REG_NUM] ={0x55f,
+					  0x051f,
+					  0x055f,
+					  0x2b01,
+					  0x0009,
+					  0x019f,
+					  //0x2f71,
+					  0x040b,  //0x409,
+					  0x1604
+						};
+		u16	*w16 = NULL;
+		size=1;
+
+		for(cnt=0;cnt<REG_NUM;cnt++){
+
+			w16=reg+cnt;
+			ret = write(spi_fd, w16, size << 1);
+			if (ret != (size << 1)) {
+				perror("write error!\n");
+				goto lcd_ili8961_config_960x240_exit;
+			}
+
+			if(dly[cnt]!=0)
+			 	usleep(dly[cnt]*1000);
+		}
+	}
+
+#endif
+
+lcd_ili8961_config_960x240_exit:
+
+	return;
+}
+
+/* ========================================================================== */
+
+
+static int lcd_ili8961_960x240(struct amba_video_sink_mode *pvout_cfg,
+	enum amba_vout_lcd_mode_info lcd_mode)
+{
+	pvout_cfg->mode		= AMBA_VIDEO_MODE_960_240;
+	pvout_cfg->ratio	= AMBA_VIDEO_RATIO_16_9;
+	pvout_cfg->bits		= AMBA_VIDEO_BITS_8;
+	pvout_cfg->type		= AMBA_VIDEO_TYPE_RGB_601;
+	pvout_cfg->format	= AMBA_VIDEO_FORMAT_PROGRESSIVE;
+	pvout_cfg->sink_type	= AMBA_VOUT_SINK_TYPE_DIGITAL;
+
+	pvout_cfg->bg_color.y	= 0x10;
+	pvout_cfg->bg_color.cb	= 0x80;
+	pvout_cfg->bg_color.cr	= 0x80;
+
+	pvout_cfg->lcd_cfg.mode	= lcd_mode;
+	pvout_cfg->lcd_cfg.seqt	= AMBA_VOUT_LCD_SEQ_R0_G1_B2;
+	pvout_cfg->lcd_cfg.seqb	= AMBA_VOUT_LCD_SEQ_G0_B1_R2; // AMBA_VOUT_LCD_SEQ_R0_G1_B2
+	pvout_cfg->lcd_cfg.dclk_edge = AMBA_VOUT_LCD_CLK_RISING_EDGE;
+	pvout_cfg->lcd_cfg.dclk_freq_hz	= 27000000;
+	pvout_cfg->lcd_cfg.hvld_pol = AMBA_VOUT_LCD_HVLD_POL_HIGH;
+
+	lcd_ili8961_config_960x240();  // open backlight + config registers
+
+	return 0;
+}
+
+
+int lcd_ili8961_setmode(int mode, struct amba_video_sink_mode *pcfg)
+{
+	int				errCode = 0;
+
+	switch(mode) {
+	case AMBA_VIDEO_MODE_960_240:
+		//errCode = lcd_ili8961_960x240(pcfg, AMBA_VOUT_LCD_MODE_1COLOR_PER_DOT);
+		errCode = lcd_ili8961_960x240(pcfg, AMBA_VOUT_LCD_MODE_1COLOR_PER_DOT);
+		break;
+
+	default:
+		errCode = -1;
+	}
+
+	return errCode;
+}
+
diff --git a/vout_test/lcd/lcd_st7789v.c b/vout_test/lcd/lcd_st7789v.c
new file mode 100644
index 0000000..0ea56e3
--- /dev/null
+++ b/vout_test/lcd/lcd_st7789v.c
@@ -0,0 +1,409 @@
+/*******************************************************************************
+ * lcd_st7789v.c
+ *
+ * History:
+ *    2016/03/11 - [BingLiang Hu] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ( "Software" ) are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *******************************************************************************/
+/* ========================================================================== */
+#include <linux/spi/spidev.h>
+
+
+/* ========================================================================== */
+
+
+#define delay(_ms)	usleep((_ms)*1000)
+
+typedef enum {
+	GPIO_UNEXPORT = 0,
+	GPIO_EXPORT = 1
+} gpio_ex;
+
+typedef enum {
+	GPIO_IN = 0,
+	GPIO_OUT = 1
+} gpio_direction;
+
+typedef enum {
+	GPIO_LOW = 0,
+	GPIO_HIGH = 1
+} gpio_state;
+
+s32 csb_fd = -1;
+s32 sdi_fd = -1;
+s32 sclb_fd = -1;
+s32 res_fd = -1;
+s32 bl_fd = -1;
+
+#define CSB_GPIO 49
+#define SDI_GPIO 47
+#define SCLB_GPIO 46
+#define RES_GPIO 53
+#define BL_GPIO 113
+
+s32 set_gpio_state(s32 *fd, s32 gpio_id, u32 state);
+
+#define csb_low() set_gpio_state(&csb_fd, CSB_GPIO, GPIO_LOW)
+#define csb_high() set_gpio_state(&csb_fd, CSB_GPIO, GPIO_HIGH)
+
+#define sdi_low() set_gpio_state(&sdi_fd, SDI_GPIO, GPIO_LOW)
+#define sdi_high() set_gpio_state(&sdi_fd, SDI_GPIO, GPIO_HIGH)
+
+#define sclb_low() set_gpio_state(&sclb_fd, SCLB_GPIO, GPIO_LOW)
+#define sclb_high() set_gpio_state(&sclb_fd, SCLB_GPIO, GPIO_HIGH)
+
+#define res_low() set_gpio_state(&res_fd, RES_GPIO, GPIO_LOW)
+#define res_high() set_gpio_state(&res_fd, RES_GPIO, GPIO_HIGH)
+
+#define bl_low() set_gpio_state(&bl_fd, BL_GPIO, GPIO_LOW)
+#define bl_high() set_gpio_state(&bl_fd, BL_GPIO, GPIO_HIGH)
+
+void write_command(unsigned char y)
+{
+	unsigned char i;
+	csb_low();
+	sclb_low();
+	sdi_low();
+	sclb_high();
+	for (i = 0; i < 8; i++) {
+		sclb_low();
+		if (y & 0x80) {
+			sdi_high();
+		}
+		else {
+			sdi_low();
+		}
+		sclb_high();
+		y = y << 1;
+	}
+	csb_high();
+}
+
+void write_data(unsigned char w)
+{
+	unsigned char i;
+	csb_low();
+	sclb_low();
+	sdi_high();
+	sclb_high();
+	for (i = 0; i < 8; i++)
+	{
+		sclb_low();
+		if (w & 0x80) {
+			sdi_high();
+		}
+		else {
+			sdi_low();
+		}
+		sclb_high();
+		w = w << 1;
+	}
+	csb_high();
+}
+
+void initi(void)
+{
+	res_high();
+	delay(1);
+	res_low();
+	delay(10);
+	res_high();
+	delay(120);
+	bl_high();
+	//--------------------------------ST7789S Frame rate setting----------------------------------//
+	write_command(0x36);
+	write_data(0x00);
+	//--------------------------------ST7789S Frame rate setting----------------------------------//
+	write_command(0xb2);
+	write_data(0x05);
+	write_data(0x05);
+	write_data(0x00);
+	write_data(0x33);
+	write_data(0x33);
+
+	write_command(0xb7);
+	write_data(0x35);
+
+	//---------------------------------ST7789S Power setting--------------------------------------//
+
+	write_command(0xbb);
+	write_data(0x3F);           //vcom
+
+	write_command(0xc0);
+	write_data(0x2C);           //17
+
+	write_command(0xc2);
+	write_data(0x01);           //17
+
+	write_command(0xc3);
+	write_data(0x0F);           //17
+
+	write_command(0xc4);
+	write_data(0x20);
+
+	write_command(0xc6);
+	write_data(0x11);
+
+	write_command(0xd0);
+	write_data(0xa4);
+	write_data(0xa1);
+
+	write_command(0xe8);
+	write_data(0x03);
+
+	write_command(0xe9);
+	write_data(0x09);
+	write_data(0x09);
+	write_data(0x08);
+	//--------------------------------ST7789S gamma setting---------------------------------------//
+	write_command(0xe0);
+	write_data(0xd0);
+	write_data(0x05);
+	write_data(0x09);
+	write_data(0x09);
+	write_data(0x08);
+	write_data(0x14);
+	write_data(0x28);
+	write_data(0x33);
+	write_data(0x3F);
+	write_data(0x07);
+	write_data(0x13);
+	write_data(0x14);
+	write_data(0x28);
+	write_data(0x30);
+
+	write_command(0xe1);
+	write_data(0xd0);
+	write_data(0x05);
+	write_data(0x09);
+	write_data(0x09);
+	write_data(0x08);
+	write_data(0x03);
+	write_data(0x24);
+	write_data(0x32);
+	write_data(0x32);
+	write_data(0x3B);
+	write_data(0x38);
+	write_data(0x14);
+	write_data(0x13);
+	write_data(0x28);
+	write_data(0x2F);
+
+	write_command(0x21);        //
+
+	//*********SET RGB Interfae***************
+	write_command(0xB0);
+	write_data(0x11);           //set RGB interface and DE mode.
+	write_data(0x00);
+	write_data(0x00);
+
+	write_command(0xB1);
+	write_data(0xEC);           // set DE mode ; SET Hs,Vs,DE,DOTCLK signal polarity
+	write_data(0x04);
+	write_data(0x14);
+
+	write_command(0x3a);
+	write_data(0x55);           //18 RGB ,55-16BIT RGB
+
+	//************************
+	write_command(0x11);
+	delay(120);                 //Delay 120ms
+
+	write_command(0x29);        //display on
+	write_command(0x2c);
+}
+
+s32 do_gpio_export(s32 gpio_id, gpio_ex ex)
+{
+	s32 ret = -1;
+	s32 fd = -1;
+	char buf[128] = {0};
+	char vbuf[4] = {0};
+
+	sprintf(buf, "/sys/class/gpio/%s", ex == GPIO_EXPORT ? "export" : "unexport");
+	if ((fd = open(buf, O_WRONLY)) < 0) {
+		perror("do_gpio_export open");
+	} else {
+		sprintf(vbuf, "%d", gpio_id);
+		if (strlen(vbuf) != write(fd, vbuf, strlen(vbuf))) {
+			perror("write");
+		} else {
+			ret = 0;
+		}
+		close(fd);
+	}
+
+	return ret;
+}
+
+s32 set_gpio_direction(s32 gpio_id, gpio_direction direction)
+{
+	s32 ret = -1;
+	s32 fd = -1;
+	char buf[128] = {0};
+	char *vbuf = NULL;
+
+	sprintf(buf, "/sys/class/gpio/gpio%d/direction", gpio_id);
+	if ((fd = open(buf, O_WRONLY)) < 0) {
+		perror("set_gpio_direction open");
+	} else {
+		switch(direction) {
+			case GPIO_OUT:
+				vbuf = "out";
+				break;
+			case GPIO_IN:
+				vbuf = "in";
+				break;
+			default:
+				fprintf(stderr, "Invalid direction!\n");
+				break;
+		}
+		if (vbuf) {
+			if (strlen(vbuf) != write(fd, vbuf, strlen(vbuf))) {
+				perror("write");
+			} else {
+				ret = 0;
+			}
+		}
+		close(fd);
+	}
+
+	return ret;
+}
+
+s32 set_gpio_state(s32 *fd, s32 gpio_id, u32 state)
+{
+	char buf[128] = {0};
+	char *vbuf = NULL;
+
+	sprintf(buf, "/sys/class/gpio/gpio%d/value", gpio_id);
+	if (*fd < 0) {
+		if ((*fd = open(buf, O_RDWR)) < 0) {
+			perror("set_gpio_state open");
+			return -1;
+		}
+	}
+	if (state == GPIO_LOW) {
+		vbuf = "0";
+	} else if (state == GPIO_HIGH) {
+		vbuf = "1";
+	} else {
+		fprintf(stderr, "Invalid gpio state: %d\n", state);
+		return -1;
+	}
+	if (vbuf) {
+		if (strlen(vbuf) != write(*fd, vbuf, strlen(vbuf))) {
+			perror("write");
+			return -1;
+		} else {
+			lseek(*fd, 0, SEEK_SET);
+		}
+	}
+
+	return 0;
+}
+
+void gpio_init(void)
+{
+	do_gpio_export(CSB_GPIO, GPIO_EXPORT);
+	do_gpio_export(SDI_GPIO, GPIO_EXPORT);
+	do_gpio_export(SCLB_GPIO, GPIO_EXPORT);
+	do_gpio_export(RES_GPIO, GPIO_EXPORT);
+	do_gpio_export(BL_GPIO, GPIO_EXPORT);
+	set_gpio_direction(CSB_GPIO, GPIO_OUT);
+	set_gpio_direction(SDI_GPIO, GPIO_OUT);
+	set_gpio_direction(SCLB_GPIO, GPIO_OUT);
+	set_gpio_direction(RES_GPIO, GPIO_OUT);
+	set_gpio_direction(BL_GPIO, GPIO_OUT);
+}
+
+void gpio_unexport(void)
+{
+	do_gpio_export(CSB_GPIO, GPIO_UNEXPORT);
+	do_gpio_export(SDI_GPIO, GPIO_UNEXPORT);
+	do_gpio_export(SCLB_GPIO, GPIO_UNEXPORT);
+	do_gpio_export(RES_GPIO, GPIO_UNEXPORT);
+	do_gpio_export(BL_GPIO, GPIO_UNEXPORT);
+}
+
+static int lcd_st7789v_config_240x320(void)
+{
+	gpio_init();
+	delay(100);
+	initi();
+
+	gpio_unexport();
+	if(csb_fd > 0)
+		close(csb_fd);
+	if(sdi_fd > 0)
+		close(sdi_fd);
+	if(sclb_fd > 0)
+		close(sclb_fd);
+	return 0;
+}
+
+
+static int lcd_st7789v_240x320(struct amba_video_sink_mode *pvout_cfg,
+	enum amba_vout_lcd_mode_info lcd_mode)
+{
+	pvout_cfg->mode		= AMBA_VIDEO_MODE_240_320;
+	pvout_cfg->ratio	= AMBA_VIDEO_RATIO_4_3;
+	pvout_cfg->bits		= AMBA_VIDEO_BITS_16;
+	pvout_cfg->type		= AMBA_VIDEO_TYPE_RGB_601;
+	pvout_cfg->format	= AMBA_VIDEO_FORMAT_PROGRESSIVE;
+	pvout_cfg->sink_type	= AMBA_VOUT_SINK_TYPE_DIGITAL;
+
+	pvout_cfg->bg_color.y	= 0x10;
+	pvout_cfg->bg_color.cb	= 0x80;
+	pvout_cfg->bg_color.cr	= 0x80;
+
+	pvout_cfg->lcd_cfg.mode	= lcd_mode;
+	pvout_cfg->lcd_cfg.seqt	= AMBA_VOUT_LCD_SEQ_R0_G1_B2;
+	pvout_cfg->lcd_cfg.seqb	= AMBA_VOUT_LCD_SEQ_R0_G1_B2;
+	pvout_cfg->lcd_cfg.dclk_edge = AMBA_VOUT_LCD_CLK_RISING_EDGE;
+	pvout_cfg->lcd_cfg.dclk_freq_hz	= 7000000;
+	pvout_cfg->lcd_cfg.hvld_pol = AMBA_VOUT_LCD_HVLD_POL_HIGH;
+
+	lcd_st7789v_config_240x320();
+	return 0;
+}
+
+int lcd_st7789v_16_setmode(int mode, struct amba_video_sink_mode *pcfg)
+{
+	int				errCode = 0;
+
+	switch(mode) {
+	case AMBA_VIDEO_MODE_240_320:
+		errCode = lcd_st7789v_240x320(pcfg, AMBA_VOUT_LCD_MODE_RGB565);
+		break;
+
+	default:
+		errCode = -1;
+	}
+
+	return errCode;
+}
+
diff --git a/vout_test/lcd/lcd_td043.c b/vout_test/lcd/lcd_td043.c
index a461932..1a2398e 100644
--- a/vout_test/lcd/lcd_td043.c
+++ b/vout_test/lcd/lcd_td043.c
@@ -4,76 +4,35 @@
  * History:
  *	2010/09/28 - [Zhenwu Xue] created file
  *
- * Copyright (C) 2007-2010, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
 /* ========================================================================== */
 #include <linux/spi/spidev.h>
 
-#define TD043_PWM_PATH(x)		"/sys/class/backlight/pwm-backlight.0/"x
-
-#define TD043_WRITE_REGISTER(addr, val)	\
-	cmd = ((addr) << 8) | (val);	\
-	write(spi_fd, &cmd, 2);
-
-/* ========================================================================== */
-static void lcd_td043_config_wvga()
-{
-	/* Power On */
-	lcd_power_on();
-
-	/* Hardware Reset */
-	//lcd_reset();
-
-#ifdef LCD_BRIGHEST
-	/* Backlight on */
-	lcd_backlight_on();
-#else
-{
-	int		ret;
-	int		pwm_fd1, pwm_fd2;
-	int		lcd_brightness;
-	char		buf[64];
-
-	pwm_fd1 = open(TD043_PWM_PATH("max_brightness"), O_RDONLY);
-	if (pwm_fd1 < 0) {
-		perror("Can't open max_brightness to read");
-		goto lcd_td043_config_wvga_exit;
-	}
-	ret = read(pwm_fd1, buf, sizeof(buf));
-	close(pwm_fd1);
-	if (ret <= 0) {
-		perror("Can't read max_brightness");
-		goto lcd_td043_config_wvga_exit;
-	} else {
-		lcd_brightness = atoi(buf) / 2;
-	}
-
-	pwm_fd2 = open(TD043_PWM_PATH("brightness"), O_WRONLY);
-	if (pwm_fd2 < 0) {
-		perror("Can't open brightness to write");
-		goto lcd_td043_config_wvga_exit;
-	}
-	sprintf(buf, "%d", lcd_brightness);
-	ret = write(pwm_fd2, buf, sizeof(buf));
-	close(pwm_fd2);
-	if (ret <= 0) {
-		perror("Can't write brightness");
-		goto lcd_td043_config_wvga_exit;
-	}
-}
-#endif
-
-lcd_td043_config_wvga_exit:
-	return;
-}
-
 /* ========================================================================== */
 static int lcd_td043_wvga(struct amba_video_sink_mode *pvout_cfg,
 	enum amba_vout_lcd_mode_info lcd_mode)
@@ -96,8 +55,6 @@ static int lcd_td043_wvga(struct amba_video_sink_mode *pvout_cfg,
 	pvout_cfg->lcd_cfg.dclk_freq_hz	= 27000000;
 	pvout_cfg->lcd_cfg.hvld_pol = AMBA_VOUT_LCD_HVLD_POL_HIGH;
 
-	lcd_td043_config_wvga();
-
 	return 0;
 }
 
diff --git a/vout_test/make.inc b/vout_test/make.inc
index ccd479e..7ecb754 100644
--- a/vout_test/make.inc
+++ b/vout_test/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/05 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2011-2015, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_UNIT_TESTS_VOUT), y)
diff --git a/vout_test/test_osd.c b/vout_test/test_osd.c
index 51e7d0e..91e74f1 100644
--- a/vout_test/test_osd.c
+++ b/vout_test/test_osd.c
@@ -1,3 +1,35 @@
+/*
+ * test_osd.c
+ *
+ * History:
+ *	2009/11/20 - [Zhenwu Xue] Initial Revision
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
     #include <unistd.h>
     #include <stdio.h>
     #include <fcntl.h>
diff --git a/vout_test/test_vout.c b/vout_test/test_vout.c
index aec5834..ebeb4da 100644
--- a/vout_test/test_vout.c
+++ b/vout_test/test_vout.c
@@ -4,12 +4,29 @@
  * History:
  *	2009/11/20 - [Zhenwu Xue] Initial Revision
  *
- * Copyright (C) 2007-2009, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 #include <unistd.h>
diff --git a/vout_test/vout_init.c b/vout_test/vout_init.c
index 3003899..e9e4703 100644
--- a/vout_test/vout_init.c
+++ b/vout_test/vout_init.c
@@ -4,12 +4,29 @@
  * History:
  *	2009/7/15 - [Zhenwu Xue] created file
  *
- * Copyright (C) 2007-2008, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
@@ -21,6 +38,8 @@
 #include "lcd/lcd_digital.c"
 #include "lcd/lcd_digital601.c"
 #include "lcd/lcd_td043.c"
+#include "lcd/lcd_st7789v.c"
+#include "lcd/lcd_ili8961.c"
 
 typedef struct lcd_model {
 	const char			*model;
@@ -33,6 +52,8 @@ lcd_model_t lcd_model_list[] = {
 	{"digital601",	lcd_digital601_setmode,	NULL				},
 	{"td043",	lcd_td043_setmode,	NULL				},
 	{"td043_16",	lcd_td043_16_setmode,	NULL				},
+	{"st7789v",	lcd_st7789v_16_setmode,	NULL				},
+	{"ili8961",	lcd_ili8961_setmode,	NULL				},
 };
 
 int get_lcd_model_index(const char *lcd_model)
@@ -104,6 +125,9 @@ vout_res_t vout_res[] = {
 	{"1080p30",	AMBA_VIDEO_MODE_1080P30,		1920, 1080},
 	{"1080p",	AMBA_VIDEO_MODE_1080P,			1920, 1080},
 	{"1080p50",	AMBA_VIDEO_MODE_1080P50,		1920, 1080},
+	{"4mp30",	AMBA_VIDEO_MODE_2560X1440P30,		2560, 1440},
+	{"4mp25",	AMBA_VIDEO_MODE_2560X1440P25,		2560, 1440},
+	{"4mp60",	AMBA_VIDEO_MODE_2560X1440P60,		2560, 1440},
 	{"native",	AMBA_VIDEO_MODE_HDMI_NATIVE,		0,    0},
 	{"2160p30",	AMBA_VIDEO_MODE_2160P30,		3840, 2160},
 	{"2160p25",	AMBA_VIDEO_MODE_2160P25,		3840, 2160},
@@ -134,10 +158,13 @@ vout_res_t vout_res[] = {
 	{"hvga",	AMBA_VIDEO_MODE_HVGA,			320,  480},	//TPO489
 	{"vga",		AMBA_VIDEO_MODE_VGA,			640,  480},
 	{"wvga",	AMBA_VIDEO_MODE_WVGA,			800,  480},	//TD043
+	{"D240x320",	AMBA_VIDEO_MODE_240_320,                240,  320},	//ST7789V
 	{"D240x400",	AMBA_VIDEO_MODE_240_400,		240,  400},	//WDF2440
 	{"xga",		AMBA_VIDEO_MODE_XGA,		       1024,  768},	//EJ080NA
 	{"wsvga",	AMBA_VIDEO_MODE_WSVGA,	       1024,  600},	//AT070TNA2
 	{"D960x540",	AMBA_VIDEO_MODE_960_540,		960,  540},	//E330QHD
+	//{"D960x576",	AMBA_VIDEO_MODE_960_576,		960,    576},
+	//{"D960x480",	AMBA_VIDEO_MODE_960_480,		960,    480},
 };
 
 int get_vout_mode(const char *name)
@@ -567,7 +594,7 @@ int vout_get_sink_id(int chan, int sink_type)
 #define CSC_HINTS	\
 	{"", "\tDisable vout csc"},	\
 	{"", "\t\tEnable or Disable color space conversion of the corresponding vout"}, \
-	{"disable|video|osd", "\tselect mixer csc"},
+	{"disable|video|osd", "Select mixer csc"},
 
 #define HDMI_3D_STRUCTURE_OPTIONS	\
 	{"3d",                    HAS_ARG,  0,   SPECIFY_HDMI_3D_STRUCTURE,               },
@@ -1260,11 +1287,11 @@ int dynamically_change_vout(void)
 		}
 
 		if (vout_flag[VOUT_0]) {
-			init_vout(VOUT_0, 1);
+			init_vout(VOUT_0, 0);
 		}
 
 		if (vout_flag[VOUT_1]) {
-			init_vout(VOUT_1, 1);
+			init_vout(VOUT_1, 0);
 		}
 
 		return 1;
diff --git a/vsync_test/make.inc b/vsync_test/make.inc
index 4597712..f3efd9a 100644
--- a/vsync_test/make.inc
+++ b/vsync_test/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/05 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2011-2015, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_UNIT_TESTS_VSYNC), y)
diff --git a/vsync_test/test_soft_vsync.c b/vsync_test/test_soft_vsync.c
index b969e86..c9d9076 100644
--- a/vsync_test/test_soft_vsync.c
+++ b/vsync_test/test_soft_vsync.c
@@ -1,17 +1,34 @@
-/*******************************************************************************
+/*
  * test_soft_vsync.c
  *
  * History:
  *   2014/09/05 - [lysun] created file
  *
- * Copyright (C) 2008-2014, Ambarella Co,Ltd.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- ******************************************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 
 #include <sys/time.h>
diff --git a/vsync_test/test_vsync_old.c b/vsync_test/test_vsync_old.c
index 5c9e568..c80fd75 100644
--- a/vsync_test/test_vsync_old.c
+++ b/vsync_test/test_vsync_old.c
@@ -4,12 +4,29 @@
  * History:
  *	2010/01/08 - [Qiao Wang] create
  *
- * Copyright (C) 2007-2010, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 #include <unistd.h>
diff --git a/idsp_test/arch_s2l/AmbaDSP_ImgCalibItunerImpl.c b/idsp_test/arch_s2l/AmbaDSP_ImgCalibItunerImpl.c
new file mode 100644
index 0000000..e86fec6
--- /dev/null
+++ b/idsp_test/arch_s2l/AmbaDSP_ImgCalibItunerImpl.c
@@ -0,0 +1,4877 @@
+/*
+ *
+ * idsp_test
+ *
+ * History:
+ *	2013/09/05 - [Dylan] Created this file
+ *
+ * Description :
+ *	Load the tuned file which generated by Img tuning tool.
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+//#include "AmbaPrintk.h"
+//#include "AmbaFS.h"
+//#include "AmbaKAL.h"
+
+//#include "AmbaDSP_ImgHighLevelApi.h"
+#include <string.h>
+#include <stdio.h>
+#include "AmbaDataType.h"
+#include "AmbaDSP_ImgUtility.h"
+
+#include "AmbaImgCalibItuner.h"
+//#include "AmbaDSP_ImgHighIsoFilter.h"
+
+
+//#pragma location=".NonCacheDDR"
+//#pragma data_alignment = 32
+UINT8 FPNMap[4000*3000];
+
+//#pragma location=".NonCacheDDR"
+//#pragma data_alignment = 32
+UINT8 VignetteTable[ITUNER_VIGNETTE_GAIN_MAP_SIZE * 4];
+
+//#pragma location=".NonCacheDDR"
+//#pragma data_alignment = 32
+UINT8 WarpGrid[4*96*64];
+
+//#pragma location=".NonCacheDDR"
+//#pragma data_alignment = 32
+UINT8 ca_grid[4*96*64];
+
+//#pragma location=".NonCacheDDR"
+//#pragma data_alignment = 32
+UINT8 CcReg[AMBA_DSP_IMG_CC_REG_SIZE];
+
+//#pragma location=".NonCacheDDR"
+//#pragma data_alignment = 32
+UINT8 Cc3d[AMBA_DSP_IMG_CC_3D_SIZE];
+
+//#pragma location=".NonCacheDDR"
+//#pragma data_alignment = 32
+UINT8 SecCc[AMBA_DSP_IMG_SEC_CC_SIZE];
+
+#define AmbaPrint(format, arg...)	printf(format"\n", ##arg)
+
+#if 1
+#define ITUNER_DEBF(fmt, arg...) AmbaPrint("[ITUNER][DEBUG]"fmt, ##arg)
+#define ITUNER_WARF(fmt, arg...) AmbaPrint("[ITUNER][WARNING]"fmt, ##arg)
+#define ITUNER_ERRF(fmt, arg...) AmbaPrint("[ITUNER][ERROR]"fmt, ##arg)
+#else
+#define ITUNER_DEBF(fmt, arg...)
+#define ITUNER_WARF(fmt, arg...)
+#define ITUNER_ERRF(fmt, arg...)
+
+#endif
+
+#define WB_DGAIN_UNIT           4096
+
+#define WARP_VIDEO_MAXHORGRID    (32)
+#define WARP_VIDEO_MAXVERGRID    (48)
+
+#define WARP_STILL_MAXVERGRID    (48)
+
+#define CAWARP_VIDEO_MAXHORGRID    (32)
+#define CAWARP_VIDEO_MAXVERGRID    (48)
+#define CAWARP_STILL_MAXHORGRID    (64)
+#define CAWARP_STILL_MAXVERGRID    (48)
+
+#define SFT 16
+#define TO_STR(x) #x
+// Note: Use to check return value
+#define CHECK_RET(RET, FUNC) if (RET != FUNC) {\
+                                    ITUNER_WARF("%s() Line:%d, call "#FUNC" Fail", __func__, __LINE__); \
+                                    Ret |= -1;\
+                                    /*break;*/\
+                                 }
+
+
+
+
+/*
+typedef struct ituner_night_portrait_s {
+    UINT8 flash_on_2nd_pic;
+    UINT8 radius;
+    UINT8 luma_path_1[256];
+    UINT8 chroma_path_1[256];
+    UINT8 luma_path_2[256];
+    UINT8 chroma_path_2[256];
+    UINT16 table[256];
+} ituner_night_portrait_t;
+
+#define MAX_HDR_IMG_COUNT (10)
+typedef struct hdr_raw_info_s {
+    UINT8  raw_path[256];
+} hdr_raw_info_t;
+
+typedef struct hdr_control_info_s {
+    int normal_frame_idx;
+    int mctf_strength;
+} hdr_control_info_t;
+*/
+
+//=====AAA algorithm==============//
+#define IMG_EXP_VIDEO                   (0x00)
+#define IMG_EXP_VIDEO_DIRECT_SET        (0x01)
+
+
+//=============================//
+#define SPECIAL_USE_NONE 0
+#define SPECIAL_USE_SKIP 1
+
+typedef struct _ITUNER_DATA_s_ {
+    AAA_FUNC_s                          AaaFunction; //
+    IMG_EXP_s                           AeInfo; //
+    amba_img_dsp_ae_stat_info_t         AeStatisticsInfo; //
+    amba_img_dsp_awb_stat_info_t        AwbStatisticsInfo;//
+    amba_img_dsp_af_stat_info_t         AfStatisticsInfo; //
+    amba_dsp_img_af_stat_ex_info_t      AfStatisticsEx;
+
+    ITUNER_FPN_s                        StaticBadPixelCorrection;//
+    ITUNER_FPN_BYPASS_s                 StaticBadPixelCorrectionByPass;//
+    ITUNER_VIGNETTE_s                   VignetteCompensation;//
+    ITUNER_VIGNETTE_BYPASS_s            VignetteCompensationByPass;//
+    ITUNER_WARP_s                       WarpCompensation;//
+    ITUNER_DZOOM_s                      Dzoom;//
+    ITUNER_WARP_DZOOM_BYPASS_s          WarpCompensationDzoomByPass;//
+    ITUNER_SENSOR_INPUT_s               SensorInputInfo;//
+    ITUNER_CHROMA_ABERRATION_s          ChromaAberrationInfo;//
+    ITUNER_CHROMA_ABERRATION_BYPASS_s   ChromaAberrationInfoByPass;//
+    ///////
+
+    amba_img_dsp_sbp_correction_t       SbpCorr;
+    AMBA_DSP_IMG_BYPASS_SBP_INFO_s      SbpCorrByPass;
+
+    amba_img_dsp_vignette_calc_info_t   VignetteCalcInfo;
+    AMBA_DSP_IMG_BYPASS_VIGNETTE_INFO_s VignetteByPass;
+
+    amba_img_dsp_sensor_info_t          SensorInfo;
+    amba_img_dsp_warp_calc_info_t       WarpCalcInfo;
+    AMBA_DSP_IMG_BYPASS_WARP_DZOOM_INFO_s WarpByPass;
+
+    AMBA_DSP_IMG_CAWARP_CALC_INFO_s     CACalcInfo;
+    AMBA_DSP_IMG_BYPASS_CAWARP_INFO_s   CAByPass;
+
+    amba_img_dsp_black_correction_t     StaticBlackLevel;//
+    amba_img_dsp_def_blc_t              DeferredBlackLevel;
+    amba_img_dsp_dbp_correction_t       DynamicBadPixelCorrection;//
+    amba_img_dsp_cfa_leakage_filter_t   CfaLeakageFilter;//
+    amba_img_dsp_cfa_noise_filter_t     CfaNoiseFilter;//
+    amba_img_dsp_anti_aliasing_t        AntiAliasing;//
+    UINT32                              GlobalDgain;//
+    amba_img_dsp_wb_gain_t              WbGain;//
+    amba_img_dsp_dgain_saturation_t     DgainSaturationLevel;//
+    amba_img_dsp_local_exposure_t       LocalExposure;//
+    amba_img_dsp_color_correction_reg_t CcReg;
+    amba_img_dsp_color_correction_t     CcThreeD;
+    ITUNER_COLOR_CORRECTION_s           ColorCorrection;//
+    amba_img_dsp_tone_curve_t           ToneCurve;//
+    amba_img_dsp_rgb_to_yuv_t           RgbToYuvMatrix;//
+    amba_img_dsp_chroma_scale_t         ChromaScale;//
+    amba_img_dsp_chroma_median_filter_t ChromaMedianFilter;//
+
+    amba_img_dsp_demosaic_t             DemosaicFilter;//
+    //li_sharpen_noise_filter
+    amba_img_dsp_sharpen_both_t  SharpenBoth;//
+    amba_img_dsp_sharpen_noise_t SharpenNoise;//
+    amba_img_dsp_fir_t          Fir;//
+    amba_img_dsp_coring_t       Coring;//
+    amba_img_dsp_level_t        MinCoringResult;//8//minimum_sharpeness_level
+    amba_img_dsp_level_t        CoringIndexScale;//10//overall_sharpeness_level
+    amba_img_dsp_level_t        ScaleCoring;//7
+    //final_sharp_noise_filter
+    amba_img_dsp_sharpen_both_t  FinalSharpenBoth;//
+    amba_img_dsp_sharpen_noise_t FinalSharpenNoise;
+    amba_img_dsp_fir_t          FinalFir;
+    amba_img_dsp_coring_t       FinalCoring;
+    amba_img_dsp_level_t        FinalMinCoringResult;//8//minimum_sharpeness_level
+    amba_img_dsp_level_t        FinalCoringIndexScale;//10//overall_sharpeness_level
+    amba_img_dsp_level_t        FinalScaleCoring;//7
+
+    amba_img_dsp_video_mctf_info_t      VideoMctf;//
+    amba_img_dsp_video_mctf_temporal_adjust_t  VideoMctfTemporalAdjust;//
+    amba_img_dsp_cdnr_info_t            CDNR;//
+    amba_img_dsp_liso_process_select_t      LisoProcessSelect;
+//    UINT8                               ShpAOrSpatialFilterSelect;//
+    UINT16                              SharpBLinearizationStrength;//
+    //idsp_cc_desat_t             cc_desatutation;//TBD
+    amba_img_dsp_asf_info_t             AsfInfo;
+
+    amba_img_dsp_chroma_filter_t        ChromaFilter;//
+    amba_img_dsp_gbgr_mismatch_t        GbGrMismatch;//
+
+    //li_wide_chroma
+    amba_img_dsp_chroma_filter_t        WideChromaFilter;//
+    AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s  WideChromaFilterCombine;//
+
+    //High iso
+    amba_img_dsp_anti_aliasing_t          HisoAntiAliasing;
+    amba_img_dsp_cfa_leakage_filter_t     HisoCfaLeakageFilter;
+    amba_img_dsp_dbp_correction_t         HisoDynamicBadPixelCorrection;
+    amba_img_dsp_cfa_noise_filter_t       HisoCfaNoiseFilter;//
+    amba_img_dsp_gbgr_mismatch_t          HisoGbGrMismatch;
+    amba_img_dsp_demosaic_t               HisoDemosaicFilter;//
+    amba_img_dsp_chroma_median_filter_t   HisoChromaMedianFilter;//
+    amba_img_dsp_cdnr_info_t              HisoCDNR;
+    AMBA_DSP_IMG_DEFER_COLOR_CORRECTION_s HisoDeferColorCorrection;//
+
+    amba_img_dsp_asf_info_t    HisoAsf;
+    amba_img_dsp_asf_info_t    HisoHighAsf;
+    amba_img_dsp_asf_info_t    HisoLowAsf;
+    amba_img_dsp_asf_info_t    HisoMedAsf;
+    amba_img_dsp_asf_info_t    HisoLi2ndAsf;
+    AMBA_DSP_IMG_CHROMA_ASF_INFO_s    HisoChromaAsf;
+
+    //HisoHighSharpen
+    amba_img_dsp_sharpen_both_t  HisoHighSharpenBoth;
+    amba_img_dsp_sharpen_noise_t HisoHighSharpenNoise;
+    amba_img_dsp_fir_t           HisoHighFir;
+    amba_img_dsp_coring_t        HisoHighCoring;
+    amba_img_dsp_level_t         HisoHighMinCoringResult;//8//minimum_sharpeness_level
+    amba_img_dsp_level_t         HisoHighCoringIndexScale;//10//overall_sharpeness_level
+    amba_img_dsp_level_t         HisoHighScaleCoring;//7
+    //HisoMedSharpen
+    amba_img_dsp_sharpen_both_t  HisoMedSharpenBoth;
+    amba_img_dsp_sharpen_noise_t HisoMedSharpenNoise;
+    amba_img_dsp_fir_t           HisoMedFir;
+    amba_img_dsp_coring_t        HisoMedCoring;
+    amba_img_dsp_level_t         HisoMedMinCoringResult;//8//minimum_sharpeness_level
+    amba_img_dsp_level_t         HisoMedCoringIndexScale;//10//overall_sharpeness_level
+    amba_img_dsp_level_t         HisoMedScaleCoring;//7
+    //HisoLiso1Sharpen
+    amba_img_dsp_sharpen_both_t  HisoLiso1SharpenBoth;
+    amba_img_dsp_sharpen_noise_t HisoLiso1SharpenNoise;
+    amba_img_dsp_fir_t           HisoLiso1Fir;
+    amba_img_dsp_coring_t        HisoLiso1Coring;
+    amba_img_dsp_level_t         HisoLiso1MinCoringResult;//8//minimum_sharpeness_level
+    amba_img_dsp_level_t         HisoLiso1CoringIndexScale;//10//overall_sharpeness_level
+    amba_img_dsp_level_t         HisoLiso1ScaleCoring;//7
+    //HisoMedSharpen
+    amba_img_dsp_sharpen_both_t  HisoLiso2SharpenBoth;//
+    amba_img_dsp_sharpen_noise_t HisoLiso2SharpenNoise;
+    amba_img_dsp_fir_t           HisoLiso2Fir;
+    amba_img_dsp_coring_t        HisoLiso2Coring;
+    amba_img_dsp_level_t         HisoLiso2MinCoringResult;//8//minimum_sharpeness_level
+    amba_img_dsp_level_t         HisoLiso2CoringIndexScale;//10//overall_sharpeness_level
+    amba_img_dsp_level_t         HisoLiso2ScaleCoring;//7
+    //Chroma
+    amba_img_dsp_chroma_filter_t        HisoChromaFilterHigh;
+    AMBA_DSP_IMG_HISO_CHROMA_LOW_VERY_LOW_FILTER_s        HisoChromaFilterLowVeryLow;//
+    AMBA_DSP_IMG_HISO_CHROMA_FILTER_s   HisoChromaFilterPre;//
+    AMBA_DSP_IMG_HISO_CHROMA_FILTER_s   HisoChromaFilterMed;
+    AMBA_DSP_IMG_HISO_CHROMA_FILTER_s   HisoChromaFilterLow;
+    AMBA_DSP_IMG_HISO_CHROMA_FILTER_s   HisoChromaFilterVeryLow;
+    //Combine
+    AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s HisoChromaFilterMedCombine;
+    AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s HisoChromaFilterLowCombine;
+    AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s HisoChromaFilterVeryLowCombine;
+    AMBA_DSP_IMG_HISO_LUMA_FILTER_COMBINE_s HisoLumaNoiseCombine;
+    AMBA_DSP_IMG_HISO_LUMA_FILTER_COMBINE_s HisoLowASFCombine;
+    AMBA_DSP_IMG_HISO_COMBINE_s               HighIsoCombine;
+    AMBA_DSP_IMG_HISO_FREQ_RECOVER_s          HisoFreqRecover;
+    AMBA_DSP_IMG_HISO_LUMA_BLEND_s            HisoLow2LumaBlend;
+    AMBA_DSP_IMG_HISO_BLEND_s                 HisoLow2BlendLumaLevel;
+
+	//MO PASS-3 filter
+	amba_img_dsp_dbp_correction_t       MoDynamicBadPixelCorrection;
+    amba_img_dsp_cfa_leakage_filter_t   MoCfaLeakageFilter;
+    amba_img_dsp_cfa_noise_filter_t     MoCfaNoiseFilter;
+    amba_img_dsp_anti_aliasing_t        MoAntiAliasing;
+    amba_img_dsp_chroma_median_filter_t MoChromaMedianFilter;
+    amba_img_dsp_demosaic_t             MoDemosaicFilter;
+    amba_img_dsp_sharpen_both_t         MoSharpenBoth;
+    amba_img_dsp_sharpen_noise_t        MoSharpenNoise;
+    amba_img_dsp_fir_t                  MoFir;
+    amba_img_dsp_coring_t               MoCoring;
+    amba_img_dsp_level_t                MoMinCoringResult;
+    amba_img_dsp_level_t                MoCoringIndexScale;
+    amba_img_dsp_level_t                MoScaleCoring;
+    amba_img_dsp_mo_process_select_t    MoProcessSelect;
+	amba_img_dsp_asf_info_t             MoAsfInfo;
+	amba_img_dsp_chroma_filter_t        MoChromaFilter;
+    amba_img_dsp_gbgr_mismatch_t        MoGbGrMismatch;
+} ITUNER_DATA_s;
+#if 0
+typedef struct {
+      UINT8 SharpenBothThreeDTable[8192];
+      UINT8 FinalSharpenBothThreeDTable[8192];
+      UINT8 AsfInfoThreeDTable[8192];
+      UINT8 HisoAsfThreeDTable[8192];
+      UINT8 HisoHighAsfThreeDTable[8192];
+      UINT8 HisoLowAsfThreeDTable[8192];
+      UINT8 HisoMedAsfThreeDTable[8192];
+      UINT8 HisoLi2ndAsfThreeDTable[8192];
+      UINT8 HisoChromaAsfThreeDTable[8192];
+      UINT8 HisoHighSharpenBothThreeDTable[8192];
+      UINT8 HisoMedSharpenBothThreeDTable[8192];
+      UINT8 HisoLiso1SharpenBothThreeDTable[8192];
+      UINT8 HisoLiso2SharpenBothThreeDTable[8192];
+      UINT8 HisoChromaFilterMedCombineThreeDTable[8192];
+      UINT8 HisoChromaFilterLowCombineThreeDTable[8192];
+      UINT8 HisoChromaFilterVeryLowCombineThreeDTable[8192];
+      UINT8 HisoLumaNoiseCombineThreeDTable[8192];
+      UINT8 HisoLowASFCombineThreeDTable[8192];
+      UINT8 HighIsoCombineThreeDTable[8192];
+} ITUNER_TABLE_s;
+static ITUNER_TABLE_s GTable;
+#endif
+static AMBA_ITUNER_VALID_FILTER_t _Ituner_Valid_Filter;
+ITUNER_DATA_s GData;
+static AmbaItuner_Hook_Func_t Ituner_Hook_Func;
+static ITUNER_SYSTEM_s _System;
+static Ituner_Internal_s _Internal;
+static int _AmbaItuner_Check_Reg(ITUNER_VALID_s FILTER_ID, int Special_Use);
+static inline void _AmbaItuner_Set_Filter_Valid(ITUNER_VALID_s Filter_Id) {
+    _Ituner_Valid_Filter[Filter_Id] = 1;
+}
+//HENRY TBD
+extern int amba_img_dsp_get_1st_sharpen_noise_sharpen_coring(amba_img_dsp_mode_cfg_t             *pMode, amba_img_dsp_coring_t               *pCoring);
+extern int AmbaDSP_ImgGetHighisoLi2ndAdvanceSpatialFilter(amba_img_dsp_mode_cfg_t *pMode, amba_img_dsp_asf_info_t *pAsf);
+static const char *const _G_Filter_Name[] = {
+    TO_STR(ITUNER_SYSTEM_INFO),
+    TO_STR(ITUNER_INTERNAL_INFO),
+    TO_STR(ITUNER_AAA_FUNCTION),
+    TO_STR(ITUNER_AE_INFO),
+    TO_STR(ITUNER_AE_STATISTICS_INFO),
+    TO_STR(ITUNER_AWB_STATISTICS_INFO),
+    TO_STR(ITUNER_AF_STATISTICS_INFO),
+    TO_STR(ITUNER_STATIC_BAD_PIXEL_CORRECTION),
+    TO_STR(ITUNER_STATIC_BAD_PIXEL_CORRECTION_BY_PASS),
+    TO_STR(ITUNER_VIGNETTE_COMPENSATION),
+    TO_STR(ITUNER_VIGNETTE_COMPENSATION_BY_PASS),
+    TO_STR(ITUNER_WARP_COMPENSATION),
+    TO_STR(ITUNER_DZOOM),
+    TO_STR(ITUNER_WARP_COMPENSATION_DZOOM_BY_PASS),
+    TO_STR(ITUNER_SENSOR_INPUT_INFO),
+    TO_STR(ITUNER_STATIC_BLACK_LEVEL),
+    TO_STR(ITUNER_DEFERRED_BLACK_LEVEL),
+    TO_STR(ITUNER_DYNAMIC_BAD_PIXEL_CORRECTION),
+    TO_STR(ITUNER_HISO_DYNAMIC_BAD_PIXEL_CORRECTION),
+    TO_STR(ITUNER_CFA_LEAKAGE_FILTER),
+    TO_STR(ITUNER_HISO_CFA_LEAKAGE_FILTER),
+    TO_STR(ITUNER_CFA_NOISE_FILTER),
+    TO_STR(ITUNER_HISO_CFA_NOISE_FILTER),
+    TO_STR(ITUNER_ANTI_ALIASING_STRENGTH),
+    TO_STR(ITUNER_HISO_ANTI_ALIASING_STRENGTH),
+    TO_STR(ITUNER_GLOBAL_DGAIN),
+    TO_STR(ITUNER_WB_GAIN),
+    TO_STR(ITUNER_DGAIN_SATURATION_LEVEL),
+    TO_STR(ITUNER_LOCAL_EXPOSURE),
+    TO_STR(ITUNER_COLOR_CORRECTION),
+    TO_STR(ITUNER_TONE_CURVE),
+    TO_STR(ITUNER_RGB_TO_YUV_MATRIX),
+    TO_STR(ITUNER_CHROMA_SCALE),
+    TO_STR(ITUNER_CHROMA_MEDIAN_FILTER),
+    TO_STR(ITUNER_HISO_CHROMA_MEDIAN_FILTER),
+    TO_STR(ITUNER_DEMOSAIC_FILTER),
+    TO_STR(ITUNER_SHARPEN_BOTH),
+    TO_STR(ITUNER_SHARPEN_NOISE),
+    TO_STR(ITUNER_FIR),
+    TO_STR(ITUNER_CORING),
+    TO_STR(ITUNER_CORING_INDEX_SCALE),
+    TO_STR(ITUNER_MIN_CORING_RESULT),
+    TO_STR(ITUNER_SCALE_CORING),
+    TO_STR(ITUNER_FINAL_SHARPEN_BOTH),
+    TO_STR(ITUNER_FINAL_SHARPEN_NOISE),
+    TO_STR(ITUNER_FINAL_FIR),
+    TO_STR(ITUNER_FINAL_CORING),
+    TO_STR(ITUNER_FINAL_CORING_INDEX_SCALE),
+    TO_STR(ITUNER_FINAL_MIN_CORING_RESULT),
+    TO_STR(ITUNER_FINAL_SCALE_CORING),
+    TO_STR(ITUNER_HISO_DEMOSAIC_FILTER),
+    TO_STR(ITUNER_HISO_HIGH_SHARPEN_BOTH),
+    TO_STR(ITUNER_HISO_MED_SHARPEN_BOTH),
+    TO_STR(ITUNER_HISO_HIGH_SHARPEN_NOISE),
+    TO_STR(ITUNER_HISO_MED_SHARPEN_NOISE),
+    TO_STR(ITUNER_HISO_HIGH_FIR),
+    TO_STR(ITUNER_HISO_MED_FIR),
+    TO_STR(ITUNER_HISO_HIGH_CORING),
+    TO_STR(ITUNER_HISO_MED_CORING),
+    TO_STR(ITUNER_HISO_HIGH_CORING_INDEX_SCALE),
+    TO_STR(ITUNER_HISO_HIGH_MIN_CORING_RESULT),
+    TO_STR(ITUNER_HISO_HIGH_SCALE_CORING),
+    TO_STR(ITUNER_HISO_MED_CORING_INDEX_SCALE),
+    TO_STR(ITUNER_HISO_MED_MIN_CORING_RESULT),
+    TO_STR(ITUNER_HISO_MED_SCALE_CORING),
+    TO_STR(ITUNER_VIDEO_MCTF),
+    TO_STR(ITUNER_VIDEO_MCTF_TEMPORAL_ADJUST),
+    TO_STR(ITUNER_CDNR),
+    TO_STR(ITUNER_HISO_DEFER_COLOR_CORRECTION),
+    TO_STR(ITUNER_SHP_A_OR_SPATIAL_FILTE_SELECT),
+    TO_STR(ITUNER_ASF_INFO),
+    TO_STR(ITUNER_HISO_ASF),
+    TO_STR(ITUNER_HISO_HIGH_ASF),
+    TO_STR(ITUNER_HISO_LOW_ASF),
+    TO_STR(ITUNER_HISO_MED_ASF),
+    TO_STR(ITUNER_HISO_CHROMA_ASF),
+    TO_STR(ITUNER_CHROMA_FILTER),
+    TO_STR(ITUNER_WIDE_CHROMA_FILTER),
+    TO_STR(ITUNER_WIDE_CHROMA_FILTER_COMBINE),
+    TO_STR(ITUNER_HISO_CHROMA_FILTER_HIGH),
+    TO_STR(ITUNER_GB_GR_MISMATCH),
+    TO_STR(ITUNER_HISO_GB_GR_MISMATCH),
+    TO_STR(ITUNER_CHROMA_ABERRATION_INFO),
+    TO_STR(ITUNER_CHROMA_ABERRATION_INFO_BY_PASS),
+    TO_STR(ITUNER_HISO_CHROMA_FILTER_LOW_VERY_LOW),
+    TO_STR(ITUNER_HISO_CHROMA_FILTER_PRE),
+    TO_STR(ITUNER_HISO_CHROMA_FILTER_MED),
+    TO_STR(ITUNER_HISO_CHROMA_FILTER_LOW),
+    TO_STR(ITUNER_HISO_CHROMA_FILTER_VERY_LOW),
+    TO_STR(ITUNER_HISO_CHROMA_FILTER_VERY_LOW_COMBINE),
+    TO_STR(ITUNER_HISO_CHROMA_FILTER_MED_COMBINE),
+    TO_STR(ITUNER_HISO_CHROMA_FILTER_LOW_COMBINE),
+    TO_STR(ITUNER_HISO_LUMA_NOISE_COMBINE),
+    TO_STR(ITUNER_HISO_LOW_ASF_COMBINE),
+    TO_STR(ITUNER_HISO_FREQ_RECOVER),
+    TO_STR(ITUNER_SENSOR_INFO),
+    TO_STR(ITUNER_MO_DYNAMIC_BAD_PIXEL_CORRECTION),
+    TO_STR(ITUNER_MO_CFA_LEAKAGE_FILTER),
+    TO_STR(ITUNER_MO_CFA_NOISE_FILTER),
+    TO_STR(ITUNER_MO_ANTI_ALIASING_STRENGTH),
+    TO_STR(ITUNER_MO_DEMOSAIC_FILTER),
+    TO_STR(ITUNER_MO_GB_GR_MISMATCH),
+    TO_STR(ITUNER_MO_SHP_A_OR_SPATIAL_FILTE_SELECT),
+    TO_STR(ITUNER_MO_ASF_INFO),
+    TO_STR(ITUNER_MO_CHROMA_FILTER),
+    TO_STR(ITUNER_MO_CHROMA_MEDIAN_FILTER),
+    TO_STR(ITUNER_MO_SHARPEN_BOTH),
+    TO_STR(ITUNER_MO_SHARPEN_NOISE),
+    TO_STR(ITUNER_MO_FIR),
+    TO_STR(ITUNER_MO_CORING),
+    TO_STR(ITUNER_MO_CORING_INDEX_SCALE),
+    TO_STR(ITUNER_MO_MIN_CORING_RESULT),
+    TO_STR(ITUNER_MO_SCALE_CORING),
+};
+static int _AmbaItuner_Is_Video_Preview_Tuning(void)
+{
+    return (0 == strcmp(_System.TuningMode, TUING_MODE_TO_STR(IMG_MODE_PREVIEW))) ? 1 : 0;
+}
+static int _AmbaItuner_Check_Filter(amba_img_dsp_mode_cfg_t Mode)
+{
+    const UINT8 Liso_Still_Filter[] = {
+        ITUNER_COLOR_CORRECTION,
+        ITUNER_STATIC_BLACK_LEVEL,
+        ITUNER_DEFERRED_BLACK_LEVEL,
+        ITUNER_DYNAMIC_BAD_PIXEL_CORRECTION,
+        ITUNER_CFA_LEAKAGE_FILTER,
+        ITUNER_CFA_NOISE_FILTER,
+        ITUNER_ANTI_ALIASING_STRENGTH,
+        ITUNER_WB_GAIN,
+        ITUNER_DGAIN_SATURATION_LEVEL,
+        ITUNER_LOCAL_EXPOSURE,
+        ITUNER_TONE_CURVE,
+        ITUNER_RGB_TO_YUV_MATRIX,
+        ITUNER_CHROMA_SCALE,
+        ITUNER_CHROMA_MEDIAN_FILTER,
+        ITUNER_DEMOSAIC_FILTER,
+        ITUNER_GB_GR_MISMATCH,
+        ITUNER_SHP_A_OR_SPATIAL_FILTE_SELECT,
+//        ITUNER_CDNR,
+        ITUNER_CHROMA_FILTER,
+        ITUNER_DZOOM,
+    };
+    const UINT8 Hiso_Still_Filter[] = {
+        ITUNER_COLOR_CORRECTION,
+        ITUNER_STATIC_BLACK_LEVEL,
+        ITUNER_DEFERRED_BLACK_LEVEL,
+        ITUNER_DYNAMIC_BAD_PIXEL_CORRECTION,
+        ITUNER_CFA_LEAKAGE_FILTER,
+        ITUNER_CFA_NOISE_FILTER,
+        ITUNER_ANTI_ALIASING_STRENGTH,
+        ITUNER_WB_GAIN,
+        ITUNER_DGAIN_SATURATION_LEVEL,
+        ITUNER_LOCAL_EXPOSURE,
+        ITUNER_TONE_CURVE,
+        ITUNER_RGB_TO_YUV_MATRIX,
+        ITUNER_CHROMA_SCALE,
+        //ITUNER_CHROMA_MEDIAN_FILTER,
+        ITUNER_DEMOSAIC_FILTER,
+        ITUNER_GB_GR_MISMATCH,
+        //ITUNER_SHP_A_OR_SPATIAL_FILTE_SELECT,
+        //ITUNER_CDNR,
+        //ITUNER_CHROMA_FILTER,
+        ITUNER_HISO_ANTI_ALIASING_STRENGTH,
+        ITUNER_HISO_CFA_LEAKAGE_FILTER,
+        ITUNER_HISO_DYNAMIC_BAD_PIXEL_CORRECTION,
+        ITUNER_HISO_CFA_NOISE_FILTER,
+        ITUNER_HISO_GB_GR_MISMATCH,
+        ITUNER_HISO_DEMOSAIC_FILTER,
+        ITUNER_HISO_CHROMA_MEDIAN_FILTER,
+        ITUNER_HISO_DEFER_COLOR_CORRECTION,
+        ITUNER_HISO_ASF,
+        ITUNER_HISO_HIGH_ASF,
+        ITUNER_HISO_LOW_ASF,
+        ITUNER_HISO_MED_ASF,
+        ITUNER_HISO_CHROMA_ASF,
+        ITUNER_HISO_HIGH_SHARPEN_BOTH,
+        ITUNER_HISO_HIGH_SHARPEN_NOISE,
+        ITUNER_HISO_HIGH_FIR,
+        ITUNER_HISO_HIGH_CORING,
+        ITUNER_HISO_HIGH_CORING_INDEX_SCALE,
+        ITUNER_HISO_HIGH_MIN_CORING_RESULT,
+        ITUNER_HISO_HIGH_SCALE_CORING,
+        ITUNER_HISO_MED_SHARPEN_BOTH,
+        ITUNER_HISO_MED_SHARPEN_NOISE,
+        ITUNER_HISO_MED_FIR,
+        ITUNER_HISO_MED_CORING,
+        ITUNER_HISO_MED_CORING_INDEX_SCALE,
+        ITUNER_HISO_MED_MIN_CORING_RESULT,
+        ITUNER_HISO_MED_SCALE_CORING,
+        ITUNER_HISO_CHROMA_FILTER_HIGH,
+        ITUNER_HISO_CHROMA_FILTER_LOW_VERY_LOW,
+        ITUNER_HISO_CHROMA_FILTER_PRE,
+        ITUNER_HISO_CHROMA_FILTER_MED,
+        ITUNER_HISO_CHROMA_FILTER_LOW,
+        ITUNER_HISO_CHROMA_FILTER_VERY_LOW,
+        ITUNER_HISO_CHROMA_FILTER_MED_COMBINE,
+        ITUNER_HISO_CHROMA_FILTER_LOW_COMBINE,
+        ITUNER_HISO_CHROMA_FILTER_VERY_LOW_COMBINE,
+        ITUNER_HISO_LUMA_NOISE_COMBINE,
+        ITUNER_HISO_LOW_ASF_COMBINE,
+        ITUNER_HISO_FREQ_RECOVER,
+        ITUNER_STATIC_BAD_PIXEL_CORRECTION,
+        ITUNER_DZOOM,
+    };
+    const UINT8 Video_Filter[] = {
+        ITUNER_COLOR_CORRECTION,
+        ITUNER_STATIC_BLACK_LEVEL,
+        ITUNER_DEFERRED_BLACK_LEVEL,
+        ITUNER_DYNAMIC_BAD_PIXEL_CORRECTION,
+        ITUNER_CFA_LEAKAGE_FILTER,
+        ITUNER_CFA_NOISE_FILTER,
+        ITUNER_ANTI_ALIASING_STRENGTH,
+        ITUNER_WB_GAIN,
+        ITUNER_DGAIN_SATURATION_LEVEL,
+        ITUNER_LOCAL_EXPOSURE,
+        ITUNER_TONE_CURVE,
+        ITUNER_RGB_TO_YUV_MATRIX,
+        ITUNER_CHROMA_SCALE,
+        ITUNER_CHROMA_MEDIAN_FILTER,
+        ITUNER_DEMOSAIC_FILTER,
+        ITUNER_GB_GR_MISMATCH,
+        ITUNER_SHP_A_OR_SPATIAL_FILTE_SELECT,
+//        ITUNER_CDNR,
+        ITUNER_CHROMA_FILTER,
+//        ITUNER_VIDEO_MCTF,
+        ITUNER_DZOOM,
+    };
+    // High Iso
+    const UINT8 Hiso_Video_Filter[] = {
+        ITUNER_COLOR_CORRECTION,
+        ITUNER_STATIC_BLACK_LEVEL,
+        ITUNER_DEFERRED_BLACK_LEVEL,
+        ITUNER_DYNAMIC_BAD_PIXEL_CORRECTION,
+        ITUNER_CFA_LEAKAGE_FILTER,
+        ITUNER_CFA_NOISE_FILTER,
+        ITUNER_ANTI_ALIASING_STRENGTH,
+        ITUNER_WB_GAIN,
+        ITUNER_DGAIN_SATURATION_LEVEL,
+        ITUNER_LOCAL_EXPOSURE,
+        ITUNER_TONE_CURVE,
+        ITUNER_RGB_TO_YUV_MATRIX,
+        ITUNER_CHROMA_SCALE,
+        //ITUNER_CHROMA_MEDIAN_FILTER,
+        ITUNER_DEMOSAIC_FILTER,
+        ITUNER_GB_GR_MISMATCH,
+        //ITUNER_SHP_A_OR_SPATIAL_FILTE_SELECT,
+        //ITUNER_CDNR,
+        //ITUNER_CHROMA_FILTER,
+        ITUNER_VIDEO_MCTF,
+        ITUNER_DZOOM,
+    };
+
+    const UINT8 *Necessary_Filter = NULL;
+    UINT8 Size = 0;
+    if (Mode.Pipe == AMBA_DSP_IMG_PIPE_VIDEO) {
+        if (Mode.AlgoMode == AMBA_DSP_IMG_ALGO_MODE_HISO) {
+            Necessary_Filter = Hiso_Video_Filter;
+            Size = sizeof(Hiso_Video_Filter) / sizeof(Hiso_Video_Filter[0]);
+        } else {
+            Necessary_Filter = Video_Filter;
+            Size = sizeof(Video_Filter) / sizeof(Video_Filter[0]);
+        }
+        // HENRY TBD
+        // TODO: Add Preview Tuning
+    } else {
+        // Note: Still Mode
+        if (Mode.AlgoMode == AMBA_DSP_IMG_ALGO_MODE_HISO) {
+            Necessary_Filter = Hiso_Still_Filter;
+            Size = sizeof(Hiso_Still_Filter) / sizeof(Hiso_Still_Filter[0]);
+        } else {
+            Necessary_Filter = Liso_Still_Filter;
+            Size = sizeof(Liso_Still_Filter) / sizeof(Liso_Still_Filter[0]);
+        }
+    }
+    int Ret = 0;
+    int i;
+    for (i = 0; i < Size; i++) {
+        if (_Ituner_Valid_Filter[(UINT8)Necessary_Filter[i]] == 0) {
+            ITUNER_WARF("%s() %d, Pipe: %d, AlogMode: %d Lose Filter ID : %s", __func__, __LINE__, Mode.Pipe, Mode.AlgoMode, _G_Filter_Name[(UINT8)Necessary_Filter[i]]);
+            Ret = -1;
+        }
+    }
+    return Ret;
+}
+
+static inline void _AmbaItuner_GData_Init(void)
+{
+    memset(_Ituner_Valid_Filter, 0x0, sizeof(_Ituner_Valid_Filter));
+    memset(&GData, 0x0, sizeof(ITUNER_DATA_s));
+    // HENRY TBD
+    // TODO: Clear GTable
+#if 0
+    //Liso Sharp and Asf
+    GData.SharpenBoth.ThreeD.pTable = GTable.SharpenBothThreeDTable;
+    GData.FinalSharpenBoth.ThreeD.pTable = GTable.FinalSharpenBothThreeDTable;
+    GData.AsfInfo.Adapt.ThreeD.pTable = GTable.AsfInfoThreeDTable;
+    //Hiso Asf
+    GData.HisoAsf.Adapt.ThreeD.pTable       = GTable.HisoAsfThreeDTable;
+    GData.HisoHighAsf.Adapt.ThreeD.pTable   = GTable.HisoHighAsfThreeDTable;
+    GData.HisoLowAsf.Adapt.ThreeD.pTable    = GTable.HisoLowAsfThreeDTable;
+    GData.HisoMedAsf.Adapt.ThreeD.pTable   = GTable.HisoMedAsfThreeDTable;
+    GData.HisoLi2ndAsf.Adapt.ThreeD.pTable  = GTable.HisoLi2ndAsfThreeDTable;
+    GData.HisoChromaAsf.ThreeD.pTable = GTable.HisoChromaAsfThreeDTable;
+    //HisoHighSharpen
+    GData.HisoHighSharpenBoth.ThreeD.pTable = GTable.HisoHighSharpenBothThreeDTable;
+    //HisoMedSharpen
+    GData.HisoMedSharpenBoth.ThreeD.pTable = GTable.HisoMedSharpenBothThreeDTable;
+    //HisoLiso1Sharpen
+    GData.HisoLiso1SharpenBoth.ThreeD.pTable = GTable.HisoLiso1SharpenBothThreeDTable;
+    //HisoMedSharpen
+    GData.HisoLiso2SharpenBoth.ThreeD.pTable = GTable.HisoLiso2SharpenBothThreeDTable;
+#endif
+}
+
+static inline void _AmbaItuner_System_Init(void)
+{
+    //HENRY TBD
+    /*
+    typedef enum {
+        ITUNER_SAVE,
+        ITUNER_LOAD,
+        ITUNER_RAW_ENC,
+        ITUNER_RAW_CAP,
+    } ITUNER_MODE_e;
+    ITUNER_MODE_e Ituner_Mode = ITUNER_SAVE;
+    */
+    memset(&_System, 0x0, sizeof(_System));
+    strncpy(_System.ChipRev, "A9\0", sizeof(_System.ChipRev));
+    // TODO:
+    strncpy(_System.TuningMode, TUING_MODE_TO_STR(IMG_MODE_VIDEO), sizeof(_System.TuningMode));
+    strncpy(_System.TuningModeExt, TUING_MODE_EXT_TO_STR(SINGLE_SHOT), sizeof(_System.TuningModeExt));
+    /*
+    switch(Ituner_Mode)
+    {
+        case ITUNER_SAVE:
+            strncpy(_System.TuningMode, TUING_MODE_TO_STR(IMG_MODE_VIDEO), sizeof(_System.TuningMode));
+            strncpy(_System.TuningModeExt, TUING_MODE_EXT_TO_STR(SINGLE_SHOT), sizeof(_System.TuningModeExt));
+            break;
+    }
+    */
+}
+
+static inline void _AmbaItuner_Internal_Init(void)
+{
+    memset(&_Internal, 0x0, sizeof(_Internal));
+    _Internal.FpnHighlight = -1;
+    _Internal.Internal_u16_1 = 0;
+    _Internal.Internal_s32_0 = -1;
+    _Internal.Internal_s32_1 = -1;
+    _Internal.Internal_s32_2 = -1;
+    _Internal.Internal_s32_3 = -1;
+    _Internal.Internal_s32_4 = -1;
+    _Internal.Internal_sha_0 = -1;
+    _Internal.Internal_sha_1 = -1;
+    _Internal.Internal_sha_2 = -1;
+    _Internal.Internal_sha_3 = -1;
+    _Internal.Internal_sha_4 = -1;
+    _Internal.Internal_sha_5 = -1;
+    _Internal.Internal_shb_0 = -1;
+    _Internal.Internal_shb_1 = -1;
+    _Internal.Internal_shb_2 = -1;
+    _Internal.Internal_shb_3 = -1;
+    _Internal.Internal_shb_4 = -1;
+    _Internal.Internal_shb_5 = -1;
+    _Internal.Internal_wm_0 = -1;
+    _Internal.Internal_wm_1 = -1;
+    _Internal.Internal_wm_2 = -1;
+    _Internal.Internal_wm_3 = -1;
+    _Internal.NOT_CUSTOMER_VISIBLE_FULL_RAW_W = -1;
+    _Internal.NOT_CUSTOMER_VISIBLE_FULL_MAIN_W = -1;
+    _Internal.Internal_hdr_0 = -1;
+    _Internal.Internal_hdr_1 = -1;
+    _Internal.DiagMode = 0;
+}
+/*
+void _set_internal_params_default(void) {
+    _Internal.FpnHighlight = -1;
+    _Internal.Internal_u16_1 = 0;
+    _Internal.Internal_s32_0 = -1;
+    _Internal.Internal_s32_1 = -1;
+    _Internal.Internal_s32_2 = -1;
+    _Internal.Internal_s32_3 = -1;
+    _Internal.Internal_s32_4 = -1;
+    _Internal.Internal_sha_0 = -1;
+    _Internal.Internal_sha_1 = -1;
+    _Internal.Internal_sha_2 = -1;
+    _Internal.Internal_sha_3 = -1;
+    _Internal.Internal_sha_4 = -1;
+    _Internal.Internal_sha_5 = -1;
+    _Internal.Internal_shb_0 = -1;
+    _Internal.Internal_shb_1 = -1;
+    _Internal.Internal_shb_2 = -1;
+    _Internal.Internal_shb_3 = -1;
+    _Internal.Internal_shb_4 = -1;
+    _Internal.Internal_shb_5 = -1;
+    _Internal.Internal_wm_0 = -1;
+    _Internal.Internal_wm_1 = -1;
+    _Internal.Internal_wm_2 = -1;
+    _Internal.Internal_wm_3 = -1;
+    _Internal.NOT_CUSTOMER_VISIBLE_FULL_RAW_W = -1;
+    _Internal.NOT_CUSTOMER_VISIBLE_FULL_MAIN_W = -1;
+    _Internal.Internal_hdr_0 = -1;
+    _Internal.Internal_hdr_1 = -1;
+    _Internal.DiagMode = 0;
+}
+*/
+void AmbaItuner_Set_InternalInfo(Ituner_Internal_s *Internal) {
+    memcpy(&_Internal, Internal, sizeof(_Internal));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_INTERNAL_INFO);
+}
+
+void AmbaItuner_Get_InternalInfo(Ituner_Internal_s *Internal) {
+    memcpy(Internal, &_Internal, sizeof(Ituner_Internal_s));
+}
+
+void AmbaItuner_Set_SystemInfo(ITUNER_SYSTEM_s *System) {
+    memcpy(&_System, System, sizeof(_System));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_SYSTEM_INFO);
+}
+
+void AmbaItuner_Get_SystemInfo(ITUNER_SYSTEM_s *System) {
+    memcpy(System, &_System, sizeof(ITUNER_SYSTEM_s));
+}
+
+void AmbaItuner_Set_AAAFunction(AAA_FUNC_s *AaaFunction) {
+    memcpy(&GData.AaaFunction, AaaFunction, sizeof(GData.AaaFunction));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_AAA_FUNCTION);
+}
+
+void AmbaItuner_Get_AAAFunction(AAA_FUNC_s *AaaFunction) {
+    memcpy(AaaFunction, &GData.AaaFunction, sizeof(AAA_FUNC_s));
+}
+
+void AmbaItuner_Set_AeInfo(IMG_EXP_s *AeInfo) {
+    memcpy(&GData.AeInfo, AeInfo, sizeof(GData.AeInfo));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_AE_INFO);
+}
+
+void AmbaItuner_Get_AeInfo(IMG_EXP_s *AeInfo) {
+    memcpy(AeInfo, &GData.AeInfo, sizeof(IMG_EXP_s));
+}
+
+void AmbaItuner_Set_AeStatisticsInfo(amba_img_dsp_ae_stat_info_t *AeStatisticsInfo) {
+    memcpy(&GData.AeStatisticsInfo, AeStatisticsInfo, sizeof(GData.AeStatisticsInfo));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_AE_STATISTICS_INFO);
+}
+
+void AmbaItuner_Get_AeStatisticsInfo(amba_img_dsp_ae_stat_info_t *AeStatisticsInfo) {
+    memcpy(AeStatisticsInfo, &GData.AeStatisticsInfo, sizeof(amba_img_dsp_ae_stat_info_t));
+}
+
+void AmbaItuner_Set_AwbStatisticsInfo(amba_img_dsp_awb_stat_info_t *AwbStatisticsInfo) {
+    memcpy(&GData.AwbStatisticsInfo, AwbStatisticsInfo, sizeof(GData.AwbStatisticsInfo));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_AWB_STATISTICS_INFO);
+}
+
+void AmbaItuner_Get_AwbStatisticsInfo(amba_img_dsp_awb_stat_info_t *AwbStatisticsInfo) {
+    memcpy(AwbStatisticsInfo, &GData.AwbStatisticsInfo, sizeof(amba_img_dsp_awb_stat_info_t));
+}
+
+void AmbaItuner_Set_AfStatisticsInfo(amba_img_dsp_af_stat_info_t *AfStatisticsInfo) {
+    memcpy(&GData.AfStatisticsInfo, AfStatisticsInfo, sizeof(GData.AfStatisticsInfo));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_AF_STATISTICS_INFO);
+}
+
+void AmbaItuner_Get_AfStatisticsInfo(amba_img_dsp_af_stat_info_t *AfStatisticsInfo) {
+    memcpy(AfStatisticsInfo, &GData.AfStatisticsInfo, sizeof(amba_img_dsp_af_stat_info_t));
+}
+
+void AmbaItuner_Set_StaticBadPixelCorrection(ITUNER_FPN_s *StaticBadPixelCorrection) {
+    memcpy(&GData.StaticBadPixelCorrection, StaticBadPixelCorrection, sizeof(GData.StaticBadPixelCorrection));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_STATIC_BAD_PIXEL_CORRECTION);
+}
+
+void AmbaItuner_Get_StaticBadPixelCorrection(ITUNER_FPN_s *StaticBadPixelCorrection) {
+    memcpy(StaticBadPixelCorrection, &GData.StaticBadPixelCorrection, sizeof(ITUNER_FPN_s));
+}
+
+void AmbaItuner_Get_SbpCorr(amba_img_dsp_sbp_correction_t *SbpCorr) {
+    // Note: Only Get, without Set Api
+    memcpy(SbpCorr, &GData.SbpCorr, sizeof(amba_img_dsp_sbp_correction_t));
+}
+
+void AmbaItuner_Set_StaticBadPixelCorrectionByPass(ITUNER_FPN_BYPASS_s *StaticBadPixelCorrectionByPass) {
+    memcpy(&GData.StaticBadPixelCorrectionByPass, StaticBadPixelCorrectionByPass, sizeof(GData.StaticBadPixelCorrectionByPass));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_STATIC_BAD_PIXEL_CORRECTION_BY_PASS);
+}
+
+void AmbaItuner_Get_StaticBadPixelCorrectionByPass(ITUNER_FPN_BYPASS_s *StaticBadPixelCorrectionByPass) {
+    memcpy(StaticBadPixelCorrectionByPass, &GData.StaticBadPixelCorrectionByPass, sizeof(ITUNER_FPN_BYPASS_s));
+}
+
+void AmbaItuner_Set_VignetteCompensation(ITUNER_VIGNETTE_s *VignetteCompensation) {
+    memcpy(&GData.VignetteCompensation, VignetteCompensation, sizeof(GData.VignetteCompensation));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_VIGNETTE_COMPENSATION);
+}
+
+void AmbaItuner_Get_VignetteCompensation(ITUNER_VIGNETTE_s *VignetteCompensation) {
+    memcpy(VignetteCompensation, &GData.VignetteCompensation, sizeof(ITUNER_VIGNETTE_s));
+}
+
+void AmbaItuner_Get_VignetteCalcInfo(amba_img_dsp_vignette_calc_info_t *VignetteCalcInfo) {
+    // Note: Only Get, without Set Api
+    memcpy(VignetteCalcInfo, &GData.VignetteCalcInfo, sizeof(amba_img_dsp_vignette_calc_info_t));
+}
+
+void AmbaItuner_Set_VignetteCompensationByPass(ITUNER_VIGNETTE_BYPASS_s *VignetteCompensationByPass) {
+    memcpy(&GData.VignetteCompensationByPass, VignetteCompensationByPass, sizeof(GData.VignetteCompensationByPass));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_VIGNETTE_COMPENSATION_BY_PASS);
+}
+
+void AmbaItuner_Get_VignetteCompensationByPass(ITUNER_VIGNETTE_BYPASS_s *VignetteCompensationByPass) {
+    memcpy(VignetteCompensationByPass, &GData.VignetteCompensationByPass, sizeof(ITUNER_VIGNETTE_BYPASS_s));
+}
+
+void AmbaItuner_Set_WarpCompensation(ITUNER_WARP_s *WarpCompensation) {
+    memcpy(&GData.WarpCompensation, WarpCompensation, sizeof(GData.WarpCompensation));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_WARP_COMPENSATION);
+}
+
+void AmbaItuner_Get_WarpCompensation(ITUNER_WARP_s *WarpCompensation) {
+    memcpy(WarpCompensation, &GData.WarpCompensation, sizeof(ITUNER_WARP_s));
+}
+
+void AmbaItuner_Get_WarpCalcInfo(amba_img_dsp_warp_calc_info_t *WarpCalcInfo) {
+    memcpy(WarpCalcInfo, &GData.WarpCalcInfo, sizeof(amba_img_dsp_warp_calc_info_t));
+}
+
+void AmbaItuner_Set_Dzoom(ITUNER_DZOOM_s *Dzoom) {
+    memcpy(&GData.Dzoom, Dzoom, sizeof(GData.Dzoom));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_DZOOM);
+}
+
+void AmbaItuner_Get_Dzoom(ITUNER_DZOOM_s *Dzoom) {
+    memcpy(Dzoom, &GData.Dzoom, sizeof(ITUNER_DZOOM_s));
+}
+
+void AmbaItuner_Set_WarpCompensationDzoomByPass(ITUNER_WARP_DZOOM_BYPASS_s *WarpCompensationDzoomByPass) {
+    memcpy(&GData.WarpCompensationDzoomByPass, WarpCompensationDzoomByPass, sizeof(GData.WarpCompensationDzoomByPass));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_WARP_COMPENSATION_DZOOM_BY_PASS);
+}
+
+void AmbaItuner_Get_WarpCompensationDzoomByPass(ITUNER_WARP_DZOOM_BYPASS_s *WarpCompensationDzoomByPass) {
+    memcpy(WarpCompensationDzoomByPass, &GData.WarpCompensationDzoomByPass, sizeof(ITUNER_WARP_DZOOM_BYPASS_s));
+}
+
+void AmbaItuner_Set_SensorInputInfo(ITUNER_SENSOR_INPUT_s *SensorInputInfo) {
+    memcpy(&GData.SensorInputInfo, SensorInputInfo, sizeof(GData.SensorInputInfo));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_SENSOR_INPUT_INFO);
+}
+
+void AmbaItuner_Get_SensorInputInfo(ITUNER_SENSOR_INPUT_s *SensorInputInfo) {
+    memcpy(SensorInputInfo, &GData.SensorInputInfo, sizeof(ITUNER_SENSOR_INPUT_s));
+}
+
+void AmbaItuner_Set_StaticBlackLevel(amba_img_dsp_black_correction_t *StaticBlackLevel) {
+    memcpy(&GData.StaticBlackLevel, StaticBlackLevel, sizeof(GData.StaticBlackLevel));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_STATIC_BLACK_LEVEL);
+}
+
+void AmbaItuner_Get_StaticBlackLevel(amba_img_dsp_black_correction_t *StaticBlackLevel) {
+    memcpy(StaticBlackLevel, &GData.StaticBlackLevel, sizeof(amba_img_dsp_black_correction_t));
+}
+
+void AmbaItuner_Set_DeferredBlackLevel(amba_img_dsp_def_blc_t *DeferredBlackLevel) {
+    memcpy(&GData.DeferredBlackLevel, DeferredBlackLevel, sizeof(GData.DeferredBlackLevel));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_DEFERRED_BLACK_LEVEL);
+}
+
+void AmbaItuner_Get_DeferredBlackLevel(amba_img_dsp_def_blc_t *DeferredBlackLevel) {
+    memcpy(DeferredBlackLevel, &GData.DeferredBlackLevel, sizeof(amba_img_dsp_def_blc_t));
+}
+
+void AmbaItuner_Set_DynamicBadPixelCorrection(amba_img_dsp_dbp_correction_t *DynamicBadPixelCorrection) {
+    memcpy(&GData.DynamicBadPixelCorrection, DynamicBadPixelCorrection, sizeof(GData.DynamicBadPixelCorrection));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_DYNAMIC_BAD_PIXEL_CORRECTION);
+}
+
+void AmbaItuner_Get_DynamicBadPixelCorrection(amba_img_dsp_dbp_correction_t *DynamicBadPixelCorrection) {
+    memcpy(DynamicBadPixelCorrection, &GData.DynamicBadPixelCorrection, sizeof(amba_img_dsp_dbp_correction_t));
+}
+
+void AmbaItuner_Set_HisoDynamicBadPixelCorrection(amba_img_dsp_dbp_correction_t *HisoDynamicBadPixelCorrection) {
+    memcpy(&GData.HisoDynamicBadPixelCorrection, HisoDynamicBadPixelCorrection, sizeof(GData.HisoDynamicBadPixelCorrection));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_DYNAMIC_BAD_PIXEL_CORRECTION);
+}
+
+void AmbaItuner_Get_HisoDynamicBadPixelCorrection(amba_img_dsp_dbp_correction_t *HisoDynamicBadPixelCorrection) {
+    memcpy(HisoDynamicBadPixelCorrection, &GData.HisoDynamicBadPixelCorrection, sizeof(amba_img_dsp_dbp_correction_t));
+}
+
+void AmbaItuner_Set_CfaLeakageFilter(amba_img_dsp_cfa_leakage_filter_t *CfaLeakageFilter) {
+    memcpy(&GData.CfaLeakageFilter, CfaLeakageFilter, sizeof(GData.CfaLeakageFilter));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_CFA_LEAKAGE_FILTER);
+}
+
+void AmbaItuner_Get_CfaLeakageFilter(amba_img_dsp_cfa_leakage_filter_t *CfaLeakageFilter) {
+    memcpy(CfaLeakageFilter, &GData.CfaLeakageFilter, sizeof(amba_img_dsp_cfa_leakage_filter_t));
+}
+
+void AmbaItuner_Set_HisoCfaLeakageFilter(amba_img_dsp_cfa_leakage_filter_t *HisoCfaLeakageFilter) {
+    memcpy(&GData.HisoCfaLeakageFilter, HisoCfaLeakageFilter, sizeof(GData.HisoCfaLeakageFilter));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_CFA_LEAKAGE_FILTER);
+}
+
+void AmbaItuner_Get_HisoCfaLeakageFilter(amba_img_dsp_cfa_leakage_filter_t *HisoCfaLeakageFilter) {
+    memcpy(HisoCfaLeakageFilter, &GData.HisoCfaLeakageFilter, sizeof(amba_img_dsp_cfa_leakage_filter_t));
+}
+
+void AmbaItuner_Set_CfaNoiseFilter(amba_img_dsp_cfa_noise_filter_t *CfaNoiseFilter) {
+    memcpy(&GData.CfaNoiseFilter, CfaNoiseFilter, sizeof(GData.CfaNoiseFilter));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_CFA_NOISE_FILTER);
+}
+
+void AmbaItuner_Get_CfaNoiseFilter(amba_img_dsp_cfa_noise_filter_t *CfaNoiseFilter) {
+    memcpy(CfaNoiseFilter, &GData.CfaNoiseFilter, sizeof(amba_img_dsp_cfa_noise_filter_t));
+}
+
+void AmbaItuner_Set_HisoCfaNoiseFilter(amba_img_dsp_cfa_noise_filter_t *HisoCfaNoiseFilter) {
+    memcpy(&GData.HisoCfaNoiseFilter, HisoCfaNoiseFilter, sizeof(GData.HisoCfaNoiseFilter));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_CFA_NOISE_FILTER);
+}
+
+void AmbaItuner_Get_HisoCfaNoiseFilter(amba_img_dsp_cfa_noise_filter_t *HisoCfaNoiseFilter) {
+    memcpy(HisoCfaNoiseFilter, &GData.HisoCfaNoiseFilter, sizeof(amba_img_dsp_cfa_noise_filter_t));
+}
+
+void AmbaItuner_Set_AntiAliasingStrength(amba_img_dsp_anti_aliasing_t *AntiAliasing) {
+    memcpy(&GData.AntiAliasing, AntiAliasing, sizeof(amba_img_dsp_anti_aliasing_t));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_ANTI_ALIASING_STRENGTH);
+}
+
+void AmbaItuner_Get_AntiAliasingStrength(amba_img_dsp_anti_aliasing_t *AntiAliasing) {
+    *AntiAliasing = GData.AntiAliasing;
+}
+
+void AmbaItuner_Set_HisoAntiAliasingStrength(amba_img_dsp_anti_aliasing_t *HisoAntiAliasing) {
+    memcpy(&GData.HisoAntiAliasing, HisoAntiAliasing, sizeof(amba_img_dsp_anti_aliasing_t));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_ANTI_ALIASING_STRENGTH);
+}
+
+void AmbaItuner_Get_HisoAntiAliasingStrength(amba_img_dsp_anti_aliasing_t *HisoAntiAliasing) {
+    *HisoAntiAliasing = GData.HisoAntiAliasing;
+}
+
+
+void AmbaItuner_Set_GlobalDgain(UINT32 GlobalDgain) {
+    GData.GlobalDgain = GlobalDgain;
+    _AmbaItuner_Set_Filter_Valid(ITUNER_GLOBAL_DGAIN);
+}
+
+void AmbaItuner_Get_GlobalDgain(UINT32 *GlobalDgain) {
+    *GlobalDgain = GData.GlobalDgain;
+}
+
+void AmbaItuner_Set_WbGain(amba_img_dsp_wb_gain_t *WbGain) {
+    memcpy(&GData.WbGain, WbGain, sizeof(GData.WbGain));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_WB_GAIN);
+}
+
+void AmbaItuner_Get_WbGain(amba_img_dsp_wb_gain_t *WbGain) {
+    memcpy(WbGain, &GData.WbGain, sizeof(amba_img_dsp_wb_gain_t));
+}
+
+void AmbaItuner_Set_DgainSaturationLevel(amba_img_dsp_dgain_saturation_t *DgainSaturationLevel) {
+    memcpy(&GData.DgainSaturationLevel, DgainSaturationLevel, sizeof(GData.DgainSaturationLevel));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_DGAIN_SATURATION_LEVEL);
+}
+
+void AmbaItuner_Get_DgainSaturationLevel(amba_img_dsp_dgain_saturation_t *DgainSaturationLevel) {
+    memcpy(DgainSaturationLevel, &GData.DgainSaturationLevel, sizeof(amba_img_dsp_dgain_saturation_t));
+}
+
+void AmbaItuner_Set_LocalExposure(amba_img_dsp_local_exposure_t *LocalExposure) {
+    memcpy(&GData.LocalExposure, LocalExposure, sizeof(GData.LocalExposure));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_LOCAL_EXPOSURE);
+}
+
+void AmbaItuner_Get_LocalExposure(amba_img_dsp_local_exposure_t *LocalExposure) {
+    memcpy(LocalExposure, &GData.LocalExposure, sizeof(amba_img_dsp_local_exposure_t));
+}
+
+void AmbaItuner_Get_FilterStatus(AMBA_ITUNER_VALID_FILTER_t *FilterStatus)
+{
+    // Note: Only Get, without Set Api
+    memcpy(FilterStatus, &_Ituner_Valid_Filter, sizeof(AMBA_ITUNER_VALID_FILTER_t));
+}
+
+void AmbaItuner_Get_CcReg(amba_img_dsp_color_correction_reg_t *CcReg) {
+    // Note: Only Get, without Set Api
+    memcpy(CcReg, &GData.CcReg, sizeof(amba_img_dsp_color_correction_reg_t));
+}
+
+void AmbaItuner_Get_CcThreeD(amba_img_dsp_color_correction_t *CcThreeD) {
+    // Note: Only Get, without Set Api
+    memcpy(CcThreeD, &GData.CcThreeD, sizeof(amba_img_dsp_color_correction_t));
+}
+
+void AmbaItuner_Set_ColorCorrection(ITUNER_COLOR_CORRECTION_s *ColorCorrection) {
+    memcpy(&GData.ColorCorrection, ColorCorrection, sizeof(GData.ColorCorrection));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_COLOR_CORRECTION);
+}
+
+void AmbaItuner_Get_ColorCorrection(ITUNER_COLOR_CORRECTION_s *ColorCorrection) {
+    memcpy(ColorCorrection, &GData.ColorCorrection, sizeof(ITUNER_COLOR_CORRECTION_s));
+}
+
+void AmbaItuner_Set_ToneCurve(amba_img_dsp_tone_curve_t *ToneCurve) {
+    memcpy(&GData.ToneCurve, ToneCurve, sizeof(GData.ToneCurve));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_TONE_CURVE);
+}
+
+void AmbaItuner_Get_ToneCurve(amba_img_dsp_tone_curve_t *ToneCurve) {
+    memcpy(ToneCurve, &GData.ToneCurve, sizeof(amba_img_dsp_tone_curve_t));
+}
+
+void AmbaItuner_Set_RgbToYuvMatrix(amba_img_dsp_rgb_to_yuv_t *RgbToYuvMatrix) {
+    memcpy(&GData.RgbToYuvMatrix, RgbToYuvMatrix, sizeof(GData.RgbToYuvMatrix));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_RGB_TO_YUV_MATRIX);
+}
+
+void AmbaItuner_Get_RgbToYuvMatrix(amba_img_dsp_rgb_to_yuv_t *RgbToYuvMatrix) {
+    memcpy(RgbToYuvMatrix, &GData.RgbToYuvMatrix, sizeof(amba_img_dsp_rgb_to_yuv_t));
+}
+
+void AmbaItuner_Set_ChromaScale(amba_img_dsp_chroma_scale_t *ChromaScale) {
+    memcpy(&GData.ChromaScale, ChromaScale, sizeof(GData.ChromaScale));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_CHROMA_SCALE);
+}
+
+void AmbaItuner_Get_ChromaScale(amba_img_dsp_chroma_scale_t *ChromaScale) {
+    memcpy(ChromaScale, &GData.ChromaScale, sizeof(amba_img_dsp_chroma_scale_t));
+}
+
+void AmbaItuner_Set_ChromaMedianFilter(amba_img_dsp_chroma_median_filter_t *ChromaMedianFilter) {
+    memcpy(&GData.ChromaMedianFilter, ChromaMedianFilter, sizeof(GData.ChromaMedianFilter));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_CHROMA_MEDIAN_FILTER);
+}
+
+void AmbaItuner_Get_ChromaMedianFilter(amba_img_dsp_chroma_median_filter_t *ChromaMedianFilter) {
+    memcpy(ChromaMedianFilter, &GData.ChromaMedianFilter, sizeof(amba_img_dsp_chroma_median_filter_t));
+}
+
+void AmbaItuner_Set_HisoChromaMedianFilter(amba_img_dsp_chroma_median_filter_t *HisoChromaMedianFilter) {
+    memcpy(&GData.HisoChromaMedianFilter, HisoChromaMedianFilter, sizeof(GData.HisoChromaMedianFilter));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_CHROMA_MEDIAN_FILTER);
+}
+
+void AmbaItuner_Get_HisoChromaMedianFilter(amba_img_dsp_chroma_median_filter_t *HisoChromaMedianFilter) {
+    memcpy(HisoChromaMedianFilter, &GData.HisoChromaMedianFilter, sizeof(amba_img_dsp_chroma_median_filter_t));
+}
+
+void AmbaItuner_Set_DemosaicFilter(amba_img_dsp_demosaic_t *DemosaicFilter) {
+    memcpy(&GData.DemosaicFilter, DemosaicFilter, sizeof(amba_img_dsp_demosaic_t));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_DEMOSAIC_FILTER);
+}
+
+void AmbaItuner_Get_DemosaicFilter(amba_img_dsp_demosaic_t *DemosaicFilter) {
+    memcpy(DemosaicFilter, &GData.DemosaicFilter, sizeof(GData.DemosaicFilter));
+}
+
+void AmbaItuner_Set_HisoDemosaicFilter(amba_img_dsp_demosaic_t *HisoDemosaicFilter) {
+    memcpy(&GData.HisoDemosaicFilter, HisoDemosaicFilter, sizeof(GData.HisoDemosaicFilter));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_DEMOSAIC_FILTER);
+}
+void AmbaItuner_Get_HisoDemosaicFilter(amba_img_dsp_demosaic_t *HisoDemosaicFilter) {
+    memcpy(HisoDemosaicFilter, &GData.HisoDemosaicFilter, sizeof(amba_img_dsp_demosaic_t));
+}
+
+void AmbaItuner_Set_SharpenBoth(amba_img_dsp_sharpen_both_t *SharpenBoth) {
+    memcpy(&GData.SharpenBoth, SharpenBoth, sizeof(GData.SharpenBoth));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_SHARPEN_BOTH);
+}
+
+void AmbaItuner_Get_SharpenBoth(amba_img_dsp_sharpen_both_t *SharpenBoth) {
+    memcpy(SharpenBoth, &GData.SharpenBoth, sizeof(amba_img_dsp_sharpen_both_t));
+}
+
+void AmbaItuner_Set_FinalSharpenBoth(amba_img_dsp_sharpen_both_t *FinalSharpenBoth) {
+    memcpy(&GData.FinalSharpenBoth, FinalSharpenBoth, sizeof(GData.FinalSharpenBoth));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_FINAL_SHARPEN_BOTH);
+}
+
+void AmbaItuner_Get_FinalSharpenBoth(amba_img_dsp_sharpen_both_t *FinalSharpenBoth) {
+    memcpy(FinalSharpenBoth, &GData.FinalSharpenBoth, sizeof(amba_img_dsp_sharpen_both_t));
+}
+
+void AmbaItuner_Set_HisoHighSharpenBoth(amba_img_dsp_sharpen_both_t *HisoHighSharpenBoth) {
+    memcpy(&GData.HisoHighSharpenBoth, HisoHighSharpenBoth, sizeof(GData.HisoHighSharpenBoth));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_HIGH_SHARPEN_BOTH);
+}
+
+void AmbaItuner_Get_HisoHighSharpenBoth(amba_img_dsp_sharpen_both_t *HisoHighSharpenBoth) {
+    memcpy(HisoHighSharpenBoth, &GData.HisoHighSharpenBoth, sizeof(amba_img_dsp_sharpen_both_t));
+}
+
+void AmbaItuner_Set_HisoMedSharpenBoth(amba_img_dsp_sharpen_both_t *HisoMedSharpenBoth) {
+    memcpy(&GData.HisoMedSharpenBoth, HisoMedSharpenBoth, sizeof(GData.HisoMedSharpenBoth));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_MED_SHARPEN_BOTH);
+}
+
+void AmbaItuner_Get_HisoMedSharpenBoth(amba_img_dsp_sharpen_both_t *HisoMedSharpenBoth) {
+    memcpy(HisoMedSharpenBoth, &GData.HisoMedSharpenBoth, sizeof(amba_img_dsp_sharpen_both_t));
+}
+
+void AmbaItuner_Set_SharpenNoise(amba_img_dsp_sharpen_noise_t *SharpenNoise) {
+    memcpy(&GData.SharpenNoise, SharpenNoise, sizeof(GData.SharpenNoise));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_SHARPEN_NOISE);
+}
+
+void AmbaItuner_Get_SharpenNoise(amba_img_dsp_sharpen_noise_t *SharpenNoise) {
+    memcpy(SharpenNoise, &GData.SharpenNoise, sizeof(amba_img_dsp_sharpen_noise_t));
+}
+
+void AmbaItuner_Set_FinalSharpenNoise(amba_img_dsp_sharpen_noise_t *FinalSharpenNoise) {
+    memcpy(&GData.FinalSharpenNoise, FinalSharpenNoise, sizeof(GData.FinalSharpenNoise));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_FINAL_SHARPEN_NOISE);
+}
+
+void AmbaItuner_Get_FinalSharpenNoise(amba_img_dsp_sharpen_noise_t *FinalSharpenNoise) {
+    memcpy(FinalSharpenNoise, &GData.FinalSharpenNoise, sizeof(amba_img_dsp_sharpen_noise_t));
+}
+
+void AmbaItuner_Set_HisoHighSharpenNoise(amba_img_dsp_sharpen_noise_t *HisoHighSharpenNoise) {
+    memcpy(&GData.HisoHighSharpenNoise, HisoHighSharpenNoise, sizeof(GData.HisoHighSharpenNoise));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_HIGH_SHARPEN_NOISE);
+}
+
+void AmbaItuner_Get_HisoHighSharpenNoise(amba_img_dsp_sharpen_noise_t *HisoHighSharpenNoise) {
+    memcpy(HisoHighSharpenNoise, &GData.HisoHighSharpenNoise, sizeof(amba_img_dsp_sharpen_noise_t));
+}
+
+void AmbaItuner_Set_HisoMedSharpenNoise(amba_img_dsp_sharpen_noise_t *HisoMedSharpenNoise) {
+    memcpy(&GData.HisoMedSharpenNoise, HisoMedSharpenNoise, sizeof(GData.HisoMedSharpenNoise));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_MED_SHARPEN_NOISE);
+}
+
+void AmbaItuner_Get_HisoMedSharpenNoise(amba_img_dsp_sharpen_noise_t *HisoMedSharpenNoise) {
+    memcpy(HisoMedSharpenNoise, &GData.HisoMedSharpenNoise, sizeof(amba_img_dsp_sharpen_noise_t));
+}
+
+void AmbaItuner_Set_Fir(amba_img_dsp_fir_t *Fir) {
+    memcpy(&GData.Fir, Fir, sizeof(GData.Fir));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_FIR);
+}
+
+void AmbaItuner_Get_Fir(amba_img_dsp_fir_t *Fir) {
+    memcpy(Fir, &GData.Fir, sizeof(amba_img_dsp_fir_t));
+}
+
+void AmbaItuner_Set_FinalFir(amba_img_dsp_fir_t *FinalFir) {
+    memcpy(&GData.FinalFir, FinalFir, sizeof(GData.FinalFir));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_FINAL_FIR);
+}
+
+void AmbaItuner_Get_FinalFir(amba_img_dsp_fir_t *FinalFir) {
+    memcpy(FinalFir, &GData.FinalFir, sizeof(amba_img_dsp_fir_t));
+}
+
+void AmbaItuner_Set_HisoHighFir(amba_img_dsp_fir_t *HisoHighFir) {
+    memcpy(&GData.HisoHighFir, HisoHighFir, sizeof(GData.HisoHighFir));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_HIGH_FIR);
+}
+
+void AmbaItuner_Get_HisoHighFir(amba_img_dsp_fir_t *HisoHighFir) {
+    memcpy(HisoHighFir, &GData.HisoHighFir, sizeof(amba_img_dsp_fir_t));
+}
+
+void AmbaItuner_Set_HisoMedFir(amba_img_dsp_fir_t *HisoMedFir) {
+    memcpy(&GData.HisoMedFir, HisoMedFir, sizeof(GData.HisoMedFir));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_MED_FIR);
+}
+
+void AmbaItuner_Get_HisoMedFir(amba_img_dsp_fir_t *HisoMedFir) {
+    memcpy(HisoMedFir, &GData.HisoMedFir, sizeof(amba_img_dsp_fir_t));
+}
+
+void AmbaItuner_Set_Coring(amba_img_dsp_coring_t *Coring) {
+    memcpy(&GData.Coring, Coring, sizeof(GData.Coring));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_CORING);
+}
+
+void AmbaItuner_Get_Coring(amba_img_dsp_coring_t *Coring) {
+    memcpy(Coring, &GData.Coring, sizeof(amba_img_dsp_coring_t));
+}
+
+void AmbaItuner_Set_FinalCoring(amba_img_dsp_coring_t *FinalCoring) {
+    memcpy(&GData.FinalCoring, FinalCoring, sizeof(GData.FinalCoring));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_FINAL_CORING);
+}
+
+void AmbaItuner_Get_FinalCoring(amba_img_dsp_coring_t *FinalCoring) {
+    memcpy(FinalCoring, &GData.FinalCoring, sizeof(amba_img_dsp_coring_t));
+}
+
+void AmbaItuner_Set_HisoHighCoring(amba_img_dsp_coring_t *HisoHighCoring) {
+    memcpy(&GData.HisoHighCoring, HisoHighCoring, sizeof(GData.HisoHighCoring));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_HIGH_CORING);
+}
+
+void AmbaItuner_Get_HisoHighCoring(amba_img_dsp_coring_t *HisoHighCoring) {
+    memcpy(HisoHighCoring, &GData.HisoHighCoring, sizeof(amba_img_dsp_coring_t));
+}
+
+void AmbaItuner_Set_HisoMedCoring(amba_img_dsp_coring_t *HisoMedCoring) {
+    memcpy(&GData.HisoMedCoring, HisoMedCoring, sizeof(GData.HisoMedCoring));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_MED_CORING);
+}
+
+void AmbaItuner_Get_HisoMedCoring(amba_img_dsp_coring_t *HisoMedCoring) {
+    memcpy(HisoMedCoring, &GData.HisoMedCoring, sizeof(amba_img_dsp_coring_t));
+}
+
+void AmbaItuner_Set_CoringIndexScale(amba_img_dsp_level_t *CoringIndexScale) {
+    memcpy(&GData.CoringIndexScale, CoringIndexScale, sizeof(GData.CoringIndexScale));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_CORING_INDEX_SCALE);
+}
+
+void AmbaItuner_Get_CoringIndexScale(amba_img_dsp_level_t *CoringIndexScale) {
+    memcpy(CoringIndexScale, &GData.CoringIndexScale, sizeof(amba_img_dsp_level_t));
+}
+
+void AmbaItuner_Set_MinCoringResult(amba_img_dsp_level_t *MinCoringResult) {
+    memcpy(&GData.MinCoringResult, MinCoringResult, sizeof(GData.MinCoringResult));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_MIN_CORING_RESULT);
+}
+
+void AmbaItuner_Get_MinCoringResult(amba_img_dsp_level_t *MinCoringResult) {
+    memcpy(MinCoringResult, &GData.MinCoringResult, sizeof(amba_img_dsp_level_t));
+}
+
+void AmbaItuner_Set_ScaleCoring(amba_img_dsp_level_t *ScaleCoring) {
+    memcpy(&GData.ScaleCoring, ScaleCoring, sizeof(GData.ScaleCoring));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_SCALE_CORING);
+}
+
+void AmbaItuner_Get_ScaleCoring(amba_img_dsp_level_t *ScaleCoring) {
+    memcpy(ScaleCoring, &GData.ScaleCoring, sizeof(amba_img_dsp_level_t));
+}
+
+void AmbaItuner_Set_FinalCoringIndexScale(amba_img_dsp_level_t *FinalCoringIndexScale) {
+    memcpy(&GData.FinalCoringIndexScale, FinalCoringIndexScale, sizeof(GData.FinalCoringIndexScale));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_FINAL_CORING_INDEX_SCALE);
+}
+
+void AmbaItuner_Get_FinalCoringIndexScale(amba_img_dsp_level_t *FinalCoringIndexScale) {
+    memcpy(FinalCoringIndexScale, &GData.FinalCoringIndexScale, sizeof(amba_img_dsp_level_t));
+}
+
+void AmbaItuner_Set_FinalMinCoringResult(amba_img_dsp_level_t *FinalMinCoringResult) {
+    memcpy(&GData.FinalMinCoringResult, FinalMinCoringResult, sizeof(GData.FinalMinCoringResult));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_FINAL_MIN_CORING_RESULT);
+}
+
+void AmbaItuner_Get_FinalMinCoringResult(amba_img_dsp_level_t *FinalMinCoringResult) {
+    memcpy(FinalMinCoringResult, &GData.FinalMinCoringResult, sizeof(amba_img_dsp_level_t));
+}
+
+void AmbaItuner_Set_FinalScaleCoring(amba_img_dsp_level_t *FinalScaleCoring) {
+    memcpy(&GData.FinalScaleCoring, FinalScaleCoring, sizeof(GData.FinalScaleCoring));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_FINAL_SCALE_CORING);
+}
+
+void AmbaItuner_Get_FinalScaleCoring(amba_img_dsp_level_t *FinalScaleCoring) {
+    memcpy(FinalScaleCoring, &GData.FinalScaleCoring, sizeof(amba_img_dsp_level_t));
+}
+
+void AmbaItuner_Set_HisoHighCoringIndexScale(amba_img_dsp_level_t *HisoHighCoringIndexScale) {
+    memcpy(&GData.HisoHighCoringIndexScale, HisoHighCoringIndexScale, sizeof(GData.HisoHighCoringIndexScale));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_HIGH_CORING_INDEX_SCALE);
+}
+
+void AmbaItuner_Get_HisoHighCoringIndexScale(amba_img_dsp_level_t *HisoHighCoringIndexScale) {
+    memcpy(HisoHighCoringIndexScale, &GData.HisoHighCoringIndexScale, sizeof(amba_img_dsp_level_t));
+}
+
+void AmbaItuner_Set_HisoHighMinCoringResult(amba_img_dsp_level_t *HisoHighMinCoringResult) {
+    memcpy(&GData.HisoHighMinCoringResult, HisoHighMinCoringResult, sizeof(GData.HisoHighMinCoringResult));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_HIGH_MIN_CORING_RESULT);
+}
+
+void AmbaItuner_Get_HisoHighMinCoringResult(amba_img_dsp_level_t *HisoHighMinCoringResult) {
+    memcpy(HisoHighMinCoringResult, &GData.HisoHighMinCoringResult, sizeof(amba_img_dsp_level_t));
+}
+
+void AmbaItuner_Set_HisoHighScaleCoring(amba_img_dsp_level_t *HisoHighScaleCoring) {
+    memcpy(&GData.HisoHighScaleCoring, HisoHighScaleCoring, sizeof(GData.HisoHighScaleCoring));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_HIGH_SCALE_CORING);
+}
+
+void AmbaItuner_Get_HisoHighScaleCoring(amba_img_dsp_level_t *HisoHighScaleCoring) {
+    memcpy(HisoHighScaleCoring, &GData.HisoHighScaleCoring, sizeof(amba_img_dsp_level_t));
+}
+
+void AmbaItuner_Set_HisoMedCoringIndexScale(amba_img_dsp_level_t *HisoMedCoringIndexScale) {
+    memcpy(&GData.HisoMedCoringIndexScale, HisoMedCoringIndexScale, sizeof(GData.HisoMedCoringIndexScale));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_MED_CORING_INDEX_SCALE);
+}
+
+void AmbaItuner_Get_HisoMedCoringIndexScale(amba_img_dsp_level_t *HisoMedCoringIndexScale) {
+    memcpy(HisoMedCoringIndexScale, &GData.HisoMedCoringIndexScale, sizeof(amba_img_dsp_level_t));
+}
+
+void AmbaItuner_Set_HisoMedMinCoringResult(amba_img_dsp_level_t *HisoMedMinCoringResult) {
+    memcpy(&GData.HisoMedMinCoringResult, HisoMedMinCoringResult, sizeof(GData.HisoMedMinCoringResult));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_MED_MIN_CORING_RESULT);
+}
+
+void AmbaItuner_Get_HisoMedMinCoringResult(amba_img_dsp_level_t *HisoMedMinCoringResult) {
+    memcpy(HisoMedMinCoringResult, &GData.HisoMedMinCoringResult, sizeof(amba_img_dsp_level_t));
+}
+
+void AmbaItuner_Set_HisoMedScaleCoring(amba_img_dsp_level_t *HisoMedScaleCoring) {
+    memcpy(&GData.HisoMedScaleCoring, HisoMedScaleCoring, sizeof(GData.HisoMedScaleCoring));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_MED_SCALE_CORING);
+}
+
+void AmbaItuner_Get_HisoMedScaleCoring(amba_img_dsp_level_t *HisoMedScaleCoring) {
+    memcpy(HisoMedScaleCoring, &GData.HisoMedScaleCoring, sizeof(amba_img_dsp_level_t));
+}
+
+void AmbaItuner_Set_VideoMctf(amba_img_dsp_video_mctf_info_t *VideoMctf) {
+    memcpy(&GData.VideoMctf, VideoMctf, sizeof(GData.VideoMctf));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_VIDEO_MCTF);
+}
+
+void AmbaItuner_Get_VideoMctf(amba_img_dsp_video_mctf_info_t *VideoMctf) {
+    memcpy(VideoMctf, &GData.VideoMctf, sizeof(amba_img_dsp_video_mctf_info_t));
+}
+
+void AmbaItuner_Set_VideoMctfTemporalAdjust(amba_img_dsp_video_mctf_temporal_adjust_t *VideoMctfTemporalAdjust) {
+    memcpy(&GData.VideoMctfTemporalAdjust, VideoMctfTemporalAdjust, sizeof(GData.VideoMctfTemporalAdjust));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_VIDEO_MCTF_TEMPORAL_ADJUST);
+}
+
+void AmbaItuner_Get_VideoMctfTemporalAdjust(amba_img_dsp_video_mctf_temporal_adjust_t *VideoMctfTemporalAdjust) {
+    memcpy(VideoMctfTemporalAdjust, &GData.VideoMctfTemporalAdjust, sizeof(amba_img_dsp_video_mctf_temporal_adjust_t));
+}
+
+void AmbaItuner_Set_CDNR(amba_img_dsp_cdnr_info_t *CDNR) {
+    memcpy(&GData.CDNR, CDNR, sizeof(GData.CDNR));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_CDNR);
+}
+
+void AmbaItuner_Get_CDNR(amba_img_dsp_cdnr_info_t *CDNR) {
+    memcpy(CDNR, &GData.CDNR, sizeof(amba_img_dsp_cdnr_info_t));
+}
+
+void AmbaItuner_Set_HisoDeferColorCorrection(AMBA_DSP_IMG_DEFER_COLOR_CORRECTION_s *HisoDeferColorCorrection) {
+    memcpy(&GData.HisoDeferColorCorrection, HisoDeferColorCorrection, sizeof(GData.HisoDeferColorCorrection));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_DEFER_COLOR_CORRECTION);
+}
+
+void AmbaItuner_Get_HisoDeferColorCorrection(AMBA_DSP_IMG_DEFER_COLOR_CORRECTION_s *HisoDeferColorCorrection) {
+    memcpy(HisoDeferColorCorrection, &GData.HisoDeferColorCorrection, sizeof(AMBA_DSP_IMG_DEFER_COLOR_CORRECTION_s));
+}
+
+void AmbaItuner_Set_ShpAOrSpatialFilterSelect(amba_img_dsp_liso_process_select_t *LisoProcessSelect) {
+    memcpy(&GData.LisoProcessSelect, LisoProcessSelect, sizeof(amba_img_dsp_liso_process_select_t));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_SHP_A_OR_SPATIAL_FILTE_SELECT);
+}
+
+void AmbaItuner_Get_ShpAOrSpatialFilterSelect(amba_img_dsp_liso_process_select_t *LisoProcessSelect) {
+    memcpy(LisoProcessSelect, &GData.LisoProcessSelect, sizeof(amba_img_dsp_liso_process_select_t));
+}
+
+void AmbaItuner_Set_AsfInfo(amba_img_dsp_asf_info_t *AsfInfo) {
+    memcpy(&GData.AsfInfo, AsfInfo, sizeof(GData.AsfInfo));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_ASF_INFO);
+}
+
+void AmbaItuner_Get_AsfInfo(amba_img_dsp_asf_info_t *AsfInfo) {
+    memcpy(AsfInfo, &GData.AsfInfo, sizeof(amba_img_dsp_asf_info_t));
+}
+
+void AmbaItuner_Set_HisoAsf(amba_img_dsp_asf_info_t *HisoAsf) {
+    memcpy(&GData.HisoAsf, HisoAsf, sizeof(GData.HisoAsf));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_ASF);
+}
+
+void AmbaItuner_Get_HisoAsf(amba_img_dsp_asf_info_t *HisoAsf) {
+    memcpy(HisoAsf, &GData.HisoAsf, sizeof(amba_img_dsp_asf_info_t));
+}
+
+void AmbaItuner_Set_HisoHighAsf(amba_img_dsp_asf_info_t *HisoHighAsf) {
+    memcpy(&GData.HisoHighAsf, HisoHighAsf, sizeof(GData.HisoHighAsf));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_HIGH_ASF);
+}
+
+void AmbaItuner_Get_HisoHighAsf(amba_img_dsp_asf_info_t *HisoHighAsf) {
+    memcpy(HisoHighAsf, &GData.HisoHighAsf, sizeof(amba_img_dsp_asf_info_t));
+}
+
+void AmbaItuner_Set_HisoLowAsf(amba_img_dsp_asf_info_t *HisoLowAsf) {
+    memcpy(&GData.HisoLowAsf, HisoLowAsf, sizeof(GData.HisoLowAsf));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_LOW_ASF);
+}
+
+void AmbaItuner_Get_HisoLowAsf(amba_img_dsp_asf_info_t *HisoLowAsf) {
+    memcpy(HisoLowAsf, &GData.HisoLowAsf, sizeof(amba_img_dsp_asf_info_t));
+}
+
+void AmbaItuner_Set_HisoMedAsf(amba_img_dsp_asf_info_t *HisoMedAsf) {
+    memcpy(&GData.HisoMedAsf, HisoMedAsf, sizeof(GData.HisoMedAsf));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_MED_ASF);
+}
+
+void AmbaItuner_Get_HisoMedAsf(amba_img_dsp_asf_info_t *HisoMedAsf) {
+    memcpy(HisoMedAsf, &GData.HisoMedAsf, sizeof(amba_img_dsp_asf_info_t));
+}
+
+void AmbaItuner_Set_HisoChromaAsf(AMBA_DSP_IMG_CHROMA_ASF_INFO_s *HisoChromaAsf) {
+    memcpy(&GData.HisoChromaAsf, HisoChromaAsf, sizeof(GData.HisoChromaAsf));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_CHROMA_ASF);
+}
+
+void AmbaItuner_Get_HisoChromaAsf(AMBA_DSP_IMG_CHROMA_ASF_INFO_s *HisoChromaAsf) {
+    memcpy(HisoChromaAsf, &GData.HisoChromaAsf, sizeof(AMBA_DSP_IMG_CHROMA_ASF_INFO_s));
+}
+
+
+void AmbaItuner_Set_ChromaFilter(amba_img_dsp_chroma_filter_t *ChromaFilter) {
+    memcpy(&GData.ChromaFilter, ChromaFilter, sizeof(GData.ChromaFilter));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_CHROMA_FILTER);
+}
+
+void AmbaItuner_Get_ChromaFilter(amba_img_dsp_chroma_filter_t *ChromaFilter) {
+    memcpy(ChromaFilter, &GData.ChromaFilter, sizeof(amba_img_dsp_chroma_filter_t));
+}
+
+void AmbaItuner_Set_WideChromaFilter(amba_img_dsp_chroma_filter_t *WideChromaFilter) {
+    memcpy(&GData.WideChromaFilter, WideChromaFilter, sizeof(GData.WideChromaFilter));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_WIDE_CHROMA_FILTER);
+}
+
+void AmbaItuner_Get_WideChromaFilter(amba_img_dsp_chroma_filter_t *WideChromaFilter) {
+    memcpy(WideChromaFilter, &GData.WideChromaFilter, sizeof(amba_img_dsp_chroma_filter_t));
+}
+
+void AmbaItuner_Set_WideChromaFilterCombine(AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s *WideChromaFilterCombine) {
+    memcpy(&GData.WideChromaFilterCombine, WideChromaFilterCombine, sizeof(GData.WideChromaFilterCombine));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_WIDE_CHROMA_FILTER_COMBINE);
+}
+
+void AmbaItuner_Get_WideChromaFilterCombine(AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s *WideChromaFilterCombine) {
+    memcpy(WideChromaFilterCombine, &GData.WideChromaFilterCombine, sizeof(AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s));
+}
+
+void AmbaItuner_Set_HisoChromaFilterHigh(amba_img_dsp_chroma_filter_t *HisoChromaFilterHigh) {
+    memcpy(&GData.HisoChromaFilterHigh, HisoChromaFilterHigh, sizeof(GData.HisoChromaFilterHigh));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_CHROMA_FILTER_HIGH);
+}
+
+void AmbaItuner_Get_HisoChromaFilterHigh(amba_img_dsp_chroma_filter_t *HisoChromaFilterHigh) {
+    memcpy(HisoChromaFilterHigh, &GData.HisoChromaFilterHigh, sizeof(amba_img_dsp_chroma_filter_t));
+}
+
+void AmbaItuner_Set_GbGrMismatch(amba_img_dsp_gbgr_mismatch_t *GbGrMismatch) {
+    memcpy(&GData.GbGrMismatch, GbGrMismatch, sizeof(GData.GbGrMismatch));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_GB_GR_MISMATCH);
+}
+
+void AmbaItuner_Get_GbGrMismatch(amba_img_dsp_gbgr_mismatch_t *GbGrMismatch) {
+    memcpy(GbGrMismatch, &GData.GbGrMismatch, sizeof(amba_img_dsp_gbgr_mismatch_t));
+}
+
+void AmbaItuner_Set_HisoGbGrMismatch(amba_img_dsp_gbgr_mismatch_t *HisoGbGrMismatch) {
+    memcpy(&GData.HisoGbGrMismatch, HisoGbGrMismatch, sizeof(GData.HisoGbGrMismatch));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_GB_GR_MISMATCH);
+}
+
+void AmbaItuner_Get_HisoGbGrMismatch(amba_img_dsp_gbgr_mismatch_t *HisoGbGrMismatch) {
+    memcpy(HisoGbGrMismatch, &GData.HisoGbGrMismatch, sizeof(amba_img_dsp_gbgr_mismatch_t));
+}
+
+void AmbaItuner_Set_ChromaAberrationInfo(ITUNER_CHROMA_ABERRATION_s *ChromaAberrationInfo) {
+    memcpy(&GData.ChromaAberrationInfo, ChromaAberrationInfo, sizeof(GData.ChromaAberrationInfo));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_CHROMA_ABERRATION_INFO);
+}
+
+void AmbaItuner_Get_ChromaAberrationInfo(ITUNER_CHROMA_ABERRATION_s *ChromaAberrationInfo) {
+    memcpy(ChromaAberrationInfo, &GData.ChromaAberrationInfo, sizeof(ITUNER_CHROMA_ABERRATION_s));
+}
+
+void AmbaItuner_Get_CACalcInfo(AMBA_DSP_IMG_CAWARP_CALC_INFO_s *CACalcInfo) {
+    // Note: Only Get, without Set Api
+    memcpy(CACalcInfo, &GData.CACalcInfo, sizeof(AMBA_DSP_IMG_CAWARP_CALC_INFO_s));
+}
+void AmbaItuner_Set_ChromaAberrationInfoByPass(ITUNER_CHROMA_ABERRATION_BYPASS_s *ChromaAberrationInfoByPass) {
+    memcpy(&GData.ChromaAberrationInfoByPass, ChromaAberrationInfoByPass, sizeof(GData.ChromaAberrationInfoByPass));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_CHROMA_ABERRATION_INFO_BY_PASS);
+}
+
+void AmbaItuner_Get_ChromaAberrationInfoByPass(ITUNER_CHROMA_ABERRATION_BYPASS_s *ChromaAberrationInfoByPass) {
+    memcpy(ChromaAberrationInfoByPass, &GData.ChromaAberrationInfoByPass, sizeof(ITUNER_CHROMA_ABERRATION_BYPASS_s));
+}
+
+void AmbaItuner_Set_HisoChromaFilterLowVeryLow(AMBA_DSP_IMG_HISO_CHROMA_LOW_VERY_LOW_FILTER_s *HisoChromaFilterLowVeryLow) {
+    memcpy(&GData.HisoChromaFilterLowVeryLow, HisoChromaFilterLowVeryLow, sizeof(GData.HisoChromaFilterLowVeryLow));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_CHROMA_FILTER_LOW_VERY_LOW);
+}
+
+void AmbaItuner_Get_HisoChromaFilterLowVeryLow(AMBA_DSP_IMG_HISO_CHROMA_LOW_VERY_LOW_FILTER_s *HisoChromaFilterLowVeryLow) {
+    memcpy(HisoChromaFilterLowVeryLow, &GData.HisoChromaFilterLowVeryLow, sizeof(AMBA_DSP_IMG_HISO_CHROMA_LOW_VERY_LOW_FILTER_s));
+}
+
+void AmbaItuner_Set_HisoChromaFilterPre(AMBA_DSP_IMG_HISO_CHROMA_FILTER_s *HisoChromaFilterPre) {
+    memcpy(&GData.HisoChromaFilterPre, HisoChromaFilterPre, sizeof(GData.HisoChromaFilterPre));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_CHROMA_FILTER_PRE);
+}
+
+void AmbaItuner_Get_HisoChromaFilterPre(AMBA_DSP_IMG_HISO_CHROMA_FILTER_s *HisoChromaFilterPre) {
+    memcpy(HisoChromaFilterPre, &GData.HisoChromaFilterPre, sizeof(AMBA_DSP_IMG_HISO_CHROMA_FILTER_s));
+}
+
+void AmbaItuner_Set_HisoChromaFilterMed(AMBA_DSP_IMG_HISO_CHROMA_FILTER_s *HisoChromaFilterMed) {
+    memcpy(&GData.HisoChromaFilterMed, HisoChromaFilterMed, sizeof(GData.HisoChromaFilterMed));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_CHROMA_FILTER_MED);
+}
+
+void AmbaItuner_Get_HisoChromaFilterMed(AMBA_DSP_IMG_HISO_CHROMA_FILTER_s *HisoChromaFilterMed) {
+    memcpy(HisoChromaFilterMed, &GData.HisoChromaFilterMed, sizeof(AMBA_DSP_IMG_HISO_CHROMA_FILTER_s));
+}
+
+void AmbaItuner_Set_HisoChromaFilterLow(AMBA_DSP_IMG_HISO_CHROMA_FILTER_s *HisoChromaFilterLow) {
+    memcpy(&GData.HisoChromaFilterLow, HisoChromaFilterLow, sizeof(GData.HisoChromaFilterLow));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_CHROMA_FILTER_LOW);
+}
+
+void AmbaItuner_Get_HisoChromaFilterLow(AMBA_DSP_IMG_HISO_CHROMA_FILTER_s *HisoChromaFilterLow) {
+    memcpy(HisoChromaFilterLow, &GData.HisoChromaFilterLow, sizeof(AMBA_DSP_IMG_HISO_CHROMA_FILTER_s));
+}
+
+void AmbaItuner_Set_HisoChromaFilterVeryLow(AMBA_DSP_IMG_HISO_CHROMA_FILTER_s *HisoChromaFilterVeryLow) {
+    memcpy(&GData.HisoChromaFilterVeryLow, HisoChromaFilterVeryLow, sizeof(GData.HisoChromaFilterVeryLow));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_CHROMA_FILTER_VERY_LOW);
+}
+
+void AmbaItuner_Get_HisoChromaFilterVeryLow(AMBA_DSP_IMG_HISO_CHROMA_FILTER_s *HisoChromaFilterVeryLow) {
+    memcpy(HisoChromaFilterVeryLow, &GData.HisoChromaFilterVeryLow, sizeof(AMBA_DSP_IMG_HISO_CHROMA_FILTER_s));
+}
+
+void AmbaItuner_Set_HisoChromaFilterVeryLowCombine(AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s *HisoChromaFilterVeryLowCombine) {
+    memcpy(&GData.HisoChromaFilterVeryLowCombine, HisoChromaFilterVeryLowCombine, sizeof(GData.HisoChromaFilterVeryLowCombine));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_CHROMA_FILTER_VERY_LOW_COMBINE);
+}
+
+void AmbaItuner_Get_HisoChromaFilterVeryLowCombine(AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s *HisoChromaFilterVeryLowCombine) {
+    memcpy(HisoChromaFilterVeryLowCombine, &GData.HisoChromaFilterVeryLowCombine, sizeof(AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s));
+}
+
+void AmbaItuner_Set_HisoChromaFilterMedCombine(AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s *HisoChromaFilterMedCombine) {
+    memcpy(&GData.HisoChromaFilterMedCombine, HisoChromaFilterMedCombine, sizeof(GData.HisoChromaFilterMedCombine));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_CHROMA_FILTER_MED_COMBINE);
+}
+
+void AmbaItuner_Get_HisoChromaFilterMedCombine(AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s *HisoChromaFilterMedCombine) {
+    memcpy(HisoChromaFilterMedCombine, &GData.HisoChromaFilterMedCombine, sizeof(AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s));
+}
+
+void AmbaItuner_Set_HisoChromaFilterLowCombine(AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s *HisoChromaFilterLowCombine) {
+    memcpy(&GData.HisoChromaFilterLowCombine, HisoChromaFilterLowCombine, sizeof(GData.HisoChromaFilterLowCombine));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_CHROMA_FILTER_LOW_COMBINE);
+}
+
+void AmbaItuner_Get_HisoChromaFilterLowCombine(AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s *HisoChromaFilterLowCombine) {
+    memcpy(HisoChromaFilterLowCombine, &GData.HisoChromaFilterLowCombine, sizeof(AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s));
+}
+
+
+void AmbaItuner_Set_HisoLumaNoiseCombine(AMBA_DSP_IMG_HISO_LUMA_FILTER_COMBINE_s *HisoLumaNoiseCombine) {
+    memcpy(&GData.HisoLumaNoiseCombine, HisoLumaNoiseCombine, sizeof(GData.HisoLumaNoiseCombine));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_LUMA_NOISE_COMBINE);
+}
+
+void AmbaItuner_Get_HisoLumaNoiseCombine(AMBA_DSP_IMG_HISO_LUMA_FILTER_COMBINE_s *HisoLumaNoiseCombine) {
+    memcpy(HisoLumaNoiseCombine, &GData.HisoLumaNoiseCombine, sizeof(AMBA_DSP_IMG_HISO_LUMA_FILTER_COMBINE_s));
+}
+
+void AmbaItuner_Set_HisoLowASFCombine(AMBA_DSP_IMG_HISO_LUMA_FILTER_COMBINE_s *HisoLowASFCombine) {
+    memcpy(&GData.HisoLowASFCombine, HisoLowASFCombine, sizeof(GData.HisoLowASFCombine));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_LOW_ASF_COMBINE);
+}
+void AmbaItuner_Get_HisoLowASFCombine(AMBA_DSP_IMG_HISO_LUMA_FILTER_COMBINE_s *HisoLowASFCombine) {
+    memcpy(HisoLowASFCombine, &GData.HisoLowASFCombine, sizeof(AMBA_DSP_IMG_HISO_LUMA_FILTER_COMBINE_s));
+}
+
+void AmbaItuner_Set_HisoFreqRecover(AMBA_DSP_IMG_HISO_FREQ_RECOVER_s *HisoFreqRecover) {
+    memcpy(&GData.HisoFreqRecover, HisoFreqRecover, sizeof(GData.HisoFreqRecover));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_FREQ_RECOVER);
+}
+
+void AmbaItuner_Get_HisoFreqRecover(AMBA_DSP_IMG_HISO_FREQ_RECOVER_s *HisoFreqRecover) {
+    memcpy(HisoFreqRecover, &GData.HisoFreqRecover, sizeof(AMBA_DSP_IMG_HISO_FREQ_RECOVER_s));
+}
+
+void AmbaItuner_Set_SensorInfo(amba_img_dsp_sensor_info_t *SensorInfo) {
+    memcpy(&GData.SensorInfo, SensorInfo, sizeof(GData.SensorInfo));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_SENSOR_INFO);
+}
+
+void AmbaItuner_Get_SensorInfo(amba_img_dsp_sensor_info_t *SensorInfo) {
+    memcpy(SensorInfo, &GData.SensorInfo, sizeof(amba_img_dsp_sensor_info_t));
+}
+
+void AmbaItuner_Set_MoDynamicBadPixelCorrection(amba_img_dsp_dbp_correction_t *MoDynamicBadPixelCorrection) {
+    memcpy(&GData.MoDynamicBadPixelCorrection, MoDynamicBadPixelCorrection, sizeof(GData.MoDynamicBadPixelCorrection));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_MO_DYNAMIC_BAD_PIXEL_CORRECTION);
+}
+
+void AmbaItuner_Get_MoDynamicBadPixelCorrection(amba_img_dsp_dbp_correction_t *MoDynamicBadPixelCorrection) {
+    memcpy(MoDynamicBadPixelCorrection, &GData.MoDynamicBadPixelCorrection, sizeof(amba_img_dsp_dbp_correction_t));
+}
+
+void AmbaItuner_Set_MoCfaLeakageFilter(amba_img_dsp_cfa_leakage_filter_t *MoCfaLeakageFilter) {
+    memcpy(&GData.MoCfaLeakageFilter, MoCfaLeakageFilter, sizeof(GData.MoCfaLeakageFilter));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_MO_CFA_LEAKAGE_FILTER);
+}
+
+void AmbaItuner_Get_MoCfaLeakageFilter(amba_img_dsp_cfa_leakage_filter_t *MoCfaLeakageFilter) {
+    memcpy(MoCfaLeakageFilter, &GData.MoCfaLeakageFilter, sizeof(amba_img_dsp_cfa_leakage_filter_t));
+}
+
+void AmbaItuner_Set_MoCfaNoiseFilter(amba_img_dsp_cfa_noise_filter_t *MoCfaNoiseFilter) {
+    memcpy(&GData.MoCfaNoiseFilter, MoCfaNoiseFilter, sizeof(GData.MoCfaNoiseFilter));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_MO_CFA_NOISE_FILTER);
+}
+
+void AmbaItuner_Get_MoCfaNoiseFilter(amba_img_dsp_cfa_noise_filter_t *MoCfaNoiseFilter) {
+    memcpy(MoCfaNoiseFilter, &GData.MoCfaNoiseFilter, sizeof(amba_img_dsp_cfa_noise_filter_t));
+}
+
+void AmbaItuner_Set_MoAntiAliasingStrength(amba_img_dsp_anti_aliasing_t *MoAntiAliasing) {
+    memcpy(&GData.MoAntiAliasing, MoAntiAliasing, sizeof(amba_img_dsp_anti_aliasing_t));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_MO_ANTI_ALIASING_STRENGTH);
+}
+
+void AmbaItuner_Get_MoAntiAliasingStrength(amba_img_dsp_anti_aliasing_t *MoAntiAliasing) {
+    *MoAntiAliasing = GData.MoAntiAliasing;
+}
+
+void AmbaItuner_Set_MoDemosaicFilter(amba_img_dsp_demosaic_t *MoDemosaicFilter) {
+    memcpy(&GData.MoDemosaicFilter, MoDemosaicFilter, sizeof(amba_img_dsp_demosaic_t));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_MO_DEMOSAIC_FILTER);
+}
+
+void AmbaItuner_Get_MoDemosaicFilter(amba_img_dsp_demosaic_t *MoDemosaicFilter) {
+    memcpy(MoDemosaicFilter, &GData.MoDemosaicFilter, sizeof(GData.MoDemosaicFilter));
+}
+
+void AmbaItuner_Set_MoGbGrMismatch(amba_img_dsp_gbgr_mismatch_t *MoGbGrMismatch) {
+    memcpy(&GData.MoGbGrMismatch, MoGbGrMismatch, sizeof(GData.MoGbGrMismatch));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_MO_GB_GR_MISMATCH);
+}
+
+void AmbaItuner_Get_MoGbGrMismatch(amba_img_dsp_gbgr_mismatch_t *MoGbGrMismatch) {
+    memcpy(MoGbGrMismatch, &GData.MoGbGrMismatch, sizeof(amba_img_dsp_gbgr_mismatch_t));
+}
+
+void AmbaItuner_Set_MoShpAOrSpatialFilterSelect(amba_img_dsp_mo_process_select_t *MoProcessSelect) {
+    memcpy(&GData.MoProcessSelect, MoProcessSelect, sizeof(amba_img_dsp_mo_process_select_t));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_MO_SHP_A_OR_SPATIAL_FILTE_SELECT);
+}
+
+void AmbaItuner_Get_MoShpAOrSpatialFilterSelect(amba_img_dsp_mo_process_select_t *MoProcessSelect) {
+    memcpy(MoProcessSelect, &GData.MoProcessSelect, sizeof(amba_img_dsp_mo_process_select_t));
+}
+
+void AmbaItuner_Set_MoAsfInfo(amba_img_dsp_asf_info_t *MoAsfInfo) {
+    memcpy(&GData.MoAsfInfo, MoAsfInfo, sizeof(GData.MoAsfInfo));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_MO_ASF_INFO);
+}
+
+void AmbaItuner_Get_MoAsfInfo(amba_img_dsp_asf_info_t *MoAsfInfo) {
+    memcpy(MoAsfInfo, &GData.MoAsfInfo, sizeof(amba_img_dsp_asf_info_t));
+}
+
+void AmbaItuner_Set_MoChromaFilter(amba_img_dsp_chroma_filter_t *MoChromaFilter) {
+    memcpy(&GData.MoChromaFilter, MoChromaFilter, sizeof(GData.MoChromaFilter));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_MO_CHROMA_FILTER);
+}
+
+void AmbaItuner_Get_MoChromaFilter(amba_img_dsp_chroma_filter_t *MoChromaFilter) {
+    memcpy(MoChromaFilter, &GData.MoChromaFilter, sizeof(amba_img_dsp_chroma_filter_t));
+}
+
+void AmbaItuner_Set_MoChromaMedianFilter(amba_img_dsp_chroma_median_filter_t *MoChromaMedianFilter) {
+    memcpy(&GData.MoChromaMedianFilter, MoChromaMedianFilter, sizeof(GData.MoChromaMedianFilter));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_MO_CHROMA_MEDIAN_FILTER);
+}
+
+void AmbaItuner_Get_MoChromaMedianFilter(amba_img_dsp_chroma_median_filter_t *MoChromaMedianFilter) {
+    memcpy(MoChromaMedianFilter, &GData.MoChromaMedianFilter, sizeof(amba_img_dsp_chroma_median_filter_t));
+}
+
+void AmbaItuner_Set_MoSharpenBoth(amba_img_dsp_sharpen_both_t *MoSharpenBoth) {
+    memcpy(&GData.MoSharpenBoth, MoSharpenBoth, sizeof(GData.MoSharpenBoth));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_MO_SHARPEN_BOTH);
+}
+
+void AmbaItuner_Get_MoSharpenBoth(amba_img_dsp_sharpen_both_t *MoSharpenBoth) {
+    memcpy(MoSharpenBoth, &GData.MoSharpenBoth, sizeof(amba_img_dsp_sharpen_both_t));
+}
+
+void AmbaItuner_Set_MoSharpenNoise(amba_img_dsp_sharpen_noise_t *MoSharpenNoise) {
+    memcpy(&GData.MoSharpenNoise, MoSharpenNoise, sizeof(GData.MoSharpenNoise));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_MO_SHARPEN_NOISE);
+}
+
+void AmbaItuner_Get_MoSharpenNoise(amba_img_dsp_sharpen_noise_t *MoSharpenNoise) {
+    memcpy(MoSharpenNoise, &GData.MoSharpenNoise, sizeof(amba_img_dsp_sharpen_noise_t));
+}
+
+void AmbaItuner_Set_MoFir(amba_img_dsp_fir_t *MoFir) {
+    memcpy(&GData.MoFir, MoFir, sizeof(GData.MoFir));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_MO_FIR);
+}
+
+void AmbaItuner_Get_MoFir(amba_img_dsp_fir_t *MoFir) {
+    memcpy(MoFir, &GData.MoFir, sizeof(amba_img_dsp_fir_t));
+}
+
+void AmbaItuner_Set_MoCoring(amba_img_dsp_coring_t *MoCoring) {
+    memcpy(&GData.MoCoring, MoCoring, sizeof(GData.MoCoring));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_MO_CORING);
+}
+
+void AmbaItuner_Get_MoCoring(amba_img_dsp_coring_t *MoCoring) {
+    memcpy(MoCoring, &GData.MoCoring, sizeof(amba_img_dsp_coring_t));
+}
+
+void AmbaItuner_Set_MoCoringIndexScale(amba_img_dsp_level_t *MoCoringIndexScale) {
+    memcpy(&GData.MoCoringIndexScale, MoCoringIndexScale, sizeof(GData.MoCoringIndexScale));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_MO_CORING_INDEX_SCALE);
+}
+
+void AmbaItuner_Get_MoCoringIndexScale(amba_img_dsp_level_t *MoCoringIndexScale) {
+    memcpy(MoCoringIndexScale, &GData.MoCoringIndexScale, sizeof(amba_img_dsp_level_t));
+}
+
+void AmbaItuner_Set_MoMinCoringResult(amba_img_dsp_level_t *MoMinCoringResult) {
+    memcpy(&GData.MoMinCoringResult, MoMinCoringResult, sizeof(GData.MoMinCoringResult));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_MO_MIN_CORING_RESULT);
+}
+
+void AmbaItuner_Get_MoMinCoringResult(amba_img_dsp_level_t *MoMinCoringResult) {
+    memcpy(MoMinCoringResult, &GData.MoMinCoringResult, sizeof(amba_img_dsp_level_t));
+}
+
+void AmbaItuner_Set_MoScaleCoring(amba_img_dsp_level_t *MoScaleCoring) {
+    memcpy(&GData.MoScaleCoring, MoScaleCoring, sizeof(GData.MoScaleCoring));
+    _AmbaItuner_Set_Filter_Valid(ITUNER_MO_SCALE_CORING);
+}
+
+void AmbaItuner_Get_MoScaleCoring(amba_img_dsp_level_t *MoScaleCoring) {
+    memcpy(MoScaleCoring, &GData.MoScaleCoring, sizeof(amba_img_dsp_level_t));
+}
+
+static int _AmbaItuner_Check_Reg(ITUNER_VALID_s FILTER_ID, int Special_Use)
+{
+    int ret = 0;
+    if (_Ituner_Valid_Filter[FILTER_ID] == 1) {
+        ITUNER_DEBF("[Execute] %s", _G_Filter_Name[FILTER_ID]);
+        ret = 1;
+    } else if (_Ituner_Valid_Filter[FILTER_ID] == 0 && Special_Use == SPECIAL_USE_SKIP) {
+        ITUNER_DEBF("[Skip] %s", _G_Filter_Name[FILTER_ID]);
+    } else {
+        ITUNER_DEBF("[Without] %s", _G_Filter_Name[FILTER_ID]);
+    }
+    return ret;
+}
+/*
+static int _check_reg(REG_s *pReg, int *Rval, int SpecialUse)
+{
+    int i,tuning_mode=0;
+    INT64 Mask=0;
+    ITUNER_SYSTEM_s sys;
+
+    if (pReg == 0)
+        return 0;
+
+    if (pReg->ParamCount < 0 || pReg->ParamCount > 63)
+        Mask = -1;
+    else
+        Mask = ((INT64)1 << pReg->ParamCount) - 1;
+
+    if (pReg->Valid == Mask) {
+        AmbaPrint("[Execute] %s", pReg->Name);
+        return 1;
+    } else if (pReg->Valid == 0 && SpecialUse == SPECIAL_USE_SKIP) {
+        // for optional register, most for statistic registers
+        AmbaPrint("[Skip] %s", pReg->Name);
+        return 0;
+    } else if (((pReg->Valid & 0x1) == 1) && (strcmp(pReg->ParamList[0].Name, "enable") == 0) && SpecialUse == 0) {
+        // if current reg set enable == 0, other param will be don't care
+        AmbaPrint("[Disable] %s", pReg->Name);
+        return 1;
+    } else if (((pReg->Valid & 0x1) == 1) && (strcmp(pReg->ParamList[0].Name, "fir_strength") == 0) && SpecialUse != -1) {
+        // if current fir not manual, and only fir_strength is set
+        AmbaPrint("[Execute] %s", pReg->Name);
+        return 1;
+    }
+
+    AmbaItuner_Get_SystemInfo(&sys);
+    tuning_mode = lookup_tuning_mode(sys.TuningMode);
+    if(tuning_mode == 6) //IMG_MODE_PREVIEW do not check valid value.
+    {
+        *Rval |= -1;
+        return 0;
+    }
+
+
+    {
+        for (i = 0; i < pReg->ParamCount; i++) {
+            Mask = ((INT64)1 << i);
+            if ((pReg->Valid & Mask) == 0)
+                AmbaPrint("[Error] %s.%s not set!", pReg->Name, pReg->ParamList[i].Name);
+        }
+        *Rval |= -1;
+        return 0;
+    }
+}
+*/
+
+// Refer to WarpCompensationDzoomByPassParams
+#define WARP_COMPENSATION_WARP_CONTROL_BYPASS_INDEX 0
+#define WARP_COMPENSATION_WARP_CONTROL_BYPASS_MASK 0x1
+#define WARP_COMPENSATION_HORI_BYPASS_MASK 0x41F
+        // 0x21F = 100 0001 1111 (2)
+#define ERROR_FLAG_MASK_WARP_CONTROL_BYPASS_MASK 0x1
+
+#define WARP_COMPENSATION_VERT_WARP_ENABLE_BYPASS_INDEX 5
+#define WARP_COMPENSATION_VERT_WARP_ENABLE_BYPASS_MASK 0x20
+        // 0x20 = 10 0000 (2)
+#define WARP_COMPENSATION_VERT_BYPASS_MASK 0xBE0
+        // 0x5E0 = 1101 1110 0000 (2)
+#define ERROR_FLAG_MASK_VERT_WARP_ENABLE_BYPASS_MASK 0x2
+
+#define WARP_COMPENSATION_DZOOM_BYPASS_MASK 0x7FFF000
+        // 0x7FFF000 = 111 1111 1111 1111 0000 0000 0000 (2)
+#define ERROR_FLAG_MASK_DZOOM_BYPASS_MASK 0x4
+
+
+// Refer to ChromaAberrationByPassParams
+#define CA_HORZ_WARP_ENABLE_BYPASS_INDEX 0
+#define CA_HORZ_WARP_ENABLE_BYPASS_MASK 0x1
+#define CA_HORZ_WARP_BYPASS_MASK 0x103D
+        // 0x103D = 1 0000 0011 1101 (2)
+#define ERROR_FLAG_MASK_CA_HORZ_WARP_BYPASS_MASK 0x1
+
+#define CA_VERT_WARP_ENABLE_BYPASS_INDEX 1
+#define CA_VERT_WARP_ENABLE_BYPASS_MASK 0x2
+        // 0x2 =  10 (2)
+#define CA_VERT_WARP_BYPASS_MASK 0x23C2
+        // 0x23C2 = 10 0011 1100 0010 (2)
+#define ERROR_FLAG_MASK_CA_VERT_WARP_BYPASS_MASK 0x2
+
+#define CA_COMMON_BYPASS_MASK 0xC00
+        // 0xC00 = 1100 0000 0000 (2)
+#define ERROR_FLAG_MASK_CA_COMMON_BYPASS_MASK 0x4
+
+#define SPECIAL_USE_GENERAL    1
+// Note: SPECIAL_USE_GENERAL is used for bypass FPN and vignette function.
+
+#define SPECIAL_USE_WARP_DZOOM 2
+#define SPECIAL_USE_CAWARP     3
+
+#define BYPASS_STATUS_SKIP    0
+#define BYPASS_STATUS_EXECUTE 1
+#define BYPASS_STATUS_DISABLE 2
+#define BYPASS_STATUS_ERROR   3
+// Using _bypass_check_reg to check regs about the bypass mode function
+/*
+static int _bypass_check_reg(REG_s *pReg, int *Rval, int SpecialUse, UINT32 *pParam)
+{
+    int i,tuning_mode = 0;
+    INT64 Mask = 0;
+    ITUNER_SYSTEM_s sys;
+
+    if (pReg == 0) {
+        return BYPASS_STATUS_ERROR;
+    }
+
+    if (pReg->ParamCount < 0 || pReg->ParamCount > 63) {
+        Mask = -1;
+    } else {
+        Mask = ((INT64)1 << pReg->ParamCount) - 1;
+    }
+
+    AmbaItuner_Get_SystemInfo(&sys);
+    tuning_mode = lookup_tuning_mode(sys.TuningMode);
+
+    if (pReg->Valid == Mask) {
+        AmbaPrint("[Execute] %s", pReg->Name);
+        return BYPASS_STATUS_EXECUTE;
+    } else if (pReg->Valid == 0) {
+        // We assume that all the bypass mode functions allow skip (not exist).
+        // for optional register, most for statistic registers
+        AmbaPrint("[Skip] %s", pReg->Name);
+        return BYPASS_STATUS_SKIP;
+    } else if (((pReg->Valid & 0x1) == 1) && (strcmp(pReg->ParamList[0].Name, "enable") == 0) && SpecialUse == SPECIAL_USE_GENERAL) {
+
+        // Case: SPECIAL_USE_GENERAL means bit 0 is the only one enable/disable control for the bypass function
+        UINT8 ByPassGerenalEnable = (UINT8) *pParam;
+        if (ByPassGerenalEnable == 0) {
+            AmbaPrint("[Disable] %s", pReg->Name);
+            return BYPASS_STATUS_DISABLE;
+        }
+
+    }  else if (SpecialUse == SPECIAL_USE_WARP_DZOOM) {
+        // Special case for warp_compensation_bypass
+        // We must check warp_control(hori_warp_enable) and vert_warp_enable
+
+        UINT8 WarpCompensationBypassErrorFlag = 0;
+        UINT8 ByPassWarpControl = (UINT8) *pParam;
+        UINT8 ByPassVertWarpEnable = (UINT8) (*(pParam + 1));
+
+        // warp_control part (hori_warp_enable)
+        if ((pReg->Valid & WARP_COMPENSATION_WARP_CONTROL_BYPASS_MASK) != 0) {
+            // Caution: operator prioiry, != is higher than &
+            // This branch means that warp control (hori_warp_enable) is set.
+            if ((pReg->Valid & WARP_COMPENSATION_HORI_BYPASS_MASK) == WARP_COMPENSATION_HORI_BYPASS_MASK) {
+                // This case means that all warp control fields are set.
+                AmbaPrint("[Execute] warp_compensation_bypass horizontal part");
+            } else {
+                // This case means that warp control is set, but some fields are lost.
+                // If warp control is 0, it means disable.
+                // If warp control is not 0, it is an error case.
+                if (ByPassWarpControl == 0) {
+                    AmbaPrint("[Disable] warp_compensation_bypass horizontal part");
+                } else {
+                    AmbaPrint("[Param lost] warp_compensation_bypass horizontal part");
+                    WarpCompensationBypassErrorFlag |= ERROR_FLAG_MASK_WARP_CONTROL_BYPASS_MASK;
+                }
+            }
+        } else {
+            AmbaPrint("[Param lost] warp_compensation_bypass horizontal part");
+            WarpCompensationBypassErrorFlag |= ERROR_FLAG_MASK_WARP_CONTROL_BYPASS_MASK;
+        }
+
+        // warp_control part (hori_warp_enable) error handling
+        if ((WarpCompensationBypassErrorFlag & ERROR_FLAG_MASK_WARP_CONTROL_BYPASS_MASK) != 0) {
+            // Caution: operator prioiry, != is higher than &
+            if(tuning_mode != 6) { //Except IMG_MODE_PREVIEW, checking valid value.
+
+                for (i = 0; i < pReg->ParamCount; i++) {
+                    Mask = ((INT64)1 << i);
+                    if ((pReg->Valid & Mask) == 0 && (Mask & WARP_COMPENSATION_HORI_BYPASS_MASK) != 0) {
+                        AmbaPrint("[Error] %s.%s not set!", pReg->Name, pReg->ParamList[i].Name);
+                    }
+                }
+            }
+        }
+
+        // vert_warp_enable part
+        if ((pReg->Valid & WARP_COMPENSATION_VERT_WARP_ENABLE_BYPASS_MASK) != 0) {
+            // Caution: operator prioiry, != is higher than &
+            // This branch means that vert_warp_enable is set.
+            if ((pReg->Valid & WARP_COMPENSATION_VERT_BYPASS_MASK) == WARP_COMPENSATION_VERT_BYPASS_MASK) {
+                // This case means that all vert_warp_enable are set.
+                AmbaPrint("[Execute] warp_compensation_bypass vertical part");
+            } else {
+                // This case means that vert_warp_enable is set, but some fields are lost.
+                // If vert_warp_enable is 0, it means disable.
+                // If vert_warp_enable is not 0, it is an error case.
+                if (ByPassVertWarpEnable == 0) {
+                    AmbaPrint("[Disable] warp_compensation_bypass vertical part");
+                } else {
+                    AmbaPrint("[Param lost] warp_compensation_bypass vertical part");
+                    WarpCompensationBypassErrorFlag |= ERROR_FLAG_MASK_VERT_WARP_ENABLE_BYPASS_MASK;
+                }
+            }
+        } else {
+            AmbaPrint("[Param lost] warp_compensation_bypass vertical part");
+            WarpCompensationBypassErrorFlag |= ERROR_FLAG_MASK_VERT_WARP_ENABLE_BYPASS_MASK;
+        }
+
+        // vert_warp_enable part error handling
+        if ((WarpCompensationBypassErrorFlag & ERROR_FLAG_MASK_VERT_WARP_ENABLE_BYPASS_MASK) != 0) {
+            // Caution: operator prioiry, != is higher than &
+            if(tuning_mode != 6) { //Except IMG_MODE_PREVIEW, checking valid value.
+
+                for (i = 0; i < pReg->ParamCount; i++) {
+                    Mask = ((INT64)1 << i);
+                    if ((pReg->Valid & Mask) == 0 && (Mask & WARP_COMPENSATION_VERT_BYPASS_MASK) != 0) {
+                        AmbaPrint("[Error] %s.%s not set!", pReg->Name, pReg->ParamList[i].Name);
+                    }
+                }
+            }
+        }
+
+        // dzoom part, all the param shall be set.
+        if ((pReg->Valid & WARP_COMPENSATION_DZOOM_BYPASS_MASK) == WARP_COMPENSATION_DZOOM_BYPASS_MASK) {
+            AmbaPrint("[Execute] warp_compensation_bypass dzoom part");
+        } else {
+            AmbaPrint("[Param lost] warp_compensation_bypass dzoom part");
+            WarpCompensationBypassErrorFlag |= ERROR_FLAG_MASK_DZOOM_BYPASS_MASK;
+        }
+
+        // dzoom part error handling
+        if ((WarpCompensationBypassErrorFlag & ERROR_FLAG_MASK_DZOOM_BYPASS_MASK) != 0) {
+            // Caution: operator prioiry, != is higher than &
+            if(tuning_mode != 6) { //Except IMG_MODE_PREVIEW, checking valid value.
+                for (i = 0; i < pReg->ParamCount; i++) {
+                    Mask = ((INT64)1 << i);
+                    if ( ((pReg->Valid & Mask) == 0) && ((Mask & WARP_COMPENSATION_DZOOM_BYPASS_MASK) != 0)) {
+                        // Caution: operator prioiry, != is higher than &
+                        AmbaPrint("[Error] %s.%s not set!", pReg->Name, pReg->ParamList[i].Name);
+                    }
+                }
+            }
+        }
+
+        // After checking warp_control part, vert_warp_enable part and dzoom part, judge that it's executable or not.
+        if (WarpCompensationBypassErrorFlag == 0) {
+            AmbaPrint("[Execute] %s", pReg->Name);
+            return BYPASS_STATUS_EXECUTE;
+        } else {
+            *Rval |= -1;
+            return BYPASS_STATUS_ERROR;
+        }
+
+    } else if (SpecialUse == SPECIAL_USE_CAWARP) {
+        // strcmp(pReg->Name, "chromatic_aberration_correction_bypass") == 0
+        // Special case forchromatic_aberration_correction_bypass
+
+        UINT8  CaWarpBypassErrorFlag = 0;
+        UINT16 ByPassHorzCaWarpEnable = (UINT16) *pParam;
+        UINT16 ByPassVertCaWarpEnable = (UINT16) (*(pParam + 1));
+
+        // Horizontal part
+        if ((pReg->Valid & CA_HORZ_WARP_ENABLE_BYPASS_MASK) != 0) {
+            // Caution: operator prioiry, != is higher than &
+            // This branch means that horz_warp_enable is set. horz_warp_enable is the field name of CaWarp in A7L.
+            if ((pReg->Valid & CA_HORZ_WARP_BYPASS_MASK) == CA_HORZ_WARP_BYPASS_MASK) {
+                // This case means that all fields in horizontal part are set.
+                AmbaPrint("[Execute] chromatic_aberration_correction_bypass horizontal part");
+            } else {
+                // This case means that ByPassHorzCaWarpEnable (horz_warp_enable) is set, but some fields are lost.
+                // If ByPassHorzCaWarpEnable (horz_warp_enable) is 0, it means disable.
+                // If ByPassHorzCaWarpEnable (horz_warp_enable) is not 0, it is an error case.
+                if (ByPassHorzCaWarpEnable == 0) {
+                    AmbaPrint("[Disable] chromatic_aberration_correction_bypass horizontal part");
+                } else {
+                    AmbaPrint("[Param lost] chromatic_aberration_correction_bypass horizontal part");
+                    CaWarpBypassErrorFlag |= ERROR_FLAG_MASK_CA_HORZ_WARP_BYPASS_MASK;
+                }
+            }
+        } else {
+            AmbaPrint("[Param lost] chromatic_aberration_correction_bypass horizontal part");
+            CaWarpBypassErrorFlag |= ERROR_FLAG_MASK_CA_HORZ_WARP_BYPASS_MASK;
+        }
+
+        // Horizontal part error handling
+        if ((CaWarpBypassErrorFlag & ERROR_FLAG_MASK_CA_HORZ_WARP_BYPASS_MASK) != 0) {
+            // Caution: operator prioiry, != is higher than &
+            if(tuning_mode != 6) { //Except IMG_MODE_PREVIEW, checking valid value.
+
+                for (i = 0; i < pReg->ParamCount; i++) {
+                    Mask = ((INT64)1 << i);
+                    if ((pReg->Valid & Mask) == 0 && (Mask & CA_HORZ_WARP_BYPASS_MASK) != 0) {
+                        AmbaPrint("[Error] %s.%s not set!", pReg->Name, pReg->ParamList[i].Name);
+                    }
+                }
+            }
+        }
+
+        // Vertical part
+        if ((pReg->Valid & CA_VERT_WARP_ENABLE_BYPASS_MASK) != 0) {
+            // Caution: operator prioiry, != is higher than &
+            // This branch means that vert_warp_enable is set. vert_warp_enable is the field name of CaWarp in A7L.
+            if ((pReg->Valid & CA_VERT_WARP_BYPASS_MASK) == CA_VERT_WARP_BYPASS_MASK) {
+                // This case means that all fields in vertical part are set.
+                AmbaPrint("[Execute] chromatic_aberration_correction_bypass vertical part");
+            } else {
+                // This case means that ByPassVertCaWarpEnable (vert_warp_enable) is set, but some fields are lost.
+                // If ByPassVertCaWarpEnable (vert_warp_enable) is 0, it means disable.
+                // If ByPassVertCaWarpEnable (vert_warp_enable) is not 0, it is an error case.
+                if (ByPassVertCaWarpEnable == 0) {
+                    AmbaPrint("[Disable] chromatic_aberration_correction_bypass vertical part");
+                } else {
+                    AmbaPrint("[Param lost] chromatic_aberration_correction_bypass vertical part");
+                    CaWarpBypassErrorFlag |= ERROR_FLAG_MASK_CA_VERT_WARP_BYPASS_MASK;
+                }
+            }
+        } else {
+            AmbaPrint("[Param lost] chromatic_aberration_correction_bypass vertical part");
+            CaWarpBypassErrorFlag |= ERROR_FLAG_MASK_CA_VERT_WARP_BYPASS_MASK;
+        }
+
+        // Vertical part error handling
+        if ((CaWarpBypassErrorFlag & ERROR_FLAG_MASK_CA_VERT_WARP_BYPASS_MASK) != 0) {
+            // Caution: operator prioiry, != is higher than &
+            if(tuning_mode != 6) { //Except IMG_MODE_PREVIEW, checking valid value.
+
+                for (i = 0; i < pReg->ParamCount; i++) {
+                    Mask = ((INT64)1 << i);
+                    if ((pReg->Valid & Mask) == 0 && (Mask & CA_VERT_WARP_BYPASS_MASK) != 0) {
+                        AmbaPrint("[Error] %s.%s not set!", pReg->Name, pReg->ParamList[i].Name);
+                    }
+                }
+            }
+        }
+
+        // Check common part, anyone of CaWarp is enable, we must check.
+        if ((ByPassHorzCaWarpEnable != 0) || (ByPassVertCaWarpEnable != 0)) {
+
+            if ((pReg->Valid & CA_COMMON_BYPASS_MASK) == CA_COMMON_BYPASS_MASK) {
+                AmbaPrint("[Execute] chromatic_aberration_correction_bypass common part");
+                AmbaPrint("[Execute] %s", pReg->Name);
+            } else {
+                AmbaPrint("[Param lost] chromatic_aberration_correction_bypass common part");
+                CaWarpBypassErrorFlag |= ERROR_FLAG_MASK_CA_COMMON_BYPASS_MASK;
+            }
+
+            // common part error handling
+            if ((CaWarpBypassErrorFlag & ERROR_FLAG_MASK_CA_COMMON_BYPASS_MASK) != 0) {
+                // Caution: operator prioiry, != is higher than &
+                if(tuning_mode != 6) { //Except IMG_MODE_PREVIEW, checking valid value.
+                    for (i = 0; i < pReg->ParamCount; i++) {
+                        Mask = ((INT64)1 << i);
+                        if ( ((pReg->Valid & Mask) == 0) && ((Mask & CA_COMMON_BYPASS_MASK) != 0)) {
+                            // Caution: operator prioiry, != is higher than &
+                            AmbaPrint("[Error] %s.%s not set!", pReg->Name, pReg->ParamList[i].Name);
+                        }
+                    }
+                }
+            }
+        } else if ((ByPassHorzCaWarpEnable == 0) && (ByPassVertCaWarpEnable == 0)) {
+            AmbaPrint("[Disable] chromatic_aberration_correction_bypass");
+        }
+
+        // After checking horizontal part, vertical part and common part, judge that it's executable or not.
+        if (CaWarpBypassErrorFlag == 0) {
+            return BYPASS_STATUS_EXECUTE;
+        } else {
+            *Rval |= -1;
+            return BYPASS_STATUS_ERROR;
+        }
+
+    }
+
+
+    if(tuning_mode == 6) //IMG_MODE_PREVIEW do not check valid value.
+    {
+        *Rval |= -1;
+        return BYPASS_STATUS_ERROR;
+    }
+
+    {
+        for (i = 0; i < pReg->ParamCount; i++) {
+            Mask = ((INT64)1 << i);
+            if ((pReg->Valid & Mask) == 0)
+                AmbaPrint("[Error] %s.%s not set!", pReg->Name, pReg->ParamList[i].Name);
+        }
+        *Rval |= -1;
+        return BYPASS_STATUS_ERROR;
+    }
+}
+*/
+//===============image algo======================//
+#define WB_DGAIN_UNIT           4096
+
+
+/* //TBD
+static int _load_vignette_file(const char *filename, idsp_vignette_info_t *vig_info)
+{
+    AMBA_FS_FILE *fid;
+    char uni_fname[64];
+    char f_mode[3] = {'r','\0'};
+    int size = 33*33*sizeof(UINT16);
+    int rval = -1;
+    asc_to_uni(filename, uni_fname);
+    fid = AmbaFS_fopen(uni_fname, f_mode);
+    do {
+        if (fid == 0) {
+            AmbaPrint("[Error] Vignette file open fails!");
+            rval = -1;
+            break;
+        }
+        if (AmbaFS_fread((void*)vig_info->vignette_red_gain_addr, size, 1, fid) != 1) {
+            AmbaPrint("[Error] Vignette file read error!");
+            rval = -1;
+            break;
+        }
+        if (AmbaFS_fread((void*)vig_info->vignette_green_even_gain_addr, size, 1, fid) != 1) {
+            AmbaPrint("[Error] Vignette file read error!");
+            rval = -1;
+            break;
+        }
+        if (AmbaFS_fread((void*)vig_info->vignette_green_odd_gain_addr, size, 1, fid) != 1) {
+            AmbaPrint("[Error] Vignette file read error!");
+            rval = -1;
+            break;
+        }
+        if (AmbaFS_fread((void*)vig_info->vignette_blue_gain_addr, size, 1, fid) != 1) {
+            AmbaPrint("[Error] Vignette file read error!");
+            rval = -1;
+            break;
+        }
+        rval = 0;
+    } while (0);
+    AmbaFS_fclose(fid);
+    return 0;
+}
+
+static int _save_vignette_file(const char *filename, idsp_vignette_info_t *vig_info)
+{
+    AMBA_FS_FILE *fid;
+    char uni_fname[64];
+    char f_mode[3] = {'w','\0'};
+    int size = 33*33*sizeof(UINT16);
+    int rval = -1;
+    asc_to_uni(filename, uni_fname);
+    fid = AmbaFS_fopen(uni_fname, f_mode);
+    do {
+        if (fid == 0) {
+            AmbaPrint("[Error] Vignette file open fails!");
+            rval = -1;
+            break;
+        }
+        if (AmbaFS_fwrite(vig_info->vignette_red_gain_addr, size, 1, fid) != 1) {
+            AmbaPrint("[Error] Vignette file write error!");
+            rval = -1;
+            break;
+        }
+        if (AmbaFS_fwrite(vig_info->vignette_green_even_gain_addr, size, 1, fid) != 1) {
+            AmbaPrint("[Error] Vignette file write error!");
+            rval = -1;
+            break;
+        }
+        if (AmbaFS_fwrite(vig_info->vignette_green_odd_gain_addr, size, 1, fid) != 1) {
+            AmbaPrint("[Error] Vignette file write error!");
+            rval = -1;
+            break;
+        }
+        if (AmbaFS_fwrite(vig_info->vignette_blue_gain_addr, size, 1, fid) != 1) {
+            AmbaPrint("[Error] Vignette file write error!");
+            rval = -1;
+            break;
+        }
+        rval = 0;
+    } while (0);
+    AmbaFS_fclose(fid);
+    return rval;
+}
+*/
+/*
+static int _get_file_size(char *FileName)
+{
+
+    AMBA_FS_STAT TmpStat;
+
+    if (AmbaFS_Stat(FileName, &TmpStat) == OK) {
+        return TmpStat.Size;
+    } else {
+        AmbaPrint("[Error] _get_file_size failed!");
+        return -1;
+    }
+}
+*/
+/*
+static int _load_ext_file(char *FileName, int Size, void *Buf)
+{
+    AMBA_FS_FILE *Fid;
+    char UniFname[64];
+    char Fmode[5] = {'r','\0'};
+
+    check_ituner_system_drive(FileName);
+    asc_to_uni(FileName, UniFname);
+    Fid = AmbaFS_fopen(UniFname, Fmode);
+    if (Fid == 0) {
+        AmbaPrint("[Error] Ext file open fails! %s", FileName);
+        return -1;
+    }
+    if (AmbaFS_fread(Buf, Size, 1, Fid)) {
+        AmbaFS_fclose(Fid);
+        return 0;
+    } else {
+        AmbaPrint("[Error] Ext file read error!");
+        AmbaFS_fclose(Fid);
+        return -2;
+    }
+}
+*/
+/*
+static int _save_ext_file(const char *FileName, int Size, void *Buf)
+{
+    AMBA_FS_FILE *Fid;
+    char UniFname[64];
+    char Fmode[5] = {'w','\0'};
+    asc_to_uni(FileName, UniFname);
+    Fid = AmbaFS_fopen(UniFname, Fmode);
+    if (Fid == 0) {
+        AmbaPrint("[Error] Ext file open fails!");
+        return -1;
+    }
+    if (AmbaFS_fwrite(Buf, Size, 1, Fid)) {
+        AmbaFS_fclose(Fid);
+        return 0;
+    } else {
+        AmbaPrint("[Error] Ext file write error!");
+        AmbaFS_fclose(Fid);
+        return -1;
+    }
+}
+*/
+/*
+static void _build_ext_file_name(const char *Src, char *Dst, char *PostFix, char *Ext)
+{
+    char Buf[64];//, *Token;
+    strcpy(Buf, Src);
+    //Token = strtok(Buf, ".");
+    strcat(Buf, PostFix);
+    strcat(Buf, Ext);
+    strcpy(Dst, Buf);
+}
+*/
+/*
+int ituner_build_header(const char *raw_path, const char *cfg_path, postproc_info_t *info)
+{
+    int mode = _Ituner.tuning_mode;
+    vin_status_t vin_status={0};
+    postproc_info_t _info;
+
+    _set_reglist_valid(1);
+    //AMP_img_sensor_cmd(MW_IMG_GET_VIDEO_INPUT_STATUS, &vin_status, 0);  //TBD
+
+    // A7 does not support FAST MODE, it will use LOW ISO instead
+    // so if system try to dump FAST MODE config, dump LOW ISO instead
+    if (mode == IMG_MODE_STILL)
+        mode = IMG_MODE_LOW_ISO_STILL;
+
+    strcpy(_System.AmbacamRev, "2.2.0");
+    strcpy(_System.ChipRev, "A9");
+    strcpy(_System.SensorId, "MT9J001_ID");
+    strcpy(_System.UserMode, "Normal");
+    strcpy(_System.TuningMode, _str_tuning_mode[mode]);
+    strcpy(_System.TuningModeExt, _str_tuning_mode_ext[_Ituner.tuning_mode_ext]);
+    strcpy(_System.RawPath, raw_path);
+    if (_Ituner.tuning_mode_ext != SINGLE_SHOT) {
+        char ext_file_path[64];
+        _System.RawPath[0] = '\0';
+        strcpy(ext_file_path, cfg_path);
+        strtok(ext_file_path, ".");
+        strcat(ext_file_path, "_ext_cfg.txt");
+        strcpy(_System.ExtConfigPath, ext_file_path);
+    } else {
+        _System.ExtConfigPath[0] = '\0';
+    }
+    if (info == NULL) {
+        if (_is_video_mode(mode)) {
+            _info.src_raw_width = vin_status.vidcap_w;
+            _info.src_raw_height = vin_status.vidcap_h;
+            //raw_pitch should be 32-bytes aligment
+            _info.src_raw_pitch = ((_info.src_raw_width+15)>>4)<<5;
+            _info.src_y_width = _info.src_raw_width;
+            _info.src_y_height = _info.src_raw_height;
+        } else {
+            _info.src_raw_width = vin_status.stillcap_w;
+            _info.src_raw_height = vin_status.stillcap_h;
+            //raw_pitch should be 32-bytes aligment
+            _info.src_raw_pitch = ((_info.src_raw_width+15)>>4)<<5;
+            _info.src_y_width = _info.src_raw_width;
+            _info.src_y_height = _info.src_raw_height;
+        }
+    } else {
+        _info = *info;
+    }
+    _System.RawWidth = _info.src_raw_width;
+    _System.RawHeight = _info.src_raw_height;
+    _System.RawPitch = _info.src_raw_pitch;
+    _System.MainWidth = _info.src_y_width;
+    _System.MainHeight = _info.src_y_height;
+    _System.RawResolution = 14;//vin_status.bit_resolution;
+    _System.RawBayer = vin_status.bayer_pattern;
+    _System.InputPicCnt = 1;
+    _System.SensorReadoutMode = vin_status.sensor_readout_mode;
+    if (_Ituner.tuning_mode_ext == MULTI_SHOT_MF_HISO) {
+        _System.InputPicCnt = 6;
+        _System.RawHeight = ((_info.src_raw_height+15)>>4)<<4;
+    } else if (_Ituner.tuning_mode_ext == MULTI_SHOT_MAHDR) {
+        _System.InputPicCnt = 4;
+    }
+
+    if ( _System.RawPitch < 2 * _System.RawWidth) {
+        _System.CompressedRaw = 1;
+    } else {
+        _System.CompressedRaw = 0;
+    }
+
+    if ((_System.RawPitch != 2 * _System.RawWidth) && (_System.CompressedRaw != 1)) {
+        int pitch = (((_System.RawWidth) * 2 + 31) >> 5) << 5;
+        AmbaPrint("Warning: DSP returned pitch value is wrong %d (DSP report) vs %d", info->src_raw_pitch, pitch);
+    }
+
+    if (_Ituner.tuning_mode == 4) {
+        _System.RawPath[0] = '\0';
+        _System.RawPitch = _System.RawWidth;
+        _System.CompressedRaw = 0;
+    }
+    //NOTE: internal REG will not be exposed
+    return 0;
+}
+*/
+
+
+/* iTuner external API */
+int AmbaItuner_Init(AmbaItuner_Config_t *Config)
+{
+    memcpy(&Ituner_Hook_Func, &Config->Hook_Func, sizeof(Ituner_Hook_Func));
+    _AmbaItuner_Internal_Init();
+    _AmbaItuner_System_Init();
+    _AmbaItuner_GData_Init();
+    return 0;
+}
+
+int AmbaItuner_Execute(int fd_iav, amba_img_dsp_mode_cfg_t Mode, AMBA_ITUNER_PROC_INFO_s *ProcInfo)
+{
+    ITUNER_DEBF("%s() %d, Execute", __func__, __LINE__);
+    if (!_AmbaItuner_Is_Video_Preview_Tuning()) {
+        if (_AmbaItuner_Check_Filter(Mode) != 0) {
+            ITUNER_WARF("%s() %d, call _AmbaItuner_Check_Filter() Fail\n", __func__, __LINE__);
+            return -1;
+        }
+    }
+
+    int Ret = 0;
+    Ituner_Ext_File_Param_s Ext_File_Param;
+    UINT32 RawWidth;
+    UINT32 RawHeight;
+    UINT32 MainWidth;
+    UINT32 MainHeight;
+    UINT32 RawStartX;
+    UINT32 RawStartY;
+    UINT8 HSubSampleFactorNum, HSubSampleFactorDen, VSubSampleFactorNum, VSubSampleFactorDen;
+    amba_img_dsp_size_info_t SizeInfo;
+    do {
+        amba_img_img_set_diag_case_id(&Mode, _Internal.DiagMode);
+        if (0/*Mode.Pipe == AMBA_DSP_IMG_PIPE_VIDEO*/) {
+//            IMG_IDSP_CONFIG_INFO_s IMG_IDSP_CONFIG_INFO;
+//            extern int AmbaDSP_GetIdspCfgInfo(void *pCfgInfo);
+            RawStartX = 0;
+            RawStartY = 0;
+            HSubSampleFactorNum = 1;
+            HSubSampleFactorDen = 1;
+            VSubSampleFactorNum = 1;
+            VSubSampleFactorDen = 1;
+//            AmbaDSP_GetIdspCfgInfo((void*)&IMG_IDSP_CONFIG_INFO);
+            RawWidth  = 1920;//IMG_IDSP_CONFIG_INFO.VCapWin.Width;
+            RawHeight = 1080;//IMG_IDSP_CONFIG_INFO.VCapWin.Height;
+            MainWidth  = 1920;//IMG_IDSP_CONFIG_INFO.EncWin.Width;
+            MainHeight = 1080;//IMG_IDSP_CONFIG_INFO.EncWin.Height;
+        } else {
+            RawStartX = _System.RawStartX;
+            RawStartY = _System.RawStartY;
+            HSubSampleFactorNum = _System.HSubSampleFactorNum;
+            HSubSampleFactorDen = _System.HSubSampleFactorDen;
+            VSubSampleFactorNum = _System.VSubSampleFactorNum;
+            VSubSampleFactorDen = _System.VSubSampleFactorDen;
+            RawWidth = _System.RawWidth;
+            RawHeight = _System.RawHeight;
+            MainWidth = _System.MainWidth;
+            MainHeight = _System.MainHeight;
+        }
+        ITUNER_DEBF("%s() %d Ituner RawWidth = %d RawHeight = %d MainWidth = %d MainHeight = %d", __func__, __LINE__, RawWidth,RawHeight,MainWidth,MainHeight);
+
+        SizeInfo.WidthIn = RawWidth;
+        SizeInfo.HeightIn= RawHeight;
+        SizeInfo.WidthMain= MainWidth;
+        SizeInfo.HeightMain= MainHeight;
+        CHECK_RET(0, amba_img_dsp_set_size_info(&Mode, &SizeInfo));
+        {
+            extern int amba_img_dsp_set_static_bad_pixel_correction_highlight_mode( amba_img_dsp_mode_cfg_t *Mode, UINT8 *pSbpHighligh);
+            if (_Internal.FpnHighlight != -1) {
+                UINT8 FpnHighlight = (UINT8)_Internal.FpnHighlight;
+                CHECK_RET(0,  amba_img_dsp_set_static_bad_pixel_correction_highlight_mode(&Mode, &FpnHighlight));
+            }
+        }
+/*        if (_AmbaItuner_Check_Reg(ITUNER_AE_STATISTICS_INFO, SPECIAL_USE_SKIP)) {
+            CHECK_RET(0, AmbaDSP_Img3aSetAeStatInfo(&Mode, &GData.AeStatisticsInfo));
+        }
+        if (_AmbaItuner_Check_Reg(ITUNER_AWB_STATISTICS_INFO, SPECIAL_USE_SKIP)) {
+            CHECK_RET(0,  AmbaDSP_Img3aSetAwbStatInfo(&Mode, &GData.AwbStatisticsInfo));
+        }
+        if (_AmbaItuner_Check_Reg(ITUNER_AF_STATISTICS_INFO, SPECIAL_USE_SKIP)) {
+            CHECK_RET(0,  AmbaDSP_Img3aSetAfStatInfo(&Mode, &GData.AfStatisticsInfo));
+        }
+*/
+        //if (Mode.Pipe != AMBA_DSP_IMG_PIPE_VIDEO) {
+            memset(&GData.SensorInfo, 0x0, sizeof(amba_img_dsp_sensor_info_t));
+            CHECK_RET(0,  amba_img_dsp_get_vin_sensor_info(&Mode, &GData.SensorInfo));
+            //temp for now
+            GData.SensorInfo.SensorID = 0;
+            GData.SensorInfo.NumFieldsPerFormat = 1;
+            GData.SensorInfo.SensorResolution = _System.RawResolution;
+            GData.SensorInfo.SensorPattern = _System.RawBayer;
+            GData.SensorInfo.SensorReadOutMode = _System.SensorReadoutMode;
+            if (_AmbaItuner_Check_Reg(ITUNER_SENSOR_INFO, SPECIAL_USE_SKIP)) {
+                GData.SensorInfo.SensorReadOutMode = GData.SensorInputInfo.ReadoutMode;
+            }
+            CHECK_RET(0,  amba_img_dsp_set_vin_sensor_info(&Mode, &GData.SensorInfo));
+        //}
+        if (_AmbaItuner_Check_Reg(ITUNER_STATIC_BAD_PIXEL_CORRECTION_BY_PASS, SPECIAL_USE_NONE)) {
+            if (GData.StaticBadPixelCorrectionByPass.Enable) {
+                GData.SbpCorrByPass.Enable = GData.StaticBadPixelCorrectionByPass.Enable;
+                GData.SbpCorrByPass.PixelMapWidth = GData.StaticBadPixelCorrectionByPass.PixelMapWidth;
+                GData.SbpCorrByPass.PixelMapHeight = GData.StaticBadPixelCorrectionByPass.PixelMapHeight;
+                GData.SbpCorrByPass.PixelMapPitch = GData.StaticBadPixelCorrectionByPass.PixelMapPitch;
+                {
+                    memset(&Ext_File_Param, 0x0, sizeof(Ext_File_Param));
+                    Ext_File_Param.Bypass_FPN_MAP_Ext_Load_Param.Address = FPNMap;
+                    Ext_File_Param.Bypass_FPN_MAP_Ext_Load_Param.Size = ITUNER_CAL_BYPASS_FPN_MAP_SIZE(GData.StaticBadPixelCorrectionByPass.PixelMapPitch, GData.StaticBadPixelCorrectionByPass.PixelMapHeight);
+                    if (Ituner_Hook_Func.Load_Data(EXT_FILE_BYPASS_FPN_MAP, &Ext_File_Param) < 0) {
+                        ITUNER_WARF("%s() %d, call Ituner_Hook_Func.Load_Data(EXT_FILE_BYPASS_FPN_MAP) Fail", __func__, __LINE__);
+                    }
+                }
+                GData.SbpCorrByPass.pMap = FPNMap;
+            } else {
+                GData.SbpCorrByPass.Enable = 0;
+            }
+            extern int amba_img_dsp_set_static_bad_pixel_correction_bypass(int fd_iav, amba_img_dsp_mode_cfg_t *Mode,AMBA_DSP_IMG_BYPASS_SBP_INFO_s *pSbpCorrByPass);
+            CHECK_RET(0,  amba_img_dsp_set_static_bad_pixel_correction_bypass(fd_iav, &Mode, &GData.SbpCorrByPass));
+
+        } else {
+            if (_AmbaItuner_Check_Reg(ITUNER_STATIC_BAD_PIXEL_CORRECTION, GData.StaticBadPixelCorrection.Enable)) {
+                if (GData.StaticBadPixelCorrection.Enable) {
+                    GData.SbpCorr.CurrentVinSensorGeo.StartX = _System.RawStartX;
+                    GData.SbpCorr.CurrentVinSensorGeo.StartY = _System.RawStartY;
+                    GData.SbpCorr.CurrentVinSensorGeo.HSubSample.FactorNum = _System.HSubSampleFactorNum;
+                    GData.SbpCorr.CurrentVinSensorGeo.HSubSample.FactorDen = _System.HSubSampleFactorDen;
+                    GData.SbpCorr.CurrentVinSensorGeo.VSubSample.FactorNum = _System.VSubSampleFactorNum;
+                    GData.SbpCorr.CurrentVinSensorGeo.VSubSample.FactorDen = _System.VSubSampleFactorDen;
+                    GData.SbpCorr.CurrentVinSensorGeo.Width = _System.RawWidth;
+                    GData.SbpCorr.CurrentVinSensorGeo.Height = _System.RawHeight;
+                    GData.SbpCorr.Enb = GData.StaticBadPixelCorrection.Enable;
+                    GData.SbpCorr.CalibSbpInfo.Version = GData.StaticBadPixelCorrection.CalibVersion;
+                    GData.SbpCorr.CalibSbpInfo.VinSensorGeo.StartX = GData.StaticBadPixelCorrection.CailbVinStartX;
+                    GData.SbpCorr.CalibSbpInfo.VinSensorGeo.StartY = GData.StaticBadPixelCorrection.CailbVinStartY;
+                    GData.SbpCorr.CalibSbpInfo.VinSensorGeo.Width = GData.StaticBadPixelCorrection.CailbVinWidth;
+                    GData.SbpCorr.CalibSbpInfo.VinSensorGeo.Height = GData.StaticBadPixelCorrection.CailbVinHeight;
+                    GData.SbpCorr.CalibSbpInfo.VinSensorGeo.HSubSample.FactorNum = GData.StaticBadPixelCorrection.CailbVinHSubSampleFactorNum;
+                    GData.SbpCorr.CalibSbpInfo.VinSensorGeo.HSubSample.FactorDen = GData.StaticBadPixelCorrection.CailbVinHSubSampleFactorDen;
+                    GData.SbpCorr.CalibSbpInfo.VinSensorGeo.VSubSample.FactorNum = GData.StaticBadPixelCorrection.CailbVinVSubSampleFactorNum;
+                    GData.SbpCorr.CalibSbpInfo.VinSensorGeo.VSubSample.FactorDen = GData.StaticBadPixelCorrection.CailbVinVSubSampleFactorDen;
+                    GData.SbpCorr.CalibSbpInfo.SbpBuffer = FPNMap;
+                    // Note: Load Ext FPN Map
+                    memset(&Ext_File_Param, 0x0, sizeof(Ext_File_Param));
+                    Ext_File_Param.FPN_MAP_Ext_Load_Param.Address = GData.SbpCorr.CalibSbpInfo.SbpBuffer;
+                    Ext_File_Param.FPN_MAP_Ext_Load_Param.Size = ITUNER_CAL_FPN_MAP_SIZE(GData.StaticBadPixelCorrection.CailbVinWidth, GData.StaticBadPixelCorrection.CailbVinHeight);
+                    Ext_File_Param.FPN_MAP_Ext_Load_Param.Size = (Ext_File_Param.FPN_MAP_Ext_Load_Param.Size > sizeof(FPNMap)) ? sizeof(FPNMap) : Ext_File_Param.FPN_MAP_Ext_Load_Param.Size;
+                    if (Ituner_Hook_Func.Load_Data(EXT_FILE_FPN_MAP, &Ext_File_Param) < 0) {
+                        ITUNER_WARF("%s() %d, call Ituner_Hook_Func.Load_Data(EXT_FILE_FPN_MAP) Fail", __func__, __LINE__);
+                    }
+                } else {
+                    GData.SbpCorr.Enb = 0;
+                }
+                CHECK_RET(0,  amba_img_dsp_set_static_bad_pixel_correction(fd_iav, &Mode, &GData.SbpCorr));
+            }
+
+        }
+        if (_AmbaItuner_Check_Reg(ITUNER_VIGNETTE_COMPENSATION_BY_PASS, SPECIAL_USE_NONE)) {
+            if (GData.VignetteCompensationByPass.Enable) {
+                GData.VignetteByPass.Enable = GData.VignetteCompensationByPass.Enable;
+                GData.VignetteByPass.GainShift = GData.VignetteCompensationByPass.GainShift;
+                // There are four 33x33 vignette tables. Each data uses '2' bytes.
+                // Caution: A7L uses 33x33 vignette table, but A9 uses 65*49 vignette table.
+                GData.VignetteByPass.pRedGain = (UINT16 *)(VignetteTable + (ITUNER_BYPASS_VIGNETTE_GAIN_MAP_SIZE * 0));
+                GData.VignetteByPass.pGreenEvenGain = (UINT16 *)(VignetteTable + (ITUNER_BYPASS_VIGNETTE_GAIN_MAP_SIZE * 1));
+                GData.VignetteByPass.pGreenOddGain = (UINT16 *)(VignetteTable + (ITUNER_BYPASS_VIGNETTE_GAIN_MAP_SIZE * 2));
+                GData.VignetteByPass.pBlueGain = (UINT16 *)(VignetteTable + (ITUNER_BYPASS_VIGNETTE_GAIN_MAP_SIZE * 3));
+                // Note: Load Bypass Vignette Gain Table
+                memset(&Ext_File_Param, 0x0, sizeof(Ext_File_Param));
+                Ext_File_Param.Bypass_Vignette_Gain_Load_Param.Address = VignetteTable;
+                Ext_File_Param.Bypass_Vignette_Gain_Load_Param.Size = ITUNER_BYPASS_VIGNETTE_GAIN_MAP_SIZE * 4;
+                if (Ituner_Hook_Func.Load_Data(EXT_FILE_BYPASS_VIGNETTE_GAIN, &Ext_File_Param) < 0) {
+                    ITUNER_WARF("%s() %d, call Ituner_Hook_Func.Load_Data(EXT_FILE_BYPASS_VIGNETTE_GAIN) Fail", __func__, __LINE__);
+                }
+            } else {
+                GData.VignetteByPass.Enable = 0;
+                GData.VignetteByPass.GainShift = 0;
+            }
+            extern int amba_img_dsp_set_vignette_compensation_bypass(int fd_iav, amba_img_dsp_mode_cfg_t *Mode, AMBA_DSP_IMG_BYPASS_VIGNETTE_INFO_s *pVigCorrByPass);
+            // Non-released API, we use extern and avoid that the API is used through header file.
+            CHECK_RET(0,  amba_img_dsp_set_vignette_compensation_bypass(fd_iav, &Mode, &GData.VignetteByPass));
+        } else {
+            if (_AmbaItuner_Check_Reg(ITUNER_VIGNETTE_COMPENSATION, GData.VignetteCompensation.Enable)) {
+                if (GData.VignetteCompensation.Enable) {
+                GData.VignetteCalcInfo.Enb = GData.VignetteCompensation.Enable;
+                GData.VignetteCalcInfo.GainShift = GData.VignetteCompensation.GainShift;
+                GData.VignetteCalcInfo.VigStrength = GData.VignetteCompensation.Strength;
+                GData.VignetteCalcInfo.CurrentVinSensorGeo.StartX = (GData.VignetteCompensation.CalibVinWidth - RawWidth)>>1;
+                GData.VignetteCalcInfo.CurrentVinSensorGeo.StartY = (GData.VignetteCompensation.CalibVinHeight - RawHeight)>>1;
+                GData.VignetteCalcInfo.CurrentVinSensorGeo.Width = RawWidth;
+                GData.VignetteCalcInfo.CurrentVinSensorGeo.Height = RawHeight;
+                GData.VignetteCalcInfo.CurrentVinSensorGeo.HSubSample.FactorNum = HSubSampleFactorNum;
+                GData.VignetteCalcInfo.CurrentVinSensorGeo.HSubSample.FactorDen = HSubSampleFactorDen;
+                GData.VignetteCalcInfo.CurrentVinSensorGeo.VSubSample.FactorNum = VSubSampleFactorNum;
+                GData.VignetteCalcInfo.CurrentVinSensorGeo.VSubSample.FactorDen = VSubSampleFactorDen;
+                GData.VignetteCalcInfo.CalibVignetteInfo.Version = GData.VignetteCompensation.CalibVersion;
+                GData.VignetteCalcInfo.CalibVignetteInfo.TableWidth = GData.VignetteCompensation.CalibTableWidth;
+                GData.VignetteCalcInfo.CalibVignetteInfo.TableHeight = GData.VignetteCompensation.CalibTableHeight;
+                GData.VignetteCalcInfo.CalibVignetteInfo.CalibVinSensorGeo.StartX = GData.VignetteCompensation.CalibVinStartX;
+                GData.VignetteCalcInfo.CalibVignetteInfo.CalibVinSensorGeo.StartY = GData.VignetteCompensation.CalibVinStartY;
+                GData.VignetteCalcInfo.CalibVignetteInfo.CalibVinSensorGeo.Width = GData.VignetteCompensation.CalibVinWidth;
+                GData.VignetteCalcInfo.CalibVignetteInfo.CalibVinSensorGeo.Height = GData.VignetteCompensation.CalibVinHeight;
+                GData.VignetteCalcInfo.CalibVignetteInfo.CalibVinSensorGeo.HSubSample.FactorNum    = GData.VignetteCompensation.CailbVinHSubSampleFactorNum;
+                GData.VignetteCalcInfo.CalibVignetteInfo.CalibVinSensorGeo.HSubSample.FactorDen = GData.VignetteCompensation.CailbVinHSubSampleFactorDen;
+                GData.VignetteCalcInfo.CalibVignetteInfo.CalibVinSensorGeo.VSubSample.FactorNum = GData.VignetteCompensation.CailbVinVSubSampleFactorNum;
+                GData.VignetteCalcInfo.CalibVignetteInfo.CalibVinSensorGeo.VSubSample.FactorDen = GData.VignetteCompensation.CailbVinVSubSampleFactorDen;
+                GData.VignetteCalcInfo.CalibVignetteInfo.pVignetteRedGain = (UINT16 *)(VignetteTable       + (ITUNER_VIGNETTE_GAIN_MAP_SIZE*0));
+                GData.VignetteCalcInfo.CalibVignetteInfo.pVignetteGreenEvenGain = (UINT16 *)(VignetteTable + (ITUNER_VIGNETTE_GAIN_MAP_SIZE*1));
+                GData.VignetteCalcInfo.CalibVignetteInfo.pVignetteGreenOddGain = (UINT16 *)(VignetteTable  + (ITUNER_VIGNETTE_GAIN_MAP_SIZE*2));
+                GData.VignetteCalcInfo.CalibVignetteInfo.pVignetteBlueGain = (UINT16 *)(VignetteTable      + (ITUNER_VIGNETTE_GAIN_MAP_SIZE*3));
+                {
+                    memset(&Ext_File_Param, 0x0, sizeof(Ext_File_Param));
+                    Ext_File_Param.Vignette_Gain_Load_Param.Address = (void*)GData.VignetteCalcInfo.CalibVignetteInfo.pVignetteRedGain;
+                    Ext_File_Param.Vignette_Gain_Load_Param.Size = ITUNER_VIGNETTE_GAIN_MAP_SIZE * 4;
+                    if (Ituner_Hook_Func.Load_Data(EXT_FILE_VIGNETTE_GAIN, &Ext_File_Param) < 0) {
+                        ITUNER_WARF("%s() %d, call Ituner_Hook_Func.Load_Data(EXT_FILE_VIGNETTE_GAIN) Fail", __func__, __LINE__);
+                    }
+                }
+            } else {
+                GData.VignetteCalcInfo.Enb = 0;
+                GData.VignetteCalcInfo.GainShift = 0;
+            }
+            CHECK_RET(0,  amba_img_dsp_calc_vignette_compensation(&Mode, &GData.VignetteCalcInfo));
+            CHECK_RET(0,  amba_img_dsp_set_vignette_compensation(fd_iav, &Mode));
+        }
+        }
+        memset(WarpGrid, 0, sizeof(WarpGrid));
+        if (_AmbaItuner_Check_Reg(ITUNER_WARP_COMPENSATION_DZOOM_BY_PASS, SPECIAL_USE_NONE)) {
+            // Dzoom Part
+            GData.WarpByPass.ActualLeftTopX = GData.WarpCompensationDzoomByPass.ActualLeftTopX;
+            GData.WarpByPass.ActualLeftTopY = GData.WarpCompensationDzoomByPass.ActualLeftTopY;
+            GData.WarpByPass.ActualRightBotX = GData.WarpCompensationDzoomByPass.ActualRightBotX;
+            GData.WarpByPass.ActualRightBotY = GData.WarpCompensationDzoomByPass.ActualRightBotY;
+            GData.WarpByPass.ZoomX = GData.WarpCompensationDzoomByPass.ZoomX;
+            GData.WarpByPass.ZoomY = GData.WarpCompensationDzoomByPass.ZoomY;
+            GData.WarpByPass.XCenterOffset = GData.WarpCompensationDzoomByPass.XCenterOffset;
+            GData.WarpByPass.YCenterOffset = GData.WarpCompensationDzoomByPass.YCenterOffset;
+            GData.WarpByPass.HorSkewPhaseInc = GData.WarpCompensationDzoomByPass.HorSkewPhaseInc;
+            GData.WarpByPass.DummyWindowXLeft = GData.WarpCompensationDzoomByPass.DummyWindowXLeft;
+            GData.WarpByPass.DummyWindowYTop = GData.WarpCompensationDzoomByPass.DummyWindowYTop;
+            GData.WarpByPass.DummyWindowWidth = GData.WarpCompensationDzoomByPass.DummyWindowWidth;
+            GData.WarpByPass.DummyWindowHeight = GData.WarpCompensationDzoomByPass.DummyWindowHeight;
+            GData.WarpByPass.CfaOutputWidth = GData.WarpCompensationDzoomByPass.CfaOutputWidth;
+            GData.WarpByPass.CfaOutputHeight = GData.WarpCompensationDzoomByPass.CfaOutputHeight;
+            // Set Cfa for A9 CaWarp and WarpCalcInfo structure.
+            GData.WarpCalcInfo.CfaWinDim.Width = GData.WarpByPass.CfaOutputWidth;
+            GData.WarpCalcInfo.CfaWinDim.Height = GData.WarpByPass.CfaOutputHeight;
+            GData.WarpCalcInfo.DmyWinGeo.StartX = GData.WarpByPass.DummyWindowXLeft;
+            GData.WarpCalcInfo.DmyWinGeo.StartY = GData.WarpByPass.DummyWindowYTop;
+            GData.WarpCalcInfo.DmyWinGeo.Width = GData.WarpByPass.DummyWindowWidth;
+            GData.WarpCalcInfo.DmyWinGeo.Height = GData.WarpByPass.DummyWindowHeight;
+            GData.WarpCalcInfo.R2rOutWinDim.Width = RawWidth;
+            GData.WarpCalcInfo.R2rOutWinDim.Height = RawHeight;
+            GData.WarpCalcInfo.MainWinDim.Width = MainWidth;
+            GData.WarpCalcInfo.MainWinDim.Height = MainHeight;
+            GData.WarpCalcInfo.VinSensorGeo.StartX = RawStartX;
+            GData.WarpCalcInfo.VinSensorGeo.StartY = RawStartY;
+            GData.WarpCalcInfo.VinSensorGeo.Width = RawWidth;
+            GData.WarpCalcInfo.VinSensorGeo.Height = RawHeight;
+            GData.WarpCalcInfo.VinSensorGeo.HSubSample.FactorNum = HSubSampleFactorNum;
+            GData.WarpCalcInfo.VinSensorGeo.HSubSample.FactorDen = HSubSampleFactorDen;
+            GData.WarpCalcInfo.VinSensorGeo.VSubSample.FactorNum = VSubSampleFactorNum;
+            GData.WarpCalcInfo.VinSensorGeo.VSubSample.FactorDen = VSubSampleFactorDen;
+            GData.WarpCalcInfo.ActWinCrop.LeftTopX = GData.WarpByPass.ActualLeftTopX;
+            GData.WarpCalcInfo.ActWinCrop.LeftTopY = GData.WarpByPass.ActualLeftTopY;
+            GData.WarpCalcInfo.ActWinCrop.RightBotX = GData.WarpByPass.ActualRightBotX;
+            GData.WarpCalcInfo.ActWinCrop.RightBotY = GData.WarpByPass.ActualRightBotY;
+//            CHECK_RET(0,  amba_img_dsp_calc_warp_compensation(Mode, &GData.WarpCalcInfo));
+            // Set for warp bypass part
+            // Bypass warp horizontal part
+            if (GData.WarpCompensationDzoomByPass.WarpControl) {
+                GData.WarpByPass.WarpControl = GData.WarpCompensationDzoomByPass.WarpControl;
+                GData.WarpByPass.GridArrayWidth = GData.WarpCompensationDzoomByPass.GridArrayWidth;
+                GData.WarpByPass.GridArrayHeight = GData.WarpCompensationDzoomByPass.GridArrayHeight;
+                GData.WarpByPass.HorzGridSpacingExponent = GData.WarpCompensationDzoomByPass.HorzGridSpacingExponent;
+                GData.WarpByPass.VertGridSpacingExponent = GData.WarpCompensationDzoomByPass.VertGridSpacingExponent;
+                GData.WarpByPass.pWarpHorizontalTable = (INT16 *) WarpGrid;
+                {
+                    memset(&Ext_File_Param, 0x0, sizeof(Ext_File_Param));
+                    Ext_File_Param.Bypass_Warp_Horizontal_Table_Load_Param.Address = WarpGrid;
+                    Ext_File_Param.Bypass_Warp_Horizontal_Table_Load_Param.Max_Size = sizeof(WarpGrid) >> 1;
+                    if (Ituner_Hook_Func.Load_Data(EXT_FILE_BYPASS_WARP_HORIZONTAL_TABLE, &Ext_File_Param) < 0) {
+                        ITUNER_WARF("%s() %d, call Ituner_Hook_Func.Load_Data(EXT_FILE_BYPASS_WARP_HORIZONTAL_TABLE) Fail", __func__, __LINE__);
+                    }
+                }
+            } else {
+            #if 0
+                GData.WarpByPass.WarpControl = 0;
+                GData.WarpByPass.pWarpHorizontalTable = (INT16 *) WarpGrid;
+                // Avoid crash, so we assign reasonable values for GridArrayWidth, GridArrayHeight,
+                // HorzGridSpacingExponent, and VertGridSpacingExponent.
+                // We reference to AmbaDSP_ImgWarpCompensation.c (SVN 5404).
+                int EffectiveWidth, EffectiveHeight;
+                int TileWLog2Minus4, TileHLog2Minus4;
+                int TileW, TileH, HorGridNum, VerGridNum;
+                UINT32 MaxHorGrid, MaxVerGrid;
+                switch (Mode.Pipe) {
+                case AMBA_DSP_IMG_PIPE_VIDEO:
+                    EffectiveWidth = GData.WarpCalcInfo.MainWinDim.Width;
+                    EffectiveHeight = GData.WarpCalcInfo.CfaWinDim.Height;
+                    TileWLog2Minus4 = 0;
+                    TileHLog2Minus4 = 0;
+                    MaxHorGrid = WARP_VIDEO_MAXHORGRID;
+                    MaxVerGrid = WARP_VIDEO_MAXVERGRID;
+                    break;
+                case AMBA_DSP_IMG_PIPE_STILL:
+                    EffectiveWidth = (GData.WarpCalcInfo.ActWinCrop.RightBotX - GData.WarpCalcInfo.ActWinCrop.LeftTopX + 0xFFFF) >> SFT;
+                    EffectiveHeight = (GData.WarpCalcInfo.DmyWinGeo.Height + 19) & 0xFFFFFFF0;  // Add 4 line and pad to next 16
+                    TileWLog2Minus4 = (EffectiveWidth > 1280)?3:0;
+                    TileHLog2Minus4 = (EffectiveHeight > 1280)?3:0;
+                    MaxHorGrid = WARP_VIDEO_MAXHORGRID; // Can allow max 32 grid_width because no stitching
+                    MaxVerGrid = WARP_STILL_MAXVERGRID;
+                    break;
+                case AMBA_DSP_IMG_PIPE_DEC:
+                default:
+                    AmbaPrint("[Error] We don't support this pipe!!");
+                }
+                while ((MaxHorGrid - 1) * (1 << (4 + TileWLog2Minus4)) < EffectiveWidth) {
+                    TileWLog2Minus4++;
+                }
+                while ((MaxVerGrid - 1) * (1 << (4 + TileHLog2Minus4)) < EffectiveHeight) {
+                    TileHLog2Minus4++;
+                }
+                TileW = 1 << (4 + TileWLog2Minus4);
+                TileH = 1 << (4 + TileHLog2Minus4);
+                HorGridNum = 1 + ((EffectiveWidth + TileW - 1) >> (4 + TileWLog2Minus4));
+                VerGridNum = 1 + ((EffectiveHeight + TileH - 1) >> (4 + TileHLog2Minus4));
+                GData.WarpByPass.HorzGridSpacingExponent = TileWLog2Minus4;
+                GData.WarpByPass.VertGridSpacingExponent = TileHLog2Minus4;
+                GData.WarpByPass.GridArrayWidth = HorGridNum - 1;
+                GData.WarpByPass.GridArrayHeight = VerGridNum - 1;
+                // Bypass warp vertical part
+                if (GData.WarpCompensationDzoomByPass.VertWarpEnable) {
+                    GData.WarpByPass.VertWarpEnable = GData.WarpCompensationDzoomByPass.VertWarpEnable;
+                    GData.WarpByPass.VertWarpGridArrayWidth = GData.WarpCompensationDzoomByPass.VertWarpGridArrayWidth;
+                    GData.WarpByPass.VertWarpGridArrayHeight = GData.WarpCompensationDzoomByPass.VertWarpGridArrayHeight;
+                    GData.WarpByPass.VertWarpHorzGridSpacingExponent = GData.WarpCompensationDzoomByPass.VertWarpHorzGridSpacingExponent;
+                    GData.WarpByPass.VertWarpVertGridSpacingExponent = GData.WarpCompensationDzoomByPass.VertWarpVertGridSpacingExponent;
+                    GData.WarpByPass.pWarpVerticalTable = (INT16 *) (WarpGrid + (sizeof(WarpGrid) >> 1));
+                    {
+                        memset(&Ext_File_Param, 0x0, sizeof(Ext_File_Param));
+                        Ext_File_Param.Bypass_Warp_Vertical_Table_Load_Param.Address = GData.WarpByPass.pWarpVerticalTable;
+                        Ext_File_Param.Bypass_Warp_Vertical_Table_Load_Param.Max_Size = sizeof(WarpGrid) >> 1;
+                        if (Ituner_Hook_Func.Load_Data(EXT_FILE_BYPASS_WARP_VERTICAL_TABLE, &Ext_File_Param) < 0) {
+                            ITUNER_WARF("%s() %d, call Ituner_Hook_Func.Load_Data(EXT_FILE_BYPASS_WARP_VERITCAL_TABLE) Fail", __func__, __LINE__);
+                        }
+                    }
+                } else {
+                    GData.WarpByPass.VertWarpEnable = 0;
+                    GData.WarpByPass.pWarpVerticalTable = (INT16 *) (WarpGrid + (sizeof(WarpGrid) >> 1));
+                    // Avoid crash, so we assign reasonable values for VertWarpGridArrayWidth, VertWarpGridArrayHeight,
+                    // VertWarpHorzGridSpacingExponent, and VertWarpVertGridSpacingExponent.
+                    // We reference to AmbaDSP_ImgWarpCompensation.c (SVN 5404).
+                    int EffectiveWidth, EffectiveHeight;
+                    int TileWLog2Minus4, TileHLog2Minus4;
+                    int TileW, TileH, HorGridNum, VerGridNum;
+                    UINT32 MaxHorGrid, MaxVerGrid;
+                    UINT32 W0;
+                    switch (Mode.Pipe) {
+                    case AMBA_DSP_IMG_PIPE_VIDEO:
+                        EffectiveWidth = GData.WarpCalcInfo.MainWinDim.Width;
+                        EffectiveHeight = GData.WarpCalcInfo.MainWinDim.Height;
+                        if (EffectiveHeight == 1080){
+                            EffectiveHeight = 1088; // h264 needs 16 align height so ucode will pad to 1088 in section2 output
+                        }
+                        TileWLog2Minus4 = 0;
+                        TileHLog2Minus4 = 0;
+                        MaxHorGrid = WARP_VIDEO_MAXHORGRID;
+                        MaxVerGrid = WARP_VIDEO_MAXVERGRID;
+                        break;
+                    case AMBA_DSP_IMG_PIPE_STILL:
+                        W0 = (((GData.WarpCalcInfo.ActWinCrop.RightBotX - GData.WarpCalcInfo.ActWinCrop.LeftTopX + 0xFFFF) >> SFT));
+                        EffectiveWidth = (((UINT64)(W0) * GData.WarpCalcInfo.CfaWinDim.Width) / GData.WarpCalcInfo.DmyWinGeo.Width);
+                        EffectiveHeight = (((GData.WarpCalcInfo.ActWinCrop.RightBotY - GData.WarpCalcInfo.ActWinCrop.LeftTopY + 0xFFFF) >> SFT ) + 19 ) & 0xFFFFFFF0;  // Add 4 line and pad to next 16
+                        TileWLog2Minus4 = 0;
+                        TileHLog2Minus4 = 0;
+                        MaxHorGrid = WARP_VIDEO_MAXHORGRID; // Can allow max 32 grid_width because no stitching
+                        MaxVerGrid = WARP_STILL_MAXVERGRID;
+                        break;
+                    case AMBA_DSP_IMG_PIPE_DEC:
+                    default:
+                        AmbaPrint("[Error] We don't support this pipe!!");
+                    }
+                    while ((MaxHorGrid - 1) * (1 << (4 + TileWLog2Minus4)) < EffectiveWidth) {
+                        TileWLog2Minus4++;
+                    }
+                    while ((MaxVerGrid - 1) * (1 << (4 + TileHLog2Minus4)) < EffectiveHeight) {
+                        TileHLog2Minus4++;
+                    }
+                    TileW = 1 << (4 + TileWLog2Minus4);
+                    TileH = 1 << (4 + TileHLog2Minus4);
+                    HorGridNum = 1 + ((EffectiveWidth + TileW - 1) >> (4 + TileWLog2Minus4));
+                    VerGridNum = 1 + ((EffectiveHeight + TileH - 1) >> (4 + TileHLog2Minus4));
+                    GData.WarpByPass.VertWarpHorzGridSpacingExponent = TileWLog2Minus4;
+                    GData.WarpByPass.VertWarpVertGridSpacingExponent = TileHLog2Minus4;
+                    GData.WarpByPass.VertWarpGridArrayWidth = HorGridNum - 1;
+                    GData.WarpByPass.VertWarpGridArrayHeight = VerGridNum - 1;
+                }
+//               		 extern int AmbaDSP_ImgSetWarpCompensationByPass(amba_img_dsp_mode_cfg_t Mode, AMBA_DSP_IMG_BYPASS_WARP_DZOOM_INFO_s *pWarpDzoomCorrByPass);
+//                		CHECK_RET(0,  AmbaDSP_ImgSetWarpCompensationByPass(Mode, &GData.WarpByPass));
+		#endif
+            }
+        } else {
+            if (_AmbaItuner_Check_Reg(ITUNER_WARP_COMPENSATION, GData.WarpCompensation.Enable) && GData.WarpCompensation.Enable) {
+                GData.WarpCalcInfo.WarpEnb = GData.WarpCompensation.Enable;
+                GData.WarpCalcInfo.Control = GData.WarpCompensation.Enable;
+                GData.WarpCalcInfo.CalibWarpInfo.Version = GData.WarpCompensation.CalibVersion;
+                GData.WarpCalcInfo.CalibWarpInfo.HorGridNum = GData.WarpCompensation.HorizontalGridNumber;
+                GData.WarpCalcInfo.CalibWarpInfo.VerGridNum = GData.WarpCompensation.VerticalGridNumber;
+                GData.WarpCalcInfo.CalibWarpInfo.TileWidthExp = GData.WarpCompensation.TileWidthExponent;
+                GData.WarpCalcInfo.CalibWarpInfo.TileHeightExp = GData.WarpCompensation.TileHeightExponent;
+                GData.WarpCalcInfo.CalibWarpInfo.VinSensorGeo.StartX = GData.WarpCompensation.VinSensorStartX;
+                GData.WarpCalcInfo.CalibWarpInfo.VinSensorGeo.StartY = GData.WarpCompensation.VinSensorStartY;
+                GData.WarpCalcInfo.CalibWarpInfo.VinSensorGeo.Width = GData.WarpCompensation.VinSensorWidth;
+                GData.WarpCalcInfo.CalibWarpInfo.VinSensorGeo.Height = GData.WarpCompensation.VinSensorHeight;
+                GData.WarpCalcInfo.CalibWarpInfo.VinSensorGeo.HSubSample.FactorNum = GData.WarpCompensation.VinSensorHSubSampleFactorNum;
+                GData.WarpCalcInfo.CalibWarpInfo.VinSensorGeo.HSubSample.FactorDen = GData.WarpCompensation.VinSensorHSubSampleFactorDen;
+                GData.WarpCalcInfo.CalibWarpInfo.VinSensorGeo.VSubSample.FactorNum = GData.WarpCompensation.VinSensorVSubSampleFactorNum;
+                GData.WarpCalcInfo.CalibWarpInfo.VinSensorGeo.VSubSample.FactorDen = GData.WarpCompensation.VinSensorVSubSampleFactorDen;
+                GData.WarpCalcInfo.CalibWarpInfo.pWarp = (AMBA_DSP_IMG_GRID_POINT_s *)WarpGrid;
+                memset(&Ext_File_Param, 0x0, sizeof(Ext_File_Param));
+                Ext_File_Param.Warp_Table_Load_Param.Address = GData.WarpCalcInfo.CalibWarpInfo.pWarp;
+                Ext_File_Param.Warp_Table_Load_Param.Size = ITUNER_CAL_WARP_TABLE_SIZE(GData.WarpCalcInfo.CalibWarpInfo.HorGridNum, GData.WarpCalcInfo.CalibWarpInfo.VerGridNum);
+                if (Ituner_Hook_Func.Load_Data(EXT_FILE_WARP_TABLE, &Ext_File_Param) < 0) {
+                    ITUNER_WARF("%s() %d, call Ituner_Hook_Func.Load_Data(EXT_FILE_WARP_TABLE) Fail", __func__, __LINE__);
+                }
+                GData.WarpCalcInfo.MainWinDim.Width = MainWidth;
+                GData.WarpCalcInfo.MainWinDim.Height  = MainHeight;
+            } else {
+                GData.WarpCalcInfo.WarpEnb = 0;
+                GData.WarpCalcInfo.MainWinDim.Width = MainWidth;
+                GData.WarpCalcInfo.MainWinDim.Height  = MainHeight;
+            }
+            GData.WarpCalcInfo.VinSensorGeo.StartX = RawStartX;
+            GData.WarpCalcInfo.VinSensorGeo.StartY = RawStartY;
+            GData.WarpCalcInfo.VinSensorGeo.Width = RawWidth;
+            GData.WarpCalcInfo.VinSensorGeo.Height = RawHeight;
+            GData.WarpCalcInfo.VinSensorGeo.HSubSample.FactorNum = HSubSampleFactorNum;
+            GData.WarpCalcInfo.VinSensorGeo.HSubSample.FactorDen = HSubSampleFactorDen;
+            GData.WarpCalcInfo.VinSensorGeo.VSubSample.FactorNum = VSubSampleFactorNum;
+            GData.WarpCalcInfo.VinSensorGeo.VSubSample.FactorDen = VSubSampleFactorDen;
+            if (_AmbaItuner_Check_Reg(ITUNER_DZOOM, GData.Dzoom.Enable)) {
+                if (GData.Dzoom.Enable == 1) {
+                    GData.WarpCalcInfo.R2rOutWinDim.Width = GData.Dzoom.R2rOutputWidth;
+                    GData.WarpCalcInfo.R2rOutWinDim.Height = GData.Dzoom.R2rOutputHeigh;
+                    GData.WarpCalcInfo.DmyWinGeo.StartX = GData.Dzoom.DummyWindowLeftX;
+                    GData.WarpCalcInfo.DmyWinGeo.StartY = GData.Dzoom.DummyWindowTopY;
+                    GData.WarpCalcInfo.DmyWinGeo.Width = GData.Dzoom.DummyWindowWidth;
+                    GData.WarpCalcInfo.DmyWinGeo.Height = GData.Dzoom.DummyWindowHeight;
+                    GData.WarpCalcInfo.CfaWinDim.Width = GData.Dzoom.CfaOutputWidth;
+                    GData.WarpCalcInfo.CfaWinDim.Height = GData.Dzoom.CfaOutputHeight;
+                    GData.WarpCalcInfo.ActWinCrop.LeftTopX = GData.Dzoom.ActualLeftTopX;
+                    GData.WarpCalcInfo.ActWinCrop.LeftTopY = GData.Dzoom.ActualLeftTopY;
+                    GData.WarpCalcInfo.ActWinCrop.RightBotX = GData.Dzoom.ActualRightBotX;
+                    GData.WarpCalcInfo.ActWinCrop.RightBotY = GData.Dzoom.ActualRightBotY;
+                    GData.WarpCalcInfo.HorSkewPhaseInc = GData.Dzoom.HorSkewPhaseInc;
+                } else if (GData.Dzoom.Enable == 0) {
+                    GData.WarpCalcInfo.R2rOutWinDim.Width = RawWidth;
+                    GData.WarpCalcInfo.R2rOutWinDim.Height = RawHeight;
+                    GData.WarpCalcInfo.DmyWinGeo.StartX = RawStartX;
+                    GData.WarpCalcInfo.DmyWinGeo.StartY = RawStartY;
+                    GData.WarpCalcInfo.DmyWinGeo.Width = RawWidth;
+                    GData.WarpCalcInfo.DmyWinGeo.Height = RawHeight;
+                    GData.WarpCalcInfo.CfaWinDim.Width = RawWidth;
+                    GData.WarpCalcInfo.CfaWinDim.Height = RawHeight;
+                    GData.WarpCalcInfo.ActWinCrop.LeftTopX = 0;
+                    GData.WarpCalcInfo.ActWinCrop.LeftTopY = 0;
+                    GData.WarpCalcInfo.ActWinCrop.RightBotX = (RawWidth)<<16;
+                    GData.WarpCalcInfo.ActWinCrop.RightBotY = (RawHeight)<<16;
+                    GData.WarpCalcInfo.HorSkewPhaseInc = 0;
+                }
+            }
+//            CHECK_RET(0,  AmbaDSP_ImgCalcWarpCompensation(Mode, &GData.WarpCalcInfo));
+//            CHECK_RET(0,  AmbaDSP_ImgSetWarpCompensation(Mode));
+        }
+
+#if 0
+        memset(ca_grid, 0, sizeof(ca_grid));
+        if (_AmbaItuner_Check_Reg(ITUNER_CHROMA_ABERRATION_INFO_BY_PASS, SPECIAL_USE_NONE)) {
+            // Horizontal part
+            if (GData.ChromaAberrationInfoByPass.HorzWarpEnable) {
+                GData.CAByPass.HorzWarpEnable = GData.ChromaAberrationInfoByPass.HorzWarpEnable;
+                GData.CAByPass.HorzPassGridArrayWidth = GData.ChromaAberrationInfoByPass.HorzPassGridArrayWidth;
+                GData.CAByPass.HorzPassGridArrayHeight = GData.ChromaAberrationInfoByPass.HorzPassGridArrayHeight;
+                GData.CAByPass.HorzPassHorzGridSpacingExponent = GData.ChromaAberrationInfoByPass.HorzPassHorzGridSpacingExponent;
+                GData.CAByPass.HorzPassVertGridSpacingExponent = GData.ChromaAberrationInfoByPass.HorzPassVertGridSpacingExponent;
+                GData.CAByPass.pWarpHorzTable = (INT16 *) ca_grid;
+                memset(&Ext_File_Param, 0x0, sizeof(Ext_File_Param));
+                Ext_File_Param.Bypass_Ca_Horizontal_Table_Load_Param.Address = GData.CAByPass.pWarpHorzTable;
+                Ext_File_Param.Bypass_Ca_Horizontal_Table_Load_Param.Max_Size = sizeof(ca_grid) >> 1;
+                if (Ituner_Hook_Func.Load_Data(EXT_FILE_BYPASS_CA_HORIZONTAL_TABLE, &Ext_File_Param) < 0) {
+                    ITUNER_WARF("%s() %d, call Ituner_Hook_Func.Load_Data(EXT_FILE_BYPASS_CA_HORIZONTAL_TABLE) Fail", __func__, __LINE__);
+                }
+            } else {
+                GData.CAByPass.HorzWarpEnable = 0;
+                GData.CAByPass.pWarpHorzTable = (INT16 *) ca_grid;
+                // Avoid crash, so we assign reasonable values for HorzPassGridArrayWidth, HorzPassGridArrayHeight,
+                // HorzPassHorzGridSpacingExponent, and HorzPassVertGridSpacingExponent.
+                // We reference to AmbaDSP_ImgCawarpCompensation.c (SVN 5404).
+                int OutWidth, OutHeight;
+                int TileWLog2Minus4, TileHLog2Minus4;
+                int TileW, TileH, HorGridNum, VerGridNum;
+                UINT32 MaxHorGrid, MaxVerGrid;
+                switch (Mode.Pipe) {
+                case AMBA_DSP_IMG_PIPE_VIDEO:
+                    MaxHorGrid = CAWARP_VIDEO_MAXHORGRID;
+                    MaxVerGrid = CAWARP_VIDEO_MAXVERGRID;
+                    break;
+                case AMBA_DSP_IMG_PIPE_STILL:
+                    MaxHorGrid = CAWARP_VIDEO_MAXHORGRID;
+                    MaxVerGrid = CAWARP_VIDEO_MAXVERGRID;
+                    break;
+                case AMBA_DSP_IMG_PIPE_DEC:
+                default:
+                    AmbaPrint("[Error] We don't support this pipe!!");
+                }
+                OutWidth = GData.WarpCalcInfo.CfaWinDim.Width;
+                OutHeight = GData.WarpCalcInfo.DmyWinGeo.Height;
+                TileWLog2Minus4 = 0;
+                while ((MaxHorGrid - 1) * (1 << (4 + TileWLog2Minus4)) < OutWidth) {
+                    TileWLog2Minus4++;
+                }
+                TileHLog2Minus4 = 0;
+                while ((MaxVerGrid - 1) * (1 << (4 + TileHLog2Minus4)) < OutHeight) {
+                    TileHLog2Minus4++;
+                }
+                TileW = 1 << (4 + TileWLog2Minus4);
+                TileH = 1 << (4 + TileHLog2Minus4);
+                HorGridNum = 1 + ((OutWidth + TileW - 1) >> (4 + TileWLog2Minus4));
+                VerGridNum = 1 + ((OutHeight + TileH - 1) >> (4 + TileHLog2Minus4));
+                GData.CAByPass.HorzPassHorzGridSpacingExponent = TileWLog2Minus4;
+                GData.CAByPass.HorzPassVertGridSpacingExponent = TileHLog2Minus4;
+                GData.CAByPass.HorzPassGridArrayWidth = HorGridNum - 1;
+                GData.CAByPass.HorzPassGridArrayHeight = VerGridNum - 1;
+            }
+
+            // Vertical part
+            if (GData.ChromaAberrationInfoByPass.VertWarpEnable) {
+                GData.CAByPass.VertWarpEnable = GData.ChromaAberrationInfoByPass.VertWarpEnable;
+                GData.CAByPass.VertPassGridArrayWidth = GData.ChromaAberrationInfoByPass.VertPassGridArrayWidth;
+                GData.CAByPass.VertPassGridArrayHeight = GData.ChromaAberrationInfoByPass.VertPassGridArrayHeight;
+                GData.CAByPass.VertPassHorzGridSpacingExponent = GData.ChromaAberrationInfoByPass.VertPassHorzGridSpacingExponent;
+                GData.CAByPass.VertPassVertGridSpacingExponent = GData.ChromaAberrationInfoByPass.VertPassVertGridSpacingExponent;
+                GData.CAByPass.pWarpVertTable = (INT16 *) (ca_grid + (sizeof(ca_grid) >> 1));
+
+                memset(&Ext_File_Param, 0x0, sizeof(Ext_File_Param));
+                Ext_File_Param.Bypass_Ca_Vertical_Table_Load_Param.Address = GData.CAByPass.pWarpVertTable;
+                Ext_File_Param.Bypass_Ca_Vertical_Table_Load_Param.Max_Size = sizeof(ca_grid) >> 1;
+                if (Ituner_Hook_Func.Load_Data(EXT_FILE_BYPASS_CA_VERTICAL_TABLE, &Ext_File_Param) < 0) {
+                    ITUNER_WARF("%s() %d, call Ituner_Hook_Func.Load_Data(EXT_FILE_BYPASS_CA_VERTICAL_TABLE) Fail", __func__, __LINE__);
+                }
+            } else {
+                GData.CAByPass.VertWarpEnable = 0;
+                GData.CAByPass.pWarpVertTable = (INT16 *) (ca_grid + (sizeof(ca_grid) >> 1));
+
+                // Avoid crash, so we assign reasonable values for VertPassGridArrayWidth, VertPassGridArrayHeight,
+                // VertPassHorzGridSpacingExponent, and VertPassVertGridSpacingExponent.
+                // We reference to AmbaDSP_ImgCawarpCompensation.c (SVN 5404).
+
+                // Caution: In vertical part, there is no formula for width. It's using value from horiztontal part.
+                //          So we use the formula in horiztontal part again.
+                //          Counting here again voids the case -  "horizontal part is disable, but vertical part is enable".
+                int OutWidth, OutHeight;
+                int TileWLog2Minus4, TileHLog2Minus4;
+                int TileW, TileH, HorGridNum, VerGridNum;
+                UINT32 MaxHorGrid, MaxVerGrid;
+                switch (Mode.Pipe) {
+                case AMBA_DSP_IMG_PIPE_VIDEO:
+                    MaxHorGrid = CAWARP_VIDEO_MAXHORGRID;
+                    MaxVerGrid = CAWARP_VIDEO_MAXVERGRID;
+                    break;
+                case AMBA_DSP_IMG_PIPE_STILL:
+                    MaxHorGrid = CAWARP_VIDEO_MAXHORGRID;
+                    MaxVerGrid = CAWARP_VIDEO_MAXVERGRID;
+                    break;
+                case AMBA_DSP_IMG_PIPE_DEC:
+                default:
+                    AmbaPrint("[Error] We don't support this pipe!!");
+                }
+                OutWidth = GData.WarpCalcInfo.CfaWinDim.Width;
+                OutHeight = GData.WarpCalcInfo.CfaWinDim.Height;
+                TileWLog2Minus4 = 0;
+                while ((MaxHorGrid - 1) * (1 << (4 + TileWLog2Minus4)) < OutWidth) {
+                    TileWLog2Minus4++;
+                }
+                TileHLog2Minus4 = 0;
+                while ((MaxVerGrid - 1) * (1 << (4 + TileHLog2Minus4)) < OutHeight) {
+                    TileHLog2Minus4++;
+                }
+                TileW = 1 << (4 + TileWLog2Minus4);
+                TileH = 1 << (4 + TileHLog2Minus4);
+                HorGridNum = 1 + ((OutWidth + TileW - 1) >> (4 + TileWLog2Minus4));
+                VerGridNum = 1 + ((OutHeight + TileH - 1) >> (4 + TileHLog2Minus4));
+                GData.CAByPass.VertPassHorzGridSpacingExponent = TileWLog2Minus4;
+                GData.CAByPass.VertPassVertGridSpacingExponent = TileHLog2Minus4;
+                GData.CAByPass.VertPassGridArrayWidth = HorGridNum - 1;
+                GData.CAByPass.VertPassGridArrayHeight = VerGridNum - 1;
+            }
+            // Check common part
+            if (GData.ChromaAberrationInfoByPass.HorzWarpEnable || GData.ChromaAberrationInfoByPass.VertWarpEnable) {
+                GData.CAByPass.RedScaleFactor = GData.ChromaAberrationInfoByPass.RedScaleFactor;
+                GData.CAByPass.BlueScaleFactor = GData.ChromaAberrationInfoByPass.BlueScaleFactor;
+            } else {
+                GData.CAByPass.RedScaleFactor = 0;
+                GData.CAByPass.BlueScaleFactor = 0;
+            }
+//            extern int   AmbaDSP_ImgSetCawarpCompensationByPass(amba_img_dsp_mode_cfg_t Mode, AMBA_DSP_IMG_BYPASS_CAWARP_INFO_s *pCAWarpCorrByPass);
+//            CHECK_RET(0,  AmbaDSP_ImgSetCawarpCompensationByPass(Mode, &GData.CAByPass));
+        } else {
+            if (_AmbaItuner_Check_Reg(ITUNER_CHROMA_ABERRATION_INFO, GData.ChromaAberrationInfo.Enable) && GData.ChromaAberrationInfo.Enable) {
+                GData.CACalcInfo.CaWarpEnb = GData.ChromaAberrationInfo.Enable;
+                GData.CACalcInfo.CalibCaWarpInfo.Version = GData.ChromaAberrationInfo.CalibVersion;
+                GData.CACalcInfo.CalibCaWarpInfo.HorGridNum = GData.ChromaAberrationInfo.HorizontalGridNumber;
+                GData.CACalcInfo.CalibCaWarpInfo.VerGridNum = GData.ChromaAberrationInfo.VerticalGridNumber;
+                GData.CACalcInfo.CalibCaWarpInfo.TileWidthExp = GData.ChromaAberrationInfo.TileWidthExponent;
+                GData.CACalcInfo.CalibCaWarpInfo.TileHeightExp = GData.ChromaAberrationInfo.TileHeightExponent;
+                GData.CACalcInfo.CalibCaWarpInfo.VinSensorGeo.StartX = GData.ChromaAberrationInfo.VinSensorStartX;
+                GData.CACalcInfo.CalibCaWarpInfo.VinSensorGeo.StartY = GData.ChromaAberrationInfo.VinSensorStartY;
+                GData.CACalcInfo.CalibCaWarpInfo.VinSensorGeo.Width = GData.ChromaAberrationInfo.VinSensorWidth;
+                GData.CACalcInfo.CalibCaWarpInfo.VinSensorGeo.Height = GData.ChromaAberrationInfo.VinSensorHeight;
+                GData.CACalcInfo.CalibCaWarpInfo.VinSensorGeo.HSubSample.FactorNum = GData.ChromaAberrationInfo.VinSensorHSubSampleFactorNum;
+                GData.CACalcInfo.CalibCaWarpInfo.VinSensorGeo.HSubSample.FactorDen = GData.ChromaAberrationInfo.VinSensorHSubSampleFactorDen;
+                GData.CACalcInfo.CalibCaWarpInfo.VinSensorGeo.VSubSample.FactorNum = GData.ChromaAberrationInfo.VinSensorVSubSampleFactorNum;
+                GData.CACalcInfo.CalibCaWarpInfo.VinSensorGeo.VSubSample.FactorDen = GData.ChromaAberrationInfo.VinSensorVSubSampleFactorDen;
+                GData.CACalcInfo.CalibCaWarpInfo.RedScaleFactor = GData.ChromaAberrationInfo.RedScaleFactor;
+                GData.CACalcInfo.CalibCaWarpInfo.BlueScaleFactor = GData.ChromaAberrationInfo.BlueScaleFactor;
+                GData.CACalcInfo.CalibCaWarpInfo.pCaWarp = (AMBA_DSP_IMG_GRID_POINT_s *)ca_grid;
+                memset(&Ext_File_Param, 0x0, sizeof(Ext_File_Param));
+                Ext_File_Param.Ca_Table_Load_Param.Address = GData.CACalcInfo.CalibCaWarpInfo.pCaWarp;
+                Ext_File_Param.Ca_Table_Load_Param.Size = ITUNER_CAL_CA_TABLE_SIZE(GData.CACalcInfo.CalibCaWarpInfo.HorGridNum, GData.CACalcInfo.CalibCaWarpInfo.VerGridNum);
+                if (Ituner_Hook_Func.Load_Data(EXT_FILE_CA_TABLE, &Ext_File_Param) < 0) {
+                    ITUNER_WARF("%s() %d, call Ituner_Hook_Func.Load_Data(EXT_FILE_CA_TABLE) Fail", __func__, __LINE__);
+                }
+            } else {
+                GData.CACalcInfo.CaWarpEnb = 0;
+            }
+            GData.CACalcInfo.VinSensorGeo.StartX = RawStartX;
+            GData.CACalcInfo.VinSensorGeo.StartY = RawStartY;
+            GData.CACalcInfo.VinSensorGeo.Width = RawWidth;
+            GData.CACalcInfo.VinSensorGeo.Height = RawHeight;
+            GData.CACalcInfo.VinSensorGeo.HSubSample.FactorNum = HSubSampleFactorNum;
+            GData.CACalcInfo.VinSensorGeo.HSubSample.FactorDen = HSubSampleFactorDen;
+            GData.CACalcInfo.VinSensorGeo.VSubSample.FactorNum = VSubSampleFactorNum;
+            GData.CACalcInfo.VinSensorGeo.VSubSample.FactorDen = VSubSampleFactorDen;
+            GData.CACalcInfo.R2rOutWinDim = GData.WarpCalcInfo.R2rOutWinDim;
+            GData.CACalcInfo.DmyWinGeo = GData.WarpCalcInfo.DmyWinGeo;
+            GData.CACalcInfo.CfaWinDim = GData.WarpCalcInfo.CfaWinDim;
+//            CHECK_RET(0,  AmbaDSP_ImgCalcCawarpCompensation(Mode, &GData.CACalcInfo));
+//            CHECK_RET(0,  AmbaDSP_ImgSetCawarpCompensation(Mode));
+        }
+#endif
+        if (_AmbaItuner_Check_Reg(ITUNER_COLOR_CORRECTION, SPECIAL_USE_NONE)) {
+            GData.CcReg.RegSettingAddr = (UINT32)CcReg;
+            if (GData.CcReg.RegSettingAddr != 0) {
+                memset(&Ext_File_Param, 0x0, sizeof(Ext_File_Param));
+                Ext_File_Param.CC_Reg_Load_Param.Address = (void*)GData.CcReg.RegSettingAddr;
+                Ext_File_Param.CC_Reg_Load_Param.Size = AMBA_DSP_IMG_CC_REG_SIZE;
+                if (Ituner_Hook_Func.Load_Data(EXT_FILE_CC_REG, &Ext_File_Param) < 0) {
+                    ITUNER_WARF("%s() %d, call Ituner_Hook_Func.Load_Data(EXT_FILE_CC_REG) Fail", __func__, __LINE__);
+                } else {
+                    CHECK_RET(0,  amba_img_dsp_set_color_correction_reg(&Mode, &GData.CcReg));
+                }
+
+            }
+
+            GData.CcThreeD.MatrixThreeDTableAddr = (UINT32)Cc3d;
+            if (GData.CcThreeD.MatrixThreeDTableAddr != 0) {
+                memset(&Ext_File_Param, 0x0, sizeof(Ext_File_Param));
+                Ext_File_Param.CC_ThreeD_Load_Param.Address = (void*)GData.CcThreeD.MatrixThreeDTableAddr;
+                Ext_File_Param.CC_ThreeD_Load_Param.Size = AMBA_DSP_IMG_CC_3D_SIZE;
+                if (Ituner_Hook_Func.Load_Data(EXT_FILE_CC_THREED, &Ext_File_Param) < 0) {
+                    ITUNER_WARF("%s() %d, call Ituner_Hook_Func.Load_Data(EXT_FILE_CC_THREED) Fail", __func__, __LINE__);
+                } else {
+                    CHECK_RET(0,  amba_img_dsp_set_color_correction(fd_iav, &Mode, &GData.CcThreeD));
+                }
+            }
+        }
+        if (_AmbaItuner_Check_Reg(ITUNER_STATIC_BLACK_LEVEL, SPECIAL_USE_NONE)) {
+            CHECK_RET(0,  amba_img_dsp_set_static_black_level(fd_iav, &Mode, &GData.StaticBlackLevel));
+        }
+        if (_AmbaItuner_Check_Reg(ITUNER_WB_GAIN, SPECIAL_USE_NONE)) {
+            GData.WbGain.AeGain = (_Ituner_Valid_Filter[ITUNER_AE_INFO] == 1) ? GData.AeInfo.Dgain : WB_DGAIN_UNIT;
+            GData.WbGain.GlobalDGain = (_Ituner_Valid_Filter[ITUNER_GLOBAL_DGAIN] == 1) ? GData.GlobalDgain : WB_DGAIN_UNIT;
+            CHECK_RET(0,  amba_img_dsp_set_wb_gain(fd_iav, &Mode, &GData.WbGain));
+        }
+        if (_AmbaItuner_Check_Reg(ITUNER_DEFERRED_BLACK_LEVEL, SPECIAL_USE_NONE)) {
+            CHECK_RET(0,  amba_img_dsp_set_deferred_black_level(fd_iav, &Mode, &GData.DeferredBlackLevel));
+        }
+        if (_AmbaItuner_Check_Reg(ITUNER_DYNAMIC_BAD_PIXEL_CORRECTION, GData.DynamicBadPixelCorrection.Enb)) {
+            CHECK_RET(0,  amba_img_dsp_set_dynamic_bad_pixel_correction(fd_iav, &Mode, &GData.DynamicBadPixelCorrection));/*Need to double check*/
+        }
+        if (_AmbaItuner_Check_Reg(ITUNER_CFA_LEAKAGE_FILTER, GData.CfaLeakageFilter.Enb)) {
+            CHECK_RET(0,  amba_img_dsp_set_cfa_leakage_filter(fd_iav, &Mode, &GData.CfaLeakageFilter));/*Need to double check*/
+        }
+        if (_AmbaItuner_Check_Reg(ITUNER_CFA_NOISE_FILTER, GData.CfaNoiseFilter.Enb)) {
+            CHECK_RET(0,  amba_img_dsp_set_cfa_noise_filter(fd_iav, &Mode, &GData.CfaNoiseFilter));/*Need to double check*/
+        }
+        if (_AmbaItuner_Check_Reg(ITUNER_ANTI_ALIASING_STRENGTH, GData.AntiAliasing.Enb)) {
+            CHECK_RET(0,  amba_img_dsp_set_anti_aliasing(fd_iav, &Mode, &GData.AntiAliasing));/*Need to double check*/
+        }
+        if (_AmbaItuner_Check_Reg(ITUNER_DGAIN_SATURATION_LEVEL, SPECIAL_USE_NONE)) {
+            CHECK_RET(0,  amba_img_dsp_set_dgain_saturation_level(fd_iav, &Mode, &GData.DgainSaturationLevel));
+        }
+        if (_AmbaItuner_Check_Reg(ITUNER_LOCAL_EXPOSURE, GData.LocalExposure.Enb)) {
+            CHECK_RET(0,  amba_img_dsp_set_local_exposure(fd_iav, &Mode, &GData.LocalExposure));
+        }
+        if (_AmbaItuner_Check_Reg(ITUNER_TONE_CURVE, SPECIAL_USE_NONE)) {
+            CHECK_RET(0,  amba_img_dsp_set_tone_curve(fd_iav, &Mode, &GData.ToneCurve));
+        }
+        if (_AmbaItuner_Check_Reg(ITUNER_RGB_TO_YUV_MATRIX, SPECIAL_USE_NONE)) {
+            CHECK_RET(0,  amba_img_dsp_set_rgb_to_yuv_matrix(fd_iav, &Mode, &GData.RgbToYuvMatrix));
+        }
+        if (_AmbaItuner_Check_Reg(ITUNER_CHROMA_SCALE, GData.ChromaScale.Enb)) {
+            CHECK_RET(0,  amba_img_dsp_set_chroma_scale(fd_iav, &Mode, &GData.ChromaScale));
+        }
+        if (_AmbaItuner_Check_Reg(ITUNER_CHROMA_MEDIAN_FILTER, GData.ChromaMedianFilter.Enable)) {
+            CHECK_RET(0,  amba_img_dsp_set_chroma_median_filter(fd_iav, &Mode, &GData.ChromaMedianFilter));
+        }
+        if (_AmbaItuner_Check_Reg(ITUNER_DEMOSAIC_FILTER, SPECIAL_USE_NONE)) {
+            CHECK_RET(0,  amba_img_dsp_set_demosaic(fd_iav, &Mode, &GData.DemosaicFilter));
+        }
+        if (_AmbaItuner_Check_Reg(ITUNER_GB_GR_MISMATCH, SPECIAL_USE_NONE)) {
+            CHECK_RET(0,  amba_img_dsp_set_gbgr_mismatch(fd_iav, &Mode, &GData.GbGrMismatch));
+        }
+        if (_AmbaItuner_Check_Reg(ITUNER_SHP_A_OR_SPATIAL_FILTE_SELECT, SPECIAL_USE_NONE)) {
+            CHECK_RET(0,  amba_img_dsp_set_luma_processing_mode(fd_iav, &Mode, &GData.LisoProcessSelect));
+        }
+        if (_AmbaItuner_Check_Reg(ITUNER_CDNR, SPECIAL_USE_NONE)) {
+            CHECK_RET(0,  amba_img_dsp_set_color_dependent_noise_reduction(fd_iav, &Mode, &GData.CDNR));
+        }
+        if (_AmbaItuner_Check_Reg(ITUNER_CHROMA_FILTER, GData.ChromaFilter.Enable)) {
+            CHECK_RET(0,  amba_img_dsp_set_chroma_filter(fd_iav, &Mode, &GData.ChromaFilter));
+        }
+
+        if (GData.LisoProcessSelect.AdvancedFeaturesEnable == 2) { // 2-pass LISO
+            // wide chroma filter
+            if (_AmbaItuner_Check_Reg(ITUNER_WIDE_CHROMA_FILTER, GData.WideChromaFilter.Enable)) {
+                CHECK_RET(0,  amba_img_dsp_set_wide_chroma_filter(fd_iav, &Mode, &GData.WideChromaFilter));
+            }
+            // wide chroma filter combine
+            if (_AmbaItuner_Check_Reg(ITUNER_WIDE_CHROMA_FILTER_COMBINE, SPECIAL_USE_NONE)) {
+                CHECK_RET(0,  amba_img_dsp_set_wide_chroma_filter_combine(fd_iav, &Mode, &GData.WideChromaFilterCombine));
+            }
+
+            if (_AmbaItuner_Check_Reg(ITUNER_FINAL_SHARPEN_BOTH, SPECIAL_USE_NONE)) {
+                CHECK_RET(0,  amba_img_dsp_set_final_sharpen_noise_both(fd_iav, &Mode, &GData.FinalSharpenBoth));
+            }
+            if (_AmbaItuner_Check_Reg(ITUNER_FINAL_SHARPEN_NOISE, SPECIAL_USE_NONE)) {
+                CHECK_RET(0,  amba_img_dsp_set_final_sharpen_noise_noise(fd_iav, &Mode, &GData.FinalSharpenNoise));
+            }
+            if (_AmbaItuner_Check_Reg(ITUNER_FINAL_FIR, SPECIAL_USE_NONE)) {
+                CHECK_RET(0,  amba_img_dsp_set_final_sharpen_noise_sharpen_fir(fd_iav, &Mode, &GData.FinalFir));
+            }
+            if (_AmbaItuner_Check_Reg(ITUNER_FINAL_CORING, SPECIAL_USE_NONE)) {
+                CHECK_RET(0,  amba_img_dsp_set_final_sharpen_noise_sharpen_coring(fd_iav, &Mode, &GData.FinalCoring));
+            }
+            if (_AmbaItuner_Check_Reg(ITUNER_FINAL_CORING_INDEX_SCALE, SPECIAL_USE_NONE)) {
+                CHECK_RET(0,  amba_img_dsp_set_final_sharpen_noise_sharpen_coring_index_scale(fd_iav, &Mode, &GData.FinalCoringIndexScale));
+            }
+            if (_AmbaItuner_Check_Reg(ITUNER_FINAL_MIN_CORING_RESULT, SPECIAL_USE_NONE)) {
+                CHECK_RET(0,  amba_img_dsp_set_final_sharpen_noise_sharpen_min_coring_result(fd_iav, &Mode, &GData.FinalMinCoringResult));
+            }
+            if (_AmbaItuner_Check_Reg(ITUNER_FINAL_SCALE_CORING, SPECIAL_USE_NONE)) {
+                CHECK_RET(0,  amba_img_dsp_set_final_sharpen_noise_sharpen_scale_coring(fd_iav, &Mode, &GData.FinalScaleCoring));
+            }
+        }
+
+        if ((((GData.LisoProcessSelect.AdvancedFeaturesEnable == 2) || (GData.LisoProcessSelect.AdvancedFeaturesEnable == 0) || (GData.LisoProcessSelect.AdvancedFeaturesEnable == 3)) && (GData.LisoProcessSelect.UseSharpenNotAsf == 0)) || (GData.LisoProcessSelect.AdvancedFeaturesEnable == 1)) {
+            if (_AmbaItuner_Check_Reg(ITUNER_ASF_INFO, GData.AsfInfo.Enable)) {
+                    CHECK_RET(0,  amba_img_dsp_set_advance_spatial_filter(fd_iav, &Mode, &GData.AsfInfo));
+            }
+        }
+        if ((((GData.LisoProcessSelect.AdvancedFeaturesEnable == 2) || (GData.LisoProcessSelect.AdvancedFeaturesEnable == 0) || (GData.LisoProcessSelect.AdvancedFeaturesEnable == 3)) && (GData.LisoProcessSelect.UseSharpenNotAsf == 1)) || (GData.LisoProcessSelect.AdvancedFeaturesEnable == 1)) {
+            if (_AmbaItuner_Check_Reg(ITUNER_SHARPEN_BOTH, SPECIAL_USE_NONE)) {
+                CHECK_RET(0,  amba_img_dsp_set_1st_sharpen_noise_both(fd_iav, &Mode, &GData.SharpenBoth));
+            }
+            if (_AmbaItuner_Check_Reg(ITUNER_SHARPEN_NOISE, SPECIAL_USE_NONE)) {
+                CHECK_RET(0,  amba_img_dsp_set_1st_sharpen_noise_noise(fd_iav, &Mode, &GData.SharpenNoise));
+            }
+            if (_AmbaItuner_Check_Reg(ITUNER_FIR, SPECIAL_USE_NONE)) {
+                CHECK_RET(0,  amba_img_dsp_set_1st_sharpen_noise_sharpen_fir(fd_iav, &Mode, &GData.Fir));
+            }
+            if (_AmbaItuner_Check_Reg(ITUNER_CORING, SPECIAL_USE_NONE)) {
+                CHECK_RET(0,  amba_img_dsp_set_1st_sharpen_noise_sharpen_coring(fd_iav, &Mode, &GData.Coring));
+            }
+            if (_AmbaItuner_Check_Reg(ITUNER_CORING_INDEX_SCALE, SPECIAL_USE_NONE)) {
+                CHECK_RET(0,  amba_img_dsp_set_1st_sharpen_noise_sharpen_coring_index_scale(fd_iav, &Mode, &GData.CoringIndexScale));
+            }
+            if (_AmbaItuner_Check_Reg(ITUNER_MIN_CORING_RESULT, SPECIAL_USE_NONE)) {
+                CHECK_RET(0,  amba_img_dsp_set_1st_sharpen_noise_sharpen_min_coring_result(fd_iav, &Mode, &GData.MinCoringResult));
+            }
+            if (_AmbaItuner_Check_Reg(ITUNER_SCALE_CORING, SPECIAL_USE_NONE)) {
+                CHECK_RET(0,  amba_img_dsp_set_1st_sharpen_noise_sharpen_scale_coring(fd_iav, &Mode, &GData.ScaleCoring));
+            }
+        }
+
+        if (GData.LisoProcessSelect.AdvancedFeaturesEnable == 3) { // 3-pass LISO
+            if (_AmbaItuner_Check_Reg(ITUNER_MO_DYNAMIC_BAD_PIXEL_CORRECTION, GData.MoDynamicBadPixelCorrection.Enb)) {
+	            CHECK_RET(0,  amba_img_dsp_set_mo_dynamic_bad_pixel_correction(fd_iav, &Mode, &GData.MoDynamicBadPixelCorrection));/*Need to double check*/
+	        }
+	        if (_AmbaItuner_Check_Reg(ITUNER_MO_CFA_LEAKAGE_FILTER, GData.MoCfaLeakageFilter.Enb)) {
+	            CHECK_RET(0,  amba_img_dsp_set_mo_cfa_leakage_filter(fd_iav, &Mode, &GData.MoCfaLeakageFilter));/*Need to double check*/
+	        }
+	        if (_AmbaItuner_Check_Reg(ITUNER_MO_CFA_NOISE_FILTER, GData.MoCfaNoiseFilter.Enb)) {
+	            CHECK_RET(0,  amba_img_dsp_set_mo_cfa_noise_filter(fd_iav, &Mode, &GData.MoCfaNoiseFilter));/*Need to double check*/
+	        }
+	        if (_AmbaItuner_Check_Reg(ITUNER_MO_ANTI_ALIASING_STRENGTH, GData.MoAntiAliasing.Enb)) {
+	            CHECK_RET(0,  amba_img_dsp_set_mo_anti_aliasing(fd_iav, &Mode, &GData.MoAntiAliasing));/*Need to double check*/
+	        }
+            if (_AmbaItuner_Check_Reg(ITUNER_MO_CHROMA_MEDIAN_FILTER, GData.MoChromaMedianFilter.Enable)) {
+	            CHECK_RET(0,  amba_img_dsp_set_mo_chroma_median_filter(fd_iav, &Mode, &GData.MoChromaMedianFilter));
+	        }
+	        if (_AmbaItuner_Check_Reg(ITUNER_MO_DEMOSAIC_FILTER, SPECIAL_USE_NONE)) {
+	            CHECK_RET(0,  amba_img_dsp_set_mo_demosaic(fd_iav, &Mode, &GData.MoDemosaicFilter));
+	        }
+	        if (_AmbaItuner_Check_Reg(ITUNER_MO_GB_GR_MISMATCH, SPECIAL_USE_NONE)) {
+	            CHECK_RET(0,  amba_img_dsp_set_mo_gbgr_mismatch(fd_iav, &Mode, &GData.MoGbGrMismatch));
+	        }
+
+            ////////////////////////////////////////////////////////////////////
+	        if (_AmbaItuner_Check_Reg(ITUNER_MO_SHP_A_OR_SPATIAL_FILTE_SELECT, SPECIAL_USE_NONE)) {
+				amba_img_dsp_liso_process_select_t MoProcessSelect;
+				MoProcessSelect.UseSharpenNotAsf = GData.MoProcessSelect.UseSharpenNotAsf;
+				MoProcessSelect.AdvancedFeaturesEnable = GData.LisoProcessSelect.AdvancedFeaturesEnable;
+	            CHECK_RET(0,  amba_img_dsp_set_mo_luma_processing_mode(fd_iav, &Mode, &MoProcessSelect));
+	        }
+	        if (_AmbaItuner_Check_Reg(ITUNER_MO_CHROMA_FILTER, GData.MoChromaFilter.Enable)) {
+	            CHECK_RET(0,  amba_img_dsp_set_mo_chroma_filter(fd_iav, &Mode, &GData.MoChromaFilter));
+	        }
+
+            if(GData.MoProcessSelect.UseSharpenNotAsf==0){
+				if (_AmbaItuner_Check_Reg(ITUNER_MO_ASF_INFO, GData.MoAsfInfo.Enable)) {
+	                    CHECK_RET(0,  amba_img_dsp_set_mo_advance_spatial_filter(fd_iav, &Mode, &GData.MoAsfInfo));
+	            }
+            }
+			if(GData.MoProcessSelect.UseSharpenNotAsf==1){
+				if (_AmbaItuner_Check_Reg(ITUNER_MO_SHARPEN_BOTH, SPECIAL_USE_NONE)) {
+	                CHECK_RET(0,  amba_img_dsp_set_mo_sharpen_noise_both(fd_iav, &Mode, &GData.MoSharpenBoth));
+	            }
+	            if (_AmbaItuner_Check_Reg(ITUNER_MO_SHARPEN_NOISE, SPECIAL_USE_NONE)) {
+	                CHECK_RET(0,  amba_img_dsp_set_mo_sharpen_noise_noise(fd_iav, &Mode, &GData.MoSharpenNoise));
+	            }
+	            if (_AmbaItuner_Check_Reg(ITUNER_MO_FIR, SPECIAL_USE_NONE)) {
+	                CHECK_RET(0,  amba_img_dsp_set_mo_sharpen_noise_sharpen_fir(fd_iav, &Mode, &GData.MoFir));
+	            }
+	            if (_AmbaItuner_Check_Reg(ITUNER_MO_CORING, SPECIAL_USE_NONE)) {
+	                CHECK_RET(0,  amba_img_dsp_set_mo_sharpen_noise_sharpen_coring(fd_iav, &Mode, &GData.MoCoring));
+	            }
+	            if (_AmbaItuner_Check_Reg(ITUNER_MO_CORING_INDEX_SCALE, SPECIAL_USE_NONE)) {
+	                CHECK_RET(0,  amba_img_dsp_set_mo_sharpen_noise_sharpen_coring_index_scale(fd_iav, &Mode, &GData.MoCoringIndexScale));
+	            }
+	            if (_AmbaItuner_Check_Reg(ITUNER_MO_MIN_CORING_RESULT, SPECIAL_USE_NONE)) {
+	                CHECK_RET(0,  amba_img_dsp_set_mo_sharpen_noise_sharpen_min_coring_result(fd_iav, &Mode, &GData.MoMinCoringResult));
+	            }
+	            if (_AmbaItuner_Check_Reg(ITUNER_MO_SCALE_CORING, SPECIAL_USE_NONE)) {
+	                CHECK_RET(0,  amba_img_dsp_set_mo_sharpen_noise_sharpen_scale_coring(fd_iav, &Mode, &GData.MoScaleCoring));
+	            }
+			}
+        }
+
+
+
+        if (Mode.Pipe == AMBA_DSP_IMG_PIPE_VIDEO) {
+            if (_AmbaItuner_Check_Reg(ITUNER_VIDEO_MCTF, GData.VideoMctf.Enable)) {
+                CHECK_RET(0,  amba_img_dsp_set_video_mctf(fd_iav, &Mode, &GData.VideoMctf));
+            }
+            if (_AmbaItuner_Check_Reg(ITUNER_VIDEO_MCTF_TEMPORAL_ADJUST, SPECIAL_USE_NONE)) {
+                CHECK_RET(0,  amba_img_dsp_set_video_mctf_temporal_adjust(fd_iav, &Mode, &GData.VideoMctfTemporalAdjust));
+            }
+        }
+#if 0
+        if (Mode.Pipe == AMBA_DSP_IMG_PIPE_VIDEO) {
+            if (_AmbaItuner_Check_Reg(ITUNER_VIDEO_MCTF, GData.VideoMctf.Enable)) {
+                CHECK_RET(0,  amba_img_dsp_set_video_mctf( &Mode, &GData.VideoMctf));
+            } else {
+                GData.VideoMctf.Enable = 0;
+                CHECK_RET(0,  amba_img_dsp_set_video_mctf( &Mode, &GData.VideoMctf));
+            }
+            //if (Mode.AlgoMode == AMBA_DSP_IMG_ALGO_MODE_HISO) {
+                if (_AmbaItuner_Check_Reg(ITUNER_FINAL_SHARPEN_BOTH, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetFinalSharpenNoiseBoth(&Mode, &GData.FinalSharpenBoth));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_FINAL_SHARPEN_NOISE, SPECIAL_USE_NONE)) {
+                    ITUNER_DEBF("%s() %d, FinalSharpenNoise fir_strength_dir: %d", __func__, __LINE__, GData.FinalSharpenNoise.SpatialFir.StrengthDir);
+                    CHECK_RET(0,  AmbaDSP_ImgSetFinalSharpenNoiseNoise(&Mode, &GData.FinalSharpenNoise));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_FINALFIR, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetFinalSharpenNoiseSharpenFir(&Mode, &GData.FinalFir));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_FINAL_CORING, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetFinalSharpenNoiseSharpenCoring(&Mode, &GData.FinalCoring));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_FINAL_CORING_INDEX_SCALE, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetFinalSharpenNoiseSharpenCoringIndexScale(&Mode, &GData.FinalCoringIndexScale));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_FINAL_MIN_CORING_RESULT, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetFinalSharpenNoiseSharpenMinCoringResult(&Mode, &GData.FinalMinCoringResult));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_FINAL_SCALE_CORING, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetFinalSharpenNoiseSharpenScaleCoring(&Mode, &GData.FinalScaleCoring));
+                }
+            //}
+        }
+//	else {
+            if (Mode.AlgoMode == AMBA_DSP_IMG_ALGO_MODE_LISO) {
+                if (_AmbaItuner_Check_Reg(ITUNER_FINAL_SHARPEN_BOTH, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetFinalSharpenNoiseBoth(fd_iav, &Mode, &GData.FinalSharpenBoth));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_FINAL_SHARPEN_NOISE, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetFinalSharpenNoiseNoise(fd_iav, &Mode, &GData.FinalSharpenNoise));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_FINALFIR, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetFinalSharpenNoiseSharpenFir(fd_iav, &Mode, &GData.FinalFir));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_FINAL_CORING, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetFinalSharpenNoiseSharpenCoring(fd_iav, &Mode, &GData.FinalCoring));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_FINAL_CORING_INDEX_SCALE, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetFinalSharpenNoiseSharpenCoringIndexScale(fd_iav, &Mode, &GData.FinalCoringIndexScale));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_FINAL_MIN_CORING_RESULT, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetFinalSharpenNoiseSharpenMinCoringResult(fd_iav, &Mode, &GData.FinalMinCoringResult));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_FINAL_SCALE_CORING, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetFinalSharpenNoiseSharpenScaleCoring(fd_iav, &Mode, &GData.FinalScaleCoring));
+                }
+            } else if (Mode.AlgoMode == AMBA_DSP_IMG_ALGO_MODE_HISO) {
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_ANTI_ALIASING_STRENGTH, GData.HisoAntiAliasingStrength)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoAntiAliasing(&Mode, GData.HisoAntiAliasingStrength));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_CFA_LEAKAGE_FILTER, GData.HisoCfaLeakageFilter.Enb)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoCfaLeakageFilter( &Mode, &GData.HisoCfaLeakageFilter));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_DYNAMIC_BAD_PIXEL_CORRECTION, GData.HisoDynamicBadPixelCorrection.Enb)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoDynamicBadPixelCorrection( &Mode, &GData.HisoDynamicBadPixelCorrection));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_CFA_NOISE_FILTER, GData.HisoCfaNoiseFilter.Enb)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoCfaNoiseFilter(&Mode, &GData.HisoCfaNoiseFilter));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_GB_GR_MISMATCH, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoGbGrMismatch( &Mode, &GData.HisoGbGrMismatch));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_DEMOSAIC_FILTER, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoDemosaic( &Mode, &GData.HisoDemosaicFilter));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_CHROMA_MEDIAN_FILTER, GData.HisoChromaMedianFilter.Enable)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoChromaMedianFilter( &Mode, &GData.HisoChromaMedianFilter));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_CDNR, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoColorDependentNoiseReduction(&Mode, &GData.HisoCDNR));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_DEFER_COLOR_CORRECTION, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoDeferColorCorrection(&Mode, &GData.HisoDeferColorCorrection));
+                }
+                //Hiso Asf
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_ASF, GData.HisoAsf.Enable)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoAdvanceSpatialFilter(&Mode, &GData.HisoAsf));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_HIGH_ASF, GData.HisoHighAsf.Enable)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoHighAdvanceSpatialFilter(&Mode, &GData.HisoHighAsf));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_LOW_ASF, GData.HisoLowAsf.Enable)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoLowAdvanceSpatialFilter(&Mode, &GData.HisoLowAsf));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_MED_ASF, GData.HisoMedAsf.Enable)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoMed1AdvanceSpatialFilter(&Mode, &GData.HisoMedAsf));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_LI2ND_ASF, GData.HisoLi2ndAsf.Enable)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoLi2ndAdvanceSpatialFilter(&Mode, &GData.HisoLi2ndAsf));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_CHROMA_ASF, GData.HisoChromaAsf.Enable)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoChromaAdvanceSpatialFilter(&Mode, &GData.HisoChromaAsf));
+                }
+                //Hiso Sharpen hi_high_
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_HIGH_SHARPEN_BOTH, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoHighSharpenNoiseBoth(&Mode, &GData.HisoHighSharpenBoth));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_HIGH_SHARPEN_NOISE, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoHighSharpenNoiseNoise(&Mode, &GData.HisoHighSharpenNoise));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_HIGH_FIR, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoHighSharpenNoiseSharpenFir(&Mode, &GData.HisoHighFir));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_HIGH_CORING, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoHighSharpenNoiseSharpenCoring(&Mode, &GData.HisoHighCoring));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_HIGH_CORING_INDEX_SCALE, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoHighSharpenNoiseSharpenCoringIndexScale(&Mode, &GData.HisoHighCoringIndexScale));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_HIGH_MIN_CORING_RESULT, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoHighSharpenNoiseSharpenMinCoringResult(&Mode, &GData.HisoHighMinCoringResult));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_HIGH_SCALE_CORING, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoHighSharpenNoiseSharpenScaleCoring(&Mode, &GData.HisoHighScaleCoring));
+                }
+                //Hiso Sharpen hi_med_
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_MED_SHARPEN_BOTH, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoMedSharpenNoiseBoth(&Mode, &GData.HisoMedSharpenBoth));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_MED_SHARPEN_NOISE, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoMedSharpenNoiseNoise(&Mode, &GData.HisoMedSharpenNoise));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_MED_FIR, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoMedSharpenNoiseSharpenFir(&Mode, &GData.HisoMedFir));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_MED_CORING, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoMedSharpenNoiseSharpenCoring(&Mode, &GData.HisoMedCoring));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_MED_CORING_INDEX_SCALE, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoMedSharpenNoiseSharpenCoringIndexScale(&Mode, &GData.HisoMedCoringIndexScale));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_MED_MIN_CORING_RESULT, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoMedSharpenNoiseSharpenMinCoringResult(&Mode, &GData.HisoMedMinCoringResult));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_MED_SCALE_CORING, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoMedSharpenNoiseSharpenScaleCoring(&Mode, &GData.HisoMedScaleCoring));
+                }
+                //Hiso Sharpen hili_
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_LISO1_SHARPEN_BOTH, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoLiso1SharpenNoiseBoth(&Mode, &GData.HisoLiso1SharpenBoth));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_LISO1_SHARPEN_NOISE, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoLiso1SharpenNoiseNoise(&Mode, &GData.HisoLiso1SharpenNoise));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_LISO1_FIR, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoLiso1SharpenNoiseSharpenFir(&Mode, &GData.HisoLiso1Fir));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_LISO1_CORING, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoLiso1SharpenNoiseSharpenCoring(&Mode, &GData.HisoLiso1Coring));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_LISO1_CORING_INDEX_SCALE, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoLiso1SharpenNoiseSharpenCoringIndexScale(&Mode, &GData.HisoLiso1CoringIndexScale));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_LISO1_MIN_CORING_RESULT, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoLiso1SharpenNoiseSharpenMinCoringResult(&Mode, &GData.HisoLiso1MinCoringResult));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_LISO1_SCALE_CORING, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoLiso1SharpenNoiseSharpenScaleCoring(&Mode, &GData.HisoLiso1ScaleCoring));
+                }
+                //Hiso Sharpen li_2nd_
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_LISO2_SHARPEN_BOTH, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoLiso2SharpenNoiseBoth(&Mode, &GData.HisoLiso2SharpenBoth));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_LISO2_SHARPEN_NOISE, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoLiso2SharpenNoiseNoise(&Mode, &GData.HisoLiso2SharpenNoise));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_LISO2_FIR, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoLiso2SharpenNoiseSharpenFir(&Mode, &GData.HisoLiso2Fir));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_LISO2_CORING, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoLiso2SharpenNoiseSharpenCoring(&Mode, &GData.HisoLiso2Coring));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_LISO2_CORING_INDEX_SCALE, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoLiso2SharpenNoiseSharpenCoringIndexScale(&Mode, &GData.HisoLiso2CoringIndexScale));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_LISO2_MIN_CORING_RESULT, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoLiso2SharpenNoiseSharpenMinCoringResult(&Mode, &GData.HisoLiso2MinCoringResult));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_LISO2_SCALE_CORING, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgSetHighIsoLiso2SharpenNoiseSharpenScaleCoring(&Mode, &GData.HisoLiso2ScaleCoring));
+                }
+                //Chroma
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_CHROMA_FILTER_HIGH, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoSetChromaFilterHigh(&Mode, &GData.HisoChromaFilterHigh));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_CHROMA_FILTER_LOW_VERY_LOW, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoSetChromaFilterLowVeryLow(&Mode, &GData.HisoChromaFilterLowVeryLow));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_CHROMA_FILTER_PRE, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoSetChromaFilterPre(&Mode, &GData.HisoChromaFilterPre));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_CHROMA_FILTER_MED, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoSetChromaFilterMed(&Mode, &GData.HisoChromaFilterMed));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_CHROMA_FILTER_LOW, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoSetChromaFilterLow(&Mode, &GData.HisoChromaFilterLow));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_CHROMA_FILTER_VERY_LOW, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoSetChromaFilterVeryLow(&Mode, &GData.HisoChromaFilterVeryLow));
+                }
+                //Combine
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_CHROMA_FILTER_MED_COMBINE, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoSetChromaFilterMedCombine(&Mode, &GData.HisoChromaFilterMedCombine));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_CHROMA_FILTER_LOW_COMBINE, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoSetChromaFilterLowCombine(&Mode, &GData.HisoChromaFilterLowCombine));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_CHROMA_FILTER_VERY_LOW_COMBINE, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoSetChromaFilterVeryLowCombine(&Mode, &GData.HisoChromaFilterVeryLowCombine));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_LUMA_NOISE_COMBINE, SPECIAL_USE_NONE )) {
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoSetLumaNoiseCombine(&Mode, &GData.HisoLumaNoiseCombine));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_LOW_ASF_COMBINE, SPECIAL_USE_NONE )) {
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoSetLowASFCombine(&Mode, &GData.HisoLowASFCombine));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HIGH_ISO_COMBINE, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoSetHighIsoCombine(&Mode, &GData.HighIsoCombine));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_FREQ_RECOVER, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoSetHighIsoFreqRecover(&Mode, &GData.HisoFreqRecover));
+                }
+                if (_AmbaItuner_Check_Reg(ITUNER_HISO_LOW2_LUMA_BLEND, SPECIAL_USE_NONE)) {
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoSetHighIsoLumaBlend(&Mode, &GData.HisoLow2LumaBlend));
+                }
+                if(GData.HisoLow2LumaBlend.Enable == 1) {
+                    if (_AmbaItuner_Check_Reg(ITUNER_HISO_LOW2_BLEND_LUMA_LEVEL, SPECIAL_USE_NONE)) {
+                        CHECK_RET(0,  AmbaDSP_ImgHighIsoSetHighIsoBlendLumaLevel(&Mode, &GData.HisoLow2BlendLumaLevel));
+                    }
+                }
+
+                /*{//to hiso batch
+                    amba_img_dsp_mode_cfg_t ModeHisoBatch;
+                    ModeHisoBatch = Mode;
+                    ModeHisoBatch.BatchId = ProcInfo->HisoBatchId;
+                    if (_AmbaItuner_Check_Reg(ITUNER_STATIC_BAD_PIXEL_CORRECTION, GData.StaticBadPixelCorrection.Enable)) {
+                        CHECK_RET(0,  amba_img_dsp_set_static_bad_pixel_correction(fd_iav, ModeHisoBatch, &GData.SbpCorr));
+                    }
+                    CHECK_RET(0,  amba_img_dsp_set_vignette_compensation(fd_iav, ModeHisoBatch));
+//                    CHECK_RET(0,  AmbaDSP_ImgSetWarpCompensation(ModeHisoBatch));
+//                    CHECK_RET(0,  AmbaDSP_ImgSetCawarpCompensation(ModeHisoBatch));
+                }*/
+
+            }
+//        }
+#endif
+    } while (0);
+    return Ret;
+}
+
+int AmbaItuner_Refresh(amba_img_dsp_mode_cfg_t Mode)
+{
+    int Ret = 0;
+    do {
+        /*{
+            amba_img_dsp_aaa_stat_info_t AAA_Stat_Info;
+//            CHECK_RET(0,  AmbaDSP_Img3aGetAaaStatInfo(&Mode, &AAA_Stat_Info));
+            _AmbaItuner_Set_Filter_Valid(ITUNER_AE_STATISTICS_INFO);
+            GData.AeStatisticsInfo.AeTileNumCol = AAA_Stat_Info.AeTileNumCol;
+            GData.AeStatisticsInfo.AeTileNumRow = AAA_Stat_Info.AeTileNumRow;
+            GData.AeStatisticsInfo.AeTileColStart = AAA_Stat_Info.AeTileColStart;
+            GData.AeStatisticsInfo.AeTileRowStart = AAA_Stat_Info.AeTileRowStart;
+            GData.AeStatisticsInfo.AeTileWidth = AAA_Stat_Info.AeTileWidth;
+            GData.AeStatisticsInfo.AeTileHeight = AAA_Stat_Info.AeTileHeight;
+            GData.AeStatisticsInfo.AePixMinValue = AAA_Stat_Info.AePixMinValue;
+            GData.AeStatisticsInfo.AePixMaxValue = AAA_Stat_Info.AePixMaxValue;
+            _AmbaItuner_Set_Filter_Valid(ITUNER_AWB_STATISTICS_INFO);
+            GData.AwbStatisticsInfo.AwbTileNumCol = AAA_Stat_Info.AwbTileNumCol;
+            GData.AwbStatisticsInfo.AwbTileNumRow = AAA_Stat_Info.AwbTileNumRow;
+            GData.AwbStatisticsInfo.AwbTileColStart = AAA_Stat_Info.AwbTileColStart;
+            GData.AwbStatisticsInfo.AwbTileRowStart = AAA_Stat_Info.AwbTileRowStart;
+            GData.AwbStatisticsInfo.AwbTileWidth = AAA_Stat_Info.AwbTileWidth;
+            GData.AwbStatisticsInfo.AwbTileHeight = AAA_Stat_Info.AwbTileHeight;
+            GData.AwbStatisticsInfo.AwbTileActiveWidth = AAA_Stat_Info.AwbTileActiveWidth;
+            GData.AwbStatisticsInfo.AwbTileActiveHeight = AAA_Stat_Info.AwbTileActiveHeight;
+            GData.AwbStatisticsInfo.AwbPixMinValue = AAA_Stat_Info.AwbPixMinValue;
+            GData.AwbStatisticsInfo.AwbPixMaxValue = AAA_Stat_Info.AwbPixMaxValue;
+            _AmbaItuner_Set_Filter_Valid(ITUNER_AF_STATISTICS_INFO);
+            GData.AfStatisticsInfo.AfTileNumCol = AAA_Stat_Info.AfTileNumCol;
+            GData.AfStatisticsInfo.AfTileNumRow = AAA_Stat_Info.AfTileNumRow;
+            GData.AfStatisticsInfo.AfTileColStart = AAA_Stat_Info.AfTileColStart;
+            GData.AfStatisticsInfo.AfTileRowStart = AAA_Stat_Info.AfTileRowStart;
+            GData.AfStatisticsInfo.AfTileWidth = AAA_Stat_Info.AfTileWidth;
+            GData.AfStatisticsInfo.AfTileHeight = AAA_Stat_Info.AfTileHeight;
+            GData.AfStatisticsInfo.AfTileActiveWidth = AAA_Stat_Info.AfTileActiveWidth;
+            GData.AfStatisticsInfo.AfTileActiveHeight = AAA_Stat_Info.AfTileActiveHeight;
+        }*/
+        {// Note: static_bad_pixel_correction
+            CHECK_RET(0,  amba_img_dsp_get_static_bad_pixel_correction(&Mode, &GData.SbpCorr));
+            // TODO: Need to check , warp will use it
+            _AmbaItuner_Set_Filter_Valid(ITUNER_SYSTEM_INFO);
+            _System.RawStartX = GData.SbpCorr.CurrentVinSensorGeo.StartX;
+            _System.RawStartY = GData.SbpCorr.CurrentVinSensorGeo.StartY;
+            _System.HSubSampleFactorNum = GData.SbpCorr.CurrentVinSensorGeo.HSubSample.FactorNum;
+            _System.HSubSampleFactorDen = GData.SbpCorr.CurrentVinSensorGeo.HSubSample.FactorDen;
+            _System.VSubSampleFactorNum = GData.SbpCorr.CurrentVinSensorGeo.VSubSample.FactorNum;
+            _System.VSubSampleFactorDen = GData.SbpCorr.CurrentVinSensorGeo.VSubSample.FactorDen;
+            _System.RawWidth = GData.SbpCorr.CurrentVinSensorGeo.Width;
+            _System.RawHeight = GData.SbpCorr.CurrentVinSensorGeo.Height;
+			CHECK_RET(0,  amba_img_dsp_get_vin_sensor_info(&Mode, &GData.SensorInfo));
+			_System.RawBayer = GData.SensorInfo.SensorPattern;
+			_System.RawResolution = GData.SensorInfo.SensorResolution;
+			_System.SensorReadoutMode = GData.SensorInfo.SensorReadOutMode;
+			_AmbaItuner_Set_Filter_Valid(ITUNER_STATIC_BAD_PIXEL_CORRECTION);
+            GData.StaticBadPixelCorrection.Enable = GData.SbpCorr.Enb;
+            GData.StaticBadPixelCorrection.CalibVersion = GData.SbpCorr.CalibSbpInfo.Version;
+            GData.StaticBadPixelCorrection.CailbVinStartX = GData.SbpCorr.CalibSbpInfo.VinSensorGeo.StartX;
+            GData.StaticBadPixelCorrection.CailbVinStartY = GData.SbpCorr.CalibSbpInfo.VinSensorGeo.StartY;
+            GData.StaticBadPixelCorrection.CailbVinWidth = GData.SbpCorr.CalibSbpInfo.VinSensorGeo.Width;
+            GData.StaticBadPixelCorrection.CailbVinHeight = GData.SbpCorr.CalibSbpInfo.VinSensorGeo.Height;
+            GData.StaticBadPixelCorrection.CailbVinHSubSampleFactorNum = GData.SbpCorr.CalibSbpInfo.VinSensorGeo.HSubSample.FactorNum;
+            GData.StaticBadPixelCorrection.CailbVinHSubSampleFactorDen = GData.SbpCorr.CalibSbpInfo.VinSensorGeo.HSubSample.FactorDen;
+            GData.StaticBadPixelCorrection.CailbVinVSubSampleFactorNum = GData.SbpCorr.CalibSbpInfo.VinSensorGeo.VSubSample.FactorNum;
+            GData.StaticBadPixelCorrection.CailbVinVSubSampleFactorDen = GData.SbpCorr.CalibSbpInfo.VinSensorGeo.VSubSample.FactorDen;
+            ITUNER_DEBF("%s() %d, X : %d, Y: %d", __func__, __LINE__, GData.SbpCorr.CalibSbpInfo.VinSensorGeo.StartX, GData.SbpCorr.CalibSbpInfo.VinSensorGeo.StartY);
+        }
+
+
+        {// Note: vignette_compensation
+            CHECK_RET(0,  amba_img_dsp_get_vignette_compensation(&Mode, &GData.VignetteCalcInfo));
+            _AmbaItuner_Set_Filter_Valid(ITUNER_VIGNETTE_COMPENSATION);
+            GData.VignetteCompensation.CalibVinWidth = (GData.VignetteCalcInfo.CurrentVinSensorGeo.StartX << 1) + _System.RawWidth; //GData.VignetteCalcInfo.CurrentVinSensorGeo.StartX = (GData.VignetteCompensation.CalibVinWidth - RawWidth)>>1;
+            GData.VignetteCompensation.CalibVinHeight = (GData.VignetteCalcInfo.CurrentVinSensorGeo.StartY << 1) + _System.RawHeight; //GData.VignetteCalcInfo.CurrentVinSensorGeo.StartY = (GData.VignetteCompensation.CalibVinHeight - RawHeight)>>1;
+            //_System.RawWidth = GData.VignetteCalcInfo.CurrentVinSensorGeo.Width;
+            //_System.RawHeight = GData.VignetteCalcInfo.CurrentVinSensorGeo.Height;
+            //_System.HSubSampleFactorNum = GData.VignetteCalcInfo.CurrentVinSensorGeo.HSubSample.FactorNum;
+            //_System.HSubSampleFactorDen = GData.VignetteCalcInfo.CurrentVinSensorGeo.HSubSample.FactorDen;
+            //_System.VSubSampleFactorNum = GData.VignetteCalcInfo.CurrentVinSensorGeo.VSubSample.FactorNum;
+            //_System.VSubSampleFactorDen = GData.VignetteCalcInfo.CurrentVinSensorGeo.VSubSample.FactorDen;
+
+            GData.VignetteCompensation.Enable = GData.VignetteCalcInfo.Enb;
+            GData.VignetteCompensation.GainShift = GData.VignetteCalcInfo.GainShift;
+            GData.VignetteCompensation.Strength = GData.VignetteCalcInfo.VigStrength;
+            GData.VignetteCompensation.CalibVersion = GData.VignetteCalcInfo.CalibVignetteInfo.Version;
+            GData.VignetteCompensation.CalibTableWidth = GData.VignetteCalcInfo.CalibVignetteInfo.TableWidth;
+            GData.VignetteCompensation.CalibTableHeight = GData.VignetteCalcInfo.CalibVignetteInfo.TableHeight;
+            GData.VignetteCompensation.CalibVinStartX = GData.VignetteCalcInfo.CalibVignetteInfo.CalibVinSensorGeo.StartX;
+            GData.VignetteCompensation.CalibVinStartY = GData.VignetteCalcInfo.CalibVignetteInfo.CalibVinSensorGeo.StartY;
+            GData.VignetteCompensation.CalibVinWidth = GData.VignetteCalcInfo.CalibVignetteInfo.CalibVinSensorGeo.Width;
+            GData.VignetteCompensation.CalibVinHeight = GData.VignetteCalcInfo.CalibVignetteInfo.CalibVinSensorGeo.Height;
+            GData.VignetteCompensation.CailbVinHSubSampleFactorNum = GData.VignetteCalcInfo.CalibVignetteInfo.CalibVinSensorGeo.HSubSample.FactorNum;
+            GData.VignetteCompensation.CailbVinHSubSampleFactorDen= GData.VignetteCalcInfo.CalibVignetteInfo.CalibVinSensorGeo.HSubSample.FactorDen;
+            GData.VignetteCompensation.CailbVinVSubSampleFactorNum = GData.VignetteCalcInfo.CalibVignetteInfo.CalibVinSensorGeo.VSubSample.FactorNum;
+            GData.VignetteCompensation.CailbVinVSubSampleFactorDen = GData.VignetteCalcInfo.CalibVignetteInfo.CalibVinSensorGeo.VSubSample.FactorDen;
+    //        GData.VignetteCalcInfo.CalibVignetteInfo.pVignetteRedGain = (UINT16 *)(VignetteTable       + (65*49*2*0));
+    //        GData.VignetteCalcInfo.CalibVignetteInfo.pVignetteGreenEvenGain = (UINT16 *)(VignetteTable + (65*49*2*1));
+    //        GData.VignetteCalcInfo.CalibVignetteInfo.pVignetteGreenOddGain = (UINT16 *)(VignetteTable  + (65*49*2*2));
+    //        GData.VignetteCalcInfo.CalibVignetteInfo.pVignetteBlueGain = (UINT16 *)(VignetteTable      + (65*49*2*3));
+        }
+
+        {// Note: warp_compensation
+//            CHECK_RET(0,  AmbaDSP_ImgGetWarpCompensation(&Mode, &GData.WarpCalcInfo));
+            _AmbaItuner_Set_Filter_Valid(ITUNER_WARP_COMPENSATION);
+            GData.WarpCompensation.Enable = GData.WarpCalcInfo.WarpEnb;
+            GData.WarpCompensation.CalibVersion = GData.WarpCalcInfo.CalibWarpInfo.Version;
+            GData.WarpCompensation.HorizontalGridNumber = GData.WarpCalcInfo.CalibWarpInfo.HorGridNum;
+            GData.WarpCompensation.VerticalGridNumber = GData.WarpCalcInfo.CalibWarpInfo.VerGridNum;
+            GData.WarpCompensation.TileWidthExponent = GData.WarpCalcInfo.CalibWarpInfo.TileWidthExp;
+            GData.WarpCompensation.TileHeightExponent = GData.WarpCalcInfo.CalibWarpInfo.TileHeightExp;
+            GData.WarpCompensation.VinSensorStartX = GData.WarpCalcInfo.CalibWarpInfo.VinSensorGeo.StartX;
+            GData.WarpCompensation.VinSensorStartY = GData.WarpCalcInfo.CalibWarpInfo.VinSensorGeo.StartY;
+            GData.WarpCompensation.VinSensorWidth = GData.WarpCalcInfo.CalibWarpInfo.VinSensorGeo.Width;
+            GData.WarpCompensation.VinSensorHeight = GData.WarpCalcInfo.CalibWarpInfo.VinSensorGeo.Height;
+            GData.WarpCompensation.VinSensorHSubSampleFactorNum = GData.WarpCalcInfo.CalibWarpInfo.VinSensorGeo.HSubSample.FactorNum;
+            GData.WarpCompensation.VinSensorHSubSampleFactorDen = GData.WarpCalcInfo.CalibWarpInfo.VinSensorGeo.HSubSample.FactorDen;
+            GData.WarpCompensation.VinSensorVSubSampleFactorNum = GData.WarpCalcInfo.CalibWarpInfo.VinSensorGeo.VSubSample.FactorNum;
+            GData.WarpCompensation.VinSensorVSubSampleFactorDen = GData.WarpCalcInfo.CalibWarpInfo.VinSensorGeo.VSubSample.FactorDen;
+            //_System.MainWidth = GData.WarpCalcInfo.MainWinDim.Width;
+            //_System.MainHeight = GData.WarpCalcInfo.MainWinDim.Height;
+            //_System.RawStartX = GData.WarpCalcInfo.VinSensorGeo.StartX;
+            //_System.RawStartY = GData.WarpCalcInfo.VinSensorGeo.StartY;
+            //_System.RawWidth = GData.WarpCalcInfo.VinSensorGeo.Width;
+            //_System.RawHeight = GData.WarpCalcInfo.VinSensorGeo.Height;
+            //_System.HSubSampleFactorNum = GData.WarpCalcInfo.VinSensorGeo.HSubSample.FactorNum;
+            //_System.HSubSampleFactorDen = GData.WarpCalcInfo.VinSensorGeo.HSubSample.FactorDen;
+            //_System.VSubSampleFactorNum = GData.WarpCalcInfo.VinSensorGeo.VSubSample.FactorNum;
+            //_System.VSubSampleFactorDen = GData.WarpCalcInfo.VinSensorGeo.VSubSample.FactorDen;
+
+            //HENRY TBD Get Dzoom Enable AmbaDSP_ImgGetDzoom
+            _AmbaItuner_Set_Filter_Valid(ITUNER_DZOOM);
+            if ((GData.WarpCalcInfo.R2rOutWinDim.Width == _System.RawWidth) && (GData.WarpCalcInfo.R2rOutWinDim.Height == _System.RawHeight)) {
+                GData.Dzoom.Enable = 0;
+            } else {
+                GData.Dzoom.Enable = 1;
+                GData.Dzoom.R2rOutputWidth = GData.WarpCalcInfo.R2rOutWinDim.Width;
+                GData.Dzoom.R2rOutputHeigh = GData.WarpCalcInfo.R2rOutWinDim.Height;
+                GData.Dzoom.DummyWindowLeftX = GData.WarpCalcInfo.DmyWinGeo.StartX;
+                GData.Dzoom.DummyWindowTopY = GData.WarpCalcInfo.DmyWinGeo.StartY;
+                GData.Dzoom.DummyWindowWidth = GData.WarpCalcInfo.DmyWinGeo.Width;
+                GData.Dzoom.DummyWindowHeight = GData.WarpCalcInfo.DmyWinGeo.Height;
+                GData.Dzoom.CfaOutputWidth = GData.WarpCalcInfo.CfaWinDim.Width;
+                GData.Dzoom.CfaOutputHeight = GData.WarpCalcInfo.CfaWinDim.Height;
+                GData.Dzoom.ActualLeftTopX = GData.WarpCalcInfo.ActWinCrop.LeftTopX;
+                GData.Dzoom.ActualLeftTopY = GData.WarpCalcInfo.ActWinCrop.LeftTopY;
+                GData.Dzoom.ActualRightBotX = GData.WarpCalcInfo.ActWinCrop.RightBotX;
+                GData.Dzoom.ActualRightBotY = GData.WarpCalcInfo.ActWinCrop.RightBotY;
+                GData.Dzoom.HorSkewPhaseInc = GData.WarpCalcInfo.HorSkewPhaseInc;
+            }
+        }
+        {// Note: chromatic_aberration_correction
+//            CHECK_RET(0,  AmbaDSP_ImgGetCawarpCompensation(&Mode, &GData.CACalcInfo));
+            _AmbaItuner_Set_Filter_Valid(ITUNER_CHROMA_ABERRATION_INFO);
+            GData.ChromaAberrationInfo.Enable = GData.CACalcInfo.CaWarpEnb;
+            GData.ChromaAberrationInfo.CalibVersion = GData.CACalcInfo.CalibCaWarpInfo.Version;
+            GData.ChromaAberrationInfo.HorizontalGridNumber = GData.CACalcInfo.CalibCaWarpInfo.HorGridNum;
+            GData.ChromaAberrationInfo.VerticalGridNumber = GData.CACalcInfo.CalibCaWarpInfo.VerGridNum;
+            GData.ChromaAberrationInfo.TileWidthExponent = GData.CACalcInfo.CalibCaWarpInfo.TileWidthExp;
+            GData.ChromaAberrationInfo.TileHeightExponent = GData.CACalcInfo.CalibCaWarpInfo.TileHeightExp;
+            GData.ChromaAberrationInfo.VinSensorStartX = GData.CACalcInfo.CalibCaWarpInfo.VinSensorGeo.StartX;
+            GData.ChromaAberrationInfo.VinSensorStartY = GData.CACalcInfo.CalibCaWarpInfo.VinSensorGeo.StartY;
+            GData.ChromaAberrationInfo.VinSensorWidth = GData.CACalcInfo.CalibCaWarpInfo.VinSensorGeo.Width;
+            GData.ChromaAberrationInfo.VinSensorHeight = GData.CACalcInfo.CalibCaWarpInfo.VinSensorGeo.Height;
+            GData.ChromaAberrationInfo.VinSensorHSubSampleFactorNum = GData.CACalcInfo.CalibCaWarpInfo.VinSensorGeo.HSubSample.FactorNum;
+            GData.ChromaAberrationInfo.VinSensorHSubSampleFactorDen = GData.CACalcInfo.CalibCaWarpInfo.VinSensorGeo.HSubSample.FactorDen;
+            GData.ChromaAberrationInfo.VinSensorVSubSampleFactorNum = GData.CACalcInfo.CalibCaWarpInfo.VinSensorGeo.VSubSample.FactorNum;
+            GData.ChromaAberrationInfo.VinSensorVSubSampleFactorDen = GData.CACalcInfo.CalibCaWarpInfo.VinSensorGeo.VSubSample.FactorDen;
+            GData.ChromaAberrationInfo.RedScaleFactor = GData.CACalcInfo.CalibCaWarpInfo.RedScaleFactor;
+            GData.ChromaAberrationInfo.BlueScaleFactor = GData.CACalcInfo.CalibCaWarpInfo.BlueScaleFactor;
+
+             //_System.RawStartX = GData.CACalcInfo.VinSensorGeo.StartX;
+             //_System.RawStartY = GData.CACalcInfo.VinSensorGeo.StartY;
+             //_System.RawWidth = GData.CACalcInfo.VinSensorGeo.Width;
+             //_System.RawHeight = GData.CACalcInfo.VinSensorGeo.Height;
+             //_System.HSubSampleFactorNum = GData.CACalcInfo.VinSensorGeo.HSubSample.FactorNum;
+             //_System.HSubSampleFactorDen = GData.CACalcInfo.VinSensorGeo.HSubSample.FactorDen;
+             //_System.VSubSampleFactorNum = GData.CACalcInfo.VinSensorGeo.VSubSample.FactorNum;
+             //_System.VSubSampleFactorDen = GData.CACalcInfo.VinSensorGeo.VSubSample.FactorDen;
+             GData.WarpCalcInfo.R2rOutWinDim = GData.CACalcInfo.R2rOutWinDim;
+             GData.WarpCalcInfo.DmyWinGeo = GData.CACalcInfo.DmyWinGeo;
+             GData.WarpCalcInfo.CfaWinDim = GData.CACalcInfo.CfaWinDim;
+        }
+        {// Note: color_correction
+            CHECK_RET(0,  amba_img_dsp_get_color_correction_reg(&Mode, &GData.CcReg));
+            CHECK_RET(0,  amba_img_dsp_get_color_correction(&Mode, &GData.CcThreeD));
+            _AmbaItuner_Set_Filter_Valid(ITUNER_COLOR_CORRECTION);
+        }
+        {// Note: static_black_level
+            CHECK_RET(0,  amba_img_dsp_get_static_black_level(&Mode, &GData.StaticBlackLevel));
+            _AmbaItuner_Set_Filter_Valid(ITUNER_STATIC_BLACK_LEVEL);
+        }
+        {// Note: wb_gains
+            _AmbaItuner_Set_Filter_Valid(ITUNER_WB_GAIN);
+            CHECK_RET(0,  amba_img_dsp_get_wb_gain(&Mode, &GData.WbGain));/*OK*/
+            _AmbaItuner_Set_Filter_Valid(ITUNER_AE_INFO);
+            GData.AeInfo.Dgain = GData.WbGain.AeGain;
+            _AmbaItuner_Set_Filter_Valid(ITUNER_GLOBAL_DGAIN);
+            GData.GlobalDgain = GData.WbGain.GlobalDGain;
+        }
+        {// Note: deferred_black_level
+            CHECK_RET(0,  amba_img_dsp_get_deferred_black_level(&Mode, &GData.DeferredBlackLevel));
+            _AmbaItuner_Set_Filter_Valid(ITUNER_DEFERRED_BLACK_LEVEL);
+        }
+        {
+            _AmbaItuner_Set_Filter_Valid(ITUNER_DYNAMIC_BAD_PIXEL_CORRECTION);
+            CHECK_RET(0,  amba_img_dsp_get_dynamic_bad_pixel_correction(&Mode, &GData.DynamicBadPixelCorrection));/*Need to double check*/
+        }
+        {// Note: li_cfa_leakage_filter
+            _AmbaItuner_Set_Filter_Valid(ITUNER_CFA_LEAKAGE_FILTER);
+            CHECK_RET(0,  amba_img_dsp_get_cfa_leakage_filter(&Mode, &GData.CfaLeakageFilter));/*Need to double check*/
+        }
+        {// Note: li_cfa_noise_filter
+            _AmbaItuner_Set_Filter_Valid(ITUNER_CFA_NOISE_FILTER);
+            CHECK_RET(0,  amba_img_dsp_get_cfa_noise_filter(&Mode, &GData.CfaNoiseFilter));/*Need to double check*/
+        }
+        {// Note: li_anti_aliasing
+            _AmbaItuner_Set_Filter_Valid(ITUNER_ANTI_ALIASING_STRENGTH);
+            CHECK_RET(0,  amba_img_dsp_get_anti_aliasing(&Mode, &GData.AntiAliasing));/*Need to double check*/
+        }
+        {// Note: dgain_saturation_level
+            _AmbaItuner_Set_Filter_Valid(ITUNER_DGAIN_SATURATION_LEVEL);
+            CHECK_RET(0,  amba_img_dsp_get_dgain_saturation_level(&Mode, &GData.DgainSaturationLevel));/*OK*/
+        }
+        {// Note: local_exposure
+            _AmbaItuner_Set_Filter_Valid(ITUNER_LOCAL_EXPOSURE);
+            CHECK_RET(0,  amba_img_dsp_get_local_exposure(&Mode, &GData.LocalExposure));/*Need to double check*/
+        }
+        {// Note: tone_curve
+            _AmbaItuner_Set_Filter_Valid(ITUNER_TONE_CURVE);
+            CHECK_RET(0,  amba_img_dsp_get_tone_curve(&Mode, &GData.ToneCurve));/*Need to double check*/
+        }
+        {// Note: rgb_to_yuv_matrix
+            _AmbaItuner_Set_Filter_Valid(ITUNER_RGB_TO_YUV_MATRIX);
+            CHECK_RET(0,  amba_img_dsp_get_rgb_to_yuv_matrix(&Mode, &GData.RgbToYuvMatrix));/*OK*/
+        }
+        {// Note: chroma_scale
+            _AmbaItuner_Set_Filter_Valid(ITUNER_CHROMA_SCALE);
+            CHECK_RET(0,  amba_img_dsp_get_chroma_scale(&Mode, &GData.ChromaScale));/*Need to double check*/
+        }
+        {// Note: li_chroma_median_filter
+            _AmbaItuner_Set_Filter_Valid(ITUNER_CHROMA_MEDIAN_FILTER);
+            CHECK_RET(0,  amba_img_dsp_get_chroma_median_filter(&Mode, &GData.ChromaMedianFilter));/*Need to double check*/
+        }
+
+        {// Note: li_demosaic
+            _AmbaItuner_Set_Filter_Valid(ITUNER_DEMOSAIC_FILTER);
+            CHECK_RET(0,  amba_img_dsp_get_demosaic(&Mode, &GData.DemosaicFilter));/*Need to check*/
+        }
+        {// Note: li_gb_gr_mismatch_correct
+            _AmbaItuner_Set_Filter_Valid(ITUNER_GB_GR_MISMATCH);
+            CHECK_RET(0,  amba_img_dsp_get_gbgr_mismatch(&Mode, &GData.GbGrMismatch));/*Need to check*/
+        }
+        {// Note: li_use_1st_sharpen
+            _AmbaItuner_Set_Filter_Valid(ITUNER_SHP_A_OR_SPATIAL_FILTE_SELECT);
+            CHECK_RET(0,  amba_img_dsp_get_luma_processing_mode(&Mode, &GData.LisoProcessSelect));
+        }
+        {// Note: li_color_dependent_luma_noise_reduction
+            _AmbaItuner_Set_Filter_Valid(ITUNER_CDNR);
+            CHECK_RET(0,  amba_img_dsp_get_color_dependent_noise_reduction(&Mode, &GData.CDNR));/*Need to check*/
+        }
+        {// Note: li_chroma_filter
+            _AmbaItuner_Set_Filter_Valid(ITUNER_CHROMA_FILTER);
+            CHECK_RET(0,  amba_img_dsp_get_chroma_filter(&Mode, &GData.ChromaFilter));/*OK*/
+        }
+
+		if (GData.LisoProcessSelect.AdvancedFeaturesEnable == 2) { // 2-pass LISO
+			// wide chroma filter
+			_AmbaItuner_Set_Filter_Valid(ITUNER_WIDE_CHROMA_FILTER);
+			CHECK_RET(0,  amba_img_dsp_get_wide_chroma_filter(&Mode, &GData.WideChromaFilter));
+
+			// wide chroma filter combine
+			_AmbaItuner_Set_Filter_Valid(ITUNER_WIDE_CHROMA_FILTER_COMBINE);
+			CHECK_RET(0,  amba_img_dsp_get_wide_chroma_filter_combine(&Mode, &GData.WideChromaFilterCombine));
+
+			_AmbaItuner_Set_Filter_Valid(ITUNER_FINAL_SHARPEN_BOTH);
+			CHECK_RET(0,  amba_img_dsp_get_final_sharpen_noise_both(&Mode, &GData.FinalSharpenBoth));
+
+			_AmbaItuner_Set_Filter_Valid(ITUNER_FINAL_SHARPEN_NOISE);
+			CHECK_RET(0,  amba_img_dsp_get_final_sharpen_noise_noise(&Mode, &GData.FinalSharpenNoise));
+
+			_AmbaItuner_Set_Filter_Valid(ITUNER_FINAL_FIR);
+			CHECK_RET(0,  amba_img_dsp_get_final_sharpen_noise_sharpen_fir(&Mode, &GData.FinalFir));
+
+			_AmbaItuner_Set_Filter_Valid(ITUNER_FINAL_CORING);
+			CHECK_RET(0,  amba_img_dsp_get_final_sharpen_noise_sharpen_coring(&Mode, &GData.FinalCoring));
+
+			_AmbaItuner_Set_Filter_Valid(ITUNER_FINAL_CORING_INDEX_SCALE);
+			CHECK_RET(0,  amba_img_dsp_get_final_sharpen_noise_sharpen_coring_index_scale(&Mode, &GData.FinalCoringIndexScale));
+
+			_AmbaItuner_Set_Filter_Valid(ITUNER_FINAL_MIN_CORING_RESULT);
+			CHECK_RET(0,  amba_img_dsp_get_final_sharpen_noise_sharpen_min_coring_result(&Mode, &GData.FinalMinCoringResult));
+
+			_AmbaItuner_Set_Filter_Valid(ITUNER_FINAL_SCALE_CORING);
+			CHECK_RET(0,  amba_img_dsp_get_final_sharpen_noise_sharpen_scale_coring(&Mode, &GData.FinalScaleCoring));
+		}
+        if ((((GData.LisoProcessSelect.AdvancedFeaturesEnable == 2) || (GData.LisoProcessSelect.AdvancedFeaturesEnable == 0) || (GData.LisoProcessSelect.AdvancedFeaturesEnable == 3)) && (GData.LisoProcessSelect.UseSharpenNotAsf == 0)) || (GData.LisoProcessSelect.AdvancedFeaturesEnable == 1)) {
+            // Note: li_advanced_spatial_filter
+            _AmbaItuner_Set_Filter_Valid(ITUNER_ASF_INFO);
+            CHECK_RET(0,  amba_img_dsp_get_advance_spatial_filter(&Mode, &GData.AsfInfo));
+        } else if ((((GData.LisoProcessSelect.AdvancedFeaturesEnable == 2) || (GData.LisoProcessSelect.AdvancedFeaturesEnable == 0) || (GData.LisoProcessSelect.AdvancedFeaturesEnable == 3)) && (GData.LisoProcessSelect.UseSharpenNotAsf == 1)) || (GData.LisoProcessSelect.AdvancedFeaturesEnable == 1)){
+            // Note: li_sharpen_noise_filter_both
+            _AmbaItuner_Set_Filter_Valid(ITUNER_SHARPEN_BOTH);
+            CHECK_RET(0,  amba_img_dsp_get_1st_sharpen_noise_both(&Mode, &GData.SharpenBoth));
+            // Note: li_sharpen_noise_filter_noise
+            _AmbaItuner_Set_Filter_Valid(ITUNER_SHARPEN_NOISE);
+            CHECK_RET(0,  amba_img_dsp_get_1st_sharpen_noise_noise(&Mode, &GData.SharpenNoise));
+            // Note: li_sharpen_noise_filter_sharpen
+            _AmbaItuner_Set_Filter_Valid(ITUNER_FIR);
+            CHECK_RET(0,  amba_img_dsp_get_1st_sharpen_noise_sharpen_fir(&Mode, &GData.Fir));
+            // Note: li_sharpen_noise_filter_sharpen_coring
+            _AmbaItuner_Set_Filter_Valid(ITUNER_CORING);
+            CHECK_RET(0,  amba_img_dsp_get_1st_sharpen_noise_sharpen_coring(&Mode, &GData.Coring));
+            // Note: li_sharpen_noise_filter_sharpen_coring_index_scale
+            _AmbaItuner_Set_Filter_Valid(ITUNER_CORING_INDEX_SCALE);
+            CHECK_RET(0,  amba_img_dsp_get_1st_sharpen_noise_sharpen_coring_index_scale(&Mode, &GData.CoringIndexScale));
+            // Note: li_sharpen_noise_filter_sharpen_min_coring_result
+            _AmbaItuner_Set_Filter_Valid(ITUNER_MIN_CORING_RESULT);
+            CHECK_RET(0,  amba_img_dsp_get_1st_sharpen_noise_sharpen_min_coring_result(&Mode, &GData.MinCoringResult));
+            // Note: li_sharpen_noise_filter_sharpen_scale_coring
+            _AmbaItuner_Set_Filter_Valid(ITUNER_SCALE_CORING);
+            CHECK_RET(0,  amba_img_dsp_get_1st_sharpen_noise_sharpen_scale_coring(&Mode, &GData.ScaleCoring));
+        }
+		if (GData.LisoProcessSelect.AdvancedFeaturesEnable == 3) { // 3-pass LISO
+				_AmbaItuner_Set_Filter_Valid(ITUNER_MO_DYNAMIC_BAD_PIXEL_CORRECTION);
+	            CHECK_RET(0,  amba_img_dsp_get_mo_dynamic_bad_pixel_correction(&Mode, &GData.MoDynamicBadPixelCorrection));/*Need to double check*/
+
+				_AmbaItuner_Set_Filter_Valid(ITUNER_MO_CFA_LEAKAGE_FILTER);
+	            CHECK_RET(0,  amba_img_dsp_get_mo_cfa_leakage_filter(&Mode, &GData.MoCfaLeakageFilter));/*Need to double check*/
+
+				_AmbaItuner_Set_Filter_Valid(ITUNER_MO_CFA_NOISE_FILTER);
+	            CHECK_RET(0,  amba_img_dsp_get_mo_cfa_noise_filter(&Mode, &GData.MoCfaNoiseFilter));/*Need to double check*/
+
+				_AmbaItuner_Set_Filter_Valid(ITUNER_MO_ANTI_ALIASING_STRENGTH);
+	            CHECK_RET(0,  amba_img_dsp_get_mo_anti_aliasing(&Mode, &GData.MoAntiAliasing));/*Need to double check*/
+
+				_AmbaItuner_Set_Filter_Valid(ITUNER_MO_CHROMA_MEDIAN_FILTER);
+	            CHECK_RET(0,  amba_img_dsp_get_mo_chroma_median_filter(&Mode, &GData.MoChromaMedianFilter));
+
+				_AmbaItuner_Set_Filter_Valid(ITUNER_MO_DEMOSAIC_FILTER);
+	            CHECK_RET(0,  amba_img_dsp_get_mo_demosaic(&Mode, &GData.MoDemosaicFilter));
+
+				_AmbaItuner_Set_Filter_Valid(ITUNER_MO_GB_GR_MISMATCH);
+	            CHECK_RET(0,  amba_img_dsp_get_mo_gbgr_mismatch(&Mode, &GData.MoGbGrMismatch));
+
+            ////////////////////////////////////////////////////////////////////
+				_AmbaItuner_Set_Filter_Valid(ITUNER_MO_SHP_A_OR_SPATIAL_FILTE_SELECT);
+				amba_img_dsp_liso_process_select_t MoProcessSelect;
+				MoProcessSelect.UseSharpenNotAsf = GData.MoProcessSelect.UseSharpenNotAsf;
+				MoProcessSelect.AdvancedFeaturesEnable = GData.LisoProcessSelect.AdvancedFeaturesEnable;
+	            CHECK_RET(0,  amba_img_dsp_get_mo_luma_processing_mode(&Mode, &MoProcessSelect));
+
+				_AmbaItuner_Set_Filter_Valid(ITUNER_MO_CHROMA_FILTER);
+	            CHECK_RET(0,  amba_img_dsp_get_mo_chroma_filter(&Mode, &GData.MoChromaFilter));
+
+            if(GData.MoProcessSelect.UseSharpenNotAsf==0){
+				_AmbaItuner_Set_Filter_Valid(ITUNER_MO_ASF_INFO);
+                CHECK_RET(0,  amba_img_dsp_get_mo_advance_spatial_filter(&Mode, &GData.MoAsfInfo));
+            }
+			if(GData.MoProcessSelect.UseSharpenNotAsf==1){
+				_AmbaItuner_Set_Filter_Valid(ITUNER_MO_SHARPEN_BOTH);
+                CHECK_RET(0,  amba_img_dsp_get_mo_sharpen_noise_both(&Mode, &GData.MoSharpenBoth));
+
+				_AmbaItuner_Set_Filter_Valid(ITUNER_MO_SHARPEN_NOISE);
+                CHECK_RET(0,  amba_img_dsp_get_mo_sharpen_noise_noise(&Mode, &GData.MoSharpenNoise));
+
+				_AmbaItuner_Set_Filter_Valid(ITUNER_MO_FIR);
+                CHECK_RET(0,  amba_img_dsp_get_mo_sharpen_noise_sharpen_fir(&Mode, &GData.MoFir));
+
+				_AmbaItuner_Set_Filter_Valid(ITUNER_MO_CORING);
+                CHECK_RET(0,  amba_img_dsp_get_mo_sharpen_noise_sharpen_coring(&Mode, &GData.MoCoring));
+
+				_AmbaItuner_Set_Filter_Valid(ITUNER_MO_CORING_INDEX_SCALE);
+                CHECK_RET(0,  amba_img_dsp_get_mo_sharpen_noise_sharpen_coring_index_scale(&Mode, &GData.MoCoringIndexScale));
+
+				_AmbaItuner_Set_Filter_Valid(ITUNER_MO_MIN_CORING_RESULT);
+                CHECK_RET(0,  amba_img_dsp_get_mo_sharpen_noise_sharpen_min_coring_result(&Mode, &GData.MoMinCoringResult));
+
+				_AmbaItuner_Set_Filter_Valid(ITUNER_MO_SCALE_CORING);
+                CHECK_RET(0,  amba_img_dsp_get_mo_sharpen_noise_sharpen_scale_coring(&Mode, &GData.MoScaleCoring));
+			}
+        }
+
+        if (Mode.Pipe == AMBA_DSP_IMG_PIPE_VIDEO) {
+            {// Note: video_mctf
+                _AmbaItuner_Set_Filter_Valid(ITUNER_VIDEO_MCTF);
+                CHECK_RET(0,  amba_img_dsp_get_video_mctf(&Mode, &GData.VideoMctf));
+
+				_AmbaItuner_Set_Filter_Valid(ITUNER_VIDEO_MCTF_TEMPORAL_ADJUST);
+				CHECK_RET(0,  amba_img_dsp_get_video_mctf_temporal_adjust(&Mode, &GData.VideoMctfTemporalAdjust));
+            }
+        }
+#if 0
+        if (Mode.Pipe == AMBA_DSP_IMG_PIPE_VIDEO) {
+            {// Note: video_mctf
+                _AmbaItuner_Set_Filter_Valid(ITUNER_VIDEO_MCTF);
+                CHECK_RET(0,  amba_img_dsp_get_video_mctf(&Mode, &GData.VideoMctf));
+            }
+
+            if (Mode.AlgoMode == AMBA_DSP_IMG_ALGO_MODE_HISO) {
+                {// Note: final_sharpen_noise_filter_both
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_FINAL_SHARPEN_BOTH);
+                    CHECK_RET(0,  AmbaDSP_ImgGetFinalSharpenNoiseBoth(&Mode, &GData.FinalSharpenBoth));
+                }
+                {// Note: final_sharpen_noise_filter_noise
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_FINAL_SHARPEN_NOISE);
+                    CHECK_RET(0,  AmbaDSP_ImgGetFinalSharpenNoiseNoise(&Mode, &GData.FinalSharpenNoise));
+                }
+                {// Note: final_sharpen_noise_filter_sharpen
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_FINALFIR);
+                    CHECK_RET(0,  AmbaDSP_ImgGetFinalSharpenNoiseSharpenFir(&Mode, &GData.FinalFir));
+                }
+                {// Note: final_sharpen_noise_filter_sharpen_coring
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_FINAL_CORING);
+                    CHECK_RET(0,  AmbaDSP_ImgGetFinalSharpenNoiseSharpenCoring(&Mode, &GData.FinalCoring));
+                }
+                {// Note: final_sharpen_noise_filter_sharpen_coring_index_scale
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_FINAL_CORING_INDEX_SCALE);
+                    CHECK_RET(0,  AmbaDSP_ImgGetFinalSharpenNoiseSharpenCoringIndexScale(&Mode, &GData.FinalCoringIndexScale));
+                }
+                {// Note: final_sharpen_noise_filter_sharpen_min_coring_result
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_FINAL_MIN_CORING_RESULT);
+                    CHECK_RET(0,  AmbaDSP_ImgGetFinalSharpenNoiseSharpenMinCoringResult(&Mode, &GData.FinalMinCoringResult));
+                }
+                {// Note: final_sharpen_noise_filter_sharpen_scale_coring
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_FINAL_SCALE_CORING);
+                    CHECK_RET(0,  AmbaDSP_ImgGetFinalSharpenNoiseSharpenScaleCoring(&Mode, &GData.FinalScaleCoring));
+                }
+
+           }
+        } else {
+
+            if (Mode.AlgoMode == AMBA_DSP_IMG_ALGO_MODE_LISO) {
+                {// Note: final_sharpen_noise_filter_both
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_FINAL_SHARPEN_BOTH);
+                    CHECK_RET(0,  AmbaDSP_ImgGetFinalSharpenNoiseBoth(&Mode, &GData.FinalSharpenBoth));
+                }
+                {// Note: final_sharpen_noise_filter_noise
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_FINAL_SHARPEN_NOISE);
+                    CHECK_RET(0,  AmbaDSP_ImgGetFinalSharpenNoiseNoise(&Mode, &GData.FinalSharpenNoise));
+                }
+                {// Note: final_sharpen_noise_filter_sharpen
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_FINALFIR);
+                    CHECK_RET(0,  AmbaDSP_ImgGetFinalSharpenNoiseSharpenFir(&Mode, &GData.FinalFir));
+                }
+                {// Note: final_sharpen_noise_filter_sharpen_coring
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_FINAL_CORING);
+                    CHECK_RET(0,  AmbaDSP_ImgGetFinalSharpenNoiseSharpenCoring(&Mode, &GData.FinalCoring));
+                }
+                {// Note: final_sharpen_noise_filter_sharpen_coring_index_scale
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_FINAL_CORING_INDEX_SCALE);
+                    CHECK_RET(0,  AmbaDSP_ImgGetFinalSharpenNoiseSharpenCoringIndexScale(&Mode, &GData.FinalCoringIndexScale));
+                }
+                {// Note: final_sharpen_noise_filter_sharpen_min_coring_result
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_FINAL_MIN_CORING_RESULT);
+                    CHECK_RET(0,  AmbaDSP_ImgGetFinalSharpenNoiseSharpenMinCoringResult(&Mode, &GData.FinalMinCoringResult));
+                }
+                {// Note: final_sharpen_noise_filter_sharpen_scale_coring
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_FINAL_SCALE_CORING);
+                    CHECK_RET(0,  AmbaDSP_ImgGetFinalSharpenNoiseSharpenScaleCoring(&Mode, &GData.FinalScaleCoring));
+                }
+            } else if (Mode.AlgoMode == AMBA_DSP_IMG_ALGO_MODE_HISO) {
+                {// Note: hi_anti_aliasing
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_ANTI_ALIASING_STRENGTH);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoAntiAliasing(&Mode, &GData.HisoAntiAliasingStrength));
+                }
+                {// Note: hi_cfa_leakage_filter
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_CFA_LEAKAGE_FILTER);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoCfaLeakageFilter(&Mode, &GData.HisoCfaLeakageFilter));
+                }
+                {// Note: hi_auto_bad_pixel_correction
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_DYNAMIC_BAD_PIXEL_CORRECTION);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoDynamicBadPixelCorrection(&Mode, &GData.HisoDynamicBadPixelCorrection));
+                }
+                {// Note: hi_cfa_noise_filter
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_CFA_NOISE_FILTER);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoCfaNoiseFilter(&Mode, &GData.HisoCfaNoiseFilter));
+                }
+                {// Note: hi_gb_gr_mismatch_correct
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_GB_GR_MISMATCH);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoGbGrMismatch(&Mode, &GData.HisoGbGrMismatch));
+                }
+                {// Note: hi_demosaic
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_DEMOSAIC_FILTER);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoDemosaic(&Mode, &GData.HisoDemosaicFilter));
+                }
+                {// Note: hi_chroma_median_filter
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_CHROMA_MEDIAN_FILTER);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoChromaMedianFilter(&Mode, &GData.HisoChromaMedianFilter));
+                }
+                {// Note: hi_color_dependent_luma_noise_reduction
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_CDNR);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoColorDependentNoiseReduction(&Mode, &GData.HisoCDNR));
+                }
+                {// Note: hi_defer_cc
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_DEFER_COLOR_CORRECTION);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoDeferColorCorrection(&Mode, &GData.HisoDeferColorCorrection));
+                }
+                {// Note: hi_advanced_spatial_filter
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_ASF);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoAdvanceSpatialFilter(&Mode, &GData.HisoAsf));
+                }
+                {// Note: hi_high_advanced_spatial_filter
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_HIGH_ASF);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoHighAdvanceSpatialFilter(&Mode, &GData.HisoHighAsf));
+                }
+                {// Note: hi_low_advanced_spatial_filter
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_LOW_ASF);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoLowAdvanceSpatialFilter(&Mode, &GData.HisoLowAsf));
+                }
+                {// Note: hi_med1_advanced_spatial_filter
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_MED_ASF);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoMed1AdvanceSpatialFilter(&Mode, &GData.HisoMedAsf));
+                }
+                {// Note: li_2nd_advanced_spatial_filter
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_LI2ND_ASF);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighisoLi2ndAdvanceSpatialFilter(&Mode, &GData.HisoLi2ndAsf));
+                }
+                {// Note: hi_chroma_advanced_spatial_filter
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_CHROMA_ASF);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoChromaAdvanceSpatialFilter(&Mode, &GData.HisoChromaAsf));
+                }
+                {// Note: hi_high_sharpen_noise_filter_both
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_HIGH_SHARPEN_BOTH);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoHighSharpenNoiseBoth(&Mode, &GData.HisoHighSharpenBoth));
+                }
+                {// Note: hi_high_sharpen_noise_filter_noise
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_HIGH_SHARPEN_NOISE);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoHighSharpenNoiseNoise(&Mode, &GData.HisoHighSharpenNoise));
+                }
+                {// Note: hi_high_sharpen_noise_filter_sharpen
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_HIGH_FIR);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoHighSharpenNoiseSharpenFir(&Mode, &GData.HisoHighFir));
+                }
+                {// Note: hi_high_sharpen_noise_filter_sharpen_coring
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_HIGH_CORING);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoHighSharpenNoiseSharpenCoring(&Mode, &GData.HisoHighCoring));
+                }
+                {// Note: hi_high_sharpen_noise_filter_sharpen_coring_index_scale
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_HIGH_CORING_INDEX_SCALE);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoHighSharpenNoiseSharpenCoringIndexScale(&Mode, &GData.HisoHighCoringIndexScale));
+                }
+                {// Note: hi_high_sharpen_noise_filter_sharpen_min_coring_result
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_HIGH_MIN_CORING_RESULT);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoHighSharpenNoiseSharpenMinCoringResult(&Mode, &GData.HisoHighMinCoringResult));
+                }
+                {// Note: hi_high_sharpen_noise_filter_sharpen_scale_coring
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_HIGH_SCALE_CORING);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoHighSharpenNoiseSharpenScaleCoring(&Mode, &GData.HisoHighScaleCoring));
+                }
+                {// Note: hi_med_sharpen_noise_filter_both
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_MED_SHARPEN_BOTH);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoMedSharpenNoiseBoth(&Mode, &GData.HisoMedSharpenBoth));
+                }
+                {// Note: hi_high_sharpen_noise_filter_noise
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_MED_SHARPEN_NOISE);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoMedSharpenNoiseNoise(&Mode, &GData.HisoMedSharpenNoise));
+                }
+                {// Note: hi_med_sharpen_noise_filter_sharpen
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_MED_FIR);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoMedSharpenNoiseSharpenFir(&Mode, &GData.HisoMedFir));
+                }
+                {// Note: hi_med_sharpen_noise_filter_sharpen_coring
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_MED_CORING);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoMedSharpenNoiseSharpenCoring(&Mode, &GData.HisoMedCoring));
+                }
+                {// Note: hi_med_sharpen_noise_filter_sharpen_coring_index_scale
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_MED_CORING_INDEX_SCALE);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoMedSharpenNoiseSharpenCoringIndexScale(&Mode, &GData.HisoMedCoringIndexScale));
+                }
+                {// Note: hi_med_sharpen_noise_filter_sharpen_min_coring_result
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_MED_MIN_CORING_RESULT);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoMedSharpenNoiseSharpenMinCoringResult(&Mode, &GData.HisoMedMinCoringResult));
+                }
+                {// Note: hi_med_sharpen_noise_filter_sharpen_scale_coring
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_MED_SCALE_CORING);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoMedSharpenNoiseSharpenScaleCoring(&Mode, &GData.HisoMedScaleCoring));
+                }
+                {// Note: hili_sharpen_noise_filter_both
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_LISO1_SHARPEN_BOTH);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoLiso1SharpenNoiseBoth(&Mode, &GData.HisoLiso1SharpenBoth));
+                }
+                {// Note: hili_sharpen_noise_filter_noise
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_LISO1_SHARPEN_NOISE);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoLiso1SharpenNoiseNoise(&Mode, &GData.HisoLiso1SharpenNoise));
+                }
+                {// Note: hili_sharpen_noise_filter_sharpen
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_LISO1_FIR);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoLiso1SharpenNoiseSharpenFir(&Mode, &GData.HisoLiso1Fir));
+                }
+                {// Note: hili_sharpen_noise_filter_sharpen_coring
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_LISO1_CORING);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoLiso1SharpenNoiseSharpenCoring(&Mode, &GData.HisoLiso1Coring));
+                }
+                {// Note: hili_sharpen_noise_filter_sharpen_coring_index_scale
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_LISO1_CORING_INDEX_SCALE);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoLiso1SharpenNoiseSharpenCoringIndexScale(&Mode, &GData.HisoLiso1CoringIndexScale));
+                }
+                {// Note: hili_sharpen_noise_filter_sharpen_min_coring_result
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_LISO1_MIN_CORING_RESULT);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoLiso1SharpenNoiseSharpenMinCoringResult(&Mode, &GData.HisoLiso1MinCoringResult));
+                }
+                {// Note: hili_sharpen_noise_filter_sharpen_scale_coring
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_LISO1_SCALE_CORING);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoLiso1SharpenNoiseSharpenScaleCoring(&Mode, &GData.HisoLiso1ScaleCoring));
+                }
+                {// Note: li_2nd_sharpen_noise_filter_both
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_LISO2_SHARPEN_BOTH);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoLiso2SharpenNoiseBoth(&Mode, &GData.HisoLiso2SharpenBoth));
+                }
+                {// Note: li_2nd_sharpen_noise_filter_noise
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_LISO2_SHARPEN_NOISE);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoLiso2SharpenNoiseNoise(&Mode, &GData.HisoLiso2SharpenNoise));
+                }
+                {// Note: li_2nd_sharpen_noise_filter_sharpen
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_LISO2_FIR);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoLiso2SharpenNoiseSharpenFir(&Mode, &GData.HisoLiso2Fir));
+                }
+                {// Note: li_2nd_sharpen_noise_filter_sharpen_coring
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_LISO2_CORING);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoLiso2SharpenNoiseSharpenCoring(&Mode, &GData.HisoLiso2Coring));
+                }
+                {// Note: li_2nd_sharpen_noise_filter_sharpen_coring_index_scale
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_LISO2_CORING_INDEX_SCALE);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoLiso2SharpenNoiseSharpenCoringIndexScale(&Mode, &GData.HisoLiso2CoringIndexScale));
+                }
+                {// Note: li_2nd_sharpen_noise_filter_sharpen_min_coring_result
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_LISO2_MIN_CORING_RESULT);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoLiso2SharpenNoiseSharpenMinCoringResult(&Mode, &GData.HisoLiso2MinCoringResult));
+                }
+                {// Note: li_2nd_sharpen_noise_filter_sharpen_scale_coring
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_LISO2_SCALE_CORING);
+                    CHECK_RET(0,  AmbaDSP_ImgGetHighIsoLiso2SharpenNoiseSharpenScaleCoring(&Mode, &GData.HisoLiso2ScaleCoring));
+                }
+                {// Note: hi_chroma_filter_high
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_CHROMA_FILTER_HIGH);
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoGetChromaFilterHigh(&Mode, &GData.HisoChromaFilterHigh));
+                }
+                {// Note: hi_chroma_filter_low_and_very_low
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_CHROMA_FILTER_LOW_VERY_LOW);
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoGetChromaFilterLowVeryLow(&Mode, &GData.HisoChromaFilterLowVeryLow));
+                }
+                {// Note: hi_chroma_filter_pre
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_CHROMA_FILTER_PRE);
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoGetChromaFilterPre(&Mode, &GData.HisoChromaFilterPre));
+                }
+                {// Note: hi_chroma_filter_med
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_CHROMA_FILTER_MED);
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoGetChromaFilterMed(&Mode, &GData.HisoChromaFilterMed));
+                }
+                {// Note: hi_chroma_filter_low
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_CHROMA_FILTER_LOW);
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoGetChromaFilterLow(&Mode, &GData.HisoChromaFilterLow));
+                }
+                {// Note: hi_chroma_filter_very_low
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_CHROMA_FILTER_VERY_LOW);
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoGetChromaFilterVeryLow(&Mode, &GData.HisoChromaFilterVeryLow));
+                }
+                {// Note: hi_chroma_filter_med_combine
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_CHROMA_FILTER_MED_COMBINE);
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoGetChromaFilterMedCombine(&Mode, &GData.HisoChromaFilterMedCombine));
+                }
+                {// Note: hi_chroma_filter_low_combine
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_CHROMA_FILTER_LOW_COMBINE);
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoGetChromaFilterLowCombine(&Mode, &GData.HisoChromaFilterLowCombine));
+                }
+                {// Note: hi_chroma_filter_very_low_combine
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_CHROMA_FILTER_VERY_LOW_COMBINE);
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoGetChromaFilterVeryLowCombine(&Mode, &GData.HisoChromaFilterVeryLowCombine));
+                }
+                {// Note: hi_luma_noise_combine
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_LUMA_NOISE_COMBINE);
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoGetLumaNoiseCombine(&Mode, &GData.HisoLumaNoiseCombine));
+                }
+                {// Note: hi_low_advanced_spatial_filter_combine
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_LOW_ASF_COMBINE);
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoGetLowASFCombine(&Mode, &GData.HisoLowASFCombine));
+                }
+                {// Note: hili_combine
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HIGH_ISO_COMBINE);
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoGetHighIsoCombine(&Mode, &GData.HighIsoCombine));
+                }
+                {// Note: hili_luma_mid_high_freq_recover
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_FREQ_RECOVER);
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoGetHighIsoFreqRecover(&Mode, &GData.HisoFreqRecover));
+                }
+                {// Note: hili_2nd_luma_blend
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_LOW2_LUMA_BLEND);
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoGetHighIsoLumaBlend(&Mode, &GData.HisoLow2LumaBlend));
+                }
+                if(GData.HisoLow2LumaBlend.Enable == 1) {
+                    // Note: hili_2nd_blend
+                    _AmbaItuner_Set_Filter_Valid(ITUNER_HISO_LOW2_BLEND_LUMA_LEVEL);
+                    CHECK_RET(0,  AmbaDSP_ImgHighIsoGetHighIsoBlendLumaLevel(&Mode, &GData.HisoLow2BlendLumaLevel));
+                }
+            }
+        }
+#endif
+    } while (0);
+    return Ret;
+
+}
+
+
+
+/*
+int Calib_Ituner_Init(void)
+{
+
+    // Note: tobe delete
+    ituner_init();
+
+    memset(&GData, 0x0, sizeof(ITUNER_DATA_s));
+
+    memset(&GTable, 0x0, sizeof(ITUNER_TABLE_s));
+    //Liso Sharp and Asf
+    GData.SharpenBoth.ThreeD.pTable = GTable.SharpenBothThreeDTable;
+    GData.FinalSharpenBoth.ThreeD.pTable = GTable.FinalSharpenBothThreeDTable;
+    GData.AsfInfo.Adapt.ThreeD.pTable = GTable.AsfInfoThreeDTable;
+    //Hiso Asf
+    GData.HisoAsf.Adapt.ThreeD.pTable       = GTable.HisoAsfThreeDTable;
+    GData.HisoHighAsf.Adapt.ThreeD.pTable   = GTable.HisoHighAsfThreeDTable;
+    GData.HisoLowAsf.Adapt.ThreeD.pTable    = GTable.HisoLowAsfThreeDTable;
+    GData.HisoMedAsf.Adapt.ThreeD.pTable   = GTable.HisoMedAsfThreeDTable;
+    GData.HisoLi2ndAsf.Adapt.ThreeD.pTable  = GTable.HisoLi2ndAsfThreeDTable;
+    GData.HisoChromaAsf.Adapt.ThreeD.pTable = GTable.HisoChromaAsfThreeDTable;
+    //HisoHighSharpen
+    GData.HisoHighSharpenBoth.ThreeD.pTable = GTable.HisoHighSharpenBothThreeDTable;
+    //HisoMedSharpen
+    GData.HisoMedSharpenBoth.ThreeD.pTable = GTable.HisoMedSharpenBothThreeDTable;
+    //HisoLiso1Sharpen
+    GData.HisoLiso1SharpenBoth.ThreeD.pTable = GTable.HisoLiso1SharpenBothThreeDTable;
+    //HisoMedSharpen
+    GData.HisoLiso2SharpenBoth.ThreeD.pTable = GTable.HisoLiso2SharpenBothThreeDTable;
+    //Combine
+    GData.HisoChromaFilterMedCombine.ThreeD.pTable = GTable.HisoChromaFilterMedCombineThreeDTable;
+    GData.HisoChromaFilterLowCombine.ThreeD.pTable = GTable.HisoChromaFilterLowCombineThreeDTable;
+    GData.HisoChromaFilterVeryLowCombine.ThreeD.pTable = GTable.HisoChromaFilterVeryLowCombineThreeDTable;
+    GData.HisoLumaNoiseCombine.ThreeD.pTable = GTable.HisoLumaNoiseCombineThreeDTable;
+    GData.HisoLowASFCombine.ThreeD.pTable = GTable.HisoLowASFCombineThreeDTable;
+    GData.HighIsoCombine.ThreeD.pTable = GTable.HighIsoCombineThreeDTable;
+
+    return 0;
+}
+*/
+/*
+int Calib_Ituner_Load(const char * FileName)
+{
+    return ituner_load(FileName);
+}
+*/
+
+/*
+static int _convert_to_exp_mode(int Mode)
+{
+    int Rval;
+    switch(Mode) {
+    case IMG_MODE_VIDEO:
+        Rval = IMG_EXP_VIDEO_DIRECT_SET; break;
+    case IMG_MODE_STILL:
+    case IMG_MODE_LOW_ISO_STILL:
+    case IMG_MODE_HIGH_ISO_STILL:
+        AmbaPrint("IA2-EXP module doesn't support still parameters");
+        Rval = IMG_EXP_VIDEO_DIRECT_SET; break;
+    default:
+        Rval = IMG_EXP_VIDEO_DIRECT_SET; break;
+    }
+    return Rval;
+}
+*/
+
+int Calib_Ituner_Build(amba_img_dsp_mode_cfg_t Mode)
+{
+#if 0
+    reg_t *p_reg;
+    ae_info_t still_ae_info, video_ae_info;
+    af_tiles_t af_tiles;
+    int i, proc_mode, ext_mode;
+    UINT32 fpn_mode;
+    UINT8  vignette_mode;
+
+    // A7 does not support FAST MODE, it will use LOW ISO instead
+    // so if system try to dump FAST MODE config, dump LOW ISO instead
+    if (mode == IMG_MODE_STILL)
+        mode = IMG_MODE_LOW_ISO_STILL;
+
+    proc_mode = ituner_get_proc_mode();
+    ext_mode = ituner_get_tuning_mode_ext();
+    AMP_img_algo_cmd(MW_IA_GET_AAA_FUNCTION, &GData.aaa_function, 0);
+    if (mode == IMG_MODE_VIDEO) {
+        //AMP_img_algo_cmd(MW_IA_GET_EXPOSURE_VALUE, _convert_to_exp_mode(mode), &GData.ae_info);
+        AMP_img_algo_cmd(MW_IA_GET_AE_INFO, IMG_MODE_VIDEO, &video_ae_info);
+        GData.ae_info.shutter_index = video_ae_info.shutter_index;
+        GData.ae_info.agc_index =     video_ae_info.agc_index;
+        GData.ae_info.iris_index =    video_ae_info.iris_index;
+        GData.ae_info.dgain =         video_ae_info.dgain;
+    } else {
+        AMP_img_algo_cmd(MW_IA_GET_PREDICTED_AE_INFO, 0, &still_ae_info);
+        GData.ae_info.shutter_index = still_ae_info.shutter_index;
+        GData.ae_info.agc_index =     still_ae_info.agc_index;
+        GData.ae_info.iris_index =    still_ae_info.iris_index;
+        GData.ae_info.dgain =         still_ae_info.dgain;
+    }
+
+    AMP_img_sensor_cmd(MW_IMG_GET_AE_STAT_INFO, mode, &GData.ae_statistics_info);
+    AMP_img_sensor_cmd(MW_IMG_GET_AWB_STAT_INFO, mode, &GData.awb_statistics_info);
+    AMP_img_sensor_cmd(MW_IMG_GET_AF_STAT_INFO, mode, &af_tiles);
+    GData.af_statistics_info.af_tile_num_col = af_tiles.columns;
+    GData.af_statistics_info.af_tile_num_row = af_tiles.rows;
+    GData.af_statistics_info.af_tile_col_start = af_tiles.column_start;
+    GData.af_statistics_info.af_tile_row_start = af_tiles.row_start;
+    GData.af_statistics_info.af_tile_width = af_tiles.width;
+    GData.af_statistics_info.af_tile_height = af_tiles.height;
+    GData.af_statistics_info.af_tile_active_width = af_tiles.active_width;
+    GData.af_statistics_info.af_tile_active_height = af_tiles.active_height;
+    //AMP_img_sensor_cmd(MW_IMG_GET_AF_EX);
+
+    fpn_mode = (proc_mode == STILL_PROC ? 1:0);
+    AMP_img_sensor_cmd(MW_IMG_FPNCORE_CMD_GEN, fpn_mode, &GData.fpn_correction);
+    GData.static_bad_pixel_correction.enable = GData.fpn_correction.enable;
+    GData.static_bad_pixel_correction.pixel_map_width = GData.fpn_correction.pixel_map_width;
+    GData.static_bad_pixel_correction.pixel_map_height = GData.fpn_correction.pixel_map_height;
+    GData.static_bad_pixel_correction.pixel_map_pitch = GData.fpn_correction.fpn_pitch;
+
+    //AMP_img_sensor_cmd(MW_IMG_SET_STATIC_BAD_PIX, IMG_MODE_VIDEO, &GData.static_bad_pixel_correction);
+
+    vignette_mode = (mode == IMG_MODE_VIDEO) ? 0 : 1;
+    AMP_img_sensor_cmd(MW_IMG_VIGCORE_GET_VIG, vignette_mode, &GData.vignette_info);
+    GData.vignette_compensation.enable = GData.vignette_info.enable;
+    GData.vignette_compensation.gain_shift = GData.vignette_info.gain_shift;
+
+    AMP_img_sensor_cmd(MW_IMG_GET_WARP_CONFIG, mode, &GData.warp_dzoom_info);
+    GData.warp_compensation.enable = GData.warp_dzoom_info.warp_control;
+    GData.warp_compensation.warp_control = GData.warp_dzoom_info.warp_control;
+    GData.warp_compensation.grid_array_width = GData.warp_dzoom_info.grid_array_width;
+    GData.warp_compensation.grid_array_height = GData.warp_dzoom_info.grid_array_height;
+    GData.warp_compensation.horz_grid_spacing_exponent = GData.warp_dzoom_info.horz_grid_spacing_exponent;
+    GData.warp_compensation.vert_grid_spacing_exponent = GData.warp_dzoom_info.vert_grid_spacing_exponent;
+    GData.warp_compensation.vert_warp_enable = GData.warp_dzoom_info.vert_warp_enable;
+    GData.warp_compensation.vert_warp_grid_array_width = GData.warp_dzoom_info.vert_warp_grid_array_width;
+    GData.warp_compensation.vert_warp_grid_array_height = GData.warp_dzoom_info.vert_warp_grid_array_height;
+    GData.warp_compensation.vert_warp_horz_grid_spacing_exponent = GData.warp_dzoom_info.vert_warp_horz_grid_spacing_exponent;
+    GData.warp_compensation.vert_warp_vert_grid_spacing_exponent = GData.warp_dzoom_info.vert_warp_vert_grid_spacing_exponent;
+
+    GData.dzoom.enable = 1;
+    GData.dzoom.actual_left_top_x = GData.warp_dzoom_info.actual_left_top_x;
+    GData.dzoom.actual_left_top_y = GData.warp_dzoom_info.actual_left_top_y;
+    GData.dzoom.actual_right_bot_x = GData.warp_dzoom_info.actual_right_bot_x;
+    GData.dzoom.actual_right_bot_y = GData.warp_dzoom_info.actual_right_bot_y;
+    GData.dzoom.zoom_x = GData.warp_dzoom_info.zoom_x;
+    GData.dzoom.zoom_y = GData.warp_dzoom_info.zoom_y;
+    GData.dzoom.x_center_offset = GData.warp_dzoom_info.x_center_offset;
+    GData.dzoom.y_center_offset = GData.warp_dzoom_info.y_center_offset;
+    GData.dzoom.hor_skew_phase_inc = GData.warp_dzoom_info.hor_skew_phase_inc;
+    GData.dzoom.force_v4tap_disable = GData.warp_dzoom_info.force_v4tap_disable;
+    GData.dzoom.dummy_window_x_left = GData.warp_dzoom_info.dummy_window_x_left;
+    GData.dzoom.dummy_window_y_top = GData.warp_dzoom_info.dummy_window_y_top;
+    GData.dzoom.dummy_window_width = GData.warp_dzoom_info.dummy_window_width;
+    GData.dzoom.dummy_window_height = GData.warp_dzoom_info.dummy_window_height;
+    GData.dzoom.cfa_output_width = GData.warp_dzoom_info.cfa_output_width;
+    GData.dzoom.cfa_output_height = GData.warp_dzoom_info.cfa_output_height;
+
+    AMP_img_sensor_cmd(MW_IMG_GET_VIN_SENSOR_INFO, &GData.sensor_info, 0);
+    GData.sensor_input_info.sensor_id = GData.sensor_info.sensor_id;
+    GData.sensor_input_info.bayer_pattern = GData.sensor_info.sensor_pattern;
+    GData.sensor_input_info.sensor_resolution = GData.sensor_info.sensor_resolution;
+    GData.sensor_input_info.readout_mode = GData.sensor_info.sensor_readout_mode;
+
+    AMP_img_sensor_cmd(MW_IMG_GET_BLK_LVL, mode, &GData.static_black_level);
+    AMP_img_sensor_cmd(MW_IMG_GET_DYNAMIC_BAD_PIX, mode, &GData.dynamic_bad_pixel_correction);
+    AMP_img_sensor_cmd(MW_IMG_GET_CFA_LEAK_FLT, mode, &GData.cfa_leakage_filter);
+    AMP_img_sensor_cmd(MW_IMG_GET_CFA_NS_FLT, mode, &GData.cfa_noise_filter);
+    AMP_img_sensor_cmd(MW_IMG_GET_ANTI_ALIAS, mode, &GData.anti_aliasing_strength);
+    AMP_img_algo_cmd(MW_IA_GET_GLOBAL_DGAIN, 0, &GData.global_dgain); //API to be added
+    AMP_img_algo_cmd(MW_IA_GET_WB_GAIN, mode, &GData.wb_gain);
+    AMP_img_sensor_cmd(MW_IMG_GET_DGAIN_SAT_LVL, mode, &GData.dgain_saturation_level);
+    AMP_img_sensor_cmd(MW_IMG_GET_LOCAL_EXPOSURE, mode, &GData.local_exposure);
+    AMP_img_sensor_cmd(MW_IMG_GET_CLR_CORR_REG, mode, &GData.cc_reg);
+    AMP_img_sensor_cmd(MW_IMG_GET_CLR_CORR, mode, &GData.cc_3d);
+    AMP_img_sensor_cmd(MW_IMG_GET_TONE_CURVE, mode, &GData.tone_curve);
+    AMP_img_sensor_cmd(MW_IMG_GET_R2Y_MTX, mode, &GData.rgb_to_yuv_matrix);
+    AMP_img_sensor_cmd(MW_IMG_GET_CRMA_SCL, mode, &GData.chroma_scale);
+    AMP_img_sensor_cmd(MW_IMG_GET_CRMA_MED_FLT, mode, &GData.chroma_median_filter);
+    AMP_img_sensor_cmd(MW_IMG_GET_LUMA_HF_NS_RDC, mode, &GData.luma_high_freq_noise_reduction);
+    AMP_img_sensor_cmd(MW_IMG_GET_SHRP_A_MAXCH, mode, &GData.sharp_a_max_change);
+    AMP_img_sensor_cmd(MW_IMG_GET_SHRP_B_MAXCH, mode, &GData.sharp_b_max_change);
+
+    AMP_img_sensor_cmd(MW_IMG_GET_SHRP_A_FIR, mode, &GData.sharp_a_fir);
+    AMP_img_sensor_cmd(MW_IMG_GET_SHRP_B_FIR, mode, &GData.sharp_b_fir);
+    AMP_img_sensor_cmd(MW_IMG_GET_SHRP_A_CORING, mode, &GData.sharp_a_coring);
+    AMP_img_sensor_cmd(MW_IMG_GET_SHRP_B_CORING, mode, &GData.sharp_b_coring);
+    AMP_img_sensor_cmd(MW_IMG_GET_SHRP_A_SRL, mode, &GData.sharp_a_sig_retain_lvl);
+    AMP_img_sensor_cmd(MW_IMG_GET_SHRP_B_SRL, mode, &GData.sharp_b_sig_retain_lvl);
+    AMP_img_sensor_cmd(MW_IMG_GET_SHRP_A_LVL_MIN, mode, &GData.sharp_a_level_min);
+    AMP_img_sensor_cmd(MW_IMG_GET_SHRP_B_LVL_MIN, mode, &GData.sharp_b_level_min);
+    AMP_img_sensor_cmd(MW_IMG_GET_SHRP_A_LVL_OVRAL, mode, &GData.sharp_a_level_overall);
+    AMP_img_sensor_cmd(MW_IMG_GET_SHRP_B_LVL_OVRAL, mode, &GData.sharp_b_level_overall);
+    AMP_img_sensor_cmd(MW_IMG_GET_ADV_SPATIAL_FLT, mode, &GData.asf_info);
+    AMP_img_sensor_cmd(MW_IMG_GET_VIDEO_SHRP_A_OR_SPATIAL_FLT, mode, &GData.shpA_or_spatial_filter_select);
+    if (GData.shpA_or_spatial_filter_select == 0) {
+        char *filt_to_be_invalid[] = {
+            "a_sharpening_fir",
+            "a_sharpening_coring",
+            "a_sharpening_signal_retain_level",
+            "a_sharpening_level_minimum",
+            "a_sharpening_level_overall",
+            "a_sharpening_max_change",
+            "advanced_spatial_filter",
+            NULL
+        };
+        i = 0;
+        while (filt_to_be_invalid[i] != NULL) {
+            p_reg = ituner_lookup_reg(filt_to_be_invalid[i]);
+            p_reg->valid = 0;
+            i++;
+        }
+    } else if (GData.shpA_or_spatial_filter_select == 1) {
+        char *filt_to_be_invalid[] = {
+            "advanced_spatial_filter",
+            NULL
+        };
+        i = 0;
+        while (filt_to_be_invalid[i] != NULL) {
+            p_reg = ituner_lookup_reg(filt_to_be_invalid[i]);
+            p_reg->valid = 0;
+            i++;
+        }
+    } else if (GData.shpA_or_spatial_filter_select == 2) {
+        char *filt_to_be_invalid[] = {
+            "a_sharpening_fir",
+            "a_sharpening_coring",
+            "a_sharpening_signal_retain_level",
+            "a_sharpening_level_minimum",
+            "a_sharpening_level_overall",
+            "a_sharpening_max_change",
+            NULL
+        };
+        i = 0;
+        while (filt_to_be_invalid[i] != NULL) {
+            p_reg = ituner_lookup_reg(filt_to_be_invalid[i]);
+            p_reg->valid = 0;
+            i++;
+        }
+    }
+    AMP_img_sensor_cmd(MW_IMG_GET_CLR_DEP_NS_RDC, mode, &GData.cdnr);
+    AMP_img_sensor_cmd(MW_IMG_GET_CLR_CORR_DESAT, mode, &GData.cc_desatutation);
+    AMP_img_sensor_cmd(MW_IMG_GET_SHRP_B_LINEAR, mode, &GData.sharp_b_linearization_strength);
+    AMP_img_sensor_cmd(MW_IMG_GET_CA_CONFIG, mode, &GData.chroma_aberration);
+    GData.chroma_aberration_info.enable = GData.chroma_aberration.enable;
+    GData.chroma_aberration_info.horz_warp_enable = GData.chroma_aberration.horz_warp_enable;
+    GData.chroma_aberration_info.vert_warp_enable = GData.chroma_aberration.vert_warp_enable;
+    GData.chroma_aberration_info.horz_pass_grid_array_width = GData.chroma_aberration.horz_pass_grid_array_width;
+    GData.chroma_aberration_info.horz_pass_grid_array_height = GData.chroma_aberration.horz_pass_grid_array_height;
+    GData.chroma_aberration_info.horz_pass_horz_grid_spacing_exponent = GData.chroma_aberration.horz_pass_horz_grid_spacing_exponent;
+    GData.chroma_aberration_info.horz_pass_vert_grid_spacing_exponent = GData.chroma_aberration.horz_pass_vert_grid_spacing_exponent;
+    GData.chroma_aberration_info.vert_pass_grid_array_width = GData.chroma_aberration.vert_pass_grid_array_width;
+    GData.chroma_aberration_info.vert_pass_grid_array_height = GData.chroma_aberration.vert_pass_grid_array_height;
+    GData.chroma_aberration_info.vert_pass_horz_grid_spacing_exponent = GData.chroma_aberration.vert_pass_horz_grid_spacing_exponent;
+    GData.chroma_aberration_info.vert_pass_vert_grid_spacing_exponent = GData.chroma_aberration.vert_pass_vert_grid_spacing_exponent;
+    GData.chroma_aberration_info.red_scale_factor = GData.chroma_aberration.red_scale_factor;
+    GData.chroma_aberration_info.blue_scale_factor = GData.chroma_aberration.blue_scale_factor;
+
+    if (mode == IMG_MODE_VIDEO) {
+        /* invalid LISO/HISO REGS */
+        char *filt_to_be_invalid[] = {
+            "chroma_filt",
+            "luma_level_based_noise_reduction",
+            "luma_freq_separation",
+            "luma_very_low_freq_filter",
+            "luma_detail_preservation",
+            "luma_filt_spatial_dependent",
+            "high_iso_chroma_filt",
+            "high_iso_color_correction",
+            "high_iso_chroma_filter_spat_dep",
+            "high_iso_chroma_filter_pre",
+            "high_iso_chroma_filter_high",
+            "high_iso_chroma_filter_med",
+            "high_iso_chroma_filter_low",
+            "high_iso_chroma_filter_very_low",
+            "high_iso_chroma_filter_very_very_low",
+            "night_portrait",
+            NULL
+        };
+        i = 0;
+        while (filt_to_be_invalid[i] != NULL) {
+            p_reg = ituner_lookup_reg(filt_to_be_invalid[i]);
+            p_reg->valid = 0;
+            i++;
+        }
+        AMP_img_sensor_cmd(MW_IMG_GET_VIDEO_MCTF_INFO, 0, &GData.video_mctf);
+
+    } else if (mode == IMG_MODE_STILL) {
+        char *filt_to_be_invalid[] = {
+            "video_mctf",
+            "chroma_filt",
+            "luma_level_based_noise_reduction",
+            "luma_freq_separation",
+            "luma_very_low_freq_filter",
+            "luma_detail_preservation",
+            "luma_filt_spatial_dependent",
+            "high_iso_chroma_filt",
+            "high_iso_color_correction",
+            "high_iso_chroma_filter_spat_dep",
+            "high_iso_chroma_filter_pre",
+            "high_iso_chroma_filter_high",
+            "high_iso_chroma_filter_med",
+            "high_iso_chroma_filter_low",
+            "high_iso_chroma_filter_very_low",
+            "high_iso_chroma_filter_very_very_low",
+            "night_portrait",
+            NULL
+        };
+        i = 0;
+        while (filt_to_be_invalid[i] != NULL) {
+            p_reg = ituner_lookup_reg(filt_to_be_invalid[i]);
+            p_reg->valid = 0;
+            i++;
+        }
+    } else if (mode == IMG_MODE_LOW_ISO_STILL) {
+        char *filt_to_be_invalid[] = {
+            "video_mctf",
+            "luma_level_based_noise_reduction",
+            "luma_freq_separation",
+            "luma_very_low_freq_filter",
+            "luma_detail_preservation",
+            "luma_filt_spatial_dependent",
+            "high_iso_chroma_filt",
+            "high_iso_color_correction",
+            "high_iso_chroma_filter_spat_dep",
+            "high_iso_chroma_filter_pre",
+            "high_iso_chroma_filter_high",
+            "high_iso_chroma_filter_med",
+            "high_iso_chroma_filter_low",
+            "high_iso_chroma_filter_very_low",
+            "high_iso_chroma_filter_very_very_low",
+            "night_portrait",
+            NULL
+        };
+        i = 0;
+        while (filt_to_be_invalid[i] != NULL) {
+            p_reg = ituner_lookup_reg(filt_to_be_invalid[i]);
+            p_reg->valid = 0;
+            i++;
+        }
+        AMP_img_sensor_cmd(MW_IMG_LISO_GET_CRMA_FILT, 0, &GData.chroma_filter);
+        if (ext_mode == MULTI_SHOT_MAHDR) {
+            idsp_hdr_proc_info_t hdr_proc_info;
+            char *filt_to_be_invalid[] = {
+                "mf_hiso_mctf",
+                "mf_hiso_gmv",
+                NULL
+            };
+            i = 0;
+
+            while (filt_to_be_invalid[i] != NULL) {
+                p_reg = ituner_lookup_ext_reg(filt_to_be_invalid[i]);
+                p_reg->valid = 0;
+                i++;
+            }
+            hdr_proc_info.le_info    = GData.hdr_local_exposure;
+            hdr_proc_info.cnf_info   = GData.hdr_cfa_noise_filter;
+            hdr_proc_info.mixer_info = GData.hdr_mixer;
+            AMP_img_sensor_cmd(MW_IMG_HDR_GET_PARAM, mode, &hdr_proc_info);
+            // temporal store number frames to normal_frame_idx, raw capture always use idx 0 as normal frame
+            GData.hdr_control_info.normal_frame_idx  = hdr_proc_info.num_of_frames;
+            AMP_img_algo_cmd(MW_IA_HDR_GET_MCTF_STR, &GData.hdr_control_info.mctf_strength, 0);
+        }
+    } else if (mode == IMG_MODE_HIGH_ISO_STILL) {
+        char *filt_to_be_invalid[] = {
+            "video_mctf",
+            "chroma_filt",
+            "a_sharpening_fir",
+            "b_sharpening_fir",
+            "a_sharpening_coring",
+            "b_sharpening_coring",
+            "a_sharpening_signal_retain_level",
+            "b_sharpening_signal_retain_level",
+            "a_sharpening_level_minimum",
+            "b_sharpening_level_minimum",
+            "a_sharpening_level_overall",
+            "b_sharpening_level_overall",
+            "a_sharpening_max_change",
+            "b_sharpening_max_change",
+            "b_sharpening_linearization",
+            "night_portrait",
+            NULL
+        };
+        i = 0;
+        while (filt_to_be_invalid[i] != NULL) {
+            p_reg = ituner_lookup_reg(filt_to_be_invalid[i]);
+            p_reg->valid = 0;
+            i++;
+        }
+        AMP_img_sensor_cmd(MW_IMG_HISO_GET_LUMA_LBNR, 0, &GData.luma_level_based_noise_reduction);
+        AMP_img_sensor_cmd(MW_IMG_HISO_GET_LUMA_FREQ_SEP, 0, &GData.luma_freq_separation);
+        AMP_img_sensor_cmd(MW_IMG_HISO_GET_LUMA_VL_FREQ, 0, &GData.luma_very_low_freq_filter);
+        AMP_img_sensor_cmd(MW_IMG_HISO_GET_LUMA_DETAIL_PRE, 0, &GData.luma_detail_preservation);
+        AMP_img_sensor_cmd(MW_IMG_HISO_GET_LUMA_SPAT_DEP, 0, &GData.luma_filt_spatial_dependent);
+        AMP_img_sensor_cmd(MW_IMG_HISO_GET_HISO_CRMA_FILT, 0, &GData.high_iso_chroma_filt);
+        AMP_img_sensor_cmd(MW_IMG_HISO_GET_HISO_CC, 0, &GData.high_iso_color_correction);
+        AMP_img_sensor_cmd(MW_IMG_HISO_GET_CRMA_SPAT_DEP, 0, &GData.chroma_filter_spatial_dependent);
+        AMP_img_sensor_cmd(MW_IMG_HISO_GET_CRMA_FILT_PRE, 0, &GData.chroma_filter_pre);
+        AMP_img_sensor_cmd(MW_IMG_HISO_GET_CRMA_FILT_HIGH, 0, &GData.chroma_filter_high);
+        AMP_img_sensor_cmd(MW_IMG_HISO_GET_CRMA_FILT_MED, 0, &GData.chroma_filter_med);
+        AMP_img_sensor_cmd(MW_IMG_HISO_GET_CRMA_FILT_LOW, 0, &GData.chroma_filter_low);
+        AMP_img_sensor_cmd(MW_IMG_HISO_GET_CRMA_FILT_VL, 0, &GData.chroma_filter_very_low);
+        AMP_img_sensor_cmd(MW_IMG_HISO_GET_CRMA_FILT_VVL, 0, &GData.chroma_filter_very_very_low);
+        GData.ituner_luma_spa_dep.width = GData.luma_filt_spatial_dependent.width;
+        GData.ituner_luma_spa_dep.height = GData.luma_filt_spatial_dependent.height;
+        GData.ituner_luma_spa_dep.adaptation = GData.luma_filt_spatial_dependent.adaptation;
+        GData.ituner_luma_spa_dep.maxchange = GData.luma_filt_spatial_dependent.maxchange;
+        GData.ituner_luma_spa_dep.strength = GData.luma_filt_spatial_dependent.strength;
+        GData.ituner_chroma_spa_dep.radius = GData.chroma_filter_spatial_dependent.radius;
+        GData.ituner_chroma_spa_dep.width = GData.chroma_filter_spatial_dependent.width;
+        GData.ituner_chroma_spa_dep.height = GData.chroma_filter_spatial_dependent.height;
+        GData.ituner_chroma_spa_dep.noise_level_cb = GData.chroma_filter_spatial_dependent.noise_level_cb;
+        GData.ituner_chroma_spa_dep.noise_level_cr = GData.chroma_filter_spatial_dependent.noise_level_cr;
+
+        if (ext_mode == MULTI_SHOT_MF_HISO) {
+            char *filt_to_be_invalid[] = {
+                "local_exposure",
+                "cfa_noise_filter",
+                "hdr_mixer",
+                "hdr_control_info",
+                NULL
+            };
+            i = 0;
+
+            while (filt_to_be_invalid[i] != NULL) {
+                p_reg = ituner_lookup_ext_reg(filt_to_be_invalid[i]);
+                p_reg->valid = 0;
+                i++;
+            }
+            AMP_img_sensor_cmd(MW_IMG_HISO_GET_MF_MCTF, 0, &GData.mf_hiso_mctf_info);
+            for (i = 0; i < GData.mf_hiso_mctf_info.num_of_frames; i++)
+                AMP_img_sensor_cmd(MW_IMG_HISO_GET_MF_GMV, 0, &GData.mf_hiso_gmv_info[i]);
+        }
+    } else if (mode == 4) { // night portrait mode
+        char *filt_to_be_invalid[] = {
+            "aaa_function",
+            "ae_info",
+            "ae_statistics_info",
+            "awb_statistics_info",
+            "af_statistics_info",
+            "af_statistics_ex_t",
+            "static_bad_pixel_correction",
+            "vignette_compensation",
+            "warp_compensation",
+            "static_black_level",
+            "auto_bad_pixel_correction",
+            "cfa_leakage_filter",
+            "cfa_noise_filter",
+            "anti_aliasing",
+            "global_dgain",
+            "wb_gains",
+            "dgain_saturation_level",
+            "local_exposure",
+            "color_correction",
+            "tone_curve",
+            "rgb_to_yuv_matrix",
+            "chroma_scale",
+            "chroma_median_filter",
+            "dzoom",
+            "luma_high_freq_noise_reduction",
+            "a_sharpening_fir",
+            "b_sharpening_fir",
+            "a_sharpening_coring",
+            "b_sharpening_coring",
+            "a_sharpening_signal_retain_level",
+            "b_sharpening_signal_retain_level",
+            "a_sharpening_level_minimum",
+            "b_sharpening_level_minimum",
+            "a_sharpening_level_overall",
+            "b_sharpening_level_overall",
+            "a_sharpening_max_change",
+            "b_sharpening_max_change",
+            "video_mctf",
+            "vin_sensor_info",
+            "color_dependent_noise_reduction",
+            "li_use_1st_sharpen_not_asf",
+            "b_sharpening_linearization",
+            "desaturate_cc",
+            "advanced_spatial_filter",
+            "chroma_filt",
+            "luma_level_based_noise_reduction",
+            "luma_freq_separation",
+            "luma_very_low_freq_filter",
+            "luma_detail_preservation",
+            "luma_filt_spatial_dependent",
+            "high_iso_chroma_filt",
+            "high_iso_color_correction",
+            "high_iso_chroma_filter_spat_dep",
+            "high_iso_chroma_filter_pre",
+            "high_iso_chroma_filter_high",
+            "high_iso_chroma_filter_med",
+            "high_iso_chroma_filter_low",
+            "high_iso_chroma_filter_very_low",
+            "high_iso_chroma_filter_very_very_low",
+            "chromatic_aberration_correction",
+            NULL
+        };
+        extern int  img_night_portrait_get_flash_noflash_table(UINT16 *table_addr);
+        i = 0;
+        while (filt_to_be_invalid[i] != NULL) {
+            p_reg = ituner_lookup_reg(filt_to_be_invalid[i]);
+            p_reg->valid = 0;
+            i++;
+        }
+        AMP_img_sensor_cmd(MW_IMG_NP_GET_FLASH_2ND, mode, &GData.night_portrait.flash_on_2nd_pic);
+        img_night_portrait_get_flash_noflash_table(GData.night_portrait.table);
+    }
+#endif
+    return 0;
+}
+#if 0
+void AmbaItuner_RawSrcLoad(UINT32 InputAddr, UINT32 BufSize)
+{
+    char UniRawPath[256];
+    char Mode[] = {'r','\0'};
+    AMBA_FS_FILE *pFile;
+    int InputPitch;//, TuningModeExt;
+    int i;//, f;
+
+    //TuningModeExt = ituner_get_tuning_mode_ext();
+    if (_System.InputPicCnt > 1) {
+        /*if (tuning_mode_ext == MULTI_SHOT_MAHDR) {
+            for (f = _System.input_pic_cnt - 1; f >= 0; f--) {
+                asc_to_uni((char *)GData.hdr_raw_info[f].raw_path, uni_rawpath);
+                AmbaPrint("_raw_src_load[%d] %s to %X",f,GData.hdr_raw_info[f].raw_path,input_addr);
+                pfile = AmbaFS_fopen(uni_rawpath, mode);
+                if (pfile != NULL) {
+                    input_pitch = ((_System.raw_pitch + 31) >> 5) << 5;
+                    for (i = 0; i < _System.raw_height; i++) {
+                //        AmbaFS_fread(input_addr, _System.raw_pitch, 1, pfile);
+                        input_addr += input_pitch;
+                    }
+                    AmbaFS_fclose(pfile);
+                } else {
+                    AmbaPrint("Error: Multi shot raw file %d %s open fail", f, GData.hdr_raw_info[f].raw_path);
+                }
+            }
+        }else {
+            //The MF_HISO buffer for ucode computation is in front of raw image
+            if (tuning_mode_ext == MULTI_SHOT_MF_HISO) {
+                int mf_hiso_extra_buf_size;
+                mf_hiso_extra_buf_size = _System.raw_width * _System.raw_height;
+                if ((_System.main_width * _System.main_height) > mf_hiso_extra_buf_size)
+                    mf_hiso_extra_buf_size = _System.main_width * _System.main_height;
+                mf_hiso_extra_buf_size *=3;
+                input_addr += mf_hiso_extra_buf_size;
+            }
+            for (f=0; f<_System.input_pic_cnt; f++) {
+                asc_to_uni((char *)GData.hdr_raw_info[f].raw_path, uni_rawpath);
+                pfile = AmbaFS_fopen(uni_rawpath, mode);
+                if (pfile != NULL) {
+                    input_pitch = ((_System.raw_pitch + 31) >> 5) << 5;
+                    for (i = 0; i < _System.raw_height; i++) {
+                        AmbaFS_fread(input_addr, _System.raw_pitch, 1, pfile);
+                        input_addr += input_pitch;
+                    }
+                    AmbaFS_fclose(pfile);
+                } else {
+                    AmbaPrint("Error: Multi shot raw file %d %s open fail", f, GData.hdr_raw_info[f].raw_path);
+                }
+            }
+        }*/
+    } else {
+        asc_to_uni(_System.RawPath, UniRawPath);
+        pFile = AmbaFS_fopen(UniRawPath, Mode);
+        if (pFile != NULL) {
+            InputPitch = ((_System.RawPitch + 31) >> 5) << 5;
+            for (i = 0; i < _System.RawHeight; i++) {
+                AmbaFS_fread((void *)InputAddr, _System.RawPitch, 1, pFile);
+                InputAddr += InputPitch;
+            }
+            AmbaFS_fclose(pFile);
+        }
+    }
+}
+#endif
+/*
+ITUNER_s G_ituner = {
+    Calib_Ituner_Init,
+    Calib_Ituner_Load,
+    Calib_Ituner_Save,
+    Calib_Ituner_Execute,
+    Calib_Ituner_Build,
+    0
+};
+*/
diff --git a/idsp_test/arch_s2l/AmbaImgCalibItuner.h b/idsp_test/arch_s2l/AmbaImgCalibItuner.h
new file mode 100644
index 0000000..ec4ddfc
--- /dev/null
+++ b/idsp_test/arch_s2l/AmbaImgCalibItuner.h
@@ -0,0 +1,3401 @@
+/*
+ *
+ * idsp_test
+ *
+ * History:
+ *	2013/09/05 - [Dylan] Created this file
+ *
+ * Description :
+ *	Load the tuned file which generated by Img tuning tool.
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef _AMBA_IMG_CALIB_ITUNER_H_
+#define _AMBA_IMG_CALIB_ITUNER_H_
+
+#include "AmbaDSP_ImgDef.h"
+#include "AmbaDSP_Img3aStatistics.h" // amba_img_dsp_ae_stat_info_t need
+#include "AmbaDSP_ImgFilter.h" // amba_img_dsp_black_correction_t need
+
+#define ITUNER_VER_MAJOR    1
+#define ITUNER_VER_MINOR    0
+
+#define MAX_PARAMS          16
+
+#define TUING_MODE_TO_STR(TUING_MODE) #TUING_MODE
+#define TUING_MODE_EXT_TO_STR(TUING_MODE_EXT) #TUING_MODE_EXT
+
+#define APP_MAX_DIR_SIZE    (64)
+#define APP_MAX_FN_SIZE        (64)
+#define APP_MAX_TITLE_SIZE    (20)
+
+typedef enum {
+    IMG_MODE_VIDEO = 0, //!< Video Tuning
+    IMG_MODE_STILL, //!< Still Tuning
+    IMG_MODE_LOW_ISO_STILL, //!< Low Iso Still Tuning
+    IMG_MODE_MID_ISO_STILL, //!< Reserved
+    IMG_MODE_HIGH_ISO_STILL,//!< High Iso Still Tuning
+    IMG_MODE_NIGHT_PORTRAIT_STILL, //!< Reserved
+    IMG_MODE_PREVIEW, //!< Preview Tuning, This tuning mode will skip ituner check
+    IMG_MODE_HIGH_ISO_PREVIEW, //!< High Iso Preview Tuning, This tuning mode will skip ituner check
+    IMG_MODE_HIGH_ISO_VIDEO, //!< High Iso Video Tuning
+    IMG_MODE_NUMBER,
+} TUNING_MODE_e;
+
+typedef enum {
+    SINGLE_SHOT = 0,
+    MULTI_SHOT_HDR,
+    MULTI_SHOT_MF_HISO,
+    MULTI_SHOT_MAHDR,
+    TUNING_MODE_EXT_NUMBER,
+} TUNING_MODE_EXT_e;
+
+#define POSTPROC_MAX_RAW_PICTURE    32
+#define POSTPROC_MAX_YUV_PICTURE    32
+
+#define ITUNER_CAL_FPN_MAP_SIZE(width, height) (width * height >> 3)
+//Note: Bypass FPN table size is referenced to A7L, fpn_size = G_data.static_bad_pixel_correction.pixel_map_pitch * G_data.static_bad_pixel_correction.pixel_map_height;
+#define ITUNER_CAL_BYPASS_FPN_MAP_SIZE(width, height) (width * height)
+#define ITUNER_VIGNETTE_GAIN_MAP_SIZE (2*65*49)
+#define ITUNER_BYPASS_VIGNETTE_GAIN_MAP_SIZE (33*33*2)
+#define ITUNER_CAL_WARP_TABLE_SIZE(width, height) (width * height * sizeof(AMBA_DSP_IMG_GRID_POINT_s))
+#define ITUNER_CAL_CA_TABLE_SIZE(width, height) (width * height * sizeof(AMBA_DSP_IMG_GRID_POINT_s))
+
+typedef struct {
+    amba_img_dsp_mode_cfg_t TuningAlgoMode;
+    TUNING_MODE_EXT_e TuningModeExt;
+} ITUNER_INFO_s;
+
+typedef struct _AAA_FUNC_s_{
+    UINT8  AeOp;
+    UINT8  AwbOp;
+    UINT8  AfOp;
+    UINT8  AdjOp;
+    UINT8  Reserved1;
+    UINT8  Reserved2;
+    UINT8  Reserved3;
+    UINT8  Reserved4;
+} AAA_FUNC_s;
+
+typedef struct _IMG_EXP_s_{
+    int ShutterIndex;
+    int AgcIndex;
+    int IrisIndex;
+    int Dgain;
+} IMG_EXP_s;
+
+typedef struct _ITUNER_WARP_s_ {
+    UINT8   Enable;
+    UINT32  CalibVersion;
+    int     HorizontalGridNumber;
+    int     VerticalGridNumber;
+    int     TileWidthExponent;
+    int     TileHeightExponent;
+    UINT32  VinSensorStartX;
+    UINT32  VinSensorStartY;
+    UINT32  VinSensorWidth;
+    UINT32  VinSensorHeight;
+    UINT8   VinSensorHSubSampleFactorNum;
+    UINT8   VinSensorHSubSampleFactorDen;
+    UINT8   VinSensorVSubSampleFactorNum;
+    UINT8   VinSensorVSubSampleFactorDen;
+    char    WarpGridTablePath[64];
+} ITUNER_WARP_s;
+
+typedef struct _ITUNER_DZOOM_s_ {
+    UINT8  Enable;
+    UINT32 ActualLeftTopX;
+    UINT32 ActualLeftTopY;
+    UINT32 ActualRightBotX;
+    UINT32 ActualRightBotY;
+    int    HorSkewPhaseInc;
+    UINT16 DummyWindowLeftX;
+    UINT16 DummyWindowTopY;
+    UINT16 DummyWindowWidth;
+    UINT16 DummyWindowHeight;
+    UINT16 CfaOutputWidth;
+    UINT16 CfaOutputHeight;
+    UINT16 R2rOutputWidth;
+    UINT16 R2rOutputHeigh;
+} ITUNER_DZOOM_s;
+
+typedef struct _ITUNER_WARP_DZOOM_BYPASS_s_ {
+
+    // Warp part
+    UINT32  WarpControl;
+    UINT8   GridArrayWidth;
+    UINT8   GridArrayHeight;
+    UINT8   HorzGridSpacingExponent;
+    UINT8   VertGridSpacingExponent;
+    UINT8   VertWarpEnable;
+    UINT8   VertWarpGridArrayWidth;
+    UINT8   VertWarpGridArrayHeight;
+    UINT8   VertWarpHorzGridSpacingExponent;
+    UINT8   VertWarpVertGridSpacingExponent;
+    char    WarpHorizontalTablePath[64];
+    char    WarpVerticalTablePath[64];
+
+    // Dzoom part
+    UINT32  ActualLeftTopX;
+    UINT32  ActualLeftTopY;
+    UINT32  ActualRightBotX;
+    UINT32  ActualRightBotY;
+    UINT32  ZoomX;
+    UINT32  ZoomY;
+    UINT32  XCenterOffset;
+    UINT32  YCenterOffset;
+    INT32   HorSkewPhaseInc;
+    UINT16  DummyWindowXLeft;
+    UINT16  DummyWindowYTop;
+    UINT16  DummyWindowWidth;
+    UINT16  DummyWindowHeight;
+    UINT16  CfaOutputWidth;
+    UINT16  CfaOutputHeight;
+
+} ITUNER_WARP_DZOOM_BYPASS_s;
+
+typedef struct _ITUNER_VIGNETTE_s_ {
+    UINT8    Enable;
+    UINT8    GainShift;
+    UINT8    StrengthEffectMode;
+    UINT32   Strength;
+    UINT32   CalibVersion;
+    int      CalibTableWidth;
+    int      CalibTableHeight;
+    UINT32   CalibVinStartX;
+    UINT32   CalibVinStartY;
+    UINT32   CalibVinWidth;
+    UINT32   CalibVinHeight;
+    UINT8    CailbVinHSubSampleFactorNum;
+    UINT8    CailbVinHSubSampleFactorDen;
+    UINT8    CailbVinVSubSampleFactorNum;
+    UINT8    CailbVinVSubSampleFactorDen;
+    char     CalibTablePath[64];
+} ITUNER_VIGNETTE_s;
+
+typedef struct _ITUNER_VIGNETTE_BYPASS_s_ {
+    UINT8    Enable;
+    UINT8    GainShift;
+    char     GainPath[64];
+} ITUNER_VIGNETTE_BYPASS_s;
+
+typedef struct _ITUNER_FPN_s_ {
+    UINT8  Enable;
+    UINT32 CalibVersion;
+    UINT32 CailbVinStartX;
+    UINT32 CailbVinStartY;
+    UINT32 CailbVinWidth;
+    UINT32 CailbVinHeight;
+    UINT8  CailbVinHSubSampleFactorNum;
+    UINT8  CailbVinHSubSampleFactorDen;
+    UINT8  CailbVinVSubSampleFactorNum;
+    UINT8  CailbVinVSubSampleFactorDen;
+    char   MapPath[64];
+} ITUNER_FPN_s;
+
+typedef struct _ITUNER_FPN_BYPASS_s_ {
+    UINT8   Enable;
+    UINT16  PixelMapWidth;
+    UINT16  PixelMapHeight;
+    UINT16  PixelMapPitch;
+    char    MapPath[64];
+} ITUNER_FPN_BYPASS_s;
+
+typedef struct _ITUNER_SENSOR_INPUT_s_ {
+    UINT8    SensorId;
+    UINT8    BayerPattern;
+    UINT8    SensorResolution;
+    UINT32   ReadoutMode;
+} ITUNER_SENSOR_INPUT_s;
+
+typedef struct _ITUNER_COLOR_CORRECTION_s_ {
+    char    RegPath[64];
+    char    ThreeDPath[64];
+    //char    SecCcPath[64];
+} ITUNER_COLOR_CORRECTION_s;
+
+typedef struct _ITUNER_CHROMA_ABERRATION_s_ {
+    UINT8   Enable;
+    UINT32  CalibVersion;
+    int     HorizontalGridNumber;
+    int     VerticalGridNumber;
+    int     TileWidthExponent;
+    int     TileHeightExponent;
+    UINT32  VinSensorStartX;
+    UINT32  VinSensorStartY;
+    UINT32  VinSensorWidth;
+    UINT32  VinSensorHeight;
+    UINT8   VinSensorHSubSampleFactorNum;
+    UINT8   VinSensorHSubSampleFactorDen;
+    UINT8   VinSensorVSubSampleFactorNum;
+    UINT8   VinSensorVSubSampleFactorDen;
+    UINT32  RedScaleFactor;
+    UINT32  BlueScaleFactor;
+    char    CaGridTablePath[64];
+} ITUNER_CHROMA_ABERRATION_s;
+
+
+typedef struct _ITUNER_CHROMA_ABERRATION_BYPASS_s_ {
+
+    UINT16  HorzWarpEnable;
+    UINT16  VertWarpEnable;
+    UINT8   HorzPassGridArrayWidth;
+    UINT8   HorzPassGridArrayHeight;
+    UINT8   HorzPassHorzGridSpacingExponent;
+    UINT8   HorzPassVertGridSpacingExponent;
+    UINT8   VertPassGridArrayWidth;
+    UINT8   VertPassGridArrayHeight;
+    UINT8   VertPassHorzGridSpacingExponent;
+    UINT8   VertPassVertGridSpacingExponent;
+    UINT16  RedScaleFactor;
+    UINT16  BlueScaleFactor;
+    char    WarpHorzTablePath[64];
+    char    WarpVertTablePath[64];
+} ITUNER_CHROMA_ABERRATION_BYPASS_s;
+
+
+
+
+typedef struct _Ituner_Internal_s_ {
+    INT8   FpnHighlight;
+    UINT16 Internal_u16_1;
+    UINT16 Internal_u16_2;
+    int    Internal_s32_0;
+    int    Internal_s32_1;
+    int    Internal_s32_2;
+    int    Internal_s32_3;
+    int    Internal_s32_4;
+    int    Internal_sha_0;
+    int    Internal_sha_1;
+    int    Internal_sha_2;
+    int    Internal_sha_3;
+    int    Internal_sha_4;
+    int    Internal_sha_5;
+    int    Internal_shb_0;
+    int    Internal_shb_1;
+    int    Internal_shb_2;
+    int    Internal_shb_3;
+    int    Internal_shb_4;
+    int    Internal_shb_5;
+    int    Internal_wm_0;
+    int    Internal_wm_1;
+    int    Internal_wm_2;
+    int    Internal_wm_3;
+    int    NOT_CUSTOMER_VISIBLE_FULL_RAW_W;
+    int    NOT_CUSTOMER_VISIBLE_FULL_MAIN_W;
+    UINT8  Reserved[3];
+    int    Internal_hdr_0;
+    int    Internal_hdr_1;
+    UINT32 DiagMode;
+} Ituner_Internal_s;
+
+//#define ALIGN_32(x)    ((x == 0) ? 0 : ((x + 31) & 0xFFFFFFE0))
+//#define ALIGN_16(x)    ((x == 0) ? 0 : ((x + 15) & 0xFFFFFFF0))
+//#define TRUNCATE_16(x)    ((x == 0) ? 0 : ((x) & 0xFFFFFFF0))
+
+#if 0
+typedef struct postproc_info_s {
+    UINT32 src_raw_addr[POSTPROC_MAX_RAW_PICTURE];             /* < source raw address, recorder only */
+    UINT32 src_raw_count;                                      /* < Current raw number, recorder only */
+    UINT32 src_raw_pitch;                                      /* < source raw pitch,   recorder only */
+    UINT32 src_raw_width;                                      /* < source raw width,   recorder only */
+    UINT32 src_raw_height;                                     /* < source raw height,  recorder only */
+    UINT32 src_thm_y_addr;                                     /* < source thumbnail y address,  recorder only, count is equal to src_y_count */
+    UINT32 src_thm_uv_addr;                                    /* < source thumbnail uv address, recorder only */
+    UINT32 src_thm_y_pitch;                                    /* < source thumbnail y pitch,  recorder only */
+    UINT32 src_thm_width;                                      /* < source thumbnail y width,  recorder only */
+    UINT32 src_thm_height;                                     /* < source thumbnail y height, recorder only */
+    UINT32 src_yuv_type;                                       /* < source yuv type */
+    UINT32 src_y_addr;                                         /* < source y address */
+    UINT32 src_uv_addr;                                        /* < source uv address */
+    UINT32 src_y_pitch;                                        /* < source y pitch */
+    UINT32 src_y_width;                                        /* < source y width */
+    UINT32 src_y_height;                                       /* < source y height */
+    UINT32 scaled_yuv_type;                                    /* < scaled yuv type,   player only */
+    UINT32 scaled_y_addr;                                      /* < scaled y address,  player only */
+    UINT32 scaled_uv_addr;                                     /* < scaled uv address, player only */
+    UINT32 scaled_pitch;                                       /* < scaled pitch,      player only */
+    UINT32 scaled_width;                                       /* < scaled width,      player only */
+    UINT32 scaled_height;                                      /* < scaled height,     player only */
+    UINT32 preview_y_addr;                                     /* < preview y address */
+    UINT32 preview_uv_addr;                                    /* < preview uv address */
+    UINT32 preview_pitch;                                      /* < preview pitch */
+    UINT32 preview_width;                                      /* < preview width */
+    UINT32 preview_height;                                     /* < preview height */
+    UINT32 secondary_stream_y_addr;                            /* < secondary stream y address */
+    UINT32 secondary_stream_uv_addr;                           /* < secondary stream uv address */
+    UINT32 secondary_stream_pitch;                             /* < secondary stream pitch */
+    UINT32 secondary_stream_width;                             /* < secondary stream width */
+    UINT32 secondary_stream_height;                            /* < secondary stream height */
+    UINT32 src_scrn_thm_y_addr;                                /* < source screen thumbnail y address,  recorder only, count is equal to src_y_count */
+    UINT32 src_scrn_thm_uv_addr;                               /* < source screen thumbnail uv address, recorder only */
+    UINT32 src_scrn_thm_y_pitch;                               /* < source screen thumbnail y pitch,    recorder only */
+    UINT32 src_scrn_thm_width;                                 /* < source screen thumbnail y width,    recorder only */
+    UINT32 src_scrn_thm_height;                                /* < source screen thumbnail y height,   recorder only */
+    UINT32 src_decision_map;                                   /* < For selection flow, callback function should tell flow controller which candidate is to
+                                                                    be saved to jpeg. bit[0] means the 1st picture*/
+    UINT32 src_uncompressed_raw_addr;                          /* < Current round's uncompressed raw data,             recorder only*/
+    UINT32 src_uncompressed_raw_modified;                      /* < Postprocessor has modified source raw data or not, recorder only*/
+    UINT32 sec_scaled_yuv_type;                                /* < scaled yuv type,   player only */
+    UINT32 sec_scaled_y_addr;                                  /* < scaled y address,  player only */
+    UINT32 sec_scaled_uv_addr;                                 /* < scaled uv address, player only */
+    UINT32 sec_scaled_pitch;                                   /* < scaled pitch,      player only */
+    UINT32 sec_scaled_width;                                   /* < scaled width,      player only */
+    UINT32 sec_scaled_height;                                  /* < scaled height,     player only */
+    UINT32 src_y_count;                                        /* < Last y array position */
+    UINT32 src_y_addr_ext[POSTPROC_MAX_YUV_PICTURE];           /* < source y address */
+    UINT32 src_uv_addr_ext[POSTPROC_MAX_YUV_PICTURE];          /* < source uv address */
+    UINT32 src_thm_y_addr_ext[POSTPROC_MAX_YUV_PICTURE];       /* < source thumbnail y address,  recorder only, count is equal to src_y_count */
+    UINT32 src_thm_uv_addr_ext[POSTPROC_MAX_YUV_PICTURE];      /* < source thumbnail uv address, recorder only */
+    UINT32 src_scrn_thm_y_addr_ext[POSTPROC_MAX_YUV_PICTURE];  /* < source screen thumbnail y address, recorder only, count is equal to src_y_count */
+    UINT32 src_scrn_thm_uv_addr_ext[POSTPROC_MAX_YUV_PICTURE]; /* < source screen thumbnail uv address, recorder only */
+    UINT32 piv_y_addr;                                         /* < piv y address */
+    UINT32 piv_uv_addr;                                        /* < piv uv address */
+    UINT32 piv_pitch;                                          /* < piv pitch */
+    UINT32 piv_width;                                          /* < piv width */
+    UINT32 piv_height;                                         /* < piv height */
+    UINT32 alpha_stream_addr;                                  /* < for yuv blending */
+    UINT32 selection_queue_total;                              /* < Total number of raw_select or yuv_select when selection begins */
+} postproc_info_t;
+
+typedef struct vin_status_s {
+    UINT8  video_mode;
+    UINT8  input_format;
+    UINT8  input_frame_rate_video;
+    UINT8  input_frame_rate_mjpg;
+    UINT8  input_frame_rate_still;
+    UINT8  padding[3];
+    UINT16 input_aspect_ratio;
+    UINT8  sensor_id;
+    UINT8  bayer_pattern;
+    UINT16 vidcap_w;
+    UINT16 vidcap_h;
+    UINT16 stillcap_w;
+    UINT16 stillcap_h;
+    UINT16 mjpegcap_w;
+    UINT16 mjpegcap_h;
+    UINT16 vio_sync_start_line;
+    UINT16 vio_sync_start_line1;
+    UINT32 sensor_readout_mode;
+    UINT8  video_source;
+    UINT8  bit_resolution;
+    UINT16 reserved[3];
+} vin_status_t;
+
+typedef struct rec_stillproc_from_mem_s {
+    UINT8  input_format;
+#define MW_REC_STILL_INPUT_RAW        0
+#define MW_REC_STILL_INPUT_YUV422    1
+#define MW_REC_STILL_INPUT_YUV420    2
+    UINT8  bayer_pattern;
+    UINT8  resolution;
+    UINT8  still_process_mode;
+#define MW_REC_STILL_PROCESS_MODE_DEFAULT    2
+    void (*src_load)(UINT32 input_addr, UINT32 buf_size);
+    UINT32 input_bytes;
+    UINT16 input_pitch;
+    UINT16 input_chroma_pitch;
+    UINT16 input_h;
+    UINT16 input_w;
+    UINT16 encode_h;
+    UINT16 encode_w;
+    UINT16 cap_cntl;
+    UINT16 reserved;
+    UINT32 src_buf_addr;        /* pre-allocated buffer address, if non-zero, MW will not call src_load() */
+    UINT32 number_of_frames;    /* For simulating multiple frame features */
+    UINT32 input_pic_offset;
+    UINT32 yuv_buffer_num;
+    UINT32 yuv422_buffer_num;
+    UINT32 sensor_readout_mode;
+} rec_stillproc_from_mem_info_t;
+#endif
+
+typedef struct _AMBA_DSP_WINDOW_s_ {
+	UINT32 Width;
+	UINT32 Height;
+}AMBA_DSP_WINDOW_s;
+
+typedef struct _IMG_SLICE_INFO_s_ {
+    /* System */
+    UINT8             SliceNumberX;
+    UINT8             SliceNumberY;
+    /* Raw frame DMA */
+    AMBA_DSP_WINDOW_s RawFrnDmaInfo;
+    /* Cfa Scaler */
+    AMBA_DSP_WINDOW_s CfaScalerOutInfo;
+    /* Mctf */
+    AMBA_DSP_WINDOW_s MctfOutWin;
+    UINT32            MctfOutCfgAddr;
+    /* IDSP section 2 */
+    AMBA_DSP_WINDOW_s Sec2CfgWin;
+    UINT32            Sec2CfgAddr;
+    /* IDSP section 3 */
+    AMBA_DSP_WINDOW_s Sec3CfgWin;
+    UINT32            Sec3CfgAddr;
+} IMG_SLICE_INFO_s;
+
+typedef struct _IMG_IDSP_CONFIG_INFO_s_ {
+    AMBA_DSP_WINDOW_s VCapWin;
+    AMBA_DSP_WINDOW_s EncWin;
+    UINT8             TotalSliceNumberX;
+    UINT8             TotalSliceNumberY;
+    IMG_SLICE_INFO_s  SliceInfo[2];
+    UINT32            Sec2CfgLen;
+    UINT32            Sec3CfgLen;
+} IMG_IDSP_CONFIG_INFO_s;
+
+
+/* Multiple params */
+/*
+typedef struct _MW_TWO_PARAM_s_ {
+    UINT32 Param1;
+    UINT32 Param2;
+} MW_TWO_PARAM_s;
+*/
+/*
+typedef struct _MW_THREE_PARAM_s_ {
+    UINT32 Param1;
+    UINT32 Param2;
+    UINT32 Param3;
+} MW_THREE_PARAM_s;
+*/
+/*
+typedef struct _MW_FOUR_PARAM_s_ {
+    UINT32 Param1;
+    UINT32 Param2;
+    UINT32 Param3;
+    UINT32 Param4;
+} MW_FOUR_PARAM_s;
+*/
+/*
+typedef struct _MW_FIVE_PARAM_s_ {
+    UINT32 Param1;
+    UINT32 Param2;
+    UINT32 Param3;
+    UINT32 Param4;
+    UINT32 Param5;
+} MW_FIVE_PARAM_s;
+*/
+/*
+typedef struct _MW_SIX_PARAM_s_ {
+    UINT32 Param1;
+    UINT32 Param2;
+    UINT32 Param3;
+    UINT32 Param4;
+    UINT32 Param5;
+    UINT32 Param6;
+} MW_SIX_PARAM_s;
+*/
+/*
+typedef struct _MW_SEVEN_PARAM_s_ {
+    UINT32 Param1;
+    UINT32 Param2;
+    UINT32 Param3;
+    UINT32 Param4;
+    UINT32 Param5;
+    UINT32 Param6;
+    UINT32 Param7;
+} MW_SEVEN_PARAM_s;
+*/
+/*
+typedef struct _MW_EIGHT_PARAM_s_ {
+    UINT32 Param1;
+    UINT32 Param2;
+    UINT32 Param3;
+    UINT32 Param4;
+    UINT32 Param5;
+    UINT32 Param6;
+    UINT32 Param7;
+    UINT32 param8;
+} MW_EIGHT_PARAM_s;
+*/
+typedef struct _ITUNER_SYSTEM_s_ {
+    char    AmbacamRev[16];
+    char    ChipRev[8];
+    char    SensorId[32];
+    char    UserMode[32];
+    char    TuningMode[32];
+    char    TuningModeExt[32];
+    char    RawPath[64];
+    char    ExtConfigPath[64];
+    UINT16  RawWidth;
+    UINT16  RawHeight;
+    UINT16  RawPitch;
+    UINT16  RawResolution;
+    UINT16  RawBayer;
+    UINT16  MainWidth;
+    UINT16  MainHeight;
+    UINT16  InputPicCnt;
+    UINT16  CompressedRaw;
+    UINT16  SensorReadoutMode;
+    UINT32  RawStartX;
+    UINT32  RawStartY;
+    UINT8   HSubSampleFactorNum;
+    UINT8   HSubSampleFactorDen;
+    UINT8   VSubSampleFactorNum;
+    UINT8   VSubSampleFactorDen;
+    char    OutputFilename[64];
+    UINT16  reserved[2];
+} ITUNER_SYSTEM_s;
+extern UINT8 FPNMap[4000*3000];
+
+typedef enum {
+    ITUNER_SYSTEM_INFO = 0,
+    ITUNER_INTERNAL_INFO,
+    ITUNER_AAA_FUNCTION,
+    ITUNER_AE_INFO,
+    ITUNER_AE_STATISTICS_INFO,
+    ITUNER_AWB_STATISTICS_INFO,
+    ITUNER_AF_STATISTICS_INFO,
+    ITUNER_STATIC_BAD_PIXEL_CORRECTION,
+    ITUNER_STATIC_BAD_PIXEL_CORRECTION_BY_PASS,
+    ITUNER_VIGNETTE_COMPENSATION,
+    ITUNER_VIGNETTE_COMPENSATION_BY_PASS,
+    ITUNER_WARP_COMPENSATION,
+    ITUNER_DZOOM,
+    ITUNER_WARP_COMPENSATION_DZOOM_BY_PASS,
+    ITUNER_SENSOR_INPUT_INFO,
+    ITUNER_STATIC_BLACK_LEVEL,
+    ITUNER_DEFERRED_BLACK_LEVEL,
+    ITUNER_DYNAMIC_BAD_PIXEL_CORRECTION,
+    ITUNER_HISO_DYNAMIC_BAD_PIXEL_CORRECTION,
+    ITUNER_CFA_LEAKAGE_FILTER,
+    ITUNER_HISO_CFA_LEAKAGE_FILTER,
+    ITUNER_CFA_NOISE_FILTER,
+    ITUNER_HISO_CFA_NOISE_FILTER,
+    ITUNER_ANTI_ALIASING_STRENGTH,
+    ITUNER_HISO_ANTI_ALIASING_STRENGTH,
+    ITUNER_GLOBAL_DGAIN,
+    ITUNER_WB_GAIN,
+    ITUNER_DGAIN_SATURATION_LEVEL,
+    ITUNER_LOCAL_EXPOSURE,
+    ITUNER_COLOR_CORRECTION,
+    ITUNER_TONE_CURVE,
+    ITUNER_RGB_TO_YUV_MATRIX,
+    ITUNER_CHROMA_SCALE,
+    ITUNER_CHROMA_MEDIAN_FILTER,
+    ITUNER_HISO_CHROMA_MEDIAN_FILTER,
+    ITUNER_DEMOSAIC_FILTER,
+    ITUNER_SHARPEN_BOTH,
+    ITUNER_SHARPEN_NOISE,
+    ITUNER_FIR,
+    ITUNER_CORING,
+    ITUNER_CORING_INDEX_SCALE,
+    ITUNER_MIN_CORING_RESULT,
+    ITUNER_SCALE_CORING,
+    ITUNER_FINAL_SHARPEN_BOTH,
+    ITUNER_FINAL_SHARPEN_NOISE,
+    ITUNER_FINAL_FIR,
+    ITUNER_FINAL_CORING,
+    ITUNER_FINAL_CORING_INDEX_SCALE,
+    ITUNER_FINAL_MIN_CORING_RESULT,
+    ITUNER_FINAL_SCALE_CORING,
+    ITUNER_HISO_DEMOSAIC_FILTER,
+    ITUNER_HISO_HIGH_SHARPEN_BOTH,
+    ITUNER_HISO_MED_SHARPEN_BOTH,
+    ITUNER_HISO_HIGH_SHARPEN_NOISE,
+    ITUNER_HISO_MED_SHARPEN_NOISE,
+    ITUNER_HISO_HIGH_FIR,
+    ITUNER_HISO_MED_FIR,
+    ITUNER_HISO_HIGH_CORING,
+    ITUNER_HISO_MED_CORING,
+    ITUNER_HISO_HIGH_CORING_INDEX_SCALE,
+    ITUNER_HISO_HIGH_MIN_CORING_RESULT,
+    ITUNER_HISO_HIGH_SCALE_CORING,
+    ITUNER_HISO_MED_CORING_INDEX_SCALE,
+    ITUNER_HISO_MED_MIN_CORING_RESULT,
+    ITUNER_HISO_MED_SCALE_CORING,
+    ITUNER_VIDEO_MCTF,
+    ITUNER_VIDEO_MCTF_TEMPORAL_ADJUST,
+    ITUNER_CDNR,
+    ITUNER_HISO_DEFER_COLOR_CORRECTION,
+    ITUNER_SHP_A_OR_SPATIAL_FILTE_SELECT,
+    ITUNER_ASF_INFO,
+    ITUNER_HISO_ASF,
+    ITUNER_HISO_HIGH_ASF,
+    ITUNER_HISO_LOW_ASF,
+    ITUNER_HISO_MED_ASF,
+    ITUNER_HISO_CHROMA_ASF,
+    ITUNER_CHROMA_FILTER,
+    ITUNER_WIDE_CHROMA_FILTER,
+    ITUNER_WIDE_CHROMA_FILTER_COMBINE,
+    ITUNER_HISO_CHROMA_FILTER_HIGH,
+    ITUNER_GB_GR_MISMATCH,
+    ITUNER_HISO_GB_GR_MISMATCH,
+    ITUNER_CHROMA_ABERRATION_INFO,
+    ITUNER_CHROMA_ABERRATION_INFO_BY_PASS,
+    ITUNER_HISO_CHROMA_FILTER_LOW_VERY_LOW,
+    ITUNER_HISO_CHROMA_FILTER_PRE,
+    ITUNER_HISO_CHROMA_FILTER_MED,
+    ITUNER_HISO_CHROMA_FILTER_LOW,
+    ITUNER_HISO_CHROMA_FILTER_VERY_LOW,
+    ITUNER_HISO_CHROMA_FILTER_VERY_LOW_COMBINE,
+    ITUNER_HISO_CHROMA_FILTER_MED_COMBINE,
+    ITUNER_HISO_CHROMA_FILTER_LOW_COMBINE,
+    ITUNER_HISO_LUMA_NOISE_COMBINE,
+    ITUNER_HISO_LOW_ASF_COMBINE,
+    ITUNER_HISO_FREQ_RECOVER,
+    ITUNER_SENSOR_INFO,
+    ITUNER_MO_DYNAMIC_BAD_PIXEL_CORRECTION,
+    ITUNER_MO_CFA_LEAKAGE_FILTER,
+    ITUNER_MO_CFA_NOISE_FILTER,
+    ITUNER_MO_ANTI_ALIASING_STRENGTH,
+    ITUNER_MO_DEMOSAIC_FILTER,
+    ITUNER_MO_GB_GR_MISMATCH,
+    ITUNER_MO_SHP_A_OR_SPATIAL_FILTE_SELECT,
+    ITUNER_MO_ASF_INFO,
+    ITUNER_MO_CHROMA_FILTER,
+    ITUNER_MO_CHROMA_MEDIAN_FILTER,
+    ITUNER_MO_SHARPEN_BOTH,
+    ITUNER_MO_SHARPEN_NOISE,
+    ITUNER_MO_FIR,
+    ITUNER_MO_CORING,
+    ITUNER_MO_CORING_INDEX_SCALE,
+    ITUNER_MO_MIN_CORING_RESULT,
+    ITUNER_MO_SCALE_CORING,
+    ITUNER_MAX,
+} ITUNER_VALID_s;
+typedef UINT8 AMBA_ITUNER_VALID_FILTER_t[ITUNER_MAX];
+/*---------------------------------------------------------------------------*\
+ * Defined in AmbaImgCalibItunerImpl.c
+\*---------------------------------------------------------------------------*/
+
+typedef enum { // Note: Should be move to AmbamgCalibItuner.h
+    EXT_FILE_FPN_MAP = 0,
+    EXT_FILE_BYPASS_FPN_MAP,
+    EXT_FILE_VIGNETTE_GAIN,
+    EXT_FILE_BYPASS_VIGNETTE_GAIN,
+    EXT_FILE_WARP_TABLE,
+    EXT_FILE_BYPASS_WARP_HORIZONTAL_TABLE,
+    EXT_FILE_BYPASS_WARP_VERTICAL_TABLE,
+    EXT_FILE_CA_TABLE,
+    EXT_FILE_BYPASS_CA_HORIZONTAL_TABLE,
+    EXT_FILE_BYPASS_CA_VERTICAL_TABLE,
+    EXT_FILE_CC_REG,
+    EXT_FILE_CC_THREED,
+
+    EXT_FILE_FIRST_SHARPEN,
+    EXT_FILE_ASF,
+
+    EXT_FILE_HISO_LOW_ASF,
+
+
+    EXT_FILE_HISO_CHROMA_MED_COMBINE,
+    EXT_FILE_HISO_CHROMA_VERYLOW_COMBINE,
+
+    EXT_FILE_RAW,
+    EXT_FILE_JPG,
+    EXT_FILE_YUV,
+    EXT_FILE_MAX,
+} Ituner_Ext_File_Type_e;
+typedef struct {
+    void* Address;
+    UINT32 Size;
+} Load_Data_Info_s;
+typedef struct {
+    UINT8 Reserved;
+} Save_Data_Info_s;
+typedef struct {
+    void* Address;
+    UINT32 Max_Size;
+} Load_Data_Info_Unknow_Size_s;
+
+typedef struct {
+    void* Address;
+    UINT32 Size;
+    char* Target_File_Path;
+} Save_Data_to_Path_Info_s;
+typedef struct {
+    Save_Data_to_Path_Info_s Y_Info;
+    Save_Data_to_Path_Info_s UV_Info;
+} Save_YUV_Info_s;
+typedef union { // Note: Should be move to AmbamgCalibItuner.h
+    Load_Data_Info_Unknow_Size_s Raw_Load_Param;
+    //Save_Raw_Info_s Raw_Save_Param;
+    Save_Data_Info_s FPN_MAP_Ext_Save_Param;
+    Load_Data_Info_s FPN_MAP_Ext_Load_Param;
+    Save_Data_Info_s Bypass_FPN_MAP_Ext_Save_Param;
+    Load_Data_Info_s Bypass_FPN_MAP_Ext_Load_Param;
+    Save_Data_Info_s Vignette_Gain_Save_Param;
+    Load_Data_Info_s Vignette_Gain_Load_Param;
+    Save_Data_Info_s Bypass_Vignette_Gain_Save_Param;
+    Load_Data_Info_s Bypass_Vignette_Gain_Load_Param;
+    Save_Data_Info_s Warp_Table_Save_Param;
+    Load_Data_Info_s Warp_Table_Load_Param;
+    Load_Data_Info_Unknow_Size_s Bypass_Warp_Horizontal_Table_Load_Param;
+    Load_Data_Info_Unknow_Size_s Bypass_Warp_Vertical_Table_Load_Param;
+    Save_Data_Info_s Ca_Table_Save_Param;
+    Load_Data_Info_s Ca_Table_Load_Param;
+    Load_Data_Info_Unknow_Size_s Bypass_Ca_Horizontal_Table_Load_Param;
+    Load_Data_Info_Unknow_Size_s Bypass_Ca_Vertical_Table_Load_Param;
+    Save_Data_Info_s CC_Reg_Save_Param;
+    Load_Data_Info_s CC_Reg_Load_Param;
+    Save_Data_Info_s CC_ThreeD_Save_Param;
+    Load_Data_Info_s CC_ThreeD_Load_Param;
+
+    Save_Data_Info_s FIRST_SHARPEN_Save_Param;
+    Load_Data_Info_s FIRST_SHARPEN_Load_Param;
+    Save_Data_Info_s FINAL_SHARPEN_Save_Param;
+    Load_Data_Info_s FINAL_SHARPEN_Load_Param;
+    Save_Data_Info_s ASF_Save_Param;
+    Load_Data_Info_s ASF_Load_Param;
+
+    Save_Data_Info_s HISO_ASF_Save_Param;
+    Load_Data_Info_s HISO_ASF_Load_Param;
+    Save_Data_Info_s HISO_HIGH_ASF_Save_Param;
+    Load_Data_Info_s HISO_HIGH_ASF_Load_Param;
+    Save_Data_Info_s HISO_LOW_ASF_Save_Param;
+    Load_Data_Info_s HISO_LOW_ASF_Load_Param;
+    Save_Data_Info_s HISO_MED1_ASF_Save_Param;
+    Load_Data_Info_s HISO_MED1_ASF_Load_Param;
+    Save_Data_Info_s HISO_MED2_ASF_Save_Param;
+    Load_Data_Info_s HISO_MED2_ASF_Load_Param;
+    Save_Data_Info_s HISO_LI2ND_ASF_Save_Param;
+    Load_Data_Info_s HISO_LI2ND_ASF_Load_Param;
+    Save_Data_Info_s HISO_CHROMA_ASF_Save_Param;
+    Load_Data_Info_s HISO_CHROMA_ASF_Load_Param;
+
+    Save_Data_Info_s HISO_HIGH_SHARPEN_Save_Param;
+    Load_Data_Info_s HISO_HIGH_SHARPEN_Load_Param;
+    Save_Data_Info_s HISO_MED_SHARPEN_Save_Param;
+    Load_Data_Info_s HISO_MED_SHARPEN_Load_Param;
+    Save_Data_Info_s HISO_LISO1_SHARPEN_Save_Param;
+    Load_Data_Info_s HISO_LISO1_SHARPEN_Load_Param;
+    Save_Data_Info_s HISO_LISO2_SHARPEN_Save_Param;
+    Load_Data_Info_s HISO_LISO2_SHARPEN_Load_Param;
+
+    Save_Data_Info_s HISO_CHROMA_MED_COMBINE_Save_Param;
+    Load_Data_Info_s HISO_CHROMA_MED_COMBINE_Load_Param;
+    Save_Data_Info_s HISO_CHROMA_LOW_COMBINE_Save_Param;
+    Load_Data_Info_s HISO_CHROMA_LOW_COMBINE_Load_Param;
+    Save_Data_Info_s HISO_CHROMA_VERYLOW_COMBINE_Save_Param;
+    Load_Data_Info_s HISO_CHROMA_VERYLOW_COMBINE_Load_Param;
+    Save_Data_Info_s HISO_LUMA_NOISE_COMBINE_Save_Param;
+    Load_Data_Info_s HISO_LUMA_NOISE_COMBINE_Load_Param;
+    Save_Data_Info_s HISO_LOW_ASF_COMBINE_Save_Param;
+    Load_Data_Info_s HISO_LOW_ASF_COMBINE_Load_Param;
+    Save_Data_Info_s HISO_COMBINE_Save_Param;
+    Load_Data_Info_s HISO_COMBINE_Load_Param;
+
+    Save_YUV_Info_s YUV_Save_Param;
+    //Save_JPG_Info_s JPG_Save_Param;
+
+} Ituner_Ext_File_Param_s;
+typedef struct {
+    int (*Save_Data)(Ituner_Ext_File_Type_e Ext_File_Type, Ituner_Ext_File_Param_s* Ext_File_Param);
+    int (*Load_Data)(Ituner_Ext_File_Type_e Ext_File_Type, Ituner_Ext_File_Param_s* Ext_File_Param);
+} AmbaItuner_Hook_Func_t;
+
+typedef struct{
+    AmbaItuner_Hook_Func_t Hook_Func;
+} AmbaItuner_Config_t;
+typedef struct _AMBA_ITUNER_PROC_INFO_s_{ // Note: Should be move to AmbamgCalibItuner.h
+    UINT8  HisoBatchId;
+} AMBA_ITUNER_PROC_INFO_s;
+
+/**
+ * @brief AmbaItuner Initial
+ * If you want to use any AmbaItuner_xxx(), please call this function first.
+ *
+ * @param[in] AmbaItuner_Config_t *Config: Setup call back function and other param, that tuning need.\n
+ *                                         Detail please reference AmbaItuner_Confit_t
+ *
+ * @return 0 (Success) / -1 (Failure)
+ */
+int AmbaItuner_Init(AmbaItuner_Config_t *Config);
+
+/**
+ * @brief Refresh GData(The database, use to store config of the image kernel filter, U can use AmbaItuner_Get/Set_XXX() access GData)
+ * This function will access the api of image kernel, to get current filter config, and store those config to GData.
+ *
+ * @param[in] amba_img_dsp_mode_cfg_t Mode: set Pipe and AlgoMode
+ *
+ * @return 0 (Success) / -1 (Failure)
+ */
+int AmbaItuner_Refresh(amba_img_dsp_mode_cfg_t Mode);
+
+/**
+ * @brief Apply idsp configure of GData to ucode
+ * This function will apply a part of the idsp config that filter status is valid to ucode.\n
+ * Please make sure the config of GData was already updated.
+ *
+ * @param[in] amba_img_dsp_mode_cfg_t Mode: set Pipe and AlgoMode
+ * @param[in] AMBA_ITUNER_PROC_INFO_s *ProcInfo: set high iso batch id
+ *
+ * @return 0 (Success) / -1 (Failure)
+ */
+int AmbaItuner_Execute(int fd_iav, amba_img_dsp_mode_cfg_t Mode, AMBA_ITUNER_PROC_INFO_s *ProcInfo);
+
+/**
+ * @brief Set SystemInfo of GData
+ * This function will replace SystemInfo of GData, and set ITUNER_SYSTEM_INFO filter status is valid.\n
+ * If you want to update a part of SystemInfo, you should call AmbaItuner_Get_SystemInfo() to get current SystemInfo before the replace process.
+ *
+ * @param[in] ITUNER_SYSTEM_s *System: System Info Config. Detail please reference ITUNER_SYSTEM_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_SystemInfo(ITUNER_SYSTEM_s *System);
+
+/**
+ * @brief Get SystemInfo of GData
+ * This function will copy SystemInfo of GData.
+ *
+ * @param[out] ITUNER_SYSTEM_s *System: System Info Config. Detail please reference ITUNER_SYSTEM_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_SystemInfo(ITUNER_SYSTEM_s *System);
+
+/**
+ * @brief Set InternalInfo of GData
+ * This function will replace InternalInfo of GData, and set ITUNER_INTERNAL_INFO filter status is valid.\n
+ * If you want to update a part of InternalInfo, you should call AmbaItuner_Get_InternalInfo() to get current InternalInfo before the replace process.
+ *
+ * @param[in] ITUNER_Internal_s *Internal: Internal Info Config. Detail please reference ITUNER_Internal_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_InternalInfo(Ituner_Internal_s *Internal);
+
+/**
+ * @brief Get InternalInfo of GData
+ * This function will copy InternalInfo of GData.
+ *
+ * @param[out] Ituner_Internal_s *Internal: Internal Info Config. Detail please reference Ituner_Internal_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_InternalInfo(Ituner_Internal_s *Internal);
+
+/**
+ * @brief Set AaaFunctionInfo of GData
+ * This function will replace AaaFunctionInfo of GData, and set ITUNER_AAA_FUNCTION filter status is valid.\n
+ * If you want to update a part of AaaFunctionInfo, you should call AmbaItuner_Get_AAAFunction() to get current AaaFunctionInfo before the replace process.
+ *
+ * @param[in] AAA_FUNC_s *AaaFunction: AaaFunction Info Config. Detail please reference AAA_FUNC_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_AAAFunction(AAA_FUNC_s *AaaFunction);
+
+/**
+ * @brief Get AaaFunctionInfo of GData
+ * This function will copy AaaFunctionInfo of GData.
+ *
+ * @param[out] AAA_FUNC_s *AaaFunction: AaaFunction Info Config. Detail please reference AAA_FUNC_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_AAAFunction(AAA_FUNC_s *AaaFunction);
+
+/**
+ * @brief Set AeInfo of GData
+ * This function will replace AeInfo of GData, and set ITUNER_AE_INFO is valid.\n
+ * If you want to update a part of AeInfo, you should call AmbaItuner_Get_AeInfo() to get current AeInfo before the replace process.
+ *
+ * @param[in] IMG_EXP_s *AeInfo: AeInfo Config. Detail please reference IMG_EXP_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_AeInfo(IMG_EXP_s *AeInfo);
+
+/**
+ * @brief Get AeInfo of GData
+ * This function will copy AeInfo of GData.
+ *
+ * @param[out] IMG_EXP_s *AeInfo: AeInfo Config. Detail please reference IMG_EXP_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_AeInfo(IMG_EXP_s *AeInfo);
+
+/**
+ * @brief Set AeStatisticsInfo of GData
+ * This function will replace AeStatisticsInfo of GData, and set ITUNER_AE_STATISTICS_INFO is valid.\n
+ * If you want to update a part of AeStatisticsInfo, you should call AmbaItuner_Get_AeStatisticsInfo() to get current AeStatisticsInfo before the replace process.
+ *
+ * @param[in] amba_img_dsp_ae_stat_info_t *AeStatisticsInfo: AeStatisticsInfo Config. Detail please reference amba_img_dsp_ae_stat_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_AeStatisticsInfo(amba_img_dsp_ae_stat_info_t *AeStatisticsInfo);
+
+/**
+ * @brief Get AeStatisticsInfo of GData
+ * This function will copy AeStatisticsInfo of GData.
+ *
+ * @param[out] amba_img_dsp_ae_stat_info_t *AeStatisticsInfo: AeStatisticsInfo Config. Detail please reference amba_img_dsp_ae_stat_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_AeStatisticsInfo(amba_img_dsp_ae_stat_info_t *AeStatisticsInfo);
+
+/**
+ * @brief Set AwbStatisticsInfo of GData
+ * This function will replace AwbStatisticsInfo of GData, and set ITUNER_AWB_STATISTICS_INFO is valid.\n
+ * If you want to update a part of AwbStatisticsInfo, you should call AmbaItuner_Get_AwbStatisticsInfo() to get current AwbStatisticsInfo before the replace process.
+ *
+ * @param[in] amba_img_dsp_awb_stat_info_t *AwbStatisticsInfo: AwbStatisticsInfo Config. Detail please reference amba_img_dsp_awb_stat_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_AwbStatisticsInfo(amba_img_dsp_awb_stat_info_t *AwbStatisticsInfo);
+
+/**
+ * @brief Get AwbStatisticsInfo of GData
+ * This function will copy AwbStatisticsInfo of GData.
+ *
+ * @param[out] amba_img_dsp_awb_stat_info_t *AwbStatisticsInfo: AwbStatisticsInfo Config. Detail please reference amba_img_dsp_awb_stat_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_AwbStatisticsInfo(amba_img_dsp_awb_stat_info_t *AwbStatisticsInfo);
+
+/**
+ * @brief Set AfStatisticsInfo of GData
+ * This function will replace AfStatisticsInfo of GData, and set ITUNER_AF_STATISTICS_INFO is valid.\n
+ * If you want to update a part of AfStatisticsInfo, you should call AmbaItuner_Get_AfStatisticsInfo() to get current AfStatisticsInfo before the replace process.
+ *
+ * @param[in] amba_img_dsp_af_stat_info_t *AfStatisticsInfo: AfStatisticsInfo Config. Detail please reference amba_img_dsp_af_stat_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_AfStatisticsInfo(amba_img_dsp_af_stat_info_t *AfStatisticsInfo);
+
+/**
+ * @brief Get AfStatisticsInfo of GData
+ * This function will copy AfStatisticsInfo of GData.
+ *
+ * @param[out] amba_img_dsp_af_stat_info_t *AfStatisticsInfo: AfStatisticsInfo Config. Detail please reference amba_img_dsp_af_stat_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_AfStatisticsInfo(amba_img_dsp_af_stat_info_t *AfStatisticsInfo);
+
+/**
+ * @brief Set StaticBadPixelCorrection of GData
+ * This function will replace StaticBadPixelCorrection of GData, and set ITUNER_STATIC_BAD_PIXEL_CORRECTION is valid.\n
+ * If you want to update a part of StaticBadPixelCorrection, you should call AmbaItuner_Get_StaticBadPixelCorrection() to get current StaticBadPixelCorrection before the replace process.
+ *
+ * @param[in] ITUNER_FPN_s *StaticBadPixelCorrection: StaticBadPixelCorrection Config. Detail please reference ITUNER_FPN_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_StaticBadPixelCorrection(ITUNER_FPN_s *StaticBadPixelCorrection);
+
+/**
+ * @brief Get StaticBadPixelCorrection of GData
+ * This function will copy StaticBadPixelCorrection of GData.
+ *
+ * @param[out] ITUNER_FPN_s *StaticBadPixelCorrection: StaticBadPixelCorrection Config. Detail please reference ITUNER_FPN_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_StaticBadPixelCorrection(ITUNER_FPN_s *StaticBadPixelCorrection);
+
+/**
+ * @brief Get FPN Map
+ * This function will copy FPN Map of GData.(Read only)
+ *
+ * @param[out] amba_img_dsp_sbp_correction_t *SbpCorr: FPN Map, It's read only, please don't edit it.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_SbpCorr(amba_img_dsp_sbp_correction_t *SbpCorr);
+
+/**
+ * @brief Set StaticBadPixelCorrectionByPass of GData
+ * This function will replace StaticBadPixelCorrectionByPass of GData, and set ITUNER_STATIC_BAD_PIXEL_CORRECTION_BY_PASS is valid.\n
+ * If you want to update a part of StaticBadPixelCorrectionByPass, you should call AmbaItuner_Get_StaticBadPixelCorrectionByPass() to get current StaticBadPixelCorrectionByPass before the replace process.
+ *
+ * @param[in] ITUNER_FPN_BYPASS_s *StaticBadPixelCorrectionByPass: StaticBadPixelCorrectionByPass Config. Detail please reference ITUNER_FPN_BYPASS_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_StaticBadPixelCorrectionByPass(ITUNER_FPN_BYPASS_s *StaticBadPixelCorrectionByPass);
+
+/**
+ * @brief Get StaticBadPixelCorrectionByPass of GData
+ * This function will copy StaticBadPixelCorrectionByPass of GData.
+ *
+ * @param[out] ITUNER_FPN_BYPASS_s *StaticBadPixelCorrectionByPass: StaticBadPixelCorrectionByPass Config. Detail please reference ITUNER_FPN_BYPASS_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_StaticBadPixelCorrectionByPass(ITUNER_FPN_BYPASS_s *StaticBadPixelCorrectionByPass);
+
+/**
+ * @brief Set VignetteCompensation of GData
+ * This function will replace VignetteCompensation of GData, and set ITUNER_VIGNETTE_COMPENSATION is valid.\n
+ * If you want to update a part of VignetteCompensation, you should call AmbaItuner_Get_VignetteCompensation() to get current VignetteCompensation before the replace process.
+ *
+ * @param[in] ITUNER_VIGNETTE_s *VignetteCompensation: VignetteCompensation Config. Detail please reference ITUNER_VIGNETTE_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_VignetteCompensation(ITUNER_VIGNETTE_s *VignetteCompensation);
+
+/**
+ * @brief Get VignetteCompensation of GData
+ * This function will copy VignetteCompensation of GData.
+ *
+ * @param[out] ITUNER_VIGNETTE_s *VignetteCompensation: VignetteCompensation Config. Detail please reference ITUNER_VIGNETTE_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_VignetteCompensation(ITUNER_VIGNETTE_s *VignetteCompensation);
+
+/**
+ * @brief Get Vignette Table
+ * This function will copy Vignette Table of GData.(Read only)
+ *
+ * @param[out] amba_img_dsp_vignette_calc_info_t *VignetteCalcInfo: Vignette Table, It's read only, please don't edit it.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_VignetteCalcInfo(amba_img_dsp_vignette_calc_info_t *VignetteCalcInfo);
+
+/**
+ * @brief Set VignetteCompensationByPass of GData
+ * This function will replace VignetteCompensationByPass of GData, and set ITUNER_VIGNETTE_COMPENSATION_BY_PASS is valid.\n
+ * If you want to update a part of VignetteCompensationByPass, you should call AmbaItuner_Get_VignetteCompensationByPass() to get current VignetteCompensationByPass before the replace process.
+ *
+ * @param[in] ITUNER_VIGNETTE_BYPASS_s *VignetteCompensationByPass: VignetteCompensationByPass Config. Detail please reference ITUNER_VIGNETTE_BYPASS_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_VignetteCompensationByPass(ITUNER_VIGNETTE_BYPASS_s *VignetteCompensationByPass);
+
+/**
+ * @brief Get VignetteCompensationByPass of GData
+ * This function will copy VignetteCompensationByPass of GData.
+ *
+ * @param[out] ITUNER_VIGNETTE_BYPASS_s *VignetteCompensationByPass: VignetteCompensationByPass Config. Detail please reference ITUNER_VIGNETTE_BYPASS_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_VignetteCompensationByPass(ITUNER_VIGNETTE_BYPASS_s *VignetteCompensationByPass);
+
+/**
+ * @brief Set WarpCompensation of GData
+ * This function will replace WarpCompensation of GData, and set ITUNER_WARP_COMPENSATION is valid.\n
+ * If you want to update a part of WarpCompensation, you should call AmbaItuner_Get_WarpCompensation() to get current WarpCompensation before the replace process.
+ *
+ * @param[in] ITUNER_WARP_s *WarpCompensation: WarpCompensation Config. Detail please reference ITUNER_WARP_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_WarpCompensation(ITUNER_WARP_s *WarpCompensation);
+
+/**
+ * @brief Get WarpCompensation of GData
+ * This function will copy WarpCompensation of GData.
+ *
+ * @param[out] ITUNER_WARP_s *WarpCompensation: WarpCompensation Config. Detail please reference ITUNER_WARP_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_WarpCompensation(ITUNER_WARP_s *WarpCompensation);
+
+/**
+ * @brief Get Warp Table
+ * This function will copy Warp Table of GData.(Read only)
+ *
+ * @param[out] amba_img_dsp_warp_calc_info_t *WarpCalcInfo: Warp Table, It's read only, please don't edit it.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_WarpCalcInfo(amba_img_dsp_warp_calc_info_t *WarpCalcInfo);
+
+/**
+ * @brief Set Dzoom of GData
+ * This function will replace Dzoom of GData, and set ITUNER_DZOOM is valid.\n
+ * If you want to update a part of Dzoom, you should call AmbaItuner_Get_Dzoom() to get current Dzoom before the replace process.
+ *
+ * @param[in] ITUNER_DZOOM_s *Dzoom: Dzoom Config. Detail please reference ITUNER_DZOOM_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_Dzoom(ITUNER_DZOOM_s *Dzoom);
+
+/**
+ * @brief Get Dzoom of GData
+ * This function will copy Dzoom of GData.
+ *
+ * @param[out] ITUNER_DZOOM_s *Dzoom: Dzoom Config. Detail please reference ITUNER_DZOOM_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_Dzoom(ITUNER_DZOOM_s *Dzoom);
+
+/**
+ * @brief Set WarpCompensationDzoomByPass of GData
+ * This function will replace WarpCompensationDzoomByPass of GData, and set ITUNER_WARP_COMPENSATION_DZOOM_BY_PASS is valid.\n
+ * If you want to update a part of WarpCompensationDzoomByPass, you should call AmbaItuner_Get_WarpCompensationDzoomByPass() to get current WarpCompensationDzoomByPass before the replace process.
+ *
+ * @param[in] ITUNER_WARP_DZOOM_BYPASS_s *WarpCompensationDzoomByPass: WarpCompensationDzoomByPass Config. Detail please reference ITUNER_WARP_DZOOM_BYPASS_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_WarpCompensationDzoomByPass(ITUNER_WARP_DZOOM_BYPASS_s *WarpCompensationDzoomByPass);
+
+/**
+ * @brief Get WarpCompensationDzoomByPass of GData
+ * This function will copy WarpCompensationDzoomByPass of GData.
+ *
+ * @param[out] ITUNER_WARP_DZOOM_BYPASS_s *WarpCompensationDzoomByPass: WarpCompensationDzoomByPass Config. Detail please reference ITUNER_WARP_DZOOM_BYPASS_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_WarpCompensationDzoomByPass(ITUNER_WARP_DZOOM_BYPASS_s *WarpCompensationDzoomByPass);
+
+/**
+ * @brief Set SensorInputInfo of GData
+ * This function will replace SensorInputInfo of GData, and set ITUNER_SENSOR_INPUT_INFO is valid.\n
+ * If you want to update a part of SensorInputInfo, you should call AmbaItuner_Get_SensorInputInfo() to get current SensorInputInfo before the replace process.
+ *
+ * @param[in] ITUNER_SENSOR_INPUT_s *SensorInputInfo: SensorInputInfo Config. Detail please reference ITUNER_SENSOR_INPUT_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_SensorInputInfo(ITUNER_SENSOR_INPUT_s *SensorInputInfo);
+
+/**
+ * @brief Get SensorInputInfo of GData
+ * This function will copy SensorInputInfo of GData.
+ *
+ * @param[out] ITUNER_SENSOR_INPUT_s *SensorInputInfo: SensorInputInfo Config. Detail please reference ITUNER_SENSOR_INPUT_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_SensorInputInfo(ITUNER_SENSOR_INPUT_s *SensorInputInfo);
+
+/**
+ * @brief Set StaticBlackLevel of GData
+ * This function will replace StaticBlackLevel of GData, and set ITUNER_STATIC_BLACK_LEVEL is valid.\n
+ * If you want to update a part of StaticBlackLevel, you should call AmbaItuner_Get_StaticBlackLevel() to get current StaticBlackLevel before the replace process.
+ *
+ * @param[in] amba_img_dsp_black_correction_t *StaticBlackLevel: StaticBlackLevel Config. Detail please reference amba_img_dsp_black_correction_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_StaticBlackLevel(amba_img_dsp_black_correction_t *StaticBlackLevel);
+
+/**
+ * @brief Get StaticBlackLevel of GData
+ * This function will copy StaticBlackLevel of GData.
+ *
+ * @param[out] amba_img_dsp_black_correction_t *StaticBlackLevel: StaticBlackLevel Config. Detail please reference amba_img_dsp_black_correction_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_StaticBlackLevel(amba_img_dsp_black_correction_t *StaticBlackLevel);
+
+/**
+ * @brief Set DeferredBlackLevel of GData
+ * This function will replace DeferredBlackLevel of GData, and set ITUNER_DEFERRED_BLACK_LEVEL is valid.\n
+ * If you want to update a part of DeferredBlackLevel, you should call AmbaItuner_Get_DeferredBlackLevel() to get current DeferredBlackLevel before the replace process.
+ *
+ * @param[in] amba_img_dsp_def_blc_t *DeferredBlackLevel: DeferredBlackLevel Config. Detail please reference amba_img_dsp_def_blc_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_DeferredBlackLevel(amba_img_dsp_def_blc_t *DeferredBlackLevel);
+
+/**
+ * @brief Get DeferredBlackLevel of GData
+ * This function will copy DeferredBlackLevel of GData.
+ *
+ * @param[out] amba_img_dsp_def_blc_t *DeferredBlackLevel: DeferredBlackLevel Config. Detail please reference amba_img_dsp_def_blc_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_DeferredBlackLevel(amba_img_dsp_def_blc_t *DeferredBlackLevel);
+
+/**
+ * @brief Set DynamicBadPixelCorrection of GData
+ * This function will replace DynamicBadPixelCorrection of GData, and set ITUNER_DYNAMIC_BAD_PIXEL_CORRECTION is valid.\n
+ * If you want to update a part of DynamicBadPixelCorrection, you should call AmbaItuner_Get_DynamicBadPixelCorrection() to get current DynamicBadPixelCorrection before the replace process.
+ *
+ * @param[in] amba_img_dsp_dbp_correction_t *DynamicBadPixelCorrection: DynamicBadPixelCorrection Config. Detail please reference amba_img_dsp_dbp_correction_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_DynamicBadPixelCorrection(amba_img_dsp_dbp_correction_t *DynamicBadPixelCorrection);
+
+/**
+ * @brief Get DynamicBadPixelCorrection of GData
+ * This function will copy DynamicBadPixelCorrection of GData.
+ *
+ * @param[out] amba_img_dsp_dbp_correction_t *DynamicBadPixelCorrection: DynamicBadPixelCorrection Config. Detail please reference amba_img_dsp_dbp_correction_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_DynamicBadPixelCorrection(amba_img_dsp_dbp_correction_t *DynamicBadPixelCorrection);
+
+/**
+ * @brief Set HisoDynamicBadPixelCorrection of GData
+ * This function will replace HisoDynamicBadPixelCorrection of GData, and set ITUNER_HISO_DYNAMIC_BAD_PIXEL_CORRECTION is valid.\n
+ * If you want to update a part of HisoDynamicBadPixelCorrection, you should call AmbaItuner_Get_HisoDynamicBadPixelCorrection() to get current HisoDynamicBadPixelCorrection before the replace process.
+ *
+ * @param[in] amba_img_dsp_dbp_correction_t *HisoDynamicBadPixelCorrection: HisoDynamicBadPixelCorrection Config. Detail please reference amba_img_dsp_dbp_correction_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoDynamicBadPixelCorrection(amba_img_dsp_dbp_correction_t *HisoDynamicBadPixelCorrection);
+
+/**
+ * @brief Get HisoDynamicBadPixelCorrection of GData
+ * This function will copy HisoDynamicBadPixelCorrection of GData.
+ *
+ * @param[out] amba_img_dsp_dbp_correction_t *HisoDynamicBadPixelCorrection: HisoDynamicBadPixelCorrection Config. Detail please reference amba_img_dsp_dbp_correction_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoDynamicBadPixelCorrection(amba_img_dsp_dbp_correction_t *HisoDynamicBadPixelCorrection);
+
+/**
+ * @brief Set CfaLeakageFilter of GData
+ * This function will replace CfaLeakageFilter of GData, and set ITUNER_CFA_LEAKAGE_FILTER is valid.\n
+ * If you want to update a part of CfaLeakageFilter, you should call AmbaItuner_Get_CfaLeakageFilter() to get current CfaLeakageFilter before the replace process.
+ *
+ * @param[in] amba_img_dsp_cfa_leakage_filter_t *CfaLeakageFilter: CfaLeakageFilter Config. Detail please reference amba_img_dsp_cfa_leakage_filter_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_CfaLeakageFilter(amba_img_dsp_cfa_leakage_filter_t *CfaLeakageFilter);
+
+/**
+ * @brief Get CfaLeakageFilter of GData
+ * This function will copy CfaLeakageFilter of GData.
+ *
+ * @param[out] amba_img_dsp_cfa_leakage_filter_t *CfaLeakageFilter: CfaLeakageFilter Config. Detail please reference amba_img_dsp_cfa_leakage_filter_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_CfaLeakageFilter(amba_img_dsp_cfa_leakage_filter_t *CfaLeakageFilter);
+
+/**
+ * @brief Set HisoCfaLeakageFilter of GData
+ * This function will replace HisoCfaLeakageFilter of GData, and set ITUNER_HISO_CFA_LEAKAGE_FILTER is valid.\n
+ * If you want to update a part of HisoCfaLeakageFilter, you should call AmbaItuner_Get_HisoCfaLeakageFilter() to get current HisoCfaLeakageFilter before the replace process.
+ *
+ * @param[in] amba_img_dsp_cfa_leakage_filter_t *HisoCfaLeakageFilter: HisoCfaLeakageFilter Config. Detail please reference amba_img_dsp_cfa_leakage_filter_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoCfaLeakageFilter(amba_img_dsp_cfa_leakage_filter_t *HisoCfaLeakageFilter);
+
+/**
+ * @brief Get HisoCfaLeakageFilter of GData
+ * This function will copy HisoCfaLeakageFilter of GData.
+ *
+ * @param[out] amba_img_dsp_cfa_leakage_filter_t *HisoCfaLeakageFilter: HisoCfaLeakageFilter Config. Detail please reference amba_img_dsp_cfa_leakage_filter_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoCfaLeakageFilter(amba_img_dsp_cfa_leakage_filter_t *HisoCfaLeakageFilter);
+
+/**
+ * @brief Set CfaNoiseFilter of GData
+ * This function will replace CfaNoiseFilter of GData, and set ITUNER_CFA_NOISE_FILTER is valid.\n
+ * If you want to update a part of CfaNoiseFilter, you should call AmbaItuner_Get_CfaNoiseFilter() to get current CfaNoiseFilter before the replace process.
+ *
+ * @param[in] amba_img_dsp_cfa_noise_filter_t *CfaNoiseFilter: CfaNoiseFilter Config. Detail please reference amba_img_dsp_cfa_noise_filter_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_CfaNoiseFilter(amba_img_dsp_cfa_noise_filter_t *CfaNoiseFilter);
+
+/**
+ * @brief Get CfaNoiseFilter of GData
+ * This function will copy CfaNoiseFilter of GData.
+ *
+ * @param[out] amba_img_dsp_cfa_noise_filter_t *CfaNoiseFilter: CfaNoiseFilter Config. Detail please reference amba_img_dsp_cfa_noise_filter_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_CfaNoiseFilter(amba_img_dsp_cfa_noise_filter_t *CfaNoiseFilter);
+
+/**
+ * @brief Set HisoCfaNoiseFilter of GData
+ * This function will replace HisoCfaNoiseFilter of GData, and set ITUNER_HISO_CFA_NOISE_FILTER is valid.\n
+ * If you want to update a part of HisoCfaNoiseFilter, you should call AmbaItuner_Get_HisoCfaNoiseFilter() to get current HisoCfaNoiseFilter before the replace process.
+ *
+ * @param[in] amba_img_dsp_cfa_noise_filter_t *HisoCfaNoiseFilter: HisoCfaNoiseFilter Config. Detail please reference amba_img_dsp_cfa_noise_filter_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoCfaNoiseFilter(amba_img_dsp_cfa_noise_filter_t *HisoCfaNoiseFilter);
+
+/**
+ * @brief Get HisoCfaNoiseFilter of GData
+ * This function will copy HisoCfaNoiseFilter of GData.
+ *
+ * @param[out] amba_img_dsp_cfa_noise_filter_t *HisoCfaNoiseFilter: HisoCfaNoiseFilter Config. Detail please reference amba_img_dsp_cfa_noise_filter_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoCfaNoiseFilter(amba_img_dsp_cfa_noise_filter_t *HisoCfaNoiseFilter);
+
+/**
+ * @brief Set AntiAliasingStrength of GData
+ * This function will replace AntiAliasingStrength of GData, and set ITUNER_ANTI_ALIASING_STRENGTH is valid.\n
+ * If you want to update a part of AntiAliasingStrength, you should call AmbaItuner_Get_AntiAliasingStrength() to get current AntiAliasingStrength before the replace process.
+ *
+ * @param[in] UINT8 AntiAliasingStrength: AntiAliasingStrength Config.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_AntiAliasingStrength(amba_img_dsp_anti_aliasing_t *AntiAliasing);
+
+/**
+ * @brief Get AntiAliasingStrength of GData
+ * This function will copy AntiAliasingStrength of GData.
+ *
+ * @param[out] UINT8 *AntiAliasingStrength: AntiAliasingStrength Config.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_AntiAliasingStrength(amba_img_dsp_anti_aliasing_t *AntiAliasing);
+
+/**
+ * @brief Set HisoAntiAliasingStrength of GData
+ * This function will replace HisoAntiAliasingStrength of GData, and set ITUNER_HISO_ANTI_ALIASING_STRENGTH is valid.\n
+ * If you want to update a part of HisoAntiAliasingStrength, you should call AmbaItuner_Get_HisoAntiAliasingStrength() to get current HisoAntiAliasingStrength before the replace process.
+ *
+ * @param[in] UINT8 HisoAntiAliasingStrength: HisoAntiAliasingStrength Config.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoAntiAliasingStrength(amba_img_dsp_anti_aliasing_t *HisoAntiAliasing);
+
+/**
+ * @brief Get HisoAntiAliasingStrength of GData
+ * This function will copy HisoAntiAliasingStrength of GData.
+ *
+ * @param[out] UINT8 *HisoAntiAliasingStrength: HisoAntiAliasingStrength Config.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoAntiAliasingStrength(amba_img_dsp_anti_aliasing_t *HisoAntiAliasing);
+
+/**
+ * @brief Set GlobalDgain of GData
+ * This function will replace GlobalDgain of GData, and set ITUNER_GLOBAL_DGAIN is valid.\n
+ * If you want to update a part of GlobalDgain, you should call AmbaItuner_Get_GlobalDgain() to get current GlobalDgain before the replace process.
+ *
+ * @param[in] UINT32 GlobalDgain: GlobalDgain Config.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_GlobalDgain(UINT32 GlobalDgain);
+
+/**
+ * @brief Get GlobalDgain of GData
+ * This function will copy GlobalDgain of GData.
+ *
+ * @param[out] UINT32 GlobalDgain: GlobalDgain Config.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_GlobalDgain(UINT32 *GlobalDgain);
+
+/**
+ * @brief Set WbGain of GData
+ * This function will replace WbGain of GData, and set ITUNER_WB_GAIN is valid.\n
+ * If you want to update a part of WbGain, you should call AmbaItuner_Get_WbGain() to get current WbGain before the replace process.
+ *
+ * @param[in] : WbGain Config. Detail please reference amba_img_dsp_wb_gain_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_WbGain(amba_img_dsp_wb_gain_t *WbGain);
+
+/**
+ * @brief Get WbGain of GData
+ * This function will copy WbGain of GData.
+ *
+ * @param[out] amba_img_dsp_wb_gain_t *WbGain: WbGain Config. Detail please reference amba_img_dsp_wb_gain_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_WbGain(amba_img_dsp_wb_gain_t *WbGain);
+
+/**
+ * @brief Set DgainSaturationLevel of GData
+ * This function will replace DgainSaturationLevel of GData, and set ITUNER_DGAIN_SATURATION_LEVEL is valid.\n
+ * If you want to update a part of DgainSaturationLevel, you should call AmbaItuner_Get_DgainSaturationLevel() to get current DgainSaturationLevel before the replace process.
+ *
+ * @param[in] amba_img_dsp_dgain_saturation_t *DgainSaturationLevel: DgainSaturationLevel Config. Detail please reference amba_img_dsp_dgain_saturation_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_DgainSaturationLevel(amba_img_dsp_dgain_saturation_t *DgainSaturationLevel);
+
+/**
+ * @brief Get DgainSaturationLevel of GData
+ * This function will copy DgainSaturationLevel of GData.
+ *
+ * @param[out] amba_img_dsp_dgain_saturation_t *DgainSaturationLevel: DgainSaturationLevel Config. Detail please reference amba_img_dsp_dgain_saturation_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_DgainSaturationLevel(amba_img_dsp_dgain_saturation_t *DgainSaturationLevel);
+
+/**
+ * @brief Set LocalExposure of GData
+ * This function will replace LocalExposure of GData, and set ITUNER_LOCAL_EXPOSURE is valid.\n
+ * If you want to update a part of LocalExposure, you should call AmbaItuner_Get_LocalExposure() to get current LocalExposure before the replace process.
+ *
+ * @param[in] amba_img_dsp_local_exposure_t *LocalExposure: LocalExposure Config. Detail please reference amba_img_dsp_local_exposure_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_LocalExposure(amba_img_dsp_local_exposure_t *LocalExposure);
+
+/**
+ * @brief Get LocalExposure of GData
+ * This function will copy LocalExposure of GData.
+ *
+ * @param[out] amba_img_dsp_local_exposure_t *LocalExposure: LocalExposure Config. Detail please reference amba_img_dsp_local_exposure_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_LocalExposure(amba_img_dsp_local_exposure_t *LocalExposure);
+
+/**
+ * @brief Set ColorCorrection of GData
+ * This function will replace ColorCorrection of GData, and set ITUNER_COLOR_CORRECTION is valid.\n
+ * If you want to update a part of ColorCorrection, you should call AmbaItuner_Get_ColorCorrection() to get current ColorCorrection before the replace process.
+ *
+ * @param[in] : ColorCorrection Config. Detail please reference ITUNER_COLOR_CORRECTION_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_ColorCorrection(ITUNER_COLOR_CORRECTION_s *ColorCorrection);
+
+/**
+ * @brief Get ColorCorrection of GData
+ * This function will copy ColorCorrection of GData.
+ *
+ * @param[out] ITUNER_COLOR_CORRECTION_s *ColorCorrection: ColorCorrection Config. Detail please reference ITUNER_COLOR_CORRECTION_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_ColorCorrection(ITUNER_COLOR_CORRECTION_s *ColorCorrection);
+
+/**
+ * @brief Get Filter Status
+ * This function will report that which filters are valid.
+ *
+ * @param[out] AMBA_ITUNER_VALID_FILTER_t *FilterStatus: Filter Status Array, the index relationship please reference ITUNER_VALID_s
+ *
+ * @return None
+ */
+void AmbaItuner_Get_FilterStatus(AMBA_ITUNER_VALID_FILTER_t *FilterStatus);
+
+/**
+ * @brief Get CcReg Table
+ * This function will copy CcReg Table of GData.(Read only)
+ *
+ * @param[out] amba_img_dsp_color_correction_reg_t *CcReg: CcReg Table, It's read only, please don't edit it.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_CcReg(amba_img_dsp_color_correction_reg_t *CcReg);
+
+/**
+ * @brief Get CcThreeD Table
+ * This function will copy CcThreeD Table of GData.(Read only)
+ *
+ * @param[out] amba_img_dsp_color_correction_t *CcThreeD: CcThreeD Table, It's read only, please don't edit it.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_CcThreeD(amba_img_dsp_color_correction_t *CcThreeD);
+
+/**
+ * @brief Set ToneCurve of GData
+ * This function will replace ToneCurve of GData, and set ITUNER_TONE_CURVE is valid.\n
+ * If you want to update a part of ToneCurve, you should call AmbaItuner_Get_ToneCurve() to get current ToneCurve before the replace process.
+ *
+ * @param[in] amba_img_dsp_tone_curve_t *ToneCurve: ToneCurve Config. Detail please reference amba_img_dsp_tone_curve_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_ToneCurve(amba_img_dsp_tone_curve_t *ToneCurve);
+
+/**
+ * @brief Get ToneCurve of GData
+ * This function will copy ToneCurve of GData.
+ *
+ * @param[out] amba_img_dsp_tone_curve_t *ToneCurve: ToneCurve Config. Detail please reference amba_img_dsp_tone_curve_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_ToneCurve(amba_img_dsp_tone_curve_t *ToneCurve);
+
+/**
+ * @brief Set RgbToYuvMatrix of GData
+ * This function will replace RgbToYuvMatrix of GData, and set ITUNER_RGB_TO_YUV_MATRIX is valid.\n
+ * If you want to update a part of RgbToYuvMatrix, you should call AmbaItuner_Get_RgbToYuvMatrix() to get current RgbToYuvMatrix before the replace process.
+ *
+ * @param[in] amba_img_dsp_rgb_to_yuv_t *RgbToYuvMatrix: RgbToYuvMatrix Config. Detail please reference amba_img_dsp_rgb_to_yuv_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_RgbToYuvMatrix(amba_img_dsp_rgb_to_yuv_t *RgbToYuvMatrix);
+
+/**
+ * @brief Get RgbToYuvMatrix of GData
+ * This function will copy RgbToYuvMatrix of GData.
+ *
+ * @param[out] amba_img_dsp_rgb_to_yuv_t *RgbToYuvMatrix: RgbToYuvMatrix Config. Detail please reference amba_img_dsp_rgb_to_yuv_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_RgbToYuvMatrix(amba_img_dsp_rgb_to_yuv_t *RgbToYuvMatrix);
+
+/**
+ * @brief Set ChromaScale of GData
+ * This function will replace ChromaScale of GData, and set ITUNER_CHROMA_SCALE is valid.\n
+ * If you want to update a part of ChromaScale, you should call AmbaItuner_Get_ChromaScale() to get current ChromaScale before the replace process.
+ *
+ * @param[in] amba_img_dsp_chroma_scale_t *ChromaScale: ChromaScale Config. Detail please reference amba_img_dsp_chroma_scale_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_ChromaScale(amba_img_dsp_chroma_scale_t *ChromaScale);
+
+/**
+ * @brief Get ChromaScale of GData
+ * This function will copy ChromaScale of GData.
+ *
+ * @param[out] amba_img_dsp_chroma_scale_t *ChromaScale: ChromaScale Config. Detail please reference amba_img_dsp_chroma_scale_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_ChromaScale(amba_img_dsp_chroma_scale_t *ChromaScale);
+
+/**
+ * @brief Set ChromaMedianFilter of GData
+ * This function will replace ChromaMedianFilter of GData, and set ITUNER_CHROMA_MEDIAN_FILTER is valid.\n
+ * If you want to update a part of ChromaMedianFilter, you should call AmbaItuner_Get_ChromaMedianFilter() to get current ChromaMedianFilter before the replace process.
+ *
+ * @param[in] amba_img_dsp_chroma_median_filter_t *ChromaMedianFilter: ChromaMedianFilter Config. Detail please reference amba_img_dsp_chroma_median_filter_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_ChromaMedianFilter(amba_img_dsp_chroma_median_filter_t *ChromaMedianFilter);
+
+/**
+ * @brief Get ChromaMedianFilter of GData
+ * This function will copy ChromaMedianFilter of GData.
+ *
+ * @param[out] amba_img_dsp_chroma_median_filter_t *ChromaMedianFilter: ChromaMedianFilter Config. Detail please reference amba_img_dsp_chroma_median_filter_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_ChromaMedianFilter(amba_img_dsp_chroma_median_filter_t *ChromaMedianFilter);
+
+/**
+ * @brief Set HisoChromaMedianFilter of GData
+ * This function will replace HisoChromaMedianFilter of GData, and set ITUNER_HISO_CHROMA_MEDIAN_FILTER is valid.\n
+ * If you want to update a part of HisoChromaMedianFilter, you should call AmbaItuner_Get_HisoChromaMedianFilter() to get current HisoChromaMedianFilter before the replace process.
+ *
+ * @param[in] amba_img_dsp_chroma_median_filter_t *HisoChromaMedianFilter: HisoChromaMedianFilter Config. Detail please reference amba_img_dsp_chroma_median_filter_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoChromaMedianFilter(amba_img_dsp_chroma_median_filter_t *HisoChromaMedianFilter);
+
+/**
+ * @brief Get HisoChromaMedianFilter of GData
+ * This function will copy HisoChromaMedianFilter of GData.
+ *
+ * @param[out] amba_img_dsp_chroma_median_filter_t *HisoChromaMedianFilter: HisoChromaMedianFilter Config. Detail please reference amba_img_dsp_chroma_median_filter_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoChromaMedianFilter(amba_img_dsp_chroma_median_filter_t *HisoChromaMedianFilter);
+
+/**
+ * @brief Set DemosaicFilter of GData
+ * This function will replace DemosaicFilter of GData, and set ITUNER_DEMOSAIC_FILTER is valid.\n
+ * If you want to update a part of DemosaicFilter, you should call AmbaItuner_Get_DemosaicFilter() to get current DemosaicFilter before the replace process.
+ *
+ * @param[in] amba_img_dsp_demosaic_t *DemosaicFilter: DemosaicFilter Config. Detail please reference amba_img_dsp_demosaic_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_DemosaicFilter(amba_img_dsp_demosaic_t *DemosaicFilter);
+
+/**
+ * @brief Get DemosaicFilter of GData
+ * This function will copy DemosaicFilter of GData.
+ *
+ * @param[out] amba_img_dsp_demosaic_t *DemosaicFilter: DemosaicFilter Config. Detail please reference amba_img_dsp_demosaic_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_DemosaicFilter(amba_img_dsp_demosaic_t *DemosaicFilter);
+
+/**
+ * @brief Set HisoDemosaicFilter of GData
+ * This function will replace HisoDemosaicFilter of GData, and set ITUNER_HISO_DEMOSAIC_FILTER is valid.\n
+ * If you want to update a part of HisoDemosaicFilter, you should call AmbaItuner_Get_HisoDemosaicFilter() to get current HisoDemosaicFilter before the replace process.
+ *
+ * @param[in] amba_img_dsp_demosaic_t *HisoDemosaicFilter: HisoDemosaicFilter Config. Detail please reference amba_img_dsp_demosaic_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoDemosaicFilter(amba_img_dsp_demosaic_t *HisoDemosaicFilter);
+
+/**
+ * @brief Get HisoDemosaicFilter of GData
+ * This function will copy HisoDemosaicFilter of GData.
+ *
+ * @param[out] amba_img_dsp_demosaic_t *HisoDemosaicFilter: HisoDemosaicFilter Config. Detail please reference amba_img_dsp_demosaic_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoDemosaicFilter(amba_img_dsp_demosaic_t *HisoDemosaicFilter);
+
+/**
+ * @brief Set SharpenBoth of GData
+ * This function will replace SharpenBoth of GData, and set ITUNER_SHARPEN_BOTH is valid.\n
+ * If you want to update a part of SharpenBoth, you should call AmbaItuner_Get_SharpenBoth() to get current SharpenBoth before the replace process.
+ *
+ * @param[in] amba_img_dsp_sharpen_both_t *SharpenBoth: SharpenBoth Config. Detail please reference amba_img_dsp_sharpen_both_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_SharpenBoth(amba_img_dsp_sharpen_both_t *SharpenBoth);
+
+/**
+ * @brief Get SharpenBoth of GData
+ * This function will copy SharpenBoth of GData.
+ *
+ * @param[out] amba_img_dsp_sharpen_both_t *SharpenBoth: SharpenBoth Config. Detail please reference amba_img_dsp_sharpen_both_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_SharpenBoth(amba_img_dsp_sharpen_both_t *SharpenBoth);
+
+/**
+ * @brief Set FinalSharpenBoth of GData
+ * This function will replace FinalSharpenBoth of GData, and set ITUNER_FINAL_SHARPEN_BOTH is valid.\n
+ * If you want to update a part of FinalSharpenBoth, you should call AmbaItuner_Get_FinalSharpenBoth() to get current FinalSharpenBoth before the replace process.
+ *
+ * @param[in] amba_img_dsp_sharpen_both_t *FinalSharpenBoth: FinalSharpenBoth Config. Detail please reference amba_img_dsp_sharpen_both_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_FinalSharpenBoth(amba_img_dsp_sharpen_both_t *FinalSharpenBoth);
+
+/**
+ * @brief Get FinalSharpenBoth of GData
+ * This function will copy FinalSharpenBoth of GData.
+ *
+ * @param[out] amba_img_dsp_sharpen_both_t *FinalSharpenBoth: FinalSharpenBoth Config. Detail please reference amba_img_dsp_sharpen_both_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_FinalSharpenBoth(amba_img_dsp_sharpen_both_t *FinalSharpenBoth);
+
+/**
+ * @brief Set HisoLiso1SharpenBoth of GData
+ * This function will replace HisoLiso1SharpenBoth of GData, and set ITUNER_HISO_LISO1_SHARPEN_BOTH is valid.\n
+ * If you want to update a part of HisoLiso1SharpenBoth, you should call AmbaItuner_Get_HisoLiso1SharpenBoth() to get current HisoLiso1SharpenBoth before the replace process.
+ *
+ * @param[in] amba_img_dsp_sharpen_both_t *HisoLiso1SharpenBoth: HisoLiso1SharpenBoth Config. Detail please reference amba_img_dsp_sharpen_both_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoLiso1SharpenBoth(amba_img_dsp_sharpen_both_t *HisoLiso1SharpenBoth);
+
+/**
+ * @brief Get HisoLiso1SharpenBoth of GData
+ * This function will copy HisoLiso1SharpenBoth of GData.
+ *
+ * @param[out] amba_img_dsp_sharpen_both_t *HisoLiso1SharpenBoth: HisoLiso1SharpenBoth Config. Detail please reference amba_img_dsp_sharpen_both_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoLiso1SharpenBoth(amba_img_dsp_sharpen_both_t *HisoLiso1SharpenBoth);
+
+/**
+ * @brief Set HisoHighSharpenBoth of GData
+ * This function will replace HisoHighSharpenBoth of GData, and set ITUNER_HISO_HIGH_SHARPEN_BOTH is valid.\n
+ * If you want to update a part of HisoHighSharpenBoth, you should call AmbaItuner_Get_HisoHighSharpenBoth() to get current HisoHighSharpenBoth before the replace process.
+ *
+ * @param[in] amba_img_dsp_sharpen_both_t *HisoHighSharpenBoth: HisoHighSharpenBoth Config. Detail please reference amba_img_dsp_sharpen_both_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoHighSharpenBoth(amba_img_dsp_sharpen_both_t *HisoHighSharpenBoth);
+
+/**
+ * @brief Get HisoHighSharpenBoth of GData
+ * This function will copy HisoHighSharpenBoth of GData.
+ *
+ * @param[out] amba_img_dsp_sharpen_both_t *HisoHighSharpenBoth: HisoHighSharpenBoth Config. Detail please reference amba_img_dsp_sharpen_both_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoHighSharpenBoth(amba_img_dsp_sharpen_both_t *HisoHighSharpenBoth);
+
+/**
+ * @brief Set HisoMedSharpenBoth of GData
+ * This function will replace HisoMedSharpenBoth of GData, and set ITUNER_HISO_MED_SHARPEN_BOTH is valid.\n
+ * If you want to update a part of HisoMedSharpenBoth, you should call AmbaItuner_Get_HisoMedSharpenBoth() to get current HisoMedSharpenBoth before the replace process.
+ *
+ * @param[in] amba_img_dsp_sharpen_both_t *HisoMedSharpenBoth: HisoMedSharpenBoth Config. Detail please reference amba_img_dsp_sharpen_both_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoMedSharpenBoth(amba_img_dsp_sharpen_both_t *HisoMedSharpenBoth);
+
+/**
+ * @brief Get HisoMedSharpenBoth of GData
+ * This function will copy HisoMedSharpenBoth of GData.
+ *
+ * @param[out] amba_img_dsp_sharpen_both_t *HisoMedSharpenBoth: HisoMedSharpenBoth Config. Detail please reference amba_img_dsp_sharpen_both_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoMedSharpenBoth(amba_img_dsp_sharpen_both_t *HisoMedSharpenBoth);
+
+/**
+ * @brief Set HisoLiso2SharpenBoth of GData
+ * This function will replace HisoLiso2SharpenBoth of GData, and set ITUNER_HISO_LISO2_SHARPEN_BOTH is valid.\n
+ * If you want to update a part of HisoLiso2SharpenBoth, you should call AmbaItuner_Get_HisoLiso2SharpenBoth() to get current HisoLiso2SharpenBoth before the replace process.
+ *
+ * @param[in] amba_img_dsp_sharpen_both_t *HisoLiso2SharpenBoth: HisoLiso2SharpenBoth Config. Detail please reference amba_img_dsp_sharpen_both_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoLiso2SharpenBoth(amba_img_dsp_sharpen_both_t *HisoLiso2SharpenBoth);
+
+/**
+ * @brief Get HisoLiso2SharpenBoth of GData
+ * This function will copy HisoLiso2SharpenBoth of GData.
+ *
+ * @param[out] amba_img_dsp_sharpen_both_t *HisoLiso2SharpenBoth: HisoLiso2SharpenBoth Config. Detail please reference amba_img_dsp_sharpen_both_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoLiso2SharpenBoth(amba_img_dsp_sharpen_both_t *HisoLiso2SharpenBoth);
+
+/**
+ * @brief Set SharpenNoise of GData
+ * This function will replace SharpenNoise of GData, and set ITUNER_SHARPEN_NOISE is valid.\n
+ * If you want to update a part of SharpenNoise, you should call AmbaItuner_Get_SharpenNoise() to get current SharpenNoise before the replace process.
+ *
+ * @param[in] amba_img_dsp_sharpen_noise_t *SharpenNoise: SharpenNoise Config. Detail please reference amba_img_dsp_sharpen_noise_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_SharpenNoise(amba_img_dsp_sharpen_noise_t *SharpenNoise);
+
+/**
+ * @brief Get SharpenNoise of GData
+ * This function will copy SharpenNoise of GData.
+ *
+ * @param[out] amba_img_dsp_sharpen_noise_t *SharpenNoise: SharpenNoise Config. Detail please reference amba_img_dsp_sharpen_noise_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_SharpenNoise(amba_img_dsp_sharpen_noise_t *SharpenNoise);
+
+/**
+ * @brief Set FinalSharpenNoise of GData
+ * This function will replace FinalSharpenNoise of GData, and set ITUNER_FINAL_SHARPEN_NOISE is valid.\n
+ * If you want to update a part of FinalSharpenNoise, you should call AmbaItuner_Get_FinalSharpenNoise() to get current FinalSharpenNoise before the replace process.
+ *
+ * @param[in] amba_img_dsp_sharpen_noise_t *FinalSharpenNoise: FinalSharpenNoise Config. Detail please reference amba_img_dsp_sharpen_noise_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_FinalSharpenNoise(amba_img_dsp_sharpen_noise_t *FinalSharpenNoise);
+
+/**
+ * @brief Get FinalSharpenNoise of GData
+ * This function will copy FinalSharpenNoise of GData.
+ *
+ * @param[out] amba_img_dsp_sharpen_noise_t *FinalSharpenNoise: FinalSharpenNoise Config. Detail please reference amba_img_dsp_sharpen_noise_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_FinalSharpenNoise(amba_img_dsp_sharpen_noise_t *FinalSharpenNoise);
+
+/**
+ * @brief Set HisoHighSharpenNoise of GData
+ * This function will replace HisoHighSharpenNoise of GData, and set ITUNER_HISO_HIGH_SHARPEN_NOISE is valid.\n
+ * If you want to update a part of HisoHighSharpenNoise, you should call AmbaItuner_Get_HisoHighSharpenNoise() to get current HisoHighSharpenNoise before the replace process.
+ *
+ * @param[in] amba_img_dsp_sharpen_noise_t *HisoHighSharpenNoise: HisoHighSharpenNoise Config. Detail please reference amba_img_dsp_sharpen_noise_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoHighSharpenNoise(amba_img_dsp_sharpen_noise_t *HisoHighSharpenNoise);
+
+/**
+ * @brief Get HisoHighSharpenNoise of GData
+ * This function will copy HisoHighSharpenNoise of GData.
+ *
+ * @param[out] amba_img_dsp_sharpen_noise_t *HisoHighSharpenNoise: HisoHighSharpenNoise Config. Detail please reference amba_img_dsp_sharpen_noise_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoHighSharpenNoise(amba_img_dsp_sharpen_noise_t *HisoHighSharpenNoise);
+
+/**
+ * @brief Set HisoMedSharpenNoise of GData
+ * This function will replace HisoMedSharpenNoise of GData, and set ITUNER_HISO_MED_SHARPEN_NOISE is valid.\n
+ * If you want to update a part of HisoMedSharpenNoise, you should call AmbaItuner_Get_HisoMedSharpenNoise() to get current HisoMedSharpenNoise before the replace process.
+ *
+ * @param[in] amba_img_dsp_sharpen_noise_t *HisoMedSharpenNoise: HisoMedSharpenNoise Config. Detail please reference amba_img_dsp_sharpen_noise_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoMedSharpenNoise(amba_img_dsp_sharpen_noise_t *HisoMedSharpenNoise);
+
+/**
+ * @brief Get HisoMedSharpenNoise of GData
+ * This function will copy HisoMedSharpenNoise of GData.
+ *
+ * @param[out] amba_img_dsp_sharpen_noise_t *HisoMedSharpenNoise: HisoMedSharpenNoise Config. Detail please reference amba_img_dsp_sharpen_noise_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoMedSharpenNoise(amba_img_dsp_sharpen_noise_t *HisoMedSharpenNoise);
+
+/**
+ * @brief Set HisoLiso1SharpenNoise of GData
+ * This function will replace HisoLiso1SharpenNoise of GData, and set ITUNER_HISO_LISO1_SHARPEN_NOISE is valid.\n
+ * If you want to update a part of HisoLiso1SharpenNoise, you should call AmbaItuner_Get_HisoLiso1SharpenNoise() to get current HisoLiso1SharpenNoise before the replace process.
+ *
+ * @param[in] amba_img_dsp_sharpen_noise_t *HisoLiso1SharpenNoise: HisoLiso1SharpenNoise Config. Detail please reference amba_img_dsp_sharpen_noise_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoLiso1SharpenNoise(amba_img_dsp_sharpen_noise_t *HisoLiso1SharpenNoise);
+
+/**
+ * @brief Get HisoLiso1SharpenNoise of GData
+ * This function will copy HisoLiso1SharpenNoise of GData.
+ *
+ * @param[out] amba_img_dsp_sharpen_noise_t *HisoLiso1SharpenNoise: HisoLiso1SharpenNoise Config. Detail please reference amba_img_dsp_sharpen_noise_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoLiso1SharpenNoise(amba_img_dsp_sharpen_noise_t *HisoLiso1SharpenNoise);
+
+/**
+ * @brief Set HisoLiso2SharpenNoise of GData
+ * This function will replace HisoLiso2SharpenNoise of GData, and set ITUNER_HISO_LISO2_SHARPEN_NOISE is valid.\n
+ * If you want to update a part of HisoLiso2SharpenNoise, you should call AmbaItuner_Get_HisoLiso2SharpenNoise() to get current HisoLiso2SharpenNoise before the replace process.
+ *
+ * @param[in] amba_img_dsp_sharpen_noise_t *HisoLiso2SharpenNoise: HisoLiso2SharpenNoise Config. Detail please reference amba_img_dsp_sharpen_noise_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoLiso2SharpenNoise(amba_img_dsp_sharpen_noise_t *HisoLiso2SharpenNoise);
+
+/**
+ * @brief Get HisoLiso2SharpenNoise of GData
+ * This function will copy HisoLiso2SharpenNoise of GData.
+ *
+ * @param[out] amba_img_dsp_sharpen_noise_t *HisoLiso2SharpenNoise: HisoLiso2SharpenNoise Config. Detail please reference amba_img_dsp_sharpen_noise_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoLiso2SharpenNoise(amba_img_dsp_sharpen_noise_t *HisoLiso2SharpenNoise);
+
+/**
+ * @brief Set Fir of GData
+ * This function will replace Fir of GData, and set ITUNER_FIR is valid.\n
+ * If you want to update a part of Fir, you should call AmbaItuner_Get_Fir() to get current Fir before the replace process.
+ *
+ * @param[in] amba_img_dsp_fir_t *Fir: Fir Config. Detail please reference amba_img_dsp_fir_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_Fir(amba_img_dsp_fir_t *Fir);
+
+/**
+ * @brief Get Fir of GData
+ * This function will copy Fir of GData.
+ *
+ * @param[out] amba_img_dsp_fir_t *Fir: Fir Config. Detail please reference amba_img_dsp_fir_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_Fir(amba_img_dsp_fir_t *Fir);
+
+/**
+ * @brief Set FinalFir of GData
+ * This function will replace FinalFir of GData, and set ITUNER_FINALFIR is valid.\n
+ * If you want to update a part of FinalFir, you should call AmbaItuner_Get_FinalFir() to get current FinalFir before the replace process.
+ *
+ * @param[in] amba_img_dsp_fir_t *FinalFir: FinalFir Config. Detail please reference amba_img_dsp_fir_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_FinalFir(amba_img_dsp_fir_t *FinalFir);
+
+/**
+ * @brief Get FinalFir of GData
+ * This function will copy FinalFir of GData.
+ *
+ * @param[out] amba_img_dsp_fir_t *FinalFir: FinalFir Config. Detail please reference amba_img_dsp_fir_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_FinalFir(amba_img_dsp_fir_t *FinalFir);
+
+/**
+ * @brief Set HisoHighFir of GData
+ * This function will replace HisoHighFir of GData, and set ITUNER_HISO_HIGH_FIR is valid.\n
+ * If you want to update a part of HisoHighFir, you should call AmbaItuner_Get_HisoHighFir() to get current HisoHighFir before the replace process.
+ *
+ * @param[in] amba_img_dsp_fir_t *HisoHighFir: HisoHighFir Config. Detail please reference amba_img_dsp_fir_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoHighFir(amba_img_dsp_fir_t *HisoHighFir);
+
+/**
+ * @brief Get HisoHighFir of GData
+ * This function will copy HisoHighFir of GData.
+ *
+ * @param[out] amba_img_dsp_fir_t *HisoHighFir: HisoHighFir Config. Detail please reference amba_img_dsp_fir_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoHighFir(amba_img_dsp_fir_t *HisoHighFir);
+
+/**
+ * @brief Set HisoMedFir of GData
+ * This function will replace HisoMedFir of GData, and set ITUNER_HISO_MED_FIR is valid.\n
+ * If you want to update a part of HisoMedFir, you should call AmbaItuner_Get_HisoMedFir() to get current HisoMedFir before the replace process.
+ *
+ * @param[in] amba_img_dsp_fir_t *HisoMedFir: HisoMedFir Config. Detail please reference amba_img_dsp_fir_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoMedFir(amba_img_dsp_fir_t *HisoMedFir);
+
+/**
+ * @brief Get HisoMedFir of GData
+ * This function will copy HisoMedFir of GData.
+ *
+ * @param[out] amba_img_dsp_fir_t *HisoMedFir: HisoMedFir Config. Detail please reference amba_img_dsp_fir_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoMedFir(amba_img_dsp_fir_t *HisoMedFir);
+
+/**
+ * @brief Set HisoLiso1Fir of GData
+ * This function will replace HisoLiso1Fir of GData, and set ITUNER_HISO_LISO1_FIR is valid.\n
+ * If you want to update a part of HisoLiso1Fir, you should call AmbaItuner_Get_HisoLiso1Fir() to get current HisoLiso1Fir before the replace process.
+ *
+ * @param[in] amba_img_dsp_fir_t *HisoLiso1Fir: HisoLiso1Fir Config. Detail please reference amba_img_dsp_fir_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoLiso1Fir(amba_img_dsp_fir_t *HisoLiso1Fir);
+
+/**
+ * @brief Get HisoLiso1Fir of GData
+ * This function will copy HisoLiso1Fir of GData.
+ *
+ * @param[out] amba_img_dsp_fir_t *HisoLiso1Fir: HisoLiso1Fir Config. Detail please reference amba_img_dsp_fir_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoLiso1Fir(amba_img_dsp_fir_t *HisoLiso1Fir);
+
+/**
+ * @brief Set HisoLiso2Fir of GData
+ * This function will replace HisoLiso2Fir of GData, and set ITUNER_HISO_LISO2_FIR is valid.\n
+ * If you want to update a part of HisoLiso2Fir, you should call AmbaItuner_Get_HisoLiso2Fir() to get current HisoLiso2Fir before the replace process.
+ *
+ * @param[in] : HisoLiso2Fir Config. Detail please reference amba_img_dsp_fir_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoLiso2Fir(amba_img_dsp_fir_t *HisoLiso2Fir);
+
+/**
+ * @brief Get HisoLiso2Fir of GData
+ * This function will copy HisoLiso2Fir of GData.
+ *
+ * @param[out] amba_img_dsp_fir_t *HisoLiso2Fir: HisoLiso2Fir Config. Detail please reference amba_img_dsp_fir_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoLiso2Fir(amba_img_dsp_fir_t *HisoLiso2Fir);
+
+/**
+ * @brief Set Coring of GData
+ * This function will replace Coring of GData, and set ITUNER_CORING is valid.\n
+ * If you want to update a part of Coring, you should call AmbaItuner_Get_Coring() to get current Coring before the replace process.
+ *
+ * @param[in] amba_img_dsp_coring_t *Coring: Coring Config. Detail please reference amba_img_dsp_coring_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_Coring(amba_img_dsp_coring_t *Coring);
+
+/**
+ * @brief Get Coring of GData
+ * This function will copy Coring of GData.
+ *
+ * @param[out] amba_img_dsp_coring_t *Coring: Coring Config. Detail please reference amba_img_dsp_coring_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_Coring(amba_img_dsp_coring_t *Coring);
+
+/**
+ * @brief Set FinalCoring of GData
+ * This function will replace FinalCoring of GData, and set ITUNER_FINAL_CORING is valid.\n
+ * If you want to update a part of FinalCoring, you should call AmbaItuner_Get_FinalCoring() to get current FinalCoring before the replace process.
+ *
+ * @param[in] amba_img_dsp_coring_t *FinalCoring: FinalCoring Config. Detail please reference amba_img_dsp_coring_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_FinalCoring(amba_img_dsp_coring_t *FinalCoring);
+
+/**
+ * @brief Get FinalCoring of GData
+ * This function will copy FinalCoring of GData.
+ *
+ * @param[out] amba_img_dsp_coring_t *FinalCoring: FinalCoring Config. Detail please reference amba_img_dsp_coring_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_FinalCoring(amba_img_dsp_coring_t *FinalCoring);
+
+/**
+ * @brief Set HisoHighCoring of GData
+ * This function will replace HisoHighCoring of GData, and set ITUNER_HISO_HIGH_CORING is valid.\n
+ * If you want to update a part of HisoHighCoring, you should call AmbaItuner_Get_HisoHighCoring() to get current HisoHighCoring before the replace process.
+ *
+ * @param[in] amba_img_dsp_coring_t *HisoHighCoring: HisoHighCoring Config. Detail please reference amba_img_dsp_coring_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoHighCoring(amba_img_dsp_coring_t *HisoHighCoring);
+
+/**
+ * @brief Get HisoHighCoring of GData
+ * This function will copy HisoHighCoring of GData.
+ *
+ * @param[out] amba_img_dsp_coring_t *HisoHighCoring: HisoHighCoring Config. Detail please reference amba_img_dsp_coring_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoHighCoring(amba_img_dsp_coring_t *HisoHighCoring);
+
+/**
+ * @brief Set HisoMedCoring of GData
+ * This function will replace HisoMedCoring of GData, and set ITUNER_HISO_MED_CORING is valid.\n
+ * If you want to update a part of HisoMedCoring, you should call AmbaItuner_Get_HisoMedCoring() to get current HisoMedCoring before the replace process.
+ *
+ * @param[in] amba_img_dsp_coring_t *HisoMedCoring: HisoMedCoring Config. Detail please reference amba_img_dsp_coring_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoMedCoring(amba_img_dsp_coring_t *HisoMedCoring);
+
+/**
+ * @brief Get HisoMedCoring of GData
+ * This function will copy HisoMedCoring of GData.
+ *
+ * @param[out] amba_img_dsp_coring_t *HisoMedCoring: HisoMedCoring Config. Detail please reference amba_img_dsp_coring_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoMedCoring(amba_img_dsp_coring_t *HisoMedCoring);
+
+/**
+ * @brief Set HisoLiso1Coring of GData
+ * This function will replace HisoLiso1Coring of GData, and set ITUNER_HISO_LISO1_CORING is valid.\n
+ * If you want to update a part of HisoLiso1Coring, you should call AmbaItuner_Get_HisoLiso1Coring() to get current HisoLiso1Coring before the replace process.
+ *
+ * @param[in] amba_img_dsp_coring_t *HisoLiso1Coring: HisoLiso1Coring Config. Detail please reference amba_img_dsp_coring_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoLiso1Coring(amba_img_dsp_coring_t *HisoLiso1Coring);
+
+/**
+ * @brief Get HisoLiso1Coring of GData
+ * This function will copy HisoLiso1Coring of GData.
+ *
+ * @param[out] amba_img_dsp_coring_t *HisoLiso1Coring: HisoLiso1Coring Config. Detail please reference amba_img_dsp_coring_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoLiso1Coring(amba_img_dsp_coring_t *HisoLiso1Coring);
+
+/**
+ * @brief Set HisoLiso2Coring of GData
+ * This function will replace HisoLiso2Coring of GData, and set ITUNER_HISO_LISO2_CORING is valid.\n
+ * If you want to update a part of HisoLiso2Coring, you should call AmbaItuner_Get_HisoLiso2Coring() to get current HisoLiso2Coring before the replace process.
+ *
+ * @param[in] amba_img_dsp_coring_t *HisoLiso2Coring: HisoLiso2Coring Config. Detail please reference amba_img_dsp_coring_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoLiso2Coring(amba_img_dsp_coring_t *HisoLiso2Coring);
+
+/**
+ * @brief Get HisoLiso2Coring of GData
+ * This function will copy HisoLiso2Coring of GData.
+ *
+ * @param[out] amba_img_dsp_coring_t *HisoLiso2Coring: HisoLiso2Coring Config. Detail please reference amba_img_dsp_coring_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoLiso2Coring(amba_img_dsp_coring_t *HisoLiso2Coring);
+
+/**
+ * @brief Set CoringIndexScale of GData
+ * This function will replace CoringIndexScale of GData, and set ITUNER_CORING_INDEX_SCALE is valid.\n
+ * If you want to update a part of CoringIndexScale, you should call AmbaItuner_Get_CoringIndexScale() to get current CoringIndexScale before the replace process.
+ *
+ * @param[in] amba_img_dsp_level_t *CoringIndexScale: CoringIndexScale Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_CoringIndexScale(amba_img_dsp_level_t *CoringIndexScale);
+
+/**
+ * @brief Get CoringIndexScale of GData
+ * This function will copy CoringIndexScale of GData.
+ *
+ * @param[out] amba_img_dsp_level_t *CoringIndexScale: CoringIndexScale Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_CoringIndexScale(amba_img_dsp_level_t *CoringIndexScale);
+
+/**
+ * @brief Set MinCoringResult of GData
+ * This function will replace MinCoringResult of GData, and set ITUNER_MIN_CORING_RESULT is valid.\n
+ * If you want to update a part of MinCoringResult, you should call AmbaItuner_Get_MinCoringResult() to get current MinCoringResult before the replace process.
+ *
+ * @param[in] amba_img_dsp_level_t *MinCoringResult: MinCoringResult Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_MinCoringResult(amba_img_dsp_level_t *MinCoringResult);
+
+/**
+ * @brief Get MinCoringResult of GData
+ * This function will copy MinCoringResult of GData.
+ *
+ * @param[out] amba_img_dsp_level_t *MinCoringResult: MinCoringResult Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_MinCoringResult(amba_img_dsp_level_t *MinCoringResult);
+
+/**
+ * @brief Set FinalCoringIndexScale of GData
+ * This function will replace FinalCoringIndexScale of GData, and set ITUNER_FINAL_CORING_INDEX_SCALE is valid.\n
+ * If you want to update a part of FinalCoringIndexScale, you should call AmbaItuner_Get_FinalCoringIndexScale() to get current FinalCoringIndexScale before the replace process.
+ *
+ * @param[in] amba_img_dsp_level_t *FinalCoringIndexScale: FinalCoringIndexScale Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_FinalCoringIndexScale(amba_img_dsp_level_t *FinalCoringIndexScale);
+
+/**
+ * @brief Get FinalCoringIndexScale of GData
+ * This function will copy FinalCoringIndexScale of GData.
+ *
+ * @param[out] amba_img_dsp_level_t *FinalCoringIndexScale: FinalCoringIndexScale Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_FinalCoringIndexScale(amba_img_dsp_level_t *FinalCoringIndexScale);
+
+/**
+ * @brief Set FinalMinCoringResult of GData
+ * This function will replace FinalMinCoringResult of GData, and set ITUNER_FINAL_MIN_CORING_RESULT is valid.\n
+ * If you want to update a part of FinalMinCoringResult, you should call AmbaItuner_Get_FinalMinCoringResult() to get current FinalMinCoringResult before the replace process.
+ *
+ * @param[in] amba_img_dsp_level_t *FinalMinCoringResult: FinalMinCoringResult Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_FinalMinCoringResult(amba_img_dsp_level_t *FinalMinCoringResult);
+
+/**
+ * @brief Get FinalMinCoringResult of GData
+ * This function will copy FinalMinCoringResult of GData.
+ *
+ * @param[out] amba_img_dsp_level_t *FinalMinCoringResult: FinalMinCoringResult Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_FinalMinCoringResult(amba_img_dsp_level_t *FinalMinCoringResult);
+
+/**
+ * @brief Set FinalScaleCoring of GData
+ * This function will replace FinalScaleCoring of GData, and set ITUNER_FINAL_SCALE_CORING is valid.\n
+ * If you want to update a part of FinalScaleCoring, you should call AmbaItuner_Get_FinalScaleCoring() to get current FinalScaleCoring before the replace process.
+ *
+ * @param[in] amba_img_dsp_level_t *FinalScaleCoring: FinalScaleCoring Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_FinalScaleCoring(amba_img_dsp_level_t *FinalScaleCoring);
+
+/**
+ * @brief Get FinalScaleCoring of GData
+ * This function will copy FinalScaleCoring of GData.
+ *
+ * @param[out] amba_img_dsp_level_t *FinalScaleCoring: FinalScaleCoring Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_FinalScaleCoring(amba_img_dsp_level_t *FinalScaleCoring);
+
+/**
+ * @brief Set HisoHighCoringIndexScale of GData
+ * This function will replace HisoHighCoringIndexScale of GData, and set ITUNER_HISO_HIGH_CORING_INDEX_SCALE is valid.\n
+ * If you want to update a part of HisoHighCoringIndexScale, you should call AmbaItuner_Get_HisoHighCoringIndexScale() to get current HisoHighCoringIndexScale before the replace process.
+ *
+ * @param[in] amba_img_dsp_level_t *HisoHighCoringIndexScale: HisoHighCoringIndexScale Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoHighCoringIndexScale(amba_img_dsp_level_t *HisoHighCoringIndexScale);
+
+/**
+ * @brief Get HisoHighCoringIndexScale of GData
+ * This function will copy HisoHighCoringIndexScale of GData.
+ *
+ * @param[out] amba_img_dsp_level_t *HisoHighCoringIndexScale: HisoHighCoringIndexScale Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoHighCoringIndexScale(amba_img_dsp_level_t *HisoHighCoringIndexScale);
+
+/**
+ * @brief Set HisoHighMinCoringResult of GData
+ * This function will replace HisoHighMinCoringResult of GData, and set ITUNER_HISO_HIGH_MIN_CORING_RESULT is valid.\n
+ * If you want to update a part of HisoHighMinCoringResult, you should call AmbaItuner_Get_HisoHighMinCoringResult() to get current HisoHighMinCoringResult before the replace process.
+ *
+ * @param[in] amba_img_dsp_level_t *HisoHighMinCoringResult: HisoHighMinCoringResult Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoHighMinCoringResult(amba_img_dsp_level_t *HisoHighMinCoringResult);
+
+/**
+ * @brief Get HisoHighMinCoringResult of GData
+ * This function will copy HisoHighMinCoringResult of GData.
+ *
+ * @param[out] amba_img_dsp_level_t *HisoHighMinCoringResult: HisoHighMinCoringResult Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoHighMinCoringResult(amba_img_dsp_level_t *HisoHighMinCoringResult);
+
+/**
+ * @brief Set HisoHighScaleCoring of GData
+ * This function will replace HisoHighScaleCoring of GData, and set ITUNER_HISO_HIGH_SCALE_CORING is valid.\n
+ * If you want to update a part of HisoHighScaleCoring, you should call AmbaItuner_Get_HisoHighScaleCoring() to get current HisoHighScaleCoring before the replace process.
+ *
+ * @param[in] amba_img_dsp_level_t *HisoHighScaleCoring: HisoHighScaleCoring Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoHighScaleCoring(amba_img_dsp_level_t *HisoHighScaleCoring);
+
+/**
+ * @brief Get HisoHighScaleCoring of GData
+ * This function will copy HisoHighScaleCoring of GData.
+ *
+ * @param[out] amba_img_dsp_level_t *HisoHighScaleCoring: HisoHighScaleCoring Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoHighScaleCoring(amba_img_dsp_level_t *HisoHighScaleCoring);
+
+/**
+ * @brief Set HisoMedCoringIndexScale of GData
+ * This function will replace HisoMedCoringIndexScale of GData, and set ITUNER_HISO_MED_CORING_INDEX_SCALE is valid.\n
+ * If you want to update a part of HisoMedCoringIndexScale, you should call AmbaItuner_Get_HisoMedCoringIndexScale() to get current HisoMedCoringIndexScale before the replace process.
+ *
+ * @param[in] amba_img_dsp_level_t *HisoMedCoringIndexScale: HisoMedCoringIndexScale Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoMedCoringIndexScale(amba_img_dsp_level_t *HisoMedCoringIndexScale);
+
+/**
+ * @brief Get HisoMedCoringIndexScale of GData
+ * This function will copy HisoMedCoringIndexScale of GData.
+ *
+ * @param[out] amba_img_dsp_level_t *HisoMedCoringIndexScale: HisoMedCoringIndexScale Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoMedCoringIndexScale(amba_img_dsp_level_t *HisoMedCoringIndexScale);
+
+/**
+ * @brief Set HisoMedMinCoringResult of GData
+ * This function will replace HisoMedMinCoringResult of GData, and set ITUNER_HISO_MED_MIN_CORING_RESULT is valid.\n
+ * If you want to update a part of HisoMedMinCoringResult, you should call AmbaItuner_Get_HisoMedMinCoringResult() to get current HisoMedMinCoringResult before the replace process.
+ *
+ * @param[in] amba_img_dsp_level_t *HisoMedMinCoringResult: HisoMedMinCoringResult Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoMedMinCoringResult(amba_img_dsp_level_t *HisoMedMinCoringResult);
+
+/**
+ * @brief Get HisoMedMinCoringResult of GData
+ * This function will copy HisoMedMinCoringResult of GData.
+ *
+ * @param[out] amba_img_dsp_level_t *HisoMedMinCoringResult: HisoMedMinCoringResult Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoMedMinCoringResult(amba_img_dsp_level_t *HisoMedMinCoringResult);
+
+/**
+ * @brief Set HisoMedScaleCoring of GData
+ * This function will replace HisoMedScaleCoring of GData, and set ITUNER_HISO_MED_SCALE_CORING is valid.\n
+ * If you want to update a part of HisoMedScaleCoring, you should call AmbaItuner_Get_HisoMedScaleCoring() to get current HisoMedScaleCoring before the replace process.
+ *
+ * @param[in] amba_img_dsp_level_t *HisoMedScaleCoring: HisoMedScaleCoring Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoMedScaleCoring(amba_img_dsp_level_t *HisoMedScaleCoring);
+
+/**
+ * @brief Get HisoMedScaleCoring of GData
+ * This function will copy HisoMedScaleCoring of GData.
+ *
+ * @param[out] amba_img_dsp_level_t *HisoMedScaleCoring: HisoMedScaleCoring Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoMedScaleCoring(amba_img_dsp_level_t *HisoMedScaleCoring);
+
+/**
+ * @brief Set ScaleCoring of GData
+ * This function will replace ScaleCoring of GData, and set ITUNER_SCALE_CORING is valid.\n
+ * If you want to update a part of ScaleCoring, you should call AmbaItuner_Get_ScaleCoring() to get current ScaleCoring before the replace process.
+ *
+ * @param[in] amba_img_dsp_level_t *ScaleCoring: ScaleCoring Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_ScaleCoring(amba_img_dsp_level_t *ScaleCoring);
+
+/**
+ * @brief Get ScaleCoring of GData
+ * This function will copy ScaleCoring of GData.
+ *
+ * @param[out] amba_img_dsp_level_t *ScaleCoring: ScaleCoring Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_ScaleCoring(amba_img_dsp_level_t *ScaleCoring);
+
+/**
+ * @brief Set HisoLiso1CoringIndexScale of GData
+ * This function will replace HisoLiso1CoringIndexScale of GData, and set ITUNER_HISO_LISO1_CORING_INDEX_SCALE is valid.\n
+ * If you want to update a part of HisoLiso1CoringIndexScale, you should call AmbaItuner_Get_HisoLiso1CoringIndexScale() to get current HisoLiso1CoringIndexScale before the replace process.
+ *
+ * @param[in] amba_img_dsp_level_t *HisoLiso1CoringIndexScale: HisoLiso1CoringIndexScale Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoLiso1CoringIndexScale(amba_img_dsp_level_t *HisoLiso1CoringIndexScale);
+
+/**
+ * @brief Get HisoLiso1CoringIndexScale of GData
+ * This function will copy HisoLiso1CoringIndexScale of GData.
+ *
+ * @param[out] amba_img_dsp_level_t *HisoLiso1CoringIndexScale: HisoLiso1CoringIndexScale Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoLiso1CoringIndexScale(amba_img_dsp_level_t *HisoLiso1CoringIndexScale);
+
+/**
+ * @brief Set HisoLiso1MinCoringResult of GData
+ * This function will replace HisoLiso1MinCoringResult of GData, and set ITUNER_HISO_LISO1_MIN_CORING_RESULT is valid.\n
+ * If you want to update a part of HisoLiso1MinCoringResult, you should call AmbaItuner_Get_HisoLiso1MinCoringResult() to get current HisoLiso1MinCoringResult before the replace process.
+ *
+ * @param[in] amba_img_dsp_level_t *HisoLiso1MinCoringResult: HisoLiso1MinCoringResult Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoLiso1MinCoringResult(amba_img_dsp_level_t *HisoLiso1MinCoringResult);
+
+/**
+ * @brief Get HisoLiso1MinCoringResult of GData
+ * This function will copy HisoLiso1MinCoringResult of GData.
+ *
+ * @param[out] amba_img_dsp_level_t *HisoLiso1MinCoringResult: HisoLiso1MinCoringResult Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoLiso1MinCoringResult(amba_img_dsp_level_t *HisoLiso1MinCoringResult);
+
+/**
+ * @brief Set HisoLiso1ScaleCoring of GData
+ * This function will replace HisoLiso1ScaleCoring of GData, and set ITUNER_HISO_LISO1_SCALE_CORING is valid.\n
+ * If you want to update a part of HisoLiso1ScaleCoring, you should call AmbaItuner_Get_HisoLiso1ScaleCoring() to get current HisoLiso1ScaleCoring before the replace process.
+ *
+ * @param[in] : HisoLiso1ScaleCoring Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoLiso1ScaleCoring(amba_img_dsp_level_t *HisoLiso1ScaleCoring);
+
+/**
+ * @brief Get HisoLiso1ScaleCoring of GData
+ * This function will copy HisoLiso1ScaleCoring of GData.
+ *
+ * @param[out] amba_img_dsp_level_t *HisoLiso1ScaleCoring: HisoLiso1ScaleCoring Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoLiso1ScaleCoring(amba_img_dsp_level_t *HisoLiso1ScaleCoring);
+
+/**
+ * @brief Set HisoLiso2CoringIndexScale of GData
+ * This function will replace HisoLiso2CoringIndexScale of GData, and set ITUNER_HISO_LISO2_CORING_INDEX_SCALE is valid.\n
+ * If you want to update a part of HisoLiso2CoringIndexScale, you should call AmbaItuner_Get_HisoLiso2CoringIndexScale() to get current HisoLiso2CoringIndexScale before the replace process.
+ *
+ * @param[in] amba_img_dsp_level_t *HisoLiso2CoringIndexScale: HisoLiso2CoringIndexScale Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoLiso2CoringIndexScale(amba_img_dsp_level_t *HisoLiso2CoringIndexScale);
+
+/**
+ * @brief Get HisoLiso2CoringIndexScale of GData
+ * This function will copy HisoLiso2CoringIndexScale of GData.
+ *
+ * @param[out] amba_img_dsp_level_t *HisoLiso2CoringIndexScale: HisoLiso2CoringIndexScale Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoLiso2CoringIndexScale(amba_img_dsp_level_t *HisoLiso2CoringIndexScale);
+
+/**
+ * @brief Set HisoLiso2MinCoringResult of GData
+ * This function will replace HisoLiso2MinCoringResult of GData, and set ITUNER_HISO_LISO2_MIN_CORING_RESULT is valid.\n
+ * If you want to update a part of HisoLiso2MinCoringResult, you should call AmbaItuner_Get_HisoLiso2MinCoringResult() to get current HisoLiso2MinCoringResult before the replace process.
+ *
+ * @param[in] amba_img_dsp_level_t *HisoLiso2MinCoringResult: HisoLiso2MinCoringResult Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoLiso2MinCoringResult(amba_img_dsp_level_t *HisoLiso2MinCoringResult);
+
+/**
+ * @brief Get HisoLiso2MinCoringResult of GData
+ * This function will copy HisoLiso2MinCoringResult of GData.
+ *
+ * @param[out] amba_img_dsp_level_t *HisoLiso2MinCoringResult: HisoLiso2MinCoringResult Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoLiso2MinCoringResult(amba_img_dsp_level_t *HisoLiso2MinCoringResult);
+
+/**
+ * @brief Set HisoLiso2ScaleCoring of GData
+ * This function will replace HisoLiso2ScaleCoring of GData, and set ITUNER_HISO_LISO2_SCALE_CORING is valid.\n
+ * If you want to update a part of HisoLiso2ScaleCoring, you should call AmbaItuner_Get_HisoLiso2ScaleCoring() to get current HisoLiso2ScaleCoring before the replace process.
+ *
+ * @param[in] amba_img_dsp_level_t *HisoLiso2ScaleCoring: HisoLiso2ScaleCoring Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoLiso2ScaleCoring(amba_img_dsp_level_t *HisoLiso2ScaleCoring);
+
+/**
+ * @brief Get HisoLiso2ScaleCoring of GData
+ * This function will copy HisoLiso2ScaleCoring of GData.
+ *
+ * @param[out] amba_img_dsp_level_t *HisoLiso2ScaleCoring: HisoLiso2ScaleCoring Config. Detail please reference amba_img_dsp_level_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoLiso2ScaleCoring(amba_img_dsp_level_t *HisoLiso2ScaleCoring);
+
+/**
+ * @brief Set VideoMctf of GData
+ * This function will replace VideoMctf of GData, and set ITUNER_VIDEO_MCTF is valid.\n
+ * If you want to update a part of VideoMctf, you should call AmbaItuner_Get_VideoMctf() to get current VideoMctf before the replace process.
+ *
+ * @param[in] amba_img_dsp_video_mctf_info_t *VideoMctf: VideoMctf Config. Detail please reference amba_img_dsp_video_mctf_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_VideoMctf(amba_img_dsp_video_mctf_info_t *VideoMctf);
+
+/**
+ * @brief Get VideoMctf of GData
+ * This function will copy VideoMctf of GData.
+ *
+ * @param[out] amba_img_dsp_video_mctf_info_t *VideoMctf: VideoMctf Config. Detail please reference amba_img_dsp_video_mctf_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_VideoMctf(amba_img_dsp_video_mctf_info_t *VideoMctf);
+
+/**
+ * @brief Set VideoMctfTemporalAdjust of GData
+ * This function will replace VideoMctfTemporalAdjust of GData, and set ITUNER_VIDEO_MCTF_TEMPORAL_ADJUST is valid.\n
+ * If you want to update a part of VideoMctfTemporalAdjust, you should call AmbaItuner_Get_VideoMctfTemporalAdjust() to get current VideoMctf before the replace process.
+ *
+ * @param[in] amba_img_dsp_video_mctf_temporal_adjust_t *VideoMctfTemporalAdjust: VideoMctfTemporalAdjust Config. Detail please reference amba_img_dsp_video_mctf_temporal_adjust_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_VideoMctfTemporalAdjust(amba_img_dsp_video_mctf_temporal_adjust_t *VideoMctfTemporalAdjust);
+
+/**
+ * @brief Get VideoMctfTemporalAdjust of GData
+ * This function will copy VideoMctfTemporalAdjust of GData.
+ *
+ * @param[out] amba_img_dsp_video_mctf_temporal_adjust_t *VideoMctfTemporalAdjust: VideoMctfTemporalAdjust Config. Detail please reference amba_img_dsp_video_mctf_temporal_adjust_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_VideoMctfTemporalAdjust(amba_img_dsp_video_mctf_temporal_adjust_t *VideoMctfTemporalAdjust);
+
+/**
+ * @brief Set CDNR of GData
+ * This function will replace CDNR of GData, and set ITUNER_CDNR is valid.\n
+ * If you want to update a part of CDNR, you should call AmbaItuner_Get_CDNR() to get current CDNR before the replace process.
+ *
+ * @param[in] : CDNR Config. Detail please reference amba_img_dsp_cdnr_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_CDNR(amba_img_dsp_cdnr_info_t *CDNR);
+
+/**
+ * @brief Get CDNR of GData
+ * This function will copy CDNR of GData.
+ *
+ * @param[out] amba_img_dsp_cdnr_info_t *CDNR: CDNR Config. Detail please reference amba_img_dsp_cdnr_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_CDNR(amba_img_dsp_cdnr_info_t *CDNR);
+
+/**
+ * @brief Set HisoCDNR of GData
+ * This function will replace HisoCDNR of GData, and set ITUNER_HISO_CDNR is valid.\n
+ * If you want to update a part of HisoCDNR, you should call AmbaItuner_Get_HisoCDNR() to get current HisoCDNR before the replace process.
+ *
+ * @param[in] amba_img_dsp_cdnr_info_t *HisoCDNR: HisoCDNR Config. Detail please reference amba_img_dsp_cdnr_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoCDNR(amba_img_dsp_cdnr_info_t *HisoCDNR);
+
+/**
+ * @brief Get HisoCDNR of GData
+ * This function will copy HisoCDNR of GData.
+ *
+ * @param[out] amba_img_dsp_cdnr_info_t *HisoCDNR: HisoCDNR Config. Detail please reference amba_img_dsp_cdnr_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoCDNR(amba_img_dsp_cdnr_info_t *HisoCDNR);
+
+/**
+ * @brief Set HisoDeferColorCorrection of GData
+ * This function will replace HisoDeferColorCorrection of GData, and set ITUNER_HISO_DEFER_COLOR_CORRECTION is valid.\n
+ * If you want to update a part of HisoDeferColorCorrection, you should call AmbaItuner_Get_HisoDeferColorCorrection() to get current HisoDeferColorCorrection before the replace process.
+ *
+ * @param[in] AMBA_DSP_IMG_DEFER_COLOR_CORRECTION_s *HisoDeferColorCorrection: HisoDeferColorCorrection Config. Detail please reference AMBA_DSP_IMG_DEFER_COLOR_CORRECTION_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoDeferColorCorrection(AMBA_DSP_IMG_DEFER_COLOR_CORRECTION_s *HisoDeferColorCorrection);
+
+/**
+ * @brief Get HisoDeferColorCorrection of GData
+ * This function will copy HisoDeferColorCorrection of GData.
+ *
+ * @param[out] AMBA_DSP_IMG_DEFER_COLOR_CORRECTION_s *HisoDeferColorCorrection: HisoDeferColorCorrection Config. Detail please reference AMBA_DSP_IMG_DEFER_COLOR_CORRECTION_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoDeferColorCorrection(AMBA_DSP_IMG_DEFER_COLOR_CORRECTION_s *HisoDeferColorCorrection);
+
+/**
+ * @brief Set ShpAOrSpatialFilterSelect of GData
+ * This function will replace ShpAOrSpatialFilterSelect of GData, and set ITUNER_SHP_A_OR_SPATIAL_FILTE_SELECT is valid.\n
+ * If you want to update a part of ShpAOrSpatialFilterSelect, you should call AmbaItuner_Get_ShpAOrSpatialFilterSelect() to get current ShpAOrSpatialFilterSelect before the replace process.
+ *
+ * @param[in] UINT8 amba_img_dsp_liso_process_select_t *LisoProcessSelect: LisoProcessSelect Config. Detail please reference amba_img_dsp_liso_process_select_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_ShpAOrSpatialFilterSelect(amba_img_dsp_liso_process_select_t *LisoProcessSelect);
+
+/**
+ * @brief Get ShpAOrSpatialFilterSelect of GData
+ * This function will copy ShpAOrSpatialFilterSelect of GData.
+ *
+ * @param[out] UINT8 amba_img_dsp_liso_process_select_t *LisoProcessSelect: LisoProcessSelect Config. Detail please reference amba_img_dsp_liso_process_select_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_ShpAOrSpatialFilterSelect(amba_img_dsp_liso_process_select_t *LisoProcessSelect);
+
+/**
+ * @brief Set SharpBLinearizationStrength of GData
+ * This function will replace SharpBLinearizationStrength of GData, and set ITUNER_SHARP_B_LINEARIZATION_STRENGTH is valid.\n
+ * If you want to update a part of SharpBLinearizationStrength, you should call AmbaItuner_Get_SharpBLinearizationStrength() to get current SharpBLinearizationStrength before the replace process.
+ *
+ * @param[in] UINT16 *SharpBLinearizationStrength: SharpBLinearizationStrength Config.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_SharpBLinearizationStrength(UINT16 *SharpBLinearizationStrength);
+
+/**
+ * @brief Get SharpBLinearizationStrength of GData
+ * This function will copy SharpBLinearizationStrength of GData.
+ *
+ * @param[out] UINT16 *SharpBLinearizationStrength: SharpBLinearizationStrength Config.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_SharpBLinearizationStrength(UINT16 *SharpBLinearizationStrength);
+
+/**
+ * @brief Set AsfInfo of GData
+ * This function will replace AsfInfo of GData, and set ITUNER_ASF_INFO is valid.\n
+ * If you want to update a part of AsfInfo, you should call AmbaItuner_Get_AsfInfo() to get current AsfInfo before the replace process.
+ *
+ * @param[in] amba_img_dsp_asf_info_t *AsfInfo: AsfInfo Config. Detail please reference amba_img_dsp_asf_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_AsfInfo(amba_img_dsp_asf_info_t *AsfInfo);
+
+/**
+ * @brief Get AsfInfo of GData
+ * This function will copy AsfInfo of GData.
+ *
+ * @param[out] amba_img_dsp_asf_info_t *AsfInfo: AsfInfo Config. Detail please reference amba_img_dsp_asf_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_AsfInfo(amba_img_dsp_asf_info_t *AsfInfo);
+
+/**
+ * @brief Set HisoAsf of GData
+ * This function will replace HisoAsf of GData, and set ITUNER_HISO_ASF is valid.\n
+ * If you want to update a part of HisoAsf, you should call AmbaItuner_Get_HisoAsf() to get current HisoAsf before the replace process.
+ *
+ * @param[in] amba_img_dsp_asf_info_t *HisoAsf: HisoAsf Config. Detail please reference amba_img_dsp_asf_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoAsf(amba_img_dsp_asf_info_t *HisoAsf);
+
+/**
+ * @brief Get HisoAsf of GData
+ * This function will copy HisoAsf of GData.
+ *
+ * @param[out] amba_img_dsp_asf_info_t *HisoAsf: HisoAsf Config. Detail please reference amba_img_dsp_asf_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoAsf(amba_img_dsp_asf_info_t *HisoAsf);
+
+/**
+ * @brief Set HisoHighAsf of GData
+ * This function will replace HisoHighAsf of GData, and set ITUNER_HISO_HIGH_ASF is valid.\n
+ * If you want to update a part of HisoHighAsf, you should call AmbaItuner_Get_HisoHighAsf() to get current HisoHighAsf before the replace process.
+ *
+ * @param[in] amba_img_dsp_asf_info_t *HisoHighAsf: HisoHighAsf Config. Detail please reference amba_img_dsp_asf_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoHighAsf(amba_img_dsp_asf_info_t *HisoHighAsf);
+
+/**
+ * @brief Get HisoHighAsf of GData
+ * This function will copy HisoHighAsf of GData.
+ *
+ * @param[out] amba_img_dsp_asf_info_t *HisoHighAsf: HisoHighAsf Config. Detail please reference amba_img_dsp_asf_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoHighAsf(amba_img_dsp_asf_info_t *HisoHighAsf);
+
+/**
+ * @brief Set HisoLowAsf of GData
+ * This function will replace HisoLowAsf of GData, and set ITUNER_HISO_LOW_ASF is valid.\n
+ * If you want to update a part of HisoLowAsf, you should call AmbaItuner_Get_HisoLowAsf() to get current HisoLowAsf before the replace process.
+ *
+ * @param[in] amba_img_dsp_asf_info_t *HisoLowAsf: HisoLowAsf Config. Detail please reference amba_img_dsp_asf_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoLowAsf(amba_img_dsp_asf_info_t *HisoLowAsf);
+
+/**
+ * @brief Get HisoLowAsf of GData
+ * This function will copy HisoLowAsf of GData.
+ *
+ * @param[out] amba_img_dsp_asf_info_t *HisoLowAsf: HisoLowAsf Config. Detail please reference amba_img_dsp_asf_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoLowAsf(amba_img_dsp_asf_info_t *HisoLowAsf);
+
+/**
+ * @brief Set HisoMedAsf of GData
+ * This function will replace HisoMedAsf of GData, and set ITUNER_HISO_MED_ASF is valid.\n
+ * If you want to update a part of HisoMedAsf, you should call AmbaItuner_Get_HisoMedAsf() to get current HisoMedAsf before the replace process.
+ *
+ * @param[in] amba_img_dsp_asf_info_t *HisoMedAsf: HisoMedAsf Config. Detail please reference amba_img_dsp_asf_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoMedAsf(amba_img_dsp_asf_info_t *HisoMedAsf);
+
+/**
+ * @brief Get HisoMedAsf of GData
+ * This function will copy HisoMedAsf of GData.
+ *
+ * @param[out] amba_img_dsp_asf_info_t *HisoMedAsf: HisoMedAsf Config. Detail please reference amba_img_dsp_asf_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoMedAsf(amba_img_dsp_asf_info_t *HisoMedAsf);
+
+/**
+ * @brief Set HisoLi2ndAsf of GData
+ * This function will replace HisoLi2ndAsf of GData, and set ITUNER_HISO_LI2ND_ASF is valid.\n
+ * If you want to update a part of HisoLi2ndAsf, you should call AmbaItuner_Get_HisoLi2ndAsf() to get current HisoLi2ndAsf before the replace process.
+ *
+ * @param[in] amba_img_dsp_asf_info_t *HisoLi2ndAsf: HisoLi2ndAsf Config. Detail please reference amba_img_dsp_asf_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoLi2ndAsf(amba_img_dsp_asf_info_t *HisoLi2ndAsf);
+
+/**
+ * @brief Get HisoLi2ndAsf of GData
+ * This function will copy HisoLi2ndAsf of GData.
+ *
+ * @param[out] amba_img_dsp_asf_info_t *HisoLi2ndAsf: HisoLi2ndAsf Config. Detail please reference amba_img_dsp_asf_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoLi2ndAsf(amba_img_dsp_asf_info_t *HisoLi2ndAsf);
+
+/**
+ * @brief Set HisoChromaAsf of GData
+ * This function will replace HisoChromaAsf of GData, and set ITUNER_HISO_CHROMA_ASF is valid.\n
+ * If you want to update a part of HisoChromaAsf, you should call AmbaItuner_Get_HisoChromaAsf() to get current HisoChromaAsf before the replace process.
+ *
+ * @param[in] amba_img_dsp_asf_info_t *HisoChromaAsf: HisoChromaAsf Config. Detail please reference amba_img_dsp_asf_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoChromaAsf(AMBA_DSP_IMG_CHROMA_ASF_INFO_s *HisoChromaAsf);
+
+/**
+ * @brief Get HisoChromaAsf of GData
+ * This function will copy HisoChromaAsf of GData.
+ *
+ * @param[out] amba_img_dsp_asf_info_t *HisoChromaAsf: HisoChromaAsf Config. Detail please reference amba_img_dsp_asf_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoChromaAsf(AMBA_DSP_IMG_CHROMA_ASF_INFO_s *HisoChromaAsf);
+
+
+/**
+ * @brief Set ChromaFilter of GData
+ * This function will replace ChromaFilter of GData, and set ITUNER_CHROMA_FILTER is valid.\n
+ * If you want to update a part of ChromaFilter, you should call AmbaItuner_Get_ChromaFilter() to get current ChromaFilter before the replace process.
+ *
+ * @param[in] amba_img_dsp_chroma_filter_t *ChromaFilter: ChromaFilter Config. Detail please reference amba_img_dsp_chroma_filter_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_ChromaFilter(amba_img_dsp_chroma_filter_t *ChromaFilter);
+
+/**
+ * @brief Get ChromaFilter of GData
+ * This function will copy ChromaFilter of GData.
+ *
+ * @param[out] amba_img_dsp_chroma_filter_t *ChromaFilter: ChromaFilter Config. Detail please reference amba_img_dsp_chroma_filter_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_ChromaFilter(amba_img_dsp_chroma_filter_t *ChromaFilter);
+
+/**
+ * @brief Set WideChromaFilter of GData
+ * This function will replace WideChromaFilter of GData, and set ITUNER_WIDE_CHROMA_FILTER is valid.\n
+ * If you want to update a part of WideChromaFilter, you should call AmbaItuner_Get_WideChromaFilter() to get current ChromaFilter before the replace process.
+ *
+ * @param[in] amba_img_dsp_chroma_filter_t *WideChromaFilter: ChromaFilter Config. Detail please reference amba_img_dsp_chroma_filter_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_WideChromaFilter(amba_img_dsp_chroma_filter_t *WideChromaFilter);
+
+/**
+ * @brief Get WideChromaFilter of GData
+ * This function will copy WideChromaFilter of GData.
+ *
+ * @param[out] amba_img_dsp_chroma_filter_t *WideChromaFilter: ChromaFilter Config. Detail please reference amba_img_dsp_chroma_filter_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_WideChromaFilter(amba_img_dsp_chroma_filter_t *WideChromaFilter);
+
+/**
+ * @brief Set WideChromaFilterCombine of GData
+ * This function will replace WideChromaFilterCombine of GData, and set ITUNER_WIDE_CHROMA_FILTER is valid.\n
+ * If you want to update a part of WideChromaFilterCombine, you should call AmbaItuner_Get_WideChromaFilterCombine() to get current ChromaFilter before the replace process.
+ *
+ * @param[in] AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s *WideChromaFilterCombine: ChromaFilter Config. Detail please reference AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_WideChromaFilterCombine(AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s *WideChromaFilterCombine);
+
+/**
+ * @brief Get WideChromaFilterCombine of GData
+ * This function will copy WideChromaFilterCombine of GData.
+ *
+ * @param[out] AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s *WideChromaFilterCombine: ChromaFilter Config. Detail please reference AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_WideChromaFilterCombine(AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s *WideChromaFilterCombine);
+
+/**
+ * @brief Set HisoChromaFilterHigh of GData
+ * This function will replace HisoChromaFilterHigh of GData, and set ITUNER_HISO_CHROMA_FILTER_HIGH is valid.\n
+ * If you want to update a part of HisoChromaFilterHigh, you should call AmbaItuner_Get_HisoChromaFilterHigh() to get current HisoChromaFilterHigh before the replace process.
+ *
+ * @param[in] amba_img_dsp_chroma_filter_t *HisoChromaFilterHigh: HisoChromaFilterHigh Config. Detail please reference amba_img_dsp_chroma_filter_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoChromaFilterHigh(amba_img_dsp_chroma_filter_t *HisoChromaFilterHigh);
+
+/**
+ * @brief Get HisoChromaFilterHigh of GData
+ * This function will copy HisoChromaFilterHigh of GData.
+ *
+ * @param[out] amba_img_dsp_chroma_filter_t *HisoChromaFilterHigh: HisoChromaFilterHigh Config. Detail please reference amba_img_dsp_chroma_filter_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoChromaFilterHigh(amba_img_dsp_chroma_filter_t *HisoChromaFilterHigh);
+
+/**
+ * @brief Set GbGrMismatch of GData
+ * This function will replace GbGrMismatch of GData, and set ITUNER_GB_GR_MISMATCH is valid.\n
+ * If you want to update a part of GbGrMismatch, you should call AmbaItuner_Get_GbGrMismatch() to get current GbGrMismatch before the replace process.
+ *
+ * @param[in] amba_img_dsp_gbgr_mismatch_t *GbGrMismatch: GbGrMismatch Config. Detail please reference amba_img_dsp_gbgr_mismatch_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_GbGrMismatch(amba_img_dsp_gbgr_mismatch_t *GbGrMismatch);
+
+/**
+ * @brief Get GbGrMismatch of GData
+ * This function will copy GbGrMismatch of GData.
+ *
+ * @param[out] amba_img_dsp_gbgr_mismatch_t *GbGrMismatch: GbGrMismatch Config. Detail please reference amba_img_dsp_gbgr_mismatch_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_GbGrMismatch(amba_img_dsp_gbgr_mismatch_t *GbGrMismatch);
+
+/**
+ * @brief Set HisoGbGrMismatch of GData
+ * This function will replace HisoGbGrMismatch of GData, and set ITUNER_HISO_GB_GR_MISMATCH is valid.\n
+ * If you want to update a part of HisoGbGrMismatch, you should call AmbaItuner_Get_HisoGbGrMismatch() to get current HisoGbGrMismatch before the replace process.
+ *
+ * @param[in] amba_img_dsp_gbgr_mismatch_t *HisoGbGrMismatch: HisoGbGrMismatch Config. Detail please reference amba_img_dsp_gbgr_mismatch_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoGbGrMismatch(amba_img_dsp_gbgr_mismatch_t *HisoGbGrMismatch);
+
+/**
+ * @brief Get HisoGbGrMismatch of GData
+ * This function will copy HisoGbGrMismatch of GData.
+ *
+ * @param[out] amba_img_dsp_gbgr_mismatch_t *HisoGbGrMismatch: HisoGbGrMismatch Config. Detail please reference amba_img_dsp_gbgr_mismatch_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoGbGrMismatch(amba_img_dsp_gbgr_mismatch_t *HisoGbGrMismatch);
+
+/**
+ * @brief Set ChromaAberrationInfo of GData
+ * This function will replace ChromaAberrationInfo of GData, and set ITUNER_CHROMA_ABERRATION_INFO is valid.\n
+ * If you want to update a part of ChromaAberrationInfo, you should call AmbaItuner_Get_ChromaAberrationInfo() to get current ChromaAberrationInfo before the replace process.
+ *
+ * @param[in] ITUNER_CHROMA_ABERRATION_s *ChromaAberrationInfo: ChromaAberrationInfo Config. Detail please reference ITUNER_CHROMA_ABERRATION_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_ChromaAberrationInfo(ITUNER_CHROMA_ABERRATION_s *ChromaAberrationInfo);
+
+/**
+ * @brief Get ChromaAberrationInfo of GData
+ * This function will copy ChromaAberrationInfo of GData.
+ *
+ * @param[out] ITUNER_CHROMA_ABERRATION_s *ChromaAberrationInfo: ChromaAberrationInfo Config. Detail please reference ITUNER_CHROMA_ABERRATION_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_ChromaAberrationInfo(ITUNER_CHROMA_ABERRATION_s *ChromaAberrationInfo);
+
+
+/**
+ * @brief Get CA Table
+ * This function will copy CA Table of GData.(Read only)
+ *
+ * @param[out] AMBA_DSP_IMG_CAWARP_CALC_INFO_s *CACalcInfo: CA Table, It's read only, please don't edit it.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_CACalcInfo(AMBA_DSP_IMG_CAWARP_CALC_INFO_s *CACalcInfo);
+
+/**
+ * @brief Set ChromaAberrationInfoByPass of GData
+ * This function will replace ChromaAberrationInfoByPass of GData, and set ITUNER_CHROMA_ABERRATION_INFO_BY_PASS is valid.\n
+ * If you want to update a part of ChromaAberrationInfoByPass, you should call AmbaItuner_Get_ChromaAberrationInfoByPass() to get current ChromaAberrationInfoByPass before the replace process.
+ *
+ * @param[in] ITUNER_CHROMA_ABERRATION_BYPASS_s *ChromaAberrationInfoByPass: ChromaAberrationInfoByPass Config. Detail please reference ITUNER_CHROMA_ABERRATION_BYPASS_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_ChromaAberrationInfoByPass(ITUNER_CHROMA_ABERRATION_BYPASS_s *ChromaAberrationInfoByPass);
+
+/**
+ * @brief Get ChromaAberrationInfoByPass of GData
+ * This function will copy ChromaAberrationInfoByPass of GData.
+ *
+ * @param[out] ITUNER_CHROMA_ABERRATION_BYPASS_s *ChromaAberrationInfoByPass: ChromaAberrationInfoByPass Config. Detail please reference ITUNER_CHROMA_ABERRATION_BYPASS_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_ChromaAberrationInfoByPass(ITUNER_CHROMA_ABERRATION_BYPASS_s *ChromaAberrationInfoByPass);
+
+/**
+ * @brief Set HisoChromaFilterLowVeryLow of GData
+ * This function will replace HisoChromaFilterLowVeryLow of GData, and set ITUNER_HISO_CHROMA_FILTER_LOW_VERY_LOW is valid.\n
+ * If you want to update a part of HisoChromaFilterLowVeryLow, you should call AmbaItuner_Get_HisoChromaFilterLowVeryLow() to get current HisoChromaFilterLowVeryLow before the replace process.
+ *
+ * @param[in] AMBA_DSP_IMG_HISO_CHROMA_LOW_VERY_LOW_FILTER_s *HisoChromaFilterLowVeryLow: HisoChromaFilterLowVeryLow Config. Detail please reference AMBA_DSP_IMG_HISO_CHROMA_LOW_VERY_LOW_FILTER_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoChromaFilterLowVeryLow(AMBA_DSP_IMG_HISO_CHROMA_LOW_VERY_LOW_FILTER_s *HisoChromaFilterLowVeryLow);
+
+/**
+ * @brief Get HisoChromaFilterLowVeryLow of GData
+ * This function will copy HisoChromaFilterLowVeryLow of GData.
+ *
+ * @param[out] AMBA_DSP_IMG_HISO_CHROMA_LOW_VERY_LOW_FILTER_s *HisoChromaFilterLowVeryLow: HisoChromaFilterLowVeryLow Config. Detail please reference AMBA_DSP_IMG_HISO_CHROMA_LOW_VERY_LOW_FILTER_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoChromaFilterLowVeryLow(AMBA_DSP_IMG_HISO_CHROMA_LOW_VERY_LOW_FILTER_s *HisoChromaFilterLowVeryLow);
+
+/**
+ * @brief Set HisoChromaFilterPre of GData
+ * This function will replace HisoChromaFilterPre of GData, and set ITUNER_HISO_CHROMA_FILTER_PRE is valid.\n
+ * If you want to update a part of HisoChromaFilterPre, you should call AmbaItuner_Get_HisoChromaFilterPre() to get current HisoChromaFilterPre before the replace process.
+ *
+ * @param[in] AMBA_DSP_IMG_HISO_CHROMA_FILTER_s *HisoChromaFilterPre: HisoChromaFilterPre Config. Detail please reference AMBA_DSP_IMG_HISO_CHROMA_FILTER_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoChromaFilterPre(AMBA_DSP_IMG_HISO_CHROMA_FILTER_s *HisoChromaFilterPre);
+
+/**
+ * @brief Get HisoChromaFilterPre of GData
+ * This function will copy HisoChromaFilterPre of GData.
+ *
+ * @param[out] AMBA_DSP_IMG_HISO_CHROMA_FILTER_s *HisoChromaFilterPre: HisoChromaFilterPre Config. Detail please reference AMBA_DSP_IMG_HISO_CHROMA_FILTER_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoChromaFilterPre(AMBA_DSP_IMG_HISO_CHROMA_FILTER_s *HisoChromaFilterPre);
+
+/**
+ * @brief Set HisoChromaFilterMed of GData
+ * This function will replace HisoChromaFilterMed of GData, and set ITUNER_HISO_CHROMA_FILTER_MED is valid.\n
+ * If you want to update a part of HisoChromaFilterMed, you should call AmbaItuner_Get_HisoChromaFilterMed() to get current HisoChromaFilterMed before the replace process.
+ *
+ * @param[in] AMBA_DSP_IMG_HISO_CHROMA_FILTER_s *HisoChromaFilterMed: HisoChromaFilterMed Config. Detail please reference AMBA_DSP_IMG_HISO_CHROMA_FILTER_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoChromaFilterMed(AMBA_DSP_IMG_HISO_CHROMA_FILTER_s *HisoChromaFilterMed);
+
+/**
+ * @brief Get HisoChromaFilterMed of GData
+ * This function will copy HisoChromaFilterMed of GData.
+ *
+ * @param[out] AMBA_DSP_IMG_HISO_CHROMA_FILTER_s *HisoChromaFilterMed: HisoChromaFilterMed Config. Detail please reference AMBA_DSP_IMG_HISO_CHROMA_FILTER_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoChromaFilterMed(AMBA_DSP_IMG_HISO_CHROMA_FILTER_s *HisoChromaFilterMed);
+
+/**
+ * @brief Set HisoChromaFilterLow of GData
+ * This function will replace HisoChromaFilterLow of GData, and set ITUNER_HISO_CHROMA_FILTER_LOW is valid.\n
+ * If you want to update a part of HisoChromaFilterLow, you should call AmbaItuner_Get_HisoChromaFilterLow() to get current HisoChromaFilterLow before the replace process.
+ *
+ * @param[in] AMBA_DSP_IMG_HISO_CHROMA_FILTER_s *HisoChromaFilterLow: HisoChromaFilterLow Config. Detail please reference AMBA_DSP_IMG_HISO_CHROMA_FILTER_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoChromaFilterLow(AMBA_DSP_IMG_HISO_CHROMA_FILTER_s *HisoChromaFilterLow);
+
+/**
+ * @brief Get HisoChromaFilterLow of GData
+ * This function will copy HisoChromaFilterLow of GData.
+ *
+ * @param[out] AMBA_DSP_IMG_HISO_CHROMA_FILTER_s *HisoChromaFilterLow: HisoChromaFilterLow Config. Detail please reference AMBA_DSP_IMG_HISO_CHROMA_FILTER_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoChromaFilterLow(AMBA_DSP_IMG_HISO_CHROMA_FILTER_s *HisoChromaFilterLow);
+
+/**
+ * @brief Set HisoChromaFilterVeryLow of GData
+ * This function will replace HisoChromaFilterVeryLow of GData, and set ITUNER_HISO_CHROMA_FILTER_VERY_LOW is valid.\n
+ * If you want to update a part of HisoChromaFilterVeryLow, you should call AmbaItuner_Get_HisoChromaFilterVeryLow() to get current HisoChromaFilterVeryLow before the replace process.
+ *
+ * @param[in] AMBA_DSP_IMG_HISO_CHROMA_FILTER_s *HisoChromaFilterVeryLow: HisoChromaFilterVeryLow Config. Detail please reference AMBA_DSP_IMG_HISO_CHROMA_FILTER_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoChromaFilterVeryLow(AMBA_DSP_IMG_HISO_CHROMA_FILTER_s *HisoChromaFilterVeryLow);
+
+/**
+ * @brief Get HisoChromaFilterVeryLow of GData
+ * This function will copy HisoChromaFilterVeryLow of GData.
+ *
+ * @param[out] AMBA_DSP_IMG_HISO_CHROMA_FILTER_s *HisoChromaFilterVeryLow: HisoChromaFilterVeryLow Config. Detail please reference AMBA_DSP_IMG_HISO_CHROMA_FILTER_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoChromaFilterVeryLow(AMBA_DSP_IMG_HISO_CHROMA_FILTER_s *HisoChromaFilterVeryLow);
+
+/**
+ * @brief Set HisoChromaFilterMedCombine of GData
+ * This function will replace HisoChromaFilterMedCombine of GData, and set ITUNER_HISO_CHROMA_FILTER_MED_COMBINE is valid.\n
+ * If you want to update a part of HisoChromaFilterMedCombine, you should call AmbaItuner_Get_HisoChromaFilterMedCombine() to get current HisoChromaFilterMedCombine before the replace process.
+ *
+ * @param[in] AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s *HisoChromaFilterMedCombine: HisoChromaFilterMedCombine Config. Detail please reference AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoChromaFilterMedCombine(AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s *HisoChromaFilterMedCombine);
+
+/**
+ * @brief Get HisoChromaFilterMedCombine of GData
+ * This function will copy HisoChromaFilterMedCombine of GData.
+ *
+ * @param[out] AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s *HisoChromaFilterMedCombine: HisoChromaFilterMedCombine Config. Detail please reference AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoChromaFilterMedCombine(AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s *HisoChromaFilterMedCombine);
+
+/**
+ * @brief Set HisoChromaFilterVeryLowCombine of GData
+ * This function will replace HisoChromaFilterVeryLowCombine of GData, and set ITUNER_HISO_CHROMA_FILTER_VERY_LOW_COMBINE is valid.\n
+ * If you want to update a part of HisoChromaFilterVeryLowCombine, you should call AmbaItuner_Get_HisoChromaFilterVeryLowCombine() to get current HisoChromaFilterVeryLowCombine before the replace process.
+ *
+ * @param[in] AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s *HisoChromaFilterVeryLowCombine: HisoChromaFilterVeryLowCombine Config. Detail please reference AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoChromaFilterVeryLowCombine(AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s *HisoChromaFilterVeryLowCombine);
+
+/**
+ * @brief Get HisoChromaFilterVeryLowCombine of GData
+ * This function will copy HisoChromaFilterVeryLowCombine of GData.
+ *
+ * @param[out] AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s *HisoChromaFilterVeryLowCombine: HisoChromaFilterVeryLowCombine Config. Detail please reference AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoChromaFilterVeryLowCombine(AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s *HisoChromaFilterVeryLowCombine);
+
+/**
+ * @brief Set HisoChromaFilterLowCombine of GData
+ * This function will replace HisoChromaFilterLowCombine of GData, and set ITUNER_HISO_CHROMA_FILTER_LOW_COMBINE is valid.\n
+ * If you want to update a part of HisoChromaFilterLowCombine, you should call AmbaItuner_Get_HisoChromaFilterLowCombine() to get current HisoChromaFilterLowCombine before the replace process.
+ *
+ * @param[in] AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s *HisoChromaFilterLowCombine: HisoChromaFilterLowCombine Config. Detail please reference AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoChromaFilterLowCombine(AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s *HisoChromaFilterLowCombine);
+
+/**
+ * @brief Get HisoChromaFilterLowCombine of GData
+ * This function will copy HisoChromaFilterLowCombine of GData.
+ *
+ * @param[out] AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s *HisoChromaFilterLowCombine: HisoChromaFilterLowCombine Config. Detail please reference AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoChromaFilterLowCombine(AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s *HisoChromaFilterLowCombine);
+
+/**
+ * @brief Set HisoLumaNoiseCombine of GData
+ * This function will replace HisoLumaNoiseCombine of GData, and set ITUNER_HISO_LUMA_NOISE_COMBINE is valid.\n
+ * If you want to update a part of HisoLumaNoiseCombine, you should call AmbaItuner_Get_HisoLumaNoiseCombine() to get current HisoLumaNoiseCombine before the replace process.
+ *
+ * @param[in] AMBA_DSP_IMG_HISO_LUMA_FILTER_COMBINE_s *HisoLumaNoiseCombine: HisoLumaNoiseCombine Config. Detail please reference AMBA_DSP_IMG_HISO_LUMA_FILTER_COMBINE_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoLumaNoiseCombine(AMBA_DSP_IMG_HISO_LUMA_FILTER_COMBINE_s *HisoLumaNoiseCombine);
+
+/**
+ * @brief Get HisoLumaNoiseCombine of GData
+ * This function will copy HisoLumaNoiseCombine of GData.
+ *
+ * @param[out] AMBA_DSP_IMG_HISO_LUMA_FILTER_COMBINE_s *HisoLumaNoiseCombine: HisoLumaNoiseCombine Config. Detail please reference AMBA_DSP_IMG_HISO_LUMA_FILTER_COMBINE_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoLumaNoiseCombine(AMBA_DSP_IMG_HISO_LUMA_FILTER_COMBINE_s *HisoLumaNoiseCombine);
+
+/**
+ * @brief Set HisoLowASFCombine of GData
+ * This function will replace HisoLowASFCombine of GData, and set ITUNER_HISO_LOW_ASF_COMBINE is valid.\n
+ * If you want to update a part of HisoLowASFCombine, you should call AmbaItuner_Get_HisoLowASFCombine() to get current HisoLowASFCombine before the replace process.
+ *
+ * @param[in] AMBA_DSP_IMG_HISO_LUMA_FILTER_COMBINE_s *HisoLowASFCombine: HisoLowASFCombine Config. Detail please reference AMBA_DSP_IMG_HISO_LUMA_FILTER_COMBINE_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoLowASFCombine(AMBA_DSP_IMG_HISO_LUMA_FILTER_COMBINE_s *HisoLowASFCombine);
+
+/**
+ * @brief Get HisoLowASFCombine of GData
+ * This function will copy HisoLowASFCombine of GData.
+ *
+ * @param[out] AMBA_DSP_IMG_HISO_LUMA_FILTER_COMBINE_s *HisoLowASFCombine: HisoLowASFCombine Config. Detail please reference AMBA_DSP_IMG_HISO_LUMA_FILTER_COMBINE_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoLowASFCombine(AMBA_DSP_IMG_HISO_LUMA_FILTER_COMBINE_s *HisoLowASFCombine);
+
+/**
+ * @brief Set HighIsoCombine of GData
+ * This function will replace HighIsoCombine of GData, and set ITUNER_HIGH_ISO_COMBINE is valid.\n
+ * If you want to update a part of HighIsoCombine, you should call AmbaItuner_Get_HighIsoCombine() to get current HighIsoCombine before the replace process.
+ *
+ * @param[in] AMBA_DSP_IMG_HISO_COMBINE_s *HighIsoCombine: HighIsoCombine Config. Detail please reference AMBA_DSP_IMG_HISO_COMBINE_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HighIsoCombine(AMBA_DSP_IMG_HISO_COMBINE_s *HighIsoCombine);
+
+/**
+ * @brief Get HighIsoCombine of GData
+ * This function will copy HighIsoCombine of GData.
+ *
+ * @param[out] AMBA_DSP_IMG_HISO_COMBINE_s *HighIsoCombine: HighIsoCombine Config. Detail please reference AMBA_DSP_IMG_HISO_COMBINE_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HighIsoCombine(AMBA_DSP_IMG_HISO_COMBINE_s *HighIsoCombine);
+
+/**
+ * @brief Set HisoLow2LumaBlend of GData
+ * This function will replace HisoLow2LumaBlend of GData, and set ITUNER_HISO_LOW2_LUMA_BLEND is valid.\n
+ * If you want to update a part of HisoLow2LumaBlend, you should call AmbaItuner_Get_HisoLow2LumaBlend() to get current HisoLow2LumaBlend before the replace process.
+ *
+ * @param[in] AMBA_DSP_IMG_HISO_LUMA_BLEND_s *HisoLow2LumaBlend: HisoLow2LumaBlend Config. Detail please reference AMBA_DSP_IMG_HISO_LUMA_BLEND_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoLow2LumaBlend(AMBA_DSP_IMG_HISO_LUMA_BLEND_s *HisoLow2LumaBlend);
+
+/**
+ * @brief Get HisoLow2LumaBlend of GData
+ * This function will copy HisoLow2LumaBlend of GData.
+ *
+ * @param[out] AMBA_DSP_IMG_HISO_LUMA_BLEND_s *HisoLow2LumaBlend: HisoLow2LumaBlend Config. Detail please reference AMBA_DSP_IMG_HISO_LUMA_BLEND_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoLow2LumaBlend(AMBA_DSP_IMG_HISO_LUMA_BLEND_s *HisoLow2LumaBlend);
+
+/**
+ * @brief Set HisoLow2BlendLumaLevel of GData
+ * This function will replace HisoLow2BlendLumaLevel of GData, and set ITUNER_HISO_LOW2_BLEND_LUMA_LEVEL is valid.\n
+ * If you want to update a part of HisoLow2BlendLumaLevel, you should call AmbaItuner_Get_HisoLow2BlendLumaLevel() to get current HisoLow2BlendLumaLevel before the replace process.
+ *
+ * @param[in] AMBA_DSP_IMG_HISO_BLEND_s *HisoLow2BlendLumaLevel: HisoLow2BlendLumaLevel Config. Detail please reference AMBA_DSP_IMG_HISO_BLEND_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoLow2BlendLumaLevel(AMBA_DSP_IMG_HISO_BLEND_s *HisoLow2BlendLumaLevel);
+
+/**
+ * @brief Get HisoLow2BlendLumaLevel of GData
+ * This function will copy HisoLow2BlendLumaLevel of GData.
+ *
+ * @param[out] AMBA_DSP_IMG_HISO_BLEND_s *HisoLow2BlendLumaLevel: HisoLow2BlendLumaLevel Config. Detail please reference AMBA_DSP_IMG_HISO_BLEND_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoLow2BlendLumaLevel(AMBA_DSP_IMG_HISO_BLEND_s *HisoLow2BlendLumaLevel);
+
+/**
+ * @brief Set HisoFreqRecover of GData
+ * This function will replace HisoFreqRecover of GData, and set ITUNER_HISO_FREQ_RECOVER is valid.\n
+ * If you want to update a part of HisoFreqRecover, you should call AmbaItuner_Get_HisoFreqRecover() to get current HisoFreqRecover before the replace process.
+ *
+ * @param[in] AMBA_DSP_IMG_HISO_FREQ_RECOVER_s *HisoFreqRecover: HisoFreqRecover Config. Detail please reference AMBA_DSP_IMG_HISO_FREQ_RECOVER_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_HisoFreqRecover(AMBA_DSP_IMG_HISO_FREQ_RECOVER_s *HisoFreqRecover);
+
+/**
+ * @brief Get HisoFreqRecover of GData
+ * This function will copy HisoFreqRecover of GData.
+ *
+ * @param[out] AMBA_DSP_IMG_HISO_FREQ_RECOVER_s *HisoFreqRecover: HisoFreqRecover Config. Detail please reference AMBA_DSP_IMG_HISO_FREQ_RECOVER_s.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_HisoFreqRecover(AMBA_DSP_IMG_HISO_FREQ_RECOVER_s *HisoFreqRecover);
+
+/**
+ * @brief Set SensorInfo of GData
+ * This function will replace SensorInfo of GData, and set ITUNER_SENSOR_INFO is valid.\n
+ * If you want to update a part of SensorInfo, you should call AmbaItuner_Get_SensorInfo() to get current SensorInfo before the replace process.
+ *
+ * @param[in] amba_img_dsp_sensor_info_t *SensorInfo: SensorInfo Config. Detail please reference amba_img_dsp_sensor_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Set_SensorInfo(amba_img_dsp_sensor_info_t *SensorInfo);
+
+/**
+ * @brief Get SensorInfo of GData
+ * This function will copy SensorInfo of GData.
+ *
+ * @param[out] amba_img_dsp_sensor_info_t *SensorInfo: SensorInfo Config. Detail please reference amba_img_dsp_sensor_info_t.
+ *
+ * @return None
+ */
+void AmbaItuner_Get_SensorInfo(amba_img_dsp_sensor_info_t *SensorInfo);
+
+//MO PASS-3
+void AmbaItuner_Set_MoDynamicBadPixelCorrection(amba_img_dsp_dbp_correction_t *MoDynamicBadPixelCorrection);
+void AmbaItuner_Get_MoDynamicBadPixelCorrection(amba_img_dsp_dbp_correction_t *MoDynamicBadPixelCorrection);
+void AmbaItuner_Set_MoCfaLeakageFilter(amba_img_dsp_cfa_leakage_filter_t *MoCfaLeakageFilter);
+void AmbaItuner_Get_MoCfaLeakageFilter(amba_img_dsp_cfa_leakage_filter_t *MoCfaLeakageFilter);
+void AmbaItuner_Set_MoCfaNoiseFilter(amba_img_dsp_cfa_noise_filter_t *MoCfaNoiseFilter);
+void AmbaItuner_Get_MoCfaNoiseFilter(amba_img_dsp_cfa_noise_filter_t *MoCfaNoiseFilter);
+void AmbaItuner_Set_MoAntiAliasingStrength(amba_img_dsp_anti_aliasing_t *MoAntiAliasing);
+void AmbaItuner_Get_MoAntiAliasingStrength(amba_img_dsp_anti_aliasing_t *MoAntiAliasing);
+void AmbaItuner_Set_MoDemosaicFilter(amba_img_dsp_demosaic_t *MoDemosaicFilter);
+void AmbaItuner_Get_MoDemosaicFilter(amba_img_dsp_demosaic_t *MoDemosaicFilter);
+void AmbaItuner_Set_MoGbGrMismatch(amba_img_dsp_gbgr_mismatch_t *MoGbGrMismatch);
+void AmbaItuner_Get_MoGbGrMismatch(amba_img_dsp_gbgr_mismatch_t *MoGbGrMismatch);
+void AmbaItuner_Set_MoShpAOrSpatialFilterSelect(amba_img_dsp_mo_process_select_t *MoProcessSelect);
+void AmbaItuner_Get_MoShpAOrSpatialFilterSelect(amba_img_dsp_mo_process_select_t *MoProcessSelect);
+void AmbaItuner_Set_MoAsfInfo(amba_img_dsp_asf_info_t *MoAsfInfo);
+void AmbaItuner_Get_MoAsfInfo(amba_img_dsp_asf_info_t *MoAsfInfo);
+void AmbaItuner_Set_MoChromaFilter(amba_img_dsp_chroma_filter_t *MoChromaFilter);
+void AmbaItuner_Get_MoChromaFilter(amba_img_dsp_chroma_filter_t *MoChromaFilter);
+void AmbaItuner_Set_MoChromaMedianFilter(amba_img_dsp_chroma_median_filter_t *MoChromaMedianFilter);
+void AmbaItuner_Get_MoChromaMedianFilter(amba_img_dsp_chroma_median_filter_t *MoChromaMedianFilter);
+void AmbaItuner_Set_MoSharpenBoth(amba_img_dsp_sharpen_both_t *MoSharpenBoth);
+void AmbaItuner_Get_MoSharpenBoth(amba_img_dsp_sharpen_both_t *MoSharpenBoth);
+void AmbaItuner_Set_MoSharpenNoise(amba_img_dsp_sharpen_noise_t *MoSharpenNoise);
+void AmbaItuner_Get_MoSharpenNoise(amba_img_dsp_sharpen_noise_t *MoSharpenNoise);
+void AmbaItuner_Set_MoFir(amba_img_dsp_fir_t *MoFir);
+void AmbaItuner_Get_MoFir(amba_img_dsp_fir_t *MoFir);
+void AmbaItuner_Set_MoCoring(amba_img_dsp_coring_t *MoCoring);
+void AmbaItuner_Get_MoCoring(amba_img_dsp_coring_t *MoCoring);
+void AmbaItuner_Set_MoCoringIndexScale(amba_img_dsp_level_t *MoCoringIndexScale);
+void AmbaItuner_Get_MoCoringIndexScale(amba_img_dsp_level_t *MoCoringIndexScale);
+void AmbaItuner_Set_MoMinCoringResult(amba_img_dsp_level_t *MoMinCoringResult);
+void AmbaItuner_Get_MoMinCoringResult(amba_img_dsp_level_t *MoMinCoringResult);
+void AmbaItuner_Set_MoScaleCoring(amba_img_dsp_level_t *MoScaleCoring);
+void AmbaItuner_Get_MoScaleCoring(amba_img_dsp_level_t *MoScaleCoring);
+
+#endif /* _AMBA_IMG_CALIB_ITUNER_H_ */
+/*!
+ *
+ * @} end of addtogroup Ituner
+ */
diff --git a/idsp_test/arch_s2l/AmbaTUNE_HdlrManager.c b/idsp_test/arch_s2l/AmbaTUNE_HdlrManager.c
new file mode 100644
index 0000000..0af3c67
--- /dev/null
+++ b/idsp_test/arch_s2l/AmbaTUNE_HdlrManager.c
@@ -0,0 +1,357 @@
+/*
+ *
+ * idsp_test
+ *
+ * History:
+ *	2013/09/05 - [Dylan] Created this file
+ *
+ * Description :
+ *	Load the tuned file which generated by Img tuning tool.
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <stdio.h>
+#include "AmbaTUNE_TextHdlr.h" // Note: Tune_Func_s Need
+#include "AmbaTUNE_HdlrManager.h"
+
+typedef struct _AMBA_KAL_MUTEX_t_ {
+    unsigned char Reserved[52];
+} AMBA_KAL_MUTEX_t;
+#define AmbaPrint(format, arg...)	printf(format"\n", ##arg)
+
+#define MNG_DEBF(fmt, arg...) AmbaPrint("[TUNE MNG][DEBUG]"fmt, ##arg)
+#define MNG_WARF(fmt, arg...) AmbaPrint("[TUNE MNG][WARNING]"fmt, ##arg)
+#define MNG_ERRF(fmt, arg...) AmbaPrint("[TUNE MNG][ERROR]"fmt, ##arg)
+
+#define OSAL_MUTEX_CREATE()// do {AmbaKAL_MutexCreate(gTune_Hdlr.Parser_Mutex);} while (0)
+#define OSAL_MUTEX_LOCK()// do {AmbaKAL_MutexTake(gTune_Hdlr.Parser_Mutex, AMBA_KAL_WAIT_FOREVER);} while(0)
+#define OSAL_MUTEX_UNLOCK()// do {AmbaKAL_MutexGive(gTune_Hdlr.Parser_Mutex);} while(0)
+
+#ifndef NULL
+#define NULL (void*)0
+#endif
+
+typedef struct {
+    int (*Init)(void);
+    int (*Save_IDSP)(amba_img_dsp_mode_cfg_t Mode, char *Filepath);
+    int (*Load_IDSP)(char *Filepath);
+    int (*get_ituner_stream)(char* ituner_stream);
+    int (*set_ituner_stream)(u8* ituner_stream,int size);
+    int (*Save_Data)(Ituner_Ext_File_Type_e Ext_File_Type, Ituner_Ext_File_Param_s *Ext_File_Param);
+    int (*Load_Data)(Ituner_Ext_File_Type_e Ext_File_Type, Ituner_Ext_File_Param_s *Ext_File_Param);
+    int (*Execute_IDSP)(int fd_iav, amba_img_dsp_mode_cfg_t Mode, AMBA_ITUNER_PROC_INFO_s *ProcInfo);
+    int (*Get_SystemInfo)(ITUNER_SYSTEM_s *System);
+    int (*Set_SystemInfo)(ITUNER_SYSTEM_s *System);
+    int (*Get_ItunerInfo)(ITUNER_INFO_s *ItunerInfo);
+} Tune_Func_s;
+
+
+static int _Fake_USBHdlr_Init(void){
+    MNG_ERRF("%s() %d, Not yet Implement", __func__, __LINE__);
+    return 0;
+}
+static int _Fake_USBHdlr_Save_IDSP(amba_img_dsp_mode_cfg_t Mode, char *Filepath){
+    MNG_ERRF("%s() %d, Not yet Implement", __func__, __LINE__);
+    return 0;
+}
+static int _Fake_USBHdlr_Load_IDSP(char *Filepath){
+    MNG_ERRF("%s() %d, Not yet Implement", __func__, __LINE__);
+    return 0;
+}
+static int _Fake_USBHdlr_Save_Data(Ituner_Ext_File_Type_e Ext_File_Type, Ituner_Ext_File_Param_s *Ext_File_Param){
+    MNG_ERRF("%s() %d, Not yet Implement", __func__, __LINE__);
+    return 0;
+}
+static int _Fake_USBHdlr_Load_Data(Ituner_Ext_File_Type_e Ext_File_Type, Ituner_Ext_File_Param_s *Ext_File_Param){
+    MNG_ERRF("%s() %d, Not yet Implement", __func__, __LINE__);
+    return 0;
+}
+static int _Fake_USBHdlr_Execute_IDSP(int fd_iav, amba_img_dsp_mode_cfg_t Mode, AMBA_ITUNER_PROC_INFO_s *ProcInfo){
+    MNG_ERRF("%s() %d, Not yet Implement", __func__, __LINE__);
+    return 0;
+}
+static int _Fake_USBHdlr_Get_SystemInfo(ITUNER_SYSTEM_s *System){
+    MNG_ERRF("%s() %d, Not yet Implement", __func__, __LINE__);
+    return 0;
+}
+static int _Fake_USBHdlr_Set_SystemInfo(ITUNER_SYSTEM_s *System){
+    MNG_ERRF("%s() %d, Not yet Implement", __func__, __LINE__);
+    return 0;
+}
+static int _Fake_USBHdlr_Get_ItunerInfo(ITUNER_INFO_s *ItunerInfo){
+    MNG_ERRF("%s() %d, Not yet Implement", __func__, __LINE__);
+    return 0;
+}
+
+static const Tune_Func_s gUSBHdlr_Func = {
+    .Init = _Fake_USBHdlr_Init,
+    .Save_IDSP = _Fake_USBHdlr_Save_IDSP,
+    .Load_IDSP = _Fake_USBHdlr_Load_IDSP,
+    .Save_Data = _Fake_USBHdlr_Save_Data,
+    .Load_Data = _Fake_USBHdlr_Load_Data,
+    .Execute_IDSP = _Fake_USBHdlr_Execute_IDSP,
+    .Get_SystemInfo = _Fake_USBHdlr_Get_SystemInfo,
+    .Set_SystemInfo = _Fake_USBHdlr_Set_SystemInfo,
+    .Get_ItunerInfo = _Fake_USBHdlr_Get_ItunerInfo,
+};
+
+static const Tune_Func_s gTextHdlr_Func = {
+    .Init = TextHdlr_Init,
+    .Save_IDSP = TextHdlr_Save_IDSP,
+    .Load_Data = TextHdlr_Load_Data,
+    .get_ituner_stream =TextHdlr_Load_ituner,
+    .set_ituner_stream =TextHdlr_set_ituner,
+    .Save_Data = TextHdlr_Save_Data,
+    .Load_IDSP = TextHdlr_Load_IDSP,
+    .Execute_IDSP = TextHdlr_Execute_IDSP,
+    .Get_SystemInfo = TextHdlr_Get_SystemInfo,
+    .Set_SystemInfo = TextHdlr_Set_SystemInfo,
+    .Get_ItunerInfo = TextHdlr_Get_ItunerInfo,
+};
+
+typedef enum {
+    TUNE_VALID = 0,
+    TUNE_INVALID,
+} TuneHdlr_Status_e;
+typedef struct {
+    TuneHdlr_Mode_e Active_Parser_Mode;
+    TuneHdlr_Status_e Parser_Status;
+    AMBA_KAL_MUTEX_t *Parser_Mutex;
+} TuneHdlr_s;
+static const Tune_Func_s *gTune_Func[MAX_TUNE] = {
+    &gTextHdlr_Func,
+    &gUSBHdlr_Func,
+};
+static AMBA_KAL_MUTEX_t gTune_Mutex;
+static TuneHdlr_s gTune_Hdlr = {
+    .Active_Parser_Mode = TEXT_TUNE,
+    .Parser_Status = TUNE_INVALID,
+    .Parser_Mutex = NULL,
+};
+
+static void _AmbaTUNE_Check_Mutex_Created(void)
+{
+    if (gTune_Hdlr.Parser_Mutex == NULL) {
+        MNG_DEBF("%s() %d, Create Mutex", __func__, __LINE__);
+        gTune_Hdlr.Parser_Mutex = &gTune_Mutex;
+        OSAL_MUTEX_CREATE();
+    }
+}
+
+int AmbaTUNE_Init(void)
+{
+    int Ret = 0;
+    _AmbaTUNE_Check_Mutex_Created();
+    OSAL_MUTEX_LOCK();
+    gTune_Hdlr.Parser_Status = TUNE_VALID;
+    Ret = gTune_Func[gTune_Hdlr.Active_Parser_Mode]->Init();
+    OSAL_MUTEX_UNLOCK();
+    return Ret;
+}
+
+void AmbaTUNE_Change_Parser_Mode(TuneHdlr_Mode_e Parser_Mode)
+{
+    _AmbaTUNE_Check_Mutex_Created();
+    OSAL_MUTEX_LOCK();
+    do {
+        if (gTune_Hdlr.Active_Parser_Mode == Parser_Mode) {
+            MNG_DEBF("%s() %d, Active Parser = %d Do not need to change parser mode", __func__, __LINE__, gTune_Hdlr.Active_Parser_Mode);
+            break;
+        }
+	gTune_Hdlr.Active_Parser_Mode = Parser_Mode;
+        gTune_Hdlr.Parser_Status = TUNE_INVALID;
+    } while (0);
+    OSAL_MUTEX_UNLOCK();
+
+}
+int AmbaTUNE_Save_IDSP(amba_img_dsp_mode_cfg_t Mode, char *Filepath)
+{
+    int Ret = 0;
+    _AmbaTUNE_Check_Mutex_Created();
+    OSAL_MUTEX_LOCK();
+    do {
+        if (gTune_Hdlr.Parser_Status == TUNE_INVALID) {
+            MNG_WARF("%s() %d, Parser_Status Invalid", __func__, __LINE__);
+            Ret = -1;
+            break;
+        }
+        Ret = gTune_Func[gTune_Hdlr.Active_Parser_Mode]->Save_IDSP(Mode, Filepath);
+    } while (0);
+    OSAL_MUTEX_UNLOCK();
+    return Ret;
+}
+int AmbaTUNE_load_ituner_stream(char *ituner_stream)
+{
+    int Ret = 0;
+    _AmbaTUNE_Check_Mutex_Created();
+    OSAL_MUTEX_LOCK();
+    do {
+        if (gTune_Hdlr.Parser_Status == TUNE_INVALID) {
+            MNG_WARF("%s() %d, Parser_Status Invalid", __func__, __LINE__);
+            Ret = -1;
+            break;
+        }
+        Ret = gTune_Func[gTune_Hdlr.Active_Parser_Mode]->get_ituner_stream(ituner_stream);
+    } while (0);
+    OSAL_MUTEX_UNLOCK();
+    return Ret;
+}
+
+int AmbaTUNE_Load_IDSP(char *Filepath)
+{
+    int Ret = 0;
+    _AmbaTUNE_Check_Mutex_Created();
+    OSAL_MUTEX_LOCK();
+    do {
+        if (gTune_Hdlr.Parser_Status == TUNE_INVALID) {
+            MNG_WARF("%s() %d, Parser_Status Invalid", __func__, __LINE__);
+            Ret = -1;
+            break;
+        }
+        Ret = gTune_Func[gTune_Hdlr.Active_Parser_Mode]->Load_IDSP(Filepath);
+    } while (0);
+    OSAL_MUTEX_UNLOCK();
+    return Ret;
+}
+int AmbaTUNE_apply_ituner_stream(u8* ituner_stream,int size)
+{
+    int Ret = 0;
+    _AmbaTUNE_Check_Mutex_Created();
+    OSAL_MUTEX_LOCK();
+    do {
+        if (gTune_Hdlr.Parser_Status == TUNE_INVALID) {
+            MNG_WARF("%s() %d, Parser_Status Invalid", __func__, __LINE__);
+            Ret = -1;
+            break;
+        }
+        Ret = gTune_Func[gTune_Hdlr.Active_Parser_Mode]->set_ituner_stream(ituner_stream,size);
+    } while (0);
+    OSAL_MUTEX_UNLOCK();
+    return Ret;
+}
+
+int AmbaTUNE_Save_Data(Ituner_Ext_File_Type_e Ext_File_Type, Ituner_Ext_File_Param_s *Ext_File_Param)
+{
+    int Ret = 0;
+    _AmbaTUNE_Check_Mutex_Created();
+    OSAL_MUTEX_LOCK();
+    do {
+        if (gTune_Hdlr.Parser_Status == TUNE_INVALID) {
+            MNG_WARF("%s() %d, Parser_Status Invalid", __func__, __LINE__);
+            Ret = -1;
+            break;
+        }
+        Ret = gTune_Func[gTune_Hdlr.Active_Parser_Mode]->Save_Data(Ext_File_Type, Ext_File_Param);
+    } while (0);
+    OSAL_MUTEX_UNLOCK();
+    return Ret;
+}
+
+int AmbaTUNE_Load_Data(Ituner_Ext_File_Type_e Ext_File_Type, Ituner_Ext_File_Param_s *Ext_File_Param)
+{
+    int Ret = 0;
+    _AmbaTUNE_Check_Mutex_Created();
+    OSAL_MUTEX_LOCK();
+    do {
+        if (gTune_Hdlr.Parser_Status == TUNE_INVALID) {
+            MNG_WARF("%s() %d, Parser_Status Invalid", __func__, __LINE__);
+            Ret = -1;
+            break;
+        }
+        Ret = gTune_Func[gTune_Hdlr.Active_Parser_Mode]->Load_Data(Ext_File_Type, Ext_File_Param);
+    } while(0);
+    OSAL_MUTEX_UNLOCK();
+    return Ret;
+}
+
+int AmbaTUNE_Execute_IDSP(int fd_iav, amba_img_dsp_mode_cfg_t Mode, AMBA_ITUNER_PROC_INFO_s *ProcInfo)
+{
+    int Ret = 0;
+    _AmbaTUNE_Check_Mutex_Created();
+    OSAL_MUTEX_LOCK();
+    do {
+        if (gTune_Hdlr.Parser_Status == TUNE_INVALID) {
+            MNG_WARF("%s() %d, Parser_Status Invalid", __func__, __LINE__);
+            Ret = -1;
+            break;
+        }
+        Ret = gTune_Func[gTune_Hdlr.Active_Parser_Mode]->Execute_IDSP(fd_iav, Mode, ProcInfo);
+    } while(0);
+    OSAL_MUTEX_UNLOCK();
+    return Ret;
+}
+
+int AmbaTUNE_Get_SystemInfo(ITUNER_SYSTEM_s *System)
+{
+    int Ret = 0;
+    _AmbaTUNE_Check_Mutex_Created();
+    OSAL_MUTEX_LOCK();
+    do {
+        if (gTune_Hdlr.Parser_Status == TUNE_INVALID) {
+            MNG_WARF("%s() %d, Parser_Status Invalid", __func__, __LINE__);
+            Ret = -1;
+            break;
+        }
+        Ret = gTune_Func[gTune_Hdlr.Active_Parser_Mode]->Get_SystemInfo(System);
+    } while(0);
+    OSAL_MUTEX_UNLOCK();
+    return Ret;
+}
+
+int AmbaTUNE_Set_SystemInfo(ITUNER_SYSTEM_s *System)
+{
+    int Ret = 0;
+    _AmbaTUNE_Check_Mutex_Created();
+    OSAL_MUTEX_LOCK();
+    do {
+        if (gTune_Hdlr.Parser_Status == TUNE_INVALID) {
+            MNG_WARF("%s() %d, Parser_Status Invalid", __func__, __LINE__);
+            Ret = -1;
+            break;
+        }
+        Ret = gTune_Func[gTune_Hdlr.Active_Parser_Mode]->Set_SystemInfo(System);
+    } while (0);
+    OSAL_MUTEX_UNLOCK();
+    return Ret;
+}
+
+int AmbaTUNE_Get_ItunerInfo(ITUNER_INFO_s *ItunerInfo)
+{
+    int Ret = 0;
+    _AmbaTUNE_Check_Mutex_Created();
+    OSAL_MUTEX_LOCK();
+    do {
+        if (gTune_Hdlr.Parser_Status == TUNE_INVALID) {
+            MNG_WARF("%s() %d, Parser_Status Invalid", __func__, __LINE__);
+            Ret = -1;
+            break;
+        }
+        Ret = gTune_Func[gTune_Hdlr.Active_Parser_Mode]->Get_ItunerInfo(ItunerInfo);
+    } while (0);
+    OSAL_MUTEX_UNLOCK();
+    return Ret;
+}
diff --git a/idsp_test/arch_s2l/AmbaTUNE_HdlrManager.h b/idsp_test/arch_s2l/AmbaTUNE_HdlrManager.h
new file mode 100644
index 0000000..aa89e2c
--- /dev/null
+++ b/idsp_test/arch_s2l/AmbaTUNE_HdlrManager.h
@@ -0,0 +1,60 @@
+/*
+ *
+ * idsp_test
+ *
+ * History:
+ *	2013/09/05 - [Dylan] Created this file
+ *
+ * Description :
+ *	Load the tuned file which generated by Img tuning tool.
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef _AMBA_TUNE_HDLR_MANAGER_H_
+#define _AMBA_TUNE_HDLR_MANAGER_H_
+
+#include "AmbaImgCalibItuner.h" // Note: Ituner_Ext_File_Type_e Need
+
+typedef enum {
+    TEXT_TUNE = 0,
+    USB_TUNE,
+    MAX_TUNE,
+} TuneHdlr_Mode_e;
+
+int AmbaTUNE_Init(void);
+void AmbaTUNE_Change_Parser_Mode(TuneHdlr_Mode_e Parser_Mode);
+int AmbaTUNE_Save_IDSP(amba_img_dsp_mode_cfg_t Mode, char *Filepath);
+int AmbaTUNE_Load_IDSP(char *Filepath);
+int AmbaTUNE_Save_Data(Ituner_Ext_File_Type_e Ext_File_Type, Ituner_Ext_File_Param_s *Ext_File_Param);
+int AmbaTUNE_Load_Data(Ituner_Ext_File_Type_e Ext_File_Type, Ituner_Ext_File_Param_s *Ext_File_Param);
+int AmbaTUNE_Execute_IDSP(int fd_iav, amba_img_dsp_mode_cfg_t Mode, AMBA_ITUNER_PROC_INFO_s *ProcInfo);
+int AmbaTUNE_Get_SystemInfo(ITUNER_SYSTEM_s *System);
+int AmbaTUNE_Set_SystemInfo(ITUNER_SYSTEM_s *System);
+int AmbaTUNE_Get_ItunerInfo(ITUNER_INFO_s *ItunerInfo);
+int AmbaTUNE_apply_ituner_stream(u8* ituner_stream,int size);
+int AmbaTUNE_load_ituner_stream(char *ituner_stream);
+#endif /* _AMBA_TUNE_HDLR_MANAGER_H_ */
diff --git a/idsp_test/arch_s2l/AmbaTUNE_Parser.c b/idsp_test/arch_s2l/AmbaTUNE_Parser.c
new file mode 100644
index 0000000..df644f5
--- /dev/null
+++ b/idsp_test/arch_s2l/AmbaTUNE_Parser.c
@@ -0,0 +1,521 @@
+/*
+ *
+ * idsp_test
+ *
+ * History:
+ *	2013/09/05 - [Dylan] Created this file
+ *
+ * Description :
+ *	Load the tuned file which generated by Img tuning tool.
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include "AmbaTUNE_Parser.h"
+#include "stdio.h" // sprintf need
+#include "string.h"
+#include "stdlib.h"
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+//#include "AmbaPrint.h"
+
+#define AmbaPrint(format, arg...)	printf(format"\n", ##arg)
+#define PASER_DEBF(fmt, arg...) AmbaPrint("[PASER][DEBUG]"fmt, ##arg)
+#define PASER_WARF(fmt, arg...) AmbaPrint("[PASER][WARNING]"fmt, ##arg)
+#define PASER_ERRF(fmt, arg...) AmbaPrint("[PASER][ERROR]"fmt, ##arg)
+
+#define MAX_REGS (200)
+#ifndef NULL
+    #define NULL                  ((void*)0)
+#endif
+
+static REG_s* _Reg_List[MAX_REGS];
+static char LineBuf[MAX_LINE_CHARS];
+static TUNE_Parser_Object_t Parser_Object[1];
+static OpMode_e gOpMode;
+typedef void (*pfunc_conv_t)(int, void*, void*);
+
+static void _str_to_str(int N, void *Src, void *Dst);
+static void _str_to_u8(int N, void *Src, void *Dst);
+static void _str_to_s8(int N, void *Src, void *Dst);
+static void _str_to_u16(int N, void *Src, void *Dst);
+static void _str_to_s16(int N, void *Src, void *Dst);
+static void _str_to_u32(int N, void *Src, void *Dst);
+static void _str_to_s32(int N, void *Src, void *Dst);
+static void _u8_to_str(int N, void *Src, void *Dst);
+static void _s8_to_str(int N, void *Src, void *Dst);
+static void _u16_to_str(int N, void *Src, void *Dst);
+static void _s16_to_str(int N, void *Src, void *Dst);
+static void _u32_to_str(int N, void *Src, void *Dst);
+static void _s32_to_str(int N, void *Src, void *Dst);
+
+static const pfunc_conv_t _strconvs[TYPE_MAX] = {
+    _str_to_str,
+    _str_to_str,
+    _str_to_u8,
+    _str_to_s8,
+    _str_to_u16,
+    _str_to_s16,
+    _str_to_u32,
+    _str_to_s32,
+};
+
+static const pfunc_conv_t _convstrs[TYPE_MAX] = {
+    _str_to_str,
+    _str_to_str,
+    _u8_to_str,
+    _s8_to_str,
+    _u16_to_str,
+    _s16_to_str,
+    _u32_to_str,
+    _s32_to_str,
+};
+
+void TUNE_Parser_Enc_Proc(PARAM_s* pParam, void* pField) {
+    _convstrs[pParam->ValType](pParam->ValCount, pField, pParam->ValStr);
+}
+
+void TUNE_Parser_Dec_Proc(PARAM_s* pParam, void* pField) {
+    _strconvs[pParam->ValType](pParam->ValCount, pParam->ValStr, pField);
+}
+
+/* string conversion functions */
+
+static void _str_to_str(int N, void *Src, void *Dst)
+{
+    strcpy((char*)Dst, (char*)Src);
+}
+
+static void _str_to_u8(int N, void *Src, void *Dst)
+{
+    int i = 0;
+    UINT8 *pU8 = (UINT8*)Dst, Value = 0;
+    char *pStr = (char*)Src, *Token = 0, Seps[] = " \t";
+    Token = strtok(pStr, Seps);
+    while(Token && i<N) {
+        Value = atoi(Token);
+        memcpy(pU8+i, &Value, sizeof(UINT8));
+        Token = strtok(0, Seps); i++;
+    }
+}
+static void _str_to_s8(int N, void *Src, void *Dst)
+{
+    int i = 0;
+    INT8 *pS8 = (INT8*)Dst, Value = 0;
+    char *pStr = (char*)Src, *Token = 0, Seps[] = " \t";
+    Token = strtok(pStr, Seps);
+    while(Token && i<N) {
+        Value = atoi(Token);
+        memcpy(pS8+i, &Value, sizeof(INT8));
+        Token = strtok(0, Seps); i++;
+    }
+}
+static void _str_to_u16(int N, void *Src, void *Dst)
+{
+    int i = 0;
+    UINT16 *pU16 = (UINT16*)Dst, Value = 0;
+    char *pStr = (char*)Src, *Token = 0, Seps[] = " \t";
+    Token = strtok(pStr, Seps);
+    while(Token && i<N) {
+        Value = atoi(Token);
+        memcpy(pU16+i, &Value, sizeof(UINT16));
+        Token = strtok(0, Seps); i++;
+    }
+}
+static void _str_to_s16(int N, void *Src, void *Dst)
+{
+    int i = 0;
+    INT16 *pS16 = (INT16*)Dst, Value = 0;
+    char *pStr = (char*)Src, *Token = 0, Seps[] = " \t";
+    Token = strtok(pStr, Seps);
+    while(Token && i<N) {
+        Value = atoi(Token);
+        memcpy(pS16+i, &Value, sizeof(INT16));
+        Token = strtok(0, Seps); i++;
+    }
+}
+static void _str_to_u32(int N, void *Src, void *Dst)
+{
+    int i = 0;
+    UINT32 *pU32 = (UINT32*)Dst, Value = 0;
+    char *pStr = (char*)Src, *Token = 0, Seps[] = " \t";
+    Token = strtok(pStr, Seps);
+    while(Token && i<N) {
+        Value = atoi(Token);
+        memcpy(pU32+i, &Value, sizeof(UINT32));
+        Token = strtok(0, Seps); i++;
+    }
+}
+static void _str_to_s32(int N, void *Src, void *Dst)
+{
+    int i = 0;
+    INT32 *pS32 = (INT32*)Dst, Value = 0;
+    char *pStr = (char*)Src, *Token = 0, Seps[] = " \t";
+    Token = strtok(pStr, Seps);
+    while(Token && i<N) {
+        Value = atoi(Token);
+        memcpy(pS32+i, &Value, sizeof(INT32));
+        Token = strtok(0, Seps); i++;
+    }
+}
+static void _u8_to_str(int N, void *Src, void *Dst)
+{
+    int i = 0;
+    char *pStr = (char*)Dst, OneStr[16];
+    UINT8  *pU8 = (UINT8 *)Src, Value = 0;
+    memcpy(&Value, pU8+i, sizeof(UINT8 ));
+    sprintf(OneStr, "%d", Value);
+    strcpy(pStr, OneStr);
+    for(i=1; i<N; i++) {
+        memcpy(&Value, pU8+i, sizeof(UINT8 ));
+        sprintf(OneStr, " %d", Value);
+        strcat(pStr, OneStr);
+    }
+}
+static void _s8_to_str(int N, void *Src, void *Dst)
+{
+    int i = 0;
+    char *pStr = (char*)Dst, OneStr[16];
+    INT8  *pS8 = (INT8 *)Src, Value = 0;
+    memcpy(&Value, pS8+i, sizeof(INT8 ));
+    sprintf(OneStr, "%d", Value);
+    strcpy(pStr, OneStr);
+    for(i=1; i<N; i++) {
+        memcpy(&Value, pS8+i, sizeof(INT8 ));
+        sprintf(OneStr, " %d", Value);
+        strcat(pStr, OneStr);
+    }
+}
+static void _u16_to_str(int N, void *Src, void *Dst)
+{
+    int i = 0;
+    char *pStr = (char*)Dst, OneStr[16];
+    UINT16 *pU16 = (UINT16*)Src, Value = 0;
+    memcpy(&Value, pU16+i, sizeof(UINT16));
+    sprintf(OneStr, "%d", Value);
+    strcpy(pStr, OneStr);
+    for(i=1; i<N; i++) {
+        memcpy(&Value, pU16+i, sizeof(UINT16));
+        sprintf(OneStr, " %d", Value);
+        strcat(pStr, OneStr);
+    }
+}
+static void _s16_to_str(int N, void *Src, void *Dst)
+{
+    int i = 0;
+    char *pStr = (char*)Dst, OneStr[16];
+    INT16 *pS16 = (INT16*)Src, Value = 0;
+    memcpy(&Value, pS16+i, sizeof(INT16));
+    sprintf(OneStr, "%d", Value);
+    strcpy(pStr, OneStr);
+    for(i=1; i<N; i++) {
+        memcpy(&Value, pS16+i, sizeof(INT16));
+        sprintf(OneStr, " %d", Value);
+        strcat(pStr, OneStr);
+    }
+}
+static void _u32_to_str(int N, void *Src, void *Dst)
+{
+    int i = 0;
+    char *pStr = (char*)Dst, OneStr[16];
+    UINT32 *pU32 = (UINT32*)Src, Value = 0;
+    memcpy(&Value, pU32+i, sizeof(UINT32));
+    sprintf(OneStr, "%d", Value);
+    strcpy(pStr, OneStr);
+    for(i=1; i<N; i++) {
+        memcpy(&Value, pU32+i, sizeof(UINT32));
+        sprintf(OneStr, " %d", Value);
+        strcat(pStr, OneStr);
+    }
+}
+static void _s32_to_str(int N, void *Src, void *Dst)
+{
+    int i = 0;
+    char *pStr = (char*)Dst, OneStr[16];
+    INT32 *pS32 = (INT32*)Src, Value = 0;
+    memcpy(&Value, pS32+i, sizeof(INT32));
+    sprintf(OneStr, "%d", Value);
+    strcpy(pStr, OneStr);
+    for(i=1; i<N; i++) {
+        memcpy(&Value, pS32+i, sizeof(INT32));
+        sprintf(OneStr, " %d", Value);
+        strcat(pStr, OneStr);
+    }
+}
+
+int TUNE_Parser_Create(TUNE_Parser_Object_t** Object)
+{
+    if (Object == NULL) {
+        PASER_ERRF("%s() %d, Object = NULL", __func__, __LINE__);
+        return -1;
+    }
+    int i = 0;
+    for (i = MAX_REGS-1; i >= 0; i--) {
+        _Reg_List[i] = NULL;
+    }
+    Parser_Object[0].RegList = _Reg_List;
+    Parser_Object[0].RegCount = 0;
+    Parser_Object[0].LineBuf = LineBuf;
+    Parser_Object[0].BufSize = MAX_LINE_CHARS;
+    *Object = &Parser_Object[0];
+    return 0;
+}
+
+int TUNE_Parser_Destory(TUNE_Parser_Object_t* Object)
+{
+    if (Object == NULL) {
+        PASER_ERRF("%s() %d, Object = NULL", __func__, __LINE__);
+        return -1;
+    }
+    Object->RegList = NULL;
+    Object->RegCount = 0;
+    Object->LineBuf = NULL;
+    Object->BufSize = 0;
+    return 0;
+}
+
+int TUNE_Parser_Add_Reg(REG_s *pReg, TUNE_Parser_Object_t* Object)
+{
+    int Ret = -1;
+    if (Object->RegCount < MAX_REGS) {
+        Object->RegList[Object->RegCount] = pReg;
+        Ret = Object->RegCount;
+        Object->RegCount++;
+    } else {
+        PASER_WARF("%s() %d, Exceed maximum REG number", __func__, __LINE__);
+    }
+    return Ret;
+}
+
+int TUNE_Parser_Set_Reglist_Valid(INT64 Valid, TUNE_Parser_Object_t* Object) {
+    if ((Object == NULL) || (Object->RegList == NULL) || (Object->RegCount <= 0)) {
+        PASER_ERRF("%s() %d, invalid Object", __func__, __LINE__);
+        return -1;
+    }
+    int i;
+    for( i = Object->RegCount - 1; i >= 0; i--) {
+        Object->RegList[i]->Valid = Valid;
+    }
+    return 0;
+}
+
+int TUNER_Parser_Set_Reg_Valid(const char* Name, INT64 Valid, TUNE_Parser_Object_t* Object) {
+    if (Object == NULL) {
+        PASER_ERRF("%s() %d, Object = NULL", __func__, __LINE__);
+        return -1;
+    }
+    REG_s* Reg = TUNE_Parser_Lookup_Reg(Name, Object);
+    if (Reg == NULL) {
+        PASER_WARF("%s() %d, %s Not Exist", __func__, __LINE__, Name);
+        return -1;
+    }
+    Reg->Valid = Valid;
+    return 0;
+}
+REG_s* TUNE_Parser_Get_Reg(int RegIdx, TUNE_Parser_Object_t* Object) {
+    if (Object == NULL) {
+        PASER_ERRF("%s() %d, Object = NULL", __func__, __LINE__);
+        return NULL;
+    }
+    if (RegIdx >= Object->RegCount) {
+        PASER_WARF("%s() %d, RegIdx %d > RegCount %d", __func__, __LINE__, RegIdx, Object->RegCount);
+        return NULL;
+    }
+    return Object->RegList[RegIdx];
+}
+PARAM_s* TUNE_Parser_Get_Param(REG_s* Reg, int ParamIdx) {
+    if (Reg == NULL) {
+        PASER_ERRF("%s() %d, Reg = NULL", __func__, __LINE__);
+        return NULL;
+    }
+    if (ParamIdx >= Reg->ParamCount) {
+        PASER_ERRF("%s() %d, Reg = NULL", __func__, __LINE__);
+        return NULL;
+    }
+    return &Reg->ParamList[ParamIdx];
+}
+REG_s* TUNE_Parser_Lookup_Reg(const char* Name, TUNE_Parser_Object_t* Object) {
+    if (Object == NULL) {
+        PASER_ERRF("%s() %d, Object = NULL", __func__, __LINE__);
+        return NULL;
+    }
+    REG_s *Ret = NULL;
+    int i;
+    for (i = Object->RegCount - 1; i >= 0; i--) {
+        if (strcmp(Name, Object->RegList[i]->Name) == 0) {
+            Ret = Object->RegList[i];
+            break;
+        }
+    }
+    if (Ret == NULL) {
+        PASER_WARF("%s() %d, Unknown REG: %s", __func__, __LINE__, Name);
+    }
+    return Ret;
+}
+
+PARAM_s* TUNE_Parser_Lookup_Param(const char* Name, REG_s* Reg) {
+    if (Reg == NULL) {
+        PASER_WARF("%s() %d, Reg = NULL", __func__, __LINE__);
+        return NULL;
+    }
+    PARAM_s *Ret = NULL;
+    int i;
+    for (i = Reg->ParamCount - 1; i >= 0; i--) {
+        if (strcmp(Name, Reg->ParamList[i].Name) == 0) {
+            Ret = &Reg->ParamList[i];
+            break;
+        }
+    }
+    if (Ret == NULL) {
+        PASER_WARF("%s() %d, Reg  %s Unknown Param %s", __func__, __LINE__, Reg->Name, Name);
+    }
+    return Ret;
+}
+
+static int _skip_line(const char* Linebuf)
+{
+    return ((*Linebuf == 0) || (*Linebuf == '#')) ? 1 : 0;
+}
+
+static int _split_param_value(char* ParamStr, char **Param, char **Val)
+{
+    unsigned int Pos = 0;
+    char Seps[] = " \t";
+    Pos = strcspn(ParamStr, Seps);
+    if (Pos == strlen(ParamStr)) return 0;
+    ParamStr[Pos] = 0;
+    *Param = ParamStr;
+    *Val = ParamStr + Pos + 1;
+    return 1;
+}
+static int _split_reg_param(char* Linebuf, char **Reg, char **Param)
+{
+    unsigned int Pos = 0;
+    char Seps[] = "[.";
+
+    Pos = strcspn(Linebuf, Seps);
+    if (Pos == strlen(Linebuf)) return 0;
+    Linebuf[Pos] = 0;
+    *Reg = Linebuf;
+    *Param = Linebuf + Pos + 1;
+    return 1;
+}
+
+int TUNE_Parser_Generate_Line(int RegIdx, int ParamIdx, TUNE_Parser_Object_t* Object)
+{
+    if (Object == NULL) {
+        PASER_ERRF("%s() %d, Object = NULL", __func__, __LINE__);
+        return -1;
+    }
+    REG_s* Reg = NULL;
+    PARAM_s* Param = NULL;
+    if (RegIdx >= Object->RegCount) {
+        PASER_WARF("%s() %d, RegIdx %d >= RegCount %d", __func__, __LINE__, RegIdx, Object->RegCount);
+        return -1;
+    }
+    Reg = Object->RegList[RegIdx];
+
+    if (ParamIdx >= Reg->ParamCount) {
+        PASER_WARF("%s() %d, ParamIdx %d >= ParamCount %d", __func__, __LINE__, ParamIdx, Reg->ParamCount);
+        return -1;
+    }
+    Param = &Reg->ParamList[ParamIdx];
+    // TODO: Avoid bufer overflow
+    strcpy(Object->LineBuf, Reg->Name);
+    strcat(Object->LineBuf, ".");
+    strcat(Object->LineBuf, Param->Name);
+    strcat(Object->LineBuf, " ");
+    Param->ValStr = Object->LineBuf + strlen(Object->LineBuf);
+    Reg->Process(ParamIdx, Param);
+    strcat(Object->LineBuf, "\n");
+    if (Reg->Valid & (0x1ULL << ParamIdx)) {
+        return 0;
+    } else {
+        return 1;
+    }
+}
+
+int TUNE_Parser_Get_LineBuf(TUNE_Parser_Object_t* Object, char** Line, int* Size)
+{
+    if (Object == NULL) {
+        PASER_ERRF("%s() %d, Object = NULL", __func__, __LINE__);
+        return -1;
+    }
+    if ((Object->LineBuf == NULL) || (Object->BufSize == 0)){
+        PASER_ERRF("%s() %d, LineBuf = %s, Size = %d", __func__, __LINE__, Object->LineBuf, Object->BufSize);
+        return -1;
+    }
+    *Line = Object->LineBuf;
+    *Size = Object->BufSize;
+    return 0;
+}
+
+int TUNE_Parser_Parse_Line(TUNE_Parser_Object_t* Object)
+{
+    char *RegStr = 0, *ParamValStr = 0, *ParamStr = 0, *ValStr = 0;
+    //char *RegIdStr = 0;
+    REG_s *pReg;
+    PARAM_s *pParam;
+    //int RegId = 0;
+    if (_skip_line(Object->LineBuf)) return 0;
+    if (_split_reg_param(Object->LineBuf, &RegStr, &ParamValStr)) {
+        pReg = TUNE_Parser_Lookup_Reg(RegStr, Object);
+        if (pReg == 0) return 0;
+        /* Check if multiple reg instances*/
+        if (pReg->RegNum > 1) {
+            PASER_ERRF("%s() %d, Not Implement!", __func__, __LINE__);
+            return -1;
+        }
+
+        if (_split_param_value(ParamValStr, &ParamStr, &ValStr)) {
+            pParam = TUNE_Parser_Lookup_Param(ParamStr, pReg);
+            if (pParam == 0) return 0;
+            pParam->ValStr = ValStr;
+            pReg->Valid |= (*pReg->Process)(pParam->Index, pParam);
+        }
+    }
+    return 0;
+}
+
+void TUNE_Parser_Param_Proc(PARAM_s *pParam, void* pField)
+{
+    if (gOpMode) {
+        TUNE_Parser_Dec_Proc(pParam, pField);
+    } else {
+        TUNE_Parser_Enc_Proc(pParam, pField);
+    }
+}
+
+void TUNE_Parser_Set_Opmode(OpMode_e OpMode)
+{
+    gOpMode = OpMode ;
+}
+
+OpMode_e TUNE_Parser_Get_Opmode(void)
+{
+    return gOpMode ;
+}
diff --git a/idsp_test/arch_s2l/AmbaTUNE_Parser.h b/idsp_test/arch_s2l/AmbaTUNE_Parser.h
new file mode 100644
index 0000000..f35ed09
--- /dev/null
+++ b/idsp_test/arch_s2l/AmbaTUNE_Parser.h
@@ -0,0 +1,103 @@
+/*
+ *
+ * idsp_test
+ *
+ * History:
+ *	2013/09/05 - [Dylan] Created this file
+ *
+ * Description :
+ *	Load the tuned file which generated by Img tuning tool.
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include "AmbaDataType.h"
+#define MAX_NAME_LENS       (128)
+#define MAX_LINE_CHARS (35000) // (27000)
+typedef enum {
+    EXT_PATH = 0,
+    STRING,
+    U_8,
+    S_8,
+    U_16,
+    S_16,
+    U_32,
+    S_32,
+    TYPE_MAX,
+} Param_Value_Type_e;
+
+typedef enum {
+    ITUNER_ENC = 0,
+    ITUNER_DEC,
+} OpMode_e;
+
+typedef struct _PARAM_s_ {
+    int     Index;
+    char    Name[MAX_NAME_LENS];
+    Param_Value_Type_e ValType;
+    UINT32  ValCount;
+    char*   ValStr;
+} PARAM_s;
+typedef INT64 (proc_t)(int, PARAM_s*);
+
+typedef struct _REG_s_ {
+    int      Index;
+    char     Name[MAX_NAME_LENS];
+    int      RegNum;        //!< Reserved
+    int      RegEntrySize; //!< Reserved
+    int      ParamCount;
+    INT64    Valid;
+    PARAM_s* ParamList;
+    proc_t*  Process;
+} REG_s;
+
+typedef struct {
+    REG_s** RegList;
+    int RegCount;
+    char* LineBuf;
+    int BufSize;
+}TUNE_Parser_Object_t;
+
+
+
+void TUNE_Parser_Enc_Proc(PARAM_s* pParam, void* pField);
+void TUNE_Parser_Dec_Proc(PARAM_s* pParam, void* pField);
+void TUNE_Parser_Param_Proc(PARAM_s *pParam, void* pField);
+void TUNE_Parser_Set_Opmode(OpMode_e OpMode);
+OpMode_e TUNE_Parser_Get_Opmode(void);
+int TUNE_Parser_Create(TUNE_Parser_Object_t** Object);
+int TUNE_Parser_Destory(TUNE_Parser_Object_t* Object);
+int TUNE_Parser_Add_Reg(REG_s *pReg, TUNE_Parser_Object_t* Object);
+int TUNE_Parser_Set_Reglist_Valid(INT64 Valid, TUNE_Parser_Object_t* Object);
+int TUNER_Parser_Set_Reg_Valid(const char* Name, INT64 Valid, TUNE_Parser_Object_t* Object);
+REG_s* TUNE_Parser_Lookup_Reg(const char* Name, TUNE_Parser_Object_t* Object);
+PARAM_s* TUNE_Parser_Lookup_Param(const char* Name, REG_s* Reg);
+int TUNE_Parser_Get_LineBuf(TUNE_Parser_Object_t* Object, char** Line, int* Size);
+int TUNE_Parser_Parse_Line(TUNE_Parser_Object_t* Object);
+REG_s* TUNE_Parser_Get_Reg( int RegIdx, TUNE_Parser_Object_t* Object);
+PARAM_s* TUNE_Parser_Get_Param(REG_s* Reg, int ParamIdx);
+int TUNE_Parser_Generate_Line(int RegIdx, int ParamIdx, TUNE_Parser_Object_t* Object);
+
diff --git a/idsp_test/arch_s2l/AmbaTUNE_Rule.c b/idsp_test/arch_s2l/AmbaTUNE_Rule.c
new file mode 100644
index 0000000..dd681b1
--- /dev/null
+++ b/idsp_test/arch_s2l/AmbaTUNE_Rule.c
@@ -0,0 +1,3359 @@
+/*
+ *
+ * idsp_test
+ *
+ * History:
+ *	2013/09/05 - [Dylan] Created this file
+ *
+ * Description :
+ *	Load the tuned file which generated by Img tuning tool.
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <stdio.h> // sprintf need
+#include <string.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+//#include "AmbaTUNE_TextHdlr.h"
+//#include "AmbaPrintk.h"
+#include "AmbaImgCalibItuner.h" //Note: ITUNER_SYSTEM_s need
+
+#include "AmbaDSP_ImgDef.h" // Note: AMBA_DSP_IMG_PIPE_VIDEO need
+//#include "AmbaDSP.h" // Note: AMBA_DSP_VIDEO_FILTER need
+#include "AmbaDSP_ImgFilter.h" // Note: AMBA_DSP_IMG_NUM_EXPOSURE_CURVE need
+#include "AmbaDSP_Img3aStatistics.h" // Note: AMBA_DSP_IMG_AE_STAT_INFO_s need
+#include "stdio.h" // sprintf need
+//#include "AmbaKAL.h"
+//#include "AmbaCardManager.h"// Note: AmbaSCM_GetSlotStatus need
+//#include "AmbaUtility.h"// Note: AmbaUtility_Slot2Drive need
+#include "AmbaTUNE_Parser.h"
+#include "AmbaTUNE_Rule.h"
+//#include "AmbaFS.h" //Note: AMBA_FS_FILE  need
+#include <wchar.h>
+#define AmbaPrint(format, arg...)	printf(format"\n", ##arg)
+
+#define RULE_DEBF(fmt, arg...) AmbaPrint("[TUNE RULE][DEBUG]"fmt, ##arg)
+#define RULE_WARF(fmt, arg...) AmbaPrint("[TUNE RULE][WARNING]"fmt, ##arg)
+#define RULE_ERRF(fmt, arg...) AmbaPrint("[TUNE RULE][ERROR]"fmt, ##arg)
+
+#define GET_ARRAY_NUM(array_name) (sizeof(array_name) / sizeof(array_name[0]))
+
+static INT64 _System_Proc(int Index, PARAM_s *pParam);
+static INT64 _Internal_Proc(int Index, PARAM_s *pParam);
+static INT64 _AaaFunctionProc(int Index, PARAM_s *pParam);
+static INT64 _AeInfoProc(int Index, PARAM_s *pParam);
+static INT64 _AeStatisticsInfoProc(int Index, PARAM_s *pParam);
+static INT64 _AwbStatisticsInfoProc(int Index, PARAM_s *pParam);
+static INT64 _AfStatisticsInfoProc(int Index, PARAM_s *pParam);
+static INT64 _StaticBadPixelCorrectionProc(int Index, PARAM_s *pParam);
+static INT64 _StaticBadPixelCorrectionByPassProc(int Index, PARAM_s *pParam);
+static INT64 _VignetteCompensationProc(int Index, PARAM_s *pParam);
+static INT64 _VignetteCompensationByPassProc(int Index, PARAM_s *pParam);
+static INT64 _WarpCompensationProc(int Index, PARAM_s *pParam);
+static INT64 _DzoomProc(int Index, PARAM_s *pParam);
+static INT64 _WarpCompensationDzoomByPassProc(int Index, PARAM_s *pParam);
+static INT64 _SensorInputProc(int Index, PARAM_s *pParam);
+static INT64 _StaticBlackLevelProc(int Index, PARAM_s *pParam);
+static INT64 _DeferredBlackLevelProc(int Index, PARAM_s *pParam);
+static INT64 _DynamicBadPixelCorrectionProc(int Index, PARAM_s *pParam);
+static INT64 _HighIsoDynamicBadPixelCorrectionProc(int Index, PARAM_s *pParam);
+static INT64 _CfaLeakageFilterProc(int Index, PARAM_s *pParam);
+static INT64 _HighIsoCfaLeakageFilterProc(int Index, PARAM_s *pParam);
+static INT64 _CfaNoiseFilterProc(int Index, PARAM_s *pParam);
+static INT64 _HighIsoCfaNoiseFilterProc(int Index, PARAM_s *pParam);
+static INT64 _AntiAliasingProc(int Index, PARAM_s *pParam);
+static INT64 _HighIsoAntiAliasingProc(int Index, PARAM_s *pParam);
+static INT64 _GlobalDgainProc(int Index, PARAM_s *pParam);
+static INT64 _WbGainProc(int Index, PARAM_s *pParam);
+static INT64 _DgainSaturationLevelProc(int Index, PARAM_s *pParam);
+static INT64 _LocalExposureProc(int Index, PARAM_s *pParam);
+static INT64 _ColorCorrectionProc(int Index, PARAM_s *pParam);
+static INT64 _ToneCurveProc(int Index, PARAM_s *pParam);
+static INT64 _RgbToYuvMatrixProc(int Index, PARAM_s *pParam);
+static INT64 _ChromaScaleProc(int Index, PARAM_s *pParam);
+static INT64 _ChromaMedianFilterProc(int Index, PARAM_s *pParam);
+static INT64 _HighIsoChromaMedianFilterProc(int Index, PARAM_s *pParam);
+static INT64 _DemosaicFilterProc(int Index, PARAM_s *pParam);
+static INT64 _HighIsoDemosaicFilterProc(int Index, PARAM_s *pParam);
+static INT64 _SharpenBothProc(int Index, PARAM_s *pParam);
+static INT64 _FinalSharpenBothProc(int Index, PARAM_s *pParam);
+static INT64 _HisoHighSharpenBothProc(int Index, PARAM_s *pParam);
+static INT64 _HisoMedSharpenBothProc(int Index, PARAM_s *pParam);
+static INT64 _SharpenNoiseProc(int Index, PARAM_s *pParam);
+static INT64 _FinalSharpenNoiseProc(int Index, PARAM_s *pParam);
+static INT64 _HisoHighSharpenNoiseProc(int Index, PARAM_s *pParam);
+static INT64 _HisoMedSharpenNoiseProc(int Index, PARAM_s *pParam);
+static INT64 _SharpenFirProc(int Index, PARAM_s *pParam);
+static INT64 _FinalSharpenFirProc(int Index, PARAM_s *pParam);
+static INT64 _HisoHighFirProc(int Index, PARAM_s *pParam);
+static INT64 _HisoMedFirProc(int Index, PARAM_s *pParam);
+static INT64 _SharpenCoringProc(int Index, PARAM_s *pParam);
+static INT64 _FinalSharpenCoringProc(int Index, PARAM_s *pParam);
+static INT64 _HisoHighCoringProc(int Index, PARAM_s *pParam);
+static INT64 _HisoMedCoringProc(int Index, PARAM_s *pParam);
+static INT64 _CoringIndexScaleProc(int Index, PARAM_s *pParam);
+static INT64 _MinCoringResultProc(int Index, PARAM_s *pParam);
+static INT64 _ScaleCoringProc(int Index, PARAM_s *pParam);
+static INT64 _FinalCoringIndexScaleProc(int Index, PARAM_s *pParam);
+static INT64 _FinalMinCoringResultProc(int Index, PARAM_s *pParam);
+static INT64 _FinalScaleCoringProc(int Index, PARAM_s *pParam);
+static INT64 _HisoHighCoringIndexScaleProc(int Index, PARAM_s *pParam);
+static INT64 _HisoHighMinCoringResultProc(int Index, PARAM_s *pParam);
+static INT64 _HisoHighScaleCoringProc(int Index, PARAM_s *pParam);
+static INT64 _HisoMedCoringIndexScaleProc(int Index, PARAM_s *pParam);
+static INT64 _HisoMedMinCoringResultProc(int Index, PARAM_s *pParam);
+static INT64 _HisoMedScaleCoringProc(int Index, PARAM_s *pParam);
+static INT64 _VideoMctfProc(int Index, PARAM_s *pParam);
+static INT64 _VideoMctfTemporalAdjustProc(int Index, PARAM_s *pParam);
+static INT64 _ColorDependentNoiseReductionProc(int Index, PARAM_s *pParam);
+static INT64 _DeferredColorCorrectionProc(int Index, PARAM_s *pParam);
+static INT64 _ShpAOrSpatialFilterSelectproc(int Index, PARAM_s *pParam);
+static INT64 _AdvanceSpatialFilterProc(int Index, PARAM_s *pParam);
+static INT64 _HisoAsfProc(int Index, PARAM_s *pParam);
+static INT64 _HisoHighAsfProc(int Index, PARAM_s *pParam);
+static INT64 _HisoLowAsfProc(int Index, PARAM_s *pParam);
+static INT64 _HisoMedAsfProc(int Index, PARAM_s *pParam);
+static INT64 _HisoChromaAsfProc(int Index, PARAM_s *pParam);
+static INT64 _ChromaFilterProc(int Index, PARAM_s *pParam);
+static INT64 _WideChromaFilterProc(int Index, PARAM_s *pParam);
+static INT64 _WideChromaFilterCombineProc(int Index, PARAM_s *pParam);
+static INT64 _HisoChromaFilterHighProc(int Index, PARAM_s *pParam);
+static INT64 _GbGrMismatchProc(int Index, PARAM_s *pParam);
+static INT64 _HisoGbGrMismatchProc(int Index, PARAM_s *pParam);
+static INT64 _ChromaAberrationProc(int Index, PARAM_s *pParam);
+static INT64 _ChromaAberrationByPassProc(int Index, PARAM_s *pParam);
+static INT64 _ChromaFilterLowAndVeryLowProc(int Index, PARAM_s *pParam);
+static INT64 _HisoChromaFilterProc(int Index, PARAM_s *pParam);
+static INT64 _HisoChromaFilterMedProc(int Index, PARAM_s *pParam);
+static INT64 _HisoChromaFilterLowProc(int Index, PARAM_s *pParam);
+static INT64 _HisoChromaFilterVeryLowProc(int Index, PARAM_s *pParam);
+static INT64 _HisoChromaFilterVeryLowCombineProc(int Index, PARAM_s *pParam);
+static INT64 _HisoChromaFilterMedCombineProc(int Index, PARAM_s *pParam);
+static INT64 _HisoChromaFilterLowCombineProc(int Index, PARAM_s *pParam);
+static INT64 _HisoLumaFilterCombineProc(int Index, PARAM_s *pParam);
+static INT64 _HisoLowASFCombineProc(int Index, PARAM_s *pParam);
+static INT64 _HisoFreqRecoverProc(int Index, PARAM_s *pParam);
+static INT64 _MoDynamicBadPixelCorrectionProc(int Index, PARAM_s *pParam);
+static INT64 _MoCfaLeakageFilterProc(int Index, PARAM_s *pParam);
+static INT64 _MoCfaNoiseFilterProc(int Index, PARAM_s *pParam);
+static INT64 _MoAntiAliasingProc(int Index, PARAM_s *pParam);
+static INT64 _MoDemosaicFilterProc(int Index, PARAM_s *pParam);
+static INT64 _MoGbGrMismatchProc(int Index, PARAM_s *pParam);
+static INT64 _MoShpAOrSpatialFilterSelectproc(int Index, PARAM_s *pParam);
+static INT64 _MoAdvanceSpatialFilterProc(int Index, PARAM_s *pParam);
+static INT64 _MoChromaFilterProc(int Index, PARAM_s *pParam);
+static INT64 _MoChromaMedianFilterProc(int Index, PARAM_s *pParam);
+static INT64 _MoSharpenBothProc(int Index, PARAM_s *pParam);
+static INT64 _MoSharpenNoiseProc(int Index, PARAM_s *pParam);
+static INT64 _MoSharpenFirProc(int Index, PARAM_s *pParam);
+static INT64 _MoSharpenCoringProc(int Index, PARAM_s *pParam);
+static INT64 _MoCoringIndexScaleProc(int Index, PARAM_s *pParam);
+static INT64 _MoMinCoringResultProc(int Index, PARAM_s *pParam);
+static INT64 _MoScaleCoringProc(int Index, PARAM_s *pParam);
+
+
+static const char _str_tuning_mode[IMG_MODE_NUMBER][32] = {
+    TUING_MODE_TO_STR(IMG_MODE_VIDEO),
+    TUING_MODE_TO_STR(IMG_MODE_STILL),
+    TUING_MODE_TO_STR(IMG_MODE_LOW_ISO_STILL),
+    TUING_MODE_TO_STR(IMG_MODE_MID_ISO_STILL),
+    TUING_MODE_TO_STR(IMG_MODE_HIGH_ISO_STILL),
+    TUING_MODE_TO_STR(IMG_MODE_NIGHT_PORTRAIT_STILL),
+    TUING_MODE_TO_STR(IMG_MODE_PREVIEW),
+    TUING_MODE_TO_STR(IMG_MODE_HIGH_ISO_PREVIEW),
+    TUING_MODE_TO_STR(IMG_MODE_HIGH_ISO_VIDEO),
+};
+
+static const char _str_tuning_mode_ext[TUNING_MODE_EXT_NUMBER][32] = {
+    TUING_MODE_EXT_TO_STR(SINGLE_SHOT),
+    TUING_MODE_EXT_TO_STR(MULTI_SHOT_HDR),
+    TUING_MODE_EXT_TO_STR(MULTI_SHOT_MF_HISO),
+    TUING_MODE_EXT_TO_STR(MULTI_SHOT_MA_HDR),
+};
+
+static PARAM_s _System_Params[] = {
+    {0, "ambacam_rev", STRING, 1, 0},
+    {1, "chip_rev", STRING, 1, 0},
+    {2, "sensor_id", STRING, 1, 0},
+    {3, "user_mode", STRING, 1, 0},
+    {4, "tuning_mode", STRING, 1, 0},
+    {5, "raw_path", STRING, 1, 0},
+    {6, "raw_width", U_16, 1, 0},
+    {7, "raw_height", U_16, 1, 0},
+    {8, "raw_pitch", U_16, 1, 0},
+    {9, "raw_resolution", U_16, 1, 0},
+    {10, "raw_bayer", U_16, 1, 0},
+    {11, "main_width", U_16, 1, 0},
+    {12, "main_height", U_16, 1, 0},
+    {13, "tuning_mode_ext", STRING, 1, 0},
+    {14, "extended_cfg_path", STRING, 1, 0},
+    {15, "input_pic_cnt", U_16, 1, 0},
+    {16, "compressed_raw", U_16, 1, 0},
+    {17, "sensor_readout_mode", U_16, 1, 0},
+    {18, "raw_start_x",         U_32, 1, 0},
+    {19, "raw_start_y",         U_32, 1, 0},
+    {20, "h_subsample_factor_num", U_8, 1, 0},
+    {21, "h_subsample_factor_den", U_8, 1, 0},
+    {22, "v_subsample_factor_num", U_8, 1, 0},
+    {23, "v_subsample_factor_den", U_8, 1, 0},
+    {24, "output_filename",     STRING, 1, 0},
+    //{25, "enable_raw2raw",      U_8, 1, 0}
+
+};
+
+static PARAM_s _Internal_Params[] = {
+    {0, "fpn_highlight", S_8, 1, 0},
+    {1, "internal_u16_1", U_16, 1, 0},
+    {2, "internal_u16_2", U_16, 1, 0},
+    {3, "internal_s32_0", S_32, 1, 0},
+    {4, "internal_s32_1", S_32, 1, 0},
+    {5, "internal_s32_2", S_32, 1, 0},
+    {6, "internal_s32_3", S_32, 1, 0},
+    {7, "internal_s32_4", S_32, 1, 0},
+    {8, "internal_sha_0", S_32, 1, 0},
+    {9, "internal_sha_1", S_32, 1, 0},
+    {10, "internal_sha_2", S_32, 1, 0},
+    {11, "internal_sha_3", S_32, 1, 0},
+    {12, "internal_sha_4", S_32, 1, 0},
+    {13, "internal_sha_5", S_32, 1, 0},
+    {14, "internal_shb_0", S_32, 1, 0},
+    {15, "internal_shb_1", S_32, 1, 0},
+    {16, "internal_shb_2", S_32, 1, 0},
+    {17, "internal_shb_3", S_32, 1, 0},
+    {18, "internal_shb_4", S_32, 1, 0},
+    {19, "internal_shb_5", S_32, 1, 0},
+    {20, "internal_wm_0", S_32, 1, 0},
+    {21, "internal_wm_1", S_32, 1, 0},
+    {22, "internal_wm_2", S_32, 1, 0},
+    {23, "internal_wm_3", S_32, 1, 0},
+    {24, "NOT_CUSTOMER_VISIBLE_FULL_RAW_W", S_32, 1, 0},
+    {25, "NOT_CUSTOMER_VISIBLE_FULL_MAIN_W", S_32, 1, 0},
+    {26, "internal_hdr_0", S_32, 1, 0},
+    {27, "internal_hdr_1", S_32, 1, 0},
+    {28, "diag_mode", U_8, 1, 0},
+};
+
+static PARAM_s AaaFunctionParams[] = {
+    {0, "ae_op", U_8, 1, 0},
+    {1, "awb_op", U_8, 1, 0},
+    {2, "af_op", U_8, 1, 0},
+    {3, "adj_op", U_8, 1, 0}
+};
+
+static PARAM_s AeInfoParams[] = {
+    {0, "agc_index", S_32, 1, 0},
+    {1, "shutter_index", S_32, 1, 0},
+    {2, "iris_index", S_32, 1, 0},
+    {3, "dgain", S_32, 1, 0}
+};
+
+static PARAM_s AeStatisticsInfoParams[] = {
+    {0, "ae_tile_num_col", U_16, 1, 0},
+    {1, "ae_tile_num_row", U_16, 1, 0},
+    {2, "ae_tile_col_start", U_16, 1, 0},
+    {3, "ae_tile_row_start", U_16, 1, 0},
+    {4, "ae_tile_width", U_16, 1, 0},
+    {5, "ae_tile_height", U_16, 1, 0},
+    {6, "ae_pix_min_value", U_16, 1, 0},
+    {7, "ae_pix_max_value", U_16, 1, 0}
+};
+static PARAM_s AwbStatisticsInfoParams[] = {
+    {0, "awb_tile_num_col", U_16, 1, 0},
+    {1, "awb_tile_num_row", U_16, 1, 0},
+    {2, "awb_tile_col_start", U_16, 1, 0},
+    {3, "awb_tile_row_start", U_16, 1, 0},
+    {4, "awb_tile_width", U_16, 1, 0},
+    {5, "awb_tile_height", U_16, 1, 0},
+    {6, "awb_tile_active_width", U_16, 1, 0},
+    {7, "awb_tile_active_height", U_16, 1, 0},
+    {8, "awb_pix_min_value", U_32, 1, 0},
+    {9, "awb_pix_max_value", U_32, 1, 0}
+};
+static PARAM_s AfStatisticsInfoParams[] = {
+    {0, "af_tile_num_col", U_16, 1, 0},
+    {1, "af_tile_num_row", U_16, 1, 0},
+    {2, "af_tile_col_start", U_16, 1, 0},
+    {3, "af_tile_row_start", U_16, 1, 0},
+    {4, "af_tile_width", U_16, 1, 0},
+    {5, "af_tile_height", U_16, 1, 0},
+    {6, "af_tile_active_width", U_16, 1, 0},
+    {7, "af_tile_active_height", U_16, 1, 0}
+};
+static PARAM_s StaticBadPixelCorrectionParams[] = {
+    {0, "enable", U_8, 1, 0},
+    {1, "calib_version", U_32, 1, 0},
+    {2, "calib_vin_start_x", U_32, 1, 0},
+    {3, "calib_vin_start_y", U_32, 1, 0},
+    {4, "calib_vin_width", U_32, 1, 0},
+    {5, "calib_vin_height", U_32, 1, 0},
+    {6, "calib_vin_h_subsample_factor_num", U_8, 1, 0},
+    {7, "calib_vin_h_subsample_factor_den", U_8, 1, 0},
+    {8, "calib_vin_v_subsample_factor_num", U_8, 1, 0},
+    {9, "calib_vin_v_subsample_factor_den", U_8, 1, 0},
+    {10, "map_path", EXT_PATH, 1, 0}
+};
+static PARAM_s StaticBadPixelCorrectionByPassParams[] = {
+    {0, "enable", U_8, 1, 0},
+    {1, "pixel_map_width", U_16, 1, 0},
+    {2, "pixel_map_height", U_16, 1, 0},
+    {3, "pixel_map_pitch", U_16, 1, 0},
+    {4, "map_path", EXT_PATH, 1, 0}
+};
+
+static PARAM_s VignetteCompensationParams[] = {
+    {0, "enable", U_8, 1, 0},
+    {1, "gain_shift", U_8, 1, 0},
+    {2, "strength_effect_mode", U_8, 1, 0},
+    {3, "strength", U_32, 1, 0},
+    {4, "calib_version", U_32, 1, 0},
+    {5, "calib_table_width", S_32, 1, 0},
+    {6, "calib_table_height", S_32, 1, 0},
+    {7, "calib_vin_start_x", U_32, 1, 0},
+    {8, "calib_vin_start_y", U_32, 1, 0},
+    {9, "calib_vin_width", U_32, 1, 0},
+    {10, "calib_vin_height", U_32, 1, 0},
+    {11, "calib_vin_h_subsample_factor_num", U_8, 1, 0},
+    {12, "calib_vin_h_subsample_factor_den", U_8, 1, 0},
+    {13, "calib_vin_v_subsample_factor_num", U_8, 1, 0},
+    {14, "calib_vin_v_subsample_factor_den", U_8, 1, 0},
+    {15, "calib_table_path", EXT_PATH, 1, 0},
+};
+static PARAM_s VignetteCompensationByPassParams[] = {
+    {0, "enable", U_8, 1, 0},
+    {1, "gain_shift", U_16, 1, 0},
+    {2, "gain_path", EXT_PATH, 1, 0},
+};
+
+static PARAM_s WarpCompensationParams[] = {
+    {0, "enable", U_8, 1, 0},
+    {1, "calib_version", U_32, 1, 0},
+    {2, "horizontal_grid_number", S_32, 1, 0},
+    {3, "vertical_grid_number", S_32, 1, 0},
+    {4, "tile_width_exponent", S_32, 1, 0},
+    {5, "tile_height_exponent", S_32, 1, 0},
+    {6, "vin_sensor_start_x", U_32, 1, 0},
+    {7, "vin_sensor_start_y", U_32, 1, 0},
+    {8, "vin_sensor_width", U_32, 1, 0},
+    {9, "vin_sensor_height", U_32, 1, 0},
+    {10, "vin_sensor_h_subsample_factor_num", U_8, 1, 0},
+    {11, "vin_sensor_h_subsample_factor_den", U_8, 1, 0},
+    {12, "vin_sensor_v_subsample_factor_num", U_8, 1, 0},
+    {13, "vin_sensor_v_subsample_factor_den", U_8, 1, 0},
+    {14, "warp_grid_table_path", EXT_PATH, 1, 0},
+};
+
+static PARAM_s WarpCompensationDzoomByPassParams[] = {
+    // Warp Part
+    {0, "warp_control", U_32, 1, 0},
+    {1, "grid_array_width", U_8, 1, 0},
+    {2, "grid_array_height", U_8, 1, 0},
+    {3, "horz_grid_spacing_exponent", U_8, 1, 0},
+    {4, "vert_grid_spacing_exponent", U_8, 1, 0},
+    {5, "vert_warp_enable", U_8, 1, 0},
+    {6, "vert_warp_grid_array_width", U_8, 1, 0},
+    {7, "vert_warp_grid_array_height", U_8, 1, 0},
+    {8, "vert_warp_horz_grid_spacing_exponent", U_8, 1, 0},
+    {9, "vert_warp_vert_grid_spacing_exponent", U_8, 1, 0},
+    {10, "warp_horizontal_table_path", EXT_PATH, 1, 0},
+    {11, "warp_vertical_table_path", EXT_PATH, 1, 0},
+
+    // Dzoom Part
+    {12, "dzoom_actual_left_top_x", U_32, 1, 0},
+    {13, "dzoom_actual_left_top_y", U_32, 1, 0},
+    {14, "dzoom_actual_right_bot_x", U_32, 1, 0},
+    {15, "dzoom_actual_right_bot_y", U_32, 1, 0},
+    {16, "dzoom_zoom_x", U_32, 1, 0},
+    {17, "dzoom_zoom_y", U_32, 1, 0},
+    {18, "dzoom_x_center_offset", U_32, 1, 0},
+    {19, "dzoom_y_center_offset", U_32, 1, 0},
+    {20, "dzoom_hor_skew_phase_inc", S_32, 1, 0},
+    {21, "dzoom_dummy_window_x_left", U_16, 1, 0},
+    {22, "dzoom_dummy_window_y_top", U_16, 1, 0},
+    {23, "dzoom_dummy_window_width", U_16, 1, 0},
+    {24, "dzoom_dummy_window_height", U_16, 1, 0},
+    {25, "dzoom_cfa_output_width", U_16, 1, 0},
+    {26, "dzoom_cfa_output_height", U_16, 1, 0},
+};
+
+static PARAM_s DzoomParams[] = {
+    {0, "enable", U_8, 1, 0},
+    {1, "actual_left_top_x", U_32, 1, 0},
+    {2, "actual_left_top_y", U_32, 1, 0},
+    {3, "actual_right_bot_x", U_32, 1, 0},
+    {4, "actual_right_bot_y", U_32, 1, 0},
+    {5, "hor_skew_phase_inc", S_32, 1, 0},
+    {6, "dummy_window_x_left", U_16, 1, 0},
+    {7, "dummy_window_y_top", U_16, 1, 0},
+    {8, "dummy_window_width", U_16, 1, 0},
+    {9, "dummy_window_height", U_16, 1, 0},
+    {10, "cfa_output_width", U_16, 1, 0},
+    {11, "cfa_output_height", U_16, 1, 0},
+    {12, "r2r_output_width", U_16, 1, 0},
+    {13, "r2r_output_heigh", U_16, 1, 0},
+};
+
+static PARAM_s ChromaAberrationParams[] = {
+    {0, "enable", U_8, 1, 0},
+    {1, "calib_version", U_32, 1, 0},
+    {2, "horizontal_grid_number", S_32, 1, 0},
+    {3, "vertical_grid_number", S_32, 1, 0},
+    {4, "tile_width_exponent", S_32, 1, 0},
+    {5, "tile_height_exponent", S_32, 1, 0},
+    {6, "vin_sensor_start_x", U_32, 1, 0},
+    {7, "vin_sensor_start_y", U_32, 1, 0},
+    {8, "vin_sensor_width", U_32, 1, 0},
+    {9, "vin_sensor_height", U_32, 1, 0},
+    {10, "vin_sensor_h_subsample_factor_num", U_8, 1, 0},
+    {11, "vin_sensor_h_subsample_factor_den", U_8, 1, 0},
+    {12, "vin_sensor_v_subsample_factor_num", U_8, 1, 0},
+    {13, "vin_sensor_v_subsample_factor_den", U_8, 1, 0},
+    {14, "red_scale_factor", U_32, 1, 0},
+    {15, "blue_scale_factor", U_32, 1, 0},
+    {16, "ca_grid_table_path", EXT_PATH, 1, 0},
+};
+
+static PARAM_s ChromaAberrationByPassParams[] = {
+    {0, "horz_warp_enable", U_16, 1, 0},
+    {1, "vert_warp_enable", U_16, 1, 0},
+    {2, "horz_pass_grid_array_width", U_8, 1, 0},
+    {3, "horz_pass_grid_array_height", U_8, 1, 0},
+    {4, "horz_pass_horz_grid_spacing_exponent", U_8, 1, 0},
+    {5, "horz_pass_vert_grid_spacing_exponent", U_8, 1, 0},
+    {6, "vert_pass_grid_array_width", U_8, 1, 0},
+    {7, "vert_pass_grid_array_height", U_8, 1, 0},
+    {8, "vert_pass_horz_grid_spacing_exponent", U_8, 1, 0},
+    {9, "vert_pass_vert_grid_spacing_exponent", U_8, 1, 0},
+    {10, "red_scale_factor", U_16, 1, 0},
+    {11, "blue_scale_factor", U_16, 1, 0},
+    {12, "warp_horz_table_path", EXT_PATH, 1, 0},
+    {13, "warp_vert_table_path", EXT_PATH, 1, 0}
+};
+
+static PARAM_s SensorInputParams[] = {
+    {0, "sensor_id", U_8, 1, 0},
+    {1, "bayer_pattern", U_8, 1, 0},
+    {2, "sensor_resolution", U_8, 1, 0},
+    {3, "readout_mode", U_32, 1, 0}
+};
+
+static PARAM_s StaticBlackLevelParams[] = {
+    {0, "r_black", S_16, 1, 0},
+    {1, "g_r_black", S_16, 1, 0},
+    {2, "g_b_black", S_16, 1, 0},
+    {3, "b_black", S_16, 1, 0},
+    //{4, "def_method", U_8, 1, 0}
+
+};
+static PARAM_s DeferredBlackLevelParams[] = {
+    {0, "enable", U_8, 1, 0}
+};
+static PARAM_s DynamicBadPixelCorrectionParams[] = {
+    {0, "enable", U_8, 1, 0},
+    {1, "hot_pixel_detection_strength", U_8, 1, 0},
+    {2, "dark_pixel_detection_strength", U_8, 1, 0},
+    {3, "correction_method", U_8, 1, 0},
+};
+static PARAM_s CfaLeakageFilterParams[] = {
+    {0, "enable", U_8, 1, 0},
+    {1, "alpha_rr", S_8, 1, 0},
+    {2, "alpha_rb", S_8, 1, 0},
+    {3, "alpha_br", S_8, 1, 0},
+    {4, "alpha_bb", S_8, 1, 0},
+    {5, "saturation_level", U_16, 1, 0}
+};
+
+static PARAM_s CfaNoiseFilterParams[] = {
+    {0, "enable", U_8, 1, 0},
+    {1, "noise_level_red", U_16, 1, 0},
+    {2, "noise_level_green", U_16, 1, 0},
+    {3, "noise_level_blue", U_16, 1, 0},
+    {4, "original_blend_strength_red", U_16, 1, 0},
+    {5, "original_blend_strength_green", U_16, 1, 0},
+    {6, "original_blend_strength_blue", U_16, 1, 0},
+    {7, "extent_regular_red", U_16, 1, 0},
+    {8, "extent_regular_green", U_16, 1, 0},
+    {9, "extent_regular_blue", U_16, 1, 0},
+    {10, "extent_fine_red", U_16, 1, 0},
+    {11, "extent_fine_green", U_16, 1, 0},
+    {12, "extent_fine_blue", U_16, 1, 0},
+    {13, "strength_fine_red", U_16, 1, 0},
+    {14, "strength_fine_green", U_16, 1, 0},
+    {15, "strength_fine_blue", U_16, 1, 0},
+    {16, "selectivity_regular", U_16, 1, 0},
+    {17, "selectivity_fine", U_16, 1, 0}
+};
+static PARAM_s AntiAliasingParams[] = {
+    {0, "enable", U_8, 1, 0},
+    {1, "thresh", U_16, 1, 0},
+    {2, "log_fractional_correct", U_8, 1, 0},
+};
+static PARAM_s GlobalDgainParams[] = {
+    {0, "gain", U_32, 1, 0}
+};
+static PARAM_s WbGainParams[] = {
+    {0, "r_gain", U_32, 1, 0},
+    {1, "g_gain", U_32, 1, 0},
+    {2, "b_gain", U_32, 1, 0}
+};
+static PARAM_s DgainSaturationLevelParams[] = {
+    {0, "level_red", U_32, 1, 0},
+    {1, "level_green_even", U_32, 1, 0},
+    {2, "level_green_odd", U_32, 1, 0},
+    {3, "level_blue", U_32, 1, 0}
+};
+
+static PARAM_s LocalExposureParams[] = {
+    {0, "enable", U_8, 1, 0},
+    {1, "radius", U_8, 1, 0},
+    {2, "luma_weight_red", U_8, 1, 0},
+    {3, "luma_weight_green", U_8, 1, 0},
+    {4, "luma_weight_blue", U_8, 1, 0},
+    {5, "luma_weight_shift", U_8, 1, 0},
+    {6, "gain_curve", U_16, AMBA_DSP_IMG_NUM_EXPOSURE_CURVE, 0},
+};
+static PARAM_s ColorCorrectionParams[] = {
+    {0, "reg_path", EXT_PATH, 1, 0},
+    {1, "three_d_path", EXT_PATH, 1, 0},
+    //{2, "sec_cc_path", EXT_PATH, 1, 0}
+};
+static PARAM_s ToneCurveParams[] = {
+    {0, "curve_red", U_16, AMBA_DSP_IMG_NUM_TONE_CURVE, 0},
+    {1, "curve_green", U_16, AMBA_DSP_IMG_NUM_TONE_CURVE, 0},
+    {2, "curve_blue", U_16, AMBA_DSP_IMG_NUM_TONE_CURVE, 0}
+};
+static PARAM_s RgbToYuvMatrixParams[] = {
+    {0, "m11", S_16, 1, 0},
+    {1, "m12", S_16, 1, 0},
+    {2, "m13", S_16, 1, 0},
+    {3, "m21", S_16, 1, 0},
+    {4, "m22", S_16, 1, 0},
+    {5, "m23", S_16, 1, 0},
+    {6, "m31", S_16, 1, 0},
+    {7, "m32", S_16, 1, 0},
+    {8, "m33", S_16, 1, 0},
+    {9, "y_offset", S_16, 1, 0},
+    {10, "u_offset", S_16, 1, 0},
+    {11, "v_offset", S_16, 1, 0}
+};
+static PARAM_s ChromaScaleParams[] = {
+    {0, "enable", U_8, 1, 0},
+    {1, "gain_curve", U_16, AMBA_DSP_IMG_NUM_CHROMA_GAIN_CURVE, 0}
+};
+
+static PARAM_s ChromaMedianFilterParams[] = {
+    {0, "enable", S_32, 1, 0},
+    {1, "cb_adaptive_strength", U_16, 1, 0},
+    {2, "cr_adaptive_strength", U_16, 1, 0},
+    {3, "cb_non_adaptive_strength", U_8, 1, 0},
+    {4, "cr_non_adaptive_strength", U_8, 1, 0},
+    {5, "cb_adaptive_amount", U_16, 1, 0},
+    {6, "cr_adaptive_amount", U_16, 1, 0},
+};
+
+static PARAM_s DemosaicFilterParams[] = {
+    {0, "activity_thresh", U_16, 1, 0},
+    {1, "activity_difference_thresh", U_16, 1, 0},
+    {2, "grad_clip_thresh", U_16, 1, 0},
+    {3, "grad_noise_thresh", U_16, 1, 0},
+};
+
+static PARAM_s GbGrMismatchParams[] = {
+    {0, "narrow_enable", U_8, 1, 0},
+    {1, "wide_enable", U_8, 1, 0},
+    {2, "wide_safety", U_16, 1, 0},
+    {3, "wide_thresh", U_16, 1, 0},
+};
+
+static PARAM_s SharpeningBothParams[] = {
+    {0, "enable", U_8, 1, 0},
+    {1, "mode"  , U_8, 1, 0},
+    {2, "edge_thresh", U_16, 1, 0},
+    {3, "wide_edge_detect", U_8, 1, 0},
+    {4, "max_change_up5x5", U_8, 1, 0},
+    {5, "max_change_down5x5", U_8, 1, 0},
+};
+
+static PARAM_s SharpeningNoiseParams[] = {
+    {0,  "fir_specify",                  U_8,  1, 0},
+    {1,  "fir_strength_iso",             U_16, 1, 0},
+    {2,  "fir_strength_dir",             U_16, 1, 0},
+    {3,  "fir_per_dir_fir_dir_amounts",  U_16, 9, 0},
+    {4,  "fir_per_dir_fir_dir_strengths",U_16, 9, 0},
+    {5,  "fir_per_dir_fir_iso_strengths",U_16, 9, 0},
+    {6,  "fir_coefs",                    S_16, 225, 0},
+    {7,  "max_change_down",    U_8, 1, 0},
+    {8,  "max_change_up",      U_8, 1, 0},
+    {9,  "level_str_adjust_high",          U_8, 1, 0},
+    {10, "level_str_adjust_high_delta",   U_8, 1, 0},
+    {11, "level_str_adjust_high_strength",U_8, 1, 0},
+    {12, "level_str_adjust_mid_strength", U_8, 1, 0},
+    {13, "level_str_adjust_low",          U_8, 1, 0},
+    {14, "level_str_adjust_low_delta",      U_8, 1, 0},
+    {15, "level_str_adjust_low_strength", U_8, 1, 0},
+    {16, "level_str_adjust_not_T0T1_level_based", U_8, 1, 0},
+    {17, "T0", U_8, 1, 0},
+    {18, "T1", U_8, 1, 0},
+    {19, "alpha_min", U_8, 1, 0},
+    {20, "alpha_max", U_8, 1, 0},
+};
+
+static PARAM_s SharpeningNoiseParams_A12[] = {
+    {0,  "fir_specify",                  U_8,  1, 0},
+    {1,  "fir_strength_iso",             U_16, 1, 0},
+    {2,  "fir_strength_dir",             U_16, 1, 0},
+    {3,  "fir_per_dir_fir_dir_amounts",  U_16, 9, 0},
+    {4,  "fir_per_dir_fir_dir_strengths",U_16, 9, 0},
+    {5,  "fir_per_dir_fir_iso_strengths",U_16, 9, 0},
+    {6,  "fir_coefs",                    U_16, 225, 0},
+    {7,  "max_change_down",    U_8, 1, 0},
+    {8,  "max_change_up",      U_8, 1, 0},
+    {9,  "level_str_adjust_high",          U_8, 1, 0},
+    {10, "level_str_adjust_high_delta",   U_8, 1, 0},
+    {11, "level_str_adjust_high_strength",U_8, 1, 0},
+    {12, "level_str_adjust_mid_strength", U_8, 1, 0},
+    {13, "level_str_adjust_low",          U_8, 1, 0},
+    {14, "level_str_adjust_low_delta",      U_8, 1, 0},
+    {15, "level_str_adjust_low_strength", U_8, 1, 0},
+    {16, "level_str_adjust_not_T0T1_level_based", U_8, 1, 0},
+    {17, "T0", U_8, 1, 0},
+    {18, "T1", U_8, 1, 0},
+    {19, "alpha_min", U_8, 1, 0},
+    {20, "alpha_max", U_8, 1, 0},
+};
+
+static PARAM_s SharpeningFirParams[] = {
+    {0,  "fir_specify",                  U_8,  1, 0},
+    {1,  "fir_strength_iso",             U_16, 1, 0},
+    {2,  "fir_strength_dir",             U_16, 1, 0},
+    {3,  "fir_per_dir_fir_dir_amounts",  U_16, 9, 0},
+    {4,  "fir_per_dir_fir_dir_strengths",U_16, 9, 0},
+    {5,  "fir_per_dir_fir_iso_strengths",U_16, 9, 0},
+    {6,  "fir_coefs",                    S_16, 225, 0},
+};
+
+static PARAM_s SharpeningCoringParams[] = {
+    {0, "coring_table", U_8, AMBA_DSP_IMG_NUM_CORING_TABLE_INDEX, 0},
+    {1, "fractional_bits", U_8, 1, 0},
+};
+
+static PARAM_s SharpeningLevelParams[] = {
+    {0, "high",            U_8, 1, 0},
+    {1, "high_delta",  U_8, 1, 0},
+    {2, "high_strength",U_8, 1, 0},
+    {3, "mid_strength", U_8, 1, 0},
+    {4, "low",            U_8, 1, 0},
+    {5, "low_delta",    U_8, 1, 0},
+    {6, "low_strength", U_8, 1, 0},
+};
+
+static PARAM_s VideoMctfParams[] = {
+    {0,  "enable"            ,   U_8, 1, 0},
+    {1,  "y_max_change",    U_16, 1, 0},
+    {2,  "u_max_change",    U_16, 1, 0},
+    {3,  "v_max_change",    U_16, 1, 0},
+    {4,  "weighting_based_on_local_motion",    U_8, 1, 0},
+    {5,  "T0",        U_8, 4, 0},
+    {6,  "T1",        U_8, 4, 0},
+    {7,  "T2",        U_8, 4, 0},
+    {8,  "T3",        U_8, 4, 0},
+    {9,  "alpha1", U_16, 4, 0},
+    {10, "alpha2", U_16, 4, 0},
+    {11, "alpha3", U_16, 4, 0},
+};
+
+static PARAM_s VideoMctfTemporalAdjustParams[] = {
+    {0,  "still_thresh"                         ,   U_8, 1, 0},
+    {1,  "min"                                  ,   U_8, 1, 0},
+    {2,  "slow_mo_sensitivity"                  ,   U_8, 1, 0},
+    {3,  "motion_response"                      ,   U_16, 1, 0},
+    {4,  "noise_base"                           ,   U_8, 1, 0},
+    {5,  "smooth"                               ,   U_8, 1, 0},
+    {6,  "lev_adjust_high"                      ,   U_8, 1, 0},
+    {7,  "lev_adjust_high_delta"                ,   U_8, 1, 0},
+    {8,  "lev_adjust_high_strength"             ,   U_8, 1, 0},
+    {9,  "lev_adjust_low"                       ,   U_8, 1, 0},
+    {10, "lev_adjust_low_delta"                 ,   U_8, 1, 0},
+    {11, "lev_adjust_low_strength"              ,   U_8, 1, 0},
+    {12, "lev_adjust_mid_strength"              ,   U_8, 1, 0},
+    {13, "uv_max"                               ,   U_8, 1, 0},
+    {14, "uv_min"                               ,   U_8, 1, 0},
+    {15, "y_max"                                ,   U_8, 1, 0},
+    {16, "y_min"                                ,   U_8, 1, 0},
+};
+
+static PARAM_s ColorDependentNoiseReductionParams[] = {
+    {0, "enable", U_8, 1, 0},
+};
+
+static PARAM_s DeferredColorCorrectionParams[] = {
+    {0, "enable", U_8, 1, 0},
+};
+
+static PARAM_s ShpAOrSpatialFilterSelectParams[] = {
+    {0, "advanced_features_enable", U_8, 1, 0},
+    {1, "use_1st_sharpen_not_asf", U_8, 1, 0}
+};
+
+static PARAM_s MoShpAOrSpatialFilterSelectParams[] = {
+    {0, "use_1st_sharpen_not_asf", U_8, 1, 0}
+};
+
+static PARAM_s AdvanceSpatialFilterParams_A12[] = {
+    {0,  "enable",  U_8, 1, 0},
+    {1,  "directional_decide_t0", U_8, 1, 0},
+    {2,  "directional_decide_t1", U_8, 1, 0},
+    {3,  "fir_specify",                  U_8, 1, 0},
+    {4,  "fir_strength_iso",             U_16, 1, 0},
+    {5,  "fir_strength_dir",             U_16, 1, 0},
+    {6,  "fir_per_dir_fir_dir_amounts",  U_16, 9, 0},
+    {7,  "fir_per_dir_fir_dir_strengths",U_16, 9, 0},
+    {8,  "fir_per_dir_fir_iso_strengths",U_16, 9, 0},
+    {9,  "fir_coefs",                    U_16, 225, 0},
+    {10, "fir_wide_edge_detect",         U_8, 1, 0},
+    {11, "level_str_adjust_high",         U_8, 1, 0},
+    {12, "level_str_adjust_high_delta",   U_8, 1, 0},
+    {13, "level_str_adjust_high_strength",U_8, 1, 0},
+    {14, "level_str_adjust_mid_strength", U_8, 1, 0},
+    {15, "level_str_adjust_low",          U_8, 1, 0},
+    {16, "level_str_adjust_low_delta",    U_8, 1, 0},
+    {17, "level_str_adjust_low_strength", U_8, 1, 0},
+    {18, "max_change_not_T0T1_alpha",   U_8, 1, 0},
+    {19, "max_change_down", U_8, 1, 0},
+    {20, "max_change_up",   U_8, 1, 0},
+    {21, "T0_down",       U_8, 1, 0},
+    {22, "T0_up",         U_8, 1, 0},
+    {23, "T1_down",       U_8, 1, 0},
+    {24, "T1_up",         U_8, 1, 0},
+    {25, "alpha_min_down",U_8, 1, 0},
+    {26, "alpha_min_up",  U_8, 1, 0},
+    {27, "alpha_max_down",U_8, 1, 0},
+    {28, "alpha_max_up",  U_8, 1, 0},
+    {29, "T0T1_div_high",         U_8, 1, 0},
+    {30, "T0T1_div_high_delta",   U_8, 1, 0},
+    {31, "T0T1_div_high_strength",U_8, 1, 0},
+    {32, "T0T1_div_low",          U_8, 1, 0},
+    {33, "T0T1_div_low_delta",    U_8, 1, 0},
+    {34, "T0T1_div_low_strength", U_8, 1, 0},
+    {35, "T0T1_div_mid_strength", U_8, 1, 0},
+};
+
+
+static PARAM_s ChromaAdvanceSpatialFilterParams[] = {
+    {0,  "enable",  U_8, 1, 0},
+    {1,  "directional_decide_t0", U_8, 1, 0},
+    {2, "directional_decide_t1", U_8, 1, 0},
+    {3,  "fir_specify",                  U_8, 1, 0},
+    {4,  "fir_strength_iso",             U_16, 1, 0},
+    {5,  "fir_strength_dir",             U_16, 1, 0},
+    {6,  "fir_per_dir_fir_dir_amounts",  U_16, 9, 0},
+    {7,  "fir_per_dir_fir_dir_strengths",U_16, 9, 0},
+    {8,  "fir_per_dir_fir_iso_strengths",U_16, 9, 0},
+    {9,  "fir_coefs",                    S_16, 225, 0},
+    {10,  "fir_wide_edge_detect",         U_8, 1, 0},
+    {11, "level_str_adjust_high",         U_8, 1, 0},
+    {12, "level_str_adjust_high_delta",   U_8, 1, 0},
+    {13, "level_str_adjust_high_strength",U_8, 1, 0},
+    {14, "level_str_adjust_mid_strength", U_8, 1, 0},
+    {15, "level_str_adjust_low",          U_8, 1, 0},
+    {16, "level_str_adjust_low_delta",    U_8, 1, 0},
+    {17, "level_str_adjust_low_strength", U_8, 1, 0},
+    {18, "max_change_not_T0T1_alpha",   U_8, 1, 0},
+    {19, "max_change", U_8, 1, 0},
+    {20, "T0",       U_8, 1, 0},
+    {21, "T1",       U_8, 1, 0},
+    {22, "alpha_max",U_8, 1, 0},
+    {23, "alpha_min",U_8, 1, 0},
+    {24, "T0T1_div_high",         U_8, 1, 0},
+    {25, "T0T1_div_high_delta",   U_8, 1, 0},
+    {26, "T0T1_div_high_strength",U_8, 1, 0},
+    {27, "T0T1_div_low",          U_8, 1, 0},
+    {28, "T0T1_div_low_delta",    U_8, 1, 0},
+    {29, "T0T1_div_low_strength", U_8, 1, 0},
+    {30, "T0T1_div_mid_strength", U_8, 1, 0},
+};
+
+static PARAM_s ChromaFilterParams[] = {
+    {0, "enable", U_8, 1, 0},
+    {1, "noise_level_cb", U_8, 1, 0},
+    {2, "noise_level_cr", U_8, 1, 0},
+    {3, "original_blend_strength_cb", U_16, 1, 0},
+    {4, "original_blend_strength_cr", U_16, 1, 0},
+    {5, "radius", U_16, 1, 0}
+};
+
+static PARAM_s ChromaFilterLowAndVeryLowParams[] = {
+    {0, "edge_start_cb", U_8, 1, 0},
+    {1, "edge_start_cr", U_8, 1, 0},
+    {2, "edge_end_cb", U_8, 1, 0},
+    {3, "edge_end_cr", U_8, 1, 0},
+
+};
+
+static PARAM_s HisoChromaFilterParams[] = {
+    {0, "enable", U_8, 1, 0},
+    {1, "noise_level_cb", U_8, 1, 0},
+    {2, "noise_level_cr", U_8, 1, 0},
+    {3, "original_blend_strength_cb", U_16, 1, 0},
+    {4, "original_blend_strength_cr", U_16, 1, 0},
+};
+
+static PARAM_s HisoChromaFilterCombineParams[] = {
+    {0, "T0_cb",       U_8, 1, 0},
+    {1, "T0_cr",       U_8, 1, 0},
+    {2, "T1_cb",       U_8, 1, 0},
+    {3, "T1_cr",       U_8, 1, 0},
+
+    {4, "alpha_max_cb",      U_8, 1, 0},
+    {5, "alpha_max_cr",      U_8, 1, 0},
+    {6, "alpha_min_cb",      U_8, 1, 0},
+    {7, "alpha_min_cr",      U_8, 1, 0},
+
+    {8, "max_change_cb",      U_8, 1, 0},
+    {9, "max_change_cr",      U_8, 1, 0},
+};
+
+static PARAM_s HisoLumaFilterCombineParams[] = {
+    {0, "T0",       U_8, 1, 0},
+    {1, "T1",       U_8, 1, 0},
+    {2, "alpha_max",      U_8, 1, 0},
+    {3, "alpha_min",      U_8, 1, 0},
+    {4, "max_change",     U_8, 1, 0},
+};
+
+static PARAM_s HisoFreqRecoverParams[] = {
+    {0,  "fir_specify",                  U_8,  1, 0},
+    {1,  "fir_strength_iso",             U_16, 1, 0},
+    {2,  "fir_strength_dir",             U_16, 1, 0},
+    {3,  "fir_per_dir_fir_dir_amounts",  U_16, 9, 0},
+    {4,  "fir_per_dir_fir_dir_strengths",U_16, 9, 0},
+    {5,  "fir_per_dir_fir_iso_strengths",U_16, 9, 0},
+    {6,  "fir_coefs",    S_16, 225, 0},
+
+    {7, "fir_wide_edge_detect", U_8, 1, 0},
+    {8, "fir_edge_thresh", U_16, 1, 0},
+    {9, "smooth_select", U_8, 256, 0},
+
+    {10,  "max_down",     U_8, 1, 0},
+    {11,  "max_up",       U_8, 1, 0},
+    {12,  "high",         U_8, 1, 0},
+    {13, "high_delta",   U_8, 1, 0},
+    {14, "high_strength",U_8, 1, 0},
+    {15, "mid_strength", U_8, 1, 0},
+    {16, "low",          U_8, 1, 0},
+    {17, "low_delta",    U_8, 1, 0},
+    {18, "low_strength", U_8, 1, 0},
+};
+
+static REG_s ImgRegs[] = {
+    {ITUNER_SYSTEM_INFO, "system", 1, 0, GET_ARRAY_NUM(_System_Params), 0, _System_Params, &_System_Proc},
+    {ITUNER_INTERNAL_INFO, "internal", 1, 0, GET_ARRAY_NUM(_Internal_Params), 0, _Internal_Params, &_Internal_Proc},
+    {ITUNER_AAA_FUNCTION, "aaa_function", 1, 0, GET_ARRAY_NUM(AaaFunctionParams), 0, AaaFunctionParams, &_AaaFunctionProc},
+    {ITUNER_AE_INFO, "ae_info", 1, 0, GET_ARRAY_NUM(AeInfoParams), 0, AeInfoParams, &_AeInfoProc},
+    //{ITUNER_WB_SIM_INFO, "wb_sim_info", 1, 0, GET_ARRAY_NUM(WbSimInfoParams), 0, WbSimInfoParams, &_WbSimInfoProc},
+    {ITUNER_AE_STATISTICS_INFO, "ae_statistics_info", 1, 0, GET_ARRAY_NUM(AeStatisticsInfoParams), 0, AeStatisticsInfoParams, &_AeStatisticsInfoProc},
+    {ITUNER_AWB_STATISTICS_INFO, "awb_statistics_info", 1, 0, GET_ARRAY_NUM(AwbStatisticsInfoParams), 0, AwbStatisticsInfoParams, &_AwbStatisticsInfoProc},
+    {ITUNER_AF_STATISTICS_INFO, "af_statistics_info", 1, 0, GET_ARRAY_NUM(AfStatisticsInfoParams), 0, AfStatisticsInfoParams, &_AfStatisticsInfoProc},
+    //{7, "af_statistics_ex_t", 1, 0, 0, 0, 0, 0},
+    {ITUNER_STATIC_BAD_PIXEL_CORRECTION, "static_bad_pixel_correction", 1, 0, GET_ARRAY_NUM(StaticBadPixelCorrectionParams), 0, StaticBadPixelCorrectionParams, &_StaticBadPixelCorrectionProc},
+    {ITUNER_VIGNETTE_COMPENSATION, "vignette_compensation", 1, 0, GET_ARRAY_NUM(VignetteCompensationParams), 0, VignetteCompensationParams, &_VignetteCompensationProc},
+    {ITUNER_WARP_COMPENSATION, "warp_compensation", 1, 0, GET_ARRAY_NUM(WarpCompensationParams), 0, WarpCompensationParams, &_WarpCompensationProc},
+    {ITUNER_STATIC_BLACK_LEVEL, "static_black_level", 1, 0, GET_ARRAY_NUM(StaticBlackLevelParams), 0, StaticBlackLevelParams, &_StaticBlackLevelProc},
+    {ITUNER_DEFERRED_BLACK_LEVEL, "deferred_black_level", 1, 0, GET_ARRAY_NUM(DeferredBlackLevelParams), 0, DeferredBlackLevelParams, &_DeferredBlackLevelProc},
+    {ITUNER_DYNAMIC_BAD_PIXEL_CORRECTION, "li_auto_bad_pixel_correction", 1, 0, GET_ARRAY_NUM(DynamicBadPixelCorrectionParams), 0, DynamicBadPixelCorrectionParams, &_DynamicBadPixelCorrectionProc},
+    {ITUNER_CFA_LEAKAGE_FILTER, "li_cfa_leakage_filter", 1, 0, GET_ARRAY_NUM(CfaLeakageFilterParams), 0, CfaLeakageFilterParams, &_CfaLeakageFilterProc},
+    {ITUNER_CFA_NOISE_FILTER, "li_cfa_noise_filter", 1, 0, GET_ARRAY_NUM(CfaNoiseFilterParams), 0, CfaNoiseFilterParams, &_CfaNoiseFilterProc},
+    {ITUNER_ANTI_ALIASING_STRENGTH, "li_anti_aliasing", 1, 0, GET_ARRAY_NUM(AntiAliasingParams), 0, AntiAliasingParams, &_AntiAliasingProc},
+    {ITUNER_GLOBAL_DGAIN, "global_dgain", 1, 0, GET_ARRAY_NUM(GlobalDgainParams), 0, GlobalDgainParams, &_GlobalDgainProc},
+    {ITUNER_WB_GAIN, "wb_gains", 1, 0, GET_ARRAY_NUM(WbGainParams), 0, WbGainParams, &_WbGainProc},
+    {ITUNER_DGAIN_SATURATION_LEVEL, "dgain_saturation_level", 1, 0, GET_ARRAY_NUM(DgainSaturationLevelParams), 0, DgainSaturationLevelParams, &_DgainSaturationLevelProc},
+    {ITUNER_LOCAL_EXPOSURE, "local_exposure", 1, 0, GET_ARRAY_NUM(LocalExposureParams), 0, LocalExposureParams, &_LocalExposureProc},
+    {ITUNER_COLOR_CORRECTION, "color_correction", 1, 0, GET_ARRAY_NUM(ColorCorrectionParams), 0, ColorCorrectionParams, &_ColorCorrectionProc},
+    {ITUNER_TONE_CURVE, "tone_curve", 1, 0, GET_ARRAY_NUM(ToneCurveParams), 0, ToneCurveParams, &_ToneCurveProc},
+    {ITUNER_RGB_TO_YUV_MATRIX, "rgb_to_yuv_matrix", 1, 0, GET_ARRAY_NUM(RgbToYuvMatrixParams), 0, RgbToYuvMatrixParams, &_RgbToYuvMatrixProc},
+    {ITUNER_CHROMA_SCALE, "chroma_scale", 1, 0, GET_ARRAY_NUM(ChromaScaleParams), 0, ChromaScaleParams, &_ChromaScaleProc},
+    {ITUNER_CHROMA_MEDIAN_FILTER, "li_chroma_median_filter", 1, 0, GET_ARRAY_NUM(ChromaMedianFilterParams), 0, ChromaMedianFilterParams, &_ChromaMedianFilterProc},
+    {ITUNER_DZOOM, "dzoom", 1, 0, GET_ARRAY_NUM(DzoomParams), 0, DzoomParams, &_DzoomProc},
+    {ITUNER_DEMOSAIC_FILTER, "li_demosaic", 1, 0, GET_ARRAY_NUM(DemosaicFilterParams), 0, DemosaicFilterParams, &_DemosaicFilterProc},
+    {ITUNER_GB_GR_MISMATCH, "li_gb_gr_mismatch_correct", 1, 0, GET_ARRAY_NUM(GbGrMismatchParams), 0, GbGrMismatchParams, &_GbGrMismatchProc},
+    {ITUNER_VIDEO_MCTF, "video_mctf", 1, 0, GET_ARRAY_NUM(VideoMctfParams), 0, VideoMctfParams, &_VideoMctfProc},
+    {ITUNER_VIDEO_MCTF_TEMPORAL_ADJUST, "video_mctf_temporal_adjust", 1, 0, GET_ARRAY_NUM(VideoMctfTemporalAdjustParams), 0, VideoMctfTemporalAdjustParams, &_VideoMctfTemporalAdjustProc},
+    {ITUNER_SENSOR_INPUT_INFO, "vin_sensor_info", 1, 0, GET_ARRAY_NUM(SensorInputParams), 0, SensorInputParams, &_SensorInputProc},
+    {ITUNER_CDNR, "li_color_dependent_luma_noise_reduction", 1, 0, GET_ARRAY_NUM(ColorDependentNoiseReductionParams), 0, ColorDependentNoiseReductionParams, &_ColorDependentNoiseReductionProc},
+    {ITUNER_SHP_A_OR_SPATIAL_FILTE_SELECT, "li_processing_select", 1, 0, GET_ARRAY_NUM(ShpAOrSpatialFilterSelectParams), 0, ShpAOrSpatialFilterSelectParams, &_ShpAOrSpatialFilterSelectproc},
+    {ITUNER_ASF_INFO, "li_advanced_spatial_filter", 1, 0, GET_ARRAY_NUM(AdvanceSpatialFilterParams_A12), 0, AdvanceSpatialFilterParams_A12, &_AdvanceSpatialFilterProc},
+    {ITUNER_CHROMA_FILTER, "li_chroma_filter", 1, 0, GET_ARRAY_NUM(ChromaFilterParams), 0, ChromaFilterParams, &_ChromaFilterProc},
+    {ITUNER_CHROMA_ABERRATION_INFO, "chromatic_aberration_correction", 1, 0, GET_ARRAY_NUM(ChromaAberrationParams), 0, ChromaAberrationParams, &_ChromaAberrationProc},
+    //li_sharpen_noise_filter
+    {ITUNER_SHARPEN_BOTH, "li_sharpen_noise_filter_both", 1, 0, GET_ARRAY_NUM(SharpeningBothParams), 0, SharpeningBothParams, &_SharpenBothProc},
+    {ITUNER_SHARPEN_NOISE, "li_sharpen_noise_filter_noise", 1, 0, GET_ARRAY_NUM(SharpeningNoiseParams_A12), 0, SharpeningNoiseParams_A12, &_SharpenNoiseProc},
+    {ITUNER_FIR, "li_sharpen_noise_filter_sharpen", 1, 0, GET_ARRAY_NUM(SharpeningFirParams), 0, SharpeningFirParams, &_SharpenFirProc},
+    {ITUNER_CORING, "li_sharpen_noise_filter_sharpen_coring", 1, 0, GET_ARRAY_NUM(SharpeningCoringParams), 0, SharpeningCoringParams, &_SharpenCoringProc},
+    {ITUNER_CORING_INDEX_SCALE, "li_sharpen_noise_filter_sharpen_coring_index_scale", 1, 0, GET_ARRAY_NUM(SharpeningLevelParams), 0, SharpeningLevelParams, &_CoringIndexScaleProc},
+    {ITUNER_MIN_CORING_RESULT, "li_sharpen_noise_filter_sharpen_min_coring_result", 1, 0, GET_ARRAY_NUM(SharpeningLevelParams), 0, SharpeningLevelParams, &_MinCoringResultProc},
+    {ITUNER_SCALE_CORING, "li_sharpen_noise_filter_sharpen_scale_coring", 1, 0, GET_ARRAY_NUM(SharpeningLevelParams), 0, SharpeningLevelParams, &_ScaleCoringProc},
+    //li_wide_chroma
+    {ITUNER_WIDE_CHROMA_FILTER, "li_wide_chroma_filter", 1, 0, GET_ARRAY_NUM(ChromaFilterParams), 0, ChromaFilterParams, &_WideChromaFilterProc},
+    {ITUNER_WIDE_CHROMA_FILTER_COMBINE, "li_wide_chroma_filter_combine", 1, 0, GET_ARRAY_NUM(HisoChromaFilterCombineParams), 0, HisoChromaFilterCombineParams, &_WideChromaFilterCombineProc},
+    //li_final_sharpen_noise_filter
+    {ITUNER_FINAL_SHARPEN_BOTH, "li_final_sharpen_noise_filter_both", 1, 0, GET_ARRAY_NUM(SharpeningBothParams), 0, SharpeningBothParams, &_FinalSharpenBothProc},
+    {ITUNER_FINAL_SHARPEN_NOISE, "li_final_sharpen_noise_filter_noise", 1, 0, GET_ARRAY_NUM(SharpeningNoiseParams_A12), 0, SharpeningNoiseParams_A12, &_FinalSharpenNoiseProc},
+    {ITUNER_FINAL_FIR, "li_final_sharpen_noise_filter_sharpen", 1, 0, GET_ARRAY_NUM(SharpeningFirParams), 0, SharpeningFirParams, &_FinalSharpenFirProc},
+    {ITUNER_FINAL_CORING, "li_final_sharpen_noise_filter_sharpen_coring", 1, 0, GET_ARRAY_NUM(SharpeningCoringParams), 0, SharpeningCoringParams, &_FinalSharpenCoringProc},
+    {ITUNER_FINAL_CORING_INDEX_SCALE, "li_final_sharpen_noise_filter_sharpen_coring_index_scale", 1, 0, GET_ARRAY_NUM(SharpeningLevelParams), 0, SharpeningLevelParams, &_FinalCoringIndexScaleProc},
+    {ITUNER_FINAL_MIN_CORING_RESULT, "li_final_sharpen_noise_filter_sharpen_min_coring_result", 1, 0, GET_ARRAY_NUM(SharpeningLevelParams), 0, SharpeningLevelParams, &_FinalMinCoringResultProc},
+    {ITUNER_FINAL_SCALE_CORING, "li_final_sharpen_noise_filter_sharpen_scale_coring", 1, 0, GET_ARRAY_NUM(SharpeningLevelParams), 0, SharpeningLevelParams, &_FinalScaleCoringProc},
+    //high iso
+    {ITUNER_HISO_ANTI_ALIASING_STRENGTH, "hi_anti_aliasing", 1, 0, GET_ARRAY_NUM(AntiAliasingParams), 0, AntiAliasingParams, &_HighIsoAntiAliasingProc},
+    {ITUNER_HISO_CFA_LEAKAGE_FILTER, "hi_cfa_leakage_filter", 1, 0, GET_ARRAY_NUM(CfaLeakageFilterParams), 0, CfaLeakageFilterParams, &_HighIsoCfaLeakageFilterProc},
+    {ITUNER_HISO_DYNAMIC_BAD_PIXEL_CORRECTION, "hi_auto_bad_pixel_correction", 1, 0, GET_ARRAY_NUM(DynamicBadPixelCorrectionParams), 0, DynamicBadPixelCorrectionParams, &_HighIsoDynamicBadPixelCorrectionProc},
+    {ITUNER_HISO_CFA_NOISE_FILTER, "hi_cfa_noise_filter", 1, 0, GET_ARRAY_NUM(CfaNoiseFilterParams), 0, CfaNoiseFilterParams, &_HighIsoCfaNoiseFilterProc},
+    {ITUNER_HISO_GB_GR_MISMATCH, "hi_gb_gr_mismatch_correct", 1, 0, GET_ARRAY_NUM(GbGrMismatchParams), 0, GbGrMismatchParams, &_HisoGbGrMismatchProc},
+    {ITUNER_HISO_DEMOSAIC_FILTER, "hi_demosaic", 1, 0, GET_ARRAY_NUM(DemosaicFilterParams), 0, DemosaicFilterParams, &_HighIsoDemosaicFilterProc},
+    {ITUNER_HISO_CHROMA_MEDIAN_FILTER, "hi_chroma_median_filter", 1, 0, GET_ARRAY_NUM(ChromaMedianFilterParams), 0, ChromaMedianFilterParams, &_HighIsoChromaMedianFilterProc},
+    {ITUNER_HISO_DEFER_COLOR_CORRECTION, "hi_defer_cc", 1, 0, GET_ARRAY_NUM(DeferredColorCorrectionParams), 0, DeferredColorCorrectionParams, &_DeferredColorCorrectionProc},
+    //Hiso Asf
+    {ITUNER_HISO_ASF, "hi_advanced_spatial_filter", 1, 0, GET_ARRAY_NUM(AdvanceSpatialFilterParams_A12), 0, AdvanceSpatialFilterParams_A12, &_HisoAsfProc},
+    {ITUNER_HISO_HIGH_ASF, "hi_high_advanced_spatial_filter", 1, 0, GET_ARRAY_NUM(AdvanceSpatialFilterParams_A12), 0, AdvanceSpatialFilterParams_A12, &_HisoHighAsfProc},
+    {ITUNER_HISO_LOW_ASF, "hi_low_advanced_spatial_filter", 1, 0, GET_ARRAY_NUM(AdvanceSpatialFilterParams_A12), 0, AdvanceSpatialFilterParams_A12, &_HisoLowAsfProc},
+    {ITUNER_HISO_MED_ASF, "hi_med_advanced_spatial_filter", 1, 0, GET_ARRAY_NUM(AdvanceSpatialFilterParams_A12), 0, AdvanceSpatialFilterParams_A12, &_HisoMedAsfProc},
+    {ITUNER_HISO_CHROMA_ASF, "hi_chroma_advanced_spatial_filter", 1, 0, GET_ARRAY_NUM(ChromaAdvanceSpatialFilterParams), 0, ChromaAdvanceSpatialFilterParams, &_HisoChromaAsfProc},
+    //Hiso Sharpen hi_high_
+    {ITUNER_HISO_HIGH_SHARPEN_BOTH, "hi_high_sharpen_noise_filter_both", 1, 0, GET_ARRAY_NUM(SharpeningBothParams), 0, SharpeningBothParams, &_HisoHighSharpenBothProc},
+    {ITUNER_HISO_HIGH_SHARPEN_NOISE, "hi_high_sharpen_noise_filter_noise", 1, 0, GET_ARRAY_NUM(SharpeningNoiseParams), 0, SharpeningNoiseParams, &_HisoHighSharpenNoiseProc},
+    {ITUNER_HISO_HIGH_FIR, "hi_high_sharpen_noise_filter_sharpen", 1, 0, GET_ARRAY_NUM(SharpeningFirParams), 0, SharpeningFirParams, &_HisoHighFirProc},
+    {ITUNER_HISO_HIGH_CORING, "hi_high_sharpen_noise_filter_sharpen_coring", 1, 0, GET_ARRAY_NUM(SharpeningCoringParams), 0, SharpeningCoringParams, &_HisoHighCoringProc},
+    {ITUNER_HISO_HIGH_CORING_INDEX_SCALE, "hi_high_sharpen_noise_filter_sharpen_coring_index_scale", 1, 0, GET_ARRAY_NUM(SharpeningLevelParams), 0, SharpeningLevelParams, &_HisoHighCoringIndexScaleProc},
+    {ITUNER_HISO_HIGH_MIN_CORING_RESULT, "hi_high_sharpen_noise_filter_sharpen_min_coring_result", 1, 0, GET_ARRAY_NUM(SharpeningLevelParams), 0, SharpeningLevelParams, &_HisoHighMinCoringResultProc},
+    {ITUNER_HISO_HIGH_SCALE_CORING, "hi_high_sharpen_noise_filter_sharpen_scale_coring", 1, 0, GET_ARRAY_NUM(SharpeningLevelParams), 0, SharpeningLevelParams, &_HisoHighScaleCoringProc},
+    //Hiso Sharpen hi_med_
+    {ITUNER_HISO_MED_SHARPEN_BOTH, "hi_med_sharpen_noise_filter_both", 1, 0, GET_ARRAY_NUM(SharpeningBothParams), 0, SharpeningBothParams, &_HisoMedSharpenBothProc},
+    {ITUNER_HISO_MED_SHARPEN_NOISE, "hi_med_sharpen_noise_filter_noise", 1, 0, GET_ARRAY_NUM(SharpeningNoiseParams), 0, SharpeningNoiseParams, &_HisoMedSharpenNoiseProc},
+    {ITUNER_HISO_MED_FIR, "hi_med_sharpen_noise_filter_sharpen", 1, 0, GET_ARRAY_NUM(SharpeningFirParams), 0, SharpeningFirParams, &_HisoMedFirProc},
+    {ITUNER_HISO_MED_CORING, "hi_med_sharpen_noise_filter_sharpen_coring", 1, 0, GET_ARRAY_NUM(SharpeningCoringParams), 0, SharpeningCoringParams, &_HisoMedCoringProc},
+    {ITUNER_HISO_MED_CORING_INDEX_SCALE, "hi_med_sharpen_noise_filter_sharpen_coring_index_scale", 1, 0, GET_ARRAY_NUM(SharpeningLevelParams), 0, SharpeningLevelParams, &_HisoMedCoringIndexScaleProc},
+    {ITUNER_HISO_MED_MIN_CORING_RESULT, "hi_med_sharpen_noise_filter_sharpen_min_coring_result", 1, 0, GET_ARRAY_NUM(SharpeningLevelParams), 0, SharpeningLevelParams, &_HisoMedMinCoringResultProc},
+    {ITUNER_HISO_MED_SCALE_CORING, "hi_med_sharpen_noise_filter_sharpen_scale_coring", 1, 0, GET_ARRAY_NUM(SharpeningLevelParams), 0, SharpeningLevelParams, &_HisoMedScaleCoringProc},
+    //Chroma
+    {ITUNER_HISO_CHROMA_FILTER_HIGH, "hi_chroma_filter_high", 1, 0, GET_ARRAY_NUM(ChromaFilterParams), 0, ChromaFilterParams, &_HisoChromaFilterHighProc},
+    {ITUNER_HISO_CHROMA_FILTER_LOW_VERY_LOW, "hi_chroma_filter_low_and_very_low", 1, 0, GET_ARRAY_NUM(ChromaFilterLowAndVeryLowParams), 0, ChromaFilterLowAndVeryLowParams, &_ChromaFilterLowAndVeryLowProc},
+    {ITUNER_HISO_CHROMA_FILTER_PRE, "hi_chroma_filter_pre", 1, 0, GET_ARRAY_NUM(HisoChromaFilterParams), 0, HisoChromaFilterParams, &_HisoChromaFilterProc},
+    {ITUNER_HISO_CHROMA_FILTER_MED, "hi_chroma_filter_med", 1, 0, GET_ARRAY_NUM(HisoChromaFilterParams), 0, HisoChromaFilterParams, &_HisoChromaFilterMedProc},
+    {ITUNER_HISO_CHROMA_FILTER_LOW, "hi_chroma_filter_low", 1, 0, GET_ARRAY_NUM(HisoChromaFilterParams), 0, HisoChromaFilterParams, &_HisoChromaFilterLowProc},
+    {ITUNER_HISO_CHROMA_FILTER_VERY_LOW, "hi_chroma_filter_very_low", 1, 0, GET_ARRAY_NUM(HisoChromaFilterParams), 0, HisoChromaFilterParams, &_HisoChromaFilterVeryLowProc},
+    //Combine
+    {ITUNER_HISO_CHROMA_FILTER_MED_COMBINE, "hi_chroma_filter_med_combine", 1, 0, GET_ARRAY_NUM(HisoChromaFilterCombineParams), 0, HisoChromaFilterCombineParams,  &_HisoChromaFilterMedCombineProc},
+    {ITUNER_HISO_CHROMA_FILTER_LOW_COMBINE, "hi_chroma_filter_low_combine", 1, 0, GET_ARRAY_NUM(HisoChromaFilterCombineParams), 0, HisoChromaFilterCombineParams, &_HisoChromaFilterLowCombineProc},
+    {ITUNER_HISO_CHROMA_FILTER_VERY_LOW_COMBINE, "hi_chroma_filter_very_low_combine", 1, 0, GET_ARRAY_NUM(HisoChromaFilterCombineParams), 0, HisoChromaFilterCombineParams, &_HisoChromaFilterVeryLowCombineProc},
+    {ITUNER_HISO_LUMA_NOISE_COMBINE, "hi_luma_noise_combine", 1, 0, GET_ARRAY_NUM(HisoLumaFilterCombineParams), 0, HisoLumaFilterCombineParams, &_HisoLumaFilterCombineProc},
+    {ITUNER_HISO_LOW_ASF_COMBINE, "hi_low_advanced_spatial_filter_combine", 1, 0, GET_ARRAY_NUM(HisoLumaFilterCombineParams), 0, HisoLumaFilterCombineParams, &_HisoLowASFCombineProc},
+
+    {ITUNER_HISO_FREQ_RECOVER, "hili_luma_mid_high_freq_recover", 1, 0, GET_ARRAY_NUM(HisoFreqRecoverParams), 0, HisoFreqRecoverParams, &_HisoFreqRecoverProc},
+
+    // ByPass FPN
+    {ITUNER_STATIC_BAD_PIXEL_CORRECTION_BY_PASS, "static_bad_pixel_correction_bypass", 1, 0, GET_ARRAY_NUM(StaticBadPixelCorrectionByPassParams), 0, StaticBadPixelCorrectionByPassParams, &_StaticBadPixelCorrectionByPassProc},
+    // ByPass Vignette
+    {ITUNER_VIGNETTE_COMPENSATION_BY_PASS, "vignette_compensation_bypass", 1, 0, GET_ARRAY_NUM(VignetteCompensationByPassParams), 0, VignetteCompensationByPassParams, &_VignetteCompensationByPassProc},
+    // ByPass CaWarp
+    {ITUNER_CHROMA_ABERRATION_INFO_BY_PASS, "chromatic_aberration_correction_bypass", 1, 0, GET_ARRAY_NUM(ChromaAberrationByPassParams), 0, ChromaAberrationByPassParams, &_ChromaAberrationByPassProc},
+    // ByPass Warp and Dzoom
+    {ITUNER_WARP_COMPENSATION_DZOOM_BY_PASS, "warp_compensation_bypass", 1, 0, GET_ARRAY_NUM(WarpCompensationDzoomByPassParams), 0, WarpCompensationDzoomByPassParams, &_WarpCompensationDzoomByPassProc},
+    //{-1}
+    // MO PASS-3 filter
+    {ITUNER_MO_DYNAMIC_BAD_PIXEL_CORRECTION, "mo_auto_bad_pixel_correction", 1, 0, GET_ARRAY_NUM(DynamicBadPixelCorrectionParams), 0, DynamicBadPixelCorrectionParams, &_MoDynamicBadPixelCorrectionProc},
+    {ITUNER_MO_CFA_LEAKAGE_FILTER, "mo_cfa_leakage_filter", 1, 0, GET_ARRAY_NUM(CfaLeakageFilterParams), 0, CfaLeakageFilterParams, &_MoCfaLeakageFilterProc},
+    {ITUNER_MO_CFA_NOISE_FILTER, "mo_cfa_noise_filter", 1, 0, GET_ARRAY_NUM(CfaNoiseFilterParams), 0, CfaNoiseFilterParams, &_MoCfaNoiseFilterProc},
+    {ITUNER_MO_ANTI_ALIASING_STRENGTH, "mo_anti_aliasing", 1, 0, GET_ARRAY_NUM(AntiAliasingParams), 0, AntiAliasingParams, &_MoAntiAliasingProc},
+    {ITUNER_MO_DEMOSAIC_FILTER, "mo_demosaic", 1, 0, GET_ARRAY_NUM(DemosaicFilterParams), 0, DemosaicFilterParams, &_MoDemosaicFilterProc},
+    {ITUNER_MO_GB_GR_MISMATCH, "mo_gb_gr_mismatch_correct", 1, 0, GET_ARRAY_NUM(GbGrMismatchParams), 0, GbGrMismatchParams, &_MoGbGrMismatchProc},
+    {ITUNER_MO_SHP_A_OR_SPATIAL_FILTE_SELECT, "mo_processing_select", 1, 0, GET_ARRAY_NUM(MoShpAOrSpatialFilterSelectParams), 0, MoShpAOrSpatialFilterSelectParams, &_MoShpAOrSpatialFilterSelectproc},
+    {ITUNER_MO_ASF_INFO, "mo_advanced_spatial_filter", 1, 0, GET_ARRAY_NUM(AdvanceSpatialFilterParams_A12), 0, AdvanceSpatialFilterParams_A12, &_MoAdvanceSpatialFilterProc},
+    {ITUNER_MO_CHROMA_FILTER, "mo_chroma_filter", 1, 0, GET_ARRAY_NUM(ChromaFilterParams), 0, ChromaFilterParams, &_MoChromaFilterProc},
+    {ITUNER_MO_CHROMA_MEDIAN_FILTER, "mo_chroma_median_filter", 1, 0, GET_ARRAY_NUM(ChromaMedianFilterParams), 0, ChromaMedianFilterParams, &_MoChromaMedianFilterProc},
+    {ITUNER_MO_SHARPEN_BOTH, "mo_sharpen_noise_filter_both", 1, 0, GET_ARRAY_NUM(SharpeningBothParams), 0, SharpeningBothParams, &_MoSharpenBothProc},
+    {ITUNER_MO_SHARPEN_NOISE, "mo_sharpen_noise_filter_noise", 1, 0, GET_ARRAY_NUM(SharpeningNoiseParams_A12), 0, SharpeningNoiseParams_A12, &_MoSharpenNoiseProc},
+    {ITUNER_MO_FIR, "mo_sharpen_noise_filter_sharpen", 1, 0, GET_ARRAY_NUM(SharpeningFirParams), 0, SharpeningFirParams, &_MoSharpenFirProc},
+    {ITUNER_MO_CORING, "mo_sharpen_noise_filter_sharpen_coring", 1, 0, GET_ARRAY_NUM(SharpeningCoringParams), 0, SharpeningCoringParams, &_MoSharpenCoringProc},
+    {ITUNER_MO_CORING_INDEX_SCALE, "mo_sharpen_noise_filter_sharpen_coring_index_scale", 1, 0, GET_ARRAY_NUM(SharpeningLevelParams), 0, SharpeningLevelParams, &_MoCoringIndexScaleProc},
+    {ITUNER_MO_MIN_CORING_RESULT, "mo_sharpen_noise_filter_sharpen_min_coring_result", 1, 0, GET_ARRAY_NUM(SharpeningLevelParams), 0, SharpeningLevelParams, &_MoMinCoringResultProc},
+    {ITUNER_MO_SCALE_CORING, "mo_sharpen_noise_filter_sharpen_scale_coring", 1, 0, GET_ARRAY_NUM(SharpeningLevelParams), 0, SharpeningLevelParams, &_MoScaleCoringProc},
+};
+
+int TUNE_Rule_Get_Info(Rule_Info_t *RuleInfo)
+{
+    RuleInfo->RegList = &ImgRegs[0];
+    RuleInfo->RegCount = GET_ARRAY_NUM(ImgRegs);
+    return 0;
+}
+
+const char* TUNE_Rule_Lookup_Tuning_Mode_Str(TUNING_MODE_e Tuning_Mode)
+{
+    return _str_tuning_mode[Tuning_Mode];
+}
+
+const char* TUNE_Rule_Lookup_Tuning_Mode_Ext_Str(TUNING_MODE_EXT_e Tuning_Mode_Ext)
+{
+    return _str_tuning_mode_ext[Tuning_Mode_Ext];
+}
+
+TUNING_MODE_e TUNE_Rule_Lookup_Tuning_Mode(const char* Key)
+{
+    int Mode = 0;
+    for (Mode = 0; Mode < IMG_MODE_NUMBER; Mode++) {
+        if (strncmp(Key, _str_tuning_mode[Mode], strlen(_str_tuning_mode[Mode])) == 0) {
+            break;
+        }
+    }
+    if (Mode == IMG_MODE_NUMBER) {
+        RULE_WARF("%s() %d, Unknown Tuning Mode: %s", __func__, __LINE__, Key);
+        return IMG_MODE_VIDEO;
+    }
+    return (TUNING_MODE_e)Mode;
+}
+
+TUNING_MODE_EXT_e TUNE_Rule_Lookup_Tuning_Mode_Ext(const char* Key)
+{
+    int Mode = 0;
+    for (Mode = 0; Mode < TUNING_MODE_EXT_NUMBER; Mode++) {
+        if (strcmp(Key, _str_tuning_mode_ext[Mode]) == 0) {
+            break;
+        }
+    }
+    if (Mode == TUNING_MODE_EXT_NUMBER) {
+        RULE_WARF("%s() %d, Unknown Tuning Mode Ext: %s", __func__, __LINE__, Key);
+        return SINGLE_SHOT;
+    }
+    return (TUNING_MODE_EXT_e)Mode;
+}
+
+
+#define OVER_FLOW_CHECK(INDEX, MAX) \
+    if (INDEX > MAX) {\
+        RULE_ERRF("%s() %d Index = %d, Max = %d", __func__, __LINE__, INDEX, MAX);\
+        K_ASSERT(0);\
+    }
+
+
+static INT64 _System_Proc(int Index, PARAM_s *pParam)
+{
+    ITUNER_SYSTEM_s Data;
+    void *pField[25];
+    AmbaItuner_Get_SystemInfo(&Data);
+	pField[0] = &Data.AmbacamRev;
+	pField[1] = &Data.ChipRev;
+	pField[2] = &Data.SensorId;
+	pField[3] = &Data.UserMode;
+	pField[4] = &Data.TuningMode;
+	pField[5] = &Data.RawPath;
+	pField[6] = &Data.RawWidth;
+	pField[7] = &Data.RawHeight;
+	pField[8] = &Data.RawPitch;
+	pField[9] = &Data.RawResolution;
+	pField[10] = &Data.RawBayer;
+	pField[11] = &Data.MainWidth;
+	pField[12] = &Data.MainHeight;
+	pField[13] = &Data.TuningModeExt;
+	pField[14] = &Data.ExtConfigPath;
+	pField[15] = &Data.InputPicCnt;
+	pField[16] = &Data.CompressedRaw;
+	pField[17] = &Data.SensorReadoutMode;
+	pField[18] = &Data.RawStartX;
+	pField[19] = &Data.RawStartY;
+	pField[20] = &Data.HSubSampleFactorNum;
+	pField[21] = &Data.HSubSampleFactorDen;
+	pField[22] = &Data.VSubSampleFactorNum;
+	pField[23] = &Data.VSubSampleFactorDen;
+	pField[24] = &Data.OutputFilename;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_SystemInfo(&Data);
+    return SKIP_VALID_CHECK;
+}
+
+static INT64 _Internal_Proc(int Index, PARAM_s *pParam)
+{
+    Ituner_Internal_s Data;
+    void *pField[29];
+    AmbaItuner_Get_InternalInfo(&Data);
+    pField[0] = &Data.FpnHighlight;
+    pField[1] = &Data.Internal_u16_1;
+    pField[2] = &Data.Internal_u16_2;
+    pField[3] = &Data.Internal_s32_0;
+    pField[4] = &Data.Internal_s32_1;
+    pField[5] = &Data.Internal_s32_2;
+    pField[6] = &Data.Internal_s32_3;
+    pField[7] = &Data.Internal_s32_4;
+    pField[8] = &Data.Internal_sha_0;
+    pField[9] = &Data.Internal_sha_1;
+    pField[10] = &Data.Internal_sha_2;
+    pField[11] = &Data.Internal_sha_3;
+    pField[12] = &Data.Internal_sha_4;
+    pField[13] = &Data.Internal_sha_5;
+    pField[14] = &Data.Internal_shb_0;
+    pField[15] = &Data.Internal_shb_1;
+    pField[16] = &Data.Internal_shb_2;
+    pField[17] = &Data.Internal_shb_3;
+    pField[18] = &Data.Internal_shb_4;
+    pField[19] = &Data.Internal_shb_5;
+    pField[20] = &Data.Internal_wm_0;
+    pField[21] = &Data.Internal_wm_1;
+    pField[22] = &Data.Internal_wm_2;
+    pField[23] = &Data.Internal_wm_3;
+    pField[24] = &Data.NOT_CUSTOMER_VISIBLE_FULL_RAW_W;
+    pField[25] = &Data.NOT_CUSTOMER_VISIBLE_FULL_MAIN_W;
+    pField[26] = &Data.Internal_hdr_0;
+    pField[27] = &Data.Internal_hdr_1;
+    pField[28] = &Data.DiagMode;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_InternalInfo(&Data);
+    return SKIP_VALID_CHECK;
+}
+
+static INT64 _AaaFunctionProc(int Index, PARAM_s *pParam)
+{
+    AAA_FUNC_s Data;
+    void *pField[GET_ARRAY_NUM(AaaFunctionParams)];
+    AmbaItuner_Get_AAAFunction(&Data);
+    pField[0] = &Data.AeOp;
+    pField[1] = &Data.AwbOp;
+    pField[2] = &Data.AfOp;
+    pField[3] = &Data.AdjOp;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_AAAFunction(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _AeInfoProc(int Index, PARAM_s *pParam)
+{
+    IMG_EXP_s Data;
+    void *pField[GET_ARRAY_NUM(AeInfoParams)];
+    AmbaItuner_Get_AeInfo(&Data);
+    pField[0] = &Data.AgcIndex;
+    pField[1] = &Data.ShutterIndex;
+    pField[2] = &Data.IrisIndex;
+    pField[3] = &Data.Dgain;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_AeInfo(&Data);
+    return SKIP_VALID_CHECK;
+}
+
+static INT64 _AeStatisticsInfoProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_ae_stat_info_t Data;
+    void *pField[GET_ARRAY_NUM(AeStatisticsInfoParams)];
+    AmbaItuner_Get_AeStatisticsInfo(&Data);
+    pField[0] = &Data.AeTileNumCol;
+    pField[1] = &Data.AeTileNumRow;
+    pField[2] = &Data.AeTileColStart;
+    pField[3] = &Data.AeTileRowStart;
+    pField[4] = &Data.AeTileWidth;
+    pField[5] = &Data.AeTileHeight;
+    pField[6] = &Data.AePixMinValue;
+    pField[7] = &Data.AePixMaxValue;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_AeStatisticsInfo(&Data);
+    return (0x1ULL << Index);
+}
+static INT64 _AwbStatisticsInfoProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_awb_stat_info_t Data;
+    AmbaItuner_Get_AwbStatisticsInfo(&Data);
+    void *pField[GET_ARRAY_NUM(AwbStatisticsInfoParams)];
+    pField[0] = &Data.AwbTileNumCol;
+    pField[1] = &Data.AwbTileNumRow;
+    pField[2] = &Data.AwbTileColStart;
+    pField[3] = &Data.AwbTileRowStart;
+    pField[4] = &Data.AwbTileWidth;
+    pField[5] = &Data.AwbTileHeight;
+    pField[6] = &Data.AwbTileActiveWidth;
+    pField[7] = &Data.AwbTileActiveHeight;
+    pField[8] = &Data.AwbPixMinValue;
+    pField[9] = &Data.AwbPixMaxValue;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_AwbStatisticsInfo(&Data);
+    return (0x1ULL << Index);
+}
+static INT64 _AfStatisticsInfoProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_af_stat_info_t Data;
+    void *pField[GET_ARRAY_NUM(AfStatisticsInfoParams)];
+    AmbaItuner_Get_AfStatisticsInfo(&Data);
+    pField[0] = &Data.AfTileNumCol;
+    pField[1] = &Data.AfTileNumRow;
+    pField[2] = &Data.AfTileColStart;
+    pField[3] = &Data.AfTileRowStart;
+    pField[4] = &Data.AfTileWidth;
+    pField[5] = &Data.AfTileHeight;
+    pField[6] = &Data.AfTileActiveWidth;
+    pField[7] = &Data.AfTileActiveHeight;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_AfStatisticsInfo(&Data);
+    return (0x1ULL << Index);
+}
+static INT64 _StaticBadPixelCorrectionProc(int Index, PARAM_s *pParam)
+{
+    ITUNER_FPN_s Data;
+    void *pField[GET_ARRAY_NUM(StaticBadPixelCorrectionParams)];
+    AmbaItuner_Get_StaticBadPixelCorrection(&Data);
+    pField[0] = &Data.Enable;
+    pField[1] = &Data.CalibVersion;
+    pField[2] = &Data.CailbVinStartX;
+    pField[3] = &Data.CailbVinStartY;
+    pField[4] = &Data.CailbVinWidth;
+    pField[5] = &Data.CailbVinHeight;
+    pField[6] = &Data.CailbVinHSubSampleFactorNum;
+    pField[7] = &Data.CailbVinHSubSampleFactorDen;
+    pField[8] = &Data.CailbVinVSubSampleFactorNum;
+    pField[9] = &Data.CailbVinVSubSampleFactorDen;
+    pField[10] = &Data.MapPath;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_StaticBadPixelCorrection(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+static INT64 _StaticBadPixelCorrectionByPassProc(int Index, PARAM_s *pParam)
+{
+    ITUNER_FPN_BYPASS_s Data;
+    void *pField[GET_ARRAY_NUM(StaticBadPixelCorrectionByPassParams)];
+    AmbaItuner_Get_StaticBadPixelCorrectionByPass(&Data);
+    pField[0] = &Data.Enable;
+    pField[1] = &Data.PixelMapWidth;
+    pField[2] = &Data.PixelMapHeight;
+    pField[3] = &Data.PixelMapPitch;
+    pField[4] = &Data.MapPath;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_StaticBadPixelCorrectionByPass(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+static INT64 _VignetteCompensationProc(int Index, PARAM_s *pParam)
+{
+    ITUNER_VIGNETTE_s Data;
+    void *pField[GET_ARRAY_NUM(VignetteCompensationParams)];
+    AmbaItuner_Get_VignetteCompensation(&Data);
+    pField[0] = &Data.Enable;
+    pField[1] = &Data.GainShift;
+    pField[2] = &Data.StrengthEffectMode;
+    pField[3] = &Data.Strength;
+    pField[4] = &Data.CalibVersion;
+    pField[5] = &Data.CalibTableWidth;
+    pField[6] = &Data.CalibTableHeight;
+    pField[7] = &Data.CalibVinStartX;
+    pField[8] = &Data.CalibVinStartY;
+    pField[9] = &Data.CalibVinWidth;
+    pField[10] = &Data.CalibVinHeight;
+    pField[11] = &Data.CailbVinHSubSampleFactorNum;
+    pField[12] = &Data.CailbVinHSubSampleFactorDen;
+    pField[13] = &Data.CailbVinVSubSampleFactorNum;
+    pField[14] = &Data.CailbVinVSubSampleFactorDen;
+    pField[15] = &Data.CalibTablePath;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_VignetteCompensation(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _VignetteCompensationByPassProc(int Index, PARAM_s *pParam)
+{
+    ITUNER_VIGNETTE_BYPASS_s Data;
+    void *pField[GET_ARRAY_NUM(VignetteCompensationByPassParams)];
+    AmbaItuner_Get_VignetteCompensationByPass(&Data);
+    pField[0] = &Data.Enable;
+    pField[1] = &Data.GainShift;
+    pField[2] = &Data.GainPath;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_VignetteCompensationByPass(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+static INT64 _WarpCompensationProc(int Index, PARAM_s *pParam)
+{
+    ITUNER_WARP_s Data;
+    void *pField[GET_ARRAY_NUM(WarpCompensationParams)];
+    AmbaItuner_Get_WarpCompensation(&Data);
+    pField[0] = &Data.Enable;
+    pField[1] = &Data.CalibVersion;
+    pField[2] = &Data.HorizontalGridNumber;
+    pField[3] = &Data.VerticalGridNumber;
+    pField[4] = &Data.TileWidthExponent;
+    pField[5] = &Data.TileHeightExponent;
+    pField[6] = &Data.VinSensorStartX;
+    pField[7] = &Data.VinSensorStartY;
+    pField[8] = &Data.VinSensorWidth;
+    pField[9] = &Data.VinSensorHeight;
+    pField[10] = &Data.VinSensorHSubSampleFactorNum;
+    pField[11] = &Data.VinSensorHSubSampleFactorDen;
+    pField[12] = &Data.VinSensorVSubSampleFactorNum;
+    pField[13] = &Data.VinSensorVSubSampleFactorDen;
+    pField[14] = &Data.WarpGridTablePath;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_WarpCompensation(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _DzoomProc(int Index, PARAM_s *pParam)
+{
+    ITUNER_DZOOM_s Data;
+    void *pField[GET_ARRAY_NUM(DzoomParams)];
+    AmbaItuner_Get_Dzoom(&Data);
+    pField[0] = &Data.Enable;
+    pField[1] = &Data.ActualLeftTopX;
+    pField[2] = &Data.ActualLeftTopY;
+    pField[3] = &Data.ActualRightBotX;
+    pField[4] = &Data.ActualRightBotY;
+    pField[5] = &Data.HorSkewPhaseInc;
+    pField[6] = &Data.DummyWindowLeftX;
+    pField[7] = &Data.DummyWindowTopY;
+    pField[8] = &Data.DummyWindowWidth;
+    pField[9] = &Data.DummyWindowHeight;
+    pField[10] = &Data.CfaOutputWidth;
+    pField[11] = &Data.CfaOutputHeight;
+    pField[12] = &Data.R2rOutputWidth;
+    pField[13] = &Data.R2rOutputHeigh;
+
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_Dzoom(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _WarpCompensationDzoomByPassProc(int Index, PARAM_s *pParam)
+{
+    ITUNER_WARP_DZOOM_BYPASS_s Data;
+    void *pField[GET_ARRAY_NUM(WarpCompensationDzoomByPassParams)];
+    AmbaItuner_Get_WarpCompensationDzoomByPass(&Data);
+    // Warp Part
+    //pField[0] = &Data.Enable;
+    pField[0] = &Data.WarpControl;
+    pField[1] = &Data.GridArrayWidth;//
+    pField[2] = &Data.GridArrayHeight;//
+    pField[3] = &Data.HorzGridSpacingExponent;//
+    pField[4] = &Data.VertGridSpacingExponent;//
+    pField[5] = &Data.VertWarpEnable;
+    pField[6] = &Data.VertWarpGridArrayWidth;
+    pField[7] = &Data.VertWarpGridArrayHeight;
+    pField[8] = &Data.VertWarpHorzGridSpacingExponent;
+    pField[9] = &Data.VertWarpVertGridSpacingExponent;
+    pField[10] = &Data.WarpHorizontalTablePath;//
+    pField[11] = &Data.WarpVerticalTablePath;
+
+    // Dzoom Part
+    //pField[13] = &Data.DzoomEnable;
+    pField[12] = &Data.ActualLeftTopX;
+    pField[13] = &Data.ActualLeftTopY;
+    pField[14] = &Data.ActualRightBotX;
+    pField[15] = &Data.ActualRightBotY;
+    pField[16] = &Data.ZoomX;
+    pField[17] = &Data.ZoomY;
+    pField[18] = &Data.XCenterOffset;
+    pField[19] = &Data.YCenterOffset;
+    pField[20] = &Data.HorSkewPhaseInc;
+    //pField[21] = &Data.ForceV4tapDisable;
+    pField[21] = &Data.DummyWindowXLeft;
+    pField[22] = &Data.DummyWindowYTop;
+    pField[23] = &Data.DummyWindowWidth;
+    pField[24] = &Data.DummyWindowHeight;
+    pField[25] = &Data.CfaOutputWidth;
+    pField[26] = &Data.CfaOutputHeight;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_WarpCompensationDzoomByPass(&Data);
+    if ((Index == 0) && (Data.WarpControl == 0)) {
+        return (0x1ULL << 0) | //WarpControl
+               (0x1ULL << 1) | //GridArrayWidth
+               (0x1ULL << 2) | //GridArrayHeight
+               (0x1ULL << 3) | //HorzGridSpacingExponent
+               (0x1ULL << 4) | //VertGridSpacingExponent
+               (0x1ULL << 10); //WarpHorizontalTablePath
+    } else if ((Index == 5) && (Data.VertWarpEnable == 0)) {
+        return (0x1ULL << 5) | //VertWarpEnable
+               (0x1ULL << 6) | //VertWarpGridArrayWidth
+               (0x1ULL << 7) | //VertWarpGridArrayHeight
+               (0x1ULL << 8) | //VertWarpHorzGridSpacingExponent
+               (0x1ULL << 9) | //VertWarpVertGridSpacingExponent
+               (0x1ULL << 11); //WarpVerticalTablePath
+    }
+    return (0x1ULL << Index);
+}
+
+static INT64 _SensorInputProc(int Index, PARAM_s *pParam)
+{
+    ITUNER_SENSOR_INPUT_s Data;
+    void *pField[GET_ARRAY_NUM(SensorInputParams)];
+    AmbaItuner_Get_SensorInputInfo(&Data);
+    pField[0] = &Data.SensorId;
+    pField[1] = &Data.BayerPattern;
+    pField[2] = &Data.SensorResolution;
+    pField[3] = &Data.ReadoutMode;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_SensorInputInfo(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _StaticBlackLevelProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_black_correction_t Data;
+    void *pField[GET_ARRAY_NUM(StaticBlackLevelParams)];
+    AmbaItuner_Get_StaticBlackLevel(&Data);
+    pField[0] = &Data.BlackR;
+    pField[1] = &Data.BlackGr;
+    pField[2] = &Data.BlackGb;
+    pField[3] = &Data.BlackB;
+    //pField[4] = &Data.DefMethod;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_StaticBlackLevel(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _DeferredBlackLevelProc(int Index, PARAM_s *pParam)
+{
+
+    amba_img_dsp_def_blc_t Data;
+    void *pField[GET_ARRAY_NUM(DeferredBlackLevelParams)];
+    AmbaItuner_Get_DeferredBlackLevel(&Data);
+
+    pField[0] = &Data.Enb;
+
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_DeferredBlackLevel(&Data);
+
+    return (0x1ULL << Index);
+}
+
+static INT64 _DynamicBadPixelCorrectionProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_dbp_correction_t Data;
+    void *pField[GET_ARRAY_NUM(DynamicBadPixelCorrectionParams)];
+    AmbaItuner_Get_DynamicBadPixelCorrection(&Data);
+    pField[0] = &Data.Enb;
+    pField[1] = &Data.HotPixelStrength;
+    pField[2] = &Data.DarkPixelStrength;
+    pField[3] = &Data.CorrectionMethod;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_DynamicBadPixelCorrection(&Data);
+    return ((Index == 0) && (Data.Enb == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _HighIsoDynamicBadPixelCorrectionProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_dbp_correction_t Data;
+    void *pField[GET_ARRAY_NUM(DynamicBadPixelCorrectionParams)];
+    AmbaItuner_Get_HisoDynamicBadPixelCorrection(&Data);
+    pField[0] = &Data.Enb;
+    pField[1] = &Data.HotPixelStrength;
+    pField[2] = &Data.DarkPixelStrength;
+    pField[3] = &Data.CorrectionMethod;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoDynamicBadPixelCorrection(&Data);
+    return ((Index == 0) && (Data.Enb == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _CfaLeakageFilterProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_cfa_leakage_filter_t Data;
+    void *pField[GET_ARRAY_NUM(CfaLeakageFilterParams)];
+    AmbaItuner_Get_CfaLeakageFilter(&Data);
+    pField[0] = &Data.Enb;
+    pField[1] = &Data.AlphaRR;
+    pField[2] = &Data.AlphaRB;
+    pField[3] = &Data.AlphaBR;
+    pField[4] = &Data.AlphaBB;
+    pField[5] = &Data.SaturationLevel;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_CfaLeakageFilter(&Data);
+    return ((Index == 0) && (Data.Enb == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _HighIsoCfaLeakageFilterProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_cfa_leakage_filter_t Data;
+    void *pField[GET_ARRAY_NUM(CfaLeakageFilterParams)];
+    AmbaItuner_Get_HisoCfaLeakageFilter(&Data);
+    pField[0] = &Data.Enb;
+    pField[1] = &Data.AlphaRR;
+    pField[2] = &Data.AlphaRB;
+    pField[3] = &Data.AlphaBR;
+    pField[4] = &Data.AlphaBB;
+    pField[5] = &Data.SaturationLevel;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoCfaLeakageFilter(&Data);
+    return ((Index == 0) && (Data.Enb == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _CfaNoiseFilterProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_cfa_noise_filter_t Data;
+    void *pField[GET_ARRAY_NUM(CfaNoiseFilterParams)];
+    AmbaItuner_Get_CfaNoiseFilter(&Data);
+    pField[0] = &Data.Enb;
+    pField[1] = &Data.NoiseLevel[0];
+    pField[2] = &Data.NoiseLevel[1];
+    pField[3] = &Data.NoiseLevel[2];
+    pField[4] = &Data.OriginalBlendStr[0];
+    pField[5] = &Data.OriginalBlendStr[1];
+    pField[6] = &Data.OriginalBlendStr[2];
+    pField[7] = &Data.ExtentRegular[0];
+    pField[8] = &Data.ExtentRegular[1];
+    pField[9] = &Data.ExtentRegular[2];
+    pField[10] = &Data.ExtentFine[0];
+    pField[11] = &Data.ExtentFine[1];
+    pField[12] = &Data.ExtentFine[2];
+    pField[13] = &Data.StrengthFine[0];
+    pField[14] = &Data.StrengthFine[1];
+    pField[15] = &Data.StrengthFine[2];
+    pField[16] = &Data.SelectivityRegular;
+    pField[17] = &Data.SelectivityFine;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_CfaNoiseFilter(&Data);
+    return ((Index == 0) && (Data.Enb == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _HighIsoCfaNoiseFilterProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_cfa_noise_filter_t Data;
+    void *pField[GET_ARRAY_NUM(CfaNoiseFilterParams)];
+    AmbaItuner_Get_HisoCfaNoiseFilter(&Data);
+    pField[0] = &Data.Enb;
+    pField[1] = &Data.NoiseLevel[0];
+    pField[2] = &Data.NoiseLevel[1];
+    pField[3] = &Data.NoiseLevel[2];
+    pField[4] = &Data.OriginalBlendStr[0];
+    pField[5] = &Data.OriginalBlendStr[1];
+    pField[6] = &Data.OriginalBlendStr[2];
+    pField[7] = &Data.ExtentRegular[0];
+    pField[8] = &Data.ExtentRegular[1];
+    pField[9] = &Data.ExtentRegular[2];
+    pField[10] = &Data.ExtentFine[0];
+    pField[11] = &Data.ExtentFine[1];
+    pField[12] = &Data.ExtentFine[2];
+    pField[13] = &Data.StrengthFine[0];
+    pField[14] = &Data.StrengthFine[1];
+    pField[15] = &Data.StrengthFine[2];
+    pField[16] = &Data.SelectivityRegular;
+    pField[17] = &Data.SelectivityFine;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoCfaNoiseFilter(&Data);
+    return ((Index == 0) && (Data.Enb == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _AntiAliasingProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_anti_aliasing_t Data;
+    void *pField[GET_ARRAY_NUM(AntiAliasingParams)];
+    AmbaItuner_Get_AntiAliasingStrength(&Data);
+    pField[0] = &Data.Enb;
+    pField[1] = &Data.Thresh;
+    pField[2] = &Data.LogFractionalCorrect;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_AntiAliasingStrength(&Data);
+    return ((Index == 0) && (Data.Enb == 0||Data.Enb != 4)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _HighIsoAntiAliasingProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_anti_aliasing_t Data;
+    void *pField[GET_ARRAY_NUM(AntiAliasingParams)];
+    AmbaItuner_Get_HisoAntiAliasingStrength(&Data);
+    pField[0] = &Data.Enb;
+    pField[1] = &Data.Thresh;
+    pField[2] = &Data.LogFractionalCorrect;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    return ((Index == 0) && (Data.Enb == 0||Data.Enb != 4)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _GlobalDgainProc(int Index, PARAM_s *pParam)
+{
+    UINT32 GlobalDgain;
+    AmbaItuner_Get_GlobalDgain(&GlobalDgain);
+    TUNE_Parser_Param_Proc(pParam, &GlobalDgain);
+    AmbaItuner_Set_GlobalDgain(GlobalDgain);
+	return (0x1ULL << Index);
+}
+
+static INT64 _WbGainProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_wb_gain_t Data;
+    void *pField[GET_ARRAY_NUM(WbGainParams)];
+    AmbaItuner_Get_WbGain(&Data);
+    pField[0] = &Data.GainR;
+    pField[1] = &Data.GainG;
+    pField[2] = &Data.GainB;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_WbGain(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _DgainSaturationLevelProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_dgain_saturation_t Data;
+    void *pField[GET_ARRAY_NUM(DgainSaturationLevelParams)];
+    AmbaItuner_Get_DgainSaturationLevel(&Data);
+    pField[0] = &Data.LevelRed;
+    pField[1] = &Data.LevelGreenEven;
+    pField[2] = &Data.LevelGreenOdd;
+    pField[3] = &Data.LevelBlue;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_DgainSaturationLevel(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _LocalExposureProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_local_exposure_t Data;
+    void *pField[GET_ARRAY_NUM(LocalExposureParams)];
+    AmbaItuner_Get_LocalExposure(&Data);
+    pField[0] = &Data.Enb;
+    pField[1] = &Data.Radius;
+    pField[2] = &Data.LumaWeightRed;
+    pField[3] = &Data.LumaWeightGreen;
+    pField[4] = &Data.LumaWeightBlue;
+    pField[5] = &Data.LumaWeightShift;
+    pField[6] = &Data.GainCurveTable;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_LocalExposure(&Data);
+    return ((Index == 0) && (Data.Enb == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _ColorCorrectionProc(int Index, PARAM_s *pParam)
+{
+    ITUNER_COLOR_CORRECTION_s Data;
+    void *pField[GET_ARRAY_NUM(ColorCorrectionParams)];
+    AmbaItuner_Get_ColorCorrection(&Data);
+    pField[0] = &Data.RegPath;
+    pField[1] = &Data.ThreeDPath;
+    //pField[2] = &Data.SecCcPath;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_ColorCorrection(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _ToneCurveProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_tone_curve_t Data;
+    void *pField[GET_ARRAY_NUM(ToneCurveParams)];
+    AmbaItuner_Get_ToneCurve(&Data);
+    pField[0] = &Data.ToneCurveRed;
+    pField[1] = &Data.ToneCurveGreen;
+    pField[2] = &Data.ToneCurveBlue;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_ToneCurve(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _RgbToYuvMatrixProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_rgb_to_yuv_t Data;
+    void *pField[GET_ARRAY_NUM(RgbToYuvMatrixParams)];
+    AmbaItuner_Get_RgbToYuvMatrix(&Data);
+    pField[0] = &Data.MatrixValues[0];
+    pField[1] = &Data.MatrixValues[1];
+    pField[2] = &Data.MatrixValues[2];
+    pField[3] = &Data.MatrixValues[3];
+    pField[4] = &Data.MatrixValues[4];
+    pField[5] = &Data.MatrixValues[5];
+    pField[6] = &Data.MatrixValues[6];
+    pField[7] = &Data.MatrixValues[7];
+    pField[8] = &Data.MatrixValues[8];
+    pField[9] = &Data.YOffset;
+    pField[10] = &Data.UOffset;
+    pField[11] = &Data.VOffset;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_RgbToYuvMatrix(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _ChromaScaleProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_chroma_scale_t Data;
+    void *pField[GET_ARRAY_NUM(ChromaScaleParams)];
+    AmbaItuner_Get_ChromaScale(&Data);
+    pField[0] = &Data.Enb;
+    pField[1] = &Data.GainCurve;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_ChromaScale(&Data);
+    return ((Index == 0) && (Data.Enb == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _ChromaMedianFilterProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_chroma_median_filter_t Data;
+    void *pField[GET_ARRAY_NUM(ChromaMedianFilterParams)];
+    AmbaItuner_Get_ChromaMedianFilter(&Data);
+    pField[0] = &Data.Enable;
+    pField[1] = &Data.CbAdaptiveStrength;
+    pField[2] = &Data.CrAdaptiveStrength;
+    pField[3] = &Data.CbNonAdaptiveStrength;
+    pField[4] = &Data.CrNonAdaptiveStrength;
+    pField[5] = &Data.CbAdaptiveAmount;
+    pField[6] = &Data.CrAdaptiveAmount;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_ChromaMedianFilter(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _HighIsoChromaMedianFilterProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_chroma_median_filter_t Data;
+    void *pField[GET_ARRAY_NUM(ChromaMedianFilterParams)];
+    AmbaItuner_Get_HisoChromaMedianFilter(&Data);
+    pField[0] = &Data.Enable;
+    pField[1] = &Data.CbAdaptiveStrength;
+    pField[2] = &Data.CrAdaptiveStrength;
+    pField[3] = &Data.CbNonAdaptiveStrength;
+    pField[4] = &Data.CrNonAdaptiveStrength;
+    pField[5] = &Data.CbAdaptiveAmount;
+    pField[6] = &Data.CrAdaptiveAmount;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoChromaMedianFilter(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _DemosaicFilterProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_demosaic_t Data;
+    void *pField[GET_ARRAY_NUM(DemosaicFilterParams)];
+    AmbaItuner_Get_DemosaicFilter(&Data);
+    pField[0] = &Data.ActivityThresh;
+    pField[1] = &Data.ActivityDifferenceThresh;
+    pField[2] = &Data.GradClipThresh;
+    pField[3] = &Data.GradNoiseThresh;
+//    pField[4] = &Data.ZipperNoiseDifferenceMultThresh;
+//    pField[5] = &Data.ZipperNoiseDifferenceAddThresh;
+//    pField[6] = &Data.BlackWhiteResolutionDetail;
+//    pField[7] = &Data.ClampDirectionalCandidates;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_DemosaicFilter(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _HighIsoDemosaicFilterProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_demosaic_t Data;
+    void *pField[GET_ARRAY_NUM(DemosaicFilterParams)];
+    AmbaItuner_Get_HisoDemosaicFilter(&Data);
+    pField[0] = &Data.ActivityThresh;
+    pField[1] = &Data.ActivityDifferenceThresh;
+    pField[2] = &Data.GradClipThresh;
+    pField[3] = &Data.GradNoiseThresh;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoDemosaicFilter(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _SharpenBothProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_sharpen_both_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningBothParams)];
+    AmbaItuner_Get_SharpenBoth(&Data);
+    pField[0] = &Data.Enable;
+    pField[1] = &Data.Mode;
+    pField[2] = &Data.EdgeThresh;
+    pField[3] = &Data.WideEdgeDetect;
+    pField[4] = &Data.MaxChangeUp5x5;
+    pField[5] = &Data.MaxChangeDown5x5;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_SharpenBoth(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _FinalSharpenBothProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_sharpen_both_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningBothParams)];
+    AmbaItuner_Get_FinalSharpenBoth(&Data);
+    pField[0] = &Data.Enable;
+    pField[1] = &Data.Mode;
+    pField[2] = &Data.EdgeThresh;
+    pField[3] = &Data.WideEdgeDetect;
+    pField[4] = &Data.MaxChangeUp5x5;
+    pField[5] = &Data.MaxChangeDown5x5;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_FinalSharpenBoth(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _HisoHighSharpenBothProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_sharpen_both_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningBothParams)];
+    AmbaItuner_Get_HisoHighSharpenBoth(&Data);
+    pField[0] = &Data.Enable;
+    pField[1] = &Data.Mode;
+    pField[2] = &Data.EdgeThresh;
+    pField[3] = &Data.WideEdgeDetect;
+    pField[4] = &Data.MaxChangeUp5x5;
+    pField[5] = &Data.MaxChangeDown5x5;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoHighSharpenBoth(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+
+static INT64 _HisoMedSharpenBothProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_sharpen_both_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningBothParams)];
+    AmbaItuner_Get_HisoMedSharpenBoth(&Data);
+    pField[0] = &Data.Enable;
+    pField[1] = &Data.Mode;
+    pField[2] = &Data.EdgeThresh;
+    pField[3] = &Data.WideEdgeDetect;
+    pField[4] = &Data.MaxChangeUp5x5;
+    pField[5] = &Data.MaxChangeDown5x5;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoMedSharpenBoth(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _SharpenNoiseProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_sharpen_noise_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningNoiseParams_A12)];
+    AmbaItuner_Get_SharpenNoise(&Data);
+    pField[0] = &Data.SpatialFir.Specify;
+    pField[1] = &Data.SpatialFir.StrengthIso;
+    pField[2] = &Data.SpatialFir.StrengthDir;
+    pField[3] = &Data.SpatialFir.PerDirFirDirAmounts;
+    pField[4] = &Data.SpatialFir.PerDirFirDirStrengths;
+    pField[5] = &Data.SpatialFir.PerDirFirIsoStrengths;
+    pField[6] = &Data.SpatialFir.Coefs;
+    pField[7] = &Data.MaxChangeDown;
+    pField[8] = &Data.MaxChangeUp;
+    pField[9] = &Data.LevelStrAdjust.High;
+    pField[10] = &Data.LevelStrAdjust.HighDelta;
+    pField[11] = &Data.LevelStrAdjust.HighStrength;
+    pField[12] = &Data.LevelStrAdjust.MidStrength;
+    pField[13] = &Data.LevelStrAdjust.Low;
+    pField[14] = &Data.LevelStrAdjust.LowDelta;
+    pField[15] = &Data.LevelStrAdjust.LowStrength;
+    pField[16] = &Data.LevelStrAdjustNotT0T1LevelBased;
+    pField[17] = &Data.T0;
+    pField[18] = &Data.T1;
+    pField[19] = &Data.AlphaMin;
+    pField[20] = &Data.AlphaMax;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_SharpenNoise(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _FinalSharpenNoiseProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_sharpen_noise_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningNoiseParams_A12)];
+    AmbaItuner_Get_FinalSharpenNoise(&Data);
+    pField[0] = &Data.SpatialFir.Specify;
+    pField[1] = &Data.SpatialFir.StrengthIso;
+    pField[2] = &Data.SpatialFir.StrengthDir;
+    pField[3] = &Data.SpatialFir.PerDirFirDirAmounts;
+    pField[4] = &Data.SpatialFir.PerDirFirDirStrengths;
+    pField[5] = &Data.SpatialFir.PerDirFirIsoStrengths;
+    pField[6] = &Data.SpatialFir.Coefs;
+    pField[7] = &Data.MaxChangeDown;
+    pField[8] = &Data.MaxChangeUp;
+    pField[9] = &Data.LevelStrAdjust.High;
+    pField[10] = &Data.LevelStrAdjust.HighDelta;
+    pField[11] = &Data.LevelStrAdjust.HighStrength;
+    pField[12] = &Data.LevelStrAdjust.MidStrength;
+    pField[13] = &Data.LevelStrAdjust.Low;
+    pField[14] = &Data.LevelStrAdjust.LowDelta;
+    pField[15] = &Data.LevelStrAdjust.LowStrength;
+    pField[16] = &Data.LevelStrAdjustNotT0T1LevelBased;
+    pField[17] = &Data.T0;
+    pField[18] = &Data.T1;
+    pField[19] = &Data.AlphaMin;
+    pField[20] = &Data.AlphaMax;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_FinalSharpenNoise(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _HisoHighSharpenNoiseProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_sharpen_noise_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningNoiseParams)];
+    AmbaItuner_Get_HisoHighSharpenNoise(&Data);
+    pField[0] = &Data.SpatialFir.Specify;
+    pField[1] = &Data.SpatialFir.StrengthIso;
+    pField[2] = &Data.SpatialFir.StrengthDir;
+    pField[3] = &Data.SpatialFir.PerDirFirDirAmounts;
+    pField[4] = &Data.SpatialFir.PerDirFirDirStrengths;
+    pField[5] = &Data.SpatialFir.PerDirFirIsoStrengths;
+    pField[6] = &Data.SpatialFir.Coefs;
+    pField[7] = &Data.MaxChangeDown;
+    pField[8] = &Data.MaxChangeUp;
+    pField[9] = &Data.LevelStrAdjust.High;
+    pField[10] = &Data.LevelStrAdjust.HighDelta;
+    pField[11] = &Data.LevelStrAdjust.HighStrength;
+    pField[12] = &Data.LevelStrAdjust.MidStrength;
+    pField[13] = &Data.LevelStrAdjust.Low;
+    pField[14] = &Data.LevelStrAdjust.LowDelta;
+    pField[15] = &Data.LevelStrAdjust.LowStrength;
+    //pField[16] = &Data.LevelStrAdjust.Method;
+
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoHighSharpenNoise(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _HisoMedSharpenNoiseProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_sharpen_noise_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningNoiseParams)];
+    AmbaItuner_Get_HisoMedSharpenNoise(&Data);
+    pField[0] = &Data.SpatialFir.Specify;
+    pField[1] = &Data.SpatialFir.StrengthIso;
+    pField[2] = &Data.SpatialFir.StrengthDir;
+    pField[3] = &Data.SpatialFir.PerDirFirDirAmounts;
+    pField[4] = &Data.SpatialFir.PerDirFirDirStrengths;
+    pField[5] = &Data.SpatialFir.PerDirFirIsoStrengths;
+    pField[6] = &Data.SpatialFir.Coefs;
+    pField[7] = &Data.MaxChangeDown;
+    pField[8] = &Data.MaxChangeUp;
+    pField[9] = &Data.LevelStrAdjust.High;
+    pField[10] = &Data.LevelStrAdjust.HighDelta;
+    pField[11] = &Data.LevelStrAdjust.HighStrength;
+    pField[12] = &Data.LevelStrAdjust.MidStrength;
+    pField[13] = &Data.LevelStrAdjust.Low;
+    pField[14] = &Data.LevelStrAdjust.LowDelta;
+    pField[15] = &Data.LevelStrAdjust.LowStrength;
+    //pField[16] = &Data.LevelStrAdjust.Method;
+
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoMedSharpenNoise(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _SharpenFirProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_fir_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningFirParams)];
+    AmbaItuner_Get_Fir(&Data);
+    pField[0] = &Data.Specify;
+    pField[1] = &Data.StrengthIso;
+    pField[2] = &Data.StrengthDir;
+    pField[3] = &Data.PerDirFirDirAmounts;
+    pField[4] = &Data.PerDirFirDirStrengths;
+    pField[5] = &Data.PerDirFirIsoStrengths;
+    pField[6] = &Data.Coefs;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_Fir(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _FinalSharpenFirProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_fir_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningFirParams)];
+    AmbaItuner_Get_FinalFir(&Data);
+    pField[0] = &Data.Specify;
+    pField[1] = &Data.StrengthIso;
+    pField[2] = &Data.StrengthDir;
+    pField[3] = &Data.PerDirFirDirAmounts;
+    pField[4] = &Data.PerDirFirDirStrengths;
+    pField[5] = &Data.PerDirFirIsoStrengths;
+    pField[6] = &Data.Coefs;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_FinalFir(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _HisoHighFirProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_fir_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningFirParams)];
+    AmbaItuner_Get_HisoHighFir(&Data);
+    pField[0] = &Data.Specify;
+    pField[1] = &Data.StrengthIso;
+    pField[2] = &Data.StrengthDir;
+    pField[3] = &Data.PerDirFirDirAmounts;
+    pField[4] = &Data.PerDirFirDirStrengths;
+    pField[5] = &Data.PerDirFirIsoStrengths;
+    pField[6] = &Data.Coefs;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoHighFir(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _HisoMedFirProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_fir_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningFirParams)];
+    AmbaItuner_Get_HisoMedFir(&Data);
+    pField[0] = &Data.Specify;
+    pField[1] = &Data.StrengthIso;
+    pField[2] = &Data.StrengthDir;
+    pField[3] = &Data.PerDirFirDirAmounts;
+    pField[4] = &Data.PerDirFirDirStrengths;
+    pField[5] = &Data.PerDirFirIsoStrengths;
+    pField[6] = &Data.Coefs;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoMedFir(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _SharpenCoringProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_coring_t Data;
+
+    void *pField[GET_ARRAY_NUM(SharpeningCoringParams)];
+    AmbaItuner_Get_Coring(&Data);
+    pField[0] = &Data.Coring;
+    pField[1] = &Data.FractionalBits;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_Coring(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _FinalSharpenCoringProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_coring_t Data;
+
+    void *pField[GET_ARRAY_NUM(SharpeningCoringParams)];
+    AmbaItuner_Get_FinalCoring(&Data);
+    pField[0] = &Data.Coring;
+    pField[1] = &Data.FractionalBits;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_FinalCoring(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _HisoHighCoringProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_coring_t Data;
+
+    void *pField[GET_ARRAY_NUM(SharpeningCoringParams)];
+    AmbaItuner_Get_HisoHighCoring(&Data);
+    pField[0] = &Data.Coring;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoHighCoring(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _HisoMedCoringProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_coring_t Data;
+
+    void *pField[GET_ARRAY_NUM(SharpeningCoringParams)];
+    AmbaItuner_Get_HisoMedCoring(&Data);
+    pField[0] = &Data.Coring;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoMedCoring(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _CoringIndexScaleProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_level_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningLevelParams)];
+    AmbaItuner_Get_CoringIndexScale(&Data);
+    pField[0] = &Data.High;
+    pField[1] = &Data.HighDelta;
+    pField[2] = &Data.HighStrength;
+    pField[3] = &Data.MidStrength;
+    pField[4] = &Data.Low;
+    pField[5] = &Data.LowDelta;
+    pField[6] = &Data.LowStrength;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_CoringIndexScale(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _MinCoringResultProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_level_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningLevelParams)];
+    AmbaItuner_Get_MinCoringResult(&Data);
+    pField[0] = &Data.High;
+    pField[1] = &Data.HighDelta;
+    pField[2] = &Data.HighStrength;
+    pField[3] = &Data.MidStrength;
+    pField[4] = &Data.Low;
+    pField[5] = &Data.LowDelta;
+    pField[6] = &Data.LowStrength;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_MinCoringResult(&Data);
+    return (0x1ULL << Index);
+}
+
+
+static INT64 _ScaleCoringProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_level_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningLevelParams)];
+    AmbaItuner_Get_ScaleCoring(&Data);
+    pField[0] = &Data.High;
+    pField[1] = &Data.HighDelta;
+    pField[2] = &Data.HighStrength;
+    pField[3] = &Data.MidStrength;
+    pField[4] = &Data.Low;
+    pField[5] = &Data.LowDelta;
+    pField[6] = &Data.LowStrength;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_ScaleCoring(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _FinalCoringIndexScaleProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_level_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningLevelParams)];
+    AmbaItuner_Get_FinalCoringIndexScale(&Data);
+    pField[0] = &Data.High;
+    pField[1] = &Data.HighDelta;
+    pField[2] = &Data.HighStrength;
+    pField[3] = &Data.MidStrength;
+    pField[4] = &Data.Low;
+    pField[5] = &Data.LowDelta;
+    pField[6] = &Data.LowStrength;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_FinalCoringIndexScale(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _FinalMinCoringResultProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_level_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningLevelParams)];
+    AmbaItuner_Get_FinalMinCoringResult(&Data);
+    pField[0] = &Data.High;
+    pField[1] = &Data.HighDelta;
+    pField[2] = &Data.HighStrength;
+    pField[3] = &Data.MidStrength;
+    pField[4] = &Data.Low;
+    pField[5] = &Data.LowDelta;
+    pField[6] = &Data.LowStrength;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_FinalMinCoringResult(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _FinalScaleCoringProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_level_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningLevelParams)];
+    AmbaItuner_Get_FinalScaleCoring(&Data);
+    pField[0] = &Data.High;
+    pField[1] = &Data.HighDelta;
+    pField[2] = &Data.HighStrength;
+    pField[3] = &Data.MidStrength;
+    pField[4] = &Data.Low;
+    pField[5] = &Data.LowDelta;
+    pField[6] = &Data.LowStrength;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_FinalScaleCoring(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _HisoHighCoringIndexScaleProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_level_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningLevelParams)];
+    AmbaItuner_Get_HisoHighCoringIndexScale(&Data);
+    pField[0] = &Data.High;
+    pField[1] = &Data.HighDelta;
+    pField[2] = &Data.HighStrength;
+    pField[3] = &Data.MidStrength;
+    pField[4] = &Data.Low;
+    pField[5] = &Data.LowDelta;
+    pField[6] = &Data.LowStrength;
+//    pField[7] = &Data.Method;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoHighCoringIndexScale(&Data);
+    return (0x1ULL << Index);
+}
+
+
+static INT64 _HisoHighMinCoringResultProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_level_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningLevelParams)];
+    AmbaItuner_Get_HisoHighMinCoringResult(&Data);
+    pField[0] = &Data.High;
+    pField[1] = &Data.HighDelta;
+    pField[2] = &Data.HighStrength;
+    pField[3] = &Data.MidStrength;
+    pField[4] = &Data.Low;
+    pField[5] = &Data.LowDelta;
+    pField[6] = &Data.LowStrength;
+//    pField[7] = &Data.Method;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoHighMinCoringResult(&Data);
+    return (0x1ULL << Index);
+}
+
+
+static INT64 _HisoHighScaleCoringProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_level_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningLevelParams)];
+    AmbaItuner_Get_HisoHighScaleCoring(&Data);
+    pField[0] = &Data.High;
+    pField[1] = &Data.HighDelta;
+    pField[2] = &Data.HighStrength;
+    pField[3] = &Data.MidStrength;
+    pField[4] = &Data.Low;
+    pField[5] = &Data.LowDelta;
+    pField[6] = &Data.LowStrength;
+//    pField[7] = &Data.Method;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoHighScaleCoring(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _HisoMedCoringIndexScaleProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_level_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningLevelParams)];
+    AmbaItuner_Get_HisoMedCoringIndexScale(&Data);
+    pField[0] = &Data.High;
+    pField[1] = &Data.HighDelta;
+    pField[2] = &Data.HighStrength;
+    pField[3] = &Data.MidStrength;
+    pField[4] = &Data.Low;
+    pField[5] = &Data.LowDelta;
+    pField[6] = &Data.LowStrength;
+//    pField[7] = &Data.Method;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoMedCoringIndexScale(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _HisoMedMinCoringResultProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_level_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningLevelParams)];
+    AmbaItuner_Get_HisoMedMinCoringResult(&Data);
+    pField[0] = &Data.High;
+    pField[1] = &Data.HighDelta;
+    pField[2] = &Data.HighStrength;
+    pField[3] = &Data.MidStrength;
+    pField[4] = &Data.Low;
+    pField[5] = &Data.LowDelta;
+    pField[6] = &Data.LowStrength;
+//    pField[7] = &Data.Method;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoMedMinCoringResult(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _HisoMedScaleCoringProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_level_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningLevelParams)];
+    AmbaItuner_Get_HisoMedScaleCoring(&Data);
+    pField[0] = &Data.High;
+    pField[1] = &Data.HighDelta;
+    pField[2] = &Data.HighStrength;
+    pField[3] = &Data.MidStrength;
+    pField[4] = &Data.Low;
+    pField[5] = &Data.LowDelta;
+    pField[6] = &Data.LowStrength;
+//    pField[7] = &Data.Method;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoMedScaleCoring(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _VideoMctfProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_video_mctf_info_t Data;
+    void *pField[GET_ARRAY_NUM(VideoMctfParams)];
+    AmbaItuner_Get_VideoMctf(&Data);
+    pField[0]  = &Data.Enable;
+    pField[1]  = &Data.YMaxChange;
+    pField[2]  = &Data.UMaxChange;
+    pField[3]  = &Data.VMaxChange;
+    pField[4]  = &Data.WeightingBasedOnLocalMotion;
+    pField[5]  = &Data.Threshold0;
+    pField[6]  = &Data.Threshold1;
+    pField[7]  = &Data.Threshold2;
+    pField[8]  = &Data.Threshold3;
+    pField[9] = &Data.Alpha1;
+    pField[10] = &Data.Alpha2;
+    pField[11] = &Data.Alpha3;
+
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_VideoMctf(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _VideoMctfTemporalAdjustProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_video_mctf_temporal_adjust_t Data;
+    void *pField[GET_ARRAY_NUM(VideoMctfTemporalAdjustParams)];
+    AmbaItuner_Get_VideoMctfTemporalAdjust(&Data);
+    pField[0]  = &Data.StillThresh;
+    pField[1]  = &Data.Min;
+    pField[2]  = &Data.SlowMoSensitivity;
+    pField[3]  = &Data.MotionResponse;
+    pField[4]  = &Data.NoiseBase;
+    pField[5]  = &Data.Smooth;
+    pField[6]  = &Data.LevAdjustHigh;
+    pField[7]  = &Data.LevAdjustHighDelta;
+    pField[8]  = &Data.LevAdjustHighStrength;
+    pField[9]  = &Data.LevAdjustLow;
+    pField[10]  = &Data.LevAdjustLowDelta;
+    pField[11]  = &Data.LevAdjustLowStrength;
+    pField[12]  = &Data.LevAdjustMidStrength;
+    pField[13]  = &Data.UVMax;
+    pField[14]  = &Data.UVMin;
+    pField[15]  = &Data.YMax;
+    pField[16]  = &Data.YMin;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_VideoMctfTemporalAdjust(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _ColorDependentNoiseReductionProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_cdnr_info_t Data;
+    void *pField[GET_ARRAY_NUM(ColorDependentNoiseReductionParams)];
+    AmbaItuner_Get_CDNR(&Data);
+    pField[0]  = &Data.Enable;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_CDNR(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _DeferredColorCorrectionProc(int Index, PARAM_s *pParam)
+{
+    AMBA_DSP_IMG_DEFER_COLOR_CORRECTION_s Data;
+    void *pField[GET_ARRAY_NUM(DeferredColorCorrectionParams)];
+    AmbaItuner_Get_HisoDeferColorCorrection(&Data);
+    pField[0]  = &Data.Enable;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoDeferColorCorrection(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+
+static INT64 _ShpAOrSpatialFilterSelectproc(int Index, PARAM_s *pParam)
+{
+//	UINT8 ShpAOrSpatialFilterSelect;
+    amba_img_dsp_liso_process_select_t Data;
+    void *pField[GET_ARRAY_NUM(ShpAOrSpatialFilterSelectParams)];
+	AmbaItuner_Get_ShpAOrSpatialFilterSelect(&Data);
+    pField[0] = &Data.AdvancedFeaturesEnable;
+    pField[1] = &Data.UseSharpenNotAsf;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_ShpAOrSpatialFilterSelect(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _AdvanceSpatialFilterProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_asf_info_t Data;
+    void *pField[GET_ARRAY_NUM(AdvanceSpatialFilterParams_A12)];
+    AmbaItuner_Get_AsfInfo(&Data);
+    pField[0]  = &Data.Enable;
+    pField[1]  = &Data.DirectionalDecideT0;
+    pField[2]  = &Data.DirectionalDecideT1;
+    pField[3]  = &Data.Fir.Specify;
+    pField[4]  = &Data.Fir.StrengthIso;
+    pField[5]  = &Data.Fir.StrengthDir;
+    pField[6]  = &Data.Fir.PerDirFirDirAmounts;
+    pField[7]  = &Data.Fir.PerDirFirDirStrengths;
+    pField[8]  = &Data.Fir.PerDirFirIsoStrengths;
+    pField[9]  = &Data.Fir.Coefs;
+    pField[10] = &Data.Fir.WideEdgeDetect;
+    pField[11] = &Data.LevelStrAdjust.High;
+    pField[12] = &Data.LevelStrAdjust.HighDelta;
+    pField[13] = &Data.LevelStrAdjust.HighStrength;
+    pField[14] = &Data.LevelStrAdjust.MidStrength;
+    pField[15] = &Data.LevelStrAdjust.Low;
+    pField[16] = &Data.LevelStrAdjust.LowDelta;
+    pField[17] = &Data.LevelStrAdjust.LowStrength;
+    pField[18] = &Data.MaxChangeNotT0T1Alpha;
+    pField[19] = &Data.MaxChangeDown;
+    pField[20] = &Data.MaxChangeUp;
+    pField[21] = &Data.Adapt.T0Down;
+    pField[22] = &Data.Adapt.T0Up;
+    pField[23] = &Data.Adapt.T1Down;
+    pField[24] = &Data.Adapt.T1Up;
+    pField[25] = &Data.Adapt.AlphaMinDown;
+    pField[26] = &Data.Adapt.AlphaMinUp;
+    pField[27] = &Data.Adapt.AlphaMaxDown;
+    pField[28] = &Data.Adapt.AlphaMaxUp;
+    pField[29] = &Data.T0T1Div.High;
+    pField[30] = &Data.T0T1Div.HighDelta;
+    pField[31] = &Data.T0T1Div.HighStrength;
+    pField[32] = &Data.T0T1Div.Low;
+    pField[33] = &Data.T0T1Div.LowDelta;
+    pField[34] = &Data.T0T1Div.LowStrength;
+    pField[35] = &Data.T0T1Div.MidStrength;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_AsfInfo(&Data);
+    return (INT64)(((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index));
+}
+
+static INT64 _HisoAsfProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_asf_info_t Data;
+    void *pField[GET_ARRAY_NUM(AdvanceSpatialFilterParams_A12)];
+    AmbaItuner_Get_HisoAsf(&Data);
+    pField[0]  = &Data.Enable;
+    pField[1]  = &Data.Fir.Specify;
+    pField[2]  = &Data.Fir.StrengthIso;
+    pField[3]  = &Data.Fir.StrengthDir;
+    pField[4]  = &Data.Fir.PerDirFirDirAmounts;
+    pField[5]  = &Data.Fir.PerDirFirDirStrengths;
+    pField[6]  = &Data.Fir.PerDirFirIsoStrengths;
+    pField[7]  = &Data.Fir.Coefs;
+    pField[8]  = &Data.Fir.WideEdgeDetect;
+    pField[9]  = &Data.DirectionalDecideT0;
+    pField[10] = &Data.DirectionalDecideT1;
+    pField[11] = &Data.Adapt.AlphaMaxDown;
+    pField[12] = &Data.Adapt.AlphaMaxUp;
+    pField[13] = &Data.Adapt.AlphaMinDown;
+    pField[14] = &Data.Adapt.AlphaMinUp;
+    pField[15] = &Data.Adapt.T0Down;
+    pField[16] = &Data.Adapt.T0Up;
+    pField[17] = &Data.Adapt.T1Down;
+    pField[18] = &Data.Adapt.T1Up;
+    pField[19] = &Data.LevelStrAdjust.High;
+    pField[20] = &Data.LevelStrAdjust.HighDelta;
+    pField[21] = &Data.LevelStrAdjust.HighStrength;
+    pField[22] = &Data.LevelStrAdjust.MidStrength;
+    pField[23] = &Data.LevelStrAdjust.Low;
+    pField[24] = &Data.LevelStrAdjust.LowDelta;
+    pField[25] = &Data.LevelStrAdjust.LowStrength;
+    pField[26] = &Data.T0T1Div.High;
+    pField[27] = &Data.T0T1Div.HighDelta;
+    pField[28] = &Data.T0T1Div.HighStrength;
+    pField[29] = &Data.T0T1Div.Low;
+    pField[30] = &Data.T0T1Div.LowDelta;
+    pField[31] = &Data.T0T1Div.LowStrength;
+    pField[32] = &Data.T0T1Div.MidStrength;
+    pField[33] = &Data.MaxChangeDown;
+    pField[34] = &Data.MaxChangeUp;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoAsf(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _HisoHighAsfProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_asf_info_t Data;
+    void *pField[GET_ARRAY_NUM(AdvanceSpatialFilterParams_A12)];
+    AmbaItuner_Get_HisoHighAsf(&Data);
+    pField[0]  = &Data.Enable;
+    pField[1]  = &Data.Fir.Specify;
+    pField[2]  = &Data.Fir.StrengthIso;
+    pField[3]  = &Data.Fir.StrengthDir;
+    pField[4]  = &Data.Fir.PerDirFirDirAmounts;
+    pField[5]  = &Data.Fir.PerDirFirDirStrengths;
+    pField[6]  = &Data.Fir.PerDirFirIsoStrengths;
+    pField[7]  = &Data.Fir.Coefs;
+    pField[8]  = &Data.Fir.WideEdgeDetect;
+    pField[9]  = &Data.DirectionalDecideT0;
+    pField[10] = &Data.DirectionalDecideT1;
+    pField[11] = &Data.Adapt.AlphaMaxDown;
+    pField[12] = &Data.Adapt.AlphaMaxUp;
+    pField[13] = &Data.Adapt.AlphaMinDown;
+    pField[14] = &Data.Adapt.AlphaMinUp;
+    pField[15] = &Data.Adapt.T0Down;
+    pField[16] = &Data.Adapt.T0Up;
+    pField[17] = &Data.Adapt.T1Down;
+    pField[18] = &Data.Adapt.T1Up;
+    pField[19] = &Data.LevelStrAdjust.High;
+    pField[20] = &Data.LevelStrAdjust.HighDelta;
+    pField[21] = &Data.LevelStrAdjust.HighStrength;
+    pField[22] = &Data.LevelStrAdjust.MidStrength;
+    pField[23] = &Data.LevelStrAdjust.Low;
+    pField[24] = &Data.LevelStrAdjust.LowDelta;
+    pField[25] = &Data.LevelStrAdjust.LowStrength;
+    pField[26] = &Data.T0T1Div.High;
+    pField[27] = &Data.T0T1Div.HighDelta;
+    pField[28] = &Data.T0T1Div.HighStrength;
+    pField[29] = &Data.T0T1Div.Low;
+    pField[30] = &Data.T0T1Div.LowDelta;
+    pField[31] = &Data.T0T1Div.LowStrength;
+    pField[32] = &Data.T0T1Div.MidStrength;
+    pField[33] = &Data.MaxChangeDown;
+    pField[34] = &Data.MaxChangeUp;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoHighAsf(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _HisoLowAsfProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_asf_info_t Data;
+    void *pField[GET_ARRAY_NUM(AdvanceSpatialFilterParams_A12)];
+    AmbaItuner_Get_HisoLowAsf(&Data);
+    pField[0]  = &Data.Enable;
+    pField[1]  = &Data.Fir.Specify;
+    pField[2]  = &Data.Fir.StrengthIso;
+    pField[3]  = &Data.Fir.StrengthDir;
+    pField[4]  = &Data.Fir.PerDirFirDirAmounts;
+    pField[5]  = &Data.Fir.PerDirFirDirStrengths;
+    pField[6]  = &Data.Fir.PerDirFirIsoStrengths;
+    pField[7]  = &Data.Fir.Coefs;
+    pField[8]  = &Data.Fir.WideEdgeDetect;
+    pField[9]  = &Data.DirectionalDecideT0;
+    pField[10] = &Data.DirectionalDecideT1;
+    pField[11] = &Data.Adapt.AlphaMaxDown;
+    pField[12] = &Data.Adapt.AlphaMaxUp;
+    pField[13] = &Data.Adapt.AlphaMinDown;
+    pField[14] = &Data.Adapt.AlphaMinUp;
+    pField[15] = &Data.Adapt.T0Down;
+    pField[16] = &Data.Adapt.T0Up;
+    pField[17] = &Data.Adapt.T1Down;
+    pField[18] = &Data.Adapt.T1Up;
+    pField[19] = &Data.LevelStrAdjust.High;
+    pField[20] = &Data.LevelStrAdjust.HighDelta;
+    pField[21] = &Data.LevelStrAdjust.HighStrength;
+    pField[22] = &Data.LevelStrAdjust.MidStrength;
+    pField[23] = &Data.LevelStrAdjust.Low;
+    pField[24] = &Data.LevelStrAdjust.LowDelta;
+    pField[25] = &Data.LevelStrAdjust.LowStrength;
+    pField[26] = &Data.T0T1Div.High;
+    pField[27] = &Data.T0T1Div.HighDelta;
+    pField[28] = &Data.T0T1Div.HighStrength;
+    pField[29] = &Data.T0T1Div.Low;
+    pField[30] = &Data.T0T1Div.LowDelta;
+    pField[31] = &Data.T0T1Div.LowStrength;
+    pField[32] = &Data.T0T1Div.MidStrength;
+    pField[33] = &Data.MaxChangeDown;
+    pField[34] = &Data.MaxChangeUp;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoLowAsf(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _HisoMedAsfProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_asf_info_t Data;
+    void *pField[GET_ARRAY_NUM(AdvanceSpatialFilterParams_A12)];
+    AmbaItuner_Get_HisoMedAsf(&Data);
+    pField[0]  = &Data.Enable;
+    pField[1]  = &Data.Fir.Specify;
+    pField[2]  = &Data.Fir.StrengthIso;
+    pField[3]  = &Data.Fir.StrengthDir;
+    pField[4]  = &Data.Fir.PerDirFirDirAmounts;
+    pField[5]  = &Data.Fir.PerDirFirDirStrengths;
+    pField[6]  = &Data.Fir.PerDirFirIsoStrengths;
+    pField[7]  = &Data.Fir.Coefs;
+    pField[8]  = &Data.Fir.WideEdgeDetect;
+    pField[9]  = &Data.DirectionalDecideT0;
+    pField[10] = &Data.DirectionalDecideT1;
+    pField[11] = &Data.Adapt.AlphaMaxDown;
+    pField[12] = &Data.Adapt.AlphaMaxUp;
+    pField[13] = &Data.Adapt.AlphaMinDown;
+    pField[14] = &Data.Adapt.AlphaMinUp;
+    pField[15] = &Data.Adapt.T0Down;
+    pField[16] = &Data.Adapt.T0Up;
+    pField[17] = &Data.Adapt.T1Down;
+    pField[18] = &Data.Adapt.T1Up;
+    pField[19] = &Data.LevelStrAdjust.High;
+    pField[20] = &Data.LevelStrAdjust.HighDelta;
+    pField[21] = &Data.LevelStrAdjust.HighStrength;
+    pField[22] = &Data.LevelStrAdjust.MidStrength;
+    pField[23] = &Data.LevelStrAdjust.Low;
+    pField[24] = &Data.LevelStrAdjust.LowDelta;
+    pField[25] = &Data.LevelStrAdjust.LowStrength;
+    pField[26] = &Data.T0T1Div.High;
+    pField[27] = &Data.T0T1Div.HighDelta;
+    pField[28] = &Data.T0T1Div.HighStrength;
+    pField[29] = &Data.T0T1Div.Low;
+    pField[30] = &Data.T0T1Div.LowDelta;
+    pField[31] = &Data.T0T1Div.LowStrength;
+    pField[32] = &Data.T0T1Div.MidStrength;
+    pField[33] = &Data.MaxChangeDown;
+    pField[34] = &Data.MaxChangeUp;    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoMedAsf(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _HisoChromaAsfProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    AMBA_DSP_IMG_CHROMA_ASF_INFO_s Data;
+    void *pField[GET_ARRAY_NUM(ChromaAdvanceSpatialFilterParams)];
+    AmbaItuner_Get_HisoChromaAsf(&Data);
+
+    pField[0]  = &Data.Enable;
+    pField[1]  = &Data.Fir.Specify;
+    pField[2]  = &Data.Fir.StrengthIso;
+    pField[3]  = &Data.Fir.StrengthDir;
+    pField[4]  = &Data.Fir.PerDirFirDirAmounts;
+    pField[5]  = &Data.Fir.PerDirFirDirStrengths;
+    pField[6]  = &Data.Fir.PerDirFirIsoStrengths;
+    pField[7]  = &Data.Fir.Coefs;
+    pField[8]  = &Data.Fir.WideEdgeDetect;
+    pField[9]  = &Data.DirectionalDecideT0;
+    pField[10] = &Data.DirectionalDecideT1;
+
+    pField[11] = &Data.AlphaMax;
+    pField[12] = &Data.AlphaMin;
+    pField[13] = &Data.T0;
+    pField[14] = &Data.T1;
+
+    pField[15] = &Data.LevelStrAdjust.High;
+    pField[16] = &Data.LevelStrAdjust.HighDelta;
+    pField[17] = &Data.LevelStrAdjust.HighStrength;
+    pField[18] = &Data.LevelStrAdjust.MidStrength;
+    pField[19] = &Data.LevelStrAdjust.Low;
+    pField[20] = &Data.LevelStrAdjust.LowDelta;
+    pField[21] = &Data.LevelStrAdjust.LowStrength;
+    pField[22] = &Data.T0T1Div.High;
+    pField[23] = &Data.T0T1Div.HighDelta;
+    pField[24] = &Data.T0T1Div.HighStrength;
+    pField[25] = &Data.T0T1Div.Low;
+    pField[26] = &Data.T0T1Div.LowDelta;
+    pField[27] = &Data.T0T1Div.LowStrength;
+    pField[28] = &Data.T0T1Div.MidStrength;
+    pField[29] = &Data.MaxChange;
+
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoChromaAsf(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _ChromaFilterProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_chroma_filter_t Data;
+    void *pField[GET_ARRAY_NUM(ChromaFilterParams)];
+    AmbaItuner_Get_ChromaFilter(&Data);
+    pField[0] = &Data.Enable;
+    pField[1] = &Data.NoiseLevelCb;
+    pField[2] = &Data.NoiseLevelCr;
+    pField[3] = &Data.OriginalBlendStrengthCb;
+    pField[4] = &Data.OriginalBlendStrengthCr;
+    pField[5] = &Data.Radius;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_ChromaFilter(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _WideChromaFilterProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_chroma_filter_t Data;
+    void *pField[GET_ARRAY_NUM(ChromaFilterParams)];
+    AmbaItuner_Get_WideChromaFilter(&Data);
+    pField[0] = &Data.Enable;
+    pField[1] = &Data.NoiseLevelCb;
+    pField[2] = &Data.NoiseLevelCr;
+    pField[3] = &Data.OriginalBlendStrengthCb;
+    pField[4] = &Data.OriginalBlendStrengthCr;
+    pField[5] = &Data.Radius;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_WideChromaFilter(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _WideChromaFilterCombineProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s Data;
+    void *pField[GET_ARRAY_NUM(HisoChromaFilterCombineParams)];
+    AmbaItuner_Get_WideChromaFilterCombine(&Data);
+    pField[0] = &Data.T0Cb;
+    pField[1] = &Data.T0Cr;
+    pField[2] = &Data.T1Cb;
+    pField[3] = &Data.T1Cr;
+    pField[4] = &Data.AlphaMaxCb;
+    pField[5] = &Data.AlphaMaxCr;
+    pField[6] = &Data.AlphaMinCb;
+    pField[7] = &Data.AlphaMinCr;
+    pField[8] = &Data.MaxChangeCb;
+    pField[9] = &Data.MaxChangeCr;
+
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_WideChromaFilterCombine(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _HisoChromaFilterHighProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_chroma_filter_t Data;
+    void *pField[GET_ARRAY_NUM(ChromaFilterParams)];
+    AmbaItuner_Get_HisoChromaFilterHigh(&Data);
+    pField[0] = &Data.Enable;
+    pField[1] = &Data.NoiseLevelCb;
+    pField[2] = &Data.NoiseLevelCr;
+    pField[3] = &Data.OriginalBlendStrengthCb;
+    pField[4] = &Data.OriginalBlendStrengthCr;
+    pField[5] = &Data.Radius;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoChromaFilterHigh(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _GbGrMismatchProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_gbgr_mismatch_t Data;
+    void *pField[GET_ARRAY_NUM(GbGrMismatchParams)];
+    AmbaItuner_Get_GbGrMismatch(&Data);
+    pField[0] = &Data.NarrowEnable;
+    pField[1] = &Data.WideEnable;
+    pField[2] = &Data.WideSafety;
+    pField[3] = &Data.WideThresh;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_GbGrMismatch(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _HisoGbGrMismatchProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_gbgr_mismatch_t Data;
+    void *pField[GET_ARRAY_NUM(GbGrMismatchParams)];
+    AmbaItuner_Get_HisoGbGrMismatch(&Data);
+    pField[0] = &Data.NarrowEnable;
+    pField[1] = &Data.WideEnable;
+    pField[2] = &Data.WideSafety;
+    pField[3] = &Data.WideThresh;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoGbGrMismatch(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _ChromaAberrationProc(int Index, PARAM_s *pParam)
+{
+    ITUNER_CHROMA_ABERRATION_s Data;
+    void *pField[GET_ARRAY_NUM(ChromaAberrationParams)];
+    AmbaItuner_Get_ChromaAberrationInfo(&Data);
+    pField[0] = &Data.Enable;
+    pField[1] = &Data.CalibVersion;
+    pField[2] = &Data.HorizontalGridNumber;
+    pField[3] = &Data.VerticalGridNumber;
+    pField[4] = &Data.TileWidthExponent;
+    pField[5] = &Data.TileHeightExponent;
+    pField[6] = &Data.VinSensorStartX;
+    pField[7] = &Data.VinSensorStartY;
+    pField[8] = &Data.VinSensorWidth;
+    pField[9] = &Data.VinSensorHeight;
+    pField[10] = &Data.VinSensorHSubSampleFactorNum;
+    pField[11] = &Data.VinSensorHSubSampleFactorDen;
+    pField[12] = &Data.VinSensorVSubSampleFactorNum;
+    pField[13] = &Data.VinSensorVSubSampleFactorDen;
+    pField[14] = &Data.RedScaleFactor;
+    pField[15] = &Data.BlueScaleFactor;
+    pField[16] = &Data.CaGridTablePath;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_ChromaAberrationInfo(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _ChromaAberrationByPassProc(int Index, PARAM_s *pParam)
+{
+    ITUNER_CHROMA_ABERRATION_BYPASS_s Data;
+    void *pField[GET_ARRAY_NUM(ChromaAberrationByPassParams)];
+    AmbaItuner_Get_ChromaAberrationInfoByPass(&Data);
+    pField[0] = &Data.HorzWarpEnable;
+    pField[1] = &Data.VertWarpEnable;
+    pField[2] = &Data.HorzPassGridArrayWidth;
+    pField[3] = &Data.HorzPassGridArrayHeight;
+    pField[4] = &Data.HorzPassHorzGridSpacingExponent;
+    pField[5] = &Data.HorzPassVertGridSpacingExponent;
+    pField[6] = &Data.VertPassGridArrayWidth;
+    pField[7] = &Data.VertPassGridArrayHeight;
+    pField[8] = &Data.VertPassHorzGridSpacingExponent;
+    pField[9] = &Data.VertPassVertGridSpacingExponent;
+    pField[10] = &Data.RedScaleFactor;
+    pField[11] = &Data.BlueScaleFactor;
+    pField[12] = &Data.WarpHorzTablePath;
+    pField[13] = &Data.WarpVertTablePath;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_ChromaAberrationInfoByPass(&Data);
+    if ((Index == 0) && (Data.HorzWarpEnable == 0)) {
+        return (0x1ULL << 0) | //HorzWarpEnable
+               (0x1ULL << 2) | //HorzPassGridArrayWidth
+               (0x1ULL << 3) | //HorzPassGridArrayHeight
+               (0x1ULL << 4) | //HorzPassHorzGridSpacingExponent
+               (0x1ULL << 5) | //HorzPassVertGridSpacingExponent
+               (0x1ULL << 12); //WarpHorzTablePath
+    } else if ((Index == 1) && (Data.VertWarpEnable == 0)) {
+        return (0x1ULL << 1) | //VertWarpEnable
+               (0x1ULL << 6) | //VertPassGridArrayWidth
+               (0x1ULL << 7) | //VertPassGridArrayHeight
+               (0x1ULL << 8) | //VertPassHorzGridSpacingExponent
+               (0x1ULL << 9) | //VertPassVertGridSpacingExponent
+               (0x1ULL <<13); //WarpVertTablePath
+    }
+    return (0x1ULL << Index);
+}
+
+static INT64 _ChromaFilterLowAndVeryLowProc(int Index, PARAM_s *pParam)
+{
+    AMBA_DSP_IMG_HISO_CHROMA_LOW_VERY_LOW_FILTER_s Data;
+    void *pField[GET_ARRAY_NUM(ChromaFilterLowAndVeryLowParams)];
+    AmbaItuner_Get_HisoChromaFilterLowVeryLow(&Data);
+    pField[0] = &Data.EdgeStartCb;
+    pField[1] = &Data.EdgeStartCr;
+    pField[2] = &Data.EdgeEndCb;
+    pField[3] = &Data.EdgeEndCr;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoChromaFilterLowVeryLow(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _HisoChromaFilterProc(int Index, PARAM_s *pParam)
+{
+    AMBA_DSP_IMG_HISO_CHROMA_FILTER_s Data;
+    void *pField[GET_ARRAY_NUM(HisoChromaFilterParams)];
+    AmbaItuner_Get_HisoChromaFilterPre(&Data);
+    pField[0] = &Data.Enable;
+    pField[1] = &Data.NoiseLevelCb;
+    pField[2] = &Data.NoiseLevelCr;
+    pField[3] = &Data.OriginalBlendStrengthCb;
+    pField[4] = &Data.OriginalBlendStrengthCr;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoChromaFilterPre(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _HisoChromaFilterMedProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    AMBA_DSP_IMG_HISO_CHROMA_FILTER_s Data;
+    void *pField[GET_ARRAY_NUM(HisoChromaFilterParams)];
+    AmbaItuner_Get_HisoChromaFilterMed(&Data);
+    pField[0] = &Data.Enable;
+    pField[1] = &Data.NoiseLevelCb;
+    pField[2] = &Data.NoiseLevelCr;
+    pField[3] = &Data.OriginalBlendStrengthCb;
+    pField[4] = &Data.OriginalBlendStrengthCr;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoChromaFilterMed(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _HisoChromaFilterLowProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    AMBA_DSP_IMG_HISO_CHROMA_FILTER_s Data;
+    void *pField[GET_ARRAY_NUM(HisoChromaFilterParams)];
+    AmbaItuner_Get_HisoChromaFilterLow(&Data);
+    pField[0] = &Data.Enable;
+    pField[1] = &Data.NoiseLevelCb;
+    pField[2] = &Data.NoiseLevelCr;
+    pField[3] = &Data.OriginalBlendStrengthCb;
+    pField[4] = &Data.OriginalBlendStrengthCr;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoChromaFilterLow(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _HisoChromaFilterVeryLowProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    AMBA_DSP_IMG_HISO_CHROMA_FILTER_s Data;
+    void *pField[GET_ARRAY_NUM(HisoChromaFilterParams)];
+    AmbaItuner_Get_HisoChromaFilterVeryLow(&Data);
+    pField[0] = &Data.Enable;
+    pField[1] = &Data.NoiseLevelCb;
+    pField[2] = &Data.NoiseLevelCr;
+    pField[3] = &Data.OriginalBlendStrengthCb;
+    pField[4] = &Data.OriginalBlendStrengthCr;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoChromaFilterVeryLow(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _HisoChromaFilterVeryLowCombineProc(int Index, PARAM_s *pParam)
+{
+    AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s Data;
+    void *pField[GET_ARRAY_NUM(HisoChromaFilterCombineParams)];
+    AmbaItuner_Get_HisoChromaFilterVeryLowCombine(&Data);
+    pField[0] = &Data.T0Cb;
+    pField[1] = &Data.T0Cr;
+    pField[2] = &Data.T1Cb;
+    pField[3] = &Data.T1Cr;
+    pField[4] = &Data.AlphaMaxCb;
+    pField[5] = &Data.AlphaMaxCr;
+    pField[6] = &Data.AlphaMinCb;
+    pField[7] = &Data.AlphaMinCr;
+    pField[8] = &Data.MaxChangeCb;
+    pField[9] = &Data.MaxChangeCr;
+
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoChromaFilterVeryLowCombine(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _HisoChromaFilterMedCombineProc(int Index, PARAM_s *pParam)
+{
+    AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s Data;
+    void *pField[GET_ARRAY_NUM(HisoChromaFilterCombineParams)];
+    AmbaItuner_Get_HisoChromaFilterMedCombine(&Data);
+    pField[0] = &Data.T0Cb;
+    pField[1] = &Data.T0Cr;
+    pField[2] = &Data.T1Cb;
+    pField[3] = &Data.T1Cr;
+    pField[4] = &Data.AlphaMaxCb;
+    pField[5] = &Data.AlphaMaxCr;
+    pField[6] = &Data.AlphaMinCb;
+    pField[7] = &Data.AlphaMinCr;
+    pField[8] = &Data.MaxChangeCb;
+    pField[9] = &Data.MaxChangeCr;
+
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoChromaFilterMedCombine(&Data);
+    return (0x1ULL << Index);
+}
+
+
+static INT64 _HisoChromaFilterLowCombineProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s Data;
+    void *pField[GET_ARRAY_NUM(HisoChromaFilterCombineParams)];
+    AmbaItuner_Get_HisoChromaFilterLowCombine(&Data);
+    pField[0] = &Data.T0Cb;
+    pField[1] = &Data.T0Cr;
+    pField[2] = &Data.T1Cb;
+    pField[3] = &Data.T1Cr;
+    pField[4] = &Data.AlphaMaxCb;
+    pField[5] = &Data.AlphaMaxCr;
+    pField[6] = &Data.AlphaMinCb;
+    pField[7] = &Data.AlphaMinCr;
+    pField[8] = &Data.MaxChangeCb;
+    pField[9] = &Data.MaxChangeCr;
+
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoChromaFilterLowCombine(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _HisoLumaFilterCombineProc(int Index, PARAM_s *pParam)
+{
+    AMBA_DSP_IMG_HISO_LUMA_FILTER_COMBINE_s Data;
+    void *pField[GET_ARRAY_NUM(HisoLumaFilterCombineParams)];
+    AmbaItuner_Get_HisoLumaNoiseCombine(&Data);
+
+    pField[0] = &Data.T0;
+    pField[1] = &Data.T1;
+    pField[2] = &Data.AlphaMax;
+    pField[3] = &Data.AlphaMin;
+    pField[4] = &Data.MaxChange;
+
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoLumaNoiseCombine(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _HisoLowASFCombineProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    AMBA_DSP_IMG_HISO_LUMA_FILTER_COMBINE_s Data;
+    void *pField[GET_ARRAY_NUM(HisoLumaFilterCombineParams)];
+    AmbaItuner_Get_HisoLowASFCombine(&Data);
+
+    pField[0] = &Data.T0;
+    pField[1] = &Data.T1;
+    pField[2] = &Data.AlphaMax;
+    pField[3] = &Data.AlphaMin;
+    pField[4] = &Data.MaxChange;
+
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoLowASFCombine(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _HisoFreqRecoverProc(int Index, PARAM_s *pParam)
+{
+    AMBA_DSP_IMG_HISO_FREQ_RECOVER_s Data;
+    void *pField[GET_ARRAY_NUM(HisoFreqRecoverParams)];
+    AmbaItuner_Get_HisoFreqRecover(&Data);
+    pField[0]  = &Data.Fir.Specify;
+    pField[1]  = &Data.Fir.StrengthIso;
+    pField[2]  = &Data.Fir.StrengthDir;
+    pField[3]  = &Data.Fir.PerDirFirDirAmounts;
+    pField[4]  = &Data.Fir.PerDirFirDirStrengths;
+    pField[5]  = &Data.Fir.PerDirFirIsoStrengths;
+    pField[6]  = &Data.Fir.Coefs;
+    pField[7] = &Data.MaxDown;
+    pField[8] = &Data.MaxUp;
+    pField[9] = &Data.Level.High;
+    pField[10] = &Data.Level.HighDelta;
+    pField[11] = &Data.Level.HighStrength;
+    pField[12] = &Data.Level.MidStrength;
+    pField[13] = &Data.Level.Low;
+    pField[14] = &Data.Level.LowDelta;
+    pField[15] = &Data.Level.LowStrength;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_HisoFreqRecover(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _MoDynamicBadPixelCorrectionProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_dbp_correction_t Data;
+    void *pField[GET_ARRAY_NUM(DynamicBadPixelCorrectionParams)];
+    AmbaItuner_Get_MoDynamicBadPixelCorrection(&Data);
+    pField[0] = &Data.Enb;
+    pField[1] = &Data.HotPixelStrength;
+    pField[2] = &Data.DarkPixelStrength;
+    pField[3] = &Data.CorrectionMethod;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_MoDynamicBadPixelCorrection(&Data);
+    return ((Index == 0) && (Data.Enb == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _MoCfaLeakageFilterProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_cfa_leakage_filter_t Data;
+    void *pField[GET_ARRAY_NUM(CfaLeakageFilterParams)];
+    AmbaItuner_Get_MoCfaLeakageFilter(&Data);
+    pField[0] = &Data.Enb;
+    pField[1] = &Data.AlphaRR;
+    pField[2] = &Data.AlphaRB;
+    pField[3] = &Data.AlphaBR;
+    pField[4] = &Data.AlphaBB;
+    pField[5] = &Data.SaturationLevel;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_MoCfaLeakageFilter(&Data);
+    return ((Index == 0) && (Data.Enb == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _MoCfaNoiseFilterProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_cfa_noise_filter_t Data;
+    void *pField[GET_ARRAY_NUM(CfaNoiseFilterParams)];
+    AmbaItuner_Get_MoCfaNoiseFilter(&Data);
+    pField[0] = &Data.Enb;
+    pField[1] = &Data.NoiseLevel[0];
+    pField[2] = &Data.NoiseLevel[1];
+    pField[3] = &Data.NoiseLevel[2];
+    pField[4] = &Data.OriginalBlendStr[0];
+    pField[5] = &Data.OriginalBlendStr[1];
+    pField[6] = &Data.OriginalBlendStr[2];
+    pField[7] = &Data.ExtentRegular[0];
+    pField[8] = &Data.ExtentRegular[1];
+    pField[9] = &Data.ExtentRegular[2];
+    pField[10] = &Data.ExtentFine[0];
+    pField[11] = &Data.ExtentFine[1];
+    pField[12] = &Data.ExtentFine[2];
+    pField[13] = &Data.StrengthFine[0];
+    pField[14] = &Data.StrengthFine[1];
+    pField[15] = &Data.StrengthFine[2];
+    pField[16] = &Data.SelectivityRegular;
+    pField[17] = &Data.SelectivityFine;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_MoCfaNoiseFilter(&Data);
+    return ((Index == 0) && (Data.Enb == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _MoAntiAliasingProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_anti_aliasing_t Data;
+    void *pField[GET_ARRAY_NUM(AntiAliasingParams)];
+    AmbaItuner_Get_MoAntiAliasingStrength(&Data);
+    pField[0] = &Data.Enb;
+    pField[1] = &Data.Thresh;
+    pField[2] = &Data.LogFractionalCorrect;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_MoAntiAliasingStrength(&Data);
+    return ((Index == 0) && (Data.Enb == 0||Data.Enb != 4)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _MoDemosaicFilterProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_demosaic_t Data;
+    void *pField[GET_ARRAY_NUM(DemosaicFilterParams)];
+    AmbaItuner_Get_MoDemosaicFilter(&Data);
+    pField[0] = &Data.ActivityThresh;
+    pField[1] = &Data.ActivityDifferenceThresh;
+    pField[2] = &Data.GradClipThresh;
+    pField[3] = &Data.GradNoiseThresh;
+//    pField[4] = &Data.ZipperNoiseDifferenceMultThresh;
+//    pField[5] = &Data.ZipperNoiseDifferenceAddThresh;
+//    pField[6] = &Data.BlackWhiteResolutionDetail;
+//    pField[7] = &Data.ClampDirectionalCandidates;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_MoDemosaicFilter(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _MoGbGrMismatchProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_gbgr_mismatch_t Data;
+    void *pField[GET_ARRAY_NUM(GbGrMismatchParams)];
+    AmbaItuner_Get_MoGbGrMismatch(&Data);
+    pField[0] = &Data.NarrowEnable;
+    pField[1] = &Data.WideEnable;
+    pField[2] = &Data.WideSafety;
+    pField[3] = &Data.WideThresh;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_MoGbGrMismatch(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _MoShpAOrSpatialFilterSelectproc(int Index, PARAM_s *pParam)
+{
+//	UINT8 ShpAOrSpatialFilterSelect;
+    amba_img_dsp_mo_process_select_t Data;
+    void *pField[GET_ARRAY_NUM(MoShpAOrSpatialFilterSelectParams)];
+	AmbaItuner_Get_MoShpAOrSpatialFilterSelect(&Data);
+    pField[0] = &Data.UseSharpenNotAsf;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_MoShpAOrSpatialFilterSelect(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _MoAdvanceSpatialFilterProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_asf_info_t Data;
+    void *pField[GET_ARRAY_NUM(AdvanceSpatialFilterParams_A12)];
+    AmbaItuner_Get_MoAsfInfo(&Data);
+    pField[0]  = &Data.Enable;
+    pField[1]  = &Data.DirectionalDecideT0;
+    pField[2]  = &Data.DirectionalDecideT1;
+    pField[3]  = &Data.Fir.Specify;
+    pField[4]  = &Data.Fir.StrengthIso;
+    pField[5]  = &Data.Fir.StrengthDir;
+    pField[6]  = &Data.Fir.PerDirFirDirAmounts;
+    pField[7]  = &Data.Fir.PerDirFirDirStrengths;
+    pField[8]  = &Data.Fir.PerDirFirIsoStrengths;
+    pField[9]  = &Data.Fir.Coefs;
+    pField[10] = &Data.Fir.WideEdgeDetect;
+    pField[11] = &Data.LevelStrAdjust.High;
+    pField[12] = &Data.LevelStrAdjust.HighDelta;
+    pField[13] = &Data.LevelStrAdjust.HighStrength;
+    pField[14] = &Data.LevelStrAdjust.MidStrength;
+    pField[15] = &Data.LevelStrAdjust.Low;
+    pField[16] = &Data.LevelStrAdjust.LowDelta;
+    pField[17] = &Data.LevelStrAdjust.LowStrength;
+    pField[18] = &Data.MaxChangeNotT0T1Alpha;
+    pField[19] = &Data.MaxChangeDown;
+    pField[20] = &Data.MaxChangeUp;
+    pField[21] = &Data.Adapt.T0Down;
+    pField[22] = &Data.Adapt.T0Up;
+    pField[23] = &Data.Adapt.T1Down;
+    pField[24] = &Data.Adapt.T1Up;
+    pField[25] = &Data.Adapt.AlphaMinDown;
+    pField[26] = &Data.Adapt.AlphaMinUp;
+    pField[27] = &Data.Adapt.AlphaMaxDown;
+    pField[28] = &Data.Adapt.AlphaMaxUp;
+    pField[29] = &Data.T0T1Div.High;
+    pField[30] = &Data.T0T1Div.HighDelta;
+    pField[31] = &Data.T0T1Div.HighStrength;
+    pField[32] = &Data.T0T1Div.Low;
+    pField[33] = &Data.T0T1Div.LowDelta;
+    pField[34] = &Data.T0T1Div.LowStrength;
+    pField[35] = &Data.T0T1Div.MidStrength;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_MoAsfInfo(&Data);
+    return (INT64)(((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index));
+}
+
+static INT64 _MoChromaFilterProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_chroma_filter_t Data;
+    void *pField[GET_ARRAY_NUM(ChromaFilterParams)];
+    AmbaItuner_Get_MoChromaFilter(&Data);
+    pField[0] = &Data.Enable;
+    pField[1] = &Data.NoiseLevelCb;
+    pField[2] = &Data.NoiseLevelCr;
+    pField[3] = &Data.OriginalBlendStrengthCb;
+    pField[4] = &Data.OriginalBlendStrengthCr;
+    pField[5] = &Data.Radius;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_MoChromaFilter(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _MoChromaMedianFilterProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_chroma_median_filter_t Data;
+    void *pField[GET_ARRAY_NUM(ChromaMedianFilterParams)];
+    AmbaItuner_Get_MoChromaMedianFilter(&Data);
+    pField[0] = &Data.Enable;
+    pField[1] = &Data.CbAdaptiveStrength;
+    pField[2] = &Data.CrAdaptiveStrength;
+    pField[3] = &Data.CbNonAdaptiveStrength;
+    pField[4] = &Data.CrNonAdaptiveStrength;
+    pField[5] = &Data.CbAdaptiveAmount;
+    pField[6] = &Data.CrAdaptiveAmount;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_MoChromaMedianFilter(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _MoSharpenBothProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_sharpen_both_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningBothParams)];
+    AmbaItuner_Get_MoSharpenBoth(&Data);
+    pField[0] = &Data.Enable;
+    pField[1] = &Data.Mode;
+    pField[2] = &Data.EdgeThresh;
+    pField[3] = &Data.WideEdgeDetect;
+    pField[4] = &Data.MaxChangeUp5x5;
+    pField[5] = &Data.MaxChangeDown5x5;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_MoSharpenBoth(&Data);
+    return ((Index == 0) && (Data.Enable == 0)) ? SKIP_VALID_CHECK : (0x1ULL << Index);
+}
+
+static INT64 _MoSharpenNoiseProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_sharpen_noise_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningNoiseParams_A12)];
+    AmbaItuner_Get_MoSharpenNoise(&Data);
+    pField[0] = &Data.SpatialFir.Specify;
+    pField[1] = &Data.SpatialFir.StrengthIso;
+    pField[2] = &Data.SpatialFir.StrengthDir;
+    pField[3] = &Data.SpatialFir.PerDirFirDirAmounts;
+    pField[4] = &Data.SpatialFir.PerDirFirDirStrengths;
+    pField[5] = &Data.SpatialFir.PerDirFirIsoStrengths;
+    pField[6] = &Data.SpatialFir.Coefs;
+    pField[7] = &Data.MaxChangeDown;
+    pField[8] = &Data.MaxChangeUp;
+    pField[9] = &Data.LevelStrAdjust.High;
+    pField[10] = &Data.LevelStrAdjust.HighDelta;
+    pField[11] = &Data.LevelStrAdjust.HighStrength;
+    pField[12] = &Data.LevelStrAdjust.MidStrength;
+    pField[13] = &Data.LevelStrAdjust.Low;
+    pField[14] = &Data.LevelStrAdjust.LowDelta;
+    pField[15] = &Data.LevelStrAdjust.LowStrength;
+    pField[16] = &Data.LevelStrAdjustNotT0T1LevelBased;
+    pField[17] = &Data.T0;
+    pField[18] = &Data.T1;
+    pField[19] = &Data.AlphaMin;
+    pField[20] = &Data.AlphaMax;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_MoSharpenNoise(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _MoSharpenFirProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_fir_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningFirParams)];
+    AmbaItuner_Get_MoFir(&Data);
+    pField[0] = &Data.Specify;
+    pField[1] = &Data.StrengthIso;
+    pField[2] = &Data.StrengthDir;
+    pField[3] = &Data.PerDirFirDirAmounts;
+    pField[4] = &Data.PerDirFirDirStrengths;
+    pField[5] = &Data.PerDirFirIsoStrengths;
+    pField[6] = &Data.Coefs;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_MoFir(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _MoSharpenCoringProc(int Index, PARAM_s *pParam)
+{
+    amba_img_dsp_coring_t Data;
+
+    void *pField[GET_ARRAY_NUM(SharpeningCoringParams)];
+    AmbaItuner_Get_MoCoring(&Data);
+    pField[0] = &Data.Coring;
+    pField[1] = &Data.FractionalBits;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_MoCoring(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _MoCoringIndexScaleProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_level_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningLevelParams)];
+    AmbaItuner_Get_MoCoringIndexScale(&Data);
+    pField[0] = &Data.High;
+    pField[1] = &Data.HighDelta;
+    pField[2] = &Data.HighStrength;
+    pField[3] = &Data.MidStrength;
+    pField[4] = &Data.Low;
+    pField[5] = &Data.LowDelta;
+    pField[6] = &Data.LowStrength;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_MoCoringIndexScale(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _MoMinCoringResultProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_level_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningLevelParams)];
+    AmbaItuner_Get_MoMinCoringResult(&Data);
+    pField[0] = &Data.High;
+    pField[1] = &Data.HighDelta;
+    pField[2] = &Data.HighStrength;
+    pField[3] = &Data.MidStrength;
+    pField[4] = &Data.Low;
+    pField[5] = &Data.LowDelta;
+    pField[6] = &Data.LowStrength;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_MoMinCoringResult(&Data);
+    return (0x1ULL << Index);
+}
+
+static INT64 _MoScaleCoringProc(int Index, PARAM_s *pParam)
+{
+    // Note:
+    amba_img_dsp_level_t Data;
+    void *pField[GET_ARRAY_NUM(SharpeningLevelParams)];
+    AmbaItuner_Get_MoScaleCoring(&Data);
+    pField[0] = &Data.High;
+    pField[1] = &Data.HighDelta;
+    pField[2] = &Data.HighStrength;
+    pField[3] = &Data.MidStrength;
+    pField[4] = &Data.Low;
+    pField[5] = &Data.LowDelta;
+    pField[6] = &Data.LowStrength;
+    TUNE_Parser_Param_Proc(pParam, pField[Index]);
+    AmbaItuner_Set_MoScaleCoring(&Data);
+    return (0x1ULL << Index);
+}
+
+
+
diff --git a/idsp_test/arch_s2l/AmbaTUNE_Rule.h b/idsp_test/arch_s2l/AmbaTUNE_Rule.h
new file mode 100644
index 0000000..c5da2da
--- /dev/null
+++ b/idsp_test/arch_s2l/AmbaTUNE_Rule.h
@@ -0,0 +1,63 @@
+/*
+ *
+ * idsp_test
+ *
+ * History:
+ *	2013/09/05 - [Dylan] Created this file
+ *
+ * Description :
+ *	Load the tuned file which generated by Img tuning tool.
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+ /*!
+ * @addtogroup ParserHdlr
+ * @{
+ *      @addtogroup Rule
+ *      @{
+ */
+#ifndef _AMBA_TEXT_RULE_H_
+#define _AMBA_TEXT_RULE_H_
+/*******************************************************************************
+ * Header include
+ ******************************************************************************/
+#define SKIP_VALID_CHECK 0xFFFFFFFFFFFFFFFFULL
+typedef struct {
+    REG_s * RegList;
+    UINT8 RegCount;
+} Rule_Info_t;
+
+int TUNE_Rule_Get_Info(Rule_Info_t * RuleInfo);
+const char* TUNE_Rule_Lookup_Tuning_Mode_Str(TUNING_MODE_e Tuning_Mode);
+const char* TUNE_Rule_Lookup_Tuning_Mode_Ext_Str(TUNING_MODE_EXT_e Tuning_Mode_Ext);
+TUNING_MODE_EXT_e TUNE_Rule_Lookup_Tuning_Mode_Ext(const char* Key);
+TUNING_MODE_e TUNE_Rule_Lookup_Tuning_Mode(const char* Key);
+#endif /* _AMBA_TEXT_HDLR_H_ */
+/*!
+ *      @} end of addtogroup Rule
+ * @} end of addtogroup ParserHdlr
+ */
diff --git a/idsp_test/arch_s2l/AmbaTUNE_TextHdlr.c b/idsp_test/arch_s2l/AmbaTUNE_TextHdlr.c
new file mode 100644
index 0000000..2096e25
--- /dev/null
+++ b/idsp_test/arch_s2l/AmbaTUNE_TextHdlr.c
@@ -0,0 +1,1530 @@
+/*
+ *
+ * idsp_test
+ *
+ * History:
+ *	2013/09/05 - [Dylan] Created this file
+ *
+ * Description :
+ *	Load the tuned file which generated by Img tuning tool.
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <stdio.h> // sprintf need
+#include <string.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+#include "AmbaTUNE_TextHdlr.h"
+#include "AmbaImgCalibItuner.h" //Note: ITUNER_SYSTEM_s need
+//#include "AmbaFS.h" //Note: AMBA_FS_FILE  need
+#include "AmbaDSP_ImgDef.h" // Note: AMBA_DSP_IMG_PIPE_VIDEO need
+//#include "AmbaDSP.h" // Note: AMBA_DSP_VIDEO_FILTER need
+#include "AmbaDSP_ImgFilter.h" // Note: AMBA_DSP_IMG_NUM_EXPOSURE_CURVE need
+#include "AmbaDSP_Img3aStatistics.h" // Note: amba_img_dsp_ae_stat_info_t need
+//#include "AmbaKAL.h"
+//#include "AmbaCardManager.h"// Note: AmbaSCM_GetSlotStatus need
+//#include "AmbaUtility.h"// Note: AmbaUtility_Slot2Drive need
+
+#include "AmbaTUNE_Parser.h"
+#include "AmbaTUNE_Rule.h"
+
+#define AmbaPrint(format, arg...)	printf(format"\n", ##arg)
+typedef FILE AMBA_FS_FILE;
+
+#define HDLR_DEBF(fmt, arg...) AmbaPrint("[TEXT HDLR][DEBUG]"fmt, ##arg)
+#define HDLR_WARF(fmt, arg...) AmbaPrint("[TEXT HDLR][WARNING]"fmt, ##arg)
+#define HDLR_ERRF(fmt, arg...) AmbaPrint("[TEXT HDLR][ERROR]"fmt, ##arg)
+
+
+#define MIN(a, b) ((a) > (b) ? (b) : (a))
+
+typedef void (*pfunc_conv_t)(int, void*, void*);
+
+typedef struct _ITUNER_OBJ_s_ {
+    amba_img_dsp_mode_cfg_t TuningAlgoMode;
+    TUNING_MODE_EXT_e TuningModeExt;
+    TUNE_Parser_Object_t* ParserObject;
+    UINT8 Is_Idsp_Load_Finish;
+} ITUNER_OBJ_s;
+
+typedef struct _TEXT_STREAM_s {
+    char* text_addr;
+    int size;
+    int ptr;
+}TEXT_STREAM;
+
+//static int _TextHdlr_Add_Reg(REG_s *pReg);
+
+static int _TextHdlr_Check_Param_Completeness(void);
+static AMBA_DSP_IMG_PIPE_e _TextHdlr_Get_Imag_Pipe(TUNING_MODE_e TuningMode);
+static AMBA_DSP_IMG_ALGO_MODE_e _TextHdlr_Get_Image_Algo_Mode(TUNING_MODE_e TuningMode);
+static int _TextHdlr_Update_ItunerInfo(void);
+static int _TextHdlr_Save_Ext_File(char *FileName, int Size, void *Buf);
+static int _TextHdlr_load_Ext_file(char *FileName, int Size, void *Buf);
+
+
+static ITUNER_OBJ_s _Ituner;
+
+static char Ituner_File_Path[64];
+
+static int _save_line(FILE *Fid, char * LineBuf)
+{
+    return (fwrite(LineBuf, 1, strlen(LineBuf), Fid));
+}
+
+#define BUF_SIZE 1024
+static char ReadBuffer[BUF_SIZE+32];
+static UINT8 READ_TEXT(void* destAddr, int size, int count, TEXT_STREAM* srcAddr)
+{
+	if( (srcAddr->ptr + size*count) >= srcAddr->size)
+		return -1;
+	else {
+		int idx = srcAddr->ptr;
+		memcpy(destAddr, &(srcAddr->text_addr[idx]), size*count);
+		srcAddr->ptr = srcAddr->ptr + size*count;
+	}
+	return 0;
+}
+
+static int _read_line(TEXT_STREAM* text, char * Line_Buf, int Buf_Size, char **Ptr)
+{
+    int Ret = 0;
+
+   *Ptr = Line_Buf;
+    while(READ_TEXT(*Ptr, 1, 1, text) == 0) {
+        if ((**Ptr == '\r') || (**Ptr == '\n')) {
+            **Ptr = 0;
+            //AmbaPrintColor(YELLOW, "%s", Line_Buf);
+            Ret = 1;
+            break;
+        }
+        (*Ptr)++;
+        if ((*Ptr - Line_Buf) >= Buf_Size) {
+            HDLR_WARF("%s() %d, Input Text String is too long", __func__, __LINE__);
+            Ret = 1;
+            break;
+        }
+
+    }
+
+    return Ret;
+
+}
+
+int HT_set_ituner_stream(u8* ituner_stream,int size)
+{
+    char *Buf = NULL;
+    int BufSize = 0;
+	char *Ptr;
+	int Line = 0;
+	TEXT_STREAM text;
+	text.text_addr =(char*)ituner_stream;
+	text.ptr =0;
+	text.size =size;
+	ITUNER_SYSTEM_s System;
+
+    HDLR_DEBF("---------------------");
+    HDLR_DEBF("iTuner ver. %d.%d", ITUNER_VER_MAJOR, ITUNER_VER_MINOR);
+    HDLR_DEBF("---------------------");
+
+    TUNE_Parser_Set_Opmode(ITUNER_DEC);
+    if (0 != TUNE_Parser_Set_Reglist_Valid(0, _Ituner.ParserObject)) {
+        HDLR_WARF("%s() %d, call TUNE_PArser_Set_Reglist_Valid() Fail", __func__, __LINE__);
+        return -1;
+    }
+    if (0 != TUNE_Parser_Get_LineBuf(_Ituner.ParserObject, &Buf, &BufSize)) {
+        HDLR_WARF("%s() %d, call TUNE_Parser_Get_LineBuf() Fail", __func__, __LINE__);
+        return -1;
+    }
+	while(_read_line(&text, Buf, BufSize, &Ptr)) {
+
+	TUNE_Parser_Parse_Line(_Ituner.ParserObject);
+	Line++;
+	}
+
+	AmbaItuner_Get_SystemInfo(&System);
+	   // If multi shot mode, read in additional config files
+	_Ituner.TuningModeExt = TUNE_Rule_Lookup_Tuning_Mode_Ext(System.TuningModeExt);
+
+
+    return 0;
+}
+
+static int _TextHdlr_Load_Text(char *FileName)
+{
+    int Line = 0;
+    char AscFname[64];
+    //char Fmode[] = {'r','b','\0'};
+    //char *Ptr;
+//    char ExtCfgFileName[64];
+    int Fid;
+    ITUNER_SYSTEM_s System;
+    //uni_to_asc(FileName, AscFname);
+    memset(AscFname, 0x0, sizeof(AscFname));
+    strncpy(AscFname, FileName, sizeof(AscFname));
+    HDLR_DEBF("---------------------");
+    HDLR_DEBF("iTuner ver. %d.%d", ITUNER_VER_MAJOR, ITUNER_VER_MINOR);
+    HDLR_DEBF("---------------------");
+    HDLR_DEBF("file to load:%s", AscFname);
+    TUNE_Parser_Set_Opmode(ITUNER_DEC);
+    if (0 != TUNE_Parser_Set_Reglist_Valid(0, _Ituner.ParserObject)) {
+        HDLR_WARF("%s() %d, call TUNE_PArser_Set_Reglist_Valid() Fail", __func__, __LINE__);
+        return -1;
+    }
+/*    if (0 != _TextHdlr_Change_System_Drive(FileName)) {
+        HDLR_WARF("%s() %d, call _TextHdlr_Change_System_Drive(%s) Fail", __func__, __LINE__, FileName);
+        return -1;
+    }*/
+
+    char *Buf = NULL;
+    int BufSize = 0;
+    struct stat FileStat;
+
+    if (0 != TUNE_Parser_Get_LineBuf(_Ituner.ParserObject, &Buf, &BufSize)) {
+        HDLR_WARF("%s() %d, call TUNE_Parser_Get_LineBuf() Fail", __func__, __LINE__);
+        return -1;
+    }
+
+    Fid = open(AscFname, O_RDONLY, 0);
+    if (Fid < 0) {
+        HDLR_WARF("%s() %d, call open(%s) Fail", __func__, __LINE__, AscFname);
+        return -1;
+    }
+
+    fstat(Fid, &FileStat);
+
+    memset(ReadBuffer, 0x0, sizeof(ReadBuffer));
+    char* pReadBuf = &ReadBuffer[32 - (((UINT32)ReadBuffer)%32)];
+    char* pStartOfStr = pReadBuf;
+    char* pDstStr = Buf;
+    pReadBuf = &ReadBuffer[32 - (((UINT32)ReadBuffer)%32)];
+    pStartOfStr = pReadBuf;
+    pDstStr = Buf;
+    int ReadSize;
+    UINT32 len = 0;
+    int i;
+
+    ReadSize = FileStat.st_size;
+    //AmbaPrint("ReadSize: %d", ReadSize);
+
+    while(ReadSize > 0 && read(Fid, pReadBuf, ((ReadSize > BUF_SIZE) ? BUF_SIZE : ReadSize)) > 0) {
+        for (i = 0; i < ((ReadSize > BUF_SIZE) ? BUF_SIZE : ReadSize); i++) {
+            if (pReadBuf[i] == '\n' || pReadBuf[i] == '\r') {
+                pReadBuf[i] = '\0';
+            }
+        }
+        while (1) {
+            len = strlen(pStartOfStr);
+            if (&pStartOfStr[len] >= (pReadBuf + BUF_SIZE)) {
+                strncpy(pDstStr, pStartOfStr, BUF_SIZE - (pStartOfStr - pReadBuf));
+                pDstStr = &Buf[BUF_SIZE - (pStartOfStr - pReadBuf)];
+                pStartOfStr = pReadBuf;
+                // Feed ReadBuf Again
+                break;
+            } else {
+                strncpy(pDstStr, pStartOfStr, BUF_SIZE - (pStartOfStr - pReadBuf));
+                pStartOfStr = &pStartOfStr[len + 1];
+                //AmbaPrint("Feed String: %s", Buf);
+                if (Buf[0] != '\0') {
+                    TUNE_Parser_Parse_Line(_Ituner.ParserObject);
+                    Line++;
+                }
+
+                if (pStartOfStr - pReadBuf >= ReadSize) {
+                    break;
+                }
+                pDstStr = Buf;
+            }
+        }
+        ReadSize -= BUF_SIZE;
+    }
+
+    HDLR_DEBF("%s() %d, Read Line Num: %d", __func__, __LINE__, Line);
+    close(Fid);
+
+
+    AmbaItuner_Get_SystemInfo(&System);
+    // If multi shot mode, read in additional config files
+    _Ituner.TuningModeExt = TUNE_Rule_Lookup_Tuning_Mode_Ext(System.TuningModeExt);
+    /*if (_Ituner.TuningModeExt) {
+        HDLR_DEBF("extended config file to load:%s", System.ExtConfigPath);
+        if (0 != _TextHdlr_Change_System_Drive(System.ExtConfigPath)) {
+            HDLR_WARF("%s() %d, call _TextHdlr_Change_System_Drive(%s) Fail", __func__, __LINE__, System.ExtConfigPath);
+            return -1;
+        }
+        asc_to_uni(System.ExtConfigPath, ExtCfgFileName);
+        Fid = AmbaFS_fopen(ExtCfgFileName, Fmode);
+        if (Fid == 0) {
+            HDLR_WARF("%s() %d, call AmbaFS_fopen(%s) Fail", __func__, __LINE__, ExtCfgFileName);
+            return -1;
+        }
+        while(_read_line(Fid, LineBuf, &Ptr)) {
+            _parse_line(Line, LineBuf, 1);
+            Line++;
+        }
+        AmbaFS_fclose(Fid);
+    }*/
+    return 0;
+}
+
+int TextHdlr_Init(void)
+{
+    int i;
+    Rule_Info_t Rule_Info;
+    TUNE_Parser_Set_Opmode(ITUNER_DEC);
+    memset(&_Ituner.TuningAlgoMode,0x0, sizeof(amba_img_dsp_mode_cfg_t));
+    _Ituner.TuningAlgoMode.Pipe = AMBA_DSP_IMG_PIPE_VIDEO;
+    _Ituner.TuningAlgoMode.AlgoMode= AMBA_DSP_IMG_ALGO_MODE_FAST;
+    _Ituner.TuningAlgoMode.BatchId= 0;
+    TUNE_Parser_Create(&_Ituner.ParserObject);
+    _Ituner.Is_Idsp_Load_Finish = FALSE;
+    TUNE_Rule_Get_Info(&Rule_Info);
+    for (i = 0; i < Rule_Info.RegCount; i++) {
+        TUNE_Parser_Add_Reg(&Rule_Info.RegList[i], _Ituner.ParserObject);
+    }
+
+    TUNE_Parser_Set_Reglist_Valid(0, _Ituner.ParserObject);
+
+
+    /* //TBD
+    for(i=0; i<MAX_REGS; i++) {
+        if (img_ext_regs[i].index == -1) break;
+		ituner_add_ext_reg(&img_ext_regs[i]);
+    }*/
+    AmbaItuner_Config_t Ituner_Config = {
+        .Hook_Func.Load_Data = TextHdlr_Load_Data,
+        .Hook_Func.Save_Data = TextHdlr_Save_Data,
+    };
+    return AmbaItuner_Init(&Ituner_Config);
+}
+
+int TextHdlr_Load_IDSP(char *Filepath)
+{
+	if (0 != _TextHdlr_Load_Text(Filepath)) {
+	    HDLR_WARF("%s() %d, call _TextHdlr_Load_Text(%s) Fail", __func__, __LINE__, Filepath);
+	    return -1;
+	}
+	_TextHdlr_Update_ItunerInfo();
+	if (0 != _TextHdlr_Check_Param_Completeness()) {
+	    HDLR_WARF("%s() %d, call _TextHdlr_Check_Param_Completeness() Fail", __func__, __LINE__);
+	    return -1;
+	}
+	return 0;
+}
+static int _TextHdlr_Check_Param_Completeness(void)
+{
+    int Filter_Idx;
+    int Param_Idx;
+    int Ret = 0;
+    REG_s* Reg = NULL;
+    PARAM_s* Param = NULL;
+    AMBA_ITUNER_VALID_FILTER_t FilterStatus;
+    AmbaItuner_Get_FilterStatus(&FilterStatus);
+
+    for (Filter_Idx = 0; Filter_Idx < _Ituner.ParserObject->RegCount; Filter_Idx++) {
+        Reg = TUNE_Parser_Get_Reg(Filter_Idx, _Ituner.ParserObject);
+        if (Reg == NULL) {
+            HDLR_WARF("%s() %d, call TUNE_Param_Get_Reg Fail", __func__, __LINE__);
+            continue;
+        }
+        if (FilterStatus[Reg->Index] == 1) {
+            if ((Reg->Valid & ((0x1ULL << Reg->ParamCount) - 1)) != ((0x1ULL << Reg->ParamCount) - 1)) {
+                for (Param_Idx = 0; Param_Idx < Reg->ParamCount; Param_Idx++) {
+                    if (Reg->Valid & (0x1ULL << Param_Idx)) {
+                } else {
+                        Param = TUNE_Parser_Get_Param(Reg, Param_Idx);
+                    HDLR_WARF("%s() %d, Lost Param: %s.%s, %llx", __func__, __LINE__,
+                                Reg->Name, Param->Name, Reg->Valid);
+                    Ret = -1;
+                }
+            }
+        }
+    }
+    }
+    return Ret;
+}
+int TextHdlr_set_ituner(u8* ituner_stream,int size)
+{
+//	_Ituner.Is_Idsp_Load_Finish = TRUE;
+	   if (0 != HT_set_ituner_stream(ituner_stream,size)) {
+		   return -1;
+	   }
+	   _TextHdlr_Update_ItunerInfo();
+   	   if (0 != _TextHdlr_Check_Param_Completeness()) {
+		   HDLR_WARF("%s() %d, call _TextHdlr_Check_Param_Completeness() Fail", __func__, __LINE__);
+		   return -1;
+	   }
+	return 0;
+}
+
+int TextHdlr_Execute_IDSP(int fd_iav, amba_img_dsp_mode_cfg_t Mode, AMBA_ITUNER_PROC_INFO_s *ProcInfo)
+{
+	AmbaItuner_Execute(fd_iav, Mode, ProcInfo);
+	return 0;
+}
+
+int TextHdlr_Get_SystemInfo(ITUNER_SYSTEM_s *System) {
+    AmbaItuner_Get_SystemInfo(System);
+    return 0;
+}
+
+int TextHdlr_Set_SystemInfo(ITUNER_SYSTEM_s *System) {
+    AmbaItuner_Set_SystemInfo(System);
+    return 0;
+}
+int TextHdlr_Get_ItunerInfo(ITUNER_INFO_s *ItunerInfo) {
+    ITUNER_SYSTEM_s System;
+    AmbaItuner_Get_SystemInfo(&System);
+    TUNING_MODE_e TuningMode = TUNE_Rule_Lookup_Tuning_Mode(System.TuningMode);
+    _Ituner.TuningModeExt = TUNE_Rule_Lookup_Tuning_Mode_Ext(System.TuningModeExt);
+    _Ituner.TuningAlgoMode.Pipe = _TextHdlr_Get_Imag_Pipe(TuningMode);
+    _Ituner.TuningAlgoMode.AlgoMode = _TextHdlr_Get_Image_Algo_Mode(TuningMode);
+    _Ituner.TuningAlgoMode.BatchId = 0;//(_Ituner.TuningAlgoMode.Pipe == AMBA_DSP_IMG_PIPE_VIDEO)? AMBA_DSP_VIDEO_FILTER : AMBA_DSP_STILL_LISO_FILTER;
+    memcpy(&ItunerInfo->TuningAlgoMode, &_Ituner.TuningAlgoMode, sizeof(ItunerInfo->TuningAlgoMode));
+    ItunerInfo->TuningModeExt = _Ituner.TuningModeExt;
+    return 0;
+}
+static int _TextHdlr_Update_ItunerInfo(void)
+{
+    ITUNER_SYSTEM_s System;
+    AmbaItuner_Get_SystemInfo(&System);
+    TUNING_MODE_e TuningMode = TUNE_Rule_Lookup_Tuning_Mode(System.TuningMode);
+    _Ituner.TuningModeExt = TUNE_Rule_Lookup_Tuning_Mode_Ext(System.TuningModeExt);
+    _Ituner.TuningAlgoMode.Pipe = _TextHdlr_Get_Imag_Pipe(TuningMode);
+    _Ituner.TuningAlgoMode.AlgoMode = _TextHdlr_Get_Image_Algo_Mode(TuningMode);
+    _Ituner.TuningAlgoMode.BatchId = 0;//(_Ituner.TuningAlgoMode.Pipe == AMBA_DSP_IMG_PIPE_VIDEO)? AMBA_DSP_VIDEO_FILTER : AMBA_DSP_STILL_LISO_FILTER;
+    if (TuningMode == IMG_MODE_NIGHT_PORTRAIT_STILL) {
+        System.InputPicCnt = 4;
+    } else {
+        System.InputPicCnt = 1;
+    }
+    AmbaItuner_Set_SystemInfo(&System);
+    return 0;
+}
+
+static int _TextHdlr_Update_System_Info(amba_img_dsp_mode_cfg_t Mode)
+{
+    ITUNER_SYSTEM_s System;
+    char const *Tuning_Mode_Str;
+    AmbaItuner_Get_SystemInfo(&System);
+    if (Mode.Pipe == AMBA_DSP_IMG_PIPE_VIDEO) {
+        if (Mode.AlgoMode == AMBA_DSP_IMG_ALGO_MODE_HISO) {
+            Tuning_Mode_Str = TUNE_Rule_Lookup_Tuning_Mode_Str(IMG_MODE_HIGH_ISO_VIDEO);
+        } else {
+            Tuning_Mode_Str = TUNE_Rule_Lookup_Tuning_Mode_Str(IMG_MODE_VIDEO);
+        }
+    } else { //AMBA_DSP_IMG_PIPE_STILL
+        if (Mode.AlgoMode == AMBA_DSP_IMG_ALGO_MODE_HISO) {
+            Tuning_Mode_Str = TUNE_Rule_Lookup_Tuning_Mode_Str(IMG_MODE_HIGH_ISO_STILL);
+        } else {
+            Tuning_Mode_Str = TUNE_Rule_Lookup_Tuning_Mode_Str(IMG_MODE_LOW_ISO_STILL);
+        }
+    }
+    strncpy(System.TuningMode, Tuning_Mode_Str, sizeof(System.TuningMode));
+    AmbaItuner_Set_SystemInfo(&System);
+    return 0;
+}
+
+
+static int _TextHdlr_Get_Ext_File_Path(Ituner_Ext_File_Type_e Ext_File_Type, char *Ext_File_path)
+{
+    char* Ext_pos;
+    if (strlen(Ituner_File_Path) < 7) {
+        HDLR_ERRF("%s() %d, Ituner_File_Path = %s, it should not happened!", __func__, __LINE__, Ext_File_path);
+        return -1;
+    }
+    strncpy(Ext_File_path, Ituner_File_Path, 64);
+    Ext_pos = strrchr(Ext_File_path, '.');
+    if (Ext_pos == NULL) {
+        HDLR_WARF("%s() %d, Ituner_File_Path = %s, it should not happened!", __func__, __LINE__, Ext_File_path);
+        return -1;
+    }
+    *Ext_pos = '\0';
+    switch (Ext_File_Type) {
+    case EXT_FILE_FPN_MAP:
+        strcat(Ext_File_path, "_Fpn_Map.bin");
+        break;
+    case EXT_FILE_VIGNETTE_GAIN:
+        strcat(Ext_File_path, "_Vignette_Gain.bin");
+        break;
+    case EXT_FILE_WARP_TABLE:
+        strcat(Ext_File_path, "_Warp_Table.bin");
+        break;
+    case EXT_FILE_CA_TABLE:
+        strcat(Ext_File_path, "_Ca_Table.bin");
+        break;
+    case EXT_FILE_CC_REG:
+        strcat(Ext_File_path, "_CC_Reg.bin");
+        break;
+    case EXT_FILE_CC_THREED:
+        strcat(Ext_File_path, "_CC_3d.bin");
+            break;
+    default:
+        HDLR_ERRF("%s() %d, Invalid Ext_File_Type = %d", __func__, __LINE__, Ext_File_Type);
+        return -1;
+    }
+    return 0;
+}
+
+static int _TextHdlr_Load_Raw(Ituner_Ext_File_Param_s *Ext_File_Param)
+{
+    int Ret = 0;
+/*    char UniRawPath[256];
+    ITUNER_SYSTEM_s System;
+    AMBA_FS_FILE *Fd;
+    AmbaItuner_Get_SystemInfo(&System);
+    if (strlen(System.RawPath) < 8 || Ext_File_Param->Raw_Load_Param.Address == NULL || Ext_File_Param->Raw_Load_Param.Max_Size == 0) {
+        HDLR_WARF("%s() %d, RawPath: %s, Addr: %p, Max_Size: %d",
+            __func__, __LINE__, System.RawPath, Ext_File_Param->Raw_Load_Param.Address, Ext_File_Param->Raw_Load_Param.Max_Size);
+        return -1;
+    }
+    if (0 != _TextHdlr_Change_System_Drive(System.RawPath)) {
+        HDLR_WARF("%s() %d, call _TextHdlr_Change_System_Drive(%s) Fail", __func__, __LINE__, System.RawPath);
+        return -1;
+    }
+    asc_to_uni(System.RawPath, UniRawPath);
+    Fd = AmbaFS_fopen(UniRawPath, "r");
+    if (Fd == NULL) {
+        HDLR_WARF("%s() %d, call AmbaFS_fopen(%s) Fail", __func__, __LINE__, UniRawPath);
+        return -1;
+    }
+    int InputPitch = ((System.RawPitch + 31) >> 5) << 5;
+    int i;
+    int Offset = 0;
+    for (i = 0; i < System.RawHeight; i++) {
+        if ((Offset + System.RawPitch) > Ext_File_Param->Raw_Load_Param.Max_Size) {
+            HDLR_WARF("%s() %d, Load Size Buffer Full, Max_Size = %d, i = %d, InputPitch = %d",
+                __func__, __LINE__, Ext_File_Param->Raw_Load_Param.Max_Size, i, InputPitch);
+            Ret = -1;
+        }
+        AmbaFS_fread(&((UINT8*)Ext_File_Param->Raw_Load_Param.Address)[Offset], System.RawPitch, 1, Fd);
+        Offset += InputPitch;
+    }
+    AmbaFS_fclose(Fd);*/
+    return Ret;
+}
+
+static int _TextHldr_Load_Vignette(Ituner_Ext_File_Param_s *Ext_File_Param)
+{
+    ITUNER_VIGNETTE_s VignetteCompensation;
+    AmbaItuner_Get_VignetteCompensation(&VignetteCompensation);
+    if (VignetteCompensation.Enable) {
+        HDLR_DEBF("%s() %d, Load Vignette Gain", __func__, __LINE__);
+        if (Ext_File_Param == NULL) {
+            HDLR_ERRF("%s() %d, Ext_File_Param = NULL", __func__, __LINE__);
+            return -1;
+        }
+        if (strlen(VignetteCompensation.CalibTablePath) < 4 || Ext_File_Param->Vignette_Gain_Load_Param.Address == NULL || Ext_File_Param->Vignette_Gain_Load_Param.Size == 0) {
+            HDLR_DEBF("%s() %d, Vignette_Gain_Path = %s, Address = %p, Size = %d",
+                    __func__, __LINE__, VignetteCompensation.CalibTablePath, Ext_File_Param->Vignette_Gain_Load_Param.Address, Ext_File_Param->Vignette_Gain_Load_Param.Size);
+            return 0;
+        }
+        if (_TextHdlr_load_Ext_file(VignetteCompensation.CalibTablePath, Ext_File_Param->Vignette_Gain_Load_Param.Size, Ext_File_Param->Vignette_Gain_Load_Param.Address) < 0) {
+            HDLR_WARF("%s() %d, call _TextHdlr_load_ext_file(%s, Addr : %p) Fail",
+                    __func__, __LINE__,VignetteCompensation.CalibTablePath, Ext_File_Param->Vignette_Gain_Load_Param.Address);
+            return -1;
+        }
+    } else {
+        HDLR_DEBF("%s() %d, Vignette Disable, Skip Load Process", __func__, __LINE__);
+    }
+    return 0;
+}
+
+static int _TextHldr_Load_Bypass_Vignette(Ituner_Ext_File_Param_s *Ext_File_Param)
+{
+    ITUNER_VIGNETTE_BYPASS_s VignetteCompensationByPass;
+    AmbaItuner_Get_VignetteCompensationByPass(&VignetteCompensationByPass);
+    if (VignetteCompensationByPass.Enable) {
+        HDLR_DEBF("%s() %d, Load Bypass Vignette Gain", __func__, __LINE__);
+        if (Ext_File_Param == NULL) {
+            HDLR_ERRF("%s() %d, Ext_File_Param = NULL", __func__, __LINE__);
+            return -1;
+        }
+
+        if (strlen(VignetteCompensationByPass.GainPath) < 4 || Ext_File_Param->Bypass_Vignette_Gain_Load_Param.Address == NULL || Ext_File_Param->Bypass_Vignette_Gain_Load_Param.Size == 0) {
+            HDLR_ERRF("%s() %d, Bypass Vignette_Gain_Path = %s, Address = %p, Size = %d",
+                    __func__, __LINE__, VignetteCompensationByPass.GainPath, Ext_File_Param->Bypass_Vignette_Gain_Load_Param.Address, Ext_File_Param->Bypass_Vignette_Gain_Load_Param.Size);
+            return -1;
+        }
+        if (_TextHdlr_load_Ext_file(VignetteCompensationByPass.GainPath, Ext_File_Param->Bypass_Vignette_Gain_Load_Param.Size, Ext_File_Param->Bypass_Vignette_Gain_Load_Param.Address) < 0) {
+            HDLR_WARF("%s() %d, call _TextHdlr_load_ext_file(%s, Addr : %p) Fail",
+                    __func__, __LINE__,VignetteCompensationByPass.GainPath, Ext_File_Param->Bypass_Vignette_Gain_Load_Param.Address);
+            return -1;
+        }
+    } else {
+        HDLR_DEBF("%s() %d, Bypass Vignette Disable, Skip Load Process", __func__, __LINE__);
+    }
+    return 0;
+}
+static int _TextHdlr_Load_Warp_Table(Ituner_Ext_File_Param_s *Ext_File_Param)
+{
+    ITUNER_WARP_s WarpCompensation;
+    AmbaItuner_Get_WarpCompensation(&WarpCompensation);
+    if (WarpCompensation.Enable) {
+        HDLR_DEBF("%s() %d, Load Warp Table", __func__, __LINE__);
+        if (Ext_File_Param == NULL) {
+            HDLR_ERRF("%s() %d, Ext_File_Param = NULL", __func__, __LINE__);
+            return -1;
+        }
+        if (strlen(WarpCompensation.WarpGridTablePath) < 4 || Ext_File_Param->Warp_Table_Load_Param.Address == NULL || Ext_File_Param->Warp_Table_Load_Param.Size == 0) {
+            HDLR_ERRF("%s() %d, Warp_Table_Path = %s, Address = %p, Size = %d",
+                    __func__, __LINE__, WarpCompensation.WarpGridTablePath, Ext_File_Param->Warp_Table_Load_Param.Address, Ext_File_Param->Warp_Table_Load_Param.Size);
+            return -1;
+        }
+        if (_TextHdlr_load_Ext_file(WarpCompensation.WarpGridTablePath, Ext_File_Param->Warp_Table_Load_Param.Size, Ext_File_Param->Warp_Table_Load_Param.Address) < 0) {
+            HDLR_WARF("%s() %d, call _TextHdlr_load_ext_file(%s, Addr : %p) Fail",
+                    __func__, __LINE__,WarpCompensation.WarpGridTablePath, Ext_File_Param->Warp_Table_Load_Param.Address);
+            return -1;
+        }
+    } else {
+        HDLR_DEBF("%s() %d, Warp Disable, Skip Load Process", __func__, __LINE__);
+    }
+    return 0;
+}
+
+static int _TextHdlr_Load_Bypass_Horizontal_Table(Ituner_Ext_File_Param_s *Ext_File_Param)
+{
+    ITUNER_WARP_DZOOM_BYPASS_s WarpCompensationDzoomByPass;
+    AmbaItuner_Get_WarpCompensationDzoomByPass(&WarpCompensationDzoomByPass);
+    if (WarpCompensationDzoomByPass.WarpControl) {
+        HDLR_DEBF("%s() %d, Load Warp Horizontal Table", __func__, __LINE__);
+        if (Ext_File_Param == NULL) {
+            HDLR_ERRF("%s() %d, Ext_File_Param = NULL", __func__, __LINE__);
+            return -1;
+        }
+
+        if (strlen(WarpCompensationDzoomByPass.WarpHorizontalTablePath) < 4 || Ext_File_Param->Bypass_Warp_Horizontal_Table_Load_Param.Address == NULL || Ext_File_Param->Bypass_Warp_Horizontal_Table_Load_Param.Max_Size == 0) {
+            HDLR_ERRF("%s() %d, Warp_Horizontal_Table_Path = %s, Address = %p, Size = %d",
+                    __func__, __LINE__, WarpCompensationDzoomByPass.WarpHorizontalTablePath, Ext_File_Param->Bypass_Warp_Horizontal_Table_Load_Param.Address, Ext_File_Param->Bypass_Warp_Horizontal_Table_Load_Param.Max_Size);
+            return -1;
+        }
+        //AMBA_FS_STAT FileInfo;
+        struct stat tmp_fileinfo;
+//        if (AmbaFS_Stat(WarpCompensationDzoomByPass.WarpHorizontalTablePath, &FileInfo) != OK) {
+	if(stat(WarpCompensationDzoomByPass.WarpHorizontalTablePath, &tmp_fileinfo)<0){
+            HDLR_WARF("%s() %d, call AmbaFS_Stat(%s) Fail", __func__, __LINE__, WarpCompensationDzoomByPass.WarpHorizontalTablePath);
+            return -1;
+        }
+//        if (FileInfo.Size > Ext_File_Param->Bypass_Warp_Horizontal_Table_Load_Param.Max_Size) {
+	if(tmp_fileinfo.st_size> Ext_File_Param->Bypass_Warp_Horizontal_Table_Load_Param.Max_Size) {
+            HDLR_WARF("%s() %d, call Invalid File Size", __func__, __LINE__);
+            return -1;
+        }
+//        if (_TextHdlr_load_Ext_file(WarpCompensationDzoomByPass.WarpHorizontalTablePath, FileInfo.Size, Ext_File_Param->Bypass_Warp_Horizontal_Table_Load_Param.Address) < 0) {
+      if (_TextHdlr_load_Ext_file(WarpCompensationDzoomByPass.WarpHorizontalTablePath, tmp_fileinfo.st_size, Ext_File_Param->Bypass_Warp_Horizontal_Table_Load_Param.Address) < 0) {
+
+            HDLR_WARF("%s() %d, call _TextHdlr_load_ext_file(%s, Addr : %p) Fail",
+                    __func__, __LINE__,WarpCompensationDzoomByPass.WarpHorizontalTablePath, Ext_File_Param->Bypass_Warp_Horizontal_Table_Load_Param.Address);
+            return -1;
+        }
+    } else {
+        HDLR_DEBF("%s() %d, Bypass Horizontal Warp Disable, Skip Load Process", __func__, __LINE__);
+    }
+    return 0;
+}
+
+static int _TextHdlr_Load_Bypass_Vertical_Table(Ituner_Ext_File_Param_s *Ext_File_Param)
+{
+    ITUNER_WARP_DZOOM_BYPASS_s WarpCompensationDzoomByPass;
+    AmbaItuner_Get_WarpCompensationDzoomByPass(&WarpCompensationDzoomByPass);
+    if (WarpCompensationDzoomByPass.VertWarpEnable) {
+        HDLR_DEBF("%s() %d, Load Warp Vertical Table", __func__, __LINE__);
+        if (Ext_File_Param == NULL) {
+            HDLR_ERRF("%s() %d, Ext_File_Param = NULL", __func__, __LINE__);
+            return -1;
+        }
+
+        if (strlen(WarpCompensationDzoomByPass.WarpVerticalTablePath) < 4 || Ext_File_Param->Bypass_Warp_Vertical_Table_Load_Param.Address == NULL || Ext_File_Param->Bypass_Warp_Vertical_Table_Load_Param.Max_Size == 0) {
+            HDLR_ERRF("%s() %d, Warp_Vertical_Table_Path = %s, Address = %p, Size = %d",
+                    __func__, __LINE__, WarpCompensationDzoomByPass.WarpVerticalTablePath, Ext_File_Param->Bypass_Warp_Vertical_Table_Load_Param.Address, Ext_File_Param->Bypass_Warp_Vertical_Table_Load_Param.Max_Size);
+            return -1;
+        }
+//        AMBA_FS_STAT FileInfo;
+	struct stat tmp_fileinfo;
+//        if (AmbaFS_Stat(WarpCompensationDzoomByPass.WarpVerticalTablePath, &FileInfo) != OK) {
+    	if (stat(WarpCompensationDzoomByPass.WarpVerticalTablePath, &tmp_fileinfo) <0) {
+            HDLR_WARF("%s() %d, call AmbaFS_Stat(%s) Fail", __func__, __LINE__, WarpCompensationDzoomByPass.WarpVerticalTablePath);
+            return -1;
+        }
+        if (tmp_fileinfo.st_size > Ext_File_Param->Bypass_Warp_Vertical_Table_Load_Param.Max_Size) {
+            HDLR_WARF("%s() %d, call Invalid File Size", __func__, __LINE__);
+            return -1;
+        }
+        if (_TextHdlr_load_Ext_file(WarpCompensationDzoomByPass.WarpVerticalTablePath, tmp_fileinfo.st_size, Ext_File_Param->Bypass_Warp_Vertical_Table_Load_Param.Address) < 0) {
+            HDLR_WARF("%s() %d, call _TextHdlr_load_ext_file(%s, Addr : %p) Fail",
+                    __func__, __LINE__,WarpCompensationDzoomByPass.WarpVerticalTablePath, Ext_File_Param->Bypass_Warp_Vertical_Table_Load_Param.Address);
+            return -1;
+        }
+    } else {
+        HDLR_DEBF("%s() %d, Bypass Vertical Warp Disable, Skip Load Process", __func__, __LINE__);
+    }
+    return 0;
+}
+
+static int _TextHdlr_Load_Ca_Table(Ituner_Ext_File_Param_s *Ext_File_Param)
+{
+    ITUNER_CHROMA_ABERRATION_s ChromaAberrationInfo;
+    AmbaItuner_Get_ChromaAberrationInfo(&ChromaAberrationInfo);
+    if (ChromaAberrationInfo.Enable) {
+        HDLR_DEBF("%s() %d, Load Ca Table", __func__, __LINE__);
+        if (Ext_File_Param == NULL) {
+            HDLR_ERRF("%s() %d, Ext_File_Param = NULL", __func__, __LINE__);
+            return -1;
+        }
+        if (strlen(ChromaAberrationInfo.CaGridTablePath) < 4 || Ext_File_Param->Ca_Table_Load_Param.Address == NULL || Ext_File_Param->Ca_Table_Load_Param.Size == 0) {
+            HDLR_ERRF("%s() %d, Ca_Table_Path = %s, Address = %p, Size = %d",
+                    __func__, __LINE__, ChromaAberrationInfo.CaGridTablePath, Ext_File_Param->Ca_Table_Load_Param.Address, Ext_File_Param->Ca_Table_Load_Param.Size);
+            return -1;
+        }
+        if (_TextHdlr_load_Ext_file(ChromaAberrationInfo.CaGridTablePath, Ext_File_Param->Ca_Table_Load_Param.Size, Ext_File_Param->Ca_Table_Load_Param.Address) < 0) {
+            HDLR_WARF("%s() %d, call _TextHdlr_load_ext_file(%s, Addr : %p) Fail",
+                    __func__, __LINE__,ChromaAberrationInfo.CaGridTablePath, Ext_File_Param->Ca_Table_Load_Param.Address);
+            return -1;
+        }
+    } else {
+        HDLR_DEBF("%s() %d, Ca Disable, Skip Load Process", __func__, __LINE__);
+    }
+    return 0;
+}
+
+static int _TextHldr_Load_Bypass_Ca_Horizontal_Table(Ituner_Ext_File_Param_s *Ext_File_Param)
+{
+    ITUNER_CHROMA_ABERRATION_BYPASS_s ChromaAberrationInfoByPass;
+    AmbaItuner_Get_ChromaAberrationInfoByPass(&ChromaAberrationInfoByPass);
+
+    if (ChromaAberrationInfoByPass.HorzWarpEnable) {
+        HDLR_DEBF("%s() %d, Load Bypass Horizontal Ca Table", __func__, __LINE__);
+        if (Ext_File_Param == NULL) {
+            HDLR_ERRF("%s() %d, Ext_File_Param = NULL", __func__, __LINE__);
+            return -1;
+        }
+
+        if (strlen(ChromaAberrationInfoByPass.WarpHorzTablePath) < 4 || Ext_File_Param->Bypass_Ca_Horizontal_Table_Load_Param.Address == NULL || Ext_File_Param->Bypass_Ca_Horizontal_Table_Load_Param.Max_Size == 0) {
+            HDLR_ERRF("%s() %d, Bypass Horizontal Ca_Table_Path = %s, Address = %p, Max_Size = %d",
+                    __func__, __LINE__, ChromaAberrationInfoByPass.WarpHorzTablePath, Ext_File_Param->Bypass_Ca_Horizontal_Table_Load_Param.Address, Ext_File_Param->Bypass_Ca_Horizontal_Table_Load_Param.Max_Size);
+            return -1;
+        }
+        //AMBA_FS_STAT FileInfo;
+        struct stat tmp_fileinfo;
+        if (stat(ChromaAberrationInfoByPass.WarpHorzTablePath, &tmp_fileinfo) <0) {
+            HDLR_WARF("%s() %d, call AmbaFS_Stat(%s) Fail", __func__, __LINE__, ChromaAberrationInfoByPass.WarpHorzTablePath);
+            return -1;
+        }
+        if (tmp_fileinfo.st_size > Ext_File_Param->Bypass_Ca_Horizontal_Table_Load_Param.Max_Size) {
+            HDLR_WARF("%s() %d, call Invalid File Size", __func__, __LINE__);
+            return -1;
+        }
+        if (_TextHdlr_load_Ext_file(ChromaAberrationInfoByPass.WarpHorzTablePath, tmp_fileinfo.st_size, Ext_File_Param->Bypass_Ca_Horizontal_Table_Load_Param.Address) < 0) {
+            HDLR_WARF("%s() %d, call _TextHdlr_load_ext_file(%s, Addr : %p) Fail",
+                    __func__, __LINE__,ChromaAberrationInfoByPass.WarpHorzTablePath, Ext_File_Param->Bypass_Ca_Horizontal_Table_Load_Param.Address);
+            return -1;
+        }
+    } else {
+        HDLR_DEBF("%s() %d, Bypass Horizontal Ca Disable, Skip Load Process", __func__, __LINE__);
+    }
+    return 0;
+}
+static int _TextHdlr_Load_Bypass_Ca_Vertical_Table(Ituner_Ext_File_Param_s *Ext_File_Param)
+{
+    ITUNER_CHROMA_ABERRATION_BYPASS_s ChromaAberrationInfoByPass;
+    AmbaItuner_Get_ChromaAberrationInfoByPass(&ChromaAberrationInfoByPass);
+
+    if (ChromaAberrationInfoByPass.VertWarpEnable) {
+        HDLR_DEBF("%s() %d, Load Bypass Vertical Ca Table", __func__, __LINE__);
+        if (Ext_File_Param == NULL) {
+            HDLR_ERRF("%s() %d, Ext_File_Param = NULL", __func__, __LINE__);
+            return -1;
+        }
+
+        if (strlen(ChromaAberrationInfoByPass.WarpVertTablePath) < 4 || Ext_File_Param->Bypass_Ca_Vertical_Table_Load_Param.Address == NULL || Ext_File_Param->Bypass_Ca_Vertical_Table_Load_Param.Max_Size == 0) {
+            HDLR_ERRF("%s() %d, Bypass Vertical Ca_Table_Path = %s, Address = %p, Max_Size = %d",
+                    __func__, __LINE__, ChromaAberrationInfoByPass.WarpVertTablePath, Ext_File_Param->Bypass_Ca_Vertical_Table_Load_Param.Address, Ext_File_Param->Bypass_Ca_Vertical_Table_Load_Param.Max_Size);
+            return -1;
+        }
+//        AMBA_FS_STAT FileInfo;
+	struct stat tmp_fileinfo;
+        if (stat(ChromaAberrationInfoByPass.WarpVertTablePath, &tmp_fileinfo) <0) {
+            HDLR_WARF("%s() %d, call AmbaFS_Stat(%s) Fail", __func__, __LINE__, ChromaAberrationInfoByPass.WarpVertTablePath);
+            return -1;
+        }
+        if (tmp_fileinfo.st_size > Ext_File_Param->Bypass_Ca_Vertical_Table_Load_Param.Max_Size) {
+            HDLR_WARF("%s() %d, call Invalid File Size", __func__, __LINE__);
+            return -1;
+        }
+        if (_TextHdlr_load_Ext_file(ChromaAberrationInfoByPass.WarpVertTablePath, tmp_fileinfo.st_size, Ext_File_Param->Bypass_Ca_Vertical_Table_Load_Param.Address) < 0) {
+            HDLR_WARF("%s() %d, call _TextHdlr_load_ext_file(%s, Addr : %p) Fail",
+                    __func__, __LINE__,ChromaAberrationInfoByPass.WarpVertTablePath, Ext_File_Param->Bypass_Ca_Vertical_Table_Load_Param.Address);
+            return -1;
+        }
+    } else {
+        HDLR_DEBF("%s() %d, Bypass Vertical Ca Disable, Skip Load Process", __func__, __LINE__);
+    }
+    return 0;
+}
+
+static int _TextHdlr_Load_FPN_Map(Ituner_Ext_File_Param_s *Ext_File_Param)
+{
+    ITUNER_FPN_s StaticBadPixelCorrection;
+    AmbaItuner_Get_StaticBadPixelCorrection(&StaticBadPixelCorrection);
+    if (StaticBadPixelCorrection.Enable) {
+        HDLR_DEBF("%s() %d, Load FPN Map", __func__, __LINE__);
+        if (Ext_File_Param == NULL) {
+            HDLR_ERRF("%s() %d, Ext_File_Param = NULL", __func__, __LINE__);
+            return -1;
+        }
+        if (strlen(StaticBadPixelCorrection.MapPath) < 4 || Ext_File_Param->FPN_MAP_Ext_Load_Param.Address == NULL || Ext_File_Param->FPN_MAP_Ext_Load_Param.Size == 0) {
+            HDLR_ERRF("%s() %d, FPN_Map_Path = %s, Address = %p, Size = %d",
+                    __func__, __LINE__, StaticBadPixelCorrection.MapPath, Ext_File_Param->FPN_MAP_Ext_Load_Param.Address, Ext_File_Param->FPN_MAP_Ext_Load_Param.Size);
+            return -1;
+        }
+        if (_TextHdlr_load_Ext_file(StaticBadPixelCorrection.MapPath, Ext_File_Param->FPN_MAP_Ext_Load_Param.Size, Ext_File_Param->FPN_MAP_Ext_Load_Param.Address) < 0) {
+            HDLR_WARF("%s() %d, call _TextHdlr_load_ext_file(%s, Addr : %p) Fail",
+                    __func__, __LINE__,StaticBadPixelCorrection.MapPath, Ext_File_Param->FPN_MAP_Ext_Load_Param.Address);
+            return -1;
+        }
+    } else {
+        HDLR_DEBF("%s() %d, FPN Disable, Skip Load Process", __func__, __LINE__);
+    }
+    return 0;
+}
+
+static int _TextHdlr_Load_Bypass_FPN_Map(Ituner_Ext_File_Param_s *Ext_File_Param)
+{
+    ITUNER_FPN_BYPASS_s StaticBadPixelCorrectionByPass;
+    AmbaItuner_Get_StaticBadPixelCorrectionByPass(&StaticBadPixelCorrectionByPass);
+    if (StaticBadPixelCorrectionByPass.Enable) {
+        HDLR_DEBF("%s() %d, Load Bypass FPN Map", __func__, __LINE__);
+        if (Ext_File_Param == NULL) {
+            HDLR_ERRF("%s() %d, Ext_File_Param = NULL", __func__, __LINE__);
+            return -1;
+        }
+        if (strlen(StaticBadPixelCorrectionByPass.MapPath) < 4 || Ext_File_Param->Bypass_FPN_MAP_Ext_Load_Param.Address == NULL || Ext_File_Param->Bypass_FPN_MAP_Ext_Load_Param.Size == 0) {
+            HDLR_ERRF("%s() %d, FPN_Map_Path = %s, Address = %p, Size = %d",
+                    __func__, __LINE__, StaticBadPixelCorrectionByPass.MapPath, Ext_File_Param->Bypass_FPN_MAP_Ext_Load_Param.Address, Ext_File_Param->Bypass_FPN_MAP_Ext_Load_Param.Size);
+            return -1;
+        }
+        if (_TextHdlr_load_Ext_file(StaticBadPixelCorrectionByPass.MapPath, Ext_File_Param->Bypass_FPN_MAP_Ext_Load_Param.Size, Ext_File_Param->Bypass_FPN_MAP_Ext_Load_Param.Address) < 0) {
+            HDLR_WARF("%s() %d, call _TextHdlr_load_ext_file(%s, Addr : %p) Fail",
+                    __func__, __LINE__,StaticBadPixelCorrectionByPass.MapPath, Ext_File_Param->Bypass_FPN_MAP_Ext_Load_Param.Address);
+            return -1;
+        }
+    } else {
+        HDLR_DEBF("%s() %d, Bypass FPN Disable, Skip Load Process", __func__, __LINE__);
+    }
+    return 0;
+}
+
+static int _TextHdlr_Load_CC_Reg(Ituner_Ext_File_Param_s *Ext_File_Param)
+{
+    ITUNER_COLOR_CORRECTION_s ColorCorrection;
+    AmbaItuner_Get_ColorCorrection(&ColorCorrection);
+    if (strlen(ColorCorrection.RegPath) < 4 || Ext_File_Param->CC_Reg_Load_Param.Address == NULL || Ext_File_Param->CC_Reg_Load_Param.Size == 0) {
+        HDLR_ERRF("%s() %d, CC Reg Path = %s, Address = %p, Size = %d",
+                __func__, __LINE__, ColorCorrection.RegPath, Ext_File_Param->CC_Reg_Load_Param.Address, Ext_File_Param->CC_Reg_Load_Param.Size);
+        return -1;
+    }
+    if (_TextHdlr_load_Ext_file(ColorCorrection.RegPath, Ext_File_Param->CC_Reg_Load_Param.Size, Ext_File_Param->CC_Reg_Load_Param.Address) < 0) {
+        HDLR_WARF("%s() %d, call _TextHdlr_load_ext_file(%s, Addr : %p) Fail",
+                __func__, __LINE__,ColorCorrection.RegPath, Ext_File_Param->CC_Reg_Load_Param.Address);
+        return -1;
+    }
+    return 0;
+}
+
+static int _TextHdlr_Load_CC_ThreeD(Ituner_Ext_File_Param_s *Ext_File_Param)
+{
+   ITUNER_COLOR_CORRECTION_s ColorCorrection;
+   AmbaItuner_Get_ColorCorrection(&ColorCorrection);
+   if (strlen(ColorCorrection.ThreeDPath) < 4 || Ext_File_Param->CC_ThreeD_Load_Param.Address == NULL || Ext_File_Param->CC_ThreeD_Load_Param.Size == 0) {
+       HDLR_ERRF("%s() %d, CC 3D Path = %s, Address = %p, Size = %d",
+               __func__, __LINE__, ColorCorrection.ThreeDPath, Ext_File_Param->CC_ThreeD_Load_Param.Address, Ext_File_Param->CC_ThreeD_Load_Param.Size);
+       return -1;
+   }
+   if (_TextHdlr_load_Ext_file(ColorCorrection.ThreeDPath, Ext_File_Param->CC_ThreeD_Load_Param.Size, Ext_File_Param->CC_ThreeD_Load_Param.Address) < 0) {
+       HDLR_WARF("%s() %d, call _TextHdlr_load_ext_file(%s, Addr : %p) Fail",
+               __func__, __LINE__,ColorCorrection.ThreeDPath, Ext_File_Param->CC_ThreeD_Load_Param.Address);
+       return -1;
+   }
+   return 0;
+}
+
+static int _TextHdlr_Save_FPN_Map(Ituner_Ext_File_Param_s *Ext_File_Param)
+{
+    char FilePath[64];
+    ITUNER_FPN_s StaticBadPixelCorrection;
+    AmbaItuner_Get_StaticBadPixelCorrection(&StaticBadPixelCorrection);
+    if (StaticBadPixelCorrection.Enable) {
+        amba_img_dsp_sbp_correction_t SbpCorr;
+        AmbaItuner_Get_SbpCorr(&SbpCorr);
+        if (SbpCorr.CalibSbpInfo.SbpBuffer != NULL) {
+            UINT32 FPN_Map_Size = ITUNER_CAL_FPN_MAP_SIZE(StaticBadPixelCorrection.CailbVinWidth, StaticBadPixelCorrection.CailbVinHeight);
+            HDLR_DEBF("%s() %d, Dump FPN Map", __func__, __LINE__);
+            _TextHdlr_Get_Ext_File_Path(EXT_FILE_FPN_MAP, FilePath);
+            strncpy(StaticBadPixelCorrection.MapPath, FilePath, sizeof(StaticBadPixelCorrection.MapPath));
+            AmbaItuner_Set_StaticBadPixelCorrection(&StaticBadPixelCorrection);
+            HDLR_DEBF("%s() %d, Dump FPN Map Address %s, size %d, to %s", __func__, __LINE__, SbpCorr.CalibSbpInfo.SbpBuffer,  FPN_Map_Size, StaticBadPixelCorrection.MapPath);
+            if (_TextHdlr_Save_Ext_File(StaticBadPixelCorrection.MapPath, FPN_Map_Size, SbpCorr.CalibSbpInfo.SbpBuffer) < 0) {
+                HDLR_WARF("%s() %d, call _TextHdlr_Save_Ext_File(%s, Addr : %p) Fail", __func__, __LINE__, StaticBadPixelCorrection.MapPath, SbpCorr.CalibSbpInfo.SbpBuffer);
+                return -1;
+            }
+        } else {
+            HDLR_WARF("%s() %d, EXT_FILE_FPN_MAP, FPN_Map_Addr = NULL", __func__, __LINE__);
+        }
+    } else {
+        HDLR_DEBF("%s() %d, FPN Disable, Skip Dump Process", __func__, __LINE__);
+    }
+    return 0;
+}
+static int _TextHdlr_Save_Vignette(Ituner_Ext_File_Param_s *Ext_File_Param)
+{
+    char FilePath[64];
+    ITUNER_VIGNETTE_s VignetteCompensation;
+    AmbaItuner_Get_VignetteCompensation(&VignetteCompensation);
+    if (VignetteCompensation.Enable) {
+        amba_img_dsp_vignette_calc_info_t VignetteCalcInfo;
+        AmbaItuner_Get_VignetteCalcInfo(&VignetteCalcInfo);
+        if (VignetteCalcInfo.CalibVignetteInfo.pVignetteRedGain != NULL && VignetteCalcInfo.CalibVignetteInfo.pVignetteGreenEvenGain != NULL &&
+            VignetteCalcInfo.CalibVignetteInfo.pVignetteGreenOddGain != NULL && VignetteCalcInfo.CalibVignetteInfo.pVignetteBlueGain != NULL) {
+            _TextHdlr_Get_Ext_File_Path(EXT_FILE_VIGNETTE_GAIN, FilePath);
+            strncpy(VignetteCompensation.CalibTablePath, FilePath, sizeof(VignetteCompensation.CalibTablePath));
+            AmbaItuner_Set_VignetteCompensation(&VignetteCompensation);
+            HDLR_DEBF("%s() %d, Dump Vignette Gain Address %p, size %d * 4, to %s",
+                    __func__, __LINE__, VignetteCalcInfo.CalibVignetteInfo.pVignetteRedGain,  ITUNER_VIGNETTE_GAIN_MAP_SIZE, VignetteCompensation.CalibTablePath);
+            {
+                int Fid;
+                //char UniFname[64];
+                /*if (0 != _TextHdlr_Change_System_Drive(VignetteCompensation.CalibTablePath)) {
+                    HDLR_WARF("%s() %d, call _TextHdlr_Change_System_Drive(%s) Fail", __func__, __LINE__, VignetteCompensation.CalibTablePath);
+                    return -1;
+                }
+                asc_to_uni(VignetteCompensation.CalibTablePath, UniFname);*/
+                Fid = open(VignetteCompensation.CalibTablePath, O_WRONLY | O_CREAT, 0666);
+                if (Fid == 0) {
+                    AmbaPrint("[Error] Ext file open fails!");
+                    return -1;
+                }
+                int i;
+                UINT16* SrcAddr[] = {
+                    VignetteCalcInfo.CalibVignetteInfo.pVignetteRedGain,
+                    VignetteCalcInfo.CalibVignetteInfo.pVignetteGreenEvenGain,
+                    VignetteCalcInfo.CalibVignetteInfo.pVignetteGreenOddGain,
+                    VignetteCalcInfo.CalibVignetteInfo.pVignetteBlueGain
+                };
+                for (i = 0; i < 4; i++) {
+                    if (write(Fid, SrcAddr[i], ITUNER_VIGNETTE_GAIN_MAP_SIZE) <= 0) {
+                        HDLR_WARF("%s() %d, call _TextHdlr_Save_Ext_File(%s, Addr : %p) Fail",
+                            __func__, __LINE__, VignetteCompensation.CalibTablePath, SrcAddr[i]);
+                        close(Fid);
+                        return -1;
+                    }
+                }
+                close(Fid);
+            }
+            /*
+            if (_TextHdlr_Save_Ext_File(VignetteCompensation.CalibTablePath, ITUNER_VIGNETTE_GAIN_MAP_SIZE, VignetteCalcInfo.CalibVignetteInfo.pVignetteRedGain) < 0) {
+                HDLR_WARF("%s() %d, call _TextHdlr_Save_Ext_File(%s, Addr : %p) Fail",
+                        __func__, __LINE__, VignetteCompensation.CalibTablePath, VignetteCalcInfo.CalibVignetteInfo.pVignetteRedGain);
+                return -1;
+            }
+            */
+        } else {
+            HDLR_WARF("%s() %d, EXT_FILE_VIGNETTE_GAIN, VignetteGain Address: %p %p %p %p",
+                    __func__, __LINE__,
+                    VignetteCalcInfo.CalibVignetteInfo.pVignetteRedGain,
+                    VignetteCalcInfo.CalibVignetteInfo.pVignetteGreenEvenGain,
+                    VignetteCalcInfo.CalibVignetteInfo.pVignetteGreenOddGain,
+                    VignetteCalcInfo.CalibVignetteInfo.pVignetteBlueGain);
+        }
+    } else {
+        HDLR_DEBF("%s() %d, Vignette Disable, Skip Dump Process", __func__, __LINE__);
+    }
+    return 0;
+}
+static int _TextHdlr_Save_Warp_Table(Ituner_Ext_File_Param_s *Ext_File_Param)
+{
+    char FilePath[64];
+    ITUNER_WARP_s WarpCompensation;
+    AmbaItuner_Get_WarpCompensation(&WarpCompensation);
+    if (WarpCompensation.Enable) {
+        amba_img_dsp_warp_calc_info_t WarpCalcInfo;
+        AmbaItuner_Get_WarpCalcInfo(&WarpCalcInfo);
+        if (WarpCalcInfo.CalibWarpInfo.pWarp != NULL) {
+            UINT32 Warp_Table_Size = ITUNER_CAL_WARP_TABLE_SIZE(WarpCompensation.HorizontalGridNumber, WarpCompensation.VerticalGridNumber);
+            _TextHdlr_Get_Ext_File_Path(EXT_FILE_WARP_TABLE, FilePath);
+            strncpy(WarpCompensation.WarpGridTablePath, FilePath, sizeof(WarpCompensation.WarpGridTablePath));
+            AmbaItuner_Set_WarpCompensation(&WarpCompensation);
+            HDLR_DEBF("%s() %d, Dump Warp Table Address %p, size %d, to %s",
+                    __func__, __LINE__, WarpCalcInfo.CalibWarpInfo.pWarp,  Warp_Table_Size, WarpCompensation.WarpGridTablePath);
+            if (_TextHdlr_Save_Ext_File(WarpCompensation.WarpGridTablePath, Warp_Table_Size, WarpCalcInfo.CalibWarpInfo.pWarp) < 0) {
+                HDLR_WARF("%s() %d, call _TextHdlr_Save_Ext_File(%s, Addr : %p) Fail",
+                        __func__, __LINE__, WarpCompensation.WarpGridTablePath, WarpCalcInfo.CalibWarpInfo.pWarp);
+                return -1;
+            }
+        } else {
+            HDLR_WARF("%s() %d, EXT_FILE_WARP_TABLE, WarpTable Address: NULL", __func__, __LINE__);
+        }
+    } else {
+        HDLR_DEBF("%s() %d, Warp Disable, Skip Dump Process", __func__, __LINE__);
+    }
+    return 0;
+}
+static int _TextHdlr_Save_Ca_Table(Ituner_Ext_File_Param_s *Ext_File_Param)
+{
+    char FilePath[64];
+    ITUNER_CHROMA_ABERRATION_s ChromaAberrationInfo;
+    AmbaItuner_Get_ChromaAberrationInfo(&ChromaAberrationInfo);
+    if (ChromaAberrationInfo.Enable) {
+        AMBA_DSP_IMG_CAWARP_CALC_INFO_s CACalcInfo;
+        AmbaItuner_Get_CACalcInfo(&CACalcInfo);
+        if (CACalcInfo.CalibCaWarpInfo.pCaWarp != NULL) {
+            UINT32 CA_Table_Size = ITUNER_CAL_CA_TABLE_SIZE(ChromaAberrationInfo.HorizontalGridNumber, ChromaAberrationInfo.VerticalGridNumber);
+            _TextHdlr_Get_Ext_File_Path(EXT_FILE_CA_TABLE, FilePath);
+            strncpy(ChromaAberrationInfo.CaGridTablePath, FilePath, sizeof(ChromaAberrationInfo.CaGridTablePath));
+            AmbaItuner_Set_ChromaAberrationInfo(&ChromaAberrationInfo);
+            HDLR_DEBF("%s() %d, Dump Ca Table Address %p, size %d, to %s",
+                    __func__, __LINE__, CACalcInfo.CalibCaWarpInfo.pCaWarp,  CA_Table_Size, ChromaAberrationInfo.CaGridTablePath);
+            if (_TextHdlr_Save_Ext_File(ChromaAberrationInfo.CaGridTablePath, CA_Table_Size, CACalcInfo.CalibCaWarpInfo.pCaWarp) < 0) {
+                HDLR_WARF("%s() %d, call _TextHdlr_Save_Ext_File(%s, Addr : %p) Fail",
+                        __func__, __LINE__, ChromaAberrationInfo.CaGridTablePath, CACalcInfo.CalibCaWarpInfo.pCaWarp);
+                return -1;
+            }
+        } else {
+            HDLR_WARF("%s() %d, EXT_FILE_CA_TABLE, Ca_Table Address: NULL", __func__, __LINE__);
+        }
+    } else {
+        HDLR_DEBF("%s() %d, Ca Disable, Skip Dump Process", __func__, __LINE__);
+    }
+    return 0;
+}
+
+static int _TextHdlr_Save_CC_Reg(Ituner_Ext_File_Param_s *Ext_File_Param)
+{
+    char FilePath[64];
+    amba_img_dsp_color_correction_reg_t CcReg;
+    AmbaItuner_Get_CcReg(&CcReg);
+    if (CcReg.RegSettingAddr != 0){
+        HDLR_DEBF("%s() %d, Dump CC Reg", __func__, __LINE__);
+        // Note: Update ColorCorrection Path
+        _TextHdlr_Get_Ext_File_Path(EXT_FILE_CC_REG, FilePath);
+        ITUNER_COLOR_CORRECTION_s ColorCorrection;
+        AmbaItuner_Get_ColorCorrection(&ColorCorrection);
+        strncpy(ColorCorrection.RegPath, FilePath, sizeof(ColorCorrection.RegPath));
+        AmbaItuner_Set_ColorCorrection(&ColorCorrection);
+        HDLR_DEBF("%s() %d, Dump CC Reg Address %p to %s", __func__, __LINE__,  (void*)CcReg.RegSettingAddr, ColorCorrection.RegPath);
+        if (_TextHdlr_Save_Ext_File(ColorCorrection.RegPath, AMBA_DSP_IMG_CC_REG_SIZE, (void*)CcReg.RegSettingAddr) < 0) {
+            HDLR_WARF("%s() %d, call _TextHdlr_Save_Ext_File(%s, Addr : %p) Fail", __func__, __LINE__, ColorCorrection.RegPath, (void*)CcReg.RegSettingAddr);
+            return -1;
+        }
+
+    } else {
+        HDLR_WARF("%s() %d, EXT_FILE_CC_REG, RegSettingAddr = NULL", __func__, __LINE__);
+    }
+    return 0;
+}
+static int _TextHdlr_Save_CC_ThreeD(Ituner_Ext_File_Param_s *Ext_File_Param)
+{
+    char FilePath[64];
+    amba_img_dsp_color_correction_t CcThreed;
+    AmbaItuner_Get_CcThreeD(&CcThreed);
+    if (CcThreed.MatrixThreeDTableAddr != 0) {
+        _TextHdlr_Get_Ext_File_Path(EXT_FILE_CC_THREED, FilePath);
+        ITUNER_COLOR_CORRECTION_s ColorCorrection;
+        AmbaItuner_Get_ColorCorrection(&ColorCorrection);
+        strncpy(ColorCorrection.ThreeDPath, FilePath, sizeof(ColorCorrection.ThreeDPath));
+        AmbaItuner_Set_ColorCorrection(&ColorCorrection);
+        HDLR_DEBF("%s() %d, Dump CC ThreeD Address %p to %s", __func__, __LINE__,  (void*)CcThreed.MatrixThreeDTableAddr, ColorCorrection.ThreeDPath);
+        if (_TextHdlr_Save_Ext_File(ColorCorrection.ThreeDPath, AMBA_DSP_IMG_CC_3D_SIZE, (void*)CcThreed.MatrixThreeDTableAddr) < 0) {
+            HDLR_WARF("%s() %d, call _TextHdlr_Save_Ext_File(%s, Addr : %p) Fail", __func__, __LINE__, ColorCorrection.ThreeDPath, (void*)CcThreed.MatrixThreeDTableAddr);
+            return -1;
+        }
+    }
+    return 0;
+}
+
+static int _TextHdlr_Save_Y(Save_Data_to_Path_Info_s *Y_Info)
+{
+    ITUNER_SYSTEM_s System;
+    char FilePath[64] = {0};
+    char *FileName_Pos;
+    char *Ext_Name_Pos;
+//    AMBA_FS_FILE *Fd;
+    int fd;
+    if ((Y_Info->Address == NULL) || (Y_Info->Size == 0)) {
+        HDLR_WARF("%s() %d, Y Addr = %p, Size = %d", __func__, __LINE__, Y_Info->Address, Y_Info->Size);
+        return -1;
+    }
+    AmbaItuner_Get_SystemInfo(&System);
+    memset(FilePath, 0x0, sizeof(FilePath));
+    strncpy(FilePath, Y_Info->Target_File_Path, sizeof(FilePath));
+//    if (0 != _TextHdlr_Change_System_Drive(FilePath)) {
+//        HDLR_WARF("%s() %d, call _TextHdlr_Change_System_Drive(%s) Fail", __func__, __LINE__, FilePath);
+//        return -1;
+//    }
+    FileName_Pos = strrchr(FilePath, '\\');
+//    if (FileName_Pos == NULL) {
+//        HDLR_WARF("%s() %d, FilePath : %s Invalid FileName_Pos: %s", __func__, __LINE__, FilePath, FileName_Pos);
+//        return -1;
+//    }
+    UINT8 Output_Filename_Len = strlen(System.OutputFilename);
+    if (Output_Filename_Len) {
+        sprintf(FileName_Pos + 1, "%s", System.OutputFilename);
+        Ext_Name_Pos = FileName_Pos + 1 + strlen(System.OutputFilename);
+    } else {
+        Ext_Name_Pos = strrchr(FilePath, '.');
+        if (Ext_Name_Pos == NULL) {
+            HDLR_WARF("%s() %d, Invalid FilePath : %s", __func__, __LINE__, FilePath);
+            return -1;
+        }
+
+    }
+    sprintf(Ext_Name_Pos, ".y");
+//    Fd = AmbaFS_fopen(FilePath, "w");
+    fd = open(FilePath, O_WRONLY | O_CREAT, 0666);
+    if (fd <0) {
+        HDLR_WARF("%s() %d, call AmbaFS_fopen(%s) Fail", __func__, __LINE__, FilePath);
+        return -1;
+    }
+    write(fd, Y_Info->Address, Y_Info->Size);
+    close(fd);
+    return 0;
+}
+
+static int _TextHdlr_Save_UV(Save_Data_to_Path_Info_s *UV_Info)
+{
+    ITUNER_SYSTEM_s System;
+    char FilePath[64] = {0};
+    char *FileName_Pos;
+    char *Ext_Name_Pos;
+//  AMBA_FS_FILE *Fd;
+    int fd;
+    if ((UV_Info->Address == NULL) || (UV_Info->Size == 0)) {
+        HDLR_WARF("%s() %d, UV Addr = %p, Size = %d", __func__, __LINE__, UV_Info->Address, UV_Info->Size);
+        return -1;
+    }
+    AmbaItuner_Get_SystemInfo(&System);
+    memset(FilePath, 0x0, sizeof(FilePath));
+    strncpy(FilePath, UV_Info->Target_File_Path, sizeof(FilePath));
+//  if (0 != _TextHdlr_Change_System_Drive(FilePath)) {
+//      HDLR_WARF("%s() %d, call _TextHdlr_Change_System_Drive(%s)", __func__, __LINE__, FilePath);
+//      return -1;
+//  }
+
+  FileName_Pos = strrchr(FilePath, '\\');
+//  if (FileName_Pos == NULL) {
+//      HDLR_WARF("%s() %d, Invalid FileName_Pos: %s", __func__, __LINE__, FileName_Pos);
+//      return -1;
+//  }
+    UINT8 Output_Filename_Len = strlen(System.OutputFilename);
+    if (Output_Filename_Len) {
+        sprintf(FileName_Pos + 1, "%s", System.OutputFilename);
+        Ext_Name_Pos = FileName_Pos + 1 + strlen(System.OutputFilename);
+    } else {
+        Ext_Name_Pos = strrchr(FilePath, '.');
+        if (Ext_Name_Pos == NULL) {
+            HDLR_WARF("%s() %d, Invalid FilePath : %s", __func__, __LINE__, FilePath);
+            return -1;
+        }
+
+    }
+    sprintf(Ext_Name_Pos, ".uv");
+//  Fd = AmbaFS_fopen(FilePath, "w");
+    fd = open(FilePath, O_WRONLY | O_CREAT, 0666);
+    if (fd <0) {
+        HDLR_WARF("%s() %d, call AmbaFS_fopen(%s) Fail", __func__, __LINE__, FilePath);
+        return -1;
+    }
+    write(fd, UV_Info->Address, UV_Info->Size);
+    close(fd);
+    return 0;
+}
+
+static int _TextHdlr_Save_YUV(Ituner_Ext_File_Param_s *Ext_File_Param)
+{
+    int Ret = 0;
+    Ret |= _TextHdlr_Save_Y(&Ext_File_Param->YUV_Save_Param.Y_Info);
+    Ret |= _TextHdlr_Save_UV(&Ext_File_Param->YUV_Save_Param.UV_Info);
+    return Ret;
+}
+
+static int _TextHdlr_Save_and_Load_Dummy(Ituner_Ext_File_Param_s *Ext_File_Param)
+{
+    HDLR_WARF("%s() %d, Not Yet Implement", __func__, __LINE__);
+    return 0;
+}
+
+int TextHdlr_Load_Data(Ituner_Ext_File_Type_e Ext_File_Type, Ituner_Ext_File_Param_s* Ext_File_Param)
+{
+    int (*Load_Data_Api_List[EXT_FILE_MAX])(Ituner_Ext_File_Param_s *Ext_File_Param) =
+    {
+        _TextHdlr_Load_FPN_Map, // EXT_FILE_FPN_MAP
+        _TextHdlr_Load_Bypass_FPN_Map,
+        _TextHldr_Load_Vignette,
+        _TextHldr_Load_Bypass_Vignette,
+        _TextHdlr_Load_Warp_Table,
+        _TextHdlr_Load_Bypass_Horizontal_Table,
+        _TextHdlr_Load_Bypass_Vertical_Table,
+        _TextHdlr_Load_Ca_Table,
+        _TextHldr_Load_Bypass_Ca_Horizontal_Table,
+        _TextHdlr_Load_Bypass_Ca_Vertical_Table,
+        _TextHdlr_Load_CC_Reg,
+        _TextHdlr_Load_CC_ThreeD,
+        _TextHdlr_Load_Raw,
+        _TextHdlr_Save_and_Load_Dummy, //EXT_FILE_JPG
+        _TextHdlr_Save_and_Load_Dummy, //EXT_FILE_YUV
+    };
+    if (Ext_File_Type >= EXT_FILE_MAX) {
+        HDLR_ERRF("%s() %d, Invalid Ext_File_Type %d", __func__, __LINE__, Ext_File_Type);
+        return -1;
+    }
+    return Load_Data_Api_List[Ext_File_Type](Ext_File_Param);
+}
+
+int TextHdlr_Save_Data(Ituner_Ext_File_Type_e Ext_File_Type, Ituner_Ext_File_Param_s* Ext_File_Param)
+{
+    int (*Save_Data_Api_List[EXT_FILE_MAX])(Ituner_Ext_File_Param_s *Ext_File_Param) =
+    {
+        _TextHdlr_Save_FPN_Map, // EXT_FILE_FPN_MAP
+        _TextHdlr_Save_and_Load_Dummy,//_TextHdlr_Save_Bypass_FPN_Map,
+        _TextHdlr_Save_Vignette,
+        _TextHdlr_Save_and_Load_Dummy,//_TextHldr_Save_Bypass_Vignette,
+        _TextHdlr_Save_Warp_Table,
+        _TextHdlr_Save_and_Load_Dummy,//_TextHdlr_Save_Bypass_Horizontal_Table,
+        _TextHdlr_Save_and_Load_Dummy,//_TextHdlr_Save_Bypass_Vertical_Table,
+        _TextHdlr_Save_Ca_Table,
+        _TextHdlr_Save_and_Load_Dummy, //_TextHldr_Save_Bypass_Ca_Horizontal_Table,
+        _TextHdlr_Save_and_Load_Dummy, //_TextHdlr_Save_Bypass_Ca_Vertical_Table,
+        _TextHdlr_Save_CC_Reg,
+        _TextHdlr_Save_CC_ThreeD,
+        _TextHdlr_Save_and_Load_Dummy, //_TextHdlr_Save_Raw,
+        _TextHdlr_Save_and_Load_Dummy,
+        _TextHdlr_Save_YUV,
+    };
+    if (Ext_File_Type >= EXT_FILE_MAX) {
+        HDLR_ERRF("%s() %d, Invalid Ext_File_Type %d", __func__, __LINE__, Ext_File_Type);
+        return -1;
+    }
+    return Save_Data_Api_List[Ext_File_Type](Ext_File_Param);
+}
+
+
+static int _TextHdlr_load_Ext_file(char *FileName, int Size, void *Buf)
+{
+//    AMBA_FS_FILE *Fid;
+    int Fid;
+//    char UniFname[64];
+    int Ret = 0;
+/*    if (0 != _TextHdlr_Change_System_Drive(FileName)) {
+        HDLR_WARF("%s() %d, call _TextHdlr_Change_System_Drive(%s) Fail", __func__, __LINE__, FileName);
+        return -1;
+    }
+    asc_to_uni(FileName, UniFname);*/
+//    Fid = AmbaFS_fopen(UniFname, "r");
+
+    Fid = open(FileName, O_RDONLY, 0);
+    if (Fid < 0) {
+        HDLR_WARF("%s() %d, call AmbaFS_fopen(%s) Fail", __func__, __LINE__, FileName);
+        return -1;
+    }
+    //if (AmbaFS_fread(Buf, Size, 1, Fid)) {
+    if (read(Fid, Buf, Size)!=Size) {
+	    HDLR_WARF("%s() %d, call AmbaFS_fread() Fail, Buf: %p, Size: %d", __func__, __LINE__, Buf, Size);
+	    Ret = -2;
+    }
+//    AmbaFS_fclose(Fid);
+    close(Fid);
+    return Ret;
+}
+
+static int _TextHdlr_Save_Ext_File(char *FileName, int Size, void *Buf)
+{
+//    AMBA_FS_FILE *Fid;
+    int Fid;
+//    char UniFname[64];
+    int Ret = 0;
+/*    if (0 != _TextHdlr_Change_System_Drive(FileName)) {
+        HDLR_WARF("%s() %d, call _TextHdlr_Change_System_Drive(%s) Fail", __func__, __LINE__, FileName);
+        return -1;
+    }
+    asc_to_uni(FileName, UniFname);*/
+//    Fid = AmbaFS_fopen(UniFname, "w");
+    Fid = open(FileName, O_WRONLY | O_CREAT, 0666);
+    if (Fid == 0) {
+        HDLR_WARF("%s() %d, call AmbaFS_fopen(%s) Fail", __func__, __LINE__, FileName);
+        return -1;
+    }
+//    if (AmbaFS_fwrite(Buf, Size, 1, Fid)) {
+    if (write(Fid, Buf, Size)>0) {
+
+    } else {
+        HDLR_WARF("%s() %d, call AmbaFS_fwrite() Fail, Buf: %p, Size: %d", __func__, __LINE__, Buf, Size);
+        Ret = -2;
+    }
+//    AmbaFS_fclose(Fid);
+    close(Fid);
+
+    return Ret;
+}
+static int _TextHdlr_Fill_Ext_File_Path(void)
+{
+    AMBA_ITUNER_VALID_FILTER_t Ituner_Valid;
+    AmbaItuner_Get_FilterStatus(&Ituner_Valid);
+    // Note: Without Return Fail, Because it should be happen.
+    if (Ituner_Valid[ITUNER_COLOR_CORRECTION] == 1) {
+        if (0 != TextHdlr_Save_Data(EXT_FILE_CC_REG, NULL)) {
+            HDLR_WARF("%s() %d, call TextHdlr_Save_Data(EXT_FILE_CC_REG) Fail", __func__, __LINE__);
+        }
+        if (0 != TextHdlr_Save_Data(EXT_FILE_CC_THREED, NULL)) {
+            HDLR_WARF("%s() %d, call TextHdlr_Save_Data(EXT_FILE_CC_THREED) Fail", __func__, __LINE__);
+        }
+    }
+    if (Ituner_Valid[ITUNER_STATIC_BAD_PIXEL_CORRECTION] == 1) {
+        if (0 != TextHdlr_Save_Data(EXT_FILE_FPN_MAP, NULL)) {
+            HDLR_WARF("%s() %d, call TextHdlr_Save_Data(EXT_FILE_FPN_MAP) Fail", __func__, __LINE__);
+        }
+    }
+    if (Ituner_Valid[ITUNER_VIGNETTE_COMPENSATION] == 1) {
+        if (0 != TextHdlr_Save_Data(EXT_FILE_VIGNETTE_GAIN, NULL)) {
+            HDLR_WARF("%s() %d, call TextHdlr_Save_Data(EXT_FILE_VIGNETTE_GAIN) Fail", __func__, __LINE__);
+        }
+    }
+    if (Ituner_Valid[ITUNER_WARP_COMPENSATION] == 1) {
+        if (0 != TextHdlr_Save_Data(EXT_FILE_WARP_TABLE, NULL)) {
+            HDLR_WARF("%s() %d, call TextHdlr_Save_Data(EXT_FILE_WARP_TABLE) Fail", __func__, __LINE__);
+        }
+    }
+    if (Ituner_Valid[ITUNER_CHROMA_ABERRATION_INFO] == 1) {
+        if (0 != TextHdlr_Save_Data(EXT_FILE_CA_TABLE, NULL)) {
+            HDLR_WARF("%s() %d, call TextHdlr_Save_Data(EXT_FILE_CA_TABLE) Fail", __func__, __LINE__);
+        }
+    }
+    return 0;
+}
+int TextHdlr_Load_ituner(char* ituner_stream)
+{
+	char *Buf = NULL;
+	int BufSize = 0;
+
+	int RegIndex;
+	int ParamIndex;
+	int txtdatasize = 0;
+	char endofr='\r';
+	char endchangelin='\n';
+	char endkey ='!';
+	REG_s *Reg;
+	ITUNER_INFO_s ItunerInfo;
+
+
+	// Note: Refresh GData, System...
+	TextHdlr_Get_ItunerInfo(&ItunerInfo);
+	if (0 != _TextHdlr_Update_System_Info(ItunerInfo.TuningAlgoMode)) {
+		HDLR_WARF("%s() %d, call _TextHdlr_Update_System_Info() Fail", __func__, __LINE__);
+		return -1;
+	}
+	if (0 != AmbaItuner_Refresh(ItunerInfo.TuningAlgoMode)) {
+		HDLR_WARF("%s() %d, call AmbaItuner_Refresh() Fail", __func__, __LINE__);
+		return -1;
+	}
+	if (0 != _TextHdlr_Fill_Ext_File_Path()) {
+		HDLR_WARF("%s() %d, call _TextHdlr_Fill_Ext_File_Path() Fail", __func__, __LINE__);
+		return -1;
+	}
+
+	TUNE_Parser_Set_Reglist_Valid(SKIP_VALID_CHECK, _Ituner.ParserObject);
+	TUNER_Parser_Set_Reg_Valid("internal", 0, _Ituner.ParserObject);
+
+	if (0 != TUNE_Parser_Get_LineBuf(_Ituner.ParserObject, &Buf, &BufSize)) {
+		HDLR_WARF("%s() %d, call TUNE_Parser_Get_LineBuf() Fail", __func__, __LINE__);
+		return -1;
+	}
+
+	TUNE_Parser_Set_Opmode(ITUNER_ENC);
+	AMBA_ITUNER_VALID_FILTER_t Filter_Status;
+	AmbaItuner_Get_FilterStatus(&Filter_Status);
+	// TODO : Remove _Ituner.ParserObject->RegCount, use api to get count
+	for (RegIndex = 0; RegIndex < _Ituner.ParserObject->RegCount; RegIndex++) {
+		Reg = TUNE_Parser_Get_Reg(RegIndex, _Ituner.ParserObject);
+		if (Reg == NULL) {
+			HDLR_WARF("%s() %d, Reg %d is NULL", __func__, __LINE__, RegIndex);
+			continue;
+		}
+
+		if (Filter_Status[Reg->Index] == 0) {
+			continue;
+		}
+		for (ParamIndex = 0; ParamIndex < Reg->ParamCount; ParamIndex++) {
+			if (0 != TUNE_Parser_Generate_Line(RegIndex, ParamIndex, _Ituner.ParserObject)) {
+				continue;
+			}
+
+		//	_save_line(Fd, Buf);
+			//AmbaPrintColor(YELLOW, "%s", Buf);
+			memcpy((ituner_stream+txtdatasize),Buf,strlen(Buf));
+			txtdatasize=txtdatasize+strlen(Buf);
+			*(ituner_stream+txtdatasize-sizeof(char))=endofr;
+			*(ituner_stream+txtdatasize)=endchangelin;
+			txtdatasize=txtdatasize+sizeof(char);
+		}
+	}
+	//****endmark of ituner file**************//
+
+//	*(ituner_stream+txtdatasize)=endoft;
+//	*(ituner_stream+txtdatasize+sizeof(char))=endoft;
+//	*(ituner_stream+txtdatasize+2*sizeof(char))=endoft;
+//	*(ituner_stream+txtdatasize+3*sizeof(char))=endofr;
+//	*(ituner_stream+txtdatasize+4*sizeof(char))=endchangelin;
+	*(ituner_stream+txtdatasize)=endkey;
+
+	printf("ituner file size =%d\n",txtdatasize+1);
+	return txtdatasize+1;
+}
+
+int TextHdlr_Save_IDSP(amba_img_dsp_mode_cfg_t Mode, char *Filepath)
+{
+	//char AscFilepath[64];
+	FILE *Fd;
+	int RegIndex;
+	int ParamIndex;
+	REG_s *Reg;
+	strncpy(Ituner_File_Path, Filepath, sizeof(Ituner_File_Path));
+	// Note: Refresh GData, System...
+	if (0 != _TextHdlr_Update_System_Info(Mode)) {
+	    HDLR_WARF("%s() %d, call _TextHdlr_Update_System_Info() Fail", __func__, __LINE__);
+	    return -1;
+	}
+	if (0 != AmbaItuner_Refresh(Mode)) {
+	    HDLR_WARF("%s() %d, call AmbaItuner_Refresh() Fail", __func__, __LINE__);
+	    return -1;
+	}
+	if (0 != _TextHdlr_Fill_Ext_File_Path()) {
+	    HDLR_WARF("%s() %d, call _TextHdlr_Fill_Ext_File_Path() Fail", __func__, __LINE__);
+	    return -1;
+	}
+	TUNE_Parser_Set_Reglist_Valid(SKIP_VALID_CHECK, _Ituner.ParserObject);
+	//uni_to_asc(Filepath, AscFilepath);
+    TUNER_Parser_Set_Reg_Valid("internal", 0, _Ituner.ParserObject);
+//	if (0 != _TextHdlr_Change_System_Drive(Filepath)) {
+//	    HDLR_WARF("%s() %d, call _TextHdlr_Change_System_Drive(%s) Fail", __func__, __LINE__, Filepath);
+//	    return -1;
+//	}
+
+    char *Buf = NULL;
+    int BufSize = 0;
+    if (0 != TUNE_Parser_Get_LineBuf(_Ituner.ParserObject, &Buf, &BufSize)) {
+        HDLR_WARF("%s() %d, call TUNE_Parser_Get_LineBuf() Fail", __func__, __LINE__);
+        return -1;
+    }
+    Fd = fopen(Filepath, "w");
+    if (Fd == 0) {
+        HDLR_WARF("%s() %d, File %s open fail!", __func__, __LINE__, Filepath);
+        return -1;
+    }
+    TUNE_Parser_Set_Opmode(ITUNER_ENC);
+    AMBA_ITUNER_VALID_FILTER_t Filter_Status;
+    AmbaItuner_Get_FilterStatus(&Filter_Status);
+    // TODO : Remove _Ituner.ParserObject->RegCount, use api to get count
+    for (RegIndex = 0; RegIndex < _Ituner.ParserObject->RegCount; RegIndex++) {
+        Reg = TUNE_Parser_Get_Reg(RegIndex, _Ituner.ParserObject);
+        if (Reg == NULL) {
+            HDLR_WARF("%s() %d, Reg %d is NULL", __func__, __LINE__, RegIndex);
+            continue;
+        }
+        if (Filter_Status[Reg->Index] == 0) {
+                continue;
+        }
+            for (ParamIndex = 0; ParamIndex < Reg->ParamCount; ParamIndex++) {
+            if (0 != TUNE_Parser_Generate_Line(RegIndex, ParamIndex, _Ituner.ParserObject)) {
+                continue;
+            }
+            _save_line(Fd, Buf);
+        }
+    }
+    fclose(Fd);
+
+	return 0;
+}
+
+
+
+
+static AMBA_DSP_IMG_PIPE_e _TextHdlr_Get_Imag_Pipe(TUNING_MODE_e TuningMode)
+{
+    AMBA_DSP_IMG_PIPE_e ImagePipe;
+
+    switch(TuningMode)
+    {
+    case IMG_MODE_VIDEO:
+    case IMG_MODE_PREVIEW:
+    case IMG_MODE_HIGH_ISO_VIDEO:
+            ImagePipe = AMBA_DSP_IMG_PIPE_VIDEO;
+            break;
+    case IMG_MODE_STILL:
+    case IMG_MODE_LOW_ISO_STILL:
+    case IMG_MODE_MID_ISO_STILL:
+    case IMG_MODE_HIGH_ISO_STILL:
+    case IMG_MODE_NIGHT_PORTRAIT_STILL:
+            ImagePipe = AMBA_DSP_IMG_PIPE_STILL;
+            break;
+        default:
+            ImagePipe = AMBA_DSP_IMG_PIPE_VIDEO;
+            break;
+    }
+
+    return ImagePipe;
+}
+
+static AMBA_DSP_IMG_ALGO_MODE_e _TextHdlr_Get_Image_Algo_Mode(TUNING_MODE_e TuningMode)
+{
+    AMBA_DSP_IMG_ALGO_MODE_e ImageAlgoMode;
+
+    switch(TuningMode)
+    {
+        case IMG_MODE_PREVIEW:
+        case IMG_MODE_VIDEO:
+        case IMG_MODE_LOW_ISO_STILL:
+            ImageAlgoMode = AMBA_DSP_IMG_ALGO_MODE_LISO;
+            break;
+        case IMG_MODE_HIGH_ISO_STILL:
+        case IMG_MODE_HIGH_ISO_VIDEO:
+            ImageAlgoMode = AMBA_DSP_IMG_ALGO_MODE_HISO;
+            break;
+        case IMG_MODE_STILL:
+        case IMG_MODE_MID_ISO_STILL:
+        case IMG_MODE_NIGHT_PORTRAIT_STILL:
+        default:
+            ImageAlgoMode = AMBA_DSP_IMG_ALGO_MODE_FAST;
+            break;
+    }
+
+    return ImageAlgoMode;
+
+}
+
+
+
diff --git a/idsp_test/arch_s2l/AmbaTUNE_TextHdlr.h b/idsp_test/arch_s2l/AmbaTUNE_TextHdlr.h
new file mode 100644
index 0000000..9a4b06a
--- /dev/null
+++ b/idsp_test/arch_s2l/AmbaTUNE_TextHdlr.h
@@ -0,0 +1,60 @@
+/*
+ *
+ * idsp_test
+ *
+ * History:
+ *	2013/09/05 - [Dylan] Created this file
+ *
+ * Description :
+ *	Load the tuned file which generated by Img tuning tool.
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef _AMBA_TEXT_HDLR_H_
+#define _AMBA_TEXT_HDLR_H_
+
+#include "AmbaDataType.h"
+#include "AmbaDSP_ImgDef.h" // amba_img_dsp_mode_cfg_t need
+#include "AmbaImgCalibItuner.h"
+
+#ifndef FALSE			/* in case these macros already exist */
+#define FALSE	0		/* values of boolean */
+#endif  /* FALSE */
+
+
+int TextHdlr_Init(void);
+int TextHdlr_Save_IDSP(amba_img_dsp_mode_cfg_t Mode, char *Filepath);
+int TextHdlr_Load_IDSP(char *Filepath);
+int TextHdlr_Load_Data(Ituner_Ext_File_Type_e Ext_File_Type, Ituner_Ext_File_Param_s* Ext_File_Param);
+int TextHdlr_Save_Data(Ituner_Ext_File_Type_e Ext_File_Type, Ituner_Ext_File_Param_s* Ext_File_Param);
+int TextHdlr_Execute_IDSP(int fd_iav, amba_img_dsp_mode_cfg_t Mode, AMBA_ITUNER_PROC_INFO_s *ProcInfo);
+int TextHdlr_Get_SystemInfo(ITUNER_SYSTEM_s *System);
+int TextHdlr_Set_SystemInfo(ITUNER_SYSTEM_s *System);
+int TextHdlr_Get_ItunerInfo(ITUNER_INFO_s *ItunerInfo);
+int TextHdlr_Load_ituner(char* ituner_stream);
+int TextHdlr_set_ituner(u8* ituner_stream,int size);
+#endif /* _AMBA_TEXT_HDLR_H_ */
diff --git a/idsp_test/arch_s2l/test_ituner.c b/idsp_test/arch_s2l/test_ituner.c
new file mode 100644
index 0000000..d3c5bfe
--- /dev/null
+++ b/idsp_test/arch_s2l/test_ituner.c
@@ -0,0 +1,2093 @@
+/*
+ *
+ * idsp_test
+ *
+ * History:
+ *	2015/09/10 - [Jingyang Qiu] Created this file
+ *
+ * Description :
+ *	Load the tuned file which generated by Img tuning tool.
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <errno.h>
+
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/time.h>
+#include <sys/wait.h>
+#include <time.h>
+#include <assert.h>
+#include <getopt.h>
+#include <sched.h>
+#include <signal.h>
+#include "types.h"
+
+#include "iav_ioctl.h"
+#include "ambas_imgproc_arch.h"
+#include "ambas_imgproc_ioctl_arch.h"
+#include "img_adv_struct_arch.h"
+
+#include <pthread.h>
+#include <semaphore.h>
+
+#include "AmbaDataType.h"
+#include "AmbaDSP_ImgDef.h"
+#include "AmbaDSP_ImgUtility.h"
+#include "AmbaDSP_ImgFilter.h"
+
+#include "dsp_cmd.h"
+#include "dsp_imgknl_if_a12.h"
+
+#include "AmbaTUNE_HdlrManager.h"
+#include "AmbaDSP_ImgLowIsoFilter.h"
+
+#define AmbaPrint(format, arg...)	printf(format"\n", ##arg)
+#ifndef ROUND_UP
+#define ROUND_UP(size, align) (((size) + ((align) - 1)) & ~((align) - 1))
+#endif
+
+
+//u8 IkWorkingBuf[509184+12+16];
+u8 IkWorkingBuf[2<<20];
+
+
+typedef struct _AMBA_DSP_IMG_TEST_IS2_s_
+{
+    UINT32 init;
+
+    amba_img_dsp_mode_cfg_t Mode;
+
+    char Warp1Fn[64];
+    char Warp2Fn[64];
+    UINT8 *Warp1;
+    UINT8 *Warp2;
+    UINT32 Warp1Len;
+    UINT32 Warp2Len;
+    int Blend;
+    UINT32 Decay;
+    UINT32 WarpGridWidth;
+    UINT32 WarpGridHeight;
+} AMBA_DSP_IMG_TEST_IS2_s;
+
+AMBA_DSP_IMG_TEST_IS2_s gTestIS2 = {0};
+int fd_iav;
+
+amba_img_dsp_pipe_info_t PipeInfo;//, PipeInfo_S;
+amba_img_dsp_arch_info_t ArchInfo = {0};
+amba_img_dsp_ctx_info_t DestCtx, SrcCtx;
+amba_img_dsp_cfg_info_t CfgInfo;
+static int test_is2_init(u8* mem)
+{
+    INT32 Rval = 0, TotalSize = 0;
+
+    memset(&PipeInfo, 0x0, sizeof(amba_img_dsp_pipe_info_t));
+    memset(&DestCtx, 0x0, sizeof(amba_img_dsp_ctx_info_t));
+    memset(&SrcCtx, 0x0, sizeof(amba_img_dsp_ctx_info_t));
+
+    PipeInfo.Pipe = AMBA_DSP_IMG_PIPE_VIDEO;
+    PipeInfo.CtxBufNum = 1;
+    PipeInfo.CfgBufNum = 2;
+
+
+//    ArchInfo.pWorkBuf = (UINT8*) IkWorkingBuf;
+//    ArchInfo.BufSize = sizeof(IkWorkingBuf);
+	ArchInfo.pWorkBuf = mem;
+	ArchInfo.BufSize = 2<<20;
+	ArchInfo.BufNum = 1;
+    ArchInfo.PipeNum = 1;
+    ArchInfo.pPipeInfo[0] = &PipeInfo;
+//    ArchInfo.pPipeInfo[1] = &PipeInfo_S;
+    TotalSize = amba_img_dsp_query_arch_mem_size(&ArchInfo);
+    printf("test_is2_init(): Total size needed %d Bytes\n", TotalSize);
+    //AmbaDSP_ImgSetMemory((UINT32)&IkWorkingBuf, sizeof(IkWorkingBuf));
+    //AmbaPrint("test_is2_init(): AmbaDSP_ImgUtilitySetMemory done");
+    amba_img_dsp_init_arch(&ArchInfo);
+
+    mem_op_t op;
+    op._free = free;
+    op._malloc = malloc;
+    op._memcpy = memcpy;
+    op._memset = memset;
+    img_dsp_register_mem(&op);
+    img_dsp_register_print(printf);
+    img_dsp_register_ioc((img_ioctl)ioctl);
+
+    DestCtx.Pipe = AMBA_DSP_IMG_PIPE_VIDEO;
+    DestCtx.CtxId = 0;
+//    AmbaDSP_ImgUtilityInitCtx(0, 1, DestCtx, SrcCtx);
+    amba_img_dsp_init_ctx(0, 1, 1, &DestCtx, &SrcCtx);
+
+//    DestCtx.Pipe = AMBA_DSP_IMG_PIPE_STILL;
+//    DestCtx.CtxId = 0;
+//    amba_img_dsp_init_ctx(0, 1, DestCtx, SrcCtx);
+//    CfgInfo.Pipe = AMBA_DSP_IMG_PIPE_STILL;
+//    CfgInfo.CfgId = 0;
+    CfgInfo.Pipe = AMBA_DSP_IMG_PIPE_VIDEO;
+    CfgInfo.CfgId = 0;
+    amba_img_dsp_init_cfg(&CfgInfo, AMBA_DSP_IMG_ALGO_MODE_LISO);
+    CfgInfo.Pipe = AMBA_DSP_IMG_PIPE_VIDEO;
+    CfgInfo.CfgId = 1;
+    amba_img_dsp_init_cfg(&CfgInfo, AMBA_DSP_IMG_ALGO_MODE_LISO);
+
+    return Rval;
+}
+
+static int test_ituner(int fd_iav, char* file_name)
+{
+	int Rval = -1;
+	AmbaTUNE_Change_Parser_Mode(TEXT_TUNE);
+	if (0 != AmbaTUNE_Init()) {
+	    printf("%s() %d, call AmbaTUNE_Init() Fail", __func__, __LINE__);
+	    return Rval;
+	}
+	//HENRY TBD Disable 3A
+
+	if (0 != AmbaTUNE_Load_IDSP(file_name)) {
+	    printf("%s() %d, call AmbaTUNE_Load_IDSP(%s) Fail", __func__, __LINE__, file_name);
+	     return Rval;
+	}
+//	getchar();
+	ITUNER_INFO_s ItunerInfo;
+	if (0 != AmbaTUNE_Get_ItunerInfo(&ItunerInfo)) {
+	    printf("%s() %d, call AmbaTUNE_Get_ItunerInfo() Fail", __func__, __LINE__);
+	     return Rval;
+	}
+	memcpy(&gTestIS2.Mode, &ItunerInfo.TuningAlgoMode, sizeof(amba_img_dsp_mode_cfg_t));
+	AMBA_ITUNER_PROC_INFO_s ProcInfo;
+	memset(&ProcInfo, 0, sizeof(AMBA_ITUNER_PROC_INFO_s));
+	ProcInfo.HisoBatchId = 0;
+	gTestIS2.Mode.BatchId =0xff; // FIXME
+	printf("algo mode %d\n", gTestIS2.Mode.AlgoMode);
+	if (0 != AmbaTUNE_Execute_IDSP(fd_iav, gTestIS2.Mode, &ProcInfo)) {
+	    printf("%s() %d, call AmbaTUNE_Execute_IDSP() Fail", __func__, __LINE__);
+	     return Rval;
+	}
+	Rval = 0;
+
+	return Rval;
+}
+
+
+static int test_ituner_save(int fd_iav, char* file_name)
+{
+	int Rval = -1;
+
+	do{
+		AmbaTUNE_Change_Parser_Mode(TEXT_TUNE);
+		if (0 != AmbaTUNE_Init()) {
+		    AmbaPrint("%s() %d, call AmbaTUNE_Init() Fail", __func__, __LINE__);
+		    return Rval;
+		}
+
+		if (0 != AmbaTUNE_Save_IDSP(gTestIS2.Mode, file_name)) {
+			AmbaPrint("%s() %d, call AmbaTUNE_Save_IDSP(FilePath:%s) Fail", __func__, __LINE__, file_name);
+			break;
+		}
+
+		Rval = 0;
+	}while(0);
+
+	return Rval;
+}
+
+void idsp_dump_bin(int fd_iav, u8 id)
+{
+	char bin_filename[32];
+	int fd_bin_dump = -1;
+	u8 *bin_buffer = NULL;
+	idsp_config_info_t	dump_idsp_info;
+	int rval = -1;
+
+	if(id >= 8 && id != 100){
+		printf("err: unknow id section.\n");
+		return;
+	}
+
+	if(bin_buffer == NULL){
+		bin_buffer = (u8*)malloc(MAX_DUMP_BUFFER_SIZE);
+	}
+	if(bin_buffer != NULL){
+		memset(bin_buffer, 0, MAX_DUMP_BUFFER_SIZE);
+	}else{
+		return;
+	}
+
+	dump_idsp_info.id_section = id;
+	dump_idsp_info.addr = bin_buffer;
+
+	//while(rval < 0){
+		rval = ioctl(fd_iav, IAV_IOC_IMG_DUMP_IDSP_SEC, &dump_idsp_info);
+		if (rval < 0) {
+			perror("IAV_IOC_IMG_DUMP_IDSP_SEC");
+		}
+	//	sleep(1);
+	//	printf("\n");
+	//}
+
+	sprintf(bin_filename, "/mnt/idsp_dump_bin_%d.bin",id);
+	fd_bin_dump = open(bin_filename, O_WRONLY | O_CREAT, 0666);
+	if(fd_bin_dump < 0){
+		printf("Failed to open bin file %s.\n",bin_filename);
+		goto idsp_dump_exit;
+	}
+
+	if (write(fd_bin_dump, bin_buffer, dump_idsp_info.addr_long) < 0) {
+		printf("Failed to write to bin file %s.\n",bin_filename);
+		goto idsp_dump_exit;
+	}
+
+idsp_dump_exit:
+	if(bin_buffer != NULL){
+		free(bin_buffer);
+		bin_buffer = NULL;
+	}
+
+	if(fd_bin_dump > 0){
+		close(fd_bin_dump);
+		fd_bin_dump = -1;
+	}
+}
+
+
+#define MAX_RAW_FILE_NUM		(3)
+#if 0
+static int load_hiso_config(void)
+{
+	u8 * start_addr = NULL;
+	int i, fd_raw;
+	int count, dpitch, total_size, max_size;
+	struct iav_mmap_info_s map;
+	char fn[64];
+
+	if (ioctl(fd_iav, IAV_IOC_MAP_IMGPROC, &map) < 0) {
+		perror("IAV_IOC_MAP_IMGPROC");
+		return -1;
+	}
+	printf("IAV_IOC_MAP_IMGPROC %p 0x%x\n", map.addr, map.length);
+	max_size = map.length / 2 / (MAX_RAW_FILE_NUM + 1);
+
+	start_addr = map.addr;
+	total_size = 1<<20;
+
+	/* Load raw image data file */
+	for (i = 0; i < MAX_RAW_FILE_NUM; ++i, start_addr += max_size) {
+		/*if (raw_file_path_flag & (1 << i)) {
+			fd_raw = -1;
+			if ((fd_raw = open(raw_file_path[i], O_RDONLY, 0)) < 0) {
+				printf("Failed to open file [%s].\n", raw_file_path[i]);
+				return -1;
+			}
+			if ((count = read(fd_raw, start_addr, total_size)) != total_size) {
+				printf("Read file [%s] error, it is not equal to the correct size [%d].\n",
+					raw_file_path[i], total_size);
+				return -1;
+			}
+			close(fd_raw);
+			hiso.sensor_raw_addr[i] = (u32)start_addr;
+		}*/
+	}
+
+	/* Load HISO config file */
+	printf("map %p 0x%x, start %p\n", map.addr, map.length, start_addr);
+	fd_raw = -1;
+	sprintf(fn, "/mnt/a7s_hiso_data_640x480_HI5_0.y");
+	if ((fd_raw = open(fn, O_RDONLY, 0)) < 0) {
+		printf("Failed to open file [%s].\n", fn);
+		return -1;
+	}
+	printf("cfg start addr %p\n", start_addr);
+	count = read(fd_raw, start_addr, total_size);
+	printf("read file %d cnt %d\n", fd_raw, count);
+	close(fd_raw);
+	/*hiso.hiso_config_addr = (u32)start_addr;
+	hiso.raw_width = raw_width;
+	hiso.raw_height = raw_height;
+	hiso.raw_compression = raw_comp;
+
+	printf("\nHISO Settings:\n");
+	printf("   RAW image 0: [%s]\n", raw_file_path[0]);
+	printf("   RAW image 1: [%s]\n", raw_file_path[1]);
+	printf("   RAW image 2: [%s]\n", raw_file_path[2]);
+	printf("   HISO CFG file: [%s]\n", hiso_cfg_file_path);
+	printf("   RAW size: [%dx%d]\n", raw_width, raw_height);
+	printf("   RAW compress [%d]\n\n", raw_comp);
+	if (ioctl(fd_iav, IAV_IOC_SET_HISO_VIDEO_SETUP_EX, &hiso) < 0) {
+		perror("IAV_IOC_HISO_SETUP_TEST");
+		return -1;
+	}*/
+
+	return 0;
+}
+#endif
+
+static const char* short_options = "l:ds:m:ip:P:n:rf:RC:w:h:B:atD:g:o:c:F:";
+static struct option long_options[] = {
+	{"load", 1, 0, 'l'},
+	{"debug", 0, 0, 'd'},
+	{"step", 1, 0, 's'},
+	{"mode", 1, 0, 'm'},
+
+	{"file-input", 0, 0, 'i'},
+	{"path", 1, 0, 'p'},
+	{"prefix", 1, 0, 'P'},
+	{"number", 1, 0, 'n'},
+
+	{"retrieve", 0, 0, 'r'},
+	{"file", 1, 0, 'f'},
+	{"record", 1, 0, 'R'},
+	{"cycle", 1, 0, 'C'},
+	{"width", 1, 0, 'w'},
+	{"height", 1, 0, 'h'},
+	{"batch", 1, 0, 'B'},
+	{"slave", 1, 0, 'a'},
+	{"test", 1, 0, 't'},
+	{"dump", 1, 0, 'D'},
+	{"gain", 1, 0, 'g'},
+	{"row", 1, 0, 'o'},
+	{"convert", 1, 0, 'c'},
+	{"Frame",1,0,'F'}
+};
+
+struct hint_s {
+	const char *arg;
+	const char *str;
+};
+static const struct hint_s hint[] = {
+	{"-l", "load ituner file"},
+	{"-d", "\tenable debug"},
+	{"-s", "\tdebug step"},
+	{"-m", "\tdebug mode"},
+	{"-F", "\tdebug frame"},
+	{"exp", "\ttest_ituner -l filename [-d] [-s 0] [-m 5]"},
+	{"-i", "\tfeed raw"},
+	{"-p", "\tspecify raw file path"},
+	{"-P", "\tspecify raw file prefix name"},
+	{"-n", "\ttotal RAW file number"},
+	{"-w", "\tRAW file width"},
+	{"-h", "\tRAW file height"},
+	{"-B", "\tRAW file number in one batch"},
+	{"exp", "\ttest_ituner -i -p /sdcard/raw_in -P hiso_imx104_ -n 90 -w 1280 -h 720"},
+	{"-r", "\tretrieve debug dump, in /mnt/debug"},
+	{"exp", "\ttest_ituner -r"},
+	{"-D", "\tDump idsp section, in /mnt/debug"},
+};
+void print_help(void)
+{
+	int cnt = sizeof(hint)/sizeof(hint[0]);
+	int i;
+	for(i=0; i<cnt; i++) {
+		printf("%s %s\n", hint[i].arg, hint[i].str);
+	}
+}
+typedef enum{
+	LOAD_CONFIG = 1,
+	FEED_RAW,
+	PRE_FEED_RAW,
+	DUMP_DEBUG,
+	SLAVE_MODE,
+	TEST_MODE,
+	DUMP_SECTION,
+	SENSOR_CNTL,
+	CONVERT_MODE,
+}ituner_work_mode;
+
+static ituner_work_mode work_mode;
+static int debug_step, debug_mode, debug_enable,debug_frame;
+static int enable_record;
+static int feed_raw_number;
+static char file_name[128];
+static char folder_name[128];
+static char prefix_name[128];
+static int loop_cycle = 1;
+static int loop_raw_cnt;
+static int file_width, file_height, batch_num = 5;
+static int sec_id=0;
+
+static int sensor_gain_index = -1;
+static int sensor_sht_row = -1;
+
+//static u8 mem_section;
+
+static int ituner_init_param(int argc, char **argv)
+{
+	int ch;
+	int option_index = 0;
+
+	opterr = 0;
+	while ((ch = getopt_long(argc, argv, short_options, long_options, &option_index)) != -1) {
+		switch(ch) {
+		case 'l':
+			work_mode = LOAD_CONFIG;
+			memcpy(file_name, optarg, 128);
+			break;
+		case 'd':
+			debug_enable = 1;
+			break;
+		case 's':
+			debug_step = atoi(optarg);
+			break;
+		case 'm':
+			debug_mode = atoi(optarg);
+			break;
+		case 'i':
+			work_mode = FEED_RAW;
+			break;
+		case 'F':
+		        debug_frame =atoi(optarg);
+		        break;
+		case 'p':
+			memcpy(folder_name, optarg, 128);
+			break;
+		case 'P':
+			memcpy(prefix_name, optarg, 128);
+			break;
+		case 'n':
+			feed_raw_number = atoi(optarg);
+			break;
+		case 'r':
+//			mem_section = (u8)atoi(optarg);
+			work_mode = DUMP_DEBUG;
+			break;
+		case 'f':
+			memcpy(file_name, optarg, 128);
+			break;
+		case 'R':
+			enable_record = 1;
+			break;
+		case 'C':
+			loop_cycle = atoi(optarg);
+			if(loop_cycle <= 0) {
+				printf("loop cycle shall be positive integer\n");
+				return -1;
+			}
+			break;
+		case 'w':
+			file_width = atoi(optarg);
+			break;
+		case 'h':
+			file_height = atoi(optarg);
+			break;
+		case 'B':
+			batch_num = atoi(optarg);
+			break;
+		case 'a':
+			work_mode = SLAVE_MODE;
+			break;
+		case 't':
+			work_mode = TEST_MODE;
+			break;
+		case 'D':
+			work_mode = DUMP_SECTION;
+			sec_id = atoi(optarg);
+			break;
+		case 'g':
+			work_mode = SENSOR_CNTL;
+			sensor_gain_index = atoi(optarg);
+			break;
+		case 'o':
+			work_mode = SENSOR_CNTL;
+			sensor_sht_row = atoi(optarg);
+			break;
+		case 'c':
+			work_mode = CONVERT_MODE;
+			memcpy(file_name, optarg, 128);
+			printf("conver %s\n", file_name);
+			break;
+		default:
+			printf("unknown option %c\n", ch);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+sem_t feed_sem;
+sem_t feed_ready_sem;
+sem_t rec_sem;
+u8 *feed_addr = NULL;
+u8 *cfg_start_addr = NULL, *ik_start_addr = NULL;
+u8* dest[2];
+int total_raw_cnt = 0;
+char recv_buf[1024];
+struct sockaddr_in server, client;
+
+void rec_loop(void* arg)
+{
+	sem_wait(&rec_sem);
+	system("test_encode -A -h720p -e");
+}
+
+void feed_loop(void* arg)
+{
+	int fd_raw,i=0;
+	int raw_width= 1280, raw_height=720;
+	char fn[128];
+	int dpitch;// = ROUND_UP((raw_width << 1), 32);
+	int raw_size;// = dpitch*raw_height;
+	u8 dest_num = 0;
+	u8 *buf;
+	int temp_cnt;
+
+	raw_width = file_width;
+	raw_height = file_height;
+	dpitch = ROUND_UP((raw_width << 1), 32);
+	raw_size = dpitch*raw_height;
+
+	u8* pre_buf = malloc(raw_size);
+	for(i=0; i<feed_raw_number; i++) {
+		sprintf(fn, "%s/%s%d.raw", folder_name, prefix_name, i);
+		if((fd_raw = open(fn, O_RDONLY, 0)) < 0){
+				printf("Failed to open file [%s].\n", fn);
+				return;
+			}
+		if(read(fd_raw, pre_buf, raw_size)!=raw_size){
+			printf("read %s fail\n", fn);
+			return;
+		}
+		close(fd_raw);
+		printf("\r caching raw file %d", i);
+		fflush(stdout);
+	}
+	printf("\n");
+	free(pre_buf);
+	pre_buf = NULL;
+	temp_cnt = 0;
+	while(1){
+		sem_wait(&feed_sem);
+		if(total_raw_cnt >= loop_raw_cnt)
+			continue;
+		if(temp_cnt >= feed_raw_number)
+			temp_cnt = 0;
+		buf = dest[dest_num];
+		for(i=0; i< batch_num; i++) {
+			#if 0
+			memcpy(buf + i*raw_size, pre_buf+total_raw_cnt*raw_size, raw_size);
+			total_raw_cnt++;
+			#else
+			sprintf(fn, "%s/%s%d.raw", folder_name, prefix_name, temp_cnt);
+			if((fd_raw = open(fn, O_RDONLY, 0)) < 0){
+				printf("Failed to open file [%s].\n", fn);
+				return;
+			}
+			if(read(fd_raw, buf + i*raw_size, raw_size)!=raw_size){
+				printf("read %s fail\n", fn);
+				return;
+			}
+			close(fd_raw);
+			total_raw_cnt ++;
+			temp_cnt++;
+			printf("load %s to %p, total %d\n", fn, buf, total_raw_cnt);
+			#endif
+		}
+		dest_num ^= 1;
+		sem_post(&feed_ready_sem);
+	}
+
+	return;
+}
+
+int process_cmd(void* buf)
+{
+	char shell_cmd[128];
+
+	memcpy(shell_cmd, buf, 128);
+	system(shell_cmd);
+
+	return 0;
+}
+
+int creat_socket_server(in_port_t in_port, in_addr_t in_addr)
+{
+	int socket_fd, on;
+	struct timeval timeout = {10,0};
+
+	server.sin_family = AF_INET;
+	server.sin_port = in_port;
+	server.sin_addr.s_addr = in_addr;
+
+	if((socket_fd = socket(AF_INET, SOCK_STREAM, 0))<0) {
+		perror("listen socket uninit\n");
+		return -1;
+	}
+
+	setsockopt(socket_fd, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeout, sizeof(timeout));
+	setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(int) );
+	printf("on %x\n", on);
+	if((bind(socket_fd, (struct sockaddr *)&server, sizeof(server)))<0) {
+		perror("cannot bind srv socket\n");
+		return -1;
+	}
+
+	if(listen(socket_fd, SOMAXCONN)<0) {
+		perror("cannot listen");
+		close(socket_fd);
+		return -1;
+	}
+
+	return socket_fd;
+}
+
+/*
+int map_bsb(void)
+{
+	struct iav_querybuf querybuf;
+
+	querybuf.buf = IAV_BUFFER_BSB;
+	if (ioctl(fd_iav, IAV_IOC_QUERY_BUF, &querybuf) < 0) {
+		perror("IAV_IOC_QUERY_BUF");
+		return -1;
+	}
+
+	bsb_size = querybuf.length;
+	bsb_mem = mmap(NULL, bsb_size * 2, PROT_READ, MAP_SHARED, fd_iav, querybuf.offset);
+	if (bsb_mem == MAP_FAILED) {
+		perror("mmap (%d) failed: %s\n");
+		return -1;
+	}
+
+	printf("bsb_mem = 0x%x, size = 0x%x\n", (u32)bsb_mem, bsb_size);
+	return 0;
+}
+*/
+
+int main(int argc, char **argv)
+{
+	struct iav_querybuf querybuf;
+	pthread_t thread_id;
+	extern int amba_img_dsp_set_debug_mode(amba_img_dsp_mode_cfg_t *pMode, AMBA_DSP_IMG_DEBUG_MODE_s *pDebugMode);
+	extern int amba_img_dsp_get_debug_mode(amba_img_dsp_mode_cfg_t *pMode, AMBA_DSP_IMG_DEBUG_MODE_s *pDebugMode);
+	extern int AmbaDSP_ImgLowIsoPrintCfg(amba_img_dsp_cfg_info_t CfgInfo);
+	extern int AmbaDSP_ImgLowIsoDumpCfg(amba_img_dsp_cfg_info_t CfgInfo, char *dir);
+	extern int img_dsp_low_iso_set_mem_info(u32 user_start, u32 phys_start, u32 mask);
+
+	if(argc<=1)
+		print_help();
+	if (ituner_init_param(argc, argv) < 0) {
+		return -1;
+	}
+	if ((fd_iav = open("/dev/iav", O_RDWR, 0)) < 0) {
+		perror("open /dev/iav");
+		return -1;
+	}
+	querybuf.buf = IAV_BUFFER_IMG;
+	if (ioctl(fd_iav, IAV_IOC_QUERY_BUF, &querybuf) < 0) {
+		perror("IAV_IOC_QUERY_BUF");
+		return -1;
+	}
+	printf("memory %p size %dMB from IAV\t", (void*)querybuf.offset, querybuf.length>>20);
+	ik_start_addr = mmap(NULL, querybuf.length, PROT_READ|PROT_WRITE, MAP_SHARED, fd_iav, querybuf.offset);
+	if (ik_start_addr == MAP_FAILED) {
+		perror("mmap (%d) failed: %s\n");
+		return -1;
+	}
+	printf("map to %p\n", ik_start_addr);
+	u32 phy_addr =querybuf.offset;
+	img_dsp_low_iso_set_mem_info((u32)ik_start_addr, phy_addr, 0x3fffffff);
+
+	cfg_start_addr = ik_start_addr + 0x400000;
+	feed_addr = cfg_start_addr + 0x100000;
+
+	if (ioctl(fd_iav, IAV_IOC_IMG_RESET_RAW2ENC_NI) < 0)
+		printf("IAV_IOC_IMG_RESET_RAW2ENC_NI error\n");
+
+	sem_init(&feed_sem, 0, 0);
+	sem_init(&feed_ready_sem, 0, 0);
+	sem_init(&rec_sem, 0, 0);
+
+	switch(work_mode) {
+    case LOAD_CONFIG:
+        printf("load ituner file %s, debug step%d mode%d\n", file_name, debug_step, debug_mode);
+        test_is2_init(ik_start_addr);
+        test_ituner(fd_iav, file_name);
+        AMBA_DSP_IMG_DEBUG_MODE_s debug = { 0 };
+        debug.Step = debug_step;
+        debug.Mode = debug_mode;
+        debug.PicNum = debug_frame;
+        if (debug_enable)
+            amba_img_dsp_set_debug_mode(&gTestIS2.Mode, &debug);
+        amba_img_dsp_post_exe_cfg(fd_iav, &gTestIS2.Mode, AMBA_DSP_IMG_CFG_EXE_PARTIALCOPY, 1);
+        CfgInfo.CfgId = gTestIS2.Mode.ConfigId;
+
+        if (debug_enable) {
+            AmbaDSP_ImgLowIsoDumpCfg(CfgInfo, "/mnt");
+            AmbaDSP_ImgLowIsoPrintCfg(CfgInfo);
+        }
+
+#if 0
+			debug.Step = debug_step;
+			debug.Mode = debug_mode;
+			if(debug_enable)
+				amba_img_dsp_set_debug_mode(&gTestIS2.Mode, &debug);
+			amba_img_dsp_post_exe_cfg(fd_iav, &gTestIS2.Mode, 2, 1);
+			CfgInfo.CfgId = gTestIS2.Mode.ConfigId;
+//			AmbaDSP_ImgHighIsoDumpCfg(CfgInfo, "/mnt/cfg");
+//			AmbaDSP_ImgHighIsoPrintCfg(gTestIS2.Mode, CfgInfo);
+
+
+		/*	static int cnt =200;
+			while(cnt --)
+			{
+				static aaa_tile_report_t act_tile;
+				static img_aaa_stat_t aaa_stat_info;
+				img_dsp_get_statistics(fd_iav, &aaa_stat_info, &act_tile);
+
+			}*/
+#endif
+			//test_ituner_save(fd_iav, "/sdcard/test_ituner.txt");
+			break;
+		case DUMP_SECTION:
+			idsp_dump_bin(fd_iav, sec_id);
+			break;
+		case SENSOR_CNTL:
+			if(sensor_sht_row > 0) {
+				struct vindev_shutter_row vsrc_shutter_row;
+				vsrc_shutter_row.vsrc_id = 0;
+				vsrc_shutter_row.shutter_row = sensor_sht_row;
+				if(ioctl(fd_iav, IAV_IOC_VIN_SET_SHUTTER_ROW, &vsrc_shutter_row)<0)
+					perror("IAV_IOC_VIN_SET_SHUTTER_ROW");
+			}
+			if(sensor_gain_index > 0) {
+				struct vindev_agc_idx vsrc_agc_idx;
+				vsrc_agc_idx.vsrc_id = 0;
+				vsrc_agc_idx.agc_idx = sensor_gain_index;
+				if(ioctl(fd_iav, IAV_IOC_VIN_SET_AGC_INDEX, &vsrc_agc_idx)<0)
+					perror("IAV_IOC_VIN_SET_AGC_INDEX");
+			}
+			break;
+		case FEED_RAW:
+
+			loop_raw_cnt = loop_cycle*feed_raw_number;
+			if(pthread_create(&thread_id, NULL, (void*)feed_loop, NULL)!=0) {
+				printf("Fail to start feed_loop.\n");
+				exit(-1);
+			}
+			if(enable_record) {
+				if(pthread_create(&thread_id, NULL, (void*)rec_loop, NULL)!=0) {
+					printf("Fail to start rec_loop.\n");
+					exit(-1);
+				}
+			}
+			printf("feed %d raw files in folder %s prefix %s\n", feed_raw_number, folder_name, prefix_name);
+
+			int raw_width= 1280, raw_height=720;
+			struct raw2enc_raw_feed_info feed_raw;
+			struct iav_raw_enc_setup iav_feed_raw;
+
+			raw_width = file_width;
+			raw_height = file_height;
+			int dpitch = ROUND_UP((raw_width << 1), 32);
+			int raw_size = dpitch*raw_height;
+
+			dest[0] = feed_addr;
+			dest[1] = feed_addr + batch_num*raw_size;
+			total_raw_cnt = 0;
+
+			feed_raw.dpitch = dpitch;
+			feed_raw.raw_size =raw_size;
+			feed_raw.num_frames = batch_num;
+
+			iav_feed_raw.pitch =dpitch;
+			iav_feed_raw.raw_daddr_offset =0x500000;
+			iav_feed_raw.raw_frame_size =raw_size;
+			iav_feed_raw.raw_frame_num =batch_num;
+
+			int idx = 0;
+			sem_post(&feed_sem);
+			if(enable_record)
+				sem_post(&rec_sem);
+			do {
+				//while(total_raw_cnt < feed_raw_number) {
+				while(total_raw_cnt < loop_raw_cnt) {
+					//printf("wait for data ready, cnt %d\n", total_raw_cnt);
+					sem_wait(&feed_ready_sem);
+					sem_post(&feed_sem);
+					//printf("data ready in %p\n", dest[idx]);
+					feed_raw.daddr_offset  = ((u32)dest[idx] -(u32)ik_start_addr);
+					//printf("feed_raw.daddr_offset =%x\n",feed_raw.daddr_offset);
+					if (ioctl(fd_iav, IAV_IOC_IMG_FEED_RAW_NI, &feed_raw) < 0)
+						printf("IAV_IOC_IMG_FEED_RAW_NI error\n");
+					if (ioctl(fd_iav, IAV_IOC_SET_RAW_ENCODE, &iav_feed_raw) < 0)
+						printf("IAV_IOC_SET_RAW_ENCODE error\n");
+					idx ^= 1;
+					//printf("data fired\n");
+					if (ioctl(fd_iav, IAV_IOC_IMG_WAIT_RAW2ENC_NI) < 0)
+						printf("IAV_IOC_IMG_WAIT_RAW2ENC_NI error\n");
+					//printf("raw processed\n");
+				}
+				sem_wait(&feed_ready_sem);
+				//printf("final data ready in %p\n", dest[idx]);
+				feed_raw.daddr_offset= (u32)((u32)dest[idx] -(u32)ik_start_addr);
+				if (ioctl(fd_iav, IAV_IOC_IMG_FEED_RAW_NI, &feed_raw) < 0)
+					printf("IAV_IOC_IMG_FEED_RAW_NI error\n");
+				if (ioctl(fd_iav, IAV_IOC_IMG_WAIT_RAW2ENC_NI) < 0)
+					printf("IAV_IOC_IMG_WAIT_RAW2ENC_NI error\n");
+				printf("final raw processed\n");
+
+			}while(0);
+//			if(enable_record)
+//				system("test_encode -A -h720p -s");
+			break;
+		case DUMP_DEBUG: {
+			int i;
+			u32 cfg_start_addr_tmp = 0;
+			printf("dump debug section to %s\n", folder_name);
+
+			for (i=0; i<3; i++)
+			{
+			cfg_start_addr_tmp = (u32)cfg_start_addr+ (i*0x400);
+			a12_low_iso_param_t* l_cfg = (a12_low_iso_param_t*)cfg_start_addr_tmp;
+
+			// break if ucode doesn't write debug data
+			if (l_cfg->share.debug_addr[0] == 0xffffffff ||l_cfg->share.debug_addr[1] == 0xffffffff || l_cfg->share.debug_config_addr == 0xffffffff)
+				break;
+
+			printf("sec %d, mem 0x%.8x\n", i, cfg_start_addr_tmp);
+			printf("get debug step %d mode %d\n", l_cfg->share.debug_step_id, l_cfg->share.debug_mode);
+			printf("debug cfg_addr 0x%x debug_addr 0x%x 0x%x\n", l_cfg->share.debug_config_addr,
+									l_cfg->share.debug_addr[0], l_cfg->share.debug_addr[1]);
+			printf("pitch %d %d width %d %d height %d %d\n", l_cfg->share.debug_pitch[0], l_cfg->share.debug_pitch[1],
+									l_cfg->share.debug_width[0], l_cfg->share.debug_width[1],
+									l_cfg->share.debug_height[0], l_cfg->share.debug_height[1]);
+
+			int y_size = l_cfg->share.debug_pitch[0]*l_cfg->share.debug_height[0]; //l_cfg->share.debug_width[0]*l_cfg->share.debug_height[0];
+			u32 y_src = l_cfg->share.debug_addr[0];
+			int uv_size = l_cfg->share.debug_pitch[1]*l_cfg->share.debug_height[1]; //l_cfg->share.debug_width[1]*l_cfg->share.debug_height[1];
+			u32 uv_src = l_cfg->share.debug_addr[1];
+			u32 debug_cfg_src = l_cfg->share.debug_config_addr;
+			int debug_cfg_size = 150*1024;
+
+			char fn[64], shell_cmd[128];
+			if(strlen(folder_name)==0)
+				sprintf(folder_name, "/mnt/debug");
+			sprintf(shell_cmd, "mkdir -p %s", folder_name);
+			system(shell_cmd);
+
+			if(debug_cfg_src != 0) {
+				sprintf(fn, "frm%d_step%d_mode%d_cfg.bin", l_cfg->share.debug_pic_num, l_cfg->share.debug_step_id, l_cfg->share.debug_mode);
+				sprintf(shell_cmd, "amba_debug -r 0x%x -s 0x%x -f %s/%s", debug_cfg_src, debug_cfg_size, folder_name, fn);
+				system(shell_cmd);
+			}
+			if(y_src != 0) {
+				sprintf(fn, "frm%d_step%d_mode%d_w%d_h%d.y", l_cfg->share.debug_pic_num, l_cfg->share.debug_step_id, l_cfg->share.debug_mode,
+								l_cfg->share.debug_width[0], l_cfg->share.debug_height[0]);
+				sprintf(shell_cmd, "amba_debug -r 0x%x -s 0x%x -f %s/%s", y_src, y_size, folder_name, fn);
+				system(shell_cmd);
+			}
+			if(uv_src != 0) {
+				sprintf(fn, "frm%d_step%d_mode%d_w%d_h%d.uv", l_cfg->share.debug_pic_num, l_cfg->share.debug_step_id, l_cfg->share.debug_mode,
+								l_cfg->share.debug_width[1], l_cfg->share.debug_height[1]);
+				sprintf(shell_cmd, "amba_debug -r 0x%x -s 0x%x -f %s/%s", uv_src, uv_size, folder_name, fn);
+				system(shell_cmd);
+			}
+
+		}
+		}
+			break;
+		case SLAVE_MODE:
+			{
+				int socket_fd, client_fd;
+
+				int port = 3000;
+				socklen_t client_size;
+
+				socket_fd = creat_socket_server(htons(port), htonl(INADDR_ANY));
+				if(socket_fd<0) return -1;
+
+				client_size = sizeof(client);
+				do {
+					client_fd = accept(socket_fd, (struct sockaddr*)&client, &client_size);
+					if(client_fd<0) {
+						perror("accpet");
+						printf("errno %d\n", errno);
+					}
+				}while(client_fd<0);
+				printf("connected to %s:%u\n", inet_ntoa(client.sin_addr), ntohs(client.sin_port));
+				printf("Numeric: %u\n", ntohl(client.sin_addr.s_addr));
+
+				while(1) {
+					int bytes;//, i;
+					do {
+						bytes = recv(client_fd, (void*)recv_buf, 128, MSG_WAITALL);
+						if(bytes<=0) {
+							printf("recv errno %d\n", errno);
+							switch(errno){
+							/*case EAGAIN:
+								printf("restart recv\n");
+								if((eth_link&0x1) == 0) {
+									do {
+										client_fd = accept(socket_fd, (struct sockaddr*)&client, &client_size);
+										if(client_fd<0) {
+											printf("accept errno %d\n", errno);
+										}
+									}while(client_fd<0);
+									printf("EAGAIN connected to %s:%u\n", inet_ntoa(client.sin_addr), ntohs(client.sin_port));
+									printf("Numeric: %u\n", ntohl(client.sin_addr.s_addr));
+									//sprintf(snd_buf, "re-connected to A5s from link down, 3A loop running");
+									//send(client_fd, snd_buf, 128, MSG_WAITALL);
+								}
+								break;*/
+							case ECONNRESET:
+								close(client_fd);
+								printf("restart accept\n");
+								do {
+									client_fd = accept(socket_fd, (struct sockaddr*)&client, &client_size);
+									if(client_fd<0) {
+										printf("accept errno %d\n", errno);
+									}
+								}while(client_fd<0);
+								printf("ECONNRESET connected to %s:%u\n", inet_ntoa(client.sin_addr), ntohs(client.sin_port));
+								printf("Numeric: %u\n", ntohl(client.sin_addr.s_addr));
+								//sprintf(snd_buf, "re-connected to A5s from socket reset, 3A loop running");
+								//send(client_fd, snd_buf, 128, MSG_WAITALL);
+
+								break;
+							case EAGAIN:
+							default:
+								break;
+							}
+						}
+					}while(bytes<=0);
+					printf("cmd is %s\n", recv_buf);
+					process_cmd(recv_buf);
+				}
+			}
+			break;
+		case TEST_MODE:
+{
+		#define FILE_NUM (20)
+		int count = 0;
+		int debug_step = 0,debug_mode = 0,debug_pic_num;
+		a12_low_iso_param_t* l_cfg = 0;
+		char* file_name[FILE_NUM] = {
+			"/sdcard/s2l_liso/regs_and_paths_with_invisibleRUN_Vid25.txt",
+			"/sdcard/s2l_liso/regs_and_paths_with_invisibleRUN_255.txt",
+			"/sdcard/s2l_liso/regs_and_paths_with_invisibleRUN_Vid25.txt",
+			"/sdcard/s2l_liso/regs_and_paths_with_invisibleRUN_255.txt",
+			"/sdcard/s2l_liso/regs_and_paths_with_invisibleRUN_Vid25.txt",
+			"/sdcard/s2l_liso/regs_and_paths_with_invisibleRUN_255.txt",
+			"/sdcard/s2l_liso/regs_and_paths_with_invisibleRUN_Vid25.txt",
+			"/sdcard/s2l_liso/regs_and_paths_with_invisibleRUN_255.txt",
+			"/sdcard/s2l_liso/regs_and_paths_with_invisibleRUN_Vid25.txt",
+			"/sdcard/s2l_liso/regs_and_paths_with_invisibleRUN_255.txt",
+			"/sdcard/s2l_liso/regs_and_paths_with_invisibleRUN_Vid25.txt",
+			"/sdcard/s2l_liso/regs_and_paths_with_invisibleRUN_255.txt",
+			"/sdcard/s2l_liso/regs_and_paths_with_invisibleRUN_Vid25.txt",
+			"/sdcard/s2l_liso/regs_and_paths_with_invisibleRUN_255.txt",
+			"/sdcard/s2l_liso/regs_and_paths_with_invisibleRUN_Vid25.txt",
+			"/sdcard/s2l_liso/regs_and_paths_with_invisibleRUN_255.txt",
+			"/sdcard/s2l_liso/regs_and_paths_with_invisibleRUN_Vid25.txt",
+			"/sdcard/s2l_liso/regs_and_paths_with_invisibleRUN_255.txt",
+			"/sdcard/s2l_liso/regs_and_paths_with_invisibleRUN_Vid25.txt",
+			"/sdcard/s2l_liso/regs_and_paths_with_invisibleRUN_255.txt"
+		};
+
+		test_is2_init(ik_start_addr);
+
+		test_ituner(fd_iav, file_name[count]);//count = 0
+		gTestIS2.Mode.ConfigId = CfgInfo.CfgId = count%2; // 0
+		amba_img_dsp_post_exe_cfg(fd_iav, &gTestIS2.Mode, AMBA_DSP_IMG_CFG_EXE_PARTIALCOPY, 1);
+		//AmbaDSP_ImgLowIsoPrintCfg(&gTestIS2.Mode, CfgInfo);
+
+		printf("###CfgInfo.CfgId = %d\n",CfgInfo.CfgId);
+		amba_img_dsp_get_liso_cfg(&CfgInfo, (void*)&l_cfg);
+
+		//printf("###get cfg addr outside %p \n", l_cfg);
+
+		gTestIS2.Mode.ConfigId = CfgInfo.CfgId = (++count)%2; // 1
+		amba_img_dsp_post_exe_cfg(fd_iav, &gTestIS2.Mode, AMBA_DSP_IMG_CFG_EXE_FULLCOPY, 0);
+		//AmbaDSP_ImgLowIsoPrintCfg(&gTestIS2.Mode, CfgInfo);
+
+		printf("\n\n");
+
+		while(1){
+
+		//getchar();
+		printf("set next case %s debug:\n", file_name[count]);
+		printf("[step] [mode] [pic_num]\n");
+
+		scanf("%d %d %d", &debug_step, &debug_mode, &debug_pic_num);
+		debug.Step = debug_step;
+		debug.Mode = debug_mode;
+		debug.ChannelID = 0;
+		debug.TileX = 0;
+		debug.TileY = 0;
+		debug.PicNum = debug_pic_num;
+
+		printf("###debug.Step= %d debug.Mode= %d\n",debug.Step , debug.Mode);
+
+		test_ituner(fd_iav, file_name[count]);
+
+		gTestIS2.Mode.ConfigId = CfgInfo.CfgId = count % 2;
+		printf("load ituner file %s count %d cfg id %d\n", file_name[count], count, gTestIS2.Mode.ConfigId);
+
+		amba_img_dsp_set_debug_mode(&gTestIS2.Mode, &debug);
+		amba_img_dsp_post_exe_cfg(fd_iav, &gTestIS2.Mode, AMBA_DSP_IMG_CFG_EXE_PARTIALCOPY, 0);
+		if(debug.Step != 0){
+			AmbaDSP_ImgLowIsoPrintCfg(CfgInfo);
+			AmbaDSP_ImgLowIsoDumpCfg(CfgInfo, "/mnt");
+		}
+
+		amba_img_dsp_get_liso_cfg(&CfgInfo, (void*)&l_cfg);
+
+		printf("get cfg addr outside %p debug %d %d\n", l_cfg, l_cfg->share.debug_step_id, l_cfg->share.debug_mode);
+		sleep(1);
+
+		if(debug.Step == 0 && count < (FILE_NUM-1)){
+			printf("!!!!!copy config %d to config %d\n", count%2 , (count+1)%2);
+			gTestIS2.Mode.ConfigId = CfgInfo.CfgId = (++count)%2;
+			amba_img_dsp_post_exe_cfg(fd_iav, &gTestIS2.Mode, AMBA_DSP_IMG_CFG_EXE_FULLCOPY, 0);
+		}else{
+			printf("idsp dump step %d mode %d complete\n",debug.Step, debug.Mode);
+			break;
+		}
+		printf("\n\n");
+	}
+}
+	break;
+	case CONVERT_MODE:
+			printf("convert ituner file %s\n", file_name);
+			test_is2_init(ik_start_addr);
+			test_ituner(fd_iav, file_name);
+			amba_img_dsp_post_exe_cfg(fd_iav, &gTestIS2.Mode, 2, 1);
+
+			char adj_fn[128];
+			char tmp_str[1024];
+			int pos;
+			for(pos=0; pos<strlen(file_name); pos++){
+				if(file_name[pos] == '.')
+					break;
+			}
+			memset(tmp_str, 0, sizeof(tmp_str));
+			memcpy(tmp_str, file_name, pos);
+			sprintf(adj_fn, "%s_adj.c", tmp_str);
+			printf("write to %s\n", adj_fn);
+			FILE* file = fopen(adj_fn, "w");
+			memset(tmp_str, 0, sizeof(tmp_str));
+			{
+				int i=0;
+				amba_img_dsp_black_correction_t blc;
+				amba_img_dsp_get_static_black_level(&gTestIS2.Mode,&blc);
+				sprintf(tmp_str, "ADJ_BLC\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".param[N] = {{%d, %d, %d, %d,  %d, %d, %d, %d}},\r\n", blc.BlackR,blc.BlackGr,
+												blc.BlackGb, blc.BlackB,
+												blc.BlackR,blc.BlackGr,
+												blc.BlackGb, blc.BlackB);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, "\r\nADJ_ANTIALIASING\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+                amba_img_dsp_anti_aliasing_t        AntiAliasing;
+				amba_img_dsp_get_anti_aliasing(&gTestIS2.Mode,&AntiAliasing);
+				sprintf(tmp_str, ".param[N] =  {{%d,   %d,   %d}},\r\n", AntiAliasing.Enb, AntiAliasing.Thresh, AntiAliasing.LogFractionalCorrect);
+
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, "\r\nADJ_MO_ANTIALIASING\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+                amba_img_dsp_anti_aliasing_t        MoAntiAliasing;
+				amba_img_dsp_get_mo_anti_aliasing(&gTestIS2.Mode,&MoAntiAliasing);
+				sprintf(tmp_str, ".param[N] =  {{%d,   %d,   %d}},\r\n", MoAntiAliasing.Enb, MoAntiAliasing.Thresh, MoAntiAliasing.LogFractionalCorrect);
+
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, "\r\nADJ_GRGB_MISMATCH\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_gbgr_mismatch_t mis;
+				amba_img_dsp_get_gbgr_mismatch(&gTestIS2.Mode, &mis);
+				sprintf(tmp_str, ".param[N] =  {{%d,   %d,   %d,   %d}},\r\n", mis.NarrowEnable, mis.WideEnable,mis.WideSafety, mis.WideThresh);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, "\r\nADJ_MO_GRGB_MISMATCH\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_gbgr_mismatch_t Momis;
+				amba_img_dsp_get_mo_gbgr_mismatch(&gTestIS2.Mode, &Momis);
+				sprintf(tmp_str, ".param[N] =  {{%d,   %d,   %d,   %d}},\r\n", Momis.NarrowEnable, Momis.WideEnable,Momis.WideSafety, Momis.WideThresh);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				//ADJ_DPC
+				sprintf(tmp_str, "\r\nADJ_DPC\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_dbp_correction_t dpc;
+				amba_img_dsp_get_dynamic_bad_pixel_correction(&gTestIS2.Mode, &dpc);
+				sprintf(tmp_str, ".param[N] =  {{%d,  %d,  %d,  %d}},\r\n", dpc.Enb, dpc.HotPixelStrength, dpc.DarkPixelStrength, dpc.CorrectionMethod);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, "\r\nADJ_MO_DPC\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_dbp_correction_t Modpc;
+				amba_img_dsp_get_mo_dynamic_bad_pixel_correction(&gTestIS2.Mode, &Modpc);
+				sprintf(tmp_str, ".param[N] =  {{%d,  %d,  %d,  %d}},\r\n", Modpc.Enb, Modpc.HotPixelStrength, Modpc.DarkPixelStrength, Modpc.CorrectionMethod);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				//ADJ_CFANF_LOW
+				sprintf(tmp_str, "\r\nADJ_CFANF_LOW\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_cfa_noise_filter_t cfa;
+				amba_img_dsp_get_cfa_noise_filter(&gTestIS2.Mode, &cfa);
+				sprintf(tmp_str, ".param[N]  = {{%d,   %d,   %d,   %d,   %d,  %d,  %d, %d, %d, %d, %d, %d, %d,  %d, %d, %d, %d,   %d,}},\r\n",
+					cfa.Enb, cfa.NoiseLevel[0], cfa.NoiseLevel[1], cfa.NoiseLevel[2], cfa.OriginalBlendStr[0], cfa.OriginalBlendStr[1], cfa.OriginalBlendStr[2],
+					cfa.ExtentRegular[0], cfa.ExtentRegular[1], cfa.ExtentRegular[2], cfa.ExtentFine[0], cfa.ExtentFine[1], cfa.ExtentFine[2],
+					cfa.StrengthFine[0], cfa.StrengthFine[1], cfa.StrengthFine[2], cfa.SelectivityRegular, cfa.SelectivityFine);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, "\r\nADJ_MO_CFANF_LOW\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_cfa_noise_filter_t Mocfa;
+				amba_img_dsp_get_mo_cfa_noise_filter(&gTestIS2.Mode, &Mocfa);
+				sprintf(tmp_str, ".param[N]  = {{%d,   %d,   %d,   %d,   %d,  %d,  %d, %d, %d, %d, %d, %d, %d,  %d, %d, %d, %d,   %d,}},\r\n",
+					Mocfa.Enb, Mocfa.NoiseLevel[0], Mocfa.NoiseLevel[1], Mocfa.NoiseLevel[2], Mocfa.OriginalBlendStr[0], Mocfa.OriginalBlendStr[1], Mocfa.OriginalBlendStr[2],
+					Mocfa.ExtentRegular[0], Mocfa.ExtentRegular[1], Mocfa.ExtentRegular[2], Mocfa.ExtentFine[0], Mocfa.ExtentFine[1], Mocfa.ExtentFine[2],
+					Mocfa.StrengthFine[0], Mocfa.StrengthFine[1], Mocfa.StrengthFine[2], Mocfa.SelectivityRegular, Mocfa.SelectivityFine);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				//ADJ_DEMOSAIC
+				sprintf(tmp_str, "\r\nADJ_DEMOSAIC\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_demosaic_t demosaic;
+				amba_img_dsp_get_demosaic(&gTestIS2.Mode, &demosaic);
+				sprintf(tmp_str, ".param[N] =  {{%d, %d, %d, %d}},\r\n",
+					demosaic.ActivityThresh, demosaic.ActivityDifferenceThresh, demosaic.GradClipThresh, demosaic.GradNoiseThresh);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, "\r\nADJ_MO_DEMOSAIC\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_demosaic_t Modemosaic;
+				amba_img_dsp_get_mo_demosaic(&gTestIS2.Mode, &Modemosaic);
+				sprintf(tmp_str, ".param[N] =  {{%d, %d, %d, %d}},\r\n",
+					Modemosaic.ActivityThresh, Modemosaic.ActivityDifferenceThresh, Modemosaic.GradClipThresh, Modemosaic.GradNoiseThresh);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				//ADJ_TONE
+				sprintf(tmp_str, "\r\nADJ_TONE\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_tone_curve_t tone;
+				amba_img_dsp_get_tone_curve(&gTestIS2.Mode, &tone);
+				sprintf(tmp_str, ".tbl0 = {\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<256; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%4d,", tone.ToneCurveRed[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl1 = {\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<256; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%4d,", tone.ToneCurveGreen[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl2 = {\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<256; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%4d,", tone.ToneCurveBlue[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+
+				sprintf(tmp_str, "\r\nADJ_CHROMA_SCALE\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_chroma_scale_t cs;
+				amba_img_dsp_get_chroma_scale(&gTestIS2.Mode, &cs);
+				sprintf(tmp_str, ".param[N] =  {{%d, }},\r\n",cs.Enb);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				sprintf(tmp_str, ".tbl0 = {\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<128; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%4d,", cs.GainCurve[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+
+				sprintf(tmp_str, "\r\nADJ_CHROMA_MEDIAN\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_chroma_median_filter_t cm;
+				amba_img_dsp_get_chroma_median_filter(&gTestIS2.Mode, &cm);
+				sprintf(tmp_str, ".param[N] =  {{%d, %d, %d, %d, %d, %d, %d,}},\r\n",
+					cm.Enable, cm.CbAdaptiveStrength, cm.CrAdaptiveStrength, cm.CbNonAdaptiveStrength, cm.CrNonAdaptiveStrength,
+					cm.CbAdaptiveAmount, cm.CrAdaptiveAmount);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, "\r\nADJ_MO_CHROMA_MEDIAN\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_chroma_median_filter_t Mocm;
+				amba_img_dsp_get_mo_chroma_median_filter(&gTestIS2.Mode, &Mocm);
+				sprintf(tmp_str, ".param[N] =  {{%d, %d, %d, %d, %d, %d, %d,}},\r\n",
+					Mocm.Enable, Mocm.CbAdaptiveStrength, Mocm.CrAdaptiveStrength, Mocm.CbNonAdaptiveStrength, Mocm.CrNonAdaptiveStrength,
+					Mocm.CbAdaptiveAmount, Mocm.CrAdaptiveAmount);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				//ADJ_CHROMANF
+				sprintf(tmp_str, "\r\nADJ_CHROMANF\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_chroma_filter_t cf;
+				amba_img_dsp_get_chroma_filter(&gTestIS2.Mode, &cf);
+				sprintf(tmp_str, ".param[N] =  {{%d, %d, %d, %d, %d, %d,}},\r\n",
+					cf.Enable, cf.NoiseLevelCb, cf.NoiseLevelCr, cf.OriginalBlendStrengthCb, cf.OriginalBlendStrengthCr, cf.Radius);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, "\r\nADJ_MO_CHROMANF\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_chroma_filter_t Mocf;
+				amba_img_dsp_get_mo_chroma_filter(&gTestIS2.Mode, &Mocf);
+				sprintf(tmp_str, ".param[N] =  {{%d, %d, %d, %d, %d, %d,}},\r\n",
+					Mocf.Enable, Mocf.NoiseLevelCb, Mocf.NoiseLevelCr, Mocf.OriginalBlendStrengthCb, Mocf.OriginalBlendStrengthCr, Mocf.Radius);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+
+				//ADJ_1STMODE_SEL
+				sprintf(tmp_str, "\r\nADJ_1STMODE_SEL\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_liso_process_select_t sel;
+				amba_img_dsp_get_luma_processing_mode(&gTestIS2.Mode, &sel);
+				sprintf(tmp_str, ".param[N] =  {{%d,}},\r\n", sel.UseSharpenNotAsf);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, "\r\nADJ_MO_MODE_SEL\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_liso_process_select_t Mosel;
+				amba_img_dsp_get_mo_luma_processing_mode(&gTestIS2.Mode, &Mosel);
+				sprintf(tmp_str, ".param[N] =  {{%d,}},\r\n", Mosel.UseSharpenNotAsf);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				//ADJ_ASF
+				sprintf(tmp_str, "\r\nADJ_ASF\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_asf_info_t asf;
+				amba_img_dsp_get_advance_spatial_filter(&gTestIS2.Mode, &asf);
+				sprintf(tmp_str, ".param[N] =  {{%d,  %d,   %d,   %d, %d,   %d,     %d, %d,    %d,     %d,     %d,   %d,    %d,        %d,       %d,     %d,    %d,  %d,      %d,   %d,  %d,  %d,       %d,    %d,     %d,   %d,     %d,   %d,  %d,    %d,     %d,    %d,       %d,}},\r\n",
+					asf.Enable, asf.Fir.Specify, asf.Fir.StrengthIso, asf.Fir.StrengthDir, asf.Fir.EdgeThresh, asf.Fir.WideEdgeDetect, asf.DirectionalDecideT0, asf.DirectionalDecideT1,
+					asf.Adapt.AlphaMinUp, asf.Adapt.AlphaMaxUp, asf.Adapt.T0Up, asf.Adapt.T1Up, asf.Adapt.AlphaMinDown, asf.Adapt.AlphaMaxDown, asf.Adapt.T0Down, asf.Adapt.T1Down,
+					asf.LevelStrAdjust.Low, asf.LevelStrAdjust.LowDelta, asf.LevelStrAdjust.LowStrength, asf.LevelStrAdjust.MidStrength, asf.LevelStrAdjust.High, asf.LevelStrAdjust.HighDelta, asf.LevelStrAdjust.HighStrength,
+					asf.T0T1Div.Low, asf.T0T1Div.LowDelta, asf.T0T1Div.LowStrength, asf.T0T1Div.MidStrength, asf.T0T1Div.High, asf.T0T1Div.HighDelta, asf.T0T1Div.HighStrength,
+					asf.MaxChangeNotT0T1Alpha,asf.MaxChangeUp, asf.MaxChangeDown);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl0 = {//PerDirFirIsoStrengths\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<9; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%2d,", asf.Fir.PerDirFirIsoStrengths[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl1 = {//PerDirFirDirStrengths\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<9; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%2d,", asf.Fir.PerDirFirDirStrengths[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl2 = {//PerDirFirDirAmounts\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<9; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%2d,", asf.Fir.PerDirFirDirAmounts[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl3 = {//Coefs[9][25]\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				int j;
+				for(j=0; j<9; j++) {
+					for(i=0; i<25; i++) {
+						sprintf(tmp_str, "%2d,", asf.Fir.Coefs[j][i]);
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "\r\n");
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, "\r\nADJ_MO_ASF\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_asf_info_t Moasf;
+				amba_img_dsp_get_mo_advance_spatial_filter(&gTestIS2.Mode, &Moasf);
+				sprintf(tmp_str, ".param[N] =  {{%d,  %d,   %d,   %d, %d,   %d,     %d, %d,    %d,     %d,     %d,   %d,    %d,        %d,       %d,     %d,    %d,  %d,      %d,   %d,  %d,  %d,       %d,    %d,     %d,   %d,     %d,   %d,  %d,    %d,     %d,    %d,       %d,}},\r\n",
+					Moasf.Enable, Moasf.Fir.Specify, Moasf.Fir.StrengthIso, Moasf.Fir.StrengthDir, Moasf.Fir.EdgeThresh, Moasf.Fir.WideEdgeDetect, Moasf.DirectionalDecideT0, Moasf.DirectionalDecideT1,
+					Moasf.Adapt.AlphaMinUp, Moasf.Adapt.AlphaMaxUp, Moasf.Adapt.T0Up, Moasf.Adapt.T1Up, Moasf.Adapt.AlphaMinDown, Moasf.Adapt.AlphaMaxDown, Moasf.Adapt.T0Down, Moasf.Adapt.T1Down,
+					Moasf.LevelStrAdjust.Low, Moasf.LevelStrAdjust.LowDelta, Moasf.LevelStrAdjust.LowStrength, Moasf.LevelStrAdjust.MidStrength, Moasf.LevelStrAdjust.High, Moasf.LevelStrAdjust.HighDelta, Moasf.LevelStrAdjust.HighStrength,
+					Moasf.T0T1Div.Low, Moasf.T0T1Div.LowDelta, Moasf.T0T1Div.LowStrength, Moasf.T0T1Div.MidStrength, Moasf.T0T1Div.High, Moasf.T0T1Div.HighDelta, Moasf.T0T1Div.HighStrength,
+					Moasf.MaxChangeNotT0T1Alpha,Moasf.MaxChangeUp, Moasf.MaxChangeDown);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl0 = {//PerDirFirIsoStrengths\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<9; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%2d,", Moasf.Fir.PerDirFirIsoStrengths[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl1 = {//PerDirFirDirStrengths\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<9; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%2d,", Moasf.Fir.PerDirFirDirStrengths[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl2 = {//PerDirFirDirAmounts\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<9; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%2d,", Moasf.Fir.PerDirFirDirAmounts[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl3 = {//Coefs[9][25]\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(j=0; j<9; j++) {
+					for(i=0; i<25; i++) {
+						sprintf(tmp_str, "%2d,", Moasf.Fir.Coefs[j][i]);
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "\r\n");
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				//ADJ_1ST_SHPBOTH
+				sprintf(tmp_str, "\r\nADJ_1ST_SHPBOTH\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_sharpen_both_t sa_both;
+				amba_img_dsp_get_1st_sharpen_noise_both(&gTestIS2.Mode, &sa_both);
+				sprintf(tmp_str, ".param[N] =  {{%d,   %d,   %d,         %d,      %d,   %d,}},\r\n",
+					sa_both.Enable, sa_both.Mode, sa_both.EdgeThresh, sa_both.WideEdgeDetect,
+					sa_both.MaxChangeUp5x5, sa_both.MaxChangeDown5x5);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, "\r\nADJ_MO_SHPBOTH\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_sharpen_both_t Mosa_both;
+				amba_img_dsp_get_mo_sharpen_noise_both(&gTestIS2.Mode, &Mosa_both);
+				sprintf(tmp_str, ".param[N] =  {{%d,   %d,   %d,         %d,      %d,   %d,}},\r\n",
+					Mosa_both.Enable, Mosa_both.Mode, Mosa_both.EdgeThresh, Mosa_both.WideEdgeDetect,
+					Mosa_both.MaxChangeUp5x5, Mosa_both.MaxChangeDown5x5);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				//ADJ_1ST_SHPNOISE
+				sprintf(tmp_str, "\r\nADJ_1ST_SHPNOISE\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_sharpen_noise_t sa_noise;
+				amba_img_dsp_get_1st_sharpen_noise_noise(&gTestIS2.Mode, &sa_noise);
+				sprintf(tmp_str, ".param[N] =  {{%d,    %d,     %d,     %d,   %d,   %d,     %d,   %d,  %d,   %d,    %d,  %d, %d,     %d,    %d,	%d,	%d,	%d,	%d }},\r\n",
+					sa_noise.MaxChangeUp, sa_noise.MaxChangeDown, sa_noise.SpatialFir.Specify, sa_noise.SpatialFir.StrengthIso, sa_noise.SpatialFir.StrengthDir,
+					sa_noise.SpatialFir.EdgeThresh, sa_noise.SpatialFir.WideEdgeDetect,
+					sa_noise.LevelStrAdjust.Low, sa_noise.LevelStrAdjust.LowDelta, sa_noise.LevelStrAdjust.LowStrength, sa_noise.LevelStrAdjust.MidStrength,
+					sa_noise.LevelStrAdjust.High, sa_noise.LevelStrAdjust.HighDelta, sa_noise.LevelStrAdjust.HighStrength,
+					sa_noise.LevelStrAdjustNotT0T1LevelBased,sa_noise.T0,sa_noise.T1,sa_noise.AlphaMin,sa_noise.AlphaMax);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl0 = {//PerDirFirIsoStrengths\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<9; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%2d,", sa_noise.SpatialFir.PerDirFirIsoStrengths[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl1 = {//PerDirFirDirStrengths\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<9; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%2d,", sa_noise.SpatialFir.PerDirFirDirStrengths[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl2 = {//PerDirFirDirAmounts\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<9; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%2d,", sa_noise.SpatialFir.PerDirFirDirAmounts[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl3 = {//Coefs[9][25]\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(j=0; j<9; j++) {
+					for(i=0; i<25; i++) {
+						sprintf(tmp_str, "%3d,", sa_noise.SpatialFir.Coefs[j][i]);
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "\r\n");
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, "\r\nADJ_MO_SHPNOISE\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_sharpen_noise_t Mosa_noise;
+				amba_img_dsp_get_mo_sharpen_noise_noise(&gTestIS2.Mode, &Mosa_noise);
+				sprintf(tmp_str, ".param[N] =  {{%d,    %d,     %d,     %d,   %d,   %d,     %d,   %d,  %d,   %d,    %d,  %d, %d,     %d,    %d,	%d,	%d,	%d,	%d }},\r\n",
+					Mosa_noise.MaxChangeUp, Mosa_noise.MaxChangeDown, Mosa_noise.SpatialFir.Specify, Mosa_noise.SpatialFir.StrengthIso, Mosa_noise.SpatialFir.StrengthDir,
+					Mosa_noise.SpatialFir.EdgeThresh, Mosa_noise.SpatialFir.WideEdgeDetect,
+					Mosa_noise.LevelStrAdjust.Low, Mosa_noise.LevelStrAdjust.LowDelta, Mosa_noise.LevelStrAdjust.LowStrength, Mosa_noise.LevelStrAdjust.MidStrength,
+					Mosa_noise.LevelStrAdjust.High, Mosa_noise.LevelStrAdjust.HighDelta, Mosa_noise.LevelStrAdjust.HighStrength,
+					Mosa_noise.LevelStrAdjustNotT0T1LevelBased,Mosa_noise.T0,Mosa_noise.T1,Mosa_noise.AlphaMin,Mosa_noise.AlphaMax);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl0 = {//PerDirFirIsoStrengths\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<9; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%2d,", Mosa_noise.SpatialFir.PerDirFirIsoStrengths[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl1 = {//PerDirFirDirStrengths\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<9; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%2d,", Mosa_noise.SpatialFir.PerDirFirDirStrengths[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl2 = {//PerDirFirDirAmounts\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<9; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%2d,", Mosa_noise.SpatialFir.PerDirFirDirAmounts[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl3 = {//Coefs[9][25]\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(j=0; j<9; j++) {
+					for(i=0; i<25; i++) {
+						sprintf(tmp_str, "%3d,", Mosa_noise.SpatialFir.Coefs[j][i]);
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "\r\n");
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				//ADJ_1ST_SHPFIR
+				sprintf(tmp_str, "\r\nADJ_1ST_SHPFIR\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_fir_t sa_fir;
+				amba_img_dsp_get_1st_sharpen_noise_sharpen_fir(&gTestIS2.Mode, &sa_fir);
+				sprintf(tmp_str, ".param[N] =  {{%d,   %d,   %d,    %d,     %d,}},\r\n",
+					sa_fir.Specify, sa_fir.StrengthIso, sa_fir.StrengthDir, sa_fir.EdgeThresh, sa_fir.WideEdgeDetect);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl0 = {//PerDirFirIsoStrengths\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<9; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%2d,", sa_fir.PerDirFirIsoStrengths[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl1 = {//PerDirFirDirStrengths\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<9; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%2d,", sa_fir.PerDirFirDirStrengths[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl2 = {//PerDirFirDirAmounts\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<9; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%2d,", sa_fir.PerDirFirDirAmounts[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl3 = {//Coefs[9][25]\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(j=0; j<9; j++) {
+					for(i=0; i<25; i++) {
+						sprintf(tmp_str, "%3d,", sa_fir.Coefs[j][i]);
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "\r\n");
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, "\r\nADJ_MO_SHPFIR\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_fir_t Mosa_fir;
+				amba_img_dsp_get_mo_sharpen_noise_sharpen_fir(&gTestIS2.Mode, &Mosa_fir);
+				sprintf(tmp_str, ".param[N] =  {{%d,   %d,   %d,    %d,     %d,}},\r\n",
+					Mosa_fir.Specify, Mosa_fir.StrengthIso, Mosa_fir.StrengthDir, Mosa_fir.EdgeThresh, Mosa_fir.WideEdgeDetect);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl0 = {//PerDirFirIsoStrengths\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<9; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%2d,", Mosa_fir.PerDirFirIsoStrengths[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl1 = {//PerDirFirDirStrengths\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<9; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%2d,", Mosa_fir.PerDirFirDirStrengths[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl2 = {//PerDirFirDirAmounts\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<9; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%2d,", Mosa_fir.PerDirFirDirAmounts[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl3 = {//Coefs[9][25]\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(j=0; j<9; j++) {
+					for(i=0; i<25; i++) {
+						sprintf(tmp_str, "%3d,", Mosa_fir.Coefs[j][i]);
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "\r\n");
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				//ADJ_1ST_SHPCORING
+				sprintf(tmp_str, "\r\nADJ_1ST_SHPCORING\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_coring_t coring;
+				amba_img_dsp_get_1st_sharpen_noise_sharpen_coring(&gTestIS2.Mode, &coring);
+			//	sprintf(tmp_str, ".param[N] =  {{%d,}},\r\n",coring.FractionalBits);
+			//	fwrite(tmp_str, strlen(tmp_str), 1, file);
+				sprintf(tmp_str, ".tbl0 = {\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<256; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%2d,", coring.Coring[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, "\r\nADJ_MO_SHPCORING\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_coring_t Mocoring;
+				amba_img_dsp_get_mo_sharpen_noise_sharpen_coring(&gTestIS2.Mode, &Mocoring);
+			//	sprintf(tmp_str, ".param[N] =  {{%d,}},\r\n",coring.FractionalBits);
+			//	fwrite(tmp_str, strlen(tmp_str), 1, file);
+				sprintf(tmp_str, ".tbl0 = {\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<256; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%2d,", Mocoring.Coring[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				//ADJ_1ST_SHPCORING_INDEX_SCALE
+				sprintf(tmp_str, "\r\nADJ_1ST_SHPCORING_INDEX_SCALE\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_level_t idx_scale;
+				amba_img_dsp_get_1st_sharpen_noise_sharpen_coring_index_scale(&gTestIS2.Mode, &idx_scale);
+				sprintf(tmp_str, ".param[N] =  {{%d,   %d,   %d,     %d,  %d,  %d,     %d, }},\r\n",
+					idx_scale.Low, idx_scale.LowDelta, idx_scale.LowStrength, idx_scale.MidStrength,
+					idx_scale.High, idx_scale.HighDelta, idx_scale.HighStrength);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, "\r\nADJ_MO_SHPCORING_INDEX_SCALE\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_level_t Moidx_scale;
+				amba_img_dsp_get_mo_sharpen_noise_sharpen_coring_index_scale(&gTestIS2.Mode, &Moidx_scale);
+				sprintf(tmp_str, ".param[N] =  {{%d,   %d,   %d,     %d,  %d,  %d,     %d, }},\r\n",
+					Moidx_scale.Low, Moidx_scale.LowDelta, Moidx_scale.LowStrength, Moidx_scale.MidStrength,
+					Moidx_scale.High, Moidx_scale.HighDelta, Moidx_scale.HighStrength);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				//ADJ_1ST_SHPCORING_MIN_RESULT
+				sprintf(tmp_str, "\r\nADJ_1ST_SHPCORING_MIN_RESULT\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_level_t coring_min;
+				amba_img_dsp_get_1st_sharpen_noise_sharpen_min_coring_result(&gTestIS2.Mode, &coring_min);
+				sprintf(tmp_str, ".param[N] =  {{%d,   %d,   %d,     %d,  %d,  %d,     %d, }},\r\n",
+					coring_min.Low, coring_min.LowDelta, coring_min.LowStrength, coring_min.MidStrength,
+					coring_min.High, coring_min.HighDelta, coring_min.HighStrength);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, "\r\nADJ_MO_SHPCORING_MIN_RESULT\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_level_t Mocoring_min;
+				amba_img_dsp_get_mo_sharpen_noise_sharpen_min_coring_result(&gTestIS2.Mode, &Mocoring_min);
+				sprintf(tmp_str, ".param[N] =  {{%d,   %d,   %d,     %d,  %d,  %d,     %d, }},\r\n",
+					Mocoring_min.Low, Mocoring_min.LowDelta, Mocoring_min.LowStrength, Mocoring_min.MidStrength,
+					Mocoring_min.High, Mocoring_min.HighDelta, Mocoring_min.HighStrength);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				//ADJ_1ST_SHPCORING_SCALE_CORING
+				sprintf(tmp_str, "\r\nADJ_1ST_SHPCORING_SCALE_CORING\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_level_t scale_coring;
+				amba_img_dsp_get_1st_sharpen_noise_sharpen_scale_coring(&gTestIS2.Mode, &scale_coring);
+				sprintf(tmp_str, ".param[N] =  {{%d,   %d,   %d,     %d,  %d,  %d,     %d, }},\r\n",
+					scale_coring.Low, scale_coring.LowDelta, scale_coring.LowStrength, scale_coring.MidStrength,
+					scale_coring.High, scale_coring.HighDelta, scale_coring.HighStrength);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, "\r\nADJ_MO_SHPCORING_SCALE_CORING\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_level_t Moscale_coring;
+				amba_img_dsp_get_mo_sharpen_noise_sharpen_scale_coring(&gTestIS2.Mode, &Moscale_coring);
+				sprintf(tmp_str, ".param[N] =  {{%d,   %d,   %d,     %d,  %d,  %d,     %d, }},\r\n",
+					Moscale_coring.Low, Moscale_coring.LowDelta, Moscale_coring.LowStrength, Moscale_coring.MidStrength,
+					Moscale_coring.High, Moscale_coring.HighDelta, Moscale_coring.HighStrength);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, "\r\nADJ_Final_SHPBOTH\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_sharpen_both_t sb_both;
+				amba_img_dsp_get_final_sharpen_noise_both(&gTestIS2.Mode, &sb_both);
+				sprintf(tmp_str, ".param[N] =  {{%d,   %d,   %d,         %d,      %d,   %d,}},\r\n",
+					sb_both.Enable, sb_both.Mode, sb_both.EdgeThresh, sb_both.WideEdgeDetect,
+					sb_both.MaxChangeUp5x5, sb_both.MaxChangeDown5x5);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				//ADJ_FINAL_SHPNOISE
+				sprintf(tmp_str, "\r\nADJ_FINAL_SHPNOISE\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_sharpen_noise_t sb_noise;
+				amba_img_dsp_get_final_sharpen_noise_noise(&gTestIS2.Mode, &sb_noise);
+				sprintf(tmp_str, ".param[N] =  {{%d,    %d,     %d,     %d,   %d,   %d,     %d,   %d,  %d,   %d,    %d,  %d, %d,     %d,    %d,	%d,	%d,	%d,	%d }},\r\n",
+					sb_noise.MaxChangeUp, sb_noise.MaxChangeDown, sb_noise.SpatialFir.Specify, sb_noise.SpatialFir.StrengthIso, sb_noise.SpatialFir.StrengthDir,
+					sb_noise.SpatialFir.EdgeThresh, sb_noise.SpatialFir.WideEdgeDetect,
+					sb_noise.LevelStrAdjust.Low, sb_noise.LevelStrAdjust.LowDelta, sb_noise.LevelStrAdjust.LowStrength, sb_noise.LevelStrAdjust.MidStrength,
+					sb_noise.LevelStrAdjust.High, sb_noise.LevelStrAdjust.HighDelta, sb_noise.LevelStrAdjust.HighStrength,
+					sb_noise.LevelStrAdjustNotT0T1LevelBased,sb_noise.T0,sb_noise.T1,sb_noise.AlphaMin,sb_noise.AlphaMax);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl0 = {//PerDirFirIsoStrengths\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<9; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%2d,", sb_noise.SpatialFir.PerDirFirIsoStrengths[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl1 = {//PerDirFirDirStrengths\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<9; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%2d,", sb_noise.SpatialFir.PerDirFirDirStrengths[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl2 = {//PerDirFirDirAmounts\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<9; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%2d,", sb_noise.SpatialFir.PerDirFirDirAmounts[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl3 = {//Coefs[9][25]\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(j=0; j<9; j++) {
+					for(i=0; i<25; i++) {
+						sprintf(tmp_str, "%3d,", sb_noise.SpatialFir.Coefs[j][i]);
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "\r\n");
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				//ADJ_FINAL_SHPFIR
+				sprintf(tmp_str, "\r\nADJ_FINAL_SHPFIR\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_fir_t sb_fir;
+				amba_img_dsp_get_final_sharpen_noise_sharpen_fir(&gTestIS2.Mode, &sb_fir);
+				sprintf(tmp_str, ".param[N] =  {{%d,   %d,   %d,    %d,     %d,}},\r\n",
+					sb_fir.Specify, sb_fir.StrengthIso, sb_fir.StrengthDir, sb_fir.EdgeThresh, sb_fir.WideEdgeDetect);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl0 = {//PerDirFirIsoStrengths\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<9; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%2d,", sb_fir.PerDirFirIsoStrengths[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl1 = {//PerDirFirDirStrengths\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<9; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%2d,", sb_fir.PerDirFirDirStrengths[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl2 = {//PerDirFirDirAmounts\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<9; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%2d,", sb_fir.PerDirFirDirAmounts[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				sprintf(tmp_str, ".tbl3 = {//Coefs[9][25]\r\n{{");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(j=0; j<9; j++) {
+					for(i=0; i<25; i++) {
+						sprintf(tmp_str, "%3d,", sb_fir.Coefs[j][i]);
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "\r\n");
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "},},\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				//ADJ_FINAL_SHPCORING
+				sprintf(tmp_str, "\r\nADJ_FINAL_SHPCORING\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_coring_t sb_coring;
+				amba_img_dsp_get_final_sharpen_noise_sharpen_coring(&gTestIS2.Mode, &sb_coring);
+			//	sprintf(tmp_str, ".param[N] =  {{%d,}},\r\n",coring.FractionalBits);
+			//	fwrite(tmp_str, strlen(tmp_str), 1, file);
+				sprintf(tmp_str, ".tbl0 = {\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				for(i=0; i<256; i++) {
+					if(!(i%32) && i!=0){
+						sprintf(tmp_str, "\r\n");
+						fwrite(tmp_str, strlen(tmp_str), 1, file);
+					}
+					sprintf(tmp_str, "%2d,", sb_coring.Coring[i]);
+					fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+				sprintf(tmp_str, "\r\n},\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				//ADJ_FINAL_SHPCORING_INDEX_SCALE
+				sprintf(tmp_str, "\r\nADJ_FINAL_SHPCORING_INDEX_SCALE\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_level_t sb_idx_scale;
+				amba_img_dsp_get_final_sharpen_noise_sharpen_coring_index_scale(&gTestIS2.Mode, &sb_idx_scale);
+				sprintf(tmp_str, ".param[N] =  {{%d,   %d,   %d,     %d,  %d,  %d,     %d, }},\r\n",
+					sb_idx_scale.Low, sb_idx_scale.LowDelta, sb_idx_scale.LowStrength, sb_idx_scale.MidStrength,
+					sb_idx_scale.High, sb_idx_scale.HighDelta, sb_idx_scale.HighStrength);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				//ADJ_FINAL_SHPCORING_MIN_RESULT
+				sprintf(tmp_str, "\r\nADJ_FINAL_SHPCORING_MIN_RESULT\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_level_t sb_coring_min;
+				amba_img_dsp_get_final_sharpen_noise_sharpen_min_coring_result(&gTestIS2.Mode, &sb_coring_min);
+				sprintf(tmp_str, ".param[N] =  {{%d,   %d,   %d,     %d,  %d,  %d,     %d, }},\r\n",
+					sb_coring_min.Low, sb_coring_min.LowDelta, sb_coring_min.LowStrength, sb_coring_min.MidStrength,
+					sb_coring_min.High, sb_coring_min.HighDelta, sb_coring_min.HighStrength);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				//ADJ_FINAL_SHPCORING_SCALE_CORING
+				sprintf(tmp_str, "\r\nADJ_FINAL_SHPCORING_SCALE_CORING\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_level_t sb_scale_coring;
+				amba_img_dsp_get_final_sharpen_noise_sharpen_scale_coring(&gTestIS2.Mode, &sb_scale_coring);
+				sprintf(tmp_str, ".param[N] =  {{%d,   %d,   %d,     %d,  %d,  %d,     %d, }},\r\n",
+					sb_scale_coring.Low, sb_scale_coring.LowDelta, sb_scale_coring.LowStrength, sb_scale_coring.MidStrength,
+					sb_scale_coring.High, sb_scale_coring.HighDelta, sb_scale_coring.HighStrength);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+				//ADJ_VIDEO_MCTF
+				sprintf(tmp_str, "\r\nADJ_VIDEO_MCTF\r\n");
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				amba_img_dsp_video_mctf_info_t mctf;
+				amba_img_dsp_get_video_mctf(&gTestIS2.Mode, &mctf);
+				sprintf(tmp_str, ".param[N] =  {{%d, %d,%d,%d,%d,%d,%d,%d,%d, %d,      %d,   %d,    %d,  %d,  %d,	%d,	%d,	%d,	%d,	%d,	%d,	%d, %d,	%d,	%d,	%d,	%d,	%d,	%d,	%d,	%d,	%d,	%d,}},\r\n",
+					mctf.Enable,
+					mctf.YMaxChange,mctf.UMaxChange,mctf.VMaxChange,mctf.WeightingBasedOnLocalMotion,
+					mctf.Threshold0[0],mctf.Threshold0[1],mctf.Threshold0[2],mctf.Threshold0[3],
+					mctf.Threshold1[0],mctf.Threshold1[1],mctf.Threshold1[2],mctf.Threshold1[3],
+					mctf.Threshold2[0],mctf.Threshold2[1],mctf.Threshold2[2],mctf.Threshold2[3],
+					mctf.Threshold3[0],mctf.Threshold3[1],mctf.Threshold3[2],mctf.Threshold3[3],
+					mctf.Alpha1[0],mctf.Alpha1[1],mctf.Alpha1[2],mctf.Alpha1[3],
+					mctf.Alpha2[0],mctf.Alpha2[1],mctf.Alpha2[2],mctf.Alpha2[3],
+					mctf.Alpha3[0],mctf.Alpha3[1],mctf.Alpha3[2],mctf.Alpha3[3]);
+				fwrite(tmp_str, strlen(tmp_str), 1, file);
+				}
+
+                            //ADJ_WIDE_CHROMANF
+                        sprintf(tmp_str, "\r\nADJ_WIDE_CHROMANF\r\n");
+                        fwrite(tmp_str, strlen(tmp_str), 1, file);
+                        amba_img_dsp_chroma_filter_t wide_cf;
+                        amba_img_dsp_get_wide_chroma_filter(&gTestIS2.Mode, &wide_cf);
+                        sprintf(tmp_str, ".param[N] =  {{%d, %d, %d, %d, %d, %d,}},\r\n",
+                         wide_cf.Enable, wide_cf.NoiseLevelCb, wide_cf.NoiseLevelCr, wide_cf.OriginalBlendStrengthCb, wide_cf.OriginalBlendStrengthCr, wide_cf.Radius);
+                        fwrite(tmp_str, strlen(tmp_str), 1, file);
+
+
+
+                                       //ADJ_WIDE_CHROMANF_COMBINE
+                        sprintf(tmp_str, "\r\nADJ_WIDE_CHROMANF_COMBINE\r\n");
+                        fwrite(tmp_str, strlen(tmp_str), 1, file);
+                        AMBA_DSP_IMG_HISO_CHROMA_FILTER_COMBINE_s wide_cf_combine;
+                        amba_img_dsp_get_wide_chroma_filter_combine(&gTestIS2.Mode, &wide_cf_combine);
+                        sprintf(tmp_str, ".param[N] =  {{%d, %d, %d, %d, %d, %d,%d,%d,%d,%d,}},\r\n",
+                        wide_cf_combine.T0Cb,wide_cf_combine.T0Cr,wide_cf_combine.T1Cb,wide_cf_combine.T1Cr,
+                        wide_cf_combine.AlphaMaxCb,wide_cf_combine.AlphaMaxCr,wide_cf_combine.AlphaMinCb,wide_cf_combine.AlphaMinCr,
+                        wide_cf_combine.MaxChangeCb,wide_cf_combine.MaxChangeCr);
+                        fwrite(tmp_str, strlen(tmp_str), 1, file);
+				fclose(file);
+
+			break;
+		default:
+			printf("unknow work mode %d\n", work_mode);
+			return -1;
+			break;
+	}
+	return 0;
+}
+
+
+int dump_debug_cfg(void *cfg_addr)
+{
+	printf("dump debug section to %s\n", folder_name);
+
+	a12_high_iso_param_t* h_cfg = (a12_high_iso_param_t*)cfg_addr;
+	printf("get debug step %d mode %d\n", h_cfg->share.debug_step_id, h_cfg->share.debug_mode);
+	printf("debug cfg_addr 0x%x debug_addr 0x%x 0x%x\n", h_cfg->share.debug_config_addr,
+							h_cfg->share.debug_addr[0], h_cfg->share.debug_addr[1]);
+	printf("pitch %d %d width %d %d height %d %d\n", h_cfg->share.debug_pitch[0], h_cfg->share.debug_pitch[1],
+							h_cfg->share.debug_width[0], h_cfg->share.debug_width[1],
+							h_cfg->share.debug_height[0], h_cfg->share.debug_height[1]);
+
+	int y_size = h_cfg->share.debug_pitch[0]*h_cfg->share.debug_height[0];
+	u32 y_src = h_cfg->share.debug_addr[0];
+	int uv_size = h_cfg->share.debug_pitch[1]*h_cfg->share.debug_height[1];
+	u32 uv_src = h_cfg->share.debug_addr[1];
+	u32 debug_cfg_src = h_cfg->share.debug_config_addr;
+	int debug_cfg_size = 150*1024;
+
+	char fn[64], shell_cmd[128];
+	if(strlen(folder_name)==0)
+		sprintf(folder_name, "/mnt/debug");
+	sprintf(shell_cmd, "mkdir -p %s", folder_name);
+	system(shell_cmd);
+
+	if(debug_cfg_src != 0) {
+		sprintf(fn, "step%d_mode%d_cfg.bin", h_cfg->share.debug_step_id, h_cfg->share.debug_mode);
+		sprintf(shell_cmd, "amba_debug -r 0x%x -s 0x%x -f %s/%s", debug_cfg_src, debug_cfg_size, folder_name, fn);
+		system(shell_cmd);
+	}
+	if(y_src != 0) {
+		sprintf(fn, "step%d_mode%d_w%d_h%d.y", h_cfg->share.debug_step_id, h_cfg->share.debug_mode,
+						h_cfg->share.debug_pitch[0], h_cfg->share.debug_height[0]);
+		sprintf(shell_cmd, "amba_debug -r 0x%x -s 0x%x -f %s/%s", y_src, y_size, folder_name, fn);
+		system(shell_cmd);
+	}
+	if(uv_src != 0) {
+		sprintf(fn, "step%d_mode%d_w%d_h%d.uv", h_cfg->share.debug_step_id, h_cfg->share.debug_mode,
+						h_cfg->share.debug_pitch[1], h_cfg->share.debug_height[1]);
+		sprintf(shell_cmd, "amba_debug -r 0x%x -s 0x%x -f %s/%s", uv_src, uv_size, folder_name, fn);
+		system(shell_cmd);
+	}
+
+	return 0;
+}
diff --git a/package_test/test_cryptochip.c b/package_test/test_cryptochip.c
new file mode 100644
index 0000000..73ef418
--- /dev/null
+++ b/package_test/test_cryptochip.c
@@ -0,0 +1,710 @@
+/*
+ * test_cryptochip.c
+ *
+ * History:
+ *	2015/09/22 - [Zhi He] create file for ATSHA204
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <sys/time.h>
+
+#include "cryptochip_library_if.h"
+
+#define u_printf printf
+#define u_printf_error printf
+#define u_printf_debug printf
+
+#define DCC_SLOT_CONFIG1_READ_SLOT_MASK 0x0f
+#define DCC_SLOT_CONFIG1_CHECK_ONLY_BIT 0x10
+#define DCC_SLOT_CONFIG1_SINGLE_USE_BIT 0x20
+#define DCC_SLOT_CONFIG1_ENCRYPT_READ_BIT 0x40
+#define DCC_SLOT_CONFIG1_IS_SECRET_BIT 0x80
+
+#define DCC_SLOT_CONFIG2_WRITE_SLOT_MASK 0x0f
+#define DCC_SLOT_CONFIG2_ENCRYPT_WRITE_BIT 0x40
+#define DCC_SLOT_CONFIG2_NON_WRITE_FLAG 0x80
+
+typedef struct {
+    unsigned char b_show_serial_number;
+    unsigned char b_show_config;
+    unsigned char b_show_otp;
+    unsigned char b_initialize_config_zone;
+
+    unsigned char b_initialize_otp_and_data_zone;
+    unsigned char reserved_0;
+    unsigned char reserved_1;
+    unsigned char reserved_2;
+
+    unsigned char b_test_en_write;
+    unsigned char test_en_write_slot;
+    unsigned char b_test_en_read;
+    unsigned char test_en_read_slot;
+
+    unsigned char test_generate_hwsignature;
+    unsigned char genhwsign_storage_slot;
+    unsigned char test_verify_hwsignature;
+    unsigned char verifyhwsign_storage_slot;
+
+    void * p_chip;
+} test_cryptochip_context;
+
+static void __print_textable(const char* p, int len)
+{
+    char* p_buf = (char*) malloc(len + 8);
+    snprintf(p_buf, len, "%s", p);
+    u_printf("%s\n", p_buf);
+}
+
+static void __print_memory_8align_hex(const unsigned char* p, int len)
+{
+    int i;
+
+    while (len > 8) {
+        u_printf(" 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n", p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);
+        p += 8;
+        len -= 8;
+    }
+
+    for (i = 0; i < len; i++) {
+        u_printf(" 0x%02X", p[i]);
+    }
+
+    u_printf("\n");
+}
+
+static void __print_memory_hex(const unsigned char* data, const int len)
+{
+    int i;
+
+    for (i = 0; i < len; i++) {
+        if (i > 0) {
+            u_printf(" ");
+        }
+        u_printf("0x%02X", data[i]);
+    }
+
+    u_printf("\n");
+}
+
+static void __print_ut_options()
+{
+    u_printf("test_cryptochip options:\n");
+    u_printf("\t'--showsn': will show serial number\n");
+    u_printf("\t'--showconfig': will show config zone, 88 bytes\n");
+    u_printf("\t'--showotp': will show one time programmable data, 64 bytes\n");
+
+    u_printf("\t'--initconfig': will write and lock (initialize) config zone\n");
+    u_printf("\t'--initotpdata': will write and lock (initialize) otp and data zone\n");
+
+    u_printf("\t'--testenwrite %%d': will write a data slot. (encrypt write)\n");
+    u_printf("\t'--testenread %%d': will read a data slot. (encrypt read)\n");
+
+    u_printf("\t'--testgensign %%d': will generate a fake digest (fake_digest) and store its hw signature\n");
+    u_printf("\t'--testverifysign %%d': will verify the fake digest (fake_digest) and its hw signature\n");
+
+    u_printf("\t'--help': print help\n\n");
+    u_printf("\t setup cryptochip:\n");
+    u_printf("\t\t modprobe atsha204\n");
+    u_printf("\t\t echo atsha204 0x64 | tee /sys/class/i2c-dev/i2c-0/device/new_device\n");
+}
+
+static int __init_test_cryptochip_params(int argc, char **argv, test_cryptochip_context* context)
+{
+    int i = 0;
+
+    for (i = 1; i < argc; i++) {
+        if (!strcmp("--showsn", argv[i])) {
+            context->b_show_serial_number = 1;
+            u_printf("[input argument] --showsn, show serial number.\n");
+        } else if (!strcmp("--showconfig", argv[i])) {
+            context->b_show_config = 1;
+            u_printf("[input argument] --showconfig, show config zone.\n");
+        } else if (!strcmp("--showotp", argv[i])) {
+            context->b_show_otp = 1;
+            u_printf("[input argument] --showotp, show otp zone.\n");
+        } else if (!strcmp("--initconfig", argv[i])) {
+            context->b_initialize_config_zone = 1;
+            u_printf("[input argument] --initconfig, write and lock config zone.\n");
+        } else if (!strcmp("--initotpdata", argv[i])) {
+            context->b_initialize_otp_and_data_zone = 1;
+            u_printf("[input argument] --initotpdata, write and lock otp and data zone.\n");
+        } else if (!strcmp("--testenwrite", argv[i])) {
+            int slot = 0;
+            if (argc > (i + 1)) {
+                if (1 == sscanf(argv[i + 1], "%d", &slot)) {
+                    if (16 > slot) {
+                        context->b_test_en_write = 1;
+                        context->test_en_write_slot = slot;
+                        u_printf("[input argument] --testenwrite, slot %d\n", context->test_en_write_slot);
+                    } else {
+                        u_printf_error("bad slot id %d\n", slot);
+                        return (-1);
+                    }
+                } else {
+                    u_printf_error(" --testenwrite should follow slot id \n");
+                    return (-1);
+                }
+            } else {
+                u_printf_error(" --testenwrite should follow slot id\n");
+                return (-1);
+            }
+            i ++ ;
+        } else if (!strcmp("--testenread", argv[i])) {
+            int slot = 0;
+            if (argc > (i + 1)) {
+                if (1 == sscanf(argv[i + 1], "%d", &slot)) {
+                    if (16 > slot) {
+                        context->b_test_en_read = 1;
+                        context->test_en_read_slot = slot;
+                        u_printf("[input argument] --testenread, slot %d\n", context->test_en_read_slot);
+                    } else {
+                        u_printf_error("bad slot id %d\n", slot);
+                        return (-1);
+                    }
+                } else {
+                    u_printf_error(" --testenread should follow slot id\n");
+                    return (-1);
+                }
+            } else {
+                u_printf_error(" --testenread should follow slot id\n");
+                return (-1);
+            }
+            i ++ ;
+        } else if (!strcmp("--testgensign", argv[i])) {
+            int slot = 0;
+            if (argc > (i + 1)) {
+                if (1 == sscanf(argv[i + 1], "%d", &slot)) {
+                    if (16 > slot) {
+                        context->test_generate_hwsignature = 1;
+                        context->genhwsign_storage_slot = slot;
+                        u_printf("[input argument] --testgensign, slot %d\n", context->genhwsign_storage_slot);
+                    } else {
+                        u_printf_error("bad slot id %d\n", slot);
+                        return (-1);
+                    }
+                } else {
+                    u_printf_error(" --testgensign should follow slot id\n");
+                    return (-1);
+                }
+            } else {
+                u_printf_error(" --testgensign should follow slot id\n");
+                return (-1);
+            }
+            i ++ ;
+        } else if (!strcmp("--testverifysign", argv[i])) {
+            int slot = 0;
+            if (argc > (i + 1)) {
+                if (1 == sscanf(argv[i + 1], "%d", &slot)) {
+                    if (16 > slot) {
+                        context->test_verify_hwsignature = 1;
+                        context->verifyhwsign_storage_slot = slot;
+                        u_printf("[input argument] --testverifysign, slot %d\n", context->verifyhwsign_storage_slot);
+                    } else {
+                        u_printf_error("bad slot id %d\n", slot);
+                        return (-1);
+                    }
+                } else {
+                    u_printf_error(" --testverifysign should follow slot id\n");
+                    return (-1);
+                }
+            } else {
+                u_printf_error(" --testverifysign should follow slot id\n");
+                return (-1);
+            }
+            i ++ ;
+        } else {
+            u_printf_error("error: NOT processed option(%s).\n", argv[i]);
+            __print_ut_options();
+            return (-1);
+        }
+    }
+
+    return 0;
+}
+
+
+#define DCIRCULAR_SHIFT_8(x, s) ((x >> s) | (x << (8 - s)))
+
+void __scamble_sequence(unsigned char *p, unsigned int len)
+{
+    unsigned int i = 0;
+    unsigned char r[8] = {17, 37, 5, 11, 119, 29, 163, 101};
+    unsigned char v[8] = {59, 211, 73, 7, 127, 19, 23, 73};
+    unsigned char* pp = NULL;
+
+    unsigned char t1, t2;
+
+    if (7 < len) {
+        for (i = 0; i < 8; i ++) {
+            t1 = (v[i] ^ p[i]);
+            t2 = (v[i] & 0x7);
+            v[i] = DCIRCULAR_SHIFT_8(t1, t2) ^ r[i];
+        }
+    } else {
+        for (i = 0; i < len; i ++) {
+            t1 = (v[i] ^ p[i]);
+            t2 = (v[i] & 0x7);
+            v[i] = DCIRCULAR_SHIFT_8(t1, t2) ^ r[i];
+        }
+
+        for (; i < 8; i ++) {
+            t1 = v[i];
+            t2 = (v[i] & 0x7);
+            v[i] = DCIRCULAR_SHIFT_8(t1, t2) ^ r[i];
+        }
+    }
+
+    t2 = (v[7] & 0x7);
+    i = 0;
+    pp = p;
+    while (len > 8) {
+        pp[0] = (((v[0] ^ v[1]) & (r[4] + r[5])) | DCIRCULAR_SHIFT_8(pp[0], t2)) + 19;
+        t2 = pp[0] & 0x7;
+        pp[1] = (((v[1] & v[2]) ^ (r[5] | r[6])) ^ DCIRCULAR_SHIFT_8(pp[1], t2)) + 47;
+        t2 = pp[1] & 0x7;
+        pp[2] = (((v[2] | v[3]) + (r[6] & r[7])) ^ DCIRCULAR_SHIFT_8(pp[2], t2)) + 113;
+        t2 = pp[2] & 0x7;
+        pp[3] = (((v[3] + v[4]) | (r[7] ^ r[0])) ^ DCIRCULAR_SHIFT_8(pp[3], t2)) + 17;
+        t2 = pp[3] & 0x7;
+        pp[4] = (((v[4] & v[5]) ^ (r[0] | r[1])) | DCIRCULAR_SHIFT_8(pp[4], t2)) + 101;
+        t2 = pp[4] & 0x7;
+        pp[5] = (((v[5] ^ v[6]) | (r[1] + r[2])) ^ DCIRCULAR_SHIFT_8(pp[5], t2)) + 157;
+        t2 = pp[5] & 0x7;
+        pp[6] = (((v[6] + v[7]) | (r[2] ^ r[3])) + DCIRCULAR_SHIFT_8(pp[6], t2)) + 31;
+        t2 = pp[6] & 0x7;
+        pp[7] = (((v[7] | v[0]) + (r[3] & r[4])) ^ DCIRCULAR_SHIFT_8(pp[7], t2)) + 237;
+        t2 = pp[7] & 0x7;
+
+        v[0] = (v[1] ^ r[6]) + 197 + i + pp[7];
+        r[0] = (v[6] & r[1]) + 149 + i + pp[6];
+        v[1] = ((v[2] | r[5]) ^ 109) + i + pp[5];
+        r[1] = ((v[5] + r[2]) & 83) + i + pp[4];
+
+        v[2] = (v[3] ^ r[0]) + 179 + i + pp[3];
+        r[2] = (v[0] & r[3]) + 67 + i + pp[2];
+        v[3] = ((v[4] | r[7]) ^ 71) + i + pp[1];
+        r[3] = ((v[7] + r[4]) & 37) + i + pp[0];
+
+        v[4] = (v[2] ^ r[6]) + 59 + i + pp[7];
+        r[4] = (v[6] & r[2]) + 131 + i + pp[5];
+        v[5] = ((v[1] | r[7]) ^ 71) + i + pp[3];
+        r[5] = ((v[7] + r[1]) & 29) + i + pp[1];
+
+        v[6] = (v[5] ^ r[3]) + 119 + i + pp[0];
+        r[6] = (v[3] & r[5]) + 151 + i + pp[2];
+        v[7] = ((v[4] | r[2]) ^ 61) + i + pp[4];
+        r[7] = ((v[2] + r[4]) & 91) + i + pp[6];
+
+        len -= 8;
+        pp += 8;
+        i ++;
+    }
+
+    i = 0;
+    for (i = 0; i < len; i ++) {
+        pp[i] = pp[i] ^ (((v[i] + r[(8 - i) & 0x7]) & (v[(8 - i) & 0x7] | r[i])) + 97);
+    }
+
+    return;
+}
+
+static int __write_binary_file(const char *filename, unsigned char *pdata, int len)
+{
+    FILE* file = fopen(filename, "wb");
+    if (file) {
+        fwrite(pdata, 1, len, file);
+        fclose(file);
+        file = NULL;
+    } else {
+        u_printf_error("write file (%s) fail\n", filename);
+        return (-1);
+    }
+
+    return 0;
+}
+
+static int __read_binary_file(const char *filename, unsigned char *pdata, int *len)
+{
+    FILE* file = fopen(filename, "rb");
+    if (file) {
+        int file_len = 0;
+
+        fseek(file, 0L, SEEK_END);
+        file_len = ftell(file);
+        fseek(file, 0L, SEEK_SET);
+
+        if (file_len < (*len)) {
+            *len = file_len;
+            u_printf("[warning]: file too short\n");
+        } else if (file_len > (*len)) {
+            u_printf("[warning]: file too long\n");
+        }
+
+        fread(pdata, 1, *len, file);
+        fclose(file);
+        file = NULL;
+    } else {
+        u_printf_error("read file (%s) fail\n", filename);
+        return (-1);
+    }
+
+    return 0;
+}
+
+static void __show_slot_config(unsigned char slot, unsigned char config1, unsigned char config2)
+{
+    u_printf("\tslot %d: config 1 %02x, config 2 %02x, read key slot %d, write key slot %d\n", slot, config1, config2, (config1 & DCC_SLOT_CONFIG1_READ_SLOT_MASK), (config2 & DCC_SLOT_CONFIG2_WRITE_SLOT_MASK));
+
+    if (config1 & DCC_SLOT_CONFIG1_CHECK_ONLY_BIT) {
+        u_printf("\t\tcheck only = 1\n");
+    } else {
+        u_printf("\t\tcheck only = 0\n");
+    }
+
+    if (config1 & DCC_SLOT_CONFIG1_SINGLE_USE_BIT) {
+        u_printf("\t\tsingle use = 1\n");
+    } else {
+        u_printf("\t\tsingle use = 0\n");
+    }
+
+    if (config1 & DCC_SLOT_CONFIG1_ENCRYPT_READ_BIT) {
+        u_printf("\t\tencrypt read = 1\n");
+    } else {
+        u_printf("\t\tencrypt read = 0\n");
+    }
+
+    if (config1 & DCC_SLOT_CONFIG1_IS_SECRET_BIT) {
+        u_printf("\t\tis secret = 1\n");
+    } else {
+        u_printf("\t\tis secret = 0\n");
+    }
+
+    if (config2 & DCC_SLOT_CONFIG2_ENCRYPT_WRITE_BIT) {
+        u_printf("\t\tencrypt write = 1\n");
+    } else if ((config2 & 0xc0) == DCC_SLOT_CONFIG2_NON_WRITE_FLAG) {
+        u_printf("\t\tnot writable = 1\n");
+    } else {
+        u_printf("\t\tplaintext write = 1\n");
+    }
+
+}
+
+static void __show_config_zone_configs(unsigned char* pp)
+{
+    unsigned char* p = pp + 16;
+    unsigned char i;
+
+    if (0x55 == pp[87]) {
+        u_printf("config zone is not locked\n");
+    } else {
+        u_printf("config zone is locked\n");
+    }
+
+    if (0x55 == pp[86]) {
+        u_printf("otp/data zone is not locked\n");
+    } else {
+        u_printf("otp/data zone is locked\n");
+    }
+
+    u_printf("i2c addr %02x, check mac source %02x, otp mode %02x, selector mode %02x\n", p[0], p[1], p[2], p[3]);
+
+    p += 4;
+    for (i = 0; i < 16; i ++) {
+        __show_slot_config(i, p[2 * i], p[2 * i + 1]);
+    }
+}
+
+int main(int argc, char** argv)
+{
+    int ret = 0;
+    test_cryptochip_context context;
+    sf_cryptochip_interface chip_interface;
+    unsigned int b_config_zone_locked = 0, b_otp_data_zone_locked = 0;
+
+    if (2 > argc) {
+        __print_ut_options();
+        return 0;
+    }
+
+    memset(&context, 0x0, sizeof(context));
+    chip_interface.f_create_handle = NULL;
+    chip_interface.f_destroy_handle = NULL;
+
+    ret = __init_test_cryptochip_params(argc, argv, &context);
+    if (ret) {
+        if (0 > ret) {
+            u_printf_error("__init_test_cryptochip_params fail\n");
+            goto __fail_exit;
+        }
+    }
+
+    ret = get_cryptochip_library_interface(&chip_interface, ECRYPTOCHIP_TYPE_ATMEL_ATSHA204);
+    if (ret) {
+        if (0 > ret) {
+            u_printf_error("get_cryptochip_library_interface fail, ret %d\n", ret);
+            goto __fail_exit;
+        }
+    }
+
+    if (chip_interface.f_create_handle) {
+        context.p_chip = chip_interface.f_create_handle();
+        if (!context.p_chip) {
+            u_printf_error("f_create_handle() fail\n");
+            ret = (-10);
+            goto __fail_exit;
+        }
+    } else {
+        u_printf_error("NULL f_create_handle()\n");
+        ret = (-11);
+        goto __fail_exit;
+    }
+
+    if (context.b_show_serial_number) {
+        if (chip_interface.f_query_serial_number) {
+            unsigned int serial_number_len = 0;
+            unsigned char * p_serial_number = chip_interface.f_query_serial_number(context.p_chip, &serial_number_len);
+            if (p_serial_number && serial_number_len) {
+                u_printf("show serial number, len %d\n", serial_number_len);
+                __print_memory_hex(p_serial_number, 9);
+            } else {
+                u_printf_error("f_query_serial_number() fail\n");
+                ret = (-10);
+                goto __fail_exit;
+            }
+        } else {
+            u_printf_error("NULL f_query_serial_number()\n");
+            ret = (-11);
+            goto __fail_exit;
+        }
+    }
+
+    if (chip_interface.f_query_chip_status) {
+        ret = chip_interface.f_query_chip_status(context.p_chip, &b_config_zone_locked, &b_otp_data_zone_locked);
+        if (ret) {
+            u_printf_error("f_query_chip_status() fail, ret %d\n", ret);
+            goto __fail_exit;
+        }
+
+        if (!b_config_zone_locked) {
+            u_printf("warning: chip's config zone is not initialized(locked), you should initialize config zone first\n");
+        }
+
+        if (!b_otp_data_zone_locked) {
+            u_printf("warning: chip's otp and data zone is not initialized(locked), you should initialize otp and data zone first\n");
+        }
+    } else {
+        u_printf_error("NULL f_query_chip_status()\n");
+        ret = (-11);
+        goto __fail_exit;
+    }
+
+    if (context.b_initialize_config_zone) {
+        if (chip_interface.f_initialize_config_zone) {
+            ret = chip_interface.f_initialize_config_zone(context.p_chip);
+            if (!ret) {
+                u_printf("initialize (write and lock) config zone done\n");
+            } else {
+                u_printf_error("initialize (write and lock) config zone fail, ret %d\n", ret);
+                goto __fail_exit;
+            }
+        } else {
+            u_printf_error("NULL f_initialize_config_zone()\n");
+            ret = (-11);
+            goto __fail_exit;
+        }
+    }
+
+    if (context.b_initialize_otp_and_data_zone) {
+        if (chip_interface.f_initialize_otp_data_zone) {
+            ret = chip_interface.f_initialize_otp_data_zone(context.p_chip);
+            if (!ret) {
+                u_printf("initialize (write and lock) otp and data zone done\n");
+            } else {
+                u_printf_error("initialize (write and lock) otp and data zone fail, ret %d\n", ret);
+                goto __fail_exit;
+            }
+        } else {
+            u_printf_error("NULL f_initialize_otp_data_zone()\n");
+            ret = (-11);
+            goto __fail_exit;
+        }
+    }
+
+    if (context.b_show_config) {
+        if (chip_interface.f_query_config_zone) {
+            unsigned char config_zone[88] = {0};
+            unsigned int config_zone_len = 0;
+            ret = chip_interface.f_query_config_zone(context.p_chip, config_zone, &config_zone_len);
+            if (!ret) {
+                u_printf("show config zone\n");
+                __print_memory_8align_hex(config_zone, 88);
+                __show_config_zone_configs(config_zone);
+            } else {
+                u_printf_error("f_query_config_zone() fail, %d\n", ret);
+                goto __fail_exit;
+            }
+        } else {
+            u_printf_error("NULL f_query_config_zone()\n");
+            ret = (-11);
+            goto __fail_exit;
+        }
+    }
+
+    if (context.b_show_otp) {
+        if (chip_interface.f_query_otp_zone) {
+            unsigned char otp_zone[64] = {0};
+            ret = chip_interface.f_query_otp_zone(context.p_chip, otp_zone, 64);
+            if (!ret) {
+                u_printf("show otp zone, hex:\n");
+                __print_memory_8align_hex(otp_zone, 64);
+                u_printf("show otp zone, textable:\n");
+                __print_textable((const char *)otp_zone, 64);
+            } else {
+                u_printf_error("f_query_otp_zone() fail, %d\n", ret);
+                goto __fail_exit;
+            }
+        } else {
+            u_printf_error("NULL f_query_otp_zone()\n");
+            ret = (-11);
+            goto __fail_exit;
+        }
+    }
+
+    if (context.b_test_en_write) {
+        if (chip_interface.f_encrypt_write) {
+            unsigned char ran_data[32];
+            struct timeval tv;
+
+            gettimeofday(&tv, NULL);
+            memcpy(ran_data, &tv, sizeof(tv));
+            __scamble_sequence(ran_data, 32);
+            u_printf("encrypt write data to slot %d\n", context.test_en_write_slot);
+            __print_memory_8align_hex(ran_data, 32);
+
+            ret = chip_interface.f_encrypt_write(context.p_chip, ran_data, context.test_en_write_slot);
+            if (!ret) {
+                u_printf("encrypt write done\n");
+            } else {
+                u_printf_error("f_encrypt_write() fail, ret %d\n", ret);
+                goto __fail_exit;
+            }
+        } else {
+            u_printf_error("NULL f_encrypt_write()\n");
+            ret = (-11);
+            goto __fail_exit;
+        }
+    }
+
+    if (context.b_test_en_read) {
+        if (chip_interface.f_encrypt_read) {
+            unsigned char read_data[32] = {0};
+            ret = chip_interface.f_encrypt_read(context.p_chip, read_data, context.test_en_read_slot);
+            if (!ret) {
+		u_printf("encrypt read data from slot %d\n", context.test_en_read_slot);
+		__print_memory_8align_hex(read_data, 32);
+            } else {
+                u_printf_error("f_encrypt_read() fail, ret %d\n", ret);
+                goto __fail_exit;
+            }
+        } else {
+            u_printf_error("NULL f_encrypt_read()\n");
+            ret = (-11);
+            goto __fail_exit;
+        }
+    }
+
+    if (context.test_generate_hwsignature) {
+        if (chip_interface.f_gen_hwsign) {
+            unsigned char fake_digest[32];
+            struct timeval tv;
+
+            gettimeofday(&tv, NULL);
+            memcpy(fake_digest, &tv, sizeof(tv));
+            __scamble_sequence(fake_digest, 32);
+            u_printf("generate fake digest\n");
+            __print_memory_8align_hex(fake_digest, 32);
+
+            ret = __write_binary_file("fake_digest", fake_digest, 32);
+            if (ret) {
+                u_printf_error("write binary file fail\n");
+                goto __fail_exit;
+            }
+
+            ret = chip_interface.f_gen_hwsign(context.p_chip, fake_digest, context.genhwsign_storage_slot);
+            if (!ret) {
+                u_printf("generate hw signature done\n");
+            } else {
+                u_printf_error("generate hw signature fail, ret %d\n", ret);
+                goto __fail_exit;
+            }
+
+        } else {
+            u_printf_error("NULL f_gen_hwsign()\n");
+            ret = (-11);
+            goto __fail_exit;
+        }
+    }
+
+    if (context.test_verify_hwsignature) {
+        if (chip_interface.f_verify_hwsign) {
+            unsigned char fake_digest[32];
+            int len = 32;
+
+            ret = __read_binary_file("fake_digest", fake_digest, &len);
+            if (ret) {
+                u_printf_error("read binary file fail\n");
+                goto __fail_exit;
+            }
+
+            ret = chip_interface.f_verify_hwsign(context.p_chip, fake_digest, context.verifyhwsign_storage_slot);
+            if (!ret) {
+                u_printf("verify hw signature done\n");
+            } else {
+                u_printf_error("verify hw signature fail, ret %d\n", ret);
+                goto __fail_exit;
+            }
+
+        } else {
+            u_printf_error("NULL f_verify_hwsign()\n");
+            ret = (-11);
+            goto __fail_exit;
+        }
+    }
+
+__fail_exit:
+    if (context.p_chip && chip_interface.f_destroy_handle) {
+        chip_interface.f_destroy_handle(context.p_chip);
+        context.p_chip = NULL;
+    }
+
+    return ret;
+}
+
