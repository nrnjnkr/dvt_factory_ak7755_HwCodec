diff --git a/AmbaConfig b/AmbaConfig
index 4d552f8..9c04888 100644
--- a/AmbaConfig
+++ b/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2010/02/04 - [Jian Tang] Create
 ##
-## Copyright (C) 2004-2010, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 menuconfig BUILD_AMBARELLA_APP_IPCAM
@@ -49,11 +66,10 @@ source app/ipcam/rtsp/AmbaConfig
 source app/ipcam/autorun_services/AmbaConfig
 source app/ipcam/smart_ldc/AmbaConfig
 source app/ipcam/http_uploader/AmbaConfig
+source app/ipcam/wowl/AmbaConfig
 source app/ipcam/fastboot_audio/AmbaConfig
 source app/ipcam/fastboot_smart3a/AmbaConfig
 source app/ipcam/fastboot_app/AmbaConfig
-source app/ipcam/fastboot_app/elektra_boot/AmbaConfig
-source app/ipcam/fastboot_app/darwin_injector/AmbaConfig
 
 endif
 
diff --git a/Windows/Filters/A5s_IpCamDemo/amba_guid.h b/Windows/Filters/A5s_IpCamDemo/amba_guid.h
index fb1006a..2bd7af3 100644
--- a/Windows/Filters/A5s_IpCamDemo/amba_guid.h
+++ b/Windows/Filters/A5s_IpCamDemo/amba_guid.h
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 
 
 // {66653EC4-B32D-40f9-98CB-A0BD85FF92DE}
diff --git a/Windows/Filters/A5s_IpCamDemo/amba_ifs.h b/Windows/Filters/A5s_IpCamDemo/amba_ifs.h
index 03949da..8c54294 100644
--- a/Windows/Filters/A5s_IpCamDemo/amba_ifs.h
+++ b/Windows/Filters/A5s_IpCamDemo/amba_ifs.h
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 
 #ifndef __AMBA_IFS_H__
 #define __AMBA_IFS_H__
diff --git a/Windows/Filters/A5s_IpCamDemo/ambas_common.h b/Windows/Filters/A5s_IpCamDemo/ambas_common.h
index 68941ba..8c3ce21 100644
--- a/Windows/Filters/A5s_IpCamDemo/ambas_common.h
+++ b/Windows/Filters/A5s_IpCamDemo/ambas_common.h
@@ -4,14 +4,34 @@
  * History:
  *    2008/10/23 - [Anthony Ginger] Create
  *
- * Copyright (C) 2004-2008, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
  */
 
+
 #ifndef __AMBAS_COMMON_H
 #define __AMBAS_COMMON_H
 
diff --git a/Windows/Filters/A5s_IpCamDemo/demo_page.cpp b/Windows/Filters/A5s_IpCamDemo/demo_page.cpp
index 64df717..8a017ce 100644
--- a/Windows/Filters/A5s_IpCamDemo/demo_page.cpp
+++ b/Windows/Filters/A5s_IpCamDemo/demo_page.cpp
@@ -1,9 +1,30 @@
-
-//------------------------------------------------------------------------------
-// File: demo_page.cpp
-//
-// Copyright (c) Ambarella Corporation.  All rights reserved.
-//------------------------------------------------------------------------------
+/*
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include "ambas_common.h"
 
diff --git a/Windows/Filters/A5s_IpCamDemo/demo_page.h b/Windows/Filters/A5s_IpCamDemo/demo_page.h
index 8dcffdb..c2d0ddf 100644
--- a/Windows/Filters/A5s_IpCamDemo/demo_page.h
+++ b/Windows/Filters/A5s_IpCamDemo/demo_page.h
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 
 #ifndef __AMBA_PAGE_H__
 #define __AMBA_PAGE_H__
diff --git a/Windows/Filters/A5s_IpCamDemo/fambademo.cpp b/Windows/Filters/A5s_IpCamDemo/fambademo.cpp
index 427d31d..9920526 100644
--- a/Windows/Filters/A5s_IpCamDemo/fambademo.cpp
+++ b/Windows/Filters/A5s_IpCamDemo/fambademo.cpp
@@ -1,9 +1,33 @@
-//------------------------------------------------------------------------------
-// File: fambademo.cpp
-//
-// Copyright (c) Ambarella Corporation.  All rights reserved.
-//------------------------------------------------------------------------------
-
+ /*
+ * File: fambademo.cpp
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include <winsock2.h>
 
diff --git a/Windows/Filters/A5s_IpCamDemo/fambademo.h b/Windows/Filters/A5s_IpCamDemo/fambademo.h
index 37ec03c..68f16d7 100644
--- a/Windows/Filters/A5s_IpCamDemo/fambademo.h
+++ b/Windows/Filters/A5s_IpCamDemo/fambademo.h
@@ -1,17 +1,31 @@
-//------------------------------------------------------------------------------
-// File: fambademo.h
-//
-// Desc: DirectShow sample code - main header file for the amba-demo
-//	   source filter.  For more information refer to ambademo.cpp
-//
-// Copyright (c) Ambarella Corporation.  All rights reserved.
-//------------------------------------------------------------------------------
-
+/*
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include "amba_ifs.h"
-
-//------------------------------------------------------------------------------
-// Forward Declarations
-//------------------------------------------------------------------------------
 class CAmbaDemo;
 class CAmbaStream;
 
diff --git a/Windows/Filters/A5s_IpCamDemo/iso_muxer.cpp b/Windows/Filters/A5s_IpCamDemo/iso_muxer.cpp
index 4816a75..64b26a0 100644
--- a/Windows/Filters/A5s_IpCamDemo/iso_muxer.cpp
+++ b/Windows/Filters/A5s_IpCamDemo/iso_muxer.cpp
@@ -2,14 +2,34 @@
  * iso_muxer.cpp
  *
  *
- * Copyright (C) 2007-2009, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
  */
 
+
 #include <streams.h>
 #include <Ks.h>
 #include <KsMedia.h>
diff --git a/Windows/Filters/A5s_IpCamDemo/iso_muxer.h b/Windows/Filters/A5s_IpCamDemo/iso_muxer.h
index 03c98c5..99565d9 100644
--- a/Windows/Filters/A5s_IpCamDemo/iso_muxer.h
+++ b/Windows/Filters/A5s_IpCamDemo/iso_muxer.h
@@ -3,13 +3,33 @@
  *
 
  *
- * Copyright (C) 2007-2009, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
  */
+
 #ifndef __ISO_MUXER_H__
 #define __ISO_MUXER_H__
 
diff --git a/Windows/Filters/A5s_IpCamDemo/resource.h b/Windows/Filters/A5s_IpCamDemo/resource.h
index a636a3e..1876e64 100644
--- a/Windows/Filters/A5s_IpCamDemo/resource.h
+++ b/Windows/Filters/A5s_IpCamDemo/resource.h
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 //{{NO_DEPENDENCIES}}
 // Microsoft Visual C++ generated include file.
 // Used by demo_res.rc
diff --git a/Windows/Filters/ReceiveFilter/ReceiveFilter.cpp b/Windows/Filters/ReceiveFilter/ReceiveFilter.cpp
index b7e2c4b..d79a6e6 100644
--- a/Windows/Filters/ReceiveFilter/ReceiveFilter.cpp
+++ b/Windows/Filters/ReceiveFilter/ReceiveFilter.cpp
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 // ReceiveFilter.cpp : Defines the entry point for the application.
 //
 
diff --git a/Windows/Filters/ReceiveFilter/ReceiveFilter.h b/Windows/Filters/ReceiveFilter/ReceiveFilter.h
index 28e26e3..e38eccc 100644
--- a/Windows/Filters/ReceiveFilter/ReceiveFilter.h
+++ b/Windows/Filters/ReceiveFilter/ReceiveFilter.h
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #ifndef __RECEIVEFILTER_H__
 #define __RECEIVEFILTER_H__
 
diff --git a/Windows/Filters/ReceiveFilter/ReceiveType.h b/Windows/Filters/ReceiveFilter/ReceiveType.h
index 68e4294..68ede1a 100644
--- a/Windows/Filters/ReceiveFilter/ReceiveType.h
+++ b/Windows/Filters/ReceiveFilter/ReceiveType.h
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #ifndef __RECEIVETYPE_H__
 #define __RECEIVETYPE_H__
 
diff --git a/Windows/Filters/ReceiveFilter/ambaReceive_uids.h b/Windows/Filters/ReceiveFilter/ambaReceive_uids.h
index 2664620..deaa2c4 100644
--- a/Windows/Filters/ReceiveFilter/ambaReceive_uids.h
+++ b/Windows/Filters/ReceiveFilter/ambaReceive_uids.h
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 
 // {75437AFA-6A06-4237-9FEB-7746A8624F0A}
 DEFINE_GUID(CLSID_AMBARECEIVE_DEMO, 
diff --git a/Windows/Filters/ReceiveFilter/mp4muxer.cpp b/Windows/Filters/ReceiveFilter/mp4muxer.cpp
index a81d602..92a3768 100644
--- a/Windows/Filters/ReceiveFilter/mp4muxer.cpp
+++ b/Windows/Filters/ReceiveFilter/mp4muxer.cpp
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include <fcntl.h>	 //for open O_* flags
 #include <stdlib.h>	//for malloc/free
 #include <string.h>	//for strlen/memset
diff --git a/Windows/Filters/ReceiveFilter/mp4muxer.h b/Windows/Filters/ReceiveFilter/mp4muxer.h
index a165eb8..0839fed 100644
--- a/Windows/Filters/ReceiveFilter/mp4muxer.h
+++ b/Windows/Filters/ReceiveFilter/mp4muxer.h
@@ -1,11 +1,31 @@
 /*
- * Copyright (C) 2007-2010, Ambarella, Inc.
- *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
- */
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #ifndef __MP4MUXER_H__
 #define __MP4MUXER_H__
 
diff --git a/Windows/Filters/ReceiveFilter/resource.h b/Windows/Filters/ReceiveFilter/resource.h
index bdda4ce..af89cea 100644
--- a/Windows/Filters/ReceiveFilter/resource.h
+++ b/Windows/Filters/ReceiveFilter/resource.h
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 //{{NO_DEPENDENCIES}}
 // Microsoft Visual C++ generated include file.
 // Used by ReceiveFilter.rc
diff --git a/Windows/Filters/rtspClient/AmbaRtspClient_uids.h b/Windows/Filters/rtspClient/AmbaRtspClient_uids.h
index dd093ea..53f2169 100644
--- a/Windows/Filters/rtspClient/AmbaRtspClient_uids.h
+++ b/Windows/Filters/rtspClient/AmbaRtspClient_uids.h
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 
 // {75437AFA-6A06-4237-9FEB-7746A8624F0A}
 DEFINE_GUID(CLSID_AMBARTSPCLIENT, 
diff --git a/Windows/Filters/rtspClient/AmbaRtspRecv.cpp b/Windows/Filters/rtspClient/AmbaRtspRecv.cpp
index e823c2a..e87f326 100644
--- a/Windows/Filters/rtspClient/AmbaRtspRecv.cpp
+++ b/Windows/Filters/rtspClient/AmbaRtspRecv.cpp
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include "AmbaVideoSink.h"
 #include "AmbaRtspRecv.h"
 #include "assert.h"
diff --git a/Windows/Filters/rtspClient/AmbaRtspRecv.h b/Windows/Filters/rtspClient/AmbaRtspRecv.h
index 6e0b1db..909fa1b 100644
--- a/Windows/Filters/rtspClient/AmbaRtspRecv.h
+++ b/Windows/Filters/rtspClient/AmbaRtspRecv.h
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #ifndef __AMBA_RTSP_PLAY_H__
 #define __AMBA_RTSP_PLAY_H__
 
diff --git a/Windows/Filters/rtspClient/RtspClientFilter.cpp b/Windows/Filters/rtspClient/RtspClientFilter.cpp
index ad1ad01..a513c4d 100644
--- a/Windows/Filters/rtspClient/RtspClientFilter.cpp
+++ b/Windows/Filters/rtspClient/RtspClientFilter.cpp
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include "AmbaRtspRecv.h"
 
 #include <streams.h>
diff --git a/Windows/Filters/rtspClient/RtspClientFilter.h b/Windows/Filters/rtspClient/RtspClientFilter.h
index ddacf3d..42b47b7 100644
--- a/Windows/Filters/rtspClient/RtspClientFilter.h
+++ b/Windows/Filters/rtspClient/RtspClientFilter.h
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #ifndef __RTSPCLIENT_FILTER_H__
 #define __RTSPCLIENT_FILTER_H__
 
diff --git a/Windows/Filters/rtspClient/mp4muxer.cpp b/Windows/Filters/rtspClient/mp4muxer.cpp
index bfbc2ea..4516915 100644
--- a/Windows/Filters/rtspClient/mp4muxer.cpp
+++ b/Windows/Filters/rtspClient/mp4muxer.cpp
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include <fcntl.h>	 //for open O_* flags
 #include <stdlib.h>	//for malloc/free
 #include <string.h>	//for strlen/memset
diff --git a/Windows/Filters/rtspClient/mp4muxer.h b/Windows/Filters/rtspClient/mp4muxer.h
index 4cd7e50..f76269c 100644
--- a/Windows/Filters/rtspClient/mp4muxer.h
+++ b/Windows/Filters/rtspClient/mp4muxer.h
@@ -1,11 +1,31 @@
 /*
- * Copyright (C) 2007-2010, Ambarella, Inc.
- *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
- */
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #ifndef __MP4MUXER_H__
 #define __MP4MUXER_H__
 
diff --git a/Windows/Filters/rtspClient/resource.h b/Windows/Filters/rtspClient/resource.h
index 0caf064..05c47e9 100644
--- a/Windows/Filters/rtspClient/resource.h
+++ b/Windows/Filters/rtspClient/resource.h
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 //{{NO_DEPENDENCIES}}
 // Microsoft Visual C++ generated include file.
 // Used by rtspClientFilter.rc
diff --git a/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaCamGraphMngr.cpp b/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaCamGraphMngr.cpp
index 308136d..3158c15 100644
--- a/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaCamGraphMngr.cpp
+++ b/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaCamGraphMngr.cpp
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include "StdAfx.h"
 
 #include "uuids.h"
diff --git a/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaCamGraphMngr.h b/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaCamGraphMngr.h
index 6058615..4a9399f 100644
--- a/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaCamGraphMngr.h
+++ b/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaCamGraphMngr.h
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #pragma once
 #include "AmbaInterface.h"
 #include "AmbaComm.h"
diff --git a/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugIn.cpp b/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugIn.cpp
index 3b0b5d0..d7b9432 100644
--- a/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugIn.cpp
+++ b/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugIn.cpp
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 // AmbaIPCmrWebPlugIn.cpp : Implementation of CAmbaIPCmrWebPlugInApp and DLL registration.
 
 #include "stdafx.h"
diff --git a/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugIn.h b/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugIn.h
index ff0386b..5455fdb 100644
--- a/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugIn.h
+++ b/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugIn.h
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #pragma once
 
 // AmbaIPCmrWebPlugIn.h : main header file for AmbaIPCmrWebPlugIn.DLL
diff --git a/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugInCtrl.cpp b/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugInCtrl.cpp
index 7047c7b..cb01ef2 100644
--- a/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugInCtrl.cpp
+++ b/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugInCtrl.cpp
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 // AmbaIPCmrWebPlugInCtrl.cpp : Implementation of the CAmbaIPCmrWebPlugInCtrl ActiveX Control class.
 
 
diff --git a/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugInCtrl.h b/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugInCtrl.h
index 3adffd1..6cd0497 100644
--- a/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugInCtrl.h
+++ b/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugInCtrl.h
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #pragma once
 #include "afxwin.h"
 #include <winsock2.h>
diff --git a/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugInPropPage.cpp b/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugInPropPage.cpp
index 22e4d90..f2f7f37 100644
--- a/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugInPropPage.cpp
+++ b/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugInPropPage.cpp
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 // AmbaIPCmrWebPlugInPropPage.cpp : Implementation of the CAmbaIPCmrWebPlugInPropPage property page class.
 
 #include "stdafx.h"
diff --git a/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugInPropPage.h b/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugInPropPage.h
index a76602f..8c90371 100644
--- a/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugInPropPage.h
+++ b/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugInPropPage.h
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #pragma once
 
 // AmbaIPCmrWebPlugInPropPage.h : Declaration of the CAmbaIPCmrWebPlugInPropPage property page class.
diff --git a/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugIn_i.c b/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugIn_i.c
index 7af579f..e0ff56d 100644
--- a/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugIn_i.c
+++ b/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugIn_i.c
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 
 
 /* this ALWAYS GENERATED file contains the IIDs and CLSIDs */
diff --git a/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugInidl.h b/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugInidl.h
index b230e24..47857f6 100644
--- a/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugInidl.h
+++ b/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/AmbaIPCmrWebPlugInidl.h
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 
 
 /* this ALWAYS GENERATED file contains the definitions for the interfaces */
diff --git a/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/resource.h b/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/resource.h
index a5a917e..56ff87b 100644
--- a/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/resource.h
+++ b/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/resource.h
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 //{{NO_DEPENDENCIES}}
 // Microsoft Visual C++ generated include file.
 // Used by AmbaIPCmrWebPlugIn.rc
diff --git a/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/stdafx.cpp b/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/stdafx.cpp
index 3febc43..730af19 100644
--- a/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/stdafx.cpp
+++ b/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/stdafx.cpp
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 // stdafx.cpp : source file that includes just the standard includes
 //  AmbaIPCmrWebPlugIn.pch will be the pre-compiled header
 //  stdafx.obj will contain the pre-compiled type information
diff --git a/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/stdafx.h b/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/stdafx.h
index 80f8fbd..b2397b0 100644
--- a/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/stdafx.h
+++ b/Windows/apps/activeXcontrol/AmbaIPCmrWebPlugIn/stdafx.h
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 // stdafx.h : include file for standard system include files,
 // or project specific include files that are used frequently,
 // but are changed infrequently
diff --git a/Windows/binary/setup.cpp b/Windows/binary/setup.cpp
index f7e461e..cb67a3d 100644
--- a/Windows/binary/setup.cpp
+++ b/Windows/binary/setup.cpp
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include <process.h>
 #include <stdio.h>
 
diff --git a/Windows/include/AmbaComm.h b/Windows/include/AmbaComm.h
index 95dcc15..66ea433 100644
--- a/Windows/include/AmbaComm.h
+++ b/Windows/include/AmbaComm.h
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #ifndef __AMBA_COMM_H_
 #define __AMBA_COMM_H_
 
diff --git a/Windows/include/AmbaInterface.h b/Windows/include/AmbaInterface.h
index a2741d6..74a9f3b 100644
--- a/Windows/include/AmbaInterface.h
+++ b/Windows/include/AmbaInterface.h
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #ifndef __AMBA_INTERFACE_H_
 #define __AMBA_INTERFACE_H_
 
diff --git a/autorun_services/AmbaConfig b/autorun_services/AmbaConfig
index 260d5a5..7873a89 100644
--- a/autorun_services/AmbaConfig
+++ b/autorun_services/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2010/02/04 - [Jian Tang] Create
 ##    2014/12/12 - [Alex ZHU] Modifed
-## Copyright (C) 2004-2008, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 menuconfig BUILD_AMBARELLA_APP_IPCAM_AUTORUN_SERVICES
diff --git a/autorun_services/autorun_ambacloud_agent.sh b/autorun_services/autorun_ambacloud_agent.sh
index 9faf2f7..1f46399 100644
--- a/autorun_services/autorun_ambacloud_agent.sh
+++ b/autorun_services/autorun_ambacloud_agent.sh
@@ -1,4 +1,32 @@
 #!/bin/sh
+## History:
+##
+## 2016/12/30 - [JianTang] Created file
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
 echo "Start uploading to amba cloud" > /dev/ttyS0
 /usr/bin/apps_launcher &
 /usr/local/bin/amba_cloud_agent --disableaudio --enableencryption --stream 0
diff --git a/autorun_services/autorun_example.sh b/autorun_services/autorun_example.sh
index 89783cd..d65c02d 100644
--- a/autorun_services/autorun_example.sh
+++ b/autorun_services/autorun_example.sh
@@ -1,8 +1,36 @@
 #!/bin/sh
+## History:
+##
+## 2016/12/30 - [JianTang] Created file
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
 export PATH="$PATH:/bin:/sbin"
 demoFile="/usr/local/bin/demo.sh"
 sleep 1
 echo "This is an example of systemd autorun." > /dev/ttyS0
 if [ -f "$demoFile" ]; then
 /usr/local/bin/demo.sh
-fi
\ No newline at end of file
+fi
diff --git a/autorun_services/make.inc b/autorun_services/make.inc
index f57e820..04e2600 100644
--- a/autorun_services/make.inc
+++ b/autorun_services/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/12/12 - [Alex ZHU] Create
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_APP_IPCAM_AUTORUN_SERVICES), y)
diff --git a/controlserver/Daemonize.cpp b/controlserver/Daemonize.cpp
index cba57e3..9ae4845 100644
--- a/controlserver/Daemonize.cpp
+++ b/controlserver/Daemonize.cpp
@@ -4,14 +4,33 @@
  * History:
  *  20110322 - [Yupeng Chang] created file
  *
- * Copyright (C) 2008-2011, Ambarella ShangHai Co,Ltd
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- ******************************************************************************/
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include "Daemonize.h"
 
 char globalPidFile[256];
diff --git a/controlserver/Daemonize.h b/controlserver/Daemonize.h
index 4f9eb0c..e77be39 100644
--- a/controlserver/Daemonize.h
+++ b/controlserver/Daemonize.h
@@ -4,14 +4,33 @@
  * History:
  *  20110322 - [Yupeng Chang] created file
  *
- * Copyright (C) 2008-2011, Ambarella ShangHai Co,Ltd
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- ******************************************************************************/
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #ifndef DAEMONIZE_H
 #define DAEMONIZE_H
 
diff --git a/controlserver/DataStructure.h b/controlserver/DataStructure.h
index 94fd1c1..6526d99 100644
--- a/controlserver/DataStructure.h
+++ b/controlserver/DataStructure.h
@@ -4,14 +4,33 @@
  * Histroy:
  *  20110322 - [Yupeng Chang] created file
  *
- * Copyright (C) 2008-2011, Ambarella ShangHai Co,Ltd
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- **********************************************************************/
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #ifndef APP_IPCAM_CONTROLSERVER_DATASTRUCTURE_H
 #define APP_IPCAM_CONTROLSERVER_DATASTRUCTURE_H
 #include "NetDataStructure.h"
diff --git a/controlserver/EncodeServerConfig.cpp b/controlserver/EncodeServerConfig.cpp
index c2eeda4..355a1e9 100644
--- a/controlserver/EncodeServerConfig.cpp
+++ b/controlserver/EncodeServerConfig.cpp
@@ -4,14 +4,33 @@
  * History:
  *  20110317 - [Yupeng Chang] created file
  *
- * Copyright (C) 2008-2011, Ambarella ShangHai Co,Ltd
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- ******************************************************************************/
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include "EncodeServerConfig.h"
 #include "VideoDataStructure.h"
 #include <sys/types.h>
diff --git a/controlserver/EncodeServerConfig.h b/controlserver/EncodeServerConfig.h
index a0b2a3d..25797ff 100644
--- a/controlserver/EncodeServerConfig.h
+++ b/controlserver/EncodeServerConfig.h
@@ -4,14 +4,33 @@
  * Histroy:
  *  20110317 - [Yupeng Chang] created file
  *
- * Copyright (C) 2008-2011, Ambarella ShangHai Co,Ltd
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- **********************************************************************/
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #ifndef APP_IPCAM_CONTROLSERVER_ENCODESERVERCONFIG_H
 #define APP_IPCAM_CONTROLSERVER_ENCODESERVERCONFIG_H
 
diff --git a/controlserver/IPCamControlServer.cpp b/controlserver/IPCamControlServer.cpp
index f40642c..6d10542 100644
--- a/controlserver/IPCamControlServer.cpp
+++ b/controlserver/IPCamControlServer.cpp
@@ -4,14 +4,33 @@
  * History:
  *  20110317 - [Yupeng Chang] created file
  *
- * Copyright (C) 2008-2011, Ambarella ShangHai Co,Ltd
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- ******************************************************************************/
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
diff --git a/controlserver/IPCamControlServer.h b/controlserver/IPCamControlServer.h
index e57ff0d..7405370 100644
--- a/controlserver/IPCamControlServer.h
+++ b/controlserver/IPCamControlServer.h
@@ -4,14 +4,33 @@
  * Histroy:
  *  20110317 - [Yupeng Chang] created file
  *
- * Copyright (C) 2008-2011, Ambarella ShangHai Co,Ltd
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- **********************************************************************/
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #ifndef IPCAM_CTRL_SERVER_H
 #define IPCAM_CTRL_SERVER_H
 
diff --git a/controlserver/Main.cpp b/controlserver/Main.cpp
index 334875c..b128ed2 100644
--- a/controlserver/Main.cpp
+++ b/controlserver/Main.cpp
@@ -4,14 +4,33 @@
  * Histroy:
  *  20110317 - [Yupeng Chang] created file
  *
- * Copyright (C) 2008-2011, Ambarella ShangHai Co,Ltd
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- **********************************************************************/
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include "Daemonize.h"
 #include "IPCamControlServer.h"
 #include <pthread.h>
diff --git a/controlserver/NandWrite.cpp b/controlserver/NandWrite.cpp
index d85b7d6..3e6acf1 100644
--- a/controlserver/NandWrite.cpp
+++ b/controlserver/NandWrite.cpp
@@ -4,14 +4,33 @@
  * Histroy:
  *  2011-5-9 2011 - [ypchang] created file
  *
- * Copyright (C) 2008-2011, Ambarella ShangHai Co,Ltd
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- ******************************************************************************/
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 
 #include "NandWrite.h"
 #include <sys/ioctl.h>
diff --git a/controlserver/NandWrite.h b/controlserver/NandWrite.h
index 970f0eb..d83f7e9 100644
--- a/controlserver/NandWrite.h
+++ b/controlserver/NandWrite.h
@@ -4,14 +4,33 @@
  * Histroy:
  *  2011-5-9 2011 - [ypchang] created file
  *
- * Copyright (C) 2008-2011, Ambarella ShangHai Co,Ltd
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- ******************************************************************************/
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #ifndef NANDWRITE_H
 #define NANDWRITE_H
 #include <stdio.h>
diff --git a/controlserver/NetCommand.h b/controlserver/NetCommand.h
index d5f4ce2..4e43954 100644
--- a/controlserver/NetCommand.h
+++ b/controlserver/NetCommand.h
@@ -4,14 +4,33 @@
  * Histroy:
  *  20110322 - [Yupeng Chang] created file
  *
- * Copyright (C) 2008-2011, Ambarella ShangHai Co,Ltd
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- **********************************************************************/
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #ifndef APP_IPCAM_CONTROLSERVER_NETCOMMAND_H
 #define APP_IPCAM_CONTROLSERVER_NETCOMMAND_H
 /* DHCP, STATIC - use UDP multicast
diff --git a/controlserver/NetDataStructure.h b/controlserver/NetDataStructure.h
index 4ee6706..c83d78f 100644
--- a/controlserver/NetDataStructure.h
+++ b/controlserver/NetDataStructure.h
@@ -4,14 +4,33 @@
  * Histroy:
  *  20110317 - [Yupeng Chang] created file
  *
- * Copyright (C) 2008-2011, Ambarella ShangHai Co,Ltd
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- **********************************************************************/
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #ifndef NETWORKDATASTRUCTURE_H
 #define NETWORKDATASTRUCTURE_H
 #include <string.h>
diff --git a/controlserver/NetDevInfoStruct.h b/controlserver/NetDevInfoStruct.h
index 3b370b1..c5cb850 100644
--- a/controlserver/NetDevInfoStruct.h
+++ b/controlserver/NetDevInfoStruct.h
@@ -4,14 +4,33 @@
  * Histroy:
  *  20110317 - [Yupeng Chang] created file
  *
- * Copyright (C) 2008-2011, Ambarella ShangHai Co,Ltd
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- **********************************************************************/
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #ifndef NETDEV_INFO_STRUCT_H
 #define NETDEV_INFO_STRUCT_H
 #include <string.h>
diff --git a/controlserver/SensorModuleInfo.h b/controlserver/SensorModuleInfo.h
index 9046450..04c2fa8 100644
--- a/controlserver/SensorModuleInfo.h
+++ b/controlserver/SensorModuleInfo.h
@@ -4,14 +4,33 @@
  * Histroy:
  *  20110317 - [Yupeng Chang] created file
  *
- * Copyright (C) 2008-2011, Ambarella ShangHai Co,Ltd
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- **********************************************************************/
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #ifndef SENSOR_MODULE_INFO_H
 #define SENSOR_MODULE_INFO_H
 
diff --git a/controlserver/VideoDataStructure.cpp b/controlserver/VideoDataStructure.cpp
index e421f8c..6b4bd89 100644
--- a/controlserver/VideoDataStructure.cpp
+++ b/controlserver/VideoDataStructure.cpp
@@ -4,14 +4,33 @@
  * Histroy:
  *  20110322 - [Yupeng Chang] created file
  *
- * Copyright (C) 2008-2011, Ambarella ShangHai Co,Ltd
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- **********************************************************************/
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include "VideoDataStructure.h"
 #include "basetypes.h"
 #include "iav_drv.h"
diff --git a/controlserver/VideoDataStructure.h b/controlserver/VideoDataStructure.h
index e1b422f..991476c 100644
--- a/controlserver/VideoDataStructure.h
+++ b/controlserver/VideoDataStructure.h
@@ -4,14 +4,33 @@
  * Histroy:
  *  20110322 - [Yupeng Chang] created file
  *
- * Copyright (C) 2008-2011, Ambarella ShangHai Co,Ltd
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- **********************************************************************/
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #ifndef APP_IPCAM_CONTROLSERVER_VIDEODATASTRUCTURE_H
 #define APP_IPCAM_CONTROLSERVER_VIDEODATASTRUCTURE_H
 
diff --git a/fastboot_app/AmbaConfig b/fastboot_app/AmbaConfig
index 7636089..3a17e36 100644
--- a/fastboot_app/AmbaConfig
+++ b/fastboot_app/AmbaConfig
@@ -1,20 +1,61 @@
-##
-## app/ipcam/fastboot_app/AmbaConfig
-##
-## History:
-##    2014/12/22 - [Jian Liu] Create
-##
-## Copyright (C) 2014, Ambarella, Inc.
-##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
-##
+#
+# AmbaConfig
+#
+# History:
+#       2014/12/22 - [Jian Liu] created file
+#
+# Copyright (c) 2014 Ambarella, Inc.
+#
+# This file and its contents ("Software") are protected by intellectual
+# property rights including, without limitation, U.S. and/or foreign
+# copyrights. This Software is also the confidential and proprietary
+# information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+# disclose, distribute, modify, or otherwise prepare derivative works of this
+# Software or any portion thereof except pursuant to a signed license agreement
+# or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+# In the absence of such an agreement, you agree to promptly notify and return
+# this Software to Ambarella, Inc.
+#
+# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+# MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+# IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+#
 
 
-config BUILD_AMBARELLA_APP_FASTBOOT_APP
-  bool "Build App Fastboot App"
-  default n
-  help
-    Build App Fastboot App
\ No newline at end of file
+config BUILD_AMBARELLA_BPI_APP
+	bool "Build BPI App"
+	depends on BUILD_AMBARELLA_APP_IPCAM
+	select CONFIG_AMBARELLA_LIBEV_SUPPORT
+	default n
+	help
+		Build Battery Powered IPCAM(BPI) APP
+
+config CONFIG_BPI_APP_HIBERNATION
+	bool "bpi hibernation app"
+	depends on BUILD_AMBARELLA_BPI_APP
+	default n
+	help
+		Build hibernation bpi app
+
+config BUILD_AMBARELLA_BPI_UNIT_TEST
+	bool "Build BPI Unit Test"
+	depends on BUILD_AMBARELLA_BPI_APP
+	default n
+	help
+		Build Battery Powered IPCAM(BPI) Unit Test
+
+config BUILD_AMBARELLA_BPI_TOOLS
+	bool "Build BPI Tools"
+	default n
+	help
+		Build Battery Powered IPCAM(BPI) Tools
+
diff --git a/fastboot_app/audio_material/make.inc b/fastboot_app/audio_material/make.inc
new file mode 100644
index 0000000..48331c8
--- /dev/null
+++ b/fastboot_app/audio_material/make.inc
@@ -0,0 +1,55 @@
+#
+# make.inc
+#
+# History:
+#       2017/03/17 - [jyi] created file
+#
+# Copyright (c) 2017 Ambarella, Inc.
+#
+# This file and its contents ("Software") are protected by intellectual
+# property rights including, without limitation, U.S. and/or foreign
+# copyrights. This Software is also the confidential and proprietary
+# information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+# disclose, distribute, modify, or otherwise prepare derivative works of this
+# Software or any portion thereof except pursuant to a signed license agreement
+# or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+# In the absence of such an agreement, you agree to promptly notify and return
+# this Software to Ambarella, Inc.
+#
+# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+# MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+# IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+#
+
+
+LOCAL_PATH		:= $(call my-dir)
+include $(CLEAR_VARS)
+IPCAM_APP_LOCAL_BIN_DIR	:= $(FAKEROOT_DIR)/usr/local/bin
+PROMPT_WAV		:= prompt.wav
+LOCAL_MATERIAL	:= $(wildcard $(LOCAL_PATH)/*.wav)
+
+ifeq ($(AMBOOT_AUDIO_48000), y)
+	LOCAL_MATERIAL  += $(LOCAL_PATH)/48k/*.wav
+else ifeq ($(AMBOOT_AUDIO_16000), y)
+	LOCAL_MATERIAL  += $(LOCAL_PATH)/16k/*.wav
+else
+	LOCAL_MATERIAL  += $(LOCAL_PATH)/8k/*.wav
+endif
+
+.PHONY: bpi_audio_material
+
+bpi_audio_material: $(LOCAL_MATERIAL)
+	@mkdir -p $(IPCAM_APP_LOCAL_BIN_DIR)
+	@cp -dpRf $(LOCAL_MATERIAL) $(IPCAM_APP_LOCAL_BIN_DIR)/
+	@echo "Copy BPI audio material Done"
+
+$(call add-target-into-build, bpi_audio_material)
diff --git a/fastboot_app/bpi_app/bpi_app_config.c b/fastboot_app/bpi_app/bpi_app_config.c
new file mode 100644
index 0000000..cb4fd64
--- /dev/null
+++ b/fastboot_app/bpi_app/bpi_app_config.c
@@ -0,0 +1,904 @@
+/*
+ * bpi_app_config.c
+ *
+ * History:
+ *       2015/06/07 - [CZ Lin] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+
+#include "bpi_typedefs.h"
+#include "bpi_app_config.h"
+#include "bpi_utils.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+#include "iniparser.h"
+
+#define _DIFF(config, old_config, item) (config->item != old_config->item)
+
+int load_app_conf(app_conf_t *config){
+    const char* value = NULL;
+    int ret = -1;
+    dictionary* ini_dict = NULL;
+    do{
+        ini_dict = iniparser_load(BPI_CONFIG_PATH);
+        if(!ini_dict){
+            break;
+        }
+        //bpi work mode map
+        /************************
+        *[mode_map]
+        *pir_trigger=recording
+        *wifi_wakeup_trigger=streaming
+        *wifi_reconnect_trigger=wlan_reconnect
+        *notify_trigger=notify
+        *button_click_trigger=wlan_config
+        *button_2s_trigger=xxxx
+        *button_5s_trigger=xxxx
+        **add more map here**
+        *************************/
+        AM_BPI_MODE_MAP* mode_map = config->mode_map;
+        if ((value = iniparser_getstring(ini_dict, "mode_map:pir_trigger", NULL))!= NULL) {
+            mode_map[MCU_TRIGGER_PIR_ON].index = MCU_TRIGGER_PIR_ON;
+            mode_map[MCU_TRIGGER_PIR_ON].bpi_mode = (AM_BPI_MODE)atoi(value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if ((value= iniparser_getstring(ini_dict, "mode_map:wifi_wakeup_trigger", NULL))!= NULL) {
+            mode_map[MCU_TRIGGER_WIFI_WAKEUP].index = MCU_TRIGGER_WIFI_WAKEUP;
+            mode_map[MCU_TRIGGER_WIFI_WAKEUP].bpi_mode = (AM_BPI_MODE)atoi(value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if ((value= iniparser_getstring(ini_dict, "mode_map:wifi_reconnect_trigger", NULL))!= NULL) {
+            mode_map[MCU_TRIGGER_WIFI_RECONNECT].index = MCU_TRIGGER_WIFI_RECONNECT;
+            mode_map[MCU_TRIGGER_WIFI_RECONNECT].bpi_mode = (AM_BPI_MODE)atoi(value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if ((value= iniparser_getstring(ini_dict, "mode_map:button_click_trigger", NULL))!= NULL) {
+            mode_map[MCU_TRIGGER_PWR].index = MCU_TRIGGER_PWR;
+            mode_map[MCU_TRIGGER_PWR].bpi_mode = (AM_BPI_MODE)atoi(value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if ((value= iniparser_getstring(ini_dict, "mode_map:button_2s_trigger", NULL))!= NULL) {
+            mode_map[MCU_TRIGGER_PWR_2S].index = MCU_TRIGGER_PWR_2S;
+            mode_map[MCU_TRIGGER_PWR_2S].bpi_mode = (AM_BPI_MODE)atoi(value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if ((value= iniparser_getstring(ini_dict, "mode_map:low_power_trigger", NULL))!= NULL) {
+            mode_map[MCU_TRIGGER_POWER_EMPTY].index = MCU_TRIGGER_POWER_EMPTY;
+            mode_map[MCU_TRIGGER_POWER_EMPTY].bpi_mode = (AM_BPI_MODE)atoi(value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "app:record_control_mode", NULL))!= NULL){
+            config->record_control_mode = atoi(value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "app:record_duration_after_motion_starts", NULL))!= NULL){
+            config->record_duration_after_motion_starts = atoi(value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "app:record_duration_after_motion_stops", NULL))!= NULL){
+            config->record_duration_after_motion_stops = atoi(value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "app:recording_max_duration", NULL))!= NULL){
+            config->recording_max_duration = atoi(value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "app:streaming_duration", NULL))!= NULL){
+            config->streaming_duration = atoi(value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "app:thumbnail", NULL))!= NULL){
+            if(!strcmp(value, "true")){
+                config->thumbnail = true;
+            }
+            else if(!strcmp(value, "false")){
+                config->thumbnail = false;
+            }
+            else{
+                LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+                break;
+            }
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "app:enable_ldc", NULL))!= NULL){
+            if(!strcmp(value, "true")){
+                config->enable_ldc = true;
+            }
+            else if(!strcmp(value, "false")){
+                config->enable_ldc = false;
+            }
+            else{
+                LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+                break;
+            }
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "app:osd_label", NULL))!= NULL){
+            strcpy(config->osd_label, value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "app:storage_folder", NULL))!= NULL){
+            memset(config->storage_folder, '\0', sizeof(config->storage_folder));
+            strcpy(config->storage_folder, value);
+            if('/' != value[strlen(value)-1]){
+                config->storage_folder[strlen(config->storage_folder)] = '/';
+            }
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "app:file_name_prefix", NULL))!= NULL){
+            strcpy(config->file_name_prefix, value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "app:smart_avc", NULL))!= NULL){
+            if(!strcmp(value, "true")){
+                config->smart_avc = true;
+            }
+            else if(!strcmp(value, "false")){
+                config->smart_avc = false;
+            }
+            else{
+                LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+                break;
+            }
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+
+
+        if((value = iniparser_getstring(ini_dict, "app:rotate", NULL)) != NULL){
+            if( !strcmp(value,"0") || !strcmp(value,"1") || !strcmp(value,"2") || !strcmp(value,"3")){
+                config->rotate = (BPI_ROTATION_TYPE)(atoi(value));
+            }else{
+                LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+                break;
+            }
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "container:file_duration", NULL) )!= NULL){
+            config->file_duration = atoi(value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "container:fmt", NULL))!= NULL){
+            if(!strcmp(value, "mp4")){
+                config->file_fmt = BPI_FILE_MUXER_MP4;
+            }
+            else if(!strcmp(value, "ts")){
+                config->file_fmt = BPI_FILE_MUXER_TS;
+            }
+            else{
+                LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+                break;
+            }
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "video0:enable", NULL))!= NULL){
+            if(!strcmp(value, "true")){
+                config->video0_enable = true;
+            }
+            else if(!strcmp(value, "false")){
+                config->video0_enable = false;
+            }
+            else{
+                LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+                break;
+            }
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "video0:fmt", NULL))!= NULL){
+            if(!strcmp(value, "h264")){
+                config->video0_fmt = BPI_VIDEO_CODEC_H264;
+            }
+            else if(!strcmp(value, "h265")){
+                config->video0_fmt = BPI_VIDEO_CODEC_H265;
+            }
+            else if(!strcmp(value, "mjpeg")){
+                config->video0_fmt = BPI_VIDEO_CODEC_MJPEG;
+            }
+            else{
+                LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+                break;
+            }
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "video0:resolution", NULL))!= NULL){
+            if(!strcmp(value, "720p")){
+                config->video0_width = 1280;
+                config->video0_height = 720;
+            }
+            else if(!strcmp(value, "1080p")){
+                config->video0_width = 1920;
+                config->video0_height = 1080;
+            }
+            else{
+                LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+                break;
+            }
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "video0:frame_rate", NULL))!= NULL){
+            config->video0_frame_rate = atoi(value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "video0:recording_bitrate", NULL))!= NULL){
+            config->video0_recording_bitrate = atoi(value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "video0:streaming_bitrate", NULL))!= NULL){
+            config->video0_streaming_bitrate = atoi(value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "video1:enable", NULL))!= NULL){
+            if(!strcmp(value, "true")){
+                config->video1_enable = true;
+            }
+            else if(!strcmp(value, "false")){
+                config->video1_enable = false;
+            }
+            else{
+                LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+                break;
+            }
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "video1:fmt", NULL))!= NULL){
+            if(!strcmp(value, "h264")){
+                config->video1_fmt = BPI_VIDEO_CODEC_H264;
+            }
+            else if(!strcmp(value, "h265")){
+                config->video1_fmt = BPI_VIDEO_CODEC_H265;
+            }
+            else if(!strcmp(value, "mjpeg")){
+                config->video1_fmt = BPI_VIDEO_CODEC_MJPEG;
+            }
+            else{
+                LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+                break;
+            }
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "video1:resolution", NULL))!= NULL){
+            if(!strcmp(value, "480p")){
+                config->video1_width = 720;
+                config->video1_height = 480;
+            }
+            else{
+                LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+                break;
+            }
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "video1:frame_rate", NULL))!= NULL){
+            config->video1_frame_rate = atoi(value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "video1:recording_bitrate", NULL))!= NULL){
+            config->video1_recording_bitrate = atoi(value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "video1:streaming_bitrate", NULL))!= NULL){
+            config->video1_streaming_bitrate = atoi(value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "audio:sample_rate", NULL))!= NULL){
+            if(!strcmp(value, "48000")){
+                config->audio_sample_rate= 48000;
+            }
+            else if(!strcmp(value, "16000")){
+                config->audio_sample_rate = 16000;
+            }
+            else if(!strcmp(value, "8000")){
+                config->audio_sample_rate = 8000;
+            }
+            else{
+                LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+                break;
+            }
+        }else{
+            LOG_DEBUG("Audio sample rate entry not found, fastboot only. line:%d\n", __LINE__);
+        }
+
+        if((value= iniparser_getstring(ini_dict, "audio:enable", NULL))!= NULL){
+            if(!strcmp(value, "true")){
+                config->audio_enable = true;
+            }
+            else if(!strcmp(value, "false")){
+                config->audio_enable = false;
+            }
+            else{
+                LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+                break;
+            }
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "audio:fmt", NULL))!= NULL){
+            if(!strcmp(value, "g726")){
+                config->audio_fmt = BPI_AUDIO_CODEC_G726;
+            }
+            else if(!strcmp(value, "aac")){
+                config->audio_fmt = BPI_AUDIO_CODEC_AAC;
+            }
+            else if(!strcmp(value, "g711a")){
+                config->audio_fmt = BPI_AUDIO_CODEC_G711A;
+            }
+            else if(!strcmp(value, "g711mu")){
+                config->audio_fmt = BPI_AUDIO_CODEC_G711MU;
+            }
+            else{
+                LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+                break;
+            }
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "wlan:keepalive_interval", NULL))!= NULL){
+            config->keepalive_interval = atoi(value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "wlan:dtim_interval", NULL))!= NULL){
+            config->dtim_interval = atoi(value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "wlan:wakeup_token", NULL))!= NULL){
+            strcpy(config->wakeup_token, value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "wlan:cloud_server_ip_string", NULL))!= NULL){
+            strcpy(config->cloud_server_ip, value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "wlan:ap_ssid_string", NULL))!= NULL){
+            strcpy(config->ap_ssid, value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "wlan:ap_password_string", NULL))!= NULL){
+            strcpy(config->ap_password, value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "wlan:ap_wpa_string", NULL))!= NULL){
+            strcpy(config->ap_wpa, value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if ((value = iniparser_getstring(ini_dict, "vca:enable", NULL)) != NULL) {
+            if (!strcmp(value, "true")) {
+                config->vca_enable = true;
+            }
+            else if (!strcmp(value, "false")) {
+                config->vca_enable = false;
+            }
+            else{
+                LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+                break;
+            }
+        } else {
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if ((value = iniparser_getstring(ini_dict, "vca:frame_num", NULL)) != NULL) {
+            config->vca_frame_num = atoi(value);
+            if(config->vca_frame_num > MAX_VCA_FRAME_NUM){
+                config->vca_frame_num = MAX_VCA_FRAME_NUM;
+                LOG_PRINT("vca_frame_num too large, set to %d\n", MAX_VCA_FRAME_NUM);
+            }
+        } else {
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if ((value = iniparser_getstring(ini_dict, "vca:buffer_size", NULL)) != NULL) {
+            if(!strcmp(value, "720p")){
+                config->vca_width = 1280;
+                config->vca_height = 720;
+            }
+            else if(!strcmp(value, "1080p")){
+                config->vca_width = 1920;
+                config->vca_height = 1080;
+            }
+            else if(!strcmp(value, "480p")){
+                config->vca_width = 720;
+                config->vca_height = 480;
+            }
+            else{
+                LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+                break;
+            }
+        } else {
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if ((value = iniparser_getstring(ini_dict, "vca:timeout", NULL)) != NULL) {
+            config->vca_timeout = atoi(value);
+        } else {
+            break;
+        }
+
+        if (config->enable_two_ref){
+            if (config->enable_ldc){
+                LOG_ERROR("cannot enable two ref and LDC dewarp at the same time, ignore LDC settings\n");
+                break;
+            }
+            if (config->rotate == 1 || config->rotate == 3){
+                LOG_ERROR("cannot enable two ref and rotate at the same time, ignore rotate settings\n");
+                break;
+            }
+        }
+        ret = 0;
+    }while(0);
+    if(ini_dict) iniparser_freedict(ini_dict);
+
+    return ret;
+}
+#if 0
+int save_app_conf(app_conf_t *config)
+{
+    char value[64];
+    int ret = -1;
+    dictionary* ini_dict = NULL;
+    char config_overwrite[64];
+    do{
+        ini_dict = iniparser_load(BPI_CONFIG_PATH);
+        if(!ini_dict){
+            break;
+        }
+        /* Todo: Add any config item you want to modify */
+
+        FILE* f_ini = fopen(config_overwrite, "w");
+        if(f_ini){
+            iniparser_dump_ini(ini_dict, f_ini);
+            fclose(f_ini);
+        }
+
+        ret = 0;
+    }while(0);
+    if(ini_dict) iniparser_freedict(ini_dict);
+    return ret;
+}
+#endif
+
+int config_modified(app_conf_t *config, app_conf_t *old_config)
+{
+    int is_modified =
+        _DIFF(config, old_config, enable_ldc) ||
+        _DIFF(config, old_config, video0_enable) ||
+        _DIFF(config, old_config, video0_frame_rate) ||
+        _DIFF(config, old_config, video0_recording_bitrate) ||
+        _DIFF(config, old_config, video0_width) ||
+        _DIFF(config, old_config, video0_height) ||
+        _DIFF(config, old_config, rotate) ||
+        _DIFF(config, old_config, audio_enable) ||
+        _DIFF(config, old_config, vca_enable) ||
+        _DIFF(config, old_config, vca_frame_num);
+
+    return is_modified;
+}
+
+#ifdef DAREDEVIL
+int load_doorbell_conf(doorbell_conf_t *config){
+    const char* value = NULL;
+    int ret = -1;
+    dictionary* ini_dict = NULL;
+    do{
+        ini_dict = iniparser_load("/etc/bpi/setting.ini");
+        if(!ini_dict){
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "app:streaming_duration", NULL))!= NULL){
+            config->streaming_duration = atoi(value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "app:thumbnail", NULL))!= NULL){
+            if(!strcmp(value, "true")){
+                config->thumbnail = true;
+            }
+            else if(!strcmp(value, "false")){
+                config->thumbnail = false;
+            }
+            else{
+                LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+                break;
+            }
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        strcpy(config->storage_folder, SDCARD_PATH);
+
+    #if 0
+        if((value= iniparser_getstring(ini_dict, "storage_folder", "app"))!= NULL){
+            memset(config->storage_folder, '\0', sizeof(config->storage_folder));
+            strcpy(config->storage_folder, value);
+            if('/' != value[strlen(value)-1]){
+                config->storage_folder[strlen(config->storage_folder)] = '/';
+            }
+        }else{
+            strcpy(config->storage_folder, "/sdcard/video/");
+            iniparser_set(ini_dict, "storage_folder", "/sdcard/video/", "app");
+        }
+    #endif
+
+        if((value= iniparser_getstring(ini_dict, "app:smart_avc", NULL))!= NULL){
+            if(!strcmp(value, "true")){
+                config->smart_avc = true;
+            }
+            else if(!strcmp(value, "false")){
+                config->smart_avc = false;
+            }
+            else{
+                LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+                break;
+            }
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "app:hdr_enable", NULL))!= NULL){
+            if(!strcmp(value, "true")){
+                config->hdr_enable = true;
+            }
+            else if(!strcmp(value, "false")){
+                config->hdr_enable = false;
+            }
+            else{
+                LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+                break;
+            }
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value = iniparser_getstring(ini_dict, "app:rotate",NULL)) != NULL){
+            if( (strcmp(value,"0")==0) || (strcmp(value,"1")==0)\
+                    || (strcmp(value,"2")==0) || (strcmp(value,"3")==0)){
+                config->rotate = BPI_ROTATION_TYPE(atoi(value));
+            }
+            else{
+                LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+                break;
+            }
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "container:file_duration", NULL) )!= NULL){
+            config->file_duration = atoi(value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "container:fmt", NULL))!= NULL){
+            if(!strcmp(value, "mp4")){
+                config->file_fmt = BPI_FILE_MUXER_MP4;
+            }
+            else if(!strcmp(value, "ts")){
+                config->file_fmt = BPI_FILE_MUXER_TS;
+            }
+            else{
+                LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+                break;
+            }
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "video:enable", NULL))!= NULL){
+            if(!strcmp(value, "true")){
+                config->video_enable = true;
+            }
+            else if(!strcmp(value, "false")){
+                config->video_enable = false;
+            }
+            else{
+                LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+                break;
+            }
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "video:fmt", NULL))!= NULL){
+            if(!strcmp(value, "h264")){
+                config->video_fmt = BPI_VIDEO_CODEC_H264;
+            }
+            else if(!strcmp(value, "h265")){
+                config->video_fmt = BPI_VIDEO_CODEC_H265;
+            }
+            else if(!strcmp(value, "mjpeg")){
+                config->video_fmt = BPI_VIDEO_CODEC_MJPEG;
+            }
+            else{
+                LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+                break;
+            }
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "video:width", NULL))!= NULL){
+            config->video_width = atoi(value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "video:height", NULL))!= NULL){
+            config->video_height = atoi(value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "video:frame_rate", NULL))!= NULL){
+            config->video_frame_rate = atoi(value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "video:recording_bitrate", NULL))!= NULL){
+            config->video_recording_bitrate = atoi(value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "video:streaming_bitrate", NULL))!= NULL){
+            config->video_streaming_bitrate = atoi(value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "audio:enable", NULL))!= NULL){
+            if(!strcmp(value, "true")){
+                config->audio_enable = true;
+            }
+            else if(!strcmp(value, "false")){
+                config->audio_enable = false;
+            }
+            else{
+                LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+                break;
+            }
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "audio:fmt", NULL))!= NULL){
+            if(!strcmp(value, "g726")){
+                config->audio_fmt = BPI_AUDIO_CODEC_G726;
+            }
+            else if(!strcmp(value, "aac")){
+                config->audio_fmt = BPI_AUDIO_CODEC_AAC;
+            }
+            else if(!strcmp(value, "g711a")){
+                config->audio_fmt = BPI_AUDIO_CODEC_G711A;
+            }
+            else if(!strcmp(value, "g711mu")){
+                config->audio_fmt = BPI_AUDIO_CODEC_G711MU;
+            }
+            else{
+                LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+                break;
+            }
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "wlan:cloud_server_ip_string", NULL))!= NULL){
+            strcpy(config->cloud_server_ip, value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "wlan:ap_ssid_string", NULL))!= NULL){
+            strcpy(config->ap_ssid, value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "wlan:ap_password_string", NULL))!= NULL){
+            strcpy(config->ap_password, value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if((value= iniparser_getstring(ini_dict, "wlan:ap_wpa_string", NULL))!= NULL){
+            strcpy(config->ap_wpa, value);
+        }else{
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if ((value = iniparser_getstring(ini_dict, "vca:width", NULL)) != NULL) {
+            config->vca_width = atoi(value);
+        } else {
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        if ((value = iniparser_getstring(ini_dict, "vca:height", NULL)) != NULL) {
+            config->vca_height = atoi(value);
+        } else {
+            LOG_ERROR("get ini value failed, line:%d\n", __LINE__);
+            break;
+        }
+
+        ret = 0;
+    }while(0);
+
+    if(ini_dict) iniparser_freedict(ini_dict);
+    return ret;
+}
+#endif
+#ifdef __cplusplus
+};
+#endif
diff --git a/fastboot_app/bpi_app/bpi_app_config.h b/fastboot_app/bpi_app/bpi_app_config.h
new file mode 100644
index 0000000..0eed1e7
--- /dev/null
+++ b/fastboot_app/bpi_app/bpi_app_config.h
@@ -0,0 +1,143 @@
+/*
+ * bpi_app_config.h
+ *
+ * History:
+ *       2015/06/07 - [CZ Lin] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef __BPI_APP_CONFIG_H_
+#define __BPI_APP_CONFIG_H_
+
+#include <stdint.h>
+#include "bpi_typedefs.h"
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MAX_TOKEN_LEN 127
+#define MAX_VCA_FRAME_NUM 30
+#define BPI_CONFIG_PATH "/etc/bpi/setting.ini"
+#define SDCARD_PATH "/sdcard/"
+
+typedef struct _app_conf_t {
+    unsigned char record_control_mode;
+    bool thumbnail;
+    bool enable_ldc;
+    char osd_label[128];
+    int record_duration_after_motion_stops;
+    int record_duration_after_motion_starts;
+    int recording_max_duration;
+    int streaming_duration;
+    char storage_folder[128];
+    char file_name_prefix[64];
+    bool smart_avc;
+    bool enable_two_ref;
+    BPI_ROTATION_TYPE rotate;
+
+    int file_duration;
+    BPI_FILE_MUXER_TYPE file_fmt;
+
+    bool video0_enable;
+    BPI_VIDEO_CODEC_TYPE video0_fmt;
+    int video0_width;
+    int video0_height;
+    int video0_frame_rate;
+    int video0_recording_bitrate;
+    int video0_streaming_bitrate;
+
+    bool video1_enable;
+    BPI_VIDEO_CODEC_TYPE video1_fmt;
+    int video1_width;
+    int video1_height;
+    int video1_frame_rate;
+    int video1_recording_bitrate;
+    int video1_streaming_bitrate;
+
+    int audio_sample_rate;
+    bool audio_enable;
+    BPI_AUDIO_CODEC_TYPE audio_fmt;
+
+    //parameters about wlan keepalive
+    int keepalive_interval; //seconds;
+    int dtim_interval; //mseconds;
+    char wakeup_token[MAX_TOKEN_LEN + 1];
+    char ap_ssid[128];
+    char ap_password[128];
+    char ap_wpa[64];
+    char cloud_server_ip[64];
+
+    bool vca_enable;
+    int vca_width;
+    int vca_height;
+    uint8_t reserved;
+    int vca_frame_num;
+    int vca_timeout; // in ms
+
+    AM_BPI_MODE_MAP mode_map[MCU_TRIGGER_END];
+} app_conf_t;
+int load_app_conf(app_conf_t *config);
+int save_app_conf(app_conf_t *config);
+int config_modified(app_conf_t *config, app_conf_t *old_config);
+
+#ifdef DAREDEVIL
+typedef struct _doorbell_conf_t {
+    bool thumbnail;
+    int streaming_duration;
+    char storage_folder[128];
+    bool smart_avc;
+    bool hdr_enable;
+    BPI_ROTATION_TYPE rotate;
+
+    int file_duration;
+    BPI_FILE_MUXER_TYPE file_fmt;
+
+    bool video_enable;
+    BPI_VIDEO_CODEC_TYPE video_fmt;
+    int video_width;
+    int video_height;
+    int video_frame_rate;
+    int video_recording_bitrate;
+    int video_streaming_bitrate;
+
+    bool audio_enable;
+    BPI_AUDIO_CODEC_TYPE audio_fmt;
+
+    char ap_ssid[128];
+    char ap_password[128];
+    char ap_wpa[128];
+    char cloud_server_ip[128];
+    int vca_width;
+    int vca_height;
+} doorbell_conf_t;
+int load_doorbell_conf(doorbell_conf_t *config);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif//APP_CONFIG_H
diff --git a/fastboot_app/bpi_app/bpi_mcu_event_monitor.cpp b/fastboot_app/bpi_app/bpi_mcu_event_monitor.cpp
new file mode 100644
index 0000000..8d351ce
--- /dev/null
+++ b/fastboot_app/bpi_app/bpi_mcu_event_monitor.cpp
@@ -0,0 +1,121 @@
+/*
+ * bpi_mcu_event_monitor.cpp
+ *
+ * History:
+ *       2016/09/19 - [CZ Lin] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include "device.h"
+#include "bpi_typedefs.h"
+#include "bpi_utils.h"
+#include "bpi_app_config.h"
+#include "bpi_mcu_event_monitor.h"
+
+McuEventMonitor::McuEventMonitor():
+    m_cloud_agent(NULL),
+    m_timer_start_point(0){
+}
+
+McuEventMonitor::~McuEventMonitor(){
+}
+
+void McuEventMonitor::set_cloud_agent(handle_t handle)
+{
+    m_cloud_agent = handle;
+}
+
+unsigned int McuEventMonitor::get_timer_start_point(){
+    return m_timer_start_point;
+}
+
+void McuEventMonitor::init_timer_start_point(){
+    m_timer_start_point = get_current_time();
+}
+
+void McuEventMonitor::update(MCU_EVENT_TYPE event_type, int data1 ){
+    msg_t msg;
+    if (MCU_EVENT_PWR == event_type){
+        return;
+    }
+    switch(event_type){
+        case MCU_EVENT_PIR_ON:
+        case MCU_EVENT_PIR_OFF:
+        {
+            msg.what = MSG_DEVICE_PIR;
+            if(event_type == MCU_EVENT_PIR_ON){
+                msg.para1 = EPIR_ON;
+                m_timer_start_point = 0;
+            }else{
+                msg.para1 = EPIR_OFF;
+                m_timer_start_point = get_current_time();
+            }
+            break;
+        }
+        case MCU_EVENT_BATTERY_EMPTY:
+        case MCU_EVENT_BATTERY_LOW:
+        case MCU_EVENT_BATTERY_NORMAL:
+        {
+            int battery_quantity = (int)data1;
+            msg.what = MSG_DEVICE_BATTERY;
+            msg.para2 = battery_quantity;
+            if(event_type == MCU_EVENT_BATTERY_EMPTY){
+                msg.para1 = EBattery_Empty;
+                if(battery_quantity > 5){
+                    LOG_ERROR("battery quantity(%d) incorrect under EBattery_Empty", battery_quantity);
+                    return;
+                }
+            }else if(event_type == MCU_EVENT_BATTERY_LOW){
+                msg.para1 = EBattery_Low;
+                if(battery_quantity <= 5 || battery_quantity > 20){
+                    LOG_ERROR("battery quantity(%d) incorrect under EBattery_Low", battery_quantity);
+                    return;
+                }
+            }else{
+                msg.para1 = EBattery_Normal;
+                if(battery_quantity <= 20 || battery_quantity > 100){
+                    LOG_ERROR("battery quantity(%d) incorrect under EBattery_Normal", battery_quantity);
+                    return;
+                }
+            }
+            break;
+        }
+        case MCU_EVENT_DC_ON:
+        case MCU_EVENT_DC_OFF:
+        {
+            msg.what = MSG_DEVICE_DC;
+            msg.para1 = (event_type == MCU_EVENT_DC_ON) ? EDC_Plugin : EDC_Unplugged;
+            break;
+        }
+        default:
+            LOG_ERROR("unhandled mcu event(%d)\n", event_type);
+            break;
+    }
+
+    if(m_cloud_agent){
+        device_msg_request(m_cloud_agent, &msg, NULL);
+    }
+}
diff --git a/fastboot_app/bpi_app/bpi_mcu_event_monitor.h b/fastboot_app/bpi_app/bpi_mcu_event_monitor.h
new file mode 100644
index 0000000..79a4ee2
--- /dev/null
+++ b/fastboot_app/bpi_app/bpi_mcu_event_monitor.h
@@ -0,0 +1,63 @@
+/*
+ * bpi_mcu_event_monitor.h
+ *
+ * History:
+ *       2016/09/19 - [CZ Lin] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef __BPI_MCU_EVENT_MONITOR_H_
+#define __BPI_MCU_EVENT_MONITOR_H_
+
+#include "bpi_typedefs.h"
+
+#define DAREDEVIL_SOUND_PATH  "/usr/local/bin/doorbell.wav"
+#define ELEKTRA_SOUND_PATH  "/usr/local/bin/elektra-s.wav"
+
+class IMcuEventObserver{
+public:
+    virtual void update(MCU_EVENT_TYPE event_type, int data1 )= 0;
+};
+
+class BPIRecorder;
+
+class McuEventMonitor: public IMcuEventObserver{
+public:
+    McuEventMonitor();
+    McuEventMonitor & operator=(const McuEventMonitor&) = delete;
+    McuEventMonitor(const McuEventMonitor&) = delete;
+    ~McuEventMonitor();
+    void set_cloud_agent(void* handle);
+    unsigned int get_timer_start_point();
+    void init_timer_start_point();
+    virtual void update(MCU_EVENT_TYPE event_type, int data1);
+
+private:
+    void* m_cloud_agent;
+    //m_timer_start_point -- used in record mode 1: record for a fixed period of time after motion stops(no "PIR on" singal)
+    unsigned int m_timer_start_point;
+};
+#endif
diff --git a/fastboot_app/bpi_app/bpi_mcu_proxy.cpp b/fastboot_app/bpi_app/bpi_mcu_proxy.cpp
new file mode 100644
index 0000000..8389fdd
--- /dev/null
+++ b/fastboot_app/bpi_app/bpi_mcu_proxy.cpp
@@ -0,0 +1,545 @@
+/*
+ * bpi_mcu_proxy.cpp
+ *
+ * History:
+ *       2016/09/01 - [Zhipeng Dong] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <unistd.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <assert.h>
+#include <termios.h>
+
+#include "bpi_typedefs.h"
+#include "bpi_mcu_proxy.h"
+#include "bpi_mcu_event_monitor.h"
+#include "bpi_utils.h"
+#include "config.h"
+
+#if defined(CONFIG_BSP_BOARD_S2LM_ELEKTRA)
+#include "string.h"
+
+#define MAX_LENGTH_GPIO_PATH 128
+
+#define GPIO_PORT_SHUTDOWN 112
+#define GPIO_PORT_BOOTMOOD_0 92//PC1
+#define GPIO_PORT_BOOTMOOD_1 91//PB7
+#define GPIO_PORT_BOOTMOOD_2 38//PB8
+
+#define GPIO_SET 49
+#define GPIO_CLEAR 48
+#endif
+
+
+#define UART_PORT_NAME "/dev/ttyS0"
+#define UART_PORT_BAUDRATE B9600
+#define UART_PORT_FLOWCTRL 0
+using std::unique_lock;
+using std::cv_status;
+
+BPIMcuProxy::BPIMcuProxy(){
+    m_uart_fd = -1;
+    m_pipe_fd[0] = -1;
+    m_pipe_fd[1] = -1;
+    m_thread = nullptr;
+    m_observer = nullptr;
+}
+
+BPIMcuProxy::~BPIMcuProxy(){
+    if(m_thread){
+        char cmd = 'Z';
+        write(m_pipe_fd[1], &cmd, 1);
+        LOG_PRINT("~BPIMcuProxy\n");
+        m_thread->join();
+        m_thread = nullptr;
+    }
+
+    if(m_uart_fd){
+        close(m_uart_fd);
+        m_uart_fd = -1;
+    }
+
+    if(m_pipe_fd[0]){
+        close(m_pipe_fd[0]);
+    }
+
+    if(m_pipe_fd[1]){
+        close(m_pipe_fd[1]);
+    }
+}
+
+bool BPIMcuProxy::init(){
+#if defined(CONFIG_AMBARELLA_SERIAL_PORT0_NA)
+    if(!mcu_connect()){
+        LOG_ERROR("mcu connect failed\n");
+        return false;
+    }
+
+    if (pipe(m_pipe_fd) < 0) {
+        LOG_ERROR("create pipe failed\n");
+        return false;
+    }
+
+    m_thread = new thread(on_mcu_events, this);
+    if(nullptr == m_thread){
+        return false;
+    }
+#endif
+    return true;
+}
+
+#if defined(CONFIG_BSP_BOARD_S2LM_ELEKTRA)
+static int gpio_write(int gpio, unsigned char value)
+{
+    int fd_gpio = -1;
+    int length = 0;
+    char path[MAX_LENGTH_GPIO_PATH] = {0};
+
+    //export gpio
+    char gpio_num[32] = {0};
+    fd_gpio = open("/sys/class/gpio/export", O_WRONLY, 0);
+    if (fd_gpio < 0) {
+        perror("open /sys/class/gpio/export");
+        return -1;
+    }
+    length = snprintf(gpio_num, 32, "%d", gpio);
+    write(fd_gpio, gpio_num, length);
+    close(fd_gpio);
+
+    //direction
+    char gpio_direction[] = "out";//sw mode
+    snprintf(path, MAX_LENGTH_GPIO_PATH, "/sys/class/gpio/gpio%d/direction", gpio);
+    fd_gpio = open(path, O_WRONLY, 0);
+    if (fd_gpio < 0) {
+        perror("open gpio direction");
+        return -1;
+    }
+    write(fd_gpio, gpio_direction, strlen(gpio_direction));
+    close(fd_gpio);
+
+    //value
+    snprintf(path, MAX_LENGTH_GPIO_PATH, "/sys/class/gpio/gpio%d/value", gpio);
+    fd_gpio = open(path, O_WRONLY, 0);
+    if (fd_gpio < 0) {
+        perror("open gpio value");
+        return -1;
+    }
+    write(fd_gpio, &value, 1);
+    close(fd_gpio);
+
+    return 0;
+}
+
+static int gpio_read(int gpio, unsigned char* value)
+{
+    int fd_gpio = -1;
+    int length = 0;
+    char path[MAX_LENGTH_GPIO_PATH] = {0};
+
+    *value = 0;
+
+    //export gpio
+    char gpio_num[32] = {0};
+    fd_gpio = open("/sys/class/gpio/export", O_WRONLY, 0);
+    if (fd_gpio < 0) {
+        perror("open /sys/class/gpio/export");
+        return -1;
+    }
+    length = snprintf(gpio_num, 32, "%d", gpio);
+    write(fd_gpio, gpio_num, length);
+    close(fd_gpio);
+
+    //direction
+    char gpio_direction[] = "in";//sw mode
+    snprintf(path, MAX_LENGTH_GPIO_PATH, "/sys/class/gpio/gpio%d/direction", gpio);
+    fd_gpio = open(path, O_WRONLY, 0);
+    if (fd_gpio < 0) {
+        perror("open gpio direction");
+        return -1;
+    }
+    write(fd_gpio, gpio_direction, strlen(gpio_direction));
+    close(fd_gpio);
+
+    //value
+    snprintf(path, MAX_LENGTH_GPIO_PATH, "/sys/class/gpio/gpio%d/value", gpio);
+    fd_gpio = open(path, O_RDONLY, 0);
+    if (fd_gpio < 0) {
+        perror("open gpio value");
+        return -1;
+    }
+    read(fd_gpio, value, 1);
+    close(fd_gpio);
+
+    return 0;
+}
+#endif
+
+MCU_TRIGGER_TYPE BPIMcuProxy::get_trigger_event(){
+#if defined(CONFIG_BSP_BOARD_S2LM_ELEKTRA)
+    MCU_TRIGGER_TYPE ret = MCU_TRIGGER_BASE;
+    unsigned char value = 0;
+    int mode = 0;
+
+    if (gpio_read(GPIO_PORT_BOOTMOOD_0, &value) != 0) {
+        LOG_ERROR("gpio_read gpio 92 fail\n");
+        return ret;
+    }
+
+    if (value == GPIO_SET) {
+        mode |= 1;
+    }
+
+    if (gpio_read(GPIO_PORT_BOOTMOOD_1, &value) != 0) {
+        LOG_ERROR("gpio_read gpio 91 fail\n");
+        return ret;
+    }
+
+    if (value == GPIO_SET) {
+        mode |= 1 << 1;
+    }
+
+    if (gpio_read(GPIO_PORT_BOOTMOOD_2, &value) != 0) {
+        LOG_ERROR("gpio_read gpio 38 fail\n");
+        return ret;
+    }
+
+    if (value == GPIO_SET) {
+        mode |= 1 << 2;
+    }
+
+    switch(mode){
+        case 0:
+            ret = MCU_TRIGGER_PWR;
+            break;
+        case 1:
+            ret = MCU_TRIGGER_WIFI_RECONNECT;
+            break;
+        case 4:
+            ret = MCU_TRIGGER_PIR_ON;
+            break;
+        case 5:
+            ret = MCU_TRIGGER_WIFI_WAKEUP;
+            break;
+        default:
+            break;
+    }
+
+    return ret;
+#else
+    unique_lock<mutex> lk(m_mutex_cv);
+    char request_code = MCU_CMD_GET_TRIGGER_EVENT;
+    int len = write(m_uart_fd, &request_code, 1);
+    if(len != 1){
+        LOG_ERROR("request trigger event failed\n");
+        return MCU_TRIGGER_BASE;
+    }else{
+        int count = 0;
+        do{
+            if(++count > 5){
+                LOG_ERROR("get trigger event time out!\n");
+                return MCU_TRIGGER_BASE;
+            }
+            if(cv_status::timeout == m_cv.wait_for(lk, std::chrono::milliseconds(100))
+             || ((MCU_TRIGGER_TYPE)m_cur_event != MCU_TRIGGER_PIR_ON
+                && (MCU_TRIGGER_TYPE)m_cur_event != MCU_TRIGGER_WIFI_WAKEUP
+                && (MCU_TRIGGER_TYPE)m_cur_event != MCU_TRIGGER_WIFI_RECONNECT
+                && (MCU_TRIGGER_TYPE)m_cur_event != MCU_TRIGGER_PWR
+                && (MCU_TRIGGER_TYPE)m_cur_event != MCU_TRIGGER_PWR_2S
+                && (MCU_TRIGGER_TYPE)m_cur_event != MCU_TRIGGER_POWER_EMPTY)){
+                continue;
+            }else{
+                break;
+            }
+        }while(1);
+
+        return (MCU_TRIGGER_TYPE)m_cur_event;
+    }
+#endif
+}
+
+MCU_TRIGGER_TYPE BPIMcuProxy::get_competition_trigger_event()
+{
+    unique_lock<mutex> lk(m_mutex_cv);
+    char request_code = MCU_CMD_GET_RACE_TRIGGER_EVENT;
+    int len = write(m_uart_fd, &request_code, 1);
+    if(len != 1){
+        LOG_ERROR("request trigger event failed\n");
+        return MCU_TRIGGER_BASE;
+    }else{
+        int count = 0;
+        do{
+            if(++count > 5){
+                LOG_ERROR("request competition trigger event time out!\n");
+                return MCU_TRIGGER_BASE;
+            }
+            if(cv_status::timeout == m_cv.wait_for(lk, std::chrono::milliseconds(100)) || (m_cur_event != MCU_EVENT_RACE_TRIGGER_EVENT)){
+                continue;
+            }else{
+                break;
+            }
+        }while(1);
+
+        return (MCU_TRIGGER_TYPE)m_cur_data1;
+    }
+}
+
+int BPIMcuProxy::get_time_cost(){
+    unique_lock<mutex> lk(m_mutex_cv);
+    char request_code = MCU_CMD_GET_TIME_COST;
+    int len = write(m_uart_fd, &request_code, 1);
+    if(len != 1){
+        LOG_ERROR("request time cost from mcu failed\n");
+        return -1;
+    }else{
+        int count = 0;
+        do{
+            if(++count > 5){
+                LOG_ERROR("request time cost from mcu time out!\n");
+                return -1;
+            }
+            if(cv_status::timeout == m_cv.wait_for(lk, std::chrono::milliseconds(100)) || (m_cur_event != MCU_EVENT_TIME_COST)){
+                continue;
+            }else{
+                break;
+            }
+        }while(1);
+        return m_cur_data1;
+    }
+}
+
+int BPIMcuProxy::get_mcu_version(){
+    unique_lock<mutex> lk(m_mutex_cv);
+    char request_code = MCU_CMD_GET_VERSION;
+    int len = write(m_uart_fd, &request_code, 1);
+    if(len != 1){
+        LOG_ERROR("request mcu fw version from mcu failed\n");
+        return -1;
+    }else{
+        int count = 0;
+        do{
+            if(++count > 5){
+                LOG_ERROR("request mcu fw version from mcu time out!\n");
+                return -1;
+            }
+            if(cv_status::timeout == m_cv.wait_for(lk, std::chrono::milliseconds(100)) || (m_cur_event != MCU_EVENT_VERSION)){
+                continue;
+            }else{
+                break;
+            }
+        }while(1);
+        return m_cur_data1;
+    }
+}
+
+bool BPIMcuProxy::wait_on_event(int event_type, int* data, int timeout_ms){
+    unique_lock<mutex> lk(m_mutex_cv);
+    auto now = std::chrono::system_clock::now();
+    if(m_cv.wait_until(lk, now + std::chrono::milliseconds(timeout_ms), [this, event_type](){return m_cur_event == event_type;})){
+        m_cur_event = MCU_EVENT_BASE;
+        *data = m_cur_data1;
+        return true;
+    }else{
+        return false;
+    }
+}
+
+void BPIMcuProxy::send_cmd(MCU_CMD_TYPE cmd_type){
+#if defined(CONFIG_BSP_BOARD_S2LM_ELEKTRA)
+    if(MCU_CMD_POWEROFF_CPU_DRAM == cmd_type){
+        sync();
+        usleep(500000);
+        while (1) {
+            gpio_write(GPIO_PORT_SHUTDOWN, (unsigned char)'1');
+            usleep(50000);
+        }
+    }else{
+        LOG_ERROR("unimplemented cmd(%d)\n", cmd_type);
+    }
+#else
+    char cmd = cmd_type;
+    int len = write(m_uart_fd, &cmd, 1);
+    if(len != 1){
+        LOG_ERROR("send cmd(%d) to mcu failed\n", cmd);
+    }
+#endif
+    return;
+}
+
+void BPIMcuProxy::attach(IMcuEventObserver* observer){
+    m_observer = observer;
+}
+bool BPIMcuProxy::mcu_connect(){
+    int ret = false;
+    do {
+        struct termios options;
+        m_uart_fd = open(UART_PORT_NAME, O_RDWR | O_NOCTTY | O_NONBLOCK);
+        if (m_uart_fd < 0) {
+            LOG_ERROR("Open serial port fail!\n");
+            break;
+        }
+
+        tcflush(m_uart_fd, TCIOFLUSH);
+        if (tcgetattr(m_uart_fd, &options) < 0) {
+            LOG_ERROR("Get port options fail\n");
+            break;
+        }
+
+        //use raw mode
+        cfmakeraw(&options);
+        options.c_cflag |= CLOCAL;
+        //enable/disable RTS/CTS
+        if (UART_PORT_FLOWCTRL) {
+            options.c_cflag |= CRTSCTS;
+        } else {
+            options.c_cflag &= ~CRTSCTS;
+        }
+
+        cfsetospeed(&options, UART_PORT_BAUDRATE);
+        cfsetispeed(&options, UART_PORT_BAUDRATE);
+
+        if (tcsetattr(m_uart_fd, TCSANOW, &options) < 0) {
+            LOG_ERROR("Set port options fail\n");
+            break;
+        }
+        tcflush(m_uart_fd, TCIOFLUSH);
+        ret = true;
+    } while (0);
+
+    if((false == ret) && m_uart_fd){
+        close(m_uart_fd);
+        m_uart_fd = -1;
+    }
+    return ret;
+}
+
+void BPIMcuProxy::on_mcu_events(void *arg){
+    BPIMcuProxy* m_proxy = (BPIMcuProxy*)arg;
+    fd_set fds;
+    fd_set readfds;
+    FD_ZERO(&fds);
+    FD_SET(m_proxy->m_uart_fd, &fds);
+    FD_SET(m_proxy->m_pipe_fd[0], &fds);
+    char uart_buffer;
+    int maxfd = ((m_proxy->m_uart_fd > m_proxy->m_pipe_fd[0]) ? m_proxy->m_uart_fd : m_proxy->m_pipe_fd[0]) + 1;
+    while (1) {
+        readfds = fds;
+        int ret = select(maxfd, &readfds, NULL, NULL, NULL);
+        if(FD_ISSET(m_proxy->m_pipe_fd[0], &readfds)){
+            if(1 == read(m_proxy->m_pipe_fd[0], &uart_buffer, 1)){
+                if (uart_buffer == 'Z') {
+                    break;
+                }
+            }
+        }
+        if (ret && FD_ISSET(m_proxy->m_uart_fd, &readfds)) {
+            if(1 != read(m_proxy->m_uart_fd, &uart_buffer, 1)){
+                LOG_ERROR("uart_read fail\n");
+            }else{
+                bool notify = true;
+                unique_lock<mutex> lk(m_proxy->m_mutex_cv);
+                m_proxy->m_cur_data1 = 0;
+                switch(uart_buffer){
+                    case MCU_EVENT_BATTERY_EMPTY:
+                    case MCU_EVENT_BATTERY_LOW:
+                    case MCU_EVENT_BATTERY_NORMAL:
+                    {
+                        char battery_quantity;
+                        if(1 == read(m_proxy->m_uart_fd, &battery_quantity, 1)){
+                            m_proxy->m_cur_data1 = battery_quantity;
+                        }
+                        else{
+                            LOG_ERROR("read battery quantity failed\n");
+                            notify = false;
+                        }
+                    }
+                    case MCU_EVENT_PIR_ON:
+                    case MCU_EVENT_PIR_OFF:
+                    case MCU_EVENT_BATTERY_CHARGE_OFF:
+                    case MCU_EVENT_BATTERY_CHARGE_ON:
+                    case MCU_EVENT_BATTERY_CHARGE_DONE:
+                    case MCU_EVENT_DC_ON:
+                    case MCU_EVENT_DC_OFF:
+                        notify = false;
+                    case MCU_EVENT_PWR:
+                        if (m_proxy->m_observer != nullptr){
+                            m_proxy->m_observer->update((MCU_EVENT_TYPE)uart_buffer, m_proxy->m_cur_data1);
+                        }
+                        break;
+                    case MCU_EVENT_TIME_COST:
+                    {
+                        if(4 != read(m_proxy->m_uart_fd, &m_proxy->m_cur_data1, 4)){
+                            LOG_ERROR("read time cost from mcu failed\n");
+                            notify = false;
+                        }
+                        break;
+                    }
+                    case MCU_EVENT_RACE_TRIGGER_EVENT:
+                    {
+                        char tmp_buf = 0;
+                        if(1 != read(m_proxy->m_uart_fd, &tmp_buf, 1)){
+                            LOG_ERROR("read race trigger event from mcu failed\n");
+                            notify = false;
+                        }else{
+                            m_proxy->m_cur_data1 = (MCU_TRIGGER_TYPE)tmp_buf;
+                        }
+                        break;
+                    }
+                    case MCU_TRIGGER_PIR_ON:
+                    case MCU_TRIGGER_WIFI_WAKEUP:
+                    case MCU_TRIGGER_WIFI_RECONNECT:
+                    case MCU_TRIGGER_PWR:
+                    case MCU_TRIGGER_PWR_2S:
+                    case MCU_TRIGGER_POWER_EMPTY:
+                        break;
+                    case MCU_EVENT_VERSION:
+                    {
+                        char tmp_buf[2];
+                        if(2 != read(m_proxy->m_uart_fd, tmp_buf, 2)){
+                            LOG_ERROR("get mcu version from mcu failed\n");
+                            notify = false;
+                        }
+                        m_proxy->m_cur_data1 = (tmp_buf[0]<<8)|(tmp_buf[1]);
+                        break;
+                    }
+                    default:
+                        LOG_ERROR("unknown mcu event(%d)\n", uart_buffer);
+                        notify = false;
+                        break;
+                }
+                if(notify){
+                    m_proxy->m_cur_event = (MCU_EVENT_TYPE)uart_buffer;
+                    m_proxy->m_cv.notify_all();
+                }
+            }
+        }else{
+            LOG_ERROR("uart to mcu failed!\n");
+        }
+    }
+    LOG_PRINT("mcu proxy thread exited\n");
+}
diff --git a/fastboot_app/bpi_app/bpi_mcu_proxy.h b/fastboot_app/bpi_app/bpi_mcu_proxy.h
new file mode 100644
index 0000000..9e15084
--- /dev/null
+++ b/fastboot_app/bpi_app/bpi_mcu_proxy.h
@@ -0,0 +1,75 @@
+/*
+ * bpi_mcu_proxy.h
+ *
+ * History:
+ *       2016/09/01 - [Zhipeng Dong] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __BPI_MCU_PROXY_H_
+#define __BPI_MCU_PROXY_H_
+#include <time.h>
+#include <thread>
+#include <condition_variable>
+#include <chrono>
+using std::thread;
+using std::condition_variable;
+using std::mutex;
+
+class IMcuEventObserver;
+
+class BPIMcuProxy{
+public:
+    BPIMcuProxy();
+    ~BPIMcuProxy();
+    MCU_TRIGGER_TYPE get_trigger_event();
+    MCU_TRIGGER_TYPE get_competition_trigger_event();
+    int get_time_cost();
+    int get_mcu_version();
+    void send_cmd(MCU_CMD_TYPE cmd_type);
+    void attach(IMcuEventObserver* observer);
+    bool init();
+    bool wait_on_event(int event_type, int* data, int timeout_ms);
+
+
+private:
+    bool mcu_connect();
+    static void on_mcu_events(void *arg);
+    int m_uart_fd;
+    int m_pipe_fd[2];
+    thread* m_thread;
+    IMcuEventObserver* m_observer;
+    condition_variable m_cv;
+    mutex m_mutex_cv;
+    MCU_EVENT_TYPE m_cur_event;
+    int m_cur_data1;
+};
+
+#define MCU_MAIN_VERSION(x) ((x>>8)&0xFF)
+#define MCU_SUB_VERSION(x)  (x&0xFF)
+
+#endif //__BPI_MCU_PROXY_H_
diff --git a/fastboot_app/bpi_app/bpi_oryx_config.cpp b/fastboot_app/bpi_app/bpi_oryx_config.cpp
new file mode 100644
index 0000000..c5bbe11
--- /dev/null
+++ b/fastboot_app/bpi_app/bpi_oryx_config.cpp
@@ -0,0 +1,651 @@
+/*******************************************************************************
+ * bpi_oryx_config.cpp
+ *
+ * History:
+ *   2017-07-17 - [CZ Lin]      created file
+ *
+ * Copyright (c) 2017 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <memory>
+#include <string>
+#include "bpi_utils.h"
+#include "bpi_typedefs.h"
+#include "bpi_app_config.h"
+#include "bpi_oryx_config.h"
+#include "am_configure.h"
+#include "am_define.h"
+#include "am_file.h"
+#include "am_record_msg.h"
+#include "am_low_bitrate_control_if.h"
+#include "am_motion_detect_if.h"
+#include "am_encode_overlay_if.h"
+
+using std::string;
+using std::shared_ptr;
+
+#ifdef ELEKTRA_V
+#define  ADV_MODE_RESOURCE_LIMIT  "/etc/oryx/video/hdr_line_interleaved_mode_resource_limit.acs"
+#else
+#define  ADV_MODE_RESOURCE_LIMIT  "/etc/oryx/video/adv_hdr_mode_resource_limit.acs"
+#endif
+
+// Simplify and unify the config process later
+void write_sole_config(const char *filename, void *content, size_t length)
+{
+    int fd = -1;
+    size_t write_size = 0;
+    int fd_flags = O_WRONLY | O_TRUNC;
+    do {
+        if (access(filename, F_OK) != 0) {
+            fd_flags |= O_CREAT;
+        }
+        fd = open(filename, fd_flags, 0400);
+        if (fd < 0) {
+            LOG_ERROR("open file %s failed: %s\n", filename, strerror(errno));
+            break;
+        }
+        while (write_size < length) {
+            size_t _size = write(fd, content, length);
+            if (_size < 0 && errno == EINTR) {
+                continue;
+            }
+            if (_size < 0) {
+                break;
+            }
+            write_size += _size;
+        }
+        if (write_size != length) {
+            LOG_ERROR("write file %s incorrect: %s\n", filename,
+                      strerror(errno));
+        }
+    } while (0);
+
+    if (fd) {
+        close(fd);
+    }
+}
+
+void read_sole_config(const char *filename, void *content, size_t length)
+{
+    int fd = -1;
+    size_t read_size = 0;
+    do {
+        fd = open(filename, O_RDONLY);
+        if (fd < 0) {
+            LOG_ERROR("open file %s failed: %s\n", filename, strerror(errno));
+            break;
+        }
+        while (read_size < length) {
+            size_t _size = read(fd, content, length);
+            if (_size < 0 && errno == EINTR) {
+                continue;
+            }
+            if (_size < 0) {
+                break;
+            }
+            read_size += _size;
+        }
+        if (read_size != length) {
+            LOG_ERROR("write file %s incorrect: %s\n", filename,
+                      strerror(errno));
+        }
+    } while (0);
+
+    if (fd) {
+        close(fd);
+    }
+}
+
+static bool config_oryx_image_iq(){
+    shared_ptr<AMConfig> p_iq;
+    p_iq.reset(AMConfig::create("/etc/oryx/image/iq_config.acs"));
+    if(!p_iq){
+        LOG_ERROR("load iq_config.acs failed\n");
+        return false;
+    }
+    AMConfig &iq = *p_iq;
+    if(iq["ae"].exists()){
+        iq["ae"]["slow_shutter_mode"] = 0;
+        iq["ae"]["sensor_shutter_max"] = 30;
+        iq["ae"]["sensor_gain_max"] = 42; //42 dB
+        iq["ae"]["ae_metering_mode"] = 2; //average metering
+        iq["ae"]["day_night_mode"] = -1;
+    }
+    if(p_iq){
+        (*p_iq).save();
+    }
+    return true;
+}
+bool config_oryx_engine(app_conf_t *p_user_conf){
+    shared_ptr<AMConfig> p_record_engine;
+    shared_ptr<AMConfig> p_filter_file_muxer;
+    shared_ptr<AMConfig> p_muxer;
+    shared_ptr<AMConfig> p_motion_detect;
+    shared_ptr<AMConfig> p_lbr;
+    shared_ptr<AMConfig> p_features;
+    shared_ptr<AMConfig> p_hdr_resource_limit;
+    shared_ptr<AMConfig> p_audio_source;
+    shared_ptr<AMConfig> p_filter_player;
+    shared_ptr<AMConfig> p_audio_g711_8k;
+    shared_ptr<AMConfig> p_audio_aac_48k;
+
+    if (!config_oryx_image_iq()){
+        LOG_ERROR("config_oryx_image_iq failed\n");
+        return false;
+    }
+    p_record_engine.reset(AMConfig::create("/etc/oryx/stream/engine/record-engine.acs"));
+    if(!p_record_engine){
+        LOG_ERROR("load record-engine.acs failed\n");
+        return false;
+    }
+
+    p_filter_file_muxer.reset(AMConfig::create("/etc/oryx/stream/filter/filter-file-muxer-0.acs"));
+    if(!p_filter_file_muxer){
+       LOG_ERROR("load %s failed\n", "/etc/oryx/stream/filter/filter-file-muxer-0.acs");
+       return false;
+    }
+
+    if(p_user_conf->file_fmt == BPI_FILE_MUXER_MP4){
+        p_muxer.reset(AMConfig::create("/etc/oryx/stream/muxer/muxer-mp4-0.acs"));
+        if(!p_muxer){
+            LOG_ERROR("load %s failed\n", "/etc/oryx/stream/muxer/muxer-mp4-0.acs");
+            return false;
+        }
+    }else if(p_user_conf->file_fmt == BPI_FILE_MUXER_TS){
+        p_muxer.reset(AMConfig::create("/etc/oryx/stream/muxer/muxer-ts-0.acs"));
+        if(!p_muxer){
+            LOG_ERROR("load %s failed\n", "/etc/oryx/stream/muxer/muxer-ts-0.acs");
+            return false;
+        }
+    }else{
+        LOG_ERROR("file format %d not supported\n", p_user_conf->file_fmt);
+        return false;
+    }
+
+    p_motion_detect.reset(AMConfig::create("/etc/oryx/video/vca/motion-detect.acs"));
+    if(!p_motion_detect){
+        LOG_ERROR("load %s failed\n", "/etc/oryx/video/vca/motion-detect.acs");
+        return false;
+    }
+    p_lbr.reset(AMConfig::create("/etc/oryx/video/lbr.acs"));
+    if(!p_lbr){
+        LOG_ERROR("load %s failed\n", "/etc/oryx/video/lbr.acs");
+        return false;
+    }
+
+    p_features.reset(AMConfig::create("/etc/oryx/video/features.acs"));
+    if(!p_features){
+        LOG_ERROR("load %s failed\n", "/etc/oryx/video/features.acs");
+        return false;
+    }
+    p_hdr_resource_limit.reset(AMConfig::create(ADV_MODE_RESOURCE_LIMIT));
+    if(!p_hdr_resource_limit){
+        LOG_ERROR("load %s failed\n", ADV_MODE_RESOURCE_LIMIT);
+        return false;
+    }
+
+    if (p_user_conf->audio_enable) {
+        if (48000 == p_user_conf->audio_sample_rate) {
+            p_audio_source.reset(AMConfig::create("/etc/oryx/stream/filter/filter-audio-source-48k.acs"));
+            if(!p_audio_source){
+                LOG_ERROR("load %s failed\n", "/etc/oryx/stream/filter/filter-audio-source-48k.acs");
+                return false;
+            }
+
+            p_audio_aac_48k.reset(AMConfig::create("/etc/oryx/stream/codec/codec-aac-48k.acs"));
+            if(!p_audio_aac_48k){
+                LOG_ERROR("load %s failed\n", "/etc/oryx/stream/codec/codec-aac-48k.acs");
+                return false;
+            }
+        } else if (16000 == p_user_conf->audio_sample_rate) {
+            p_audio_source.reset(AMConfig::create("/etc/oryx/stream/filter/filter-audio-source-16k.acs"));
+            if(!p_audio_source){
+                LOG_ERROR("load %s failed\n", "/etc/oryx/stream/filter/filter-audio-source-16k.acs");
+                return false;
+            }
+        } else if (8000 == p_user_conf->audio_sample_rate) {
+            p_audio_source.reset(AMConfig::create("/etc/oryx/stream/filter/filter-audio-source-8k.acs"));
+            if(!p_audio_source){
+                LOG_ERROR("load %s failed\n", "/etc/oryx/stream/filter/filter-audio-source-8k.acs");
+                return false;
+            }
+
+            p_audio_g711_8k.reset(AMConfig::create("/etc/oryx/stream/codec/codec-g711-8k.acs"));
+            if(!p_audio_g711_8k){
+                LOG_ERROR("load %s failed\n", "/etc/oryx/stream/codec/codec-g711-8k.acs");
+                return false;
+            }
+        } else {
+            LOG_ERROR("audio sample rate =%d not supported\n", p_user_conf->audio_sample_rate);
+        }
+    }
+
+    p_filter_player.reset(AMConfig::create("/etc/oryx/stream/filter/filter-player.acs"));
+    if(!p_filter_player){
+        LOG_ERROR("load %s failed\n", "/etc/oryx/stream/filter/filter-player.acs");
+        return false;
+    }
+
+    AMConfig &record_engine = *p_record_engine;
+    AMConfig &muxer = *p_muxer;
+    AMConfig &file_muxer_config = *p_filter_file_muxer;
+    AMConfig &md = *p_motion_detect;
+    AMConfig &lbr = *p_lbr;
+    AMConfig &features = *p_features;
+    AMConfig &hdr_resource_limit = *p_hdr_resource_limit;
+    AMConfig &audio_source = *p_audio_source;
+    AMConfig &filter_player = *p_filter_player;
+    AMConfig &audio_g711_8k = *p_audio_g711_8k;
+    AMConfig &audio_aac_48k = *p_audio_aac_48k;
+    int file_muxer_bitmap;
+
+    if(record_engine["filters"].exists()) record_engine["filters"].remove();
+    if(record_engine["connection"].exists()) record_engine["connection"].remove();
+    record_engine["filters"][0]=string("file-muxer-0");
+    record_engine["filters"][1]=string("video-source");
+    record_engine["connection"]["video_source"]["output"][0] = string("file-muxer-0");
+    record_engine["connection"]["file_muxer_0"]["input"][0] = string("video_source");
+
+    if(file_muxer_config["media_type"].exists()) file_muxer_config["media_type"].remove();
+    if(p_user_conf->file_fmt == BPI_FILE_MUXER_MP4){
+        file_muxer_config["media_type"][0] = string("mp4-0");
+    }else if(p_user_conf->file_fmt == BPI_FILE_MUXER_TS){
+        file_muxer_config["media_type"][0] = string("ts-0");
+    }
+    file_muxer_config["persistent_buf_duration"] = 8; // It needs to save more audio data in fastboot
+    //write muxer bitmap to nand
+    file_muxer_bitmap |= 0x01 << muxer["muxer_id"].get<unsigned int>(0);
+    write_sole_config("/tmp/config/etc/bpi/.file_muxer_bitmap",
+                    (void*)&file_muxer_bitmap, sizeof(file_muxer_bitmap));
+    muxer["file_name_prefix"] = string(p_user_conf->file_name_prefix);
+    muxer["file_location"] = string(p_user_conf->storage_folder);
+    muxer["file_location_auto_parse"] = false;
+
+    features["mode"] = string("mode4");
+    features["overlay"] = string("enable");
+    features["dptz"] = string("disable");
+    hdr_resource_limit["dsp_partition_possible"]["sub_buf_prev_C_yuv"] = true;
+    md["md_source_buffer_id"] = 2; // preview B ME1, 1/4 width of prevB, 1/4 height of prevB
+    md["roi_config"][0]["right"] = 319;  // this should change accordingly if size of prevB buffer changes
+    md["roi_config"][0]["bottom"] = 179;
+    if (p_user_conf->smart_avc) {
+        lbr["StreamConfig"][0]["AutoBitrateTarget"] = false;
+        lbr["StreamConfig"][0]["BitrateCeiling"] = 186;
+        lbr["StreamConfig"][0]["EnableLBR"] = true;
+        features["video_vca"][0] = string("vca-motion-detect");
+        features["bitrate_ctrl"] = string("lbr");
+        hdr_resource_limit["dsp_partition_possible"]["sub_buf_prev_B_me"] = true; //md use Dsp sub buf4
+    } else {
+        features["video_vca"][0] = string("");
+        features["bitrate_ctrl"] = string("none");
+        hdr_resource_limit["dsp_partition_possible"]["sub_buf_prev_B_me"] = false;
+    }
+
+    if (p_user_conf->audio_enable){
+        filter_player["audio"]["interface"] = string("alsa");
+        filter_player["audio"]["buffer_delay_ms"] = 100;
+        audio_source["packet_pool_size"] = 128; // Packet poll needs more size than default value 64 in fastboot mode
+        if (48000 == p_user_conf->audio_sample_rate){
+            record_engine["filters"][2]=string("audio-source-48k");
+            record_engine["connection"]["audio_source_48k"]["output"][0] = string("file-muxer-0");
+            record_engine["connection"]["file_muxer_0"]["input"][1] = string("audio_source_48k");
+            muxer["audio_type"] = string("aac");
+            muxer["audio_sample_rate"] = 48000;
+            file_muxer_config["audio_type"][0] = string("aac-48k");
+            audio_source["interface"] = string("raw");
+            if(audio_source["audio_type"].exists()) {audio_source["audio_type"].remove();}
+            audio_source["audio_type"][0] = string("aac");
+            audio_aac_48k["encode"]["format"] = string("aac");
+        }else if (16000 == p_user_conf->audio_sample_rate){
+            record_engine["filters"][2]=string("audio-source-16k");
+            record_engine["connection"]["audio_source_16k"]["output"][0] = string("file-muxer-0");
+            record_engine["connection"]["file_muxer_0"]["input"][1] = string("audio_source_16k");
+            muxer["audio_type"] = string("aac");
+            muxer["audio_sample_rate"] = 16000;
+            file_muxer_config["audio_type"][0] = string("aac-16k");
+            audio_source["interface"] = string("raw");
+            if(audio_source["audio_type"].exists()) {audio_source["audio_type"].remove();}
+            audio_source["audio_type"][0] = string("aac");
+        }else if (8000 == p_user_conf->audio_sample_rate){
+            record_engine["filters"][2]=string("audio-source-8k");
+            record_engine["connection"]["audio_source_8k"]["output"][0] = string("file-muxer-0");
+            record_engine["connection"]["file_muxer_0"]["input"][1] = string("audio_source_8k");
+            muxer["audio_type"] = string("g726_32");
+            muxer["audio_sample_rate"] = 8000;
+            file_muxer_config["audio_type"][0] = string("g726_32-8k");
+            audio_source["interface"] = string("raw");
+            audio_g711_8k["encode_frame_time_length"] = 40;
+        }else{
+            LOG_ERROR("audio sample rate =%d not supported\n", p_user_conf->audio_sample_rate);
+        }
+    }
+
+    if(p_record_engine){
+        (*p_record_engine).save();
+    }
+    if(p_filter_file_muxer){
+        (*p_filter_file_muxer).save();
+    }
+    if(p_muxer){
+        (*p_muxer).save();
+    }
+    if(p_features){
+        (*p_features).save();
+    }
+    if(p_lbr){
+        (*p_lbr).save();
+    }
+    if(p_motion_detect){
+        (*p_motion_detect).save();
+    }
+    if(p_hdr_resource_limit){
+        (*p_hdr_resource_limit).save();
+    }
+    if(p_audio_source){
+        (*p_audio_source).save();
+    }
+    if(p_filter_player){
+        (*p_filter_player).save();
+    }
+    if(p_audio_g711_8k){
+        (*p_audio_g711_8k).save();
+    }
+    if(p_audio_aac_48k){
+        (*p_audio_aac_48k).save();
+    }
+    return true;
+}
+
+OryxVideoModule* OryxVideoModule::get_instance()
+{
+    static OryxVideoModule instance;
+    return &instance;
+}
+
+OryxVideoModule::OryxVideoModule():
+    m_image(nullptr),
+    m_video_camera(nullptr),
+    m_lbr(nullptr),
+    m_md(nullptr),
+    m_ol(nullptr),
+    m_stream0_overlay_area0(nullptr),
+    m_area0_data0(nullptr),
+    m_am_vca(nullptr)
+{
+}
+
+OryxVideoModule::~OryxVideoModule()
+{
+}
+
+bool OryxVideoModule::start_camera()
+{
+    m_video_camera = AMIVideoCamera::get_instance();
+    if (!m_video_camera) {
+        LOG_ERROR("Failed to get AMIVideoCamera instance!");
+        return false;
+    }
+    if (m_video_camera->start() != AM_RESULT_OK) { //for fastboot, encoding is always on
+        LOG_ERROR("Start encoding failed\n");
+        return false;
+    }
+    return true;
+}
+
+bool OryxVideoModule::stop_camera()
+{
+    if (m_video_camera && m_video_camera->stop() != AM_RESULT_OK) {
+        LOG_ERROR("Stop encoding failed!\n");
+        return false;
+    }
+    return true;
+}
+
+bool OryxVideoModule::start_linux_aaa(bool enable)
+{
+    if (!enable) {
+        return true;
+    }
+    m_image = AMIImageQuality::get_instance();
+    if (!m_image) {
+        LOG_ERROR("failed to get ImageQuality instance\n");
+        return false;
+    }
+    if (!m_image->start()) {
+        LOG_ERROR("Start image module failed\n");
+        return false;
+    }
+
+    return true;
+}
+
+bool OryxVideoModule::start_overlay(const char *label)
+{
+    int stream0_area0_id = -1;
+    bool ret = false;
+    string osd_label(label);
+
+    do {
+        if (!m_video_camera)
+            break;
+        if (osd_label.empty()){
+            LOG_DEBUG("No overlay label assigned.\n");
+            ret = true;
+            break;
+        }
+        m_ol = (AMIEncodeOverlay*) m_video_camera->get_video_plugin(
+        VIDEO_PLUGIN_OVERLAY);
+        if (!m_ol) {
+            LOG_ERROR("overlay plugin is not loaded!\n");
+            break;
+        }
+
+        osd_label = osd_label.append(" ", 1);
+        printf("osd_label: %s\n", osd_label.c_str());
+
+        m_stream0_overlay_area0 = new AMOverlayAreaAttr;
+        if (NULL == m_stream0_overlay_area0)
+            {
+            LOG_ERROR("malloc memory for AMOverlayAreaAttr failed! \n");
+            break;
+        }
+        m_area0_data0 = new AMOverlayAreaData;
+        if (NULL == m_area0_data0)
+            {
+            LOG_ERROR("malloc memory for AMOverlayAreaData failed! \n");
+            break;
+        }
+
+        m_stream0_overlay_area0->enable = 1;
+        m_stream0_overlay_area0->rotate = 0;
+        m_stream0_overlay_area0->rect.offset.x = 0;
+        m_stream0_overlay_area0->rect.offset.y = 0;
+        m_stream0_overlay_area0->rect.size.width = 800;
+        m_stream0_overlay_area0->rect.size.height = 100;
+        m_stream0_overlay_area0->bg_color = {0,0,0,0}; //test color:full transparent
+
+        m_area0_data0->rect.offset.x = 0;
+        m_area0_data0->rect.offset.y = 0;
+        m_area0_data0->rect.size.width = 750;
+        m_area0_data0->rect.size.height = 90;
+        m_area0_data0->type = AM_OVERLAY_DATA_TYPE_TIME;
+        m_area0_data0->time.text.font.width = 30; //font size
+        m_area0_data0->time.text.font.height = 30;
+        m_area0_data0->time.text.font_color.id = 0; //font color:white
+        m_area0_data0->time.pre_str = osd_label; //time prefix
+        m_area0_data0->time.suf_str = "";
+
+        LOG_PRINT("init overlay ok\n");
+
+        if ((stream0_area0_id = m_ol->init_area(AM_STREAM_ID(0),
+                                                *m_stream0_overlay_area0)) < 0)
+            {
+            LOG_ERROR("init_area failed\n");
+            break;
+        }
+        if (m_ol->add_data_to_area(AM_STREAM_ID(0), stream0_area0_id,
+                                   *m_area0_data0) < 0)
+            {
+            LOG_ERROR("add_data_to_area failed\n");
+            break;
+        }
+
+        ret = true;
+        LOG_PRINT("add overlay ok\n");
+    } while (0);
+
+    return ret;
+}
+
+bool OryxVideoModule::start_smart_avc(bool enable)
+{
+    bool ret = false;
+    AMGOP h264_gop;
+    h264_gop.stream_id = AM_STREAM_ID_0;
+    h264_gop.N = 90;
+    h264_gop.idr_interval = 1;
+
+    do {
+        if (!m_video_camera){
+            break;
+        }
+        if (!enable){
+            ret = true;
+            break;
+        }
+
+        if (m_video_camera->set_h26x_gop(h264_gop)){
+            LOG_ERROR("modify h264 GOP to %u failed\n", h264_gop.N);
+            break;
+        }
+        m_am_vca = (AMIVCA*)m_video_camera->get_video_plugin(VIDEO_PLUGIN_VCA);
+        if (!m_am_vca) {
+            LOG_ERROR("AM VCA plugin is not loaded!\n");
+            break;
+        }
+        if (!m_am_vca->start()) {
+            LOG_ERROR("Start AM VCA loop failed!\n");
+            break;
+        }
+        m_md = (AMIMotionDetect*) m_am_vca->get_plugin_interface(VCA_PLUGIN_MD);
+        if (!m_md) {
+            LOG_ERROR("motion detect plugin is not loaded!\n");
+            break;
+        }
+        m_lbr = (AMILBRControl*) m_video_camera->get_video_plugin(
+            VIDEO_PLUGIN_LBR);
+        if (!m_lbr) {
+            LOG_ERROR("LBR plugin is not loaded!\n");
+            break;
+        }
+
+        if (m_md->set_md_callback(this, receive_data_from_md) == 0) {
+            LOG_ERROR("Set motion detect callback failed\n");
+            break;
+        }
+        if (!m_md->start()) {
+            LOG_ERROR("Start motion detect failed!\n");
+            break;
+        }
+        if (!m_lbr->start()) {
+            LOG_ERROR("Start LBR failed!\n");
+            break;
+        }
+        LOG_PRINT("Low bitrate control start.\n");
+        ret = true;
+    }while(0);
+
+    return ret;
+}
+
+bool OryxVideoModule::set_bitrate(int target_bitrate)
+{
+    AMBitrate brate;
+    brate.stream_id = AM_STREAM_ID(AM_STREAM_ID_0);
+    if (m_video_camera->get_bitrate(brate)) {
+        LOG_ERROR("fail to get bitrate\n");
+        return false;
+    }
+    brate.target_bitrate = target_bitrate;
+    if (m_video_camera->set_bitrate(brate)) {
+        LOG_ERROR("fail to set bitrate\n");
+        return false;
+    }
+    LOG_PRINT("set bitrate to %d\n", brate.target_bitrate);
+
+    return true;
+}
+
+bool OryxVideoModule::stop_linux_aaa()
+{
+    if (m_image && !m_image->stop()) {
+        LOG_ERROR("Stop image module failed\n");
+        return false;
+    }
+    return true;
+}
+
+bool OryxVideoModule::stop_overlay()
+{
+    if(m_ol)
+    {
+        if(m_stream0_overlay_area0)
+        {
+            delete m_stream0_overlay_area0;
+            m_stream0_overlay_area0 = NULL;
+        }
+        if(m_area0_data0)
+        {
+            delete m_area0_data0;
+            m_area0_data0 = NULL;
+        }
+    }
+    return true;
+}
+
+bool OryxVideoModule::stop_smart_avc()
+{
+    /* no need to destroy() m_lbr and m_md addidionally */
+    if (m_lbr && !m_lbr->stop()) {
+        LOG_ERROR("Stop LBR plugin failed!\n");
+        return false;
+    }
+    if (m_md && !m_md->stop()) {
+        LOG_ERROR("Stop motion detect plugin failed!\n");
+        return false;
+    }
+    return true;
+}
+
+int OryxVideoModule::receive_data_from_md(void *owner, AMMDMessage *info)
+{
+    OryxVideoModule *self = (OryxVideoModule*) owner;
+    self->m_lbr->process_motion_info(info);
+    return 0;
+}
\ No newline at end of file
diff --git a/fastboot_app/bpi_app/bpi_oryx_config.h b/fastboot_app/bpi_app/bpi_oryx_config.h
new file mode 100644
index 0000000..5b0c5f8
--- /dev/null
+++ b/fastboot_app/bpi_app/bpi_oryx_config.h
@@ -0,0 +1,82 @@
+/*******************************************************************************
+ * bpi_oryx_export.h
+ *
+ * History:
+ *   2017-01-17 - [Jian Liu]      created file
+ *
+ * Copyright (c) 2017 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+#ifndef BPI_ORYX_CONFIG_H_
+#define BPI_ORYX_CONFIG_H_
+
+#include "bpi_app_config.h"
+#include "am_image_quality_if.h"
+#include "am_video_camera_if.h"
+#include "am_vca_framework_if.h"
+
+void read_sole_config(const char *filename, void *content, size_t length);
+void write_sole_config(const char *filename, void *content, size_t length);
+bool config_oryx_engine(app_conf_t *p_user_conf);
+
+
+class AMILBRControl;
+class AMIMotionDetect;
+class AMIEncodeOverlay;
+struct AMMDMessage;
+struct AMOverlayAreaAttr;
+struct AMOverlayAreaData;
+
+class OryxVideoModule{
+public:
+    bool start_camera();
+    bool start_linux_aaa(bool enable = true);
+    bool start_overlay(const char *label);
+    bool start_smart_avc(bool enable);
+    bool set_bitrate(int target_bitrate);
+    bool stop_camera();
+    bool stop_linux_aaa();
+    bool stop_overlay();
+    bool stop_smart_avc();
+    static OryxVideoModule* get_instance();
+    static int receive_data_from_md(void *owner, AMMDMessage *info);
+private:
+    OryxVideoModule();
+    ~OryxVideoModule();
+    OryxVideoModule(const OryxVideoModule &module) = delete;
+    OryxVideoModule& operator=(const OryxVideoModule module) = delete;
+
+    AMIImageQualityPtr m_image;
+    AMIVideoCameraPtr m_video_camera; //surrogate of AMEncodeDevice
+    AMILBRControl* m_lbr;
+    AMIMotionDetect* m_md;
+    AMIEncodeOverlay* m_ol;
+    AMOverlayAreaAttr *m_stream0_overlay_area0;
+    AMOverlayAreaData *m_area0_data0;
+    AMIVCA *m_am_vca;
+};
+
+
+#endif
diff --git a/fastboot_app/bpi_app/bpi_oryx_export.cpp b/fastboot_app/bpi_app/bpi_oryx_export.cpp
new file mode 100644
index 0000000..dd2fe57
--- /dev/null
+++ b/fastboot_app/bpi_app/bpi_oryx_export.cpp
@@ -0,0 +1,444 @@
+/*******************************************************************************
+ * bpi_oryx_export.cpp
+ *
+ * History:
+ *   2017-01-17 - [Jian Liu]      created file
+ *
+ * Copyright (c) 2017 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+#include <string>
+#include "bpi_utils.h"
+#include "bpi_typedefs.h"
+#include "bpi_app_config.h"
+#include "bpi_uploader.h"
+#include "bpi_oryx_export.h"
+#include "bpi_oryx_config.h"
+#include "bpi_yuv_rotate.h"
+#include "am_define.h"
+#include "am_file.h"
+#include "am_jpeg_encoder_if.h"
+#include "am_video_reader_if.h"
+#include "am_video_address_if.h"
+#include "am_record_msg.h"
+
+#define THUMBNAIL_BUFFER_ID 1//use the same buffer that vca use, configed to 720x480
+
+using std::string;
+
+CaptureRoutine::CaptureRoutine():
+    m_rotation(BPI_ROTATION_TYPE_NONE),
+    m_enable(false),
+    m_file_name(""),
+    m_file_base("")
+{
+}
+
+CaptureRoutine::~CaptureRoutine()
+{
+}
+
+void CaptureRoutine::set_rotation(BPI_ROTATION_TYPE _rotation)
+{
+    m_rotation = _rotation;
+}
+
+void CaptureRoutine::enable(const char *storage_folder)
+{
+    m_enable = true;
+    m_file_base = storage_folder;
+    if(m_file_base.back() != '/'){
+        m_file_base.append("/");
+    }
+    m_file_name = m_file_base + "BPI_snap.jpg";
+
+    capture(THUMBNAIL_BUFFER_ID, m_file_name.c_str());
+}
+
+void CaptureRoutine::disable()
+{
+    m_enable = false;
+}
+
+bool CaptureRoutine::rename_file(string &target_name)
+{
+    if(m_enable){
+        if(parse_filename(target_name) &&
+            !rename(m_file_name.c_str(), target_name.c_str())){
+            return true;
+        }else{
+            LOG_ERROR("m_file_name: %s, target_name: %s. "
+                "Rename snapshot file name failed: %s\n", m_file_name.c_str(),
+                target_name.c_str(), strerror(errno));
+        }
+    }
+
+    return false;
+}
+
+bool CaptureRoutine::parse_filename(string &file_name)
+{
+    bool ret = false;
+    string::size_type pos_tmp;
+    do{
+        pos_tmp = file_name.find_last_of('.');
+        if(pos_tmp != string::npos){
+            file_name.replace(file_name.begin() + pos_tmp,
+                              file_name.end(), ".jpg");
+        }else{
+            LOG_ERROR("unrecognized file event(%s)!\n", file_name.c_str());
+            break;
+        }
+
+        pos_tmp = file_name.find_last_of('/');
+        if(pos_tmp != string::npos){
+            file_name.replace(file_name.begin(),
+                              file_name.begin() + pos_tmp + 1,
+                              m_file_base);
+        }else{
+            LOG_ERROR("no valid name found(%s)!\n", file_name.c_str());
+            break;
+        }
+
+        ret = true;
+    }while(0);
+
+    return ret;
+}
+
+bool CaptureRoutine::capture(int stream_id, const char* file_name)
+{
+    AMQueryFrameDesc frame_desc;
+    AM_RESULT result = AM_RESULT_OK;
+    AMIVideoReaderPtr video_reader = nullptr;
+    AMIVideoAddressPtr video_address = nullptr;
+    AMIJpegEncoderPtr jpeg_encoder = nullptr;
+    AMJpegData* jpeg = nullptr;
+    AMYUVData *yuv = nullptr;
+    AMFile f(file_name);
+
+    uint8_t *rotate_addr = nullptr;
+    do {
+        AMAddress yaddr;
+        AMAddress uvaddr;
+        video_reader = AMIVideoReader::get_instance();
+        video_address = AMIVideoAddress::get_instance();
+        jpeg_encoder = AMIJpegEncoder::get_instance();
+        yuv = (AMYUVData *)calloc(1, sizeof(AMYUVData));
+        if (!yuv) {
+            LOG_ERROR("malloc yuv failed!\n");
+            result = AM_RESULT_ERR_INVALID;
+            break;
+        }
+
+        if (AM_RESULT_OK != jpeg_encoder->create()) {
+            LOG_ERROR("jpeg_encoder create failed!\n");
+            result = AM_RESULT_ERR_INVALID;
+            break;
+        }
+
+        if (AM_RESULT_OK !=
+                video_reader->query_yuv_frame(frame_desc,
+                                              AM_SOURCE_BUFFER_ID(stream_id),
+                                              false)) {
+            result = AM_RESULT_ERR_INVALID;
+            LOG_ERROR("query yuv frame failed \n");
+            break;
+        }
+
+        if (AM_RESULT_OK != video_address->yuv_y_addr_get(frame_desc, yaddr)) {
+            result = AM_RESULT_ERR_INVALID;
+            LOG_ERROR("Failed to get y address!");
+            break;
+        }
+
+        if (AM_RESULT_OK != video_address->yuv_uv_addr_get(frame_desc,
+                                                           uvaddr)) {
+            result = AM_RESULT_ERR_INVALID;
+            LOG_ERROR("Failed to get uv address!");
+            break;
+        }
+        LOG_DEBUG("yaddr: %p, max_size: %u, offset: %u\n",
+                  (void*) yaddr.data, yaddr.max_size, yaddr.offset);
+        LOG_DEBUG("uvaddr: %p, max_size: %u, offset: %u\n",
+                  (void*) uvaddr.data, uvaddr.max_size, uvaddr.offset);
+        LOG_DEBUG("frame desc, height: %u, width: %u, "
+                  "y_offset: %u, uv_offset: %u, "
+                  "pitch: %u, seq_num: %u\n",
+                  frame_desc.yuv.height, frame_desc.yuv.width,
+                  frame_desc.yuv.y_offset, frame_desc.yuv.uv_offset,
+                  frame_desc.yuv.pitch, frame_desc.yuv.seq_num);
+
+        if((frame_desc.yuv.format == AM_CHROMA_FORMAT_YUV420)
+            && (BPI_ROTATION_TYPE_NONE != m_rotation)){
+            rotate_addr = (uint8_t*)malloc(
+                frame_desc.yuv.width * frame_desc.yuv.height*3/2);
+            if(!rotate_addr){
+                LOG_ERROR("malloc rotate_addr failed!\n");
+                result = AM_RESULT_ERR_INVALID;
+                break;
+            }
+            if((m_rotation == BPI_ROTATION_TYPE_90)
+                || (m_rotation == BPI_ROTATION_TYPE_270)){
+                yuv->width = frame_desc.yuv.height;
+                yuv->height = frame_desc.yuv.width;
+                yuv->pitch = frame_desc.yuv.height;
+                yuv->format = frame_desc.yuv.format;
+            }else{
+                yuv->width = frame_desc.yuv.width;
+                yuv->height = frame_desc.yuv.height;
+                yuv->pitch = frame_desc.yuv.width;
+                yuv->format = frame_desc.yuv.format;
+            }
+            BPIYUVRotate::BPIYUV420Rotate(rotate_addr,
+                                          yaddr.data,
+                                          uvaddr.data,
+                                          frame_desc.yuv.width,
+                                          frame_desc.yuv.height,
+                                          frame_desc.yuv.pitch,
+                                          m_rotation);
+            yuv->y_addr = rotate_addr;
+            yuv->uv_addr = rotate_addr
+                           + frame_desc.yuv.width * frame_desc.yuv.height;
+        }else{
+            yuv->width = frame_desc.yuv.width;
+            yuv->height = frame_desc.yuv.height;
+            yuv->pitch = frame_desc.yuv.pitch;
+            yuv->format = frame_desc.yuv.format;
+            yuv->y_addr = yaddr.data;
+            yuv->uv_addr = uvaddr.data;
+        }
+
+        jpeg = jpeg_encoder->new_jpeg_data(yuv->width, yuv->height);
+
+        if (!jpeg) {
+            LOG_ERROR("new_jpeg_buf failed!\n");
+            result = AM_RESULT_ERR_INVALID;
+            break;
+        }
+
+        if (AM_RESULT_OK != jpeg_encoder->encode_yuv(yuv, jpeg)) {
+            LOG_ERROR("jpeg encode failed!\n");
+            result = AM_RESULT_ERR_INVALID;
+            break;
+        }
+
+        if (!f.open(AMFile::AM_FILE_CREATE)) {
+            LOG_ERROR("Failed to open file");
+            result = AM_RESULT_ERR_INVALID;
+            break;
+        }
+
+        if (f.write_reliable(jpeg->data.iov_base, jpeg->data.iov_len) < 0) {
+            LOG_ERROR("Failed to sava data into file\n");
+            result = AM_RESULT_ERR_INVALID;
+            break;
+        }
+    } while (0);
+
+    if (rotate_addr) {
+        free(rotate_addr);
+        rotate_addr = nullptr;
+    }
+
+    if (yuv) {
+        free(yuv);
+        yuv = nullptr;
+    }
+
+    if(jpeg){
+        jpeg_encoder->free_jpeg_data(jpeg);
+        jpeg = nullptr;
+    }
+
+    if(nullptr != jpeg_encoder){
+        AM_DESTROY(jpeg_encoder);
+    }
+
+    f.close();
+
+    return (result == AM_RESULT_OK);
+}
+
+void* OryxRecorderWrapper::m_data_handler = nullptr;
+CaptureRoutine OryxRecorderWrapper::s_capture;
+int OryxRecorderWrapper::s_stop_flag = 0;
+
+OryxRecorderWrapper::OryxRecorderWrapper():
+    m_record(nullptr),
+    m_muxer_bitmap(0),
+    m_recording_duration(0),
+    m_file_number(0),
+    m_file_duration(0),
+    m_video_module(nullptr)
+{
+}
+
+OryxRecorderWrapper::~OryxRecorderWrapper()
+{
+}
+
+bool OryxRecorderWrapper::init_recorder(app_conf_t *p_user_conf)
+{
+    AMMuxerParam muxer_param;
+
+    m_video_module = OryxVideoModule::get_instance();
+    if(!m_video_module->start_camera()){
+        LOG_ERROR("Failed to start Video Camera.\n");
+        return false;
+    }
+    m_record = AMIRecord::create();
+    if (!m_record) {
+        LOG_ERROR("Failed to get AMIRecord instance!\n");
+        return false;
+    }
+    if(!m_record->init()){
+        LOG_ERROR("Failed to init AMIRecord instance!\n");
+        return false;
+    }
+    read_sole_config("/tmp/config/etc/bpi/.file_muxer_bitmap",
+                     (void*)&m_muxer_bitmap, sizeof(m_muxer_bitmap));
+    if(0 == p_user_conf->record_control_mode){
+        m_file_duration  = p_user_conf->file_duration;
+        m_recording_duration = p_user_conf->record_duration_after_motion_starts;
+        m_file_number = (m_recording_duration -1 + m_file_duration) / m_file_duration;
+        muxer_param.file_duration_int32.value.v_int32 = m_file_duration;
+        muxer_param.file_duration_int32.is_set = true;
+        muxer_param.recording_duration_u32.value.v_u32 = m_recording_duration;
+        muxer_param.recording_duration_u32.is_set = true;
+        muxer_param.recording_file_num_u32.value.v_u32 = m_file_number;
+        muxer_param.recording_file_num_u32.is_set = true;
+    }
+    muxer_param.muxer_id_bit_map = m_muxer_bitmap;
+    if (!m_record->set_muxer_param(muxer_param)) {
+        LOG_ERROR("Failed to set muxer parameters.\n");
+        return false;
+    }
+
+    AM_FILE_OPERATION_CB_TYPE cb_type;
+    cb_type = (AM_FILE_OPERATION_CB_TYPE)(AM_OPERATION_CB_FILE_CREATE);
+    if(!m_record->set_file_operation_callback(m_muxer_bitmap, cb_type,file_operation_callback)){
+        LOG_ERROR("Failed to set_file_operation_callback -- AM_OPERATION_CB_FILE_CREATE!\n");
+        return false;
+    }
+    cb_type = (AM_FILE_OPERATION_CB_TYPE)(AM_OPERATION_CB_FILE_FINISH);
+    if(!m_record->set_file_operation_callback(m_muxer_bitmap, cb_type,file_operation_callback)){
+        LOG_ERROR("Failed to set_file_operation_callback -- AM_OPERATION_CB_FILE_FINISH!\n");
+        return false;
+    }
+    if(p_user_conf->thumbnail){
+        OryxRecorderWrapper::s_capture.set_rotation(p_user_conf->rotate);
+        OryxRecorderWrapper::s_capture.enable(p_user_conf->storage_folder);
+    }
+
+    m_video_module->start_smart_avc(p_user_conf->smart_avc);
+    m_video_module->start_overlay(p_user_conf->osd_label);
+    m_video_module->start_linux_aaa();
+
+    return true;
+}
+
+bool OryxRecorderWrapper::start_recorder()
+{
+    if(!m_record){
+        return false;
+    }
+
+    if (!m_record->start()) {
+        LOG_ERROR("Failed to start recording!\n");
+        return false;
+    }
+
+    return true;
+}
+
+bool OryxRecorderWrapper::stop_recorder()
+{
+    if (m_record && !m_record->stop()) {
+        LOG_ERROR("Stop recording failed!\n");
+        return false;
+    }
+    m_video_module->stop_smart_avc();
+    m_video_module->stop_overlay();
+    m_video_module->stop_linux_aaa();
+    m_video_module->stop_camera();
+
+    return true;
+}
+
+void OryxRecorderWrapper::set_data_handler(void* p_user_data)
+{
+    if(nullptr != p_user_data){
+        OryxRecorderWrapper::m_data_handler = p_user_data;
+    }
+}
+
+void OryxRecorderWrapper::file_operation_callback(AMRecordFileInfo &file_info){
+    if (file_info.type == AM_RECORD_FILE_FINISH_INFO) {
+        LOG_PRINT("record done -> file name :%s\n", file_info.file_name);
+
+        if (file_info.finish_type == AM_RECORD_FILE_FINISH_REACH_RECORD_DURATION || file_info.finish_type == AM_RECORD_FILE_FINISH_REACH_RECORD_FILE_NUM) {
+            OryxRecorderWrapper::s_stop_flag = 1;
+        }
+
+        if(0 == file_info.stream_id && OryxRecorderWrapper::m_data_handler){
+            BPI_Upload_Task upload_task;
+            BPIUploader* uploader =
+                (BPIUploader*)(OryxRecorderWrapper::m_data_handler);
+            if(!uploader) return;
+            strcpy(upload_task.file_name, file_info.file_name);
+            strcpy(upload_task.device_id, get_device_id());
+            upload_task.dual_stream_id = file_info.stream_id;
+            upload_task.create_time = get_time_from_name(file_info.file_name);
+            upload_task.file_index = get_num_from_tail(file_info.file_name);
+            if(-1 == upload_task.create_time){
+                LOG_ERROR("skip illegal named file %s!\n", file_info.file_name);
+            }else{
+                uploader->addTask(upload_task);
+            }
+        }
+    }
+    else if(file_info.type == AM_RECORD_FILE_CREATE_INFO){
+        LOG_PRINT("record started -> file name :%s\n", file_info.file_name);
+        if(0 == file_info.stream_id){
+            string snap_file(file_info.file_name);
+            if(OryxRecorderWrapper::s_capture.rename_file(snap_file)){
+                LOG_DEBUG("thumbnail captured %s!\n", snap_file.c_str());
+                OryxRecorderWrapper::s_capture.disable();
+                if(OryxRecorderWrapper::m_data_handler){
+                    BPIUploader* uploader =
+                        (BPIUploader*)(OryxRecorderWrapper::m_data_handler);
+                    BPI_Upload_Task upload_task;
+                    strcpy(upload_task.file_name, snap_file.c_str());
+                    strcpy(upload_task.device_id, get_device_id());
+                    upload_task.dual_stream_id = file_info.stream_id;
+                    upload_task.create_time = get_time_from_name(snap_file.c_str());
+                    upload_task.file_index = get_num_from_tail(snap_file.c_str());
+                    uploader->addTask(upload_task);
+                }
+            }
+        }
+    }
+}
diff --git a/fastboot_app/bpi_app/bpi_oryx_export.h b/fastboot_app/bpi_app/bpi_oryx_export.h
new file mode 100644
index 0000000..827aba1
--- /dev/null
+++ b/fastboot_app/bpi_app/bpi_oryx_export.h
@@ -0,0 +1,82 @@
+/*******************************************************************************
+ * bpi_oryx_export.h
+ *
+ * History:
+ *   2017-01-17 - [Jian Liu]      created file
+ *
+ * Copyright (c) 2017 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+#ifndef BPI_ORYX_EXPORT_H_
+#define BPI_ORYX_EXPORT_H_
+
+#include <string>
+#include "bpi_app_config.h"
+#include "bpi_typedefs.h"
+#include "am_record_if.h"
+
+class OryxVideoModule;
+class CaptureRoutine{
+public:
+    CaptureRoutine();
+    void set_rotation(BPI_ROTATION_TYPE _rotation);
+    void enable(const char *storage_folder);
+    void disable();
+    bool rename_file(std::string &target_name);
+    ~CaptureRoutine();
+private:
+    bool parse_filename(std::string &file_name);
+    bool capture(int stream_id, const char* file_name);
+    BPI_ROTATION_TYPE m_rotation;
+    bool m_enable;
+    std::string m_file_name;
+    std::string m_file_base;
+};
+
+class OryxRecorderWrapper{
+public:
+    OryxRecorderWrapper();
+    ~OryxRecorderWrapper();
+    bool init_recorder(app_conf_t *p_user_conf);
+    bool start_recorder();
+    bool stop_recorder();
+    void set_data_handler(void* p_user_data);
+
+    static void file_operation_callback(AMRecordFileInfo &file_info);
+    static void* m_data_handler;
+    static int s_stop_flag;
+private:
+    static CaptureRoutine s_capture;
+    AMIRecordPtr m_record;
+    unsigned int m_muxer_bitmap;
+    int m_recording_duration;
+    int m_file_number;
+    int m_file_duration;
+    OryxVideoModule *m_video_module;
+};
+
+
+#endif
+
diff --git a/fastboot_app/bpi_app/bpi_typedefs.h b/fastboot_app/bpi_app/bpi_typedefs.h
new file mode 100644
index 0000000..314d76c
--- /dev/null
+++ b/fastboot_app/bpi_app/bpi_typedefs.h
@@ -0,0 +1,178 @@
+/*
+ * bpi_typedef.h
+ *
+ * History:
+ *       2015/01/14 - [Chu Chen] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __BPI_TYPEDEFS_H_
+#define __BPI_TYPEDEFS_H_
+#include <stdint.h>
+
+typedef enum {
+    EChrg_ChrgFull = 0,
+    EChrg_Charging,
+    EChrg_Discharging,
+} EChrg;
+
+typedef enum {
+    EDC_Plugin = 0,
+    EDC_Unplugged,
+} EDC;
+
+typedef enum {
+    EPIR_ON = 0,
+    EPIR_OFF,
+} EPIR;
+
+typedef enum {
+    EBattery_Low = 0,
+    EBattery_Empty,
+    EBattery_Normal,
+} EBattery;
+
+//MCU TRIGGER/CMD/MSG typedefs
+enum MCU_TRIGGER_TYPE{//max trigger number = 0x0F
+    MCU_TRIGGER_BASE = 0x00,
+
+    MCU_TRIGGER_PIR_ON,
+    MCU_TRIGGER_WIFI_WAKEUP,
+    MCU_TRIGGER_WIFI_RECONNECT,
+    MCU_TRIGGER_PWR,
+    MCU_TRIGGER_PWR_2S,
+    MCU_TRIGGER_POWER_EMPTY,
+
+    //add more trigger here
+
+    MCU_TRIGGER_END = MCU_TRIGGER_BASE + 0x10
+};
+
+enum MCU_CMD_TYPE{//max command number = 0x7F
+    MCU_CMD_BASE = MCU_TRIGGER_END,
+
+    MCU_CMD_GET_TRIGGER_EVENT,
+    MCU_CMD_GET_RACE_TRIGGER_EVENT,
+
+    MCU_CMD_LED_RED_ON,
+    MCU_CMD_LED_RED_OFF,
+    MCU_CMD_LED_GREEN_ON,
+    MCU_CMD_LED_GREEN_OFF,
+    MCU_CMD_LED_RED_BLINK,
+    MCU_CMD_LED_GREEN_BLINK,
+
+    MCU_CMD_GET_TIME_COST,
+
+    MCU_CMD_SET_STRESS_TEST_MODE,
+    MCU_CMD_SET_NORMAL_MODE,
+
+    MCU_CMD_GET_VERSION,//return the MCU_CMD_GET_VERSION + Main version + Subversion
+    MCU_CMD_NETWORK_NEED_REBUILD,
+    MCU_CMD_POWEROFF_CPU_DRAM,
+    MCU_CMD_IMAGE_UPGRADE,
+
+    //add more cmd here
+
+    MCU_CMD_END= MCU_CMD_BASE + 0x8F
+};
+
+enum MCU_EVENT_TYPE{//max event number = 0x70
+    MCU_EVENT_BASE = MCU_CMD_END,
+
+    MCU_EVENT_PIR_ON,
+    MCU_EVENT_PIR_OFF,
+
+    MCU_EVENT_BATTERY_EMPTY,
+    MCU_EVENT_BATTERY_LOW,
+    MCU_EVENT_BATTERY_NORMAL,
+    MCU_EVENT_BATTERY_CHARGE_OFF,
+    MCU_EVENT_BATTERY_CHARGE_ON,
+    MCU_EVENT_BATTERY_CHARGE_DONE,
+
+    MCU_EVENT_DC_ON,
+    MCU_EVENT_DC_OFF,
+
+    //add more event here
+    MCU_EVENT_PWR,
+
+    MCU_EVENT_TIME_COST = MCU_CMD_GET_TIME_COST,
+    MCU_EVENT_RACE_TRIGGER_EVENT = MCU_CMD_GET_RACE_TRIGGER_EVENT,
+    MCU_EVENT_VERSION = MCU_CMD_GET_VERSION,
+
+    MCU_EVENT_END = 0xFF
+};
+
+typedef enum {
+    AM_BPI_MODE_UNKNOWN = 0,
+    AM_BPI_MODE_RECORDING = 1,
+    AM_BPI_MODE_STREAMING = 2,
+    AM_BPI_MODE_WLAN_CONFIG = 3,
+    AM_BPI_MODE_WLAN_RECONNECT = 4,
+    AM_BPI_MODE_NOTIFY = 5,
+    /*add more mode here*/
+    AM_BPI_MODE_DEBUG = AM_BPI_MODE_UNKNOWN + 0x10,
+} AM_BPI_MODE;
+
+typedef struct {
+   uint8_t index;
+   uint8_t bpi_mode;
+   uint8_t reserved0;
+   uint8_t reserved1;
+} AM_BPI_MODE_MAP;
+
+typedef enum
+{
+    BPI_VIDEO_CODEC_NONE = 0,
+    BPI_VIDEO_CODEC_H264,
+    BPI_VIDEO_CODEC_H265,
+    BPI_VIDEO_CODEC_MJPEG,
+} BPI_VIDEO_CODEC_TYPE;
+
+typedef enum
+{
+    BPI_AUDIO_CODEC_AAC = 0,
+    BPI_AUDIO_CODEC_G711,
+    BPI_AUDIO_CODEC_G726,
+    BPI_AUDIO_CODEC_G711A,
+    BPI_AUDIO_CODEC_G711MU,
+} BPI_AUDIO_CODEC_TYPE;
+
+typedef enum
+{
+    BPI_FILE_MUXER_MP4 = 0,
+    BPI_FILE_MUXER_TS,
+} BPI_FILE_MUXER_TYPE;
+
+typedef enum
+{
+    BPI_ROTATION_TYPE_NONE = 0,
+    BPI_ROTATION_TYPE_90,
+    BPI_ROTATION_TYPE_180,
+    BPI_ROTATION_TYPE_270,
+} BPI_ROTATION_TYPE;
+
+#endif
\ No newline at end of file
diff --git a/fastboot_app/bpi_app/bpi_uploader.cpp b/fastboot_app/bpi_app/bpi_uploader.cpp
new file mode 100644
index 0000000..1cce3d2
--- /dev/null
+++ b/fastboot_app/bpi_app/bpi_uploader.cpp
@@ -0,0 +1,306 @@
+/*
+ * bpi_uploader.cpp
+ *
+ * History:
+ *       2016/07/15 - [Zhipeng Dong] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <unistd.h>
+#include <stdio.h>
+#include <curl/curl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <dirent.h>
+#include <regex>
+
+#include "bpi_typedefs.h"
+#include "bpi_app_config.h"
+#include "bpi_uploader.h"
+#include "bpi_utils.h"
+using std::string;
+using std::regex;
+using std::smatch;
+
+BPIUploader::BPIUploader(){
+    pthread_mutex_init(&m_mutex,nullptr);
+    pthread_cond_init(&m_cond,nullptr);
+    m_http_url = nullptr;
+    m_pid = 0;
+    m_pid2 = 0;
+}
+
+BPIUploader::~BPIUploader(){
+    pthread_mutex_destroy(&m_mutex);
+    pthread_cond_destroy(&m_cond);
+    if(m_http_url) free(m_http_url);
+}
+
+bool BPIUploader::set_url(const char* url){
+    if(m_http_url) free(m_http_url);
+    m_http_url = strdup(url);
+    return (m_http_url != nullptr);
+}
+
+bool BPIUploader::addTask(BPI_Upload_Task task){
+    pthread_mutex_lock (&m_mutex);
+    task.policy = BPI_UPLOAD_POLICY_FIFO;
+    if(m_new_files_queue.empty()) pthread_cond_signal(&m_cond);
+    m_new_files_queue.push(task);
+    LOG_PRINT("add new file(%s) to uploader\n", task.file_name);
+    pthread_mutex_unlock (&m_mutex);
+    return true;
+}
+
+bool BPIUploader::scan_folder(char* scan_folder){
+    DIR *dp;
+    struct dirent *entry;
+    struct stat statbuf;
+    const regex folder_pattern("\\d+");//oryx record folder name pattern
+    const regex file_pattern("(.*)_(\\d+)_stream0_(\\d+)_(\\d+).(mp4|ts|jpg)");// filename pattern
+    if((dp = opendir(scan_folder)) == nullptr) {
+        return false;
+    }
+    while((entry = readdir(dp)) != nullptr) {
+        string full_path = string(scan_folder) + string(entry->d_name);
+        lstat(full_path.c_str(), &statbuf);
+        if(S_ISDIR(statbuf.st_mode)) {
+            if(regex_match(string(entry->d_name), folder_pattern)){
+                DIR *sub_dp;
+                char sub_folder[512];
+                sprintf(sub_folder, "%s%s", scan_folder, entry->d_name);
+                if((sub_dp = opendir(sub_folder)) == nullptr) {
+                    continue;
+                }
+                while((entry = readdir(sub_dp)) != nullptr) {
+                    full_path = string(sub_folder) + string(entry->d_name);
+                    lstat(full_path.c_str(), &statbuf);
+                    string str(entry->d_name);
+                    if(S_ISREG(statbuf.st_mode)) {
+                        if(regex_match(str, file_pattern)){
+                            BPI_Upload_Task upload_task;
+                            string file_name = string(sub_folder) + '/' + string(entry->d_name);
+                            memset(&upload_task, 0, sizeof(BPI_Upload_Task));
+                            strcpy(upload_task.file_name, file_name.c_str());
+                            upload_task.create_time =get_time_from_name(entry->d_name);
+                            upload_task.policy = BPI_UPLOAD_POLICY_LATEST_FIRST;
+                            upload_task.dual_stream_id = get_id_from_name(entry->d_name);
+                            strcpy(upload_task.device_id, get_device_id());
+                            LOG_PRINT("add old file(%s) to uploader\n", upload_task.file_name);
+                            m_old_files_queue.push(upload_task);
+                        }
+                    }
+                }
+                closedir(sub_dp);
+            }
+        }
+    }
+    closedir(dp);
+    return true;
+}
+
+static size_t curl_read_cb(void *buffer, size_t size, size_t nmemb, void *instream){
+    FILE *fd = (FILE*)instream;
+    return fread(buffer, size, nmemb, fd);
+}
+
+bool BPIUploader::upload(BPI_Upload_Task* upload_task){
+    FILE* p_file = fopen(upload_task->file_name, "rb");
+    if (nullptr == p_file) {
+        return false;
+    }
+    bool transfer_ok = false;
+    CURL *curl = nullptr;
+    char event_type[10];
+    char event_id[64];
+    char event_num[64];
+    struct curl_httppost *formpost = nullptr;
+    struct curl_httppost *lastptr = nullptr;
+    struct curl_slist *headerlist = nullptr;
+    static const char buf[] = "Expect:";
+    if(strstr(upload_task->file_name,".mp4") || strstr(upload_task->file_name,".ts")){
+        strcpy(event_type, "0");
+    }else if(strstr(upload_task->file_name,".jpg")){
+        strcpy(event_type, "1");
+    }else{
+        strcpy(event_type, "unknown");
+    }
+    snprintf(event_id, sizeof(event_id),"%u",(unsigned int)upload_task->create_time);
+    snprintf(event_num,sizeof(event_num),"%u",(unsigned int)upload_task->file_index);
+
+    do{
+        LOG_PRINT("start to upload --> %s\n", upload_task->file_name);
+        curl = curl_easy_init();
+        if(curl) {
+            /* Fill in the file upload field. This makes libcurl load data from
+             the given file name when curl_easy_perform() is called. */
+            curl_formadd(&formpost, &lastptr, CURLFORM_PTRNAME, "reqformat", CURLFORM_PTRCONTENTS, "plain", CURLFORM_END);
+            curl_formadd(&formpost, &lastptr, CURLFORM_PTRNAME, "file", CURLFORM_FILE, upload_task->file_name, CURLFORM_END);
+            curl_formadd(&formpost, &lastptr, CURLFORM_PTRNAME, "device_id", CURLFORM_PTRCONTENTS, upload_task->device_id, CURLFORM_END);
+            curl_formadd(&formpost, &lastptr, CURLFORM_PTRNAME, "event_type", CURLFORM_PTRCONTENTS, event_type, CURLFORM_END);
+            curl_formadd(&formpost, &lastptr, CURLFORM_PTRNAME, "event_id", CURLFORM_PTRCONTENTS, event_id, CURLFORM_END);
+            curl_formadd(&formpost, &lastptr, CURLFORM_PTRNAME, "event_num", CURLFORM_PTRCONTENTS, event_num, CURLFORM_END);
+            curl_formadd(&formpost, &lastptr, CURLFORM_PTRNAME, "event_detail", CURLFORM_PTRCONTENTS, upload_task->file_name, CURLFORM_END);
+
+            /* what URL that receives this POST */
+            curl_easy_setopt(curl, CURLOPT_URL, m_http_url);
+            curl_easy_setopt(curl, CURLOPT_HTTPPOST, formpost);
+            curl_easy_setopt(curl, CURLOPT_READDATA, p_file);
+            curl_easy_setopt(curl, CURLOPT_READFUNCTION, &curl_read_cb);
+
+            /*initalize custom header list (stating that Expect: 100-continue is not
+             wanted */
+            headerlist = curl_slist_append(headerlist, buf);
+            curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headerlist);
+            curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1L);
+
+            CURLcode retcode = curl_easy_perform(curl);
+            if(CURLE_OK == retcode){
+                smatch match;
+                char uploaded_filename[256];
+                char cmd[1024];
+                const regex ftype_pattern(".(mp4|ts|jpg)");//record file filename pattern
+                string tmp_str(upload_task->file_name);
+                regex_search(tmp_str, match, ftype_pattern);
+                if(match.ready()){
+                    snprintf(uploaded_filename, sizeof(uploaded_filename), "%s_uploaded%s\n", match.prefix().str().c_str(), match[0].str().c_str());
+                    snprintf(cmd, sizeof(cmd), "mv %s %s\n", upload_task->file_name, uploaded_filename);
+                    system(cmd);
+                }
+                transfer_ok = true;
+                LOG_PRINT("upload success --> %s\n", upload_task->file_name);
+            }else{
+                LOG_ERROR("upload failed, try again later, curl ret code:%d\n", retcode);
+                sleep(5);
+            }
+        }
+    }while(0);
+
+    if(curl) curl_easy_cleanup(curl);
+    if(formpost) curl_formfree(formpost);//then cleanup the formpost chain
+    if(headerlist) curl_slist_free_all(headerlist);//free slist
+    fclose(p_file);
+    return transfer_ok;
+}
+
+void* BPIUploader::on_new_files(void *arg){
+    BPIUploader* pUploader = (BPIUploader*)arg;
+    while (true) {
+        pthread_mutex_lock (&pUploader->m_mutex);
+        if(pUploader->m_new_files_queue.empty()){
+            pthread_cond_wait(&pUploader->m_cond, &pUploader->m_mutex);
+        }
+        BPI_Upload_Task task = pUploader->m_new_files_queue.top();
+        pUploader->m_new_files_queue.pop();
+        pthread_mutex_unlock (&pUploader->m_mutex);
+        if(-1 == task.file_index) {
+            LOG_PRINT("uploader exited!!\n");
+            break;
+        }
+
+        if(0 != access(task.file_name, F_OK)) {
+            LOG_ERROR("file(%s) not exist, skip it\n", task.file_name);
+            continue;
+        }
+
+        if(false == pUploader->upload(&task)){
+            pthread_mutex_lock (&pUploader->m_mutex);
+            if(pUploader->m_new_files_queue.empty()) pthread_cond_signal(&pUploader->m_cond);
+            pUploader->m_new_files_queue.push(task);
+            pthread_mutex_unlock (&pUploader->m_mutex);
+        }
+   }
+   pthread_exit(0);
+}
+
+void* BPIUploader::on_old_files(void *arg){
+    BPIUploader* pUploader = (BPIUploader*)arg;
+    while (!pUploader->m_old_files_queue.empty() && pUploader->m_pid) {
+        BPI_Upload_Task task = pUploader->m_old_files_queue.top();
+        pUploader->m_old_files_queue.pop();
+        if(0 != access(task.file_name, F_OK)) {
+            LOG_ERROR("file(%s) not exist, skip it\n", task.file_name);
+            continue;
+        }
+        if(false == pUploader->upload(&task)){
+            pUploader->m_old_files_queue.push(task);
+        }
+   }
+   pthread_exit(0);
+}
+
+bool BPIUploader::start(){
+    if(0 != pthread_create(&m_pid, nullptr, on_new_files, this)){
+        return false;
+    }
+    if(!m_old_files_queue.empty()){
+        if(0 != pthread_create(&m_pid2, nullptr, on_old_files, this)){
+            return false;
+        }
+    }
+    return true;
+}
+
+bool BPIUploader::stop(){
+    if(m_pid) {
+        BPI_Upload_Task stop_task;
+        memset(&stop_task, 0, sizeof(BPI_Upload_Task));
+        stop_task.highest_priority = true;
+        stop_task.file_index = -1;
+        addTask(stop_task);
+        pthread_join(m_pid, nullptr);
+        m_pid = 0;
+    }
+    if(m_pid2) pthread_join(m_pid2, nullptr);
+    while(!m_old_files_queue.empty()){
+        m_old_files_queue.pop();
+    }
+    while(!m_new_files_queue.empty()){
+        m_new_files_queue.pop();
+    }
+    return true;
+}
+
+bool BPIUploader::wait_jobs_done(int timeout_sec){
+    bool all_task_done = false;
+    while(1){
+        pthread_mutex_lock (&m_mutex);
+        all_task_done = m_new_files_queue.empty();
+        pthread_mutex_unlock (&m_mutex);
+        if(all_task_done){
+            break;
+        }else if(timeout_sec > 0){
+            sleep(1);
+            timeout_sec--;
+            continue;
+        }else{
+            break;
+        }
+    }
+
+    return all_task_done;
+}
diff --git a/fastboot_app/bpi_app/bpi_uploader.h b/fastboot_app/bpi_app/bpi_uploader.h
new file mode 100644
index 0000000..722d8f0
--- /dev/null
+++ b/fastboot_app/bpi_app/bpi_uploader.h
@@ -0,0 +1,124 @@
+/*
+ * bpi_uploader.h
+ *
+ * History:
+ *       2016/07/15 - [Zhipeng Dong] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __BPI_UPLOADER_H_
+#define __BPI_UPLOADER_H_
+#include <queue>
+#include <pthread.h>
+#include <time.h>
+#include <string.h>
+#include <memory.h>
+using std::priority_queue;
+using std::vector;
+
+enum BPI_UPLOADER_POLICY {
+    BPI_UPLOAD_POLICY_FIFO,
+    BPI_UPLOAD_POLICY_LATEST_FIRST,
+    BPI_UPLOAD_POLICY_BY_TIME,
+};
+
+struct BPI_Upload_Task
+{
+    char file_name[512];
+    char device_id[128];
+    time_t create_time;
+    int file_index;
+    int dual_stream_id;
+    BPI_UPLOADER_POLICY policy;
+    bool highest_priority;
+    BPI_Upload_Task() :
+        create_time(0),
+        file_index(-1),
+        dual_stream_id(-1),
+        policy(BPI_UPLOAD_POLICY_FIFO),
+        highest_priority(false)
+    {
+        memset(file_name, 0, sizeof(file_name));
+        memset(device_id, 0, sizeof(device_id));
+    }
+
+    BPI_Upload_Task(const BPI_Upload_Task& task) :
+        create_time(task.create_time),
+        file_index(task.file_index),
+        dual_stream_id(task.dual_stream_id),
+        policy(task.policy),
+        highest_priority(task.highest_priority)
+    {
+        strcpy(file_name, task.file_name);
+        strcpy(device_id, task.device_id);
+    }
+
+};
+
+struct cmp{
+    bool operator()(const BPI_Upload_Task a, const BPI_Upload_Task b)
+    {
+        if(a.highest_priority || b.highest_priority){
+            return !a.highest_priority;
+        }
+        else if(BPI_UPLOAD_POLICY_FIFO == a.policy){
+            return false;
+        }
+        else if(BPI_UPLOAD_POLICY_BY_TIME == a.policy){
+            return a.create_time > b.create_time;
+        }
+        else if(BPI_UPLOAD_POLICY_LATEST_FIRST == a.policy){
+            return a.create_time < b.create_time;
+        }
+        return false;
+    }
+};
+
+class BPIUploader{
+public:
+    BPIUploader();
+    ~BPIUploader();
+    bool set_url(const char* url);
+    bool addTask(BPI_Upload_Task task);
+    bool start();
+    bool stop();
+    bool scan_folder(char* scan_folder);
+    bool wait_jobs_done(int timeout_sec);
+
+private:
+    static void* on_old_files(void *arg);
+    static void* on_new_files(void *arg);
+    bool upload(BPI_Upload_Task* task);
+    pthread_t m_pid;
+    pthread_t m_pid2;
+    pthread_cond_t m_cond;
+    pthread_mutex_t  m_mutex;
+    priority_queue<BPI_Upload_Task, vector<BPI_Upload_Task>, cmp> m_old_files_queue;
+    priority_queue<BPI_Upload_Task, vector<BPI_Upload_Task>, cmp> m_new_files_queue;
+    char* m_http_url;
+};
+#endif //__BPI_UPLOADER_H_
diff --git a/fastboot_app/bpi_app/bpi_yuv_rotate.cpp b/fastboot_app/bpi_app/bpi_yuv_rotate.cpp
new file mode 100644
index 0000000..397fe90
--- /dev/null
+++ b/fastboot_app/bpi_app/bpi_yuv_rotate.cpp
@@ -0,0 +1,559 @@
+/*
+ * bpi_yuv_rotate.c
+ *
+ * History:
+ *       2016/09/01 - [ShengJiang] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include "bpi_yuv_rotate.h"
+#include <arm_neon.h>
+#include <string.h>
+
+void BPIYUVRotate::BPIYUV420Rotate(unsigned char* dstImg,
+                                   unsigned char* srcImgY,
+                                   unsigned char* srcImgUV, int width,
+                                   int height, int pitch, int rotate)
+{
+    unsigned char* dstImgTmp = dstImg;
+    unsigned char* srcImgTmpY = srcImgY;
+    unsigned char* srcImgTmpUV = srcImgUV;
+    switch (rotate) {
+    case 1:
+        NeonRotateYUV420Y90(dstImg, srcImgY, width, height, pitch);
+        NeonRotateYUV420UV90(dstImg + width * height, srcImgUV,
+                             width, height / 2, pitch);
+        break;
+    case 2:
+        NeonRotateYUV420Y180(dstImg, srcImgY, width, height, pitch);
+        NeonRotateYUV420UV180(dstImg + width * height, srcImgUV,
+                              width, height / 2, pitch);
+        break;
+    case 3:
+        NeonRotateYUV420Y270(dstImg, srcImgY, width, height, pitch);
+        NeonRotateYUV420UV270(dstImg + width * height, srcImgUV,
+                              width, height / 2, pitch);
+        break;
+    default:
+        for (int i = 0; i < height; i++) {
+            memcpy(dstImgTmp, srcImgTmpY, width);
+            dstImgTmp += width;
+            srcImgTmpY += pitch;
+        }
+        for (int i = 0; i < height / 2; i++) {
+            memcpy(dstImgTmp, srcImgTmpUV, width);
+            dstImgTmp += width;
+            srcImgTmpUV += pitch;
+        }
+        break;
+    }
+}
+
+void BPIYUVRotate::NeonRotateYUV420Y180(unsigned char* dstImg,
+                                        unsigned char* srcImg, int width,
+                                        int height, int pitch)
+{
+    uint8x8x4_t y_mat1; //use 2 register array to load a 8x8 patch
+    uint8x8x4_t y_mat2;
+    for (int i = 0; i < height; i += 8)
+        {
+        for (int j = 0; j < width; j += 8)
+            {
+            //step0 load 8x8 bytes in 8 registers
+            y_mat1.val[0] = vld1_u8(srcImg + i * pitch + j);
+            y_mat1.val[1] = vld1_u8(srcImg + (i + 1) * pitch + j);
+            y_mat1.val[2] = vld1_u8(srcImg + (i + 2) * pitch + j);
+            y_mat1.val[3] = vld1_u8(srcImg + (i + 3) * pitch + j);
+            y_mat2.val[0] = vld1_u8(srcImg + (i + 4) * pitch + j);
+            y_mat2.val[1] = vld1_u8(srcImg + (i + 5) * pitch + j);
+            y_mat2.val[2] = vld1_u8(srcImg + (i + 6) * pitch + j);
+            y_mat2.val[3] = vld1_u8(srcImg + (i + 7) * pitch + j);
+            //step1 reverse every element in a row
+            y_mat1.val[0] = vrev64_u8(y_mat1.val[0]);
+            y_mat1.val[1] = vrev64_u8(y_mat1.val[1]);
+            y_mat1.val[2] = vrev64_u8(y_mat1.val[2]);
+            y_mat1.val[3] = vrev64_u8(y_mat1.val[3]);
+            y_mat2.val[0] = vrev64_u8(y_mat2.val[0]);
+            y_mat2.val[1] = vrev64_u8(y_mat2.val[1]);
+            y_mat2.val[2] = vrev64_u8(y_mat2.val[2]);
+            y_mat2.val[3] = vrev64_u8(y_mat2.val[3]);
+            //step2 store every row in reverse order
+            vst1_u8(dstImg + (height - i - 8) * width + (width - j - 8),
+                    y_mat2.val[3]);
+            vst1_u8(dstImg + (height - i - 7) * width + (width - j - 8),
+                    y_mat2.val[2]);
+            vst1_u8(dstImg + (height - i - 6) * width + (width - j - 8),
+                    y_mat2.val[1]);
+            vst1_u8(dstImg + (height - i - 5) * width + (width - j - 8),
+                    y_mat2.val[0]);
+            vst1_u8(dstImg + (height - i - 4) * width + (width - j - 8),
+                    y_mat1.val[3]);
+            vst1_u8(dstImg + (height - i - 3) * width + (width - j - 8),
+                    y_mat1.val[2]);
+            vst1_u8(dstImg + (height - i - 2) * width + (width - j - 8),
+                    y_mat1.val[1]);
+            vst1_u8(dstImg + (height - i - 1) * width + (width - j - 8),
+                    y_mat1.val[0]);
+        }
+    }
+}
+
+void BPIYUVRotate::NeonRotateYUV420UV180(unsigned char* dstImg,
+                                         unsigned char* srcImg, int width,
+                                         int height, int pitch)
+{
+    uint8x8x4_t y_mat1; //use 2 register array to load a 8x8 patch
+    uint8x8x4_t y_mat2;
+    for (int i = 0; i < height; i += 8)
+        {
+        for (int j = 0; j < width; j += 8)
+            {
+            //step0 load 8x8 bytes in 8 registers
+            y_mat1.val[0] = vld1_u8(srcImg + i * pitch + j);
+            y_mat1.val[1] = vld1_u8(srcImg + (i + 1) * pitch + j);
+            y_mat1.val[2] = vld1_u8(srcImg + (i + 2) * pitch + j);
+            y_mat1.val[3] = vld1_u8(srcImg + (i + 3) * pitch + j);
+            y_mat2.val[0] = vld1_u8(srcImg + (i + 4) * pitch + j);
+            y_mat2.val[1] = vld1_u8(srcImg + (i + 5) * pitch + j);
+            y_mat2.val[2] = vld1_u8(srcImg + (i + 6) * pitch + j);
+            y_mat2.val[3] = vld1_u8(srcImg + (i + 7) * pitch + j);
+            //step1 reverse every element in a row
+            y_mat1.val[0] = vrev64_u8(y_mat1.val[0]);
+            y_mat1.val[0] = vrev16_u8(y_mat1.val[0]);
+
+            y_mat1.val[1] = vrev64_u8(y_mat1.val[1]);
+            y_mat1.val[1] = vrev16_u8(y_mat1.val[1]);
+
+            y_mat1.val[2] = vrev64_u8(y_mat1.val[2]);
+            y_mat1.val[2] = vrev16_u8(y_mat1.val[2]);
+
+            y_mat1.val[3] = vrev64_u8(y_mat1.val[3]);
+            y_mat1.val[3] = vrev16_u8(y_mat1.val[3]);
+
+            y_mat2.val[0] = vrev64_u8(y_mat2.val[0]);
+            y_mat2.val[0] = vrev16_u8(y_mat2.val[0]);
+
+            y_mat2.val[1] = vrev64_u8(y_mat2.val[1]);
+            y_mat2.val[1] = vrev16_u8(y_mat2.val[1]);
+
+            y_mat2.val[2] = vrev64_u8(y_mat2.val[2]);
+            y_mat2.val[2] = vrev16_u8(y_mat2.val[2]);
+
+            y_mat2.val[3] = vrev64_u8(y_mat2.val[3]);
+            y_mat2.val[3] = vrev16_u8(y_mat2.val[3]);
+            //step2 store every row in reverse order
+            vst1_u8(dstImg + (height - i - 8) * width + (width - j - 8),
+                    y_mat2.val[3]);
+            vst1_u8(dstImg + (height - i - 7) * width + (width - j - 8),
+                    y_mat2.val[2]);
+            vst1_u8(dstImg + (height - i - 6) * width + (width - j - 8),
+                    y_mat2.val[1]);
+            vst1_u8(dstImg + (height - i - 5) * width + (width - j - 8),
+                    y_mat2.val[0]);
+            vst1_u8(dstImg + (height - i - 4) * width + (width - j - 8),
+                    y_mat1.val[3]);
+            vst1_u8(dstImg + (height - i - 3) * width + (width - j - 8),
+                    y_mat1.val[2]);
+            vst1_u8(dstImg + (height - i - 2) * width + (width - j - 8),
+                    y_mat1.val[1]);
+            vst1_u8(dstImg + (height - i - 1) * width + (width - j - 8),
+                    y_mat1.val[0]);
+        }
+    }
+}
+
+void BPIYUVRotate::NeonRotateYUV420Y270(unsigned char* dstImg,
+                                        unsigned char* srcImg, int width,
+                                        int height, int pitch)
+{
+    uint8x8x4_t y_mat1; //use 2 register array to load a 8x8 patch
+    uint8x8x4_t y_mat2;
+
+    uint8x8x2_t temp1;
+    uint8x8x2_t temp2;
+    uint8x8x2_t temp3;
+    uint8x8x2_t temp4;
+
+    uint16x4x2_t temp5;
+    uint16x4x2_t temp6;
+    uint16x4x2_t temp7;
+    uint16x4x2_t temp8;
+    uint16x4x2_t temp9;
+    uint16x4x2_t temp10;
+    uint16x4x2_t temp11;
+    uint16x4x2_t temp12;
+
+    uint32x2x2_t temp13;
+    uint32x2x2_t temp14;
+    uint32x2x2_t temp15;
+    uint32x2x2_t temp16;
+    uint32x2x2_t temp17;
+    uint32x2x2_t temp18;
+    uint32x2x2_t temp19;
+    uint32x2x2_t temp20;
+    for (int i = 0; i < height; i += 8)
+        {
+        for (int j = 0; j < width; j += 8)
+            {
+            //step0 load 8x8 bytes in 8 registers
+            y_mat1.val[0] = vld1_u8(srcImg + i * pitch + j);
+            y_mat1.val[1] = vld1_u8(srcImg + (i + 1) * pitch + j);
+            y_mat1.val[2] = vld1_u8(srcImg + (i + 2) * pitch + j);
+            y_mat1.val[3] = vld1_u8(srcImg + (i + 3) * pitch + j);
+            y_mat2.val[0] = vld1_u8(srcImg + (i + 4) * pitch + j);
+            y_mat2.val[1] = vld1_u8(srcImg + (i + 5) * pitch + j);
+            y_mat2.val[2] = vld1_u8(srcImg + (i + 6) * pitch + j);
+            y_mat2.val[3] = vld1_u8(srcImg + (i + 7) * pitch + j);
+            //step1 trn nearby registers
+            temp1 = vtrn_u8(y_mat1.val[0], y_mat1.val[1]);
+            temp2 = vtrn_u8(y_mat1.val[2], y_mat1.val[3]);
+            temp3 = vtrn_u8(y_mat2.val[0], y_mat2.val[1]);
+            temp4 = vtrn_u8(y_mat2.val[2], y_mat2.val[3]);
+            //step2 trn 1,3 2,4 5,7 6,8
+            temp5.val[0] = vreinterpret_u16_u8(temp1.val[0]);
+            temp5.val[1] = vreinterpret_u16_u8(temp1.val[1]);
+            temp6.val[0] = vreinterpret_u16_u8(temp2.val[0]);
+            temp6.val[1] = vreinterpret_u16_u8(temp2.val[1]);
+            temp7.val[0] = vreinterpret_u16_u8(temp3.val[0]);
+            temp7.val[1] = vreinterpret_u16_u8(temp3.val[1]);
+            temp8.val[0] = vreinterpret_u16_u8(temp4.val[0]);
+            temp8.val[1] = vreinterpret_u16_u8(temp4.val[1]);
+            temp9 = vtrn_u16(temp5.val[0], temp6.val[0]);
+            temp10 = vtrn_u16(temp5.val[1], temp6.val[1]);
+            temp11 = vtrn_u16(temp7.val[0], temp8.val[0]);
+            temp12 = vtrn_u16(temp7.val[1], temp8.val[1]);
+            //step3 trn 1,5 2,6 3,7 4,8
+            temp13.val[0] = vreinterpret_u32_u16(temp9.val[0]);
+            temp13.val[1] = vreinterpret_u32_u16(temp9.val[1]);
+            temp14.val[0] = vreinterpret_u32_u16(temp10.val[0]);
+            temp14.val[1] = vreinterpret_u32_u16(temp10.val[1]);
+            temp15.val[0] = vreinterpret_u32_u16(temp11.val[0]);
+            temp15.val[1] = vreinterpret_u32_u16(temp11.val[1]);
+            temp16.val[0] = vreinterpret_u32_u16(temp12.val[0]);
+            temp16.val[1] = vreinterpret_u32_u16(temp12.val[1]);
+            temp17 = vtrn_u32(temp13.val[0], temp15.val[0]);
+            temp18 = vtrn_u32(temp13.val[1], temp15.val[1]);
+            temp19 = vtrn_u32(temp14.val[0], temp16.val[0]);
+            temp20 = vtrn_u32(temp14.val[1], temp16.val[1]);
+            //step4 store bytes in correct position,the order now is 1,2,3,4,5,6,7,8
+            temp1.val[0] = vreinterpret_u8_u32(temp20.val[1]);
+            temp1.val[1] = vreinterpret_u8_u32(temp18.val[1]);
+            temp2.val[0] = vreinterpret_u8_u32(temp19.val[1]);
+            temp2.val[1] = vreinterpret_u8_u32(temp17.val[1]);
+            temp3.val[0] = vreinterpret_u8_u32(temp20.val[0]);
+            temp3.val[1] = vreinterpret_u8_u32(temp18.val[0]);
+            temp4.val[0] = vreinterpret_u8_u32(temp19.val[0]);
+            temp4.val[1] = vreinterpret_u8_u32(temp17.val[0]);
+            vst1_u8(dstImg + (width - j - 8) * height + i, temp1.val[0]);
+            vst1_u8(dstImg + (width - j - 7) * height + i, temp1.val[1]);
+            vst1_u8(dstImg + (width - j - 6) * height + i, temp2.val[0]);
+            vst1_u8(dstImg + (width - j - 5) * height + i, temp2.val[1]);
+            vst1_u8(dstImg + (width - j - 4) * height + i, temp3.val[0]);
+            vst1_u8(dstImg + (width - j - 3) * height + i, temp3.val[1]);
+            vst1_u8(dstImg + (width - j - 2) * height + i, temp4.val[0]);
+            vst1_u8(dstImg + (width - j - 1) * height + i, temp4.val[1]);
+        }
+    }
+}
+
+void BPIYUVRotate::NeonRotateYUV420UV270(unsigned char* dstImg,
+                                         unsigned char* srcImg, int width,
+                                         int height, int pitch)
+{
+    uint8x8x4_t y_mat1; //use 2 register array to load a 8x8 patch
+    uint8x8x4_t y_mat2;
+
+    uint8x8x2_t temp1;
+    uint8x8x2_t temp2;
+    uint8x8x2_t temp3;
+    uint8x8x2_t temp4;
+
+    uint16x4x2_t temp5;
+    uint16x4x2_t temp6;
+    uint16x4x2_t temp7;
+    uint16x4x2_t temp8;
+    uint16x4x2_t temp9;
+    uint16x4x2_t temp10;
+    uint16x4x2_t temp11;
+    uint16x4x2_t temp12;
+
+    uint32x2x2_t temp13;
+    uint32x2x2_t temp14;
+    uint32x2x2_t temp15;
+    uint32x2x2_t temp16;
+    uint32x2x2_t temp17;
+    uint32x2x2_t temp18;
+    uint32x2x2_t temp19;
+    uint32x2x2_t temp20;
+    for (int i = 0; i < height; i += 8)
+        {
+        for (int j = 0; j < width; j += 8)
+            {
+            //step0 load 8x8 bytes in 8 registers
+            y_mat1.val[0] = vld1_u8(srcImg + i * pitch + j);
+            y_mat1.val[1] = vld1_u8(srcImg + (i + 1) * pitch + j);
+            y_mat1.val[2] = vld1_u8(srcImg + (i + 2) * pitch + j);
+            y_mat1.val[3] = vld1_u8(srcImg + (i + 3) * pitch + j);
+            y_mat2.val[0] = vld1_u8(srcImg + (i + 4) * pitch + j);
+            y_mat2.val[1] = vld1_u8(srcImg + (i + 5) * pitch + j);
+            y_mat2.val[2] = vld1_u8(srcImg + (i + 6) * pitch + j);
+            y_mat2.val[3] = vld1_u8(srcImg + (i + 7) * pitch + j);
+            //step1 trn nearby registers
+            temp1 = vtrn_u8(y_mat1.val[0], y_mat1.val[1]);
+            temp2 = vtrn_u8(y_mat1.val[2], y_mat1.val[3]);
+            temp3 = vtrn_u8(y_mat2.val[0], y_mat2.val[1]);
+            temp4 = vtrn_u8(y_mat2.val[2], y_mat2.val[3]);
+            //step2 trn 1,3 2,4 5,7 6,8
+            temp5.val[0] = vreinterpret_u16_u8(temp1.val[0]);
+            temp5.val[1] = vreinterpret_u16_u8(temp1.val[1]);
+            temp6.val[0] = vreinterpret_u16_u8(temp2.val[0]);
+            temp6.val[1] = vreinterpret_u16_u8(temp2.val[1]);
+            temp7.val[0] = vreinterpret_u16_u8(temp3.val[0]);
+            temp7.val[1] = vreinterpret_u16_u8(temp3.val[1]);
+            temp8.val[0] = vreinterpret_u16_u8(temp4.val[0]);
+            temp8.val[1] = vreinterpret_u16_u8(temp4.val[1]);
+            temp9 = vtrn_u16(temp5.val[0], temp6.val[0]);
+            temp10 = vtrn_u16(temp5.val[1], temp6.val[1]);
+            temp11 = vtrn_u16(temp7.val[0], temp8.val[0]);
+            temp12 = vtrn_u16(temp7.val[1], temp8.val[1]);
+            //step3 trn 1,5 2,6 3,7 4,8
+            temp13.val[0] = vreinterpret_u32_u16(temp9.val[0]);
+            temp13.val[1] = vreinterpret_u32_u16(temp9.val[1]);
+            temp14.val[0] = vreinterpret_u32_u16(temp10.val[0]);
+            temp14.val[1] = vreinterpret_u32_u16(temp10.val[1]);
+            temp15.val[0] = vreinterpret_u32_u16(temp11.val[0]);
+            temp15.val[1] = vreinterpret_u32_u16(temp11.val[1]);
+            temp16.val[0] = vreinterpret_u32_u16(temp12.val[0]);
+            temp16.val[1] = vreinterpret_u32_u16(temp12.val[1]);
+            temp17 = vtrn_u32(temp13.val[0], temp15.val[0]);
+            temp18 = vtrn_u32(temp13.val[1], temp15.val[1]);
+            temp19 = vtrn_u32(temp14.val[0], temp16.val[0]);
+            temp20 = vtrn_u32(temp14.val[1], temp16.val[1]);
+            //step4 store bytes in correct position,the order now is 1,2,3,4,5,6,7,8
+            temp1.val[0] = vreinterpret_u8_u32(temp18.val[1]);
+            temp1.val[1] = vreinterpret_u8_u32(temp20.val[1]);
+            temp2.val[0] = vreinterpret_u8_u32(temp17.val[1]);
+            temp2.val[1] = vreinterpret_u8_u32(temp19.val[1]);
+            temp3.val[0] = vreinterpret_u8_u32(temp18.val[0]);
+            temp3.val[1] = vreinterpret_u8_u32(temp20.val[0]);
+            temp4.val[0] = vreinterpret_u8_u32(temp17.val[0]);
+            temp4.val[1] = vreinterpret_u8_u32(temp19.val[0]);
+            vst2_u8(dstImg + ((width / 2 - 4 - j / 2) * height * 2 + i * 2),
+                    temp1);
+            vst2_u8(dstImg + ((width / 2 - 3 - j / 2) * height * 2 + i * 2),
+                    temp2);
+            vst2_u8(dstImg + ((width / 2 - 2 - j / 2) * height * 2 + i * 2),
+                    temp3);
+            vst2_u8(dstImg + ((width / 2 - 1 - j / 2) * height * 2 + i * 2),
+                    temp4);
+        }
+    }
+}
+
+void BPIYUVRotate::NeonRotateYUV420Y90(unsigned char* dstImg,
+                                       unsigned char* srcImg, int width,
+                                       int height, int pitch)
+{
+    uint8x8x4_t mat1; //use 2 register array to load a 8x8 patch
+    uint8x8x4_t mat2;
+
+    uint8x8x2_t temp1;
+    uint8x8x2_t temp2;
+    uint8x8x2_t temp3;
+    uint8x8x2_t temp4;
+
+    uint16x4x2_t temp5;
+    uint16x4x2_t temp6;
+    uint16x4x2_t temp7;
+    uint16x4x2_t temp8;
+    uint16x4x2_t temp9;
+    uint16x4x2_t temp10;
+    uint16x4x2_t temp11;
+    uint16x4x2_t temp12;
+
+    uint32x2x2_t temp13;
+    uint32x2x2_t temp14;
+    uint32x2x2_t temp15;
+    uint32x2x2_t temp16;
+    uint32x2x2_t temp17;
+    uint32x2x2_t temp18;
+    uint32x2x2_t temp19;
+    uint32x2x2_t temp20;
+    for (int i = 0; i < height; i += 8)
+        {
+        for (int j = 0; j < width; j += 8)
+            {
+            //step0 load 8x8 bytes in 8 registers
+            mat1.val[0] = vld1_u8(srcImg + i * pitch + j);
+            mat1.val[1] = vld1_u8(srcImg + (i + 1) * pitch + j);
+            mat1.val[2] = vld1_u8(srcImg + (i + 2) * pitch + j);
+            mat1.val[3] = vld1_u8(srcImg + (i + 3) * pitch + j);
+            mat2.val[0] = vld1_u8(srcImg + (i + 4) * pitch + j);
+            mat2.val[1] = vld1_u8(srcImg + (i + 5) * pitch + j);
+            mat2.val[2] = vld1_u8(srcImg + (i + 6) * pitch + j);
+            mat2.val[3] = vld1_u8(srcImg + (i + 7) * pitch + j);
+            //step1 trn nearby registers
+            temp1 = vtrn_u8(mat1.val[1], mat1.val[0]);
+            temp2 = vtrn_u8(mat1.val[3], mat1.val[2]);
+            temp3 = vtrn_u8(mat2.val[1], mat2.val[0]);
+            temp4 = vtrn_u8(mat2.val[3], mat2.val[2]);
+            //step2 trn 1,3 2,4 5,7 6,8
+            temp5.val[0] = vreinterpret_u16_u8(temp1.val[0]);
+            temp5.val[1] = vreinterpret_u16_u8(temp1.val[1]);
+            temp6.val[0] = vreinterpret_u16_u8(temp2.val[0]);
+            temp6.val[1] = vreinterpret_u16_u8(temp2.val[1]);
+            temp7.val[0] = vreinterpret_u16_u8(temp3.val[0]);
+            temp7.val[1] = vreinterpret_u16_u8(temp3.val[1]);
+            temp8.val[0] = vreinterpret_u16_u8(temp4.val[0]);
+            temp8.val[1] = vreinterpret_u16_u8(temp4.val[1]);
+            temp9 = vtrn_u16(temp6.val[0], temp5.val[0]);
+            temp10 = vtrn_u16(temp6.val[1], temp5.val[1]);
+            temp11 = vtrn_u16(temp8.val[0], temp7.val[0]);
+            temp12 = vtrn_u16(temp8.val[1], temp7.val[1]);
+            //step3 trn 1,5 2,6 3,7 4,8
+            temp13.val[0] = vreinterpret_u32_u16(temp9.val[0]);
+            temp13.val[1] = vreinterpret_u32_u16(temp9.val[1]);
+            temp14.val[0] = vreinterpret_u32_u16(temp10.val[0]);
+            temp14.val[1] = vreinterpret_u32_u16(temp10.val[1]);
+            temp15.val[0] = vreinterpret_u32_u16(temp11.val[0]);
+            temp15.val[1] = vreinterpret_u32_u16(temp11.val[1]);
+            temp16.val[0] = vreinterpret_u32_u16(temp12.val[0]);
+            temp16.val[1] = vreinterpret_u32_u16(temp12.val[1]);
+            temp17 = vtrn_u32(temp15.val[0], temp13.val[0]);
+            temp18 = vtrn_u32(temp15.val[1], temp13.val[1]);
+            temp19 = vtrn_u32(temp16.val[0], temp14.val[0]);
+            temp20 = vtrn_u32(temp16.val[1], temp14.val[1]);
+            //step4 store bytes in correct position,the order now is 1,2,3,4,5,6,7,8
+            temp1.val[0] = vreinterpret_u8_u32(temp17.val[0]);
+            temp1.val[1] = vreinterpret_u8_u32(temp19.val[0]);
+            temp2.val[0] = vreinterpret_u8_u32(temp18.val[0]);
+            temp2.val[1] = vreinterpret_u8_u32(temp20.val[0]);
+            temp3.val[0] = vreinterpret_u8_u32(temp17.val[1]);
+            temp3.val[1] = vreinterpret_u8_u32(temp19.val[1]);
+            temp4.val[0] = vreinterpret_u8_u32(temp18.val[1]);
+            temp4.val[1] = vreinterpret_u8_u32(temp20.val[1]);
+            vst1_u8(dstImg + j * height + height - i - 8, temp1.val[0]);
+            vst1_u8(dstImg + (j + 1) * height + height - i - 8, temp1.val[1]);
+            vst1_u8(dstImg + (j + 2) * height + height - i - 8, temp2.val[0]);
+            vst1_u8(dstImg + (j + 3) * height + height - i - 8, temp2.val[1]);
+            vst1_u8(dstImg + (j + 4) * height + height - i - 8, temp3.val[0]);
+            vst1_u8(dstImg + (j + 5) * height + height - i - 8, temp3.val[1]);
+            vst1_u8(dstImg + (j + 6) * height + height - i - 8, temp4.val[0]);
+            vst1_u8(dstImg + (j + 7) * height + height - i - 8, temp4.val[1]);
+        }
+    }
+}
+
+void BPIYUVRotate::NeonRotateYUV420UV90(unsigned char* dstImg,
+                                        unsigned char* srcImg, int width,
+                                        int height, int pitch)
+{
+    uint8x8x4_t mat1; //use 2 register array to load a 8x8 patch
+    uint8x8x4_t mat2;
+
+    uint8x8x2_t temp1;
+    uint8x8x2_t temp2;
+    uint8x8x2_t temp3;
+    uint8x8x2_t temp4;
+
+    uint16x4x2_t temp5;
+    uint16x4x2_t temp6;
+    uint16x4x2_t temp7;
+    uint16x4x2_t temp8;
+    uint16x4x2_t temp9;
+    uint16x4x2_t temp10;
+    uint16x4x2_t temp11;
+    uint16x4x2_t temp12;
+
+    uint32x2x2_t temp13;
+    uint32x2x2_t temp14;
+    uint32x2x2_t temp15;
+    uint32x2x2_t temp16;
+    uint32x2x2_t temp17;
+    uint32x2x2_t temp18;
+    uint32x2x2_t temp19;
+    uint32x2x2_t temp20;
+    for (int i = 0; i < height; i += 8)
+        {
+        for (int j = 0; j < width; j += 8)
+            {
+            //step0 load 8x8 bytes in 8 registers
+            mat1.val[0] = vld1_u8(srcImg + i * pitch + j);
+            mat1.val[1] = vld1_u8(srcImg + (i + 1) * pitch + j);
+            mat1.val[2] = vld1_u8(srcImg + (i + 2) * pitch + j);
+            mat1.val[3] = vld1_u8(srcImg + (i + 3) * pitch + j);
+            mat2.val[0] = vld1_u8(srcImg + (i + 4) * pitch + j);
+            mat2.val[1] = vld1_u8(srcImg + (i + 5) * pitch + j);
+            mat2.val[2] = vld1_u8(srcImg + (i + 6) * pitch + j);
+            mat2.val[3] = vld1_u8(srcImg + (i + 7) * pitch + j);
+            //step1 trn nearby registers
+            temp1 = vtrn_u8(mat1.val[1], mat1.val[0]);
+            temp2 = vtrn_u8(mat1.val[3], mat1.val[2]);
+            temp3 = vtrn_u8(mat2.val[1], mat2.val[0]);
+            temp4 = vtrn_u8(mat2.val[3], mat2.val[2]);
+            //step2 trn 1,3 2,4 5,7 6,8
+            temp5.val[0] = vreinterpret_u16_u8(temp1.val[0]);
+            temp5.val[1] = vreinterpret_u16_u8(temp1.val[1]);
+            temp6.val[0] = vreinterpret_u16_u8(temp2.val[0]);
+            temp6.val[1] = vreinterpret_u16_u8(temp2.val[1]);
+            temp7.val[0] = vreinterpret_u16_u8(temp3.val[0]);
+            temp7.val[1] = vreinterpret_u16_u8(temp3.val[1]);
+            temp8.val[0] = vreinterpret_u16_u8(temp4.val[0]);
+            temp8.val[1] = vreinterpret_u16_u8(temp4.val[1]);
+            temp9 = vtrn_u16(temp6.val[0], temp5.val[0]);
+            temp10 = vtrn_u16(temp6.val[1], temp5.val[1]);
+            temp11 = vtrn_u16(temp8.val[0], temp7.val[0]);
+            temp12 = vtrn_u16(temp8.val[1], temp7.val[1]);
+            //step3 trn 1,5 2,6 3,7 4,8
+            temp13.val[0] = vreinterpret_u32_u16(temp9.val[0]);
+            temp13.val[1] = vreinterpret_u32_u16(temp9.val[1]);
+            temp14.val[0] = vreinterpret_u32_u16(temp10.val[0]);
+            temp14.val[1] = vreinterpret_u32_u16(temp10.val[1]);
+            temp15.val[0] = vreinterpret_u32_u16(temp11.val[0]);
+            temp15.val[1] = vreinterpret_u32_u16(temp11.val[1]);
+            temp16.val[0] = vreinterpret_u32_u16(temp12.val[0]);
+            temp16.val[1] = vreinterpret_u32_u16(temp12.val[1]);
+            temp17 = vtrn_u32(temp15.val[0], temp13.val[0]);
+            temp18 = vtrn_u32(temp15.val[1], temp13.val[1]);
+            temp19 = vtrn_u32(temp16.val[0], temp14.val[0]);
+            temp20 = vtrn_u32(temp16.val[1], temp14.val[1]);
+            //step4 store bytes in correct position,the order now is 1,2,3,4,5,6,7,8
+            temp1.val[0] = vreinterpret_u8_u32(temp17.val[0]);
+            temp1.val[1] = vreinterpret_u8_u32(temp19.val[0]);
+            temp2.val[0] = vreinterpret_u8_u32(temp18.val[0]);
+            temp2.val[1] = vreinterpret_u8_u32(temp20.val[0]);
+            temp3.val[0] = vreinterpret_u8_u32(temp17.val[1]);
+            temp3.val[1] = vreinterpret_u8_u32(temp19.val[1]);
+            temp4.val[0] = vreinterpret_u8_u32(temp18.val[1]);
+            temp4.val[1] = vreinterpret_u8_u32(temp20.val[1]);
+            vst2_u8(dstImg + 2 * height * (j / 2 + 1) - 16 - 2 * i, temp1);
+            vst2_u8(dstImg + 2 * height * (j / 2 + 2) - 16 - 2 * i, temp2);
+            vst2_u8(dstImg + 2 * height * (j / 2 + 3) - 16 - 2 * i, temp3);
+            vst2_u8(dstImg + 2 * height * (j / 2 + 4) - 16 - 2 * i, temp4);
+        }
+    }
+}
diff --git a/fastboot_app/bpi_app/bpi_yuv_rotate.h b/fastboot_app/bpi_app/bpi_yuv_rotate.h
new file mode 100644
index 0000000..adbf954
--- /dev/null
+++ b/fastboot_app/bpi_app/bpi_yuv_rotate.h
@@ -0,0 +1,59 @@
+/*
+ * bpi_yuv_rotate.h
+ *
+ * History:
+ *       2016/09/01 - [ShengJiang] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __BPI_YUV_ROTATE_H_
+#define __BPI_YUV_ROTATE_H_
+class BPIYUVRotate {
+public:
+    static void BPIYUV420Rotate(unsigned char* dstImg, unsigned char* srcImgY,
+                                unsigned char* srcImgUV, int width, int height,
+                                int pitch, int rotate);
+    static void NeonRotateYUV420Y90(unsigned char* dstImg,
+                                    unsigned char* srcImg, int width,
+                                    int height, int pitch);
+    static void NeonRotateYUV420UV90(unsigned char* dstImg,
+                                     unsigned char* srcImg, int width,
+                                     int height, int pitch);
+    static void NeonRotateYUV420Y180(unsigned char* dstImg,
+                                     unsigned char* srcImg, int width,
+                                     int height, int pitch);
+    static void NeonRotateYUV420UV180(unsigned char* dstImg,
+                                      unsigned char* srcImg, int width,
+                                      int height, int pitch);
+    static void NeonRotateYUV420Y270(unsigned char* dstImg,
+                                     unsigned char* srcImg, int width,
+                                     int height, int pitch);
+    static void NeonRotateYUV420UV270(unsigned char* dstImg,
+                                      unsigned char* srcImg, int width,
+                                      int height, int pitch);
+};
+#endif //__BPI_YUV_ROTATE_H_
diff --git a/fastboot_app/bpi_app/cloud_comm.c b/fastboot_app/bpi_app/cloud_comm.c
new file mode 100644
index 0000000..38c5052
--- /dev/null
+++ b/fastboot_app/bpi_app/cloud_comm.c
@@ -0,0 +1,312 @@
+/*
+ * cloud_comm.c
+ *
+ * History:
+ *       2016/06/13 - [CZ LIN] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.a
+ *
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <pthread.h>
+
+#include "device.h"
+#include "defs.h"
+#include "bpi_typedefs.h"
+#include "bpi_utils.h"
+#include "bpi_wlan.h"
+#include "bpi_app_config.h"
+#include "cloud_comm.h"
+
+#define SYSTEM_ALARM_AUDIO_PATH     "/usr/local/bin/prompt.wav"
+#define DEVICE_ELEKTRA_II            "elektraII"
+#define DEVICE_ELEKTRA_S             "elektraS"
+#define DEVICE_ELEKTRA_V             "elektraV"
+#define DEVICE_DAREDEVIL             "daredevil"
+#define DEVICE_UNKNOWN               "unkown"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+static int  cloud_port = CONF_CLOUD_DEV_PORT;
+static int local_port = 8282;
+static char fast_streaming_client_ip[MAX_IP_LEN] = {0};
+static volatile int s_is_cloud_rtsp = 0;
+static volatile int cloud_status = ECloud_Disconnected;
+static volatile int dbg_cannot_connect_cloud = 0;
+static volatile int s_remote_ctrl_standby = 0;
+pthread_mutex_t s_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+static void agent_msg_proc_alarm()
+{
+    const char *path = SYSTEM_ALARM_AUDIO_PATH;
+    LOG_DEBUG("play audio: %s", path);
+    char cmd[100]   = {0} ;
+    sprintf(cmd, "/usr/bin/aplay %s", path);
+    system(cmd);
+}
+
+static void agent_msg_proc_start_rtsp_injector(handle_t h_agent, int stream_id)
+{
+    char cmd[256];
+    sprintf(cmd, "proxy_injector rtsp://127.0.0.1:%d/stream1 rtsp://%s/%s_%d.sdp &", local_port, get_server_ip(NULL), get_device_id(), stream_id);
+    system(cmd);
+    s_is_cloud_rtsp = 1;
+}
+
+void agent_msg_notify_cb(handle_t h_agent, msg_ptr_t p_msg, result_ptr_t p_result)
+{
+    switch (p_msg->what) {
+        case MSG_DEVICE_AGENT_CONNECTED: {
+            LOG_DEBUG("agent_msg_notify_cb: ECloud_Connected\n");
+            fflush(stdout);
+            cloud_status = ECloud_Connected;
+        }
+        break;
+        case MSG_DEVICE_AGENT_CANNOT_CONNECT: {
+            LOG_DEBUG("agent_msg_notify_cb: ECloud_Disconnected\n");
+            fflush(stdout);
+            cloud_status = ECloud_Disconnected;
+        }
+        break;
+        case MSG_DEVICE_ALARM: {
+            agent_msg_proc_alarm();
+        }
+        break;
+        case MSG_RESERVED_SHUTDOWN:
+        case MSG_DEVICE_STANDBY_UDP:
+        case MSG_DEVICE_STANDBY_TCP: {
+            s_remote_ctrl_standby = 1;
+        }
+        break;
+        case MSG_DBG_CANNOT_CONNECT_CLOUD: {
+            dbg_cannot_connect_cloud = 1;
+        }
+        break;
+        case MSG_RESERVED_PLAY_AUDIO: {
+            agent_msg_proc_alarm();
+        }
+        break;
+        case MSG_FAST_STREAMING: {
+            set_fast_streaming_client((char*)p_result->obj);
+        } break;
+        case MSG_DBG_START_RTSP_INJECTOR: {
+            agent_msg_proc_start_rtsp_injector(h_agent, p_msg->para1);
+        }
+        break;
+        default:
+            LOG_ERROR("no handler, what:%d", p_msg->what);
+            break;
+    }
+}
+void set_device_mode( handle_t h_agent, int mode){
+    device_set_device_mode(h_agent, mode);
+}
+
+handle_t start_device_agent(int mode)
+{
+    param_device_t param;
+    int ret = 0;
+    handle_t h_agent = NULL;
+    ret = param_device_parse_server(get_server_ip(NULL), param.srv_ip, NULL);
+    if (ret == 0) {
+        strcpy(param.dev_uid, get_device_id());
+        param.dev_mode = mode;
+        param.srv_dev_port = cloud_port;
+        memset(param.dev_category,0,sizeof(param.dev_category));
+#if defined(ELEKTRA_S)
+        snprintf(param.dev_category,sizeof(param.dev_category),"%s",DEVICE_ELEKTRA_S);
+#elif defined(ELEKTRA_II)
+        snprintf(param.dev_category,sizeof(param.dev_category),"%s",DEVICE_ELEKTRA_II);
+#elif defined(ELEKTRA_V)
+        snprintf(param.dev_category,sizeof(param.dev_category),"%s",DEVICE_ELEKTRA_V);
+#elif defined(DAREDEVIL)
+        snprintf(param.dev_category,sizeof(param.dev_category),"%s",DEVICE_DAREDEVIL);
+#else
+        snprintf(param.dev_category,sizeof(param.dev_category),"%s",DEVICE_UNKNOWN);
+#endif
+
+        h_agent = device_create(&param);
+        if (h_agent) {
+            ret = device_init(h_agent);
+            if (ret < 0) {
+                device_deinit(h_agent);
+                LOG_ERROR("init device_agent failure\n");
+            } else {
+                device_set_msg_notify_cb(h_agent, h_agent, agent_msg_notify_cb);
+                device_start(h_agent);
+                LOG_DEBUG("device_agent start OK\n");
+            }
+        } else {
+            LOG_ERROR("create device_agent failure\n");
+        }
+    } else {
+        LOG_ERROR("param_device_parse_server failure\n");
+    }
+    return h_agent;
+}
+
+/*int notify_server_standby_udp(keep_alive_param_t* param)
+{
+    int result = 0;
+    do {
+        int fd_client = connect_server(param->server_addr, param->server_port, Net_UDP);
+        if (fd_client < 0) {
+            LOG_ERROR("connect to server fail\n");
+            result = -1;
+            break;
+        }
+
+        if (device_standby_udp(fd_client, get_device_id(), param->dev_category, param->wake_data, param->wake_data_len) != RET_OK) {
+            LOG_ERROR("notify cloud failure");
+        }
+        if (fd_client > 0) {
+            close(fd_client);
+        }
+    } while(0);
+    return result;
+}*/
+
+int notify_server_standby_tcp(keep_alive_param_t* param, int tcp_fd)
+{
+    int result = 0;
+    do {
+        // notify cloud that device enter standby
+        if (device_standby_tcp(tcp_fd, get_device_id(), param->dev_category, param->wake_data, param->wake_data_len) != RET_OK) {
+            LOG_ERROR("notify cloud failure");
+        }
+    } while(0);
+    return result ;
+}
+
+int check_standby_flag(){
+    return s_remote_ctrl_standby;
+}
+
+void clear_cloud_comm_flags(){
+     s_remote_ctrl_standby = 0;
+}
+
+char* get_fast_streaming_client()
+{
+    int wait_count = 0;
+    int MAX_WAIT_COUNT = 200;
+    int ret = -1;
+    while(wait_count < MAX_WAIT_COUNT){
+        pthread_mutex_lock(&s_mutex);
+        int cmp_result = strcmp(fast_streaming_client_ip, "\0");
+        pthread_mutex_unlock(&s_mutex);
+        if(cmp_result == 0){
+            wait_count += 1;
+            usleep(10 * 1000);
+        }else{
+            LOG_PRINT("get_ip, wait_count = %d, get_current_time = %u\n",wait_count,get_current_time());
+            ret = 0;
+            break;
+        }
+    }
+    if (wait_count >= MAX_WAIT_COUNT){
+        LOG_ERROR("Time out, no streaming destination\n");
+    }
+    return (ret == -1)? NULL:fast_streaming_client_ip;
+}
+
+void set_fast_streaming_client(char *dest_ip)
+{
+    if(strlen(dest_ip) >= sizeof(fast_streaming_client_ip)){
+        LOG_ERROR("set streaming ip incorrectly\n");
+        return;
+    }
+    pthread_mutex_lock(&s_mutex);
+    strcpy(fast_streaming_client_ip,  dest_ip);
+    pthread_mutex_unlock(&s_mutex);
+}
+
+
+void wlan_resume(){
+    wifi_power_normal();
+    int wake_reason = INVALID_STATE;
+    if (get_fd_to_server() < 0){
+        return;
+    }
+    if(0 != resume_wifi(&wake_reason, 1)){
+        LOG_ERROR("wifi resume:resume wifi failed!\n");
+    }
+    close_fd_to_server();
+}
+
+int hibernate_wlan_resume(){
+    int wake_reason = INVALID_STATE;
+    wifi_power_normal();
+    if(0 != resume_wifi(&wake_reason, 0)){
+        LOG_ERROR("wifi resume:resume wifi failed!\n");
+    }
+    return wake_reason;
+}
+
+int wlan_keepalive(int keepalive_interval, int dtim_interval, const char* wakeup_token, char *server_ip)
+{
+    keep_alive_param_t param;
+    memset(&param,0,sizeof param);
+    param.server_addr = server_ip;
+    param.server_port = CONF_CLOUD_DEV_PORT;
+    param.keepalive_interval =keepalive_interval;//seconds
+    param.dtim_interval = dtim_interval;//mseconds
+    param.timeout = 10;//seconds
+    param.verbose = 0;
+    param.wake_data_len = snprintf((char*)param.wake_data,sizeof(param.wake_data),"%s", wakeup_token);
+#if defined(ELEKTRA_S)
+    snprintf(param.dev_category,sizeof(param.dev_category),"%s",DEVICE_ELEKTRA_S);
+#elif defined(DAREDEVIL)
+    snprintf(param.dev_category,sizeof(param.dev_category),"%s",DEVICE_DAREDEVIL);
+#else
+    snprintf(param.dev_category,sizeof(param.dev_category),"%s",DEVICE_UNKNOWN);
+#endif
+    int ret = -1;
+    do {
+        int fd_client = -1;
+        LOG_PRINT("wifi standby TCP starts\n");
+        close_fd_to_server();
+        connect_server(server_ip, CONF_CLOUD_DEV_PORT, Net_TCP);
+        fd_client = get_fd_to_server();
+        if (fd_client < 0){
+            LOG_ERROR("socket to server not valid. \n");
+            ret = ECloud_Disconnected;
+            break;
+        }
+        ret = notify_server_standby_tcp(&param, fd_client);
+        if (ret < 0) {
+            break;
+        }
+        ret = tcp_keep_alive(&param, fd_client);
+    } while(0);
+    wifi_power_save();
+    return  ret;
+}
+#ifdef __cplusplus
+};
+#endif
diff --git a/fastboot_app/bpi_app/cloud_comm.h b/fastboot_app/bpi_app/cloud_comm.h
new file mode 100644
index 0000000..8e774a9
--- /dev/null
+++ b/fastboot_app/bpi_app/cloud_comm.h
@@ -0,0 +1,54 @@
+/*
+ * cloud_comm.h
+ *
+ * History:
+ *       2016/06/15 - [CZ LIN] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef _CLOUD_COMM_H_
+#define _CLOUD_COMM_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+handle_t start_device_agent(int mode);
+void wlan_resume();
+int hibernate_wlan_resume();
+int wlan_keepalive(int keepalive_interval, int dtim_interval, const char* wakeup_token, char *server_ip);
+char* get_cloud_ip();
+int check_standby_flag();
+void set_device_mode( handle_t h_agent, int mode);
+void clear_cloud_comm_flags();
+char* get_fast_streaming_client();
+void set_fast_streaming_client(char *dest_ip);
+
+
+#ifdef __cplusplus
+};
+#endif
+#endif
diff --git a/fastboot_app/bpi_app/config_reconnect.c b/fastboot_app/bpi_app/config_reconnect.c
new file mode 100644
index 0000000..e15962b
--- /dev/null
+++ b/fastboot_app/bpi_app/config_reconnect.c
@@ -0,0 +1,176 @@
+/*
+ * config_reconnect.c
+ *
+ * History:
+ *       2016/05/31 - [Jb xing] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <ctype.h>
+#include <getopt.h>
+#include <stdbool.h>
+
+#include "bpi_typedefs.h"
+#include "bpi_wlan.h"
+#include "bpi_utils.h"
+#include "bpi_app_config.h"
+#include "device.h"
+#include "cloud_comm.h"
+
+#define EXIT_PARAM 1
+#define EXIT_RECONNECT 2
+#define EXIT_CONFIG 3
+#define EXIT_WAIT_WLAN0 4
+#define EXIT_KEEPALIVE 5
+#define EXIT_LOAD_CONFIG 6
+#define EXIT_UNKNOWN 7
+
+static app_conf_t g_app_config;
+static const char *short_options = "crh";
+
+static struct option long_options[] =
+{
+    { "config", no_argument, 0, 'c' },
+    { "reconnect", no_argument, 0, 'r' },
+    { "help", no_argument, 0, 'h' },
+    { 0, 0, 0, 0 }
+};
+
+static const char* prompt[]=
+{
+     "elektra config mode",
+     "elektra reconnect mode",
+     "config_reconnect help"
+};
+
+static int usage(void)
+{
+    int i = 0;
+    for(;i<(sizeof(long_options)/sizeof(long_options[0]))-1;i++)
+    {
+        printf("-%c,  ",long_options[i].val);
+        printf("--%-20s  ",long_options[i].name);
+        printf("\t%s\n",prompt[i]);
+    }
+    exit(EXIT_UNKNOWN);
+}
+
+static int config_mode(void)
+{
+    LOG_DEBUG("CONFIG MODE \n");
+    cooee_wlan_conf_t save_wlan = {0};
+    if(config_elektra_boot(&save_wlan))
+        return EXIT_CONFIG;
+    else
+    {
+        //save wlan info
+        if(save_wlan_config(BPI_CONFIG_PATH,&save_wlan)!=0)
+        {
+            LOG_ERROR("save wlan infomation failed");
+        }
+        else
+        {
+            LOG_DEBUG("save wlan info OK \n");
+        }
+
+        if(0==wlan_keepalive(g_app_config.keepalive_interval,g_app_config.dtim_interval,g_app_config.wakeup_token,g_app_config.cloud_server_ip))
+        {
+            LOG_DEBUG("wlan standby done\n");
+            return 0;
+        }
+        else
+        {
+            LOG_ERROR("Cloud/AP not connected, failed to switch to standby state\n");
+            return EXIT_KEEPALIVE;
+        }
+    }
+}
+
+static int reconnect_mode(void)
+{
+    LOG_DEBUG("RECONNECT MODE\n");
+
+    if(connect_ap(g_app_config.ap_ssid, g_app_config.ap_password, g_app_config.ap_wpa)==EWlan_Connected)
+    {
+        LOG_DEBUG("FASTBOOT_MODE_WLAN_UP: OK \n");
+        if(0==wlan_keepalive(g_app_config.keepalive_interval,g_app_config.dtim_interval,g_app_config.wakeup_token,g_app_config.cloud_server_ip))
+        {
+            LOG_DEBUG("wlan standby done\n");
+            return   0;
+        }
+        else
+        {
+            LOG_ERROR("Cloud/AP not connected, failed to switch to standby state\n");
+            return EXIT_KEEPALIVE;
+        }
+    }
+    else
+    {
+        LOG_ERROR("FASTBOOT_MODE_WLAN_UP: FAIL \n");
+        return EXIT_RECONNECT;
+    }
+}
+
+static int init_param(int argc,char *argv[])
+{
+    int ret = 0;
+    while((ret=getopt_long(argc,argv,short_options,long_options,NULL))!=-1)
+    {
+        switch(ret)
+        {
+            case 'c':
+                return  config_mode();
+            case 'r':
+                return reconnect_mode();
+            case 'h':
+            default:
+                usage();
+        }
+    }
+    return 0;
+}
+
+int main(int argc,char **argv)
+{
+    if(argc<2)
+    {
+        usage();
+    }
+    memset(&g_app_config,0,sizeof g_app_config);
+    if(load_app_conf(&g_app_config) < 0){
+        LOG_ERROR("load app config failed\n");
+        return -1;
+    }
+
+    int ret = init_param(argc,argv);
+    system("echo mem > /sys/power/state");
+    return ret;
+}
diff --git a/fastboot_app/bpi_app/hibernate_main.cpp b/fastboot_app/bpi_app/hibernate_main.cpp
new file mode 100644
index 0000000..4c44596
--- /dev/null
+++ b/fastboot_app/bpi_app/hibernate_main.cpp
@@ -0,0 +1,586 @@
+/*
+ * hibernate_main.cpp
+ *
+ *
+ * History:
+ *       2016/12/15 - [CZ LIN] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <stdio.h>
+#include <unistd.h>
+#include <getopt.h>
+#include <sys/mount.h>
+#include <string>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <termios.h>
+#include <iav_ioctl.h>
+#include <sys/mman.h>
+
+#include "device.h"
+#include "bpi_typedefs.h"
+#include "bpi_app_config.h"
+#include "cloud_comm.h"
+#include "bpi_utils.h"
+#include "ubi/bpi_ubi.h"
+#include "adc/adc_util.h"
+#include "bpi_mcu_proxy.h"
+#include "bpi_uploader.h"
+#include "bpi_mcu_event_monitor.h"
+#include "bpi_wlan.h"
+#include "bpi_oryx_config.h"
+#include "bpi_vca.h"
+#include "streaming_rtp_over_udp.h"
+#include "streaming_audio_playback.h"
+#include "config.h"
+
+#define  ADD_MTD   (9)
+#define DMA_DESCRIPTOR_OFFSET 0x00100000 /* the value is defined in amboot */
+
+using std::string;
+const string BPI_swp =  "/dev/mtd8";
+
+static int  run_normal_mode(BPIMcuProxy& proxy);
+static int  run_hibernate_mode(BPIMcuProxy& proxy);
+static app_conf_t g_app_config;
+
+int get_audio_param_from_iav(unsigned int *audio_op_address, unsigned int *audio_op_size){
+    int fd_iav = open("/dev/iav", O_RDWR, 0);
+    if(fd_iav < 0){
+        return -1;
+    }
+    do{
+        struct iav_querybuf buf;
+        int ret = -1;
+        memset(&buf, 0, sizeof(buf));
+	 buf.buf = IAV_BUFFER_FB_AUDIO;
+	 while ( (ret = ioctl(fd_iav, IAV_IOC_QUERY_BUF, &buf)) < 0 && errno == EINTR);
+        close(fd_iav);
+	 if(ret < 0){
+	     return -1;
+        }
+	 printf("get_audio_param_from_iav --  Base Address: [0x%08X], Size [%8d KB].\n", buf.offset, (buf.length >> 10));
+	 fflush(stdout);
+	 *audio_op_address = buf.offset;
+	 *audio_op_size = buf.length;
+        return 0;
+    }while(0);
+}
+
+static int wait_dma_audio(u32 *dest_addr, u32 op_address, u32 safe_size)
+{
+    int ret = -1;
+    const u32 audio_safe_region = op_address + safe_size;
+    u32 start = get_current_time();
+    u32 now = start;
+    while(now - start < 500 * 1000){
+        printf("dma ch6 has writen to: %x, safe region: %x\n", *dest_addr, audio_safe_region);
+        if(*dest_addr < audio_safe_region && (*dest_addr > op_address + DMA_DESCRIPTOR_OFFSET)){
+            ret = (*dest_addr - op_address) / DMA_DESCRIPTOR_OFFSET + 1;
+            printf("%s: dma audio desc offset: %d\n", __func__, ret);
+            break;
+        }else{
+            sleep(1);
+        }
+        now = get_current_time();
+    }
+    return ret;
+}
+
+int peek_dma_audio(u32 op_address, u32 safe_size)
+{
+    int dma_fd = 0;
+    int ret = 0;
+
+    //these values are defined in Ambarella_A12_Hardware_Programming_Reference_Manual
+    u32 dma_address = 0xe0005000; /* page aligned */
+    u32 dma_reg_size = 0x1000; /* page aligned */
+    u32 dma_reg_offset = 0x0368; /* DMA channel 6 main destination address */
+
+    u32 *mem_dma = NULL, *mem_dma_dest_addr = NULL;
+
+    do{
+        dma_fd = open("/dev/ambad", O_RDWR, 0);
+        if(dma_fd < 0){
+            perror("/dev/ambad failed to open");
+            ret = -1;
+            break;
+        }
+
+        mem_dma = (u32*)mmap(NULL, dma_reg_size,
+                    PROT_READ|PROT_WRITE, MAP_SHARED, dma_fd, dma_address);
+        if(mem_dma == MAP_FAILED){
+            perror("mmap");
+            close(dma_fd);
+            ret = -1;
+            break;
+        }
+        mem_dma_dest_addr = mem_dma + dma_reg_offset / sizeof(u32);
+        ret = wait_dma_audio(mem_dma_dest_addr, op_address, safe_size);
+        if(ret < 0){
+            printf("ERROR: wait dma timeout\n");
+            break;
+        }
+    }while(0);
+
+    if(mem_dma != NULL){
+        munmap(mem_dma, dma_reg_size);
+    }
+    if(dma_fd){
+        close(dma_fd);
+    }
+    return ret;
+}
+
+static void mount_rw_partition()
+{
+    if (0 != bpi_ubi_attach(0, ADD_MTD)){
+        LOG_ERROR("attach mtd %d to ubi 0 failed\n", ADD_MTD);
+    }
+    if (0 != mount("/dev/ubi0_0", "/tmp/config", "ubifs", MS_SYNCHRONOUS, NULL)){
+        LOG_ERROR("mount /dev/ubi0_0 on /tmp/config failed\n");
+    }
+    if (0 != mount("/tmp/config/etc/oryx", "/etc/oryx", "", MS_BIND, NULL)){
+        LOG_ERROR("mount to /etc/oryx failed\n");
+    }
+    if (0 != mount("/tmp/config/etc/bpi", "/etc/bpi", "", MS_BIND, NULL)){
+        LOG_ERROR("mount to /etc/bpi failed\n");
+    }
+}
+
+static void umount_rw_partition()
+{
+    if (0 != umount("/etc/oryx")){
+        LOG_ERROR("umount /etc/oryx failed\n");
+    }
+    if (0 != umount("/etc/bpi")){
+        LOG_ERROR("umount /etc/bpi failed\n");
+    }
+    if (0 != umount("/tmp/config")){
+        LOG_ERROR("umount /tmp/config failed\n");
+    }
+    if (0 != bpi_ubi_detach(0, ADD_MTD)){
+        LOG_ERROR("bpi_ubi_detach mtd %d failed\n", ADD_MTD);
+    }
+}
+
+//todo
+static void recording_run(McuEventMonitor &mcu_monitor){
+    unsigned int cur_time = 0;
+    unsigned int start_time = 0;
+    int duration = 0;
+    start_time = get_current_time();
+    while(1){
+        cur_time = get_current_time();
+        duration = (cur_time - start_time) / 1000;
+        if (duration >= g_app_config.recording_max_duration) {
+           LOG_DEBUG("Reached max recording duration.\n");
+           break;
+        }
+        if (0 == g_app_config.record_control_mode && 1 == OryxRecorderWrapper::s_stop_flag) {
+            LOG_DEBUG("Reached motion start mode duration.\n");
+            OryxRecorderWrapper::s_stop_flag = 0;
+            break;
+        }else if(1 == g_app_config.record_control_mode){
+            unsigned int base_time = mcu_monitor.get_timer_start_point();
+            duration = (cur_time - base_time) / 1000;
+            if (base_time > 0 && duration >= g_app_config.record_duration_after_motion_stops){
+                LOG_DEBUG("motion stop mode, cur_time = %u, base time = %u\n", cur_time, base_time);
+                break;
+            }
+        }
+        usleep(100000);
+    }
+}
+
+static void streaming_run(unsigned int durationInMilliseconds){
+    unsigned int cur_time = 0;
+    unsigned int start_time = 0;
+    start_time = get_current_time();
+    while(1){
+        if(check_standby_flag()){
+            break;
+        }
+        cur_time = get_current_time();
+        if ((cur_time - start_time) > durationInMilliseconds){
+            break;
+        }
+        usleep(100000);
+    }
+}
+
+static void update_amboot_params(app_conf_t* config)
+{
+    struct amboot_params params = {0};
+    params.enable_audio = config->audio_enable;
+    params.enable_fastosd = 0;
+    params.enable_ldc = (unsigned char)config->enable_ldc;
+    params.rotation_mode = config->rotate;
+
+    if(config->video0_enable){
+        params.stream0_enable = 1; //enable
+        if(1280 == config->video0_width && 720 == config->video0_height){
+            params.stream0_resolution = 1; //720p
+        }else if(1920 == config->video0_width && 1080 == config->video0_height){
+            params.stream0_resolution = 0; //1080p
+        }else{
+            LOG_ERROR("unsupported video 0 resolution(%dx%d)", config->video0_width, config->video0_height);
+        }
+        params.stream0_fmt = 1; //h264
+        params.stream0_fps = config->video0_frame_rate;
+        params.stream0_bitrate = (unsigned int)config->video0_recording_bitrate;
+    }
+
+    if(config->video1_enable){
+        params.stream1_enable = 1; //enable
+        if(720 == config->video1_width && 480 == config->video1_height){
+            params.stream0_resolution = 2; //480p
+        }else{
+            LOG_ERROR("unsupported video 1 resolution(%dx%d)", config->video1_width, config->video1_height);
+        }
+        params.stream1_fmt = 1; //h264
+        params.stream1_fps = 30;
+        params.stream1_bitrate = 1000000;
+    }
+
+    snprintf(params.fastosd_string, sizeof(params.fastosd_string), "AMBA");
+    params.enable_vca = config->vca_enable;
+    params.vca_frame_num = (unsigned char)config->vca_frame_num;
+    adc_util_update(&params);
+}
+
+static void config_run(BPIMcuProxy& proxy){
+    LOG_PRINT("use 'fg' command if bpi_app is running in the background.\n");
+    system("vi /etc/bpi/setting.ini");
+    //load again to get modified conf
+    app_conf_t tmp_app_config = {0};
+    if(load_app_conf(&tmp_app_config) < 0){
+        LOG_ERROR("load app config failed\n");
+        return;
+    }
+    //config oryx settings
+    if(!config_oryx_engine(&tmp_app_config)){
+        LOG_ERROR("fail to config oryx configuration files.\n");
+        return;
+    }
+    //update amboot parameters into ADC
+    if(config_modified(&tmp_app_config, &g_app_config)){
+        update_amboot_params(&tmp_app_config);
+    }
+
+    g_app_config = tmp_app_config;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+int main(int argc, char** argv){
+    const char *short_options = "tdv";
+    struct option long_options[] = {
+        { "enable_log_time", 0, 0, 't' },
+        { "enable_debug_log", 0, 0, 'd' },
+        { "enable_vca_buf_dump", 0, 0, 'v' }
+    };
+
+    int ch = 0;
+    int log_options = 0;
+    setenv("DUMP_VCA_BUF","false",1);
+    while(1){
+        ch = getopt_long(argc, argv, short_options, long_options, NULL);
+        if(-1 == ch) break;
+        switch (ch)
+        {
+        case 't':
+            log_options |= BPI_LOG_ENABLE_TIMESTAMP;
+            break;
+        case 'd':
+            log_options |= BPI_LOG_ENABLE_DEBUG_LOG;
+            break;
+        case 'v':
+            setenv("DUMP_VCA_BUF","true",1);
+            break;
+        default:
+            printf("\n");
+            printf("usage: bpi_app [-d] [-t]\n");
+            printf("        -d,--enable_debug_log      enable debug logs\n");
+            printf("        -t,--enable_log_time       enable log timestamp\n");
+            printf("        -v,--enable_vca_buf_dump       enable vca buf dump, default to /sdcard.\n");
+            printf("\n");
+            return 1;
+        }
+    }
+    set_log_options(log_options);
+    BPIMcuProxy* mcu_proxy = new BPIMcuProxy();
+    // int mcu_version;
+    if(!mcu_proxy->init()){
+        LOG_ERROR("bpi_app connect mcu failed!\n");
+        return -1;
+    }
+    // mcu_version = mcu_proxy->get_mcu_version();
+    // if(-1 == mcu_version){
+    //     LOG_ERROR("bpi_app get mcu version failed!\n");
+    //     return -1;
+    // }
+    // LOG_PRINT("mcu version is %d.%d\n", MCU_MAIN_VERSION(mcu_version), MCU_SUB_VERSION(mcu_version));
+    mcu_proxy->send_cmd(MCU_CMD_LED_GREEN_ON);
+    if(run_normal_mode(*mcu_proxy)){
+        mcu_proxy->send_cmd(MCU_CMD_LED_RED_BLINK);
+        return -1;
+    }
+
+    run_hibernate_mode(*mcu_proxy);
+    //notify mcu to power off
+    sync();
+    mcu_proxy->send_cmd(MCU_CMD_POWEROFF_CPU_DRAM);
+    //This process can not exit,  otherwise it will close tcp-keep-alive fd
+    while(1) usleep(100000);
+    return 0;
+}
+
+
+//Normal mode, hibnate_image will be built.
+//    Return value 0 indicates operation is successful.
+//
+static void suspend_to_disk()
+{
+    unsigned int op_address = 0x08601000;
+    unsigned int op_size = 0x400000;
+    umount_rw_partition();
+    get_audio_param_from_iav(&op_address,&op_size);
+
+    if (peek_dma_audio(op_address, DMA_DESCRIPTOR_OFFSET * 5 / 2) < 0) {
+        printf("peek dma audio error, abort\n");
+    }
+    string flash_cmd = "flash_eraseall";
+    system((flash_cmd + " " + BPI_swp).c_str());
+    system("sync && echo 3 > /proc/sys/vm/drop_caches && echo disk > /sys/power/state");
+}
+
+static int  run_normal_mode(BPIMcuProxy& proxy)
+{
+    int ap_status = EWlan_Disconnected;
+
+    if(load_app_conf(&g_app_config) < 0){
+        LOG_ERROR("load app config failed\n");
+        return -1;
+    }
+    //config oryx settings
+    if (!config_oryx_engine(&g_app_config)){
+        LOG_ERROR("fail to config oryx configuration files.\n");
+        return -1;
+    }
+
+    ap_status = connect_ap(g_app_config.ap_ssid, g_app_config.ap_password, g_app_config.ap_wpa);
+    if (EWlan_Connected != ap_status){
+        LOG_PRINT("Failed to connect AP\n");
+        return -1;
+    }
+    //wifi_host_sleep();
+    update_amboot_params(&g_app_config);
+    suspend_to_disk();
+    return 0;
+}
+//
+//hibernation mode,  provide elektra_services, for example, streaming, recording,etc.
+//
+static int run_hibernate_mode(BPIMcuProxy& proxy)
+{
+    LOG_PRINT(COLOR_RESET "Resume from hibernation, get_current_time = %u\n", get_current_time());
+    handle_t cloud_agent = NULL;
+    McuEventMonitor mcu_monitor;
+    int wifi_state = -1;
+    int ka_result = 0;
+
+    mount_rw_partition();
+    MCU_TRIGGER_TYPE wakeup_event = MCU_TRIGGER_BASE;
+    wakeup_event = proxy.get_trigger_event();
+    AM_BPI_MODE_MAP* mode_map = g_app_config.mode_map;
+
+    if(load_app_conf(&g_app_config) < 0){
+        LOG_ERROR("load app config failed\n");
+        umount_rw_partition();
+        return -1;
+    }
+
+    //do vca
+    int vca_detected_or_not_enabled = 1;
+    if (g_app_config.vca_enable && (mode_map[wakeup_event].bpi_mode == AM_BPI_MODE_RECORDING) && (g_app_config.vca_frame_num > 0)) {
+        proxy.send_cmd(MCU_CMD_LED_RED_BLINK);
+
+        VCA *vca = VCA::get_instance();
+        vca->set_buffer_id(1);//buffer 1(source buffer of prev_c_yuv), prev_c_yuv
+        vca->set_frame_size(g_app_config.vca_width, g_app_config.vca_height);
+        vca->set_frame_number(g_app_config.vca_frame_num);
+        vca->set_time_out(g_app_config.vca_timeout);
+        if(vca->run() == 0){
+            //Detected, recording continue
+            LOG_PRINT("recording vca done with person\n");
+            vca_detected_or_not_enabled = 1;
+        }else{
+            //No human is detected, just suspend again.
+            LOG_PRINT("recording vca done with no person\n");
+            vca_detected_or_not_enabled = 0;
+        }
+        if(!vca_detected_or_not_enabled){
+            wifi_host_sleep();
+            goto SUSPEND;
+        }
+    }
+
+    proxy.send_cmd(MCU_CMD_LED_GREEN_ON);
+
+    wifi_state = hibernate_wlan_resume();
+    proxy.attach(&mcu_monitor);
+    if(MCU_TRIGGER_PIR_ON == wakeup_event || MCU_TRIGGER_WIFI_WAKEUP == wakeup_event){
+        cloud_agent = start_device_agent((AM_BPI_MODE_RECORDING == mode_map[wakeup_event].bpi_mode) ? DEVICE_MODE_RECORDING : DEVICE_MODE_STREAMING);
+        if(cloud_agent){
+            device_connect_cloud(cloud_agent);
+            mcu_monitor.set_cloud_agent(cloud_agent);
+        }
+    }
+    if(AM_BPI_MODE_RECORDING == mode_map[wakeup_event].bpi_mode){
+        OryxRecorderWrapper recorder;
+        BPIUploader bpi_uploader;
+        char server_url[128] = {0};
+        if(!strncmp(g_app_config.storage_folder, "/sdcard", strlen("/sdcard"))){
+            mount_sdcard();
+        }
+        recorder.set_data_handler(&bpi_uploader);
+        if(!recorder.init_recorder(&g_app_config)){
+            LOG_ERROR("Failed to init recorder engine.\n");
+            return -1;
+        }
+        snprintf(server_url, sizeof(server_url), "http://%s:6024", g_app_config.cloud_server_ip);
+        bpi_uploader.set_url(server_url);
+        bpi_uploader.scan_folder(g_app_config.storage_folder);
+        bpi_uploader.start();
+        recorder.start_recorder();
+        mcu_monitor.init_timer_start_point();
+        recording_run(mcu_monitor);
+        recorder.stop_recorder();
+        if(!bpi_uploader.wait_jobs_done(5)){
+            LOG_DEBUG("uploader not empty, continue it next time\n");
+        }
+        bpi_uploader.stop();
+        if(!strncmp(g_app_config.storage_folder, "/sdcard", strlen("/sdcard"))){
+            umount_sdcard();
+        }
+    }
+    else if(AM_BPI_MODE_STREAMING == mode_map[wakeup_event].bpi_mode){
+        LOG_PRINT("Streaming mode\n");
+        transport_info_t transport_info = {0};
+        char *audio_codec_name = NULL;
+        int audio_payload_type = -1;
+        AMPlaybackRtpUri rtp_uri;
+        bpi_streamer_info streamer_info = {0};
+        rtp_uri.udp_port = 8288;
+        rtp_uri.ip_domain  = AM_PLAYBACK_IPV4;
+        char *streaming_dest = get_fast_streaming_client();
+        if(streaming_dest){
+            if (48000 == g_app_config.audio_sample_rate){
+                audio_codec_name = (char*)"aac-48k";
+                audio_payload_type = 97;
+                rtp_uri.audio_type =  AM_AUDIO_AAC;
+                rtp_uri.sample_rate = 48000;
+                rtp_uri.channel = 1;
+            }else if (16000 == g_app_config.audio_sample_rate){
+                audio_codec_name = (char*)"aac-16k";
+                audio_payload_type = 97;
+                rtp_uri.audio_type =  AM_AUDIO_AAC;
+                rtp_uri.sample_rate = 16000;
+                rtp_uri.channel = 1;
+            }else if (8000 == g_app_config.audio_sample_rate){
+                audio_codec_name = (char*)"g711-8k";
+                audio_payload_type = 8;//g711-ALaw
+                rtp_uri.audio_type =  AM_AUDIO_G711A;
+                rtp_uri.sample_rate = 8000;
+                rtp_uri.channel = 1;
+            }
+            snprintf(transport_info.ipaddress, sizeof(transport_info.ipaddress), "%s", streaming_dest);//TODO
+            transport_info.is_ipv4 = 1;
+            transport_info.video.enable = g_app_config.video0_enable;
+            transport_info.video.port = 8554;
+            transport_info.video.payload_type = 96;
+            transport_info.video.ssrc = 0xfeadbeaf;
+            transport_info.audio.enable = g_app_config.audio_enable;
+            transport_info.audio.port = 8556;
+            transport_info.audio.payload_type = audio_payload_type;
+            transport_info.audio.ssrc = 0xfeadbea1;
+            streamer_info.stream_id = 0;
+            streamer_info.enable_lbr = g_app_config.smart_avc;
+            streamer_info.target_bitrate = g_app_config.video0_streaming_bitrate;
+            streamer_info.audio_codec_name = audio_codec_name;
+            streamer_info.transport_info = &transport_info;
+            streamer_info.osd_label = g_app_config.osd_label;
+            streaming_initialize(&streamer_info);
+            audio_play_initialize(rtp_uri);
+            streaming_run(g_app_config.streaming_duration * 1000);
+            audio_play_finalize();
+            streaming_finalize();
+        }
+    }
+    else if(AM_BPI_MODE_DEBUG == mode_map[wakeup_event].bpi_mode){
+        LOG_PRINT("Debug mode\n");
+        config_run(proxy);
+        cloud_agent = start_device_agent(DEVICE_MODE_STANDBY_TCP);
+        if(cloud_agent){
+            device_connect_cloud(cloud_agent);
+        }
+    }
+    else if(AM_BPI_MODE_WLAN_RECONNECT == mode_map[wakeup_event].bpi_mode){
+        LOG_PRINT("--------->> wifi reconnect mode\n");
+        if(AP_LOSS_BEACON == wifi_state || AP_DISASSOCIATION_OR_AUTHENTICATION == wifi_state ||WIFI_WAKE_NORMAL == wifi_state){
+            int ap_status = EWlan_Disconnected;
+            ap_status = connect_ap(g_app_config.ap_ssid, g_app_config.ap_password, g_app_config.ap_wpa);
+            if (EWlan_Connected != ap_status){
+                LOG_PRINT("Failed to reconnect AP, wifi wake reason=%d \n", wifi_state);
+            }
+        }
+    }
+    else{
+
+    }
+
+    if (cloud_agent) {
+        mcu_monitor.set_cloud_agent(NULL);
+        device_destroy(&cloud_agent);
+        cloud_agent = NULL;
+    }
+    ka_result = wlan_keepalive(g_app_config.keepalive_interval,
+                        g_app_config.dtim_interval,
+                        g_app_config.wakeup_token,
+                        g_app_config.cloud_server_ip);
+    if (0 == ka_result) {
+        LOG_PRINT("Keep alive: OK\n");
+    } else if (ECloud_Disconnected == ka_result){
+        LOG_PRINT("Server not reachable, wakeup later to reconnect\n");
+        proxy.send_cmd(MCU_CMD_NETWORK_NEED_REBUILD);
+    }else{
+        LOG_ERROR("Keep alive: Fail\n");
+    }
+SUSPEND:
+    umount_rw_partition();
+    return 0;
+}
diff --git a/fastboot_app/bpi_app/make.inc b/fastboot_app/bpi_app/make.inc
new file mode 100644
index 0000000..de535d2
--- /dev/null
+++ b/fastboot_app/bpi_app/make.inc
@@ -0,0 +1,191 @@
+#
+# make.inc
+#
+# History:
+#       2016/06/01 - [cz Lin] created file
+#
+# Copyright (c) 2015 Ambarella, Inc.
+#
+# This file and its contents ("Software") are protected by intellectual
+# property rights including, without limitation, U.S. and/or foreign
+# copyrights. This Software is also the confidential and proprietary
+# information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+# disclose, distribute, modify, or otherwise prepare derivative works of this
+# Software or any portion thereof except pursuant to a signed license agreement
+# or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+# In the absence of such an agreement, you agree to promptly notify and return
+# this Software to Ambarella, Inc.
+#
+# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+# MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+# IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+#
+
+LOCAL_PATH   := $(call my-dir)
+
+
+ifeq ($(CONFIG_BSP_BOARD_S3LM_ELEKTRA), y)
+BOARD_TYPE = ELEKTRA_S
+else ifeq ($(CONFIG_BSP_BOARD_S2LM_ELEKTRA), y)
+BOARD_TYPE = ELEKTRA_II
+else ifeq ($(CONFIG_BSP_BOARD_S5LM_ELEKTRA_V), y)
+BOARD_TYPE = ELEKTRA_V
+else ifeq ($(CONFIG_BSP_BOARD_S3LM_DAREDEVIL), y)
+BOARD_TYPE = DAREDEVIL
+endif
+ifeq ($(CONFIG_BPI_APP_HIBERNATION), y)
+###############################################
+####     hibernation apps
+################################################
+include $(CLEAR_VARS)
+
+IPCAM_APP_BIN_DIR	:= $(FAKEROOT_DIR)/usr/bin
+UTILS_DIR		:= $(LOCAL_PATH)/../utils
+AGENT_DIR		:= $(LOCAL_PATH)/../device_agent
+NET_DIR			:= $(LOCAL_PATH)/../network_manager
+BPI_CONFIG_FILE		:= $(FAKEROOT_DIR)/etc/bpi/setting.ini
+VCA_DIR		:= $(LOCAL_PATH)/../vca
+
+LOCAL_TARGET	:= bpi_app
+LOCAL_SRCS	:= $(LOCAL_PATH)/hibernate_main.cpp \
+		$(LOCAL_PATH)/cloud_comm.c \
+		$(UTILS_DIR)/xmodem/xmodem.c \
+		$(LOCAL_PATH)/bpi_app_config.c\
+		$(LOCAL_PATH)/bpi_mcu_proxy.cpp\
+		$(LOCAL_PATH)/bpi_uploader.cpp\
+		$(LOCAL_PATH)/bpi_oryx_export.cpp\
+		$(LOCAL_PATH)/bpi_oryx_config.cpp\
+		$(LOCAL_PATH)/bpi_yuv_rotate.cpp\
+		$(LOCAL_PATH)/streaming_rtp_over_udp.cpp\
+		$(LOCAL_PATH)/streaming_audio_playback.cpp\
+		$(LOCAL_PATH)/bpi_mcu_event_monitor.cpp
+
+LOCAL_CFLAGS	:= -I$(LOCAL_PATH) \
+		-I$(UTILS_DIR) \
+		-I$(UTILS_DIR)/xmodem \
+		-I$(AGENT_DIR)/include \
+		-I$(NET_DIR) \
+		-I$(PREBUILD_3RD_PARTY_DIR)/libcurl/include \
+		-I$(PREBUILD_3RD_PARTY_DIR)/iniparser/include
+LOCAL_CFLAGS	+= -I$(VCA_DIR)
+
+LOCAL_CFLAGS	+= -I$(ORYX_DIR)/include \
+		-I$(ORYX_DIR)/include/utility \
+		-I$(ORYX_DIR)/include/event \
+		-I$(ORYX_DIR)/include/video \
+		-I$(ORYX_DIR)/include/stream \
+		-I$(ORYX_DIR)/include/utility/jpeg_encoder \
+		-I$(ORYX_DIR)/include/configure \
+		-I$(ORYX_DIR)/include/audio \
+		-I$(ORYX_DIR)/include/utility \
+		-I$(ORYX_DIR)/include/image_quality \
+		-I$(ORYX_DIR)/include/audio/capture \
+		-I$(ORYX_DIR)/include/audio/codec
+
+LOCAL_CFLAGS  += -D$(BOARD_TYPE)
+
+LOCAL_CFLAGS	+= -std=c++11 -Werror
+LOCAL_LDFLAGS	:= -lpthread  -lm\
+		-L$(PREBUILD_3RD_PARTY_DIR)/libpcap/usr/lib -lpcap \
+		-L$(PREBUILD_3RD_PARTY_DIR)/json-c/usr/lib -ljson-c \
+		-L$(PREBUILD_3RD_PARTY_DIR)/libev/usr/lib -lev \
+		-L$(PREBUILD_3RD_PARTY_DIR)/libcurl/usr/lib -lcurl \
+		-L$(PREBUILD_3RD_PARTY_DIR)/iniparser/usr/lib -liniparser \
+		-Wl,-rpath-link=$(FAKEROOT_DIR)/usr/lib \
+		-Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/libssh2/usr/lib \
+		-Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/libnghttp2/usr/lib \
+		-Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/libjpeg-turbo/usr/lib \
+		-Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/libnl/usr/lib \
+		-Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/libunistring/usr/lib \
+		-Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/libidn/usr/lib \
+		-Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/zlib/usr/lib \
+		-Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/openssl/usr/lib
+
+ifeq ($(CONFIG_AMBARELLA_ALSA_SUPPORT), y)
+LOCAL_LDFLAGS	+= -L$(PREBUILD_3RD_PARTY_DIR)/alsa-lib/usr/lib -lasound
+endif
+
+LOCAL_LIBS := libbpiUtils.so libbpiNetManager.so libaplayAudio.so libdevice_agent.a libbpiUbi.so libbpiAdc.so
+LOCAL_LIBS += libamstream-record.so libamstream-playback.so libamstream-amf.so libamvideo.so libamaudio-capture.so libamjpeg-encoder.so
+LOCAL_LIBS += libamvideo-reader.so libamvideo-address.so libamiq.so libamutil.so libamosal.so libamconfig.so
+LOCAL_LIBS += libvca.so
+
+ifeq ($(AMBOOT_AUDIO_16000), y)
+FAST_AUDIO_RATE	:= 16000
+else ifeq ($(AMBOOT_AUDIO_8000), y)
+FAST_AUDIO_RATE	:= 8000
+else
+FAST_AUDIO_RATE	:= 48000
+endif
+
+include $(BUILD_APP)
+.PHONY: $(LOCAL_TARGET)
+$(LOCAL_TARGET): add_board_rootfs
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(IPCAM_APP_BIN_DIR)/
+	@cp -dpRf $< $(IPCAM_APP_BIN_DIR)/
+	@sed -i '/auto-generated/ d' $(BPI_CONFIG_FILE)
+	@sed -i '/\[audio\]/a sample_rate=$(FAST_AUDIO_RATE); auto-generated for fastboot audio. Non-editable' $(BPI_CONFIG_FILE)
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+endif
+
+########################################################
+# config_reconnect
+########################################################
+
+include $(CLEAR_VARS)
+
+LOCAL_TARGET		:= config_reconnect
+IPCAM_APP_BIN_DIR	:= $(FAKEROOT_DIR)/usr/bin
+IPCAM_APP_LOCAL_BIN_DIR	:= $(FAKEROOT_DIR)/usr/local/bin
+DEVICE_AGENT		:=$(LOCAL_PATH)/../device_agent
+
+LOCAL_SRCS	:= $(LOCAL_PATH)/config_reconnect.c \
+		$(LOCAL_PATH)/bpi_app_config.c \
+		$(LOCAL_PATH)/cloud_comm.c
+
+LOCAL_CFLAGS  	:= -I$(LOCAL_PATH)/../network_manager\
+	-I$(LOCAL_PATH)/../utils \
+	-I$(DEVICE_AGENT)/include\
+	-I$(PREBUILD_3RD_PARTY_DIR)/iniparser/include \
+	-I$(LOCAL_PATH)/../record/export
+
+LOCAL_LDFLAGS	:= -lpthread -lm  \
+	-lbpiNetManager -laplayAudio -lbpiUtils  \
+	-L$(PREBUILD_3RD_PARTY_DIR)/libpcap/usr/lib -lpcap \
+	-L$(PREBUILD_3RD_PARTY_DIR)/json-c/usr/lib -ljson-c \
+	-L$(PREBUILD_3RD_PARTY_DIR)/libev/usr/lib -lev \
+	-L$(PREBUILD_3RD_PARTY_DIR)/iniparser/usr/lib -liniparser \
+	-Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/libnl/usr/lib \
+	-Wl,-rpath-link=$(FAKEROOT_DIR)/usr/lib
+
+ifeq ($(CONFIG_AMBARELLA_ALSA_SUPPORT), y)
+LOCAL_LDFLAGS	+= -L$(PREBUILD_3RD_PARTY_DIR)/alsa-lib/usr/lib -lasound
+endif
+
+LOCAL_LIBS	:= libbpiNetManager.so libaplayAudio.so libbpiUtils.so libdevice_agent.a
+
+
+include $(BUILD_APP)
+
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(IPCAM_APP_BIN_DIR)/
+	@mkdir -p $(IPCAM_APP_LOCAL_BIN_DIR)/
+	@cp -dpRf $< $(IPCAM_APP_BIN_DIR)/
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
diff --git a/fastboot_app/bpi_app/streaming_audio_playback.cpp b/fastboot_app/bpi_app/streaming_audio_playback.cpp
new file mode 100644
index 0000000..9e1d796
--- /dev/null
+++ b/fastboot_app/bpi_app/streaming_audio_playback.cpp
@@ -0,0 +1,354 @@
+/*
+ * streaming_audio_playback.c
+ *
+ * History:
+ *       2017/03/15 - [Jian Liu] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <stdio.h>          /* for printf, fprintf */
+#include <stdlib.h>         /* for atoi()          */
+#include <errno.h>
+#include <unistd.h>         /* for close()         */
+#include <string.h>         /* for strncpy()       */
+#include <time.h>           /* for usleep()        */
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <pthread.h>
+#include <sys/stat.h>
+#include <signal.h>
+#include "streaming_audio_playback.h"
+#include "audio_play.h"
+
+/*It would be much better use AM_PLAYBACK_URI_RTP,
+*    but at this moment, AM_PLAYBACK_URI_RTP is not ready
+*/
+#define USE_UNIX_DOMAIN_URI 1
+
+//-------------------------------------------------------------------------
+// interface implementation
+//  ---- TODO:  check rtp packets and handle jitter.
+//-------------------------------------------------------------------------
+typedef struct  _context_aplay_t
+{
+    AMPlaybackRtpUri rtp_uri;
+    pthread_t thread;
+    volatile int thread_running;
+}context_aplay_t;
+
+static context_aplay_t s_aplay_context;
+
+static void *aplay_thread_routine(void *arg);
+int  audio_play_initialize(AMPlaybackRtpUri &uri){
+    memset(&s_aplay_context,0,sizeof(context_aplay_t));
+    s_aplay_context.rtp_uri = uri;
+    s_aplay_context.thread_running = 1;
+    int ret = pthread_create(&s_aplay_context.thread, NULL, aplay_thread_routine, (void*)&s_aplay_context);
+    if (ret != 0) {
+        printf("faile to spawn  audio playback thread\n");
+        audio_play_finalize();
+        return -1;
+    }
+    return 0;
+}
+
+int  audio_play_finalize(void)
+{
+    s_aplay_context.thread_running = 0;
+    if(s_aplay_context.thread){
+        pthread_join(s_aplay_context.thread, NULL);
+    }
+    return 0;
+}
+
+
+
+#ifndef   USE_UNIX_DOMAIN_URI
+static void *aplay_thread_routine(void *arg){
+    context_aplay_t* context = (context_aplay_t*)arg;
+    AMIPlaybackPtr playback  = nullptr;
+    AMPlaybackUri uri;
+
+    load_audio_playback_driver();
+
+    signal(SIGPIPE, SIG_IGN);
+    playback = AMIPlayback::create();
+    if(!playback) {
+        goto err_exit;
+    }
+    if (!playback->init()) {
+        goto err_exit;
+    }
+    uri.type = AM_PLAYBACK_URI_RTP;
+    uri.media.rtp = context->rtp_uri;
+    if (!playback->add_uri(uri)) {
+        ERROR("Failed to add uri to  play list!");
+        goto err_exit;
+    }
+    playback->play();
+    while(context->thread_running){
+        usleep(1000 * 10);
+    }
+    playback->stop();
+err_exit:
+    return (void*)NULL;
+}
+
+#else //UNIX_DOMAIN_URI
+
+#define AUDIO_PLAYBACK_DOMAIN_NAME "/tmp/audio_playback0"
+
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <errno.h>
+#include <arpa/inet.h>
+#include <poll.h>
+#include <netinet/in.h>
+static inline int ff_network_wait_fd(int fd, int write)
+{
+    int ret;
+    int ev = write ? POLLOUT : POLLIN;
+    struct pollfd p;
+    p.fd = fd;
+    p.events = ev;
+    p.revents = 0;
+    while((ret = poll(&p, 1, 100) )< 0 && (errno == EINTR));
+    return ret < 0 ? (-errno) : p.revents & ev ? 0 : (-EAGAIN);
+}
+
+static inline int socket_write(int fd, void *buf, int size)
+{
+    int ret = ff_network_wait_fd(fd, 1);
+    if (ret < 0){
+        return ret;
+    }
+    while((ret = send(fd, buf, size, 0) ) < 0 && (errno == EINTR));
+    return (ret < 0) ? -errno : ret;
+}
+
+static int retry_transfer_wrapper(int fd, void *buf_, int size)
+{
+#define FFMAX(a,b) ((a) > (b) ? (a) : (b))
+    unsigned char *buf = (unsigned char *)buf_;
+    int len;
+    int fast_retries = 5;
+    len = 0;
+    while (len < size){
+        int ret = socket_write(fd, buf+len, size-len);
+        if (ret == (-EAGAIN)){
+            ret = 0;
+            if (fast_retries)
+                fast_retries--;
+            //else
+                //my_msleep(1);
+        }else if (ret < 1){
+            return ret < 0 ? ret : len;
+        }
+        if (ret){
+            fast_retries = FFMAX(fast_retries, 2);
+        }
+        len += ret;
+    }
+    return len;
+}
+
+static int create_domain_client(char *path)
+{
+    struct sockaddr_un addr;
+    int ret,count = 1000;
+
+    if (access (path, F_OK) != 0){
+        ERROR ("Server doesn't run: %s doesn't exist!",path);
+        return -1;
+    }
+
+    int sock_fd = socket (PF_UNIX, SOCK_STREAM, 0);
+    if(sock_fd < 0){
+        return -1;
+    }
+    memset (&addr, 0, sizeof (struct sockaddr_un));
+    addr.sun_family = AF_UNIX;
+    snprintf (addr.sun_path,sizeof(addr.sun_path),"%s",path);
+retry:
+    while( (ret = connect (sock_fd, (struct sockaddr *)&addr,sizeof (struct sockaddr_un))) < 0 && errno == EINTR);
+    if ( ret < 0){
+        if(errno == ECONNREFUSED){
+            /*retry, maybe the server is not ready yet for our case*/
+            --count;
+            if(count <= 0){
+                goto exit;
+            }
+            usleep(5000);
+            goto retry;
+        }
+        ERROR("Failed to connect domain server [%s],errno = %d\n",path,errno);
+        goto exit;
+    }
+    return sock_fd;
+exit:
+    close(sock_fd);
+    return -1;
+}
+
+static void *aplay_thread_routine(void *arg){
+    context_aplay_t* context = (context_aplay_t*)arg;
+    AMIPlaybackPtr playback  = nullptr;
+    AMPlaybackUri uri;
+    struct sockaddr *addr = NULL;
+    struct sockaddr_in addr4 = { 0 };
+    //struct sockaddr_in6 addr6 = { 0 };
+    socklen_t socket_len = sizeof(struct sockaddr);
+    int domain_sock = -1;
+    int rtp_sock = -1;
+    unsigned char  send_buf[2048];
+    unsigned char *recv_buf = &send_buf[8];
+    int recv_buf_len = 2040;
+    send_buf[0] = 'R';
+    send_buf[1] = 'T';
+    send_buf[2] = 'P';
+    send_buf[3] = ' ';
+    load_audio_playback_driver();
+
+    bool play_start = false;
+    signal(SIGPIPE, SIG_IGN);
+
+    //create rtp socket, TODO, at this moment, IPV4 only
+    if(context->rtp_uri.ip_domain != AM_PLAYBACK_IPV4){
+        ERROR("At this moment, support only IPV4\n");
+        goto err_exit;
+    }
+    if((rtp_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
+        goto err_exit;
+    }
+    addr4.sin_family = AF_INET;
+    addr4.sin_addr.s_addr = htonl(INADDR_ANY);
+    addr4.sin_port = htons(context->rtp_uri.udp_port);
+    addr = (struct sockaddr*)&addr4;
+    socket_len = sizeof(addr4);
+    if (bind(rtp_sock, addr, socket_len) < 0) {
+        goto err_exit;
+    }
+
+    //create playback instance and start it
+    remove(AUDIO_PLAYBACK_DOMAIN_NAME);//make sure domain-socket path has been removed
+    playback = AMIPlayback::create();
+    if(!playback) {
+        ERROR("Failed to create player!");
+        goto err_exit;
+    }
+    if (!playback->init()) {
+        ERROR("Failed to init player!");
+        goto err_exit;
+    }
+
+    uri.type = AM_PLAYBACK_URI_UNIX_DOMAIN;
+    uri.media.unix_domain.audio_type = context->rtp_uri.audio_type;
+    uri.media.unix_domain.channel = context->rtp_uri.channel;
+    uri.media.unix_domain.sample_rate = context->rtp_uri.sample_rate;
+    uri.media.unix_domain.playback_id_bit_map |= 0x00000001 << 0;
+    snprintf(uri.media.unix_domain.name,sizeof(uri.media.unix_domain.name),"%s",AUDIO_PLAYBACK_DOMAIN_NAME);
+    /*TODO ,
+    * It is weired that player->play() will fail here, at this moment, perform this operation after at least one packet has been sent to domain-socket-server.
+    */
+#if 0
+    if(!playback->play()){
+        ERROR("Failed to player->play()!");
+        goto err_exit;
+    }
+#endif
+
+    //create domain socket
+
+    while (context->thread_running) {
+        fd_set fds;
+        int max_fd = -1;
+        FD_ZERO(&fds);
+        FD_SET(rtp_sock, &fds);
+        max_fd = rtp_sock;
+        struct timeval tv;
+        tv.tv_sec = 0;
+        tv.tv_usec = 500000;
+        int ret;
+        while((ret = select(max_fd + 1, &fds, NULL, NULL, &tv)) < 0 && errno == EINTR);
+        if(ret == 0){
+            if(play_start){
+                play_start = false;
+                if(domain_sock != -1){
+                    close(domain_sock);
+                    domain_sock = -1;
+                }
+                playback->stop();
+            }
+            continue;
+        }
+        if(ret < 0){
+            break;
+        }
+        if (FD_ISSET(rtp_sock, &fds)) {
+            ssize_t recv_len;
+            while((recv_len = recv(rtp_sock, recv_buf,recv_buf_len, 0)) < 0  && errno == EINTR);
+            if(recv_len < 0){
+                goto err_exit;
+            }
+            /*TODO:
+            *    check rtp packets and handle jitter
+            */
+            if(!play_start){
+                remove(AUDIO_PLAYBACK_DOMAIN_NAME);//make sure domain-socket path has been removed
+                if (!playback->add_uri(uri)) {
+                    ERROR("Failed to add uri to  play list!");
+                    goto err_exit;
+                }
+                domain_sock = create_domain_client((char*)AUDIO_PLAYBACK_DOMAIN_NAME);
+                if (domain_sock < 0) {
+                    ERROR("failed to create domain socket");
+                    goto err_exit;
+                }
+            }
+
+            send_buf[4] = (recv_len & 0xff000000) >> 24;
+            send_buf[5] = (recv_len & 0x00ff0000) >> 16;
+            send_buf[6] = (recv_len & 0x0000ff00) >>  8;
+            send_buf[7] = (recv_len & 0x000000ff);;
+            retry_transfer_wrapper(domain_sock, send_buf,recv_len + 8);
+
+            if(!playback->play()){
+                ERROR("Failed to player->play()!");
+                break;
+            }
+            else{
+                play_start = true;
+            }
+        }
+    }
+err_exit:
+    if(play_start) playback->stop();
+    if(rtp_sock != -1) close(rtp_sock);
+    if(domain_sock != -1) close(domain_sock);
+    return (void*)NULL;
+}
+#endif
diff --git a/fastboot_app/bpi_app/streaming_audio_playback.h b/fastboot_app/bpi_app/streaming_audio_playback.h
new file mode 100644
index 0000000..c60515c
--- /dev/null
+++ b/fastboot_app/bpi_app/streaming_audio_playback.h
@@ -0,0 +1,42 @@
+/*
+ * streaming_audio_playback.h
+ *
+ * History:
+ *       2017/03/15 - [Jian Liu] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef _STREAMING_AUDIO_PLAYBACK_H_
+#define _STREAMING_AUDIO_PLAYBACK_H_
+
+#include "am_export_if.h"
+#include "am_playback_if.h"
+
+int  audio_play_initialize(AMPlaybackRtpUri &uri);
+int  audio_play_finalize(void);
+
+#endif//_STREAMING_AUDIO_PLAYBACK_H_
+
diff --git a/fastboot_app/bpi_app/streaming_rtp_over_udp.cpp b/fastboot_app/bpi_app/streaming_rtp_over_udp.cpp
new file mode 100644
index 0000000..e256dd4
--- /dev/null
+++ b/fastboot_app/bpi_app/streaming_rtp_over_udp.cpp
@@ -0,0 +1,1444 @@
+/*
+ * streaming_rtp_over_udp.c
+ *
+ * History:
+ *       2016/12/14 - Jian Liu] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <stdio.h>          /* for printf, fprintf */
+#include <stdlib.h>         /* for atoi()          */
+#include <errno.h>
+#include <unistd.h>         /* for close()         */
+#include <string.h>         /* for strncpy()       */
+#include <time.h>           /* for usleep()        */
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <pthread.h>
+#include <sys/stat.h>
+#include <signal.h>
+#include <inttypes.h>
+#include "am_video_reader_if.h"
+#include "am_video_address_if.h"
+#include "am_video_camera_if.h"
+#include "am_audio_capture_if.h"
+#include "am_audio_codec_if.h"
+#include "am_plugin.h"
+#include "am_video_types.h"
+#include "am_image_quality_if.h"
+#include "am_low_bitrate_control_if.h"
+#include "am_motion_detect_if.h"
+#include "am_encode_overlay_if.h"
+#include "streaming_rtp_over_udp.h"
+#include "bpi_oryx_config.h"
+
+static unsigned long long get_current_time(void){
+    struct timespec now;
+    clock_gettime(CLOCK_MONOTONIC,&now);
+    unsigned long long mseconds = now.tv_sec * 1000+ now.tv_nsec/1000000;
+    return mseconds;
+}
+#include <sys/time.h>
+static unsigned long long current_time_ms(void)
+{
+    struct timeval tv;
+    gettimeofday(&tv,NULL);
+    return (tv.tv_sec * 1000 + tv.tv_usec/1000);
+}
+static void setscheduler(int priority)
+{
+    struct sched_param sched_param;
+    int sched_policy = SCHED_RR;
+    if (sched_getparam(0, &sched_param) < 0) {
+        //printf("Scheduler getparam failed...\n");
+        return;
+    }
+    sched_param.sched_priority = sched_get_priority_max(sched_policy);
+    sched_param.sched_priority -= priority;
+    if (!sched_setscheduler(0, sched_policy, &sched_param)) {
+        //printf("Scheduler set to Round Robin with priority %i...\n", sched_param.sched_priority);
+        return;
+    }
+    printf("!!!Scheduler set to Round Robin with priority %i FAILED!!!\n", sched_param.sched_priority);
+}
+
+static char* base64_encode(char const* data, unsigned length) {
+  static const char s_base64_char[] =
+       "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+
+  unsigned char const* orig = (unsigned char const*)data;
+  if (orig == NULL) return NULL;
+
+  unsigned const num_24bit_values = length/3;
+  bool have_padding = (length > num_24bit_values*3);
+  bool have_padding2 = (length == num_24bit_values*3 + 2);
+  unsigned const num_result_bytes = 4*(num_24bit_values + have_padding);
+  char* result = new char[num_result_bytes+1]; // allow for trailing '\0'
+
+  // Map each full group of 3 input bytes into 4 output base-64 characters:
+  unsigned i;
+  for (i = 0; i < num_24bit_values; ++i) {
+    result[4*i+0] = s_base64_char[(orig[3*i]>>2)&0x3F];
+    result[4*i+1] = s_base64_char[(((orig[3*i]&0x3)<<4) | (orig[3*i+1]>>4))&0x3F];
+    result[4*i+2] = s_base64_char[((orig[3*i+1]<<2) | (orig[3*i+2]>>6))&0x3F];
+    result[4*i+3] = s_base64_char[orig[3*i+2]&0x3F];
+  }
+
+  // Now, take padding into account.  (Note: i == num_24bit_values)
+  if (have_padding) {
+    result[4*i+0] = s_base64_char[(orig[3*i]>>2)&0x3F];
+    if (have_padding2) {
+      result[4*i+1] = s_base64_char[(((orig[3*i]&0x3)<<4) | (orig[3*i+1]>>4))&0x3F];
+      result[4*i+2] = s_base64_char[(orig[3*i+1]<<2)&0x3F];
+    } else {
+      result[4*i+1] = s_base64_char[((orig[3*i]&0x3)<<4)&0x3F];
+      result[4*i+2] = '=';
+    }
+    result[4*i+3] = '=';
+  }
+
+  result[num_result_bytes] = '\0';
+  return result;
+}
+
+//---------------------------------------------------------------------------------------
+// rtp utils
+//---------------------------------------------------------------------------------------
+#ifndef WORDS_BIGENDIAN
+/*
+ * rtp_hdr_t represents an RTP header.  The bit-fields in
+ * this structure should be declared "unsigned int" instead of
+ * "unsigned char", but doing so causes the MS compiler to not
+ * fully pack the bit fields.
+ */
+
+typedef struct {
+    unsigned char cc : 4; /* CSRC count             */
+    unsigned char x : 1; /* header extension flag  */
+    unsigned char p : 1; /* padding flag           */
+    unsigned char version : 2; /* protocol version    */
+    unsigned char pt : 7; /* payload type           */
+    unsigned char m : 1; /* marker bit             */
+    uint16_t seq; /* sequence number        */
+    uint32_t ts; /* timestamp              */
+    uint32_t ssrc; /* synchronization source */
+} rtp_hdr_t;
+
+#else /*  BIG_ENDIAN */
+
+typedef struct {
+    unsigned char version : 2; /* protocol version    */
+    unsigned char p : 1; /* padding flag           */
+    unsigned char x : 1; /* header extension flag  */
+    unsigned char cc : 4; /* CSRC count             */
+    unsigned char m : 1; /* marker bit             */
+    unsigned char pt : 7; /* payload type           */
+    uint16_t seq; /* sequence number        */
+    uint32_t ts; /* timestamp              */
+    uint32_t ssrc; /* synchronization source */
+} rtp_hdr_t;
+#endif
+
+/*
+ * RTP_HEADER_LEN indicates the size of an RTP header
+ */
+#define RTP_HEADER_LEN   12
+/*
+ * RTP_MAX_BUF_LEN defines the largest RTP packet in the rtp.c implementation
+ */
+#define RTP_MAX_BUF_LEN  16384
+
+typedef struct {
+    rtp_hdr_t header;
+    char body[RTP_MAX_BUF_LEN];
+} rtp_msg_t;
+
+typedef struct rtp_sender_ctx {
+    rtp_msg_t message;
+    int socket;
+    struct sockaddr_in addr; /* reciever's address */
+} rtp_sender_ctx_t;
+typedef struct rtp_sender_ctx *rtp_sender_t;
+
+#define ADDR_IS_MULTICAST(a) IN_MULTICAST(htonl(a))
+
+#define stap_a_sps_pps_buf_size 1024
+#define MAX_RTP_PAYLOAD_LEN 1400
+typedef struct _rtp_session_t{
+    rtp_sender_t sender_;
+    int sock;
+    struct in_addr rcvr_addr;
+    struct ip_mreq mreq;
+    int count_;
+    unsigned int ssrc_;
+    int freq;
+    unsigned short port_base_;
+    unsigned int fake_ts;
+
+    //for video
+    int stap_a_sps_pps_len;
+    unsigned char stap_a_sps_pps[stap_a_sps_pps_buf_size];
+}rtp_session_t;
+
+static int rtp_sendto(rtp_sender_t sender, const void* msg, int len,
+                      unsigned int timestamp)
+{
+    int octets_sent;
+    int pkt_len = len + RTP_HEADER_LEN;
+
+    /* marshal data */
+    memcpy(sender->message.body, (char*)msg, len);
+
+    /* update header */
+    sender->message.header.seq = ntohs(sender->message.header.seq) + 1;
+    sender->message.header.seq = htons(sender->message.header.seq);
+    sender->message.header.ts = htonl(timestamp);
+
+    octets_sent = sendto(sender->socket, (void*)&sender->message,
+        pkt_len, 0, (struct sockaddr*)&sender->addr,
+        sizeof(struct sockaddr_in));
+    if (octets_sent != pkt_len) {
+        //perror("rtp_sendto() -- sendto failed");
+    }
+    return octets_sent;
+}
+
+static int rtp_sendto2(rtp_sender_t sender, const void* msg, int len,
+                       const void *msg2,int len2,unsigned int timestamp)
+{
+    int octets_sent;
+    int pkt_len = len + len2 + RTP_HEADER_LEN;
+
+    /* marshal data */
+    memcpy(sender->message.body, (char*)msg, len);
+    memcpy(&sender->message.body[len], (char*)msg2, len2);
+    /* update header */
+    sender->message.header.seq = ntohs(sender->message.header.seq) + 1;
+    sender->message.header.seq = htons(sender->message.header.seq);
+    sender->message.header.ts = htonl(timestamp);
+
+    octets_sent = sendto(sender->socket, (void*)&sender->message,
+        pkt_len, 0, (struct sockaddr*)&sender->addr,
+        sizeof(struct sockaddr_in));
+
+    if (octets_sent != pkt_len) {
+        perror("rtp_sendto2() -- sendto failed");
+    }
+    return octets_sent;
+}
+
+static int rtp_sender_init(rtp_sender_t sender, int sock,
+                           struct sockaddr_in addr, unsigned int ssrc,
+                           int payload_type)
+{
+    /* set header values */
+    sender->message.header.ssrc = htonl(ssrc);
+    sender->message.header.ts = 0;
+    sender->message.header.seq = (unsigned short)rand();
+    sender->message.header.m = 0;
+    sender->message.header.pt = (unsigned char)payload_type;
+    sender->message.header.version = 2;
+    sender->message.header.p = 0;
+    sender->message.header.x = 0;
+    sender->message.header.cc = 0;
+
+    /* set other stuff */
+    sender->socket = sock;
+    sender->addr = addr;
+    return 0;
+}
+
+static rtp_sender_t rtp_sender_alloc(void) {
+  return (rtp_sender_t)malloc(sizeof(rtp_sender_ctx_t));
+}
+
+static void rtp_sender_dealloc(rtp_sender_t rtp_ctx) {
+  free(rtp_ctx);
+}
+
+
+static pthread_mutex_t  rtp_mutex = PTHREAD_MUTEX_INITIALIZER;
+static int random_initialized = 0;
+static unsigned short get_port_base(void){
+    static unsigned short s_port_min = 50000;
+    static unsigned short s_port_max = 60000;
+    static unsigned short current_port  = 50000;
+
+    unsigned short port_base;
+    pthread_mutex_lock(&rtp_mutex);
+    port_base = current_port;
+    current_port += 2;
+    if( current_port >= s_port_max){
+        current_port = s_port_min;
+    }
+    pthread_mutex_unlock(&rtp_mutex);
+    return port_base;
+}
+static int create_udp_socket(unsigned short port){
+    struct sockaddr_in adr_inet;
+    memset(&adr_inet,0,sizeof(adr_inet));
+    adr_inet.sin_family = PF_INET;
+    adr_inet.sin_port   = htons(port);
+    adr_inet.sin_addr.s_addr = htonl(INADDR_ANY);
+    int sockfd = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
+    if (sockfd == -1){
+        return -1;
+    }
+    if(bind (sockfd, (struct sockaddr *) &adr_inet, sizeof (adr_inet)) < 0){
+        close(sockfd);
+        return -1;
+    }
+    return sockfd;
+}
+
+static void *rtp_session_init(char *address, unsigned short port, int payload_type,unsigned int ssrc){
+    rtp_session_t *session = (rtp_session_t*)malloc(sizeof(rtp_session_t));
+    if(!session) return (void*)0;
+
+    int ret = -1;
+    struct sockaddr_in name = {0};
+    unsigned char ttl = 5;
+
+    pthread_mutex_lock(&rtp_mutex);
+    if(!random_initialized){
+        srand(time(NULL));
+        random_initialized = 1;
+    }
+    pthread_mutex_unlock(&rtp_mutex);
+
+    /* set address */
+#ifdef HAVE_INET_ATON
+    if (0 == inet_aton(address, &session->rcvr_addr)) {
+        fprintf(stderr, "cannot parse IP v4 address %s\n", address);
+        exit(1);
+    }
+    if (session->rcvr_addr.s_addr == INADDR_NONE) {
+        fprintf(stderr, "address error");
+        exit(1);
+    }
+#else
+    session->rcvr_addr.s_addr = inet_addr(address);
+    if (0xffffffff == session->rcvr_addr.s_addr) {
+        fprintf(stderr, "cannot parse IP v4 address %s\n", address);
+        exit(1);
+    }
+#endif
+    /* open socket */
+    session->sock = -1;
+    int max_count =  10000;
+    while(max_count--){
+        session->port_base_ = get_port_base();
+        session->sock = create_udp_socket(session->port_base_);
+        if(session->sock > 0){
+            break;
+        }
+        close(session->sock),session->sock = -1;
+    }
+    if(session->sock == -1){
+        return (void*)0;
+    }
+
+    name.sin_addr   = session->rcvr_addr;
+    name.sin_family = PF_INET;
+    name.sin_port   = htons(port);
+
+    if (ADDR_IS_MULTICAST(session->rcvr_addr.s_addr)) {
+        ret = setsockopt(session->sock, IPPROTO_IP, IP_MULTICAST_TTL, &ttl, sizeof(ttl));
+        if (ret < 0) {
+            fprintf(stderr, "Failed to set TTL for multicast group\n");
+            perror("");
+            exit(1);
+        }
+        //struct ip_mreq mreq;
+        session->mreq.imr_multiaddr.s_addr = session->rcvr_addr.s_addr;
+        session->mreq.imr_interface.s_addr = htonl(INADDR_ANY);
+        ret = setsockopt(session->sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, (void*)&session->mreq,sizeof(session->mreq));
+        if (ret < 0) {
+            fprintf(stderr, "Failed to join multicast group\n");
+            perror("");
+            exit(1);
+        }
+    }
+
+    session->ssrc_ = ssrc;
+
+    /* initialize sender's rtp and srtp contexts */
+    session->sender_ = rtp_sender_alloc();
+    if (session->sender_ == NULL) {
+      fprintf(stderr, "error: malloc() failed\n");
+      exit(1);
+    }
+    rtp_sender_init(session->sender_, session->sock, name, session->ssrc_,payload_type);
+    session->count_ = 0;
+    return (void*)session;
+}
+
+static int rtp_session_uninit(void *session_){
+    rtp_session_t *session = (rtp_session_t*)session_;
+    if(session->sock != -1){
+       if(session->sender_){
+           rtp_sender_dealloc(session->sender_);
+           session->sender_ = NULL;
+       }
+        if (ADDR_IS_MULTICAST(session->rcvr_addr.s_addr)) {
+            setsockopt(session->sock, IPPROTO_IP, IP_DROP_MEMBERSHIP, (void*)&session->mreq,sizeof(session->mreq));
+        }
+       close(session->sock);
+       session->sock = -1;
+       free(session);
+   }
+   return 0;
+}
+
+//------------------------------------------------------------------------------------------
+//video process
+//------------------------------------------------------------------------------------------
+#define NAL_NON_IDR 1
+#define NAL_IDR 5
+
+#define MAX_VIDEO_FRAME_NUM 128
+
+typedef struct _stream_context_video_t
+{
+    int stream_id;
+    AMQueryFrameDesc  frame_queue[MAX_VIDEO_FRAME_NUM];
+    int read_index;
+    int write_index;
+    int frame_num;
+    int idr_frame_arrived;
+    int first_frame_sent;
+    int target_bitrate;
+    int enable_lbr;
+    const char *osd_label;
+    pthread_t thread;
+    volatile int thread_running;
+    rtp_session_t *session;
+    OryxVideoModule *late_module;
+}stream_context_video_t;
+
+typedef struct{
+    int i_payload;
+    unsigned char *p_payload;
+    int nal_type;
+} h264_nal_t;
+
+static int parse_to_get_nals(unsigned char *data, unsigned len,
+                             h264_nal_t *nals, int *nal_num,
+                             unsigned char last_naltype){
+    unsigned char *tmp_buffer_ = data;
+    unsigned tmp_pos = 0;
+    int nal_idx = 0;
+    unsigned char nal_type;
+    int get_nal_flag = 0;
+    if(!tmp_buffer_) return -1;
+    if(len <= 4) return -2;
+
+    while(1){
+        unsigned pos = tmp_pos + 4;
+        while(pos < len - 4){
+            if(tmp_buffer_[pos] == 0x00
+                && tmp_buffer_[pos + 1] == 0x00
+                && tmp_buffer_[pos + 2] == 0x00
+                && tmp_buffer_[pos + 3] == 0x01){
+                get_nal_flag = 1;
+                break;
+            }
+            ++pos;
+        }
+        if(!get_nal_flag){
+            printf("parse_to_get_nals, error bitstream ---"
+                   "can not find any NAL unit.\n");
+            break;
+        }
+
+        if(pos - tmp_pos >= 5){
+            nal_type = tmp_buffer_[tmp_pos + 4] & 0x1F;
+            if(nal_type == last_naltype){
+                nals[nal_idx].i_payload = len - tmp_pos;
+            }else{
+               nals[nal_idx].i_payload = pos - tmp_pos;
+            }
+            nals[nal_idx].p_payload = &tmp_buffer_[tmp_pos];
+            nals[nal_idx].nal_type = nal_type;
+            ++nal_idx;
+            tmp_pos  = pos;
+        }else{
+            *nal_num = nal_idx;
+            printf("parse_to_get_nals, error bitstream --- "
+                   "nal_idx = %d, pos = %d, len = %d\n",
+                   nal_idx, pos, len);
+            if(nal_idx >= 1){
+                printf("nal_type = ");
+                for(int i =0; i < nal_idx; i++)
+                    printf(" %d ", nals[i].nal_type);
+                printf("\n");
+            }
+            fflush(stdout);
+            break;
+        }
+        if(nal_type == last_naltype){
+            *nal_num = nal_idx;
+            break;
+        }
+        if(nal_idx >= *nal_num){
+            return -3;
+        }
+    }
+    return 0;
+}
+
+static int nalSend(rtp_session_t *session, const unsigned char *buf,
+                   int  size, long long timestamp){
+
+    int nal_size = size;
+    int nal_type = buf[0] & 0x1f;
+    //SPS/PPS/IDR/non-IDR
+    if(nal_type != 7 && nal_type != 8 && nal_type != 5 && nal_type != 1){
+        return 0;
+    }
+    if (size <= MAX_RTP_PAYLOAD_LEN) {
+        if(nal_type == 7){//SPS
+            session->stap_a_sps_pps_len = 0;
+            session->stap_a_sps_pps[0] = 0x78;//STAP-A
+            session->stap_a_sps_pps[1] = (size >> 8) & 0xff;
+            session->stap_a_sps_pps[2] = (size >> 0) & 0xff;
+            memcpy(&session->stap_a_sps_pps[3],buf,size);
+            session->stap_a_sps_pps_len += 3 + size;
+            return 0;
+        }else if(nal_type == 8){//PPS
+            unsigned char *buf_ =
+                &session->stap_a_sps_pps[session->stap_a_sps_pps_len];
+            buf_[0] = (size >> 8) & 0xff;
+            buf_[1] = (size >> 0) & 0xff;
+            memcpy(&buf_[2],buf,size);
+            session->stap_a_sps_pps_len += 2 + size;
+            session->sender_->message.header.m = 1;
+            rtp_sendto(session->sender_, session->stap_a_sps_pps,
+                       session->stap_a_sps_pps_len,(unsigned int)timestamp);
+        }else{
+            session->sender_->message.header.m = 1;
+            rtp_sendto(session->sender_, buf, size,(unsigned int)timestamp);
+        }
+        ++session->count_;
+        if(session->count_ > 10){
+           session->count_ = 0;
+           while(usleep(1000) < 0 && errno == EINTR);
+        }
+    } else {
+        unsigned char type = buf[0] & 0x1F;
+        unsigned char nri = buf[0] & 0x60;
+        unsigned char indicator = 28 | nri;
+        unsigned char  fu_header = type | (1 << 7);
+        buf += 1;
+        size -= 1;
+        while (size - 2> MAX_RTP_PAYLOAD_LEN) {
+            unsigned char rtp_buf[2];
+            rtp_buf[0] =  indicator;
+            rtp_buf[1] = fu_header;
+            session->sender_->message.header.m = 0;
+            rtp_sendto2(session->sender_, rtp_buf, 2, buf,
+                        MAX_RTP_PAYLOAD_LEN - 2,
+                        (unsigned int)timestamp);
+            buf += MAX_RTP_PAYLOAD_LEN - 2;
+            size -= MAX_RTP_PAYLOAD_LEN - 2;
+            fu_header &= ~(1 << 7);
+
+            ++session->count_;
+            if(session->count_ > 10){
+               session->count_ = 0;
+               while(usleep(1000) < 0 && errno == EINTR);
+           }
+        }
+        fu_header |= 1 << 6;
+
+        unsigned char rtp_buf[2];
+        rtp_buf[0] = indicator;
+        rtp_buf[1] = fu_header;
+        session->sender_->message.header.m = 1;
+        rtp_sendto2(session->sender_, rtp_buf, 2, buf, size,
+                    (unsigned int)timestamp);
+        ++session->count_;
+        if(session->count_ > 10){
+           session->count_ = 0;
+           while(usleep(1000) < 0 && errno == EINTR);
+        }
+    }
+    return nal_size;
+}
+
+static int rtp_send_h264(void *session_, AMQueryFrameDesc *desc,
+                         AMIVideoAddressPtr address){
+    rtp_session_t *session =  (rtp_session_t *)session_;
+    h264_nal_t nals[8];
+    int nal_num = 8;
+    int i;
+    unsigned char last_naltype =
+        (desc->video.type != AM_VIDEO_FRAME_TYPE_IDR) ? NAL_NON_IDR : NAL_IDR;
+    AMAddress video_addr;
+    if (address->video_addr_get(*desc, video_addr)!= AM_RESULT_OK) {
+        printf("Failed to get the address.\n");
+        return -1;
+    }
+    if((i = parse_to_get_nals(video_addr.data, desc->video.data_size,
+                              nals, &nal_num, last_naltype)) < 0){
+        printf("rtp_send_h264 --- "
+               "failed to parse_to_get_nals, ret %d, nal_num = %d\n",
+               i, nal_num);
+        fflush(stdout);
+        return -1;
+    }
+    int sent_size = 0;
+    for(i = 0; i < nal_num; i++){
+        sent_size += nalSend(session, nals[i].p_payload + 4,
+                             nals[i].i_payload - 4, desc->pts);
+    }
+    return 0;
+}
+
+static inline int meet_start_byte(const unsigned char *stream_head)
+{
+    constexpr unsigned int start_code = 0x01000000;
+    if (*(int*)stream_head == start_code) {
+        return 1;
+    }
+
+    return 0;
+}
+
+/* strip off 0x00 0x00 0x00 0x01 from bit stream */
+static int parse_to_get_hevc_nals(const unsigned char *stream_buf,
+                                  const unsigned int stream_len,
+                                  h264_nal_t *nals, int *nal_num)
+{
+    constexpr unsigned int NALU_START_BYTE_LEN = 4;
+    unsigned int byte_pos = 0;
+    unsigned int prev_nalu_pos = 0;
+    int _nal_num = 0;
+    int ret = -1;
+
+    while (byte_pos < stream_len - NALU_START_BYTE_LEN) {
+        if (meet_start_byte(&stream_buf[byte_pos])) {
+            nals[_nal_num].p_payload =
+                (unsigned char*)&stream_buf[byte_pos + NALU_START_BYTE_LEN];
+            nals[_nal_num].nal_type =
+                (stream_buf[byte_pos + NALU_START_BYTE_LEN] & 0x7E) >> 1;
+            if (_nal_num > 0) {
+                nals[_nal_num - 1].i_payload =
+                    byte_pos - prev_nalu_pos - NALU_START_BYTE_LEN;
+            }
+            prev_nalu_pos = byte_pos;
+            _nal_num++;
+            byte_pos += 4;
+        } else {
+            byte_pos++;
+            continue;
+        }
+    }
+
+    if (_nal_num > 0 && _nal_num < *nal_num) {
+        nals[_nal_num - 1].i_payload =
+            stream_len - prev_nalu_pos - NALU_START_BYTE_LEN;
+        ret = 0;
+    }
+    *nal_num = _nal_num;
+    return ret;
+}
+
+static int send_hevc_fu(rtp_session_t *session, const unsigned char *buf,
+                        int nal_size, long long timestamp, int nal_type)
+{
+    constexpr int FU_HDR_LEN = 3;
+    constexpr int FU_PAYLOAD_LEN = MAX_RTP_PAYLOAD_LEN - FU_HDR_LEN;
+    constexpr unsigned char FU_TYPE = 49;
+    unsigned char fu_hdr[FU_HDR_LEN] = {0};
+    int sent_size = -1;
+    fu_hdr[0] = (buf[0] & 0x81) | (FU_TYPE << 1);
+    fu_hdr[1] = buf[1];
+    fu_hdr[2] = 0x80 | nal_type;
+
+    buf += 2;
+    nal_size -= 2;
+    while (nal_size > FU_PAYLOAD_LEN) {
+        session->sender_->message.header.m = 0;
+        sent_size = rtp_sendto2(session->sender_, fu_hdr, FU_HDR_LEN, buf,
+                          FU_PAYLOAD_LEN, (unsigned int)timestamp);
+        buf += FU_PAYLOAD_LEN;
+        nal_size -= FU_PAYLOAD_LEN;
+        fu_hdr[2] &= 0x3F;
+        ++session->count_;
+        if (session->count_ > 10) {
+            session->count_ = 0;
+            while (usleep(1000) < 0 && errno == EINTR);
+        }
+    }
+
+    fu_hdr[2] = 0x40 | nal_type;
+    session->sender_->message.header.m = 1;
+    sent_size = rtp_sendto2(session->sender_, fu_hdr, FU_HDR_LEN, buf, nal_size,
+                      (unsigned int)timestamp);
+    ++session->count_;
+    if (session->count_ > 10) {
+        session->count_ = 0;
+        while (usleep(1000) < 0 && errno == EINTR);
+    }
+
+    return sent_size;
+}
+
+static int send_hevc_single(rtp_session_t *session, const unsigned char *buf,
+                            int nal_size, long long timestamp)
+{
+    int sent_size = -1;
+    session->sender_->message.header.m = 1;
+    sent_size = rtp_sendto(session->sender_, buf, nal_size, timestamp);
+    ++session->count_;
+
+    return sent_size;
+}
+
+static int send_hevc_nal(rtp_session_t *session, h264_nal_t *nals,
+                         long long timestamp)
+{
+    int sent_size = -1;
+    if (nals->i_payload > MAX_RTP_PAYLOAD_LEN){
+        sent_size = send_hevc_fu(session, nals->p_payload, nals->i_payload,
+                                 timestamp, nals->nal_type);
+    } else {
+        sent_size = send_hevc_single(session, nals->p_payload, nals->i_payload,
+                                     timestamp);
+    }
+
+    return sent_size;
+}
+
+static int rtp_send_h265(void *session_, AMQueryFrameDesc *desc,
+                         AMIVideoAddressPtr address){
+    constexpr int MAX_NALU_NUM = 10;
+    rtp_session_t* session = (rtp_session_t*)session_;
+    h264_nal_t nals[MAX_NALU_NUM] = {0};
+    int nal_num = MAX_NALU_NUM;
+    int sent_size = -1;
+
+    AMAddress video_addr;
+    if (address->video_addr_get(*desc, video_addr) != AM_RESULT_OK) {
+        printf("Failed to get the address.\n");
+        return sent_size;
+    }
+    if (parse_to_get_hevc_nals(video_addr.data, desc->video.data_size,
+            nals, &nal_num) < 0) {
+        printf("%s --- failed to parse nal, nal_num = %d\n", __func__, nal_num);
+        return sent_size;
+    }
+    for (int i = 0; i < nal_num; i++) {
+        if (nals[i].nal_type == 0x23) continue;  // jump delimiter
+        sent_size += send_hevc_nal(session, &nals[i], desc->pts);
+    }
+    return sent_size;
+}
+
+static void video_queue_append(stream_context_video_t *context,
+                               AMQueryFrameDesc *desc)
+{
+    if(context->frame_num == MAX_VIDEO_FRAME_NUM){
+         context->idr_frame_arrived = 0;
+         AMQueryFrameDesc *desc_ = &context->frame_queue[context->read_index];
+         if(desc_->video.type == AM_VIDEO_FRAME_TYPE_IDR){
+             context->read_index =
+                 (context->read_index + 1) % MAX_VIDEO_FRAME_NUM;
+             -- context->frame_num;
+         }
+
+         int frame_num = context->frame_num;
+         int i;
+         for(i = 0 ; i  < frame_num; i++){
+             desc_ = &context->frame_queue[context->read_index];
+             if(desc_->video.type != AM_VIDEO_FRAME_TYPE_IDR){
+                 context->read_index =
+                     (context->read_index + 1) % MAX_VIDEO_FRAME_NUM;
+                 -- context->frame_num;
+             }else{
+                 context->idr_frame_arrived += 1;
+                 break;
+             }
+         }
+    }
+    if(!context->idr_frame_arrived){
+         if(desc->video.type != AM_VIDEO_FRAME_TYPE_IDR){
+             return;
+         }
+        context->idr_frame_arrived += 1;
+    }
+    memcpy(&context->frame_queue[context->write_index],
+           desc, sizeof(AMQueryFrameDesc));
+    context->write_index = (context->write_index +1)% MAX_VIDEO_FRAME_NUM;
+    ++ context->frame_num;
+}
+
+AMQueryFrameDesc *video_queue_get(stream_context_video_t *context)
+{
+    if(context->frame_num > 0){
+         AMQueryFrameDesc *packet = &context->frame_queue[context->read_index];
+         context->read_index = (context->read_index + 1) % MAX_VIDEO_FRAME_NUM;
+         -- context->frame_num;
+         return packet;
+    }
+    return NULL;
+}
+
+static int streaming_queue_frame(stream_context_video_t *context,
+                                 AMQueryFrameDesc *desc)
+{
+    video_queue_append(context,desc);
+    return 0;
+}
+
+static void show_h264_sdp_config(unsigned char *stap_a);
+static int streaming_send_frames(stream_context_video_t *handle,
+                                 AMIVideoAddressPtr address)
+{
+    int ret = 0;
+    for (int i = 0; i < 2; i++) {
+        AMQueryFrameDesc *desc = video_queue_get(handle);
+        if (desc) {
+            if (desc->video.stream_type == AM_STREAM_TYPE_H264) {
+                rtp_send_h264(handle->session, desc, address);
+            } else if(desc->video.stream_type == AM_STREAM_TYPE_H265) {
+                rtp_send_h265(handle->session, desc, address);
+            } else {
+                printf("streaming_send_frames -- stream type not suppoted.\n");
+                ret = -1;
+                break;
+            }
+            if (!handle->first_frame_sent) {
+                printf("streaming_send_frames --- first_frame_sent, "
+                       "frame_num = %d, current_time= %llu, pts = %" PRId64 "\n",
+                       handle->frame_num, get_current_time(), desc->pts);
+                //to do, add show_h265_sdp_config
+                if(desc->video.stream_type == AM_STREAM_TYPE_H264)
+                    show_h264_sdp_config(handle->session->stap_a_sps_pps);
+                handle->first_frame_sent = 1;
+            }
+        }
+    }
+    return ret;
+}
+
+static int handle_predata(stream_context_video_t *handle,
+                          AMIVideoReaderPtr reader)
+{
+    const int MAX_PREDATA_NUM = 300;
+    AMQueryFrameDesc *frame_desc_pre = new AMQueryFrameDesc[MAX_PREDATA_NUM];
+    if(!frame_desc_pre){
+        printf("handle_predata --- failed to alloc memory\n");
+        return -1;
+    }
+    unsigned long long video_prev_ms = 0;
+    int index = 0, start = -1;
+    unsigned long long now;
+    AM_RESULT result;
+    while(1){
+        now = current_time_ms();
+        result = reader->query_video_frame(frame_desc_pre[index],0);
+        if(result == AM_RESULT_OK
+            && frame_desc_pre[index].video.stream_id
+                == (unsigned int)handle->stream_id){
+            if(frame_desc_pre[index].video.type == AM_VIDEO_FRAME_TYPE_IDR){
+                start = index;
+            }
+            index++;
+            if(index == MAX_PREDATA_NUM){
+                index = 0;
+                continue;
+            }
+            if(video_prev_ms && now - video_prev_ms > 10){
+                break;
+            }
+            video_prev_ms = now;
+        }else{
+            break;
+        }
+    }
+
+    if(start == -1){
+        printf("handle_predata [%d frames]--- No key frame found\n", index);
+        delete [] frame_desc_pre;
+        return -1;
+    }
+    if(start < index){
+        while(start < index){
+            streaming_queue_frame(handle, &frame_desc_pre[start]);
+            start++;
+        }
+    }else{
+        while(start < MAX_PREDATA_NUM){
+            streaming_queue_frame(handle, &frame_desc_pre[start]);
+            start++;
+        }
+        start = 0;
+        while(start < index){
+            streaming_queue_frame(handle, &frame_desc_pre[start]);
+            start++;
+        }
+    }
+
+    delete [] frame_desc_pre;
+    return 0;
+}
+
+static int start_late_modules(stream_context_video_t *param)
+{
+    OryxVideoModule *late_module = param->late_module;
+    if (!param->enable_lbr) {
+        late_module->set_bitrate(param->target_bitrate);
+    }
+
+    late_module->start_smart_avc(param->enable_lbr);
+    late_module->start_overlay(param->osd_label);
+    late_module->start_linux_aaa();
+
+    return 0;
+}
+
+static int stop_late_modules(OryxVideoModule *late_module)
+{
+    late_module->stop_smart_avc();
+    late_module->stop_overlay();
+    late_module->stop_linux_aaa();
+    late_module->stop_camera();
+
+    return 0;
+}
+
+static void* video_thread_routine(void* param)
+{
+    stream_context_video_t *handle = (stream_context_video_t*)param;
+    AM_RESULT result = AM_RESULT_OK;
+    AMQueryFrameDesc frame_desc;
+
+    setscheduler(10);
+    AMIVideoReaderPtr reader;
+    AMIVideoAddressPtr address;
+    if (!(reader = AMIVideoReader::get_instance())) {
+        printf("video_thread_routine -- Failed to create greader!\n");
+        return (void*)NULL;
+    }
+    if (!(address = AMIVideoAddress::get_instance())) {
+        printf("video_thread_routine --- Failed to get instance of VideoAddress!\n");
+        return (void*)NULL;
+    }
+    if (handle_predata(handle,reader) < 0) {
+        printf("video_thread_routine --- Failed to handle_predata!\n");
+        return (void*)NULL;
+    }
+    signal(SIGPIPE, SIG_IGN);
+    while (handle->thread_running) {
+        streaming_send_frames(handle, address);
+        result = reader->query_video_frame(frame_desc, 0);
+        if (result == AM_RESULT_OK &&
+            frame_desc.video.stream_id == (unsigned int) handle->stream_id) {
+            streaming_queue_frame(handle, &frame_desc);
+        } else if (result != AM_RESULT_ERR_AGAIN) {
+            printf("Failed to query video frame.\n");
+            break;
+        }
+        while(usleep(1000) < 0 && errno == EINTR);
+    }
+
+    return (void*)NULL;
+}
+
+//------------------------------------------------------------------------------------------
+//audio process
+//------------------------------------------------------------------------------------------
+#define MAX_AUDIO_CHUNK_SIZE 2048
+typedef struct _audio_frame_packet_t{
+    unsigned char data[MAX_AUDIO_CHUNK_SIZE];
+    int size;
+    long long pts_90k;
+}audio_frame_packet_t;
+
+typedef int (*rtp_send_audio)(rtp_session_t *session,unsigned char *data,int data_size,unsigned int pts_inc);
+
+#define MAX_AUDIO_FRAME_NUM  64
+typedef struct  _stream_context_audio_t
+{
+    char codec_name[16];
+    audio_frame_packet_t  *frame_queue;
+    int read_index;
+    int write_index;
+    int frame_num;
+    AMIAudioCapture *input;
+    AMPlugin *plugin;
+    AM_AUDIO_INFO codec_required_info;
+    rtp_send_audio  rtp_send;
+    unsigned int pts_inc;
+    AMIAudioCodec *encoder;
+    unsigned char result_buf[MAX_AUDIO_CHUNK_SIZE];
+    pthread_t  thread;
+    volatile int thread_running;
+    int predata_processed;
+    unsigned long long prev_ms;
+    rtp_session_t *session;
+}stream_context_audio_t;
+
+static void audio_callback(AudioCapture *data);
+static bool initialize_audio_encoder(stream_context_audio_t *handle);
+static audio_frame_packet_t *audio_queue_get(stream_context_audio_t *context,int *frame_num);
+static int rtp_send_raw(rtp_session_t *session,unsigned char *data,int data_size,unsigned int pts_inc);
+static int rtp_send_aac(rtp_session_t *session,unsigned char *data,int data_size,unsigned int pts_inc);
+static void* audio_thread_routine(void* param)
+{
+    stream_context_audio_t *handle = (stream_context_audio_t*)param;
+    AM_AUDIO_INFO *info = &handle->codec_required_info;
+    int first_frame_sent = 0;
+    AM_AUDIO_CODEC_TYPE codec_type;
+
+    setscheduler(10);
+
+    printf("audio_thread_routine --start --current_time= %llu\n",get_current_time());
+
+    handle->predata_processed = 0;
+    handle->prev_ms = 0;
+    if(!initialize_audio_encoder(handle)){
+        printf("audio_thread_routine -- initialize_audio_encoder  failed\n");
+        goto err_exit;
+    }
+    if(info->chunk_size > MAX_AUDIO_CHUNK_SIZE){
+        printf("audio_thread_routine -- audio-chunk-size allocated is too small, %d wanted\n",info->chunk_size);
+        goto err_exit;
+    }
+
+    codec_type = handle->encoder->get_codec_type();
+    switch(codec_type){
+    case AM_AUDIO_CODEC_AAC:
+        handle->rtp_send = rtp_send_aac;
+        handle->pts_inc = 1024;
+        break;
+    case AM_AUDIO_CODEC_G711:
+    case AM_AUDIO_CODEC_G726:
+    case AM_AUDIO_CODEC_OPUS:
+        handle->rtp_send = rtp_send_raw;
+        handle->pts_inc = info->chunk_size/info->channels/sizeof(short);//TODO
+        break;
+    default:
+        handle->rtp_send = NULL;
+        handle->pts_inc = 0;
+        break;
+    }
+    if(!handle->rtp_send){
+        printf("audio_thread_routine -- audio codec type [%d] not supported\n",info->type);
+        goto err_exit;
+    }
+    printf("Audio INFO: channels %d, sample-rate %d, chunk_size_bytes %d,pts_inc = %u\n",info->channels,info->sample_rate,info->chunk_size,handle->pts_inc);
+
+    handle->frame_queue = new audio_frame_packet_t[MAX_AUDIO_FRAME_NUM];
+    if(!handle->frame_queue){
+        printf("audio_thread_routine -- failed to alloc memory\n");
+        goto err_exit;
+    }
+    handle->input  = create_audio_capture("raw","oryx_module_capture",handle,audio_callback);
+    if(!handle->input) {
+        printf("audio_thread_routine -- Failed to create audio capture with interface [raw]\n");
+        goto err_exit;
+    }
+    if (!handle->input->set_channel(info->channels) ||
+        !handle->input->set_sample_rate(info->sample_rate)||
+        !handle->input->set_chunk_bytes(info->chunk_size) ||
+        !handle->input->set_sample_format((AM_AUDIO_SAMPLE_FORMAT)info->sample_format /*AM_SAMPLE_S16LE*/) ){
+        printf("Set audio parameter failed\n");
+        goto err_exit;
+    }
+    if (!handle->input->start(90/*volume, not used*/)) {
+        printf("Start audio capture failed\n");
+        goto err_exit;
+    }
+    printf("audio_thread_routine --audio-capture start --current_time= %llu\n",get_current_time());
+
+    signal(SIGPIPE, SIG_IGN);
+    while(handle->thread_running){
+        int frame_num;
+        audio_frame_packet_t *packet = audio_queue_get(handle,&frame_num);
+        if(packet){
+            unsigned int out_size;
+            if(!first_frame_sent){
+                printf("audio_thread_routine --get first packet -- current_time = %llu\n",get_current_time());
+            }
+            if (handle->encoder->encode(packet->data, info->chunk_size,handle->result_buf,&out_size)) {
+                (* handle->rtp_send)(handle->session,handle->result_buf,out_size,handle->pts_inc);
+                if(!first_frame_sent){
+                     printf("audio_thread_routine ---first_frame_sent , frame_num = %d, current_time= %llu\n",frame_num,get_current_time());
+                     first_frame_sent = 1;
+                }else{
+                     //printf("audio_thread_routine --- frame_num = %d, current_time_ms= %llu\n",frame_num,current_time_ms());
+                }
+            }
+        }
+        //while(usleep(1000) < 0 && errno == EINTR);
+    }
+err_exit:
+    if(handle->input){
+        handle->input->stop();
+        handle->input->destroy();
+    }
+    if(handle->encoder){
+        handle->encoder->destroy(),handle->encoder = NULL;
+    }
+    if(handle->plugin){
+        handle->plugin->destroy(),handle->plugin = NULL;
+    }
+    if(handle->frame_queue){
+        delete [](handle->frame_queue);
+    }
+    return (void*)NULL;
+}
+
+#ifdef BUILD_AMBARELLA_ORYX_CODEC_DIR
+#define ORYX_CODEC_DIR ((const char*)BUILD_AMBARELLA_ORYX_CODEC_DIR)
+#else
+#define ORYX_CODEC_DIR ((const char*)"/usr/lib/oryx/codec")
+#endif
+
+#ifdef BUILD_AMBARELLA_ORYX_CONF_DIR
+#define ORYX_CODEC_CONF_DIR \
+  (const char*)(BUILD_AMBARELLA_ORYX_CONF_DIR"/stream/codec")
+#else
+#define ORYX_CODEC_CONF_DIR ((const char*)"/etc/oryx/stream/codec")
+#endif
+
+static bool initialize_audio_encoder(stream_context_audio_t *handle)
+{
+    bool ret = false;
+    std::string codec = ORYX_CODEC_DIR;
+    codec.append("/codec-").append(handle->codec_name).append(".so");
+    handle->plugin = AMPlugin::create(codec.c_str());
+    if (handle->plugin) {
+        char *codec_name = handle->codec_name;
+        AudioCodecNew get_audio_codec = (AudioCodecNew)handle->plugin->get_symbol(AUDIO_CODEC_NEW);
+        if (get_audio_codec) {
+            std::string codecConf = ORYX_CODEC_CONF_DIR;
+            codecConf.append("/codec-").append(codec_name).append(".acs");
+            handle->encoder = get_audio_codec(codecConf.c_str());
+            if (handle->encoder) {
+                /* Setup audio source parameters */
+                handle->codec_required_info.channels = 1;
+                handle->codec_required_info.sample_format = AM_SAMPLE_S16LE;
+                handle->codec_required_info.sample_size = 2;
+                if(!strcmp(codec_name, "aac-48k")){
+                    handle->codec_required_info.type = AM_AUDIO_AAC;
+                    handle->codec_required_info.sample_rate = 48000;
+                }else if(!strcmp(codec_name, "aac-16k")){
+                    handle->codec_required_info.type = AM_AUDIO_AAC;
+                    handle->codec_required_info.sample_rate = 16000;
+                }else if(!strcmp(codec_name, "g711-8k")){
+                    handle->codec_required_info.type = AM_AUDIO_G711A;
+                    handle->codec_required_info.sample_rate = 8000;
+                }else{
+                    printf("unknown codec name:%s\n", codec_name);
+                }
+
+                if (handle->encoder->check_encode_src_parameter(handle->codec_required_info)) {
+                    handle->codec_required_info.chunk_size = handle->encoder->get_encode_required_chunk_size(handle->codec_required_info);
+                    //printf("Audio codec %s is loaded!\n",codec_name);
+                    if (handle->encoder->initialize(&handle->codec_required_info, AM_AUDIO_CODEC_MODE_ENCODE)) {
+                        //printf("initialize codec %s, done!\n", codec_name);
+                        ret = true;
+                    }else{
+                        printf("Failed to initialize codec %s, abort!\n", codec_name);
+                    }
+                } else {
+                    printf("Failed to get codec %s required audio parameters!\n",codec_name);
+                }
+            } else {
+                printf("Failed to load audio codec %s!\n", codec_name);
+            }
+        } else {
+            printf("Failed to get symbol (%s) from %s!\n", AUDIO_CODEC_NEW, codec.c_str());
+        }
+    }
+    return ret;
+}
+
+static int rtp_send_raw(rtp_session_t *session,unsigned char *data,int data_size,unsigned int pts_inc)
+{
+    session->sender_->message.header.m = 1;
+    rtp_sendto(session->sender_,data,data_size,session->fake_ts);
+    session->fake_ts += pts_inc;
+    return 0;
+}
+
+static void show_aac_sdp_config(unsigned char *aac_adts_header);
+static int rtp_send_aac(rtp_session_t *session,unsigned char *data,int data_size,unsigned int pts_inc)
+{
+    static int count = 0;
+    if(!count){
+        show_aac_sdp_config(data);
+        count = 1;
+    }
+    int size = data_size - 7;
+    unsigned char rtp_buf[4];
+    rtp_buf[0] = 0x00;
+    rtp_buf[1] = 0x10;
+    rtp_buf[2] = (size & 0x1fe0) >> 5;
+    rtp_buf[3] = (size & 0x1f) << 3;
+    session->sender_->message.header.m = 1;
+    rtp_sendto2(session->sender_, rtp_buf,4,data + 7, size,(unsigned int)session->fake_ts);
+    session->fake_ts += pts_inc;
+    //printf("rtp_send_aac ---- packet_size = %d, packet_pts = %u, curent_time = %u\n",size + 4,  session->fake_ts,get_current_time());
+    return 0;
+}
+
+static pthread_mutex_t aq_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pthread_cond_t aq_cond = PTHREAD_COND_INITIALIZER;
+static audio_frame_packet_t *audio_queue_get(stream_context_audio_t *context, int *frame_num)
+{
+    pthread_mutex_lock(&aq_mutex);
+    while (context->frame_num <= 0) {
+        pthread_cond_wait(&aq_cond, &aq_mutex);
+    }
+    if(context->frame_num){
+        audio_frame_packet_t *packet = &context->frame_queue[context->read_index];
+        context->read_index = (context->read_index + 1) % MAX_AUDIO_FRAME_NUM;
+        -- context->frame_num;
+        *frame_num = context->frame_num;
+        pthread_mutex_unlock(&aq_mutex);
+        return packet;
+    }
+    pthread_mutex_unlock(&aq_mutex);
+    return NULL;
+}
+
+static int audio_queue_frame(stream_context_audio_t *context,AudioPacket *packet)
+{
+    /*streaming mode, discard all the pre-captured sampels
+    */
+    if(!context->predata_processed){
+        unsigned long long now = current_time_ms();//get_current_time();
+        if(context->prev_ms  && now - context->prev_ms > 10){
+            context->predata_processed  = 1;
+        }
+        context->prev_ms = now;
+    }
+    if(context->predata_processed){
+        pthread_mutex_lock(&aq_mutex);
+        if(context->frame_num == MAX_AUDIO_FRAME_NUM){
+            context->read_index = 0;
+            context->write_index = 0;
+            context->frame_num = 0;
+            printf("audio_queue_frame --- flush data\n");
+        }
+        memcpy(context->frame_queue[context->write_index].data,(void*)packet->data,packet->length);
+        context->frame_queue[context->write_index].size  = packet->length;
+        context->frame_queue[context->write_index].pts_90k = packet->pts;
+        context->write_index = (context->write_index +1)% MAX_AUDIO_FRAME_NUM;
+        ++ context->frame_num;
+        pthread_cond_signal(&aq_cond);
+        pthread_mutex_unlock(&aq_mutex);
+    }
+    return 0;
+}
+
+static void audio_callback(AudioCapture *data){
+    stream_context_audio_t *handle = (stream_context_audio_t*)data->owner;
+    audio_queue_frame(handle,&data->packet);
+}
+
+//-------------------------------------------------------------------------
+// interface implementation
+//-------------------------------------------------------------------------
+static stream_context_video_t   s_stream_context_video;
+static stream_context_audio_t   s_stream_context_audio;
+static transport_info_t s_transport_info;
+
+int streaming_initialize(bpi_streamer_info *streamer_info)
+{
+    OryxVideoModule *video_module = OryxVideoModule::get_instance();
+    if (!video_module->start_camera()){
+        printf("failed to start video camera.\n");
+        return -1;
+    }
+    memset(&s_stream_context_video, 0, sizeof(s_stream_context_video));
+    memset(&s_stream_context_audio, 0, sizeof(s_stream_context_audio));
+    s_stream_context_video.stream_id = streamer_info->stream_id;
+    s_stream_context_video.target_bitrate = streamer_info->target_bitrate;
+    s_stream_context_video.enable_lbr = streamer_info->enable_lbr;
+    s_stream_context_video.osd_label = streamer_info->osd_label;
+    s_stream_context_video.late_module = video_module;
+    snprintf(s_stream_context_audio.codec_name,
+             sizeof(s_stream_context_audio.codec_name),
+             "%s",
+             streamer_info->audio_codec_name);
+    memcpy(&s_transport_info, streamer_info->transport_info,
+           sizeof(transport_info_t));
+
+    if (streamer_info->transport_info->video.enable) {
+        s_stream_context_video.session = (rtp_session_t*)
+            rtp_session_init(s_transport_info.ipaddress,
+                             s_transport_info.video.port,
+                             s_transport_info.video.payload_type,
+                             s_transport_info.video.ssrc);
+        if (!s_stream_context_video.session) {
+            printf("video rtp_session_init  failed 1\n");
+            streaming_finalize();
+            return -1;
+        }
+    }
+    if (streamer_info->transport_info->audio.enable) {
+        s_stream_context_audio.session = (rtp_session_t*)
+            rtp_session_init(s_transport_info.ipaddress,
+                             s_transport_info.audio.port,
+                             s_transport_info.audio.payload_type,
+                             s_transport_info.audio.ssrc);
+        if (!s_stream_context_audio.session) {
+            printf("audio rtp_session_init failed 1\n");
+            streaming_finalize();
+            return -1;
+        }
+    }
+
+    int ret;
+    if (streamer_info->transport_info->video.enable) {
+        s_stream_context_video.thread_running = 1;
+        ret = pthread_create(&s_stream_context_video.thread, NULL,
+                             video_thread_routine,
+                             (void*) &s_stream_context_video);
+        if (ret != 0) {
+            printf("fail to spawn video thread\n");
+            streaming_finalize();
+            return -1;
+        }
+    }
+    if (streamer_info->transport_info->audio.enable) {
+        s_stream_context_audio.thread_running = 1;
+        ret = pthread_create(&s_stream_context_audio.thread, NULL,
+                             audio_thread_routine,
+                             (void*) &s_stream_context_audio);
+        if (ret != 0) {
+            printf("fail to spawn audio thread\n");
+            streaming_finalize();
+            return -1;
+        }
+    }
+    if(s_stream_context_video.thread_running){
+        start_late_modules(&s_stream_context_video);
+    }
+
+    return 0;
+}
+
+int streaming_finalize(void)
+{
+    printf("%s:called\n", __func__);
+    s_stream_context_video.thread_running = 0;
+    if(s_stream_context_video.thread){
+        pthread_join(s_stream_context_video.thread, NULL);
+    }
+    s_stream_context_audio.thread_running = 0;
+    if(s_stream_context_audio.thread){
+        pthread_join(s_stream_context_audio.thread, NULL);
+    }
+
+    if(s_stream_context_video.session){
+        rtp_session_uninit(s_stream_context_video.session);
+    }
+    if(s_stream_context_audio.session){
+        rtp_session_uninit(s_stream_context_audio.session);
+    }
+    stop_late_modules(s_stream_context_video.late_module);
+
+    printf("%s:done\n", __func__);
+    return 0;
+}
+
+static void show_h264_sdp_config(unsigned char *stap_a){
+    // Generate a new "a=fmtp:" line each time, using our SPS and PPS
+    unsigned sps_size = (stap_a[1] << 8) + (stap_a[2]);
+    unsigned char *sps = &stap_a[3];
+    unsigned pps_size = (stap_a[3 + sps_size] << 8) + (stap_a[3 + sps_size + 1]);
+    unsigned char *pps = &stap_a[3 + sps_size + 2];
+    unsigned int profileLevelId = (sps[1]<<16) | (sps[2]<<8) | sps[3];
+    char* sps_base64 = base64_encode((char*)sps, sps_size);
+    char* pps_base64 = base64_encode((char*)pps, pps_size);
+    char const* fmtp_fmt =
+        "a=fmtp:%d packetization-mode=1"
+        ";profile-level-id=%06X"
+        ";sprop-parameter-sets=%s,%s\r\n";
+    unsigned fmtp_fmt_size = strlen(fmtp_fmt)  + 3 /* max char len */ + 6 /* 3 bytes in hex */ + strlen(sps_base64) + strlen(pps_base64);
+    char* fmtp = new char[fmtp_fmt_size];
+    sprintf(fmtp, fmtp_fmt, s_transport_info.video.payload_type, profileLevelId, sps_base64, pps_base64);
+    delete[] sps_base64;
+    delete[] pps_base64;
+
+    printf("h264_sdp_config\n");
+    printf("\tm=video %d RTP/AVP %d\n",s_transport_info.video.port,s_transport_info.video.payload_type);
+    printf("\ta=rtpmap:%d H264/90000\n",s_transport_info.video.payload_type);
+    printf("\t%s\n",fmtp);
+    delete []fmtp;
+}
+
+static void show_aac_sdp_config(unsigned char *aac_adts_header){
+    unsigned char *hdr = aac_adts_header;
+    unsigned int  syncword = (hdr[0] << 4) | (hdr[1] >> 4) ;// # bslbf(12)
+    if(syncword != 0b111111111111){
+       printf("show_aac_sdp_config -- Invalid syncword");
+       exit(1);
+    }
+#if 0
+    unsigned char ID  = (hdr[1] >> 3) & 0b1;//    # bslbf(1)
+    unsigned char layer  = (hdr[1] >> 1) & 0b11;//   # uimsbf(2)
+    unsigned char protection_absent  = (hdr[1]) & 0b1;//    # bslbf(1)
+    unsigned char profile            = (hdr[2] >> 6) & 0b11;//   # uimsbf(2)
+    unsigned char sampling_freq_idx  = (hdr[2] >> 2) & 0b1111;// # uimsbf(4)
+    unsigned char private_bit        = (hdr[2] >> 1) & 0b1;//    # bslbf(1)
+    unsigned char channel_cfg        = ((hdr[2] & 0b1) << 2) | (hdr[3] >> 6);//  # uimsbf(3)
+    unsigned char original_copy      = (hdr[3] >> 5) & 0b1;//    # bslbf(1)
+    unsigned char home               = (hdr[3] >> 4) & 0b1;//    # bslbf(1)
+    //parse adts_variable_header()
+    unsigned char copyright_id_bit   = (hdr[3] >> 3) & 0b1;//    # bslbf(1)
+    unsigned char copyright_id_start = (hdr[3] >> 2) & 0b1;//    # bslbf(1)
+    unsigned int frame_length       = ((hdr[3] & 0b11) << 11) | (hdr[4] << 3) | (hdr[5] >> 5);//  # bslbf(13)
+    unsigned int adts_buf_fullness  = ((hdr[5] & 0b11111) << 6) | (hdr[6] >> 2);//  # bslbf(11)
+    unsigned int num_rawdata_blocks = (hdr[6]     ) & 0b11;//   # uimsbf(2)
+#else
+    unsigned char profile            = (hdr[2] >> 6) & 0b11;//   # uimsbf(2)
+    unsigned char sampling_freq_idx  = (hdr[2] >> 2) & 0b1111;// # uimsbf(4)
+    unsigned char channel_cfg        = ((hdr[2] & 0b1) << 2) | (hdr[3] >> 6);//  # uimsbf(3)
+#endif
+    unsigned char audioSpecificConfig[2];
+    unsigned char audioObjectType = profile + 1;
+    audioSpecificConfig[0] = (audioObjectType<<3) | (sampling_freq_idx>>1);
+    audioSpecificConfig[1] = (sampling_freq_idx<<7) | (channel_cfg <<3);
+    char fConfigStr[32];
+    sprintf(fConfigStr, "%02X%02X", audioSpecificConfig[0], audioSpecificConfig[1]);
+
+    static unsigned const samplingFrequencyFromIndex[16] = {
+        96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050,  16000, 12000, 11025, 8000, 7350, 0, 0, 0
+    };
+    printf("aac_sdp_config\n");
+    printf("\tm=audio %d RTP/AVP %d\n",s_transport_info.audio.port,s_transport_info.audio.payload_type);
+    printf("\ta=rtpmap:%d mpeg4-generic/%d/%d\n",s_transport_info.audio.payload_type,samplingFrequencyFromIndex[sampling_freq_idx],channel_cfg);
+    printf("\ta=fmtp:%d streamtype=5; profile-level-id=15; mode=AAC-hbr; config=%s;SizeLength=13; IndexLength=3; IndexDeltaLength=3; Profile=%d\n",s_transport_info.audio.payload_type,fConfigStr,profile);
+}
diff --git a/fastboot_app/bpi_app/streaming_rtp_over_udp.h b/fastboot_app/bpi_app/streaming_rtp_over_udp.h
new file mode 100644
index 0000000..87794ac
--- /dev/null
+++ b/fastboot_app/bpi_app/streaming_rtp_over_udp.h
@@ -0,0 +1,65 @@
+/*
+ * streaming_rtp_over_udp.h
+ *
+ * History:
+ *       2016/12/14 - Jian Liu] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef _STREAMING_RTP_OVER_UDP_H_
+#define _STREAMING_RTP_OVER_UDP_H_
+
+#include "am_export_if.h"
+#include "bpi_oryx_export.h"
+
+typedef struct _av_info{
+    unsigned short port;
+    int payload_type;
+    unsigned int ssrc;
+    int enable;
+}av_info_t;
+
+typedef struct transport_info_t{
+    char ipaddress[128];
+    int is_ipv4;
+    av_info_t video;
+    av_info_t audio;
+}transport_info_t;
+
+struct bpi_streamer_info {
+    int stream_id;
+    int target_bitrate;
+    int enable_lbr;
+    char *audio_codec_name;
+    const char *osd_label;
+    transport_info_t *transport_info;
+};
+
+int streaming_initialize(bpi_streamer_info *streamer_info);
+int streaming_finalize(void);
+
+#endif//_STREAMING_RTP_OVER_UDP_H_
+
diff --git a/fastboot_app/bpi_unit_test/bpi_test_audio_playback.cpp b/fastboot_app/bpi_unit_test/bpi_test_audio_playback.cpp
new file mode 100644
index 0000000..f13cefd
--- /dev/null
+++ b/fastboot_app/bpi_unit_test/bpi_test_audio_playback.cpp
@@ -0,0 +1,99 @@
+/*
+ * Bpi_test_audio_playback.cpp
+ *
+ *
+ * History:
+ *       2017/06/05 - [mzchen] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include "bpi_utils.h"
+#include "bpi_typedefs.h"
+#include "bpi_app_config.h"
+#include "bpi_oryx_config.h"
+#include "streaming_audio_playback.h"
+
+static int test_audio_playback(void)
+{
+    LOG_PRINT("test_audio_playback, get_current_time = %u\n",get_current_time());
+
+    app_conf_t app_config;
+    if(load_app_conf(&app_config) < 0) {
+        LOG_ERROR("load app config failed\n");
+        return -1;
+    }
+    //config oryx settings
+    if(!config_oryx_engine(&app_config)) {
+        LOG_ERROR("fail to config oryx configuration files.\n");
+        return -1;
+    }
+
+    AMPlaybackRtpUri rtp_uri;
+    rtp_uri.udp_port = 8288;
+    rtp_uri.ip_domain  = AM_PLAYBACK_IPV4;
+
+#if defined(AMBOOT_AUDIO_48000)
+    rtp_uri.audio_type =  AM_AUDIO_AAC;
+    rtp_uri.sample_rate = 48000;
+    rtp_uri.channel = 1;
+#elif defined(AMBOOT_AUDIO_16000)
+    rtp_uri.audio_type =  AM_AUDIO_AAC;
+    rtp_uri.sample_rate = 16000;
+    rtp_uri.channel = 1;
+#elif defined(AMBOOT_AUDIO_8000)
+    rtp_uri.audio_type =  AM_AUDIO_G711A;
+    rtp_uri.sample_rate = 8000;
+    rtp_uri.channel = 1;
+#endif
+
+    audio_play_initialize(rtp_uri);
+    while(1) sleep(20);
+    audio_play_finalize();
+    return 0;
+}
+
+int main(int argc, char **argv)
+{
+    int ret = 1;
+    int log_options = BPI_LOG_ENABLE_DEBUG_LOG;
+
+    do {
+        if(argc > 1 ) {
+            printf("test_bpi_audio_playback has none parameter.\n");
+            break;
+        }
+        set_log_options(log_options);
+
+        if(test_audio_playback()) {
+            LOG_ERROR("audio_playbac failed\n");
+            break;
+        }
+        ret = 0;
+    } while(0);
+
+    return ret;
+}
+
diff --git a/fastboot_app/bpi_unit_test/bpi_test_recorder.cpp b/fastboot_app/bpi_unit_test/bpi_test_recorder.cpp
new file mode 100644
index 0000000..18655ff
--- /dev/null
+++ b/fastboot_app/bpi_unit_test/bpi_test_recorder.cpp
@@ -0,0 +1,87 @@
+/*
+ * Bpi_test_recorder.cpp
+ *
+ *
+ * History:
+ *       2017/05/17 - [mzchen] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include "bpi_utils.h"
+#include "bpi_typedefs.h"
+#include "bpi_app_config.h"
+#include "bpi_oryx_config.h"
+#include "bpi_oryx_export.h"
+
+static int test_recorder(void)
+{
+    LOG_PRINT("test_recorder, get_current_time = %u\n",get_current_time());
+    app_conf_t app_config;
+
+    if(load_app_conf(&app_config) < 0) {
+        LOG_ERROR("load app config failed\n");
+        return -1;
+    }
+    //config oryx settings
+    if(!config_oryx_engine(&app_config)) {
+        LOG_ERROR("fail to config oryx configuration files.\n");
+        return -1;
+    }
+
+    OryxRecorderWrapper recorder;
+    recorder.set_data_handler(NULL);
+    if(!recorder.init_recorder(&app_config)) {
+        LOG_ERROR("Failed to init recorder engine.\n");
+        return -1;
+    }
+    recorder.start_recorder();
+    sleep(20);
+    recorder.stop_recorder();
+    return 0;
+}
+
+int main(int argc, char **argv)
+{
+    int ret = 1;
+    int log_options = BPI_LOG_ENABLE_DEBUG_LOG;
+
+    do {
+        if(argc > 1 ) {
+            printf("test_bpi_recorder has none parameter.\n");
+            break;
+        }
+        set_log_options(log_options);
+
+        if(test_recorder()) {
+            LOG_ERROR("recorder failed\n");
+            break;
+        }
+        ret = 0;
+    } while(0);
+
+    return ret;
+}
+
diff --git a/fastboot_app/bpi_unit_test/bpi_test_streaming.cpp b/fastboot_app/bpi_unit_test/bpi_test_streaming.cpp
new file mode 100644
index 0000000..240e204
--- /dev/null
+++ b/fastboot_app/bpi_unit_test/bpi_test_streaming.cpp
@@ -0,0 +1,205 @@
+/*
+ * bpi_test_streaming.cpp
+ *
+ *
+ * History:
+ *       2017/05/17 - [jyi] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <stdlib.h>
+#include <string.h>
+#include <signal.h>
+#include <getopt.h>
+
+#include "bpi_utils.h"
+#include "bpi_typedefs.h"
+#include "bpi_uploader.h"
+#include "bpi_app_config.h"
+#include "streaming_rtp_over_udp.h"
+#include "config.h"
+
+static char dest_ip[64] = {0};
+static char overlay_tag[64] = {0};
+static unsigned int streaming_duration = 0;
+static int enable_audio = 0;
+static int target_bitrate = 0;
+static int stop_flag = 0;
+
+static int test_streaming()
+{
+    int ret = 0;
+    char *audio_codec_name;
+    int audio_payload_type;
+#if defined(AMBOOT_AUDIO_48000)
+    audio_codec_name = (char*)"aac-48k";
+    audio_payload_type = 97;
+#elif defined(AMBOOT_AUDIO_16000)
+    audio_codec_name = (char*)"aac-16k";
+    audio_payload_type = 97;
+#elif defined(AMBOOT_AUDIO_8000)
+    audio_codec_name = (char*)"g711-8k";
+    audio_payload_type = 8;
+#else
+    audio_codec_name = NULL;
+    audio_payload_type = 0;
+    enable_audio = 0;
+#endif
+    transport_info_t transport_info;
+    bpi_streamer_info streamer_info;
+
+    snprintf(transport_info.ipaddress, sizeof(transport_info.ipaddress), "%s",
+             dest_ip);
+    transport_info.is_ipv4 = 1;
+    transport_info.video.enable = 1;
+    transport_info.video.port = 8554;
+    transport_info.video.payload_type = 96;
+    transport_info.video.ssrc = 0xfeadbeaf;
+    transport_info.audio.enable = enable_audio;
+    transport_info.audio.port = 8556;
+    transport_info.audio.payload_type = audio_payload_type;
+    transport_info.audio.ssrc = 0xfeadbea1;
+    streamer_info.stream_id = 0;
+    streamer_info.enable_lbr = (target_bitrate == 0);
+    streamer_info.target_bitrate = target_bitrate;
+    streamer_info.audio_codec_name = audio_codec_name;
+    streamer_info.transport_info = &transport_info;
+    streamer_info.osd_label = overlay_tag;
+    ret = streaming_initialize(&streamer_info);
+    if(!ret){
+        if(streaming_duration){
+            while(streaming_duration || !stop_flag){
+                sleep(1);
+                streaming_duration--;
+            }
+        }else{
+            while(!stop_flag) sleep(1);
+        }
+        ret = streaming_finalize();
+    }
+
+    return ret;
+}
+
+static void signal_interrupt(int sig)
+{
+    stop_flag = 1;
+}
+
+static int init_param(int argc, char **argv)
+{
+    int ret = -1;
+    const char *short_options = "s:d:r:o:ah";
+    struct option long_options[] = {
+        {"streaming_dest_ip", 1, 0, 's'},
+        {"duration", 1, 0, 'd'},
+        {"bitrate_cotrol", 1, 0, 'r'},
+        {"enable_audio", 0, 0, 'a'},
+        {"overlay_tag", 1, 0, 'o'},
+        {"help", 0, 0, 'h'}
+    };
+    int ch = 0;
+    int option_index = 0;
+
+    while(1){
+        ch = getopt_long(argc, argv, short_options, long_options, &option_index);
+        if(ch == -1 || ret > 0) break;
+        switch(ch){
+        case 's':
+            snprintf(dest_ip, sizeof(dest_ip), "%s", optarg);
+            ret = 0; //mandatory
+            break;
+        case 'd':
+            streaming_duration = atoi(optarg);
+            break;
+        case 'a':
+            enable_audio = 1;
+            break;
+        case 'r':
+            target_bitrate = atoi(optarg);
+            break;
+        case 'o':
+            snprintf(overlay_tag, sizeof(overlay_tag), "%s", optarg);
+            break;
+        case 'h':
+            ret = 1;
+            break;
+        default:
+            LOG_ERROR("catch default opt: %c\n", (char)ch);
+            ret = 1;
+            break;
+        }
+    }
+
+    return ret;
+}
+
+static void usage()
+{
+    printf(
+        "save this .sdp on computer:\n"
+        "\tm=video 8554 RTP/AVP 96\n"
+        "\ta=rtpmap:96 H264/90000\n"
+        "\n"
+        "Usage: bpi_test_streaming [option] [arguments]\n"
+        "-- Mandatory --\n"
+        "\t-s, --streaming_dest_ip <ip>:        appoint destination ip\n"
+        "-- Optional --\n"
+        "\t-d, --duration <duration_s>:           set streaming duration, or endless\n"
+        "\t-r, --bitrate_control <bitrate_bps>:     if not set, use lbr\n"
+        "\t-o, --overlay_tag <string>:          set overlay to video\n"
+        "\t-a, --enable_audio:                  audio .sdp has following content:\n"
+        "\t\tm=audio 8556 RTP/AVP 97\n"
+        "\t\ta=rtpmap:97 mpeg4-generic/48000/1\n"
+        "\t-h, --help: show this help content\n"
+        "-- MAKE SURE DESTINATION IP IS ACCESSIBLE AND DSP IS ENCODING --\n"
+        );
+}
+
+int main(int argc, char **argv)
+{
+    int ret = 1;
+    int log_options = BPI_LOG_ENABLE_DEBUG_LOG;
+
+    signal(SIGINT, signal_interrupt);
+    signal(SIGQUIT, signal_interrupt);
+    signal(SIGTERM, signal_interrupt);
+    do{
+        if(argc < 2 || init_param(argc, argv) != 0){
+            usage();
+            break;
+        }
+        set_log_options(log_options);
+
+        if(test_streaming()){
+            LOG_ERROR("streaming failed\n");
+            break;
+        }
+        ret = 0;
+    }while(0);
+
+    return ret;
+}
diff --git a/fastboot_app/bpi_unit_test/make.inc b/fastboot_app/bpi_unit_test/make.inc
new file mode 100644
index 0000000..7934add
--- /dev/null
+++ b/fastboot_app/bpi_unit_test/make.inc
@@ -0,0 +1,245 @@
+#
+# make.inc
+#
+# History:
+#       2017/04/24 - [jyi] created file
+#
+# Copyright (c) 2017 Ambarella, Inc.
+#
+# This file and its contents ("Software") are protected by intellectual
+# property rights including, without limitation, U.S. and/or foreign
+# copyrights. This Software is also the confidential and proprietary
+# information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+# disclose, distribute, modify, or otherwise prepare derivative works of this
+# Software or any portion thereof except pursuant to a signed license agreement
+# or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+# In the absence of such an agreement, you agree to promptly notify and return
+# this Software to Ambarella, Inc.
+#
+# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+# MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+# IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+#
+##################################################
+# Notice: put any bpi unit test into this folder #
+##################################################
+
+ifeq ($(BUILD_AMBARELLA_BPI_UNIT_TEST), y)
+
+LOCAL_PATH   := $(call my-dir)
+IPCAM_APP_BIN_DIR	:= $(FAKEROOT_DIR)/usr/bin
+IPCAM_SCRIPT_DIR	:= $(FAKEROOT_DIR)/usr/local/bin/
+BPI_APP_DIR			:= $(LOCAL_PATH)/../bpi_app
+BPI_UTILS_DIR	:= $(LOCAL_PATH)/../utils
+BPI_ADC_DIR	:= $(BPI_UTILS_DIR)/adc
+
+ifeq ($(CONFIG_ELEKTRA_FAST_BOOT), y)
+D_FASTBOOT_TEST = yes
+endif
+ifeq ($(CONFIG_ELEKTRAS_FAST_BOOT), y)
+D_FASTBOOT_TEST = yes
+endif
+ifeq ($(CONFIG_ELEKTRA_V_FAST_BOOT), y)
+D_FASTBOOT_TEST = yes
+endif
+
+ifeq ($(D_FASTBOOT_TEST), yes)
+##############################################
+#bpi_test_streaming
+##############################################
+include $(CLEAR_VARS)
+
+LOCAL_SRCS		:= $(LOCAL_PATH)/bpi_test_streaming.cpp \
+			$(BPI_APP_DIR)/bpi_oryx_config.cpp \
+			$(BPI_APP_DIR)/streaming_rtp_over_udp.cpp
+
+LOCAL_TARGET	:= bpi_test_streaming
+
+LOCAL_CFLAGS	:= -std=c++11
+LOCAL_CFLAGS	+= -I$(BPI_APP_DIR) \
+		-I$(BPI_UTILS_DIR) \
+		-I$(PREBUILD_3RD_PARTY_DIR)/libcurl/include
+
+LOCAL_CFLAGS	+= -I$(ORYX_DIR)/include \
+		-I$(ORYX_DIR)/include/utility \
+		-I$(ORYX_DIR)/include/video \
+		-I$(ORYX_DIR)/include/audio \
+		-I$(ORYX_DIR)/include/image_quality \
+		-I$(ORYX_DIR)/include/audio/capture \
+		-I$(ORYX_DIR)/include/stream \
+		-I$(ORYX_DIR)/include/configure \
+		-I$(ORYX_DIR)/include/audio/codec
+
+LOCAL_CFLAGS  += -D$(BOARD_TYPE)
+
+LOCAL_LDFLAGS	:= -lpthread \
+		-Wl,-rpath-link=$(FAKEROOT_DIR)/usr/lib
+
+
+LOCAL_LIBS		:= libbpiUtils.so
+LOCAL_LIBS += libamstream-record.so libamstream-playback.so libamstream-amf.so libamvideo.so libamaudio-capture.so
+LOCAL_LIBS += libamvideo-reader.so libamvideo-address.so libamiq.so libamutil.so libamosal.so libamconfig.so
+
+
+include $(BUILD_APP)
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): bpi_app
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(IPCAM_APP_BIN_DIR)/
+	@cp -dpRf $< $(IPCAM_APP_BIN_DIR)
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+
+##############################################
+#bpi_test_recorder
+##############################################
+include $(CLEAR_VARS)
+
+LOCAL_SRCS		:= $(LOCAL_PATH)/bpi_test_recorder.cpp \
+			$(BPI_APP_DIR)/bpi_app_config.c \
+			$(BPI_APP_DIR)/bpi_oryx_export.cpp \
+			$(BPI_APP_DIR)/bpi_oryx_config.cpp \
+			$(BPI_APP_DIR)/bpi_uploader.cpp \
+			$(BPI_APP_DIR)/bpi_yuv_rotate.c
+
+LOCAL_TARGET	:= bpi_test_recorder
+
+LOCAL_CFLAGS	:= -std=c++11 -Werror
+LOCAL_CFLAGS	+= -I$(BPI_APP_DIR) \
+		-I$(BPI_UTILS_DIR) \
+		-I$(PREBUILD_3RD_PARTY_DIR)/libcurl/include
+
+LOCAL_CFLAGS	+= -I$(ORYX_DIR)/include \
+		-I$(ORYX_DIR)/include/utility \
+		-I$(ORYX_DIR)/include/video \
+		-I$(ORYX_DIR)/include/audio \
+		-I$(ORYX_DIR)/include/image_quality \
+		-I$(ORYX_DIR)/include/audio/capture \
+		-I$(ORYX_DIR)/include/stream \
+		-I$(ORYX_DIR)/include/configure \
+		-I$(ORYX_DIR)/include/utility/jpeg_encoder \
+		-I$(ORYX_DIR)/include/audio/codec \
+		-I$(PREBUILD_3RD_PARTY_DIR)/iniparser/include
+
+LOCAL_CFLAGS  += -D$(BOARD_TYPE)
+
+LOCAL_LDFLAGS	:= -lpthread \
+		-L$(PREBUILD_3RD_PARTY_DIR)/iniparser/usr/lib -liniparser \
+		-L$(PREBUILD_3RD_PARTY_DIR)/libcurl/usr/lib -lcurl \
+		-Wl,-rpath-link=$(FAKEROOT_DIR)/usr/lib \
+		-Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/libssh2/usr/lib \
+		-Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/libnghttp2/usr/lib \
+		-Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/libjpeg-turbo/usr/lib \
+		-Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/libnl/usr/lib \
+		-Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/libunistring/usr/lib \
+		-Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/libidn/usr/lib \
+		-Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/zlib/usr/lib \
+		-Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/openssl/usr/lib
+
+LOCAL_LIBS	:= libbpiUtils.so
+LOCAL_LIBS	+= libamvideo.so libamaudio-capture.so libamvideo-reader.so \
+		libamvideo-address.so libamiq.so libamutil.so libamosal.so \
+		libamjpeg-encoder.so libamvideo-utility.so libamconfig.so \
+		libamstream-record.so libamstream-amf.so
+
+include $(BUILD_APP)
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): bpi_app
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(IPCAM_APP_BIN_DIR)/
+	@cp -dpRf $< $(IPCAM_APP_BIN_DIR)
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+
+##############################################
+#bpi_test_audio_playback
+##############################################
+include $(CLEAR_VARS)
+
+LOCAL_SRCS		:= $(LOCAL_PATH)/bpi_test_audio_playback.cpp \
+			$(BPI_APP_DIR)/bpi_oryx_config.cpp \
+			$(BPI_APP_DIR)/streaming_audio_playback.cpp \
+			$(BPI_APP_DIR)/bpi_app_config.c
+
+LOCAL_TARGET	:= bpi_test_audio_playback
+
+LOCAL_CFLAGS	:= -std=c++11 -Werror
+LOCAL_CFLAGS	+= -I$(BPI_APP_DIR) \
+		-I$(BPI_UTILS_DIR) \
+		-I$(PREBUILD_3RD_PARTY_DIR)/iniparser/include
+
+LOCAL_CFLAGS	+= -I$(ORYX_DIR)/include \
+		-I$(ORYX_DIR)/include/utility \
+		-I$(ORYX_DIR)/include/video \
+		-I$(ORYX_DIR)/include/audio \
+		-I$(ORYX_DIR)/include/image_quality \
+		-I$(ORYX_DIR)/include/stream \
+		-I$(ORYX_DIR)/include/configure
+
+LOCAL_CFLAGS  += -D$(BOARD_TYPE)
+
+LOCAL_LDFLAGS	:= -lpthread \
+		-Wl,-rpath-link=$(FAKEROOT_DIR)/usr/lib \
+		-L$(PREBUILD_3RD_PARTY_DIR)/iniparser/usr/lib -liniparser
+
+LOCAL_LIBS	:= libbpiUtils.so
+LOCAL_LIBS	+= libamvideo.so libamstream-amf.so libamutil.so libamstream-playback.so \
+		libamvideo-utility.so libamconfig.so libaplayAudio.so libamosal.so libamiq.so
+
+include $(BUILD_APP)
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): bpi_app prebuild_alsa
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(IPCAM_APP_BIN_DIR)/
+	@cp -dpRf $< $(IPCAM_APP_BIN_DIR)
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+
+##############################################
+#bpi_test_adc
+##############################################
+include $(CLEAR_VARS)
+
+LOCAL_SRCS		:= $(LOCAL_PATH)/bpi_test_adc.cpp \
+			$(BPI_APP_DIR)/bpi_app_config.c
+
+LOCAL_TARGET	:= bpi_test_adc
+
+LOCAL_CFLAGS	:= -std=c++11 -Werror
+LOCAL_CFLAGS	+= -I$(BPI_APP_DIR) \
+		-I$(BPI_UTILS_DIR) \
+		-I$(BPI_ADC_DIR) \
+		-I$(PREBUILD_3RD_PARTY_DIR)/iniparser/include
+
+LOCAL_LDFLAGS	:= -Wl,-rpath-link=$(FAKEROOT_DIR)/usr/lib \
+		-L$(PREBUILD_3RD_PARTY_DIR)/iniparser/usr/lib -liniparser
+
+LOCAL_LIBS	:= libbpiUtils.so libbpiAdc.so
+
+include $(BUILD_APP)
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(IPCAM_APP_BIN_DIR)/
+	@cp -dpRf $< $(IPCAM_APP_BIN_DIR)
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+endif  #end of D_FASTBOOT_TEST
+
+endif
diff --git a/fastboot_app/elektra_tools/convert_dsp_cmd.sh b/fastboot_app/elektra_tools/convert_dsp_cmd.sh
new file mode 100755
index 0000000..686b26e
--- /dev/null
+++ b/fastboot_app/elektra_tools/convert_dsp_cmd.sh
@@ -0,0 +1,88 @@
+#
+# convert_dsp_cmd.sh
+#
+# History:
+#       2015/12/15 - [CZ LIN] created file
+#
+# Copyright (c) 2015 Ambarella, Inc.
+#
+# This file and its contents ("Software") are protected by intellectual
+# property rights including, without limitation, U.S. and/or foreign
+# copyrights. This Software is also the confidential and proprietary
+# information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+# disclose, distribute, modify, or otherwise prepare derivative works of this
+# Software or any portion thereof except pursuant to a signed license agreement
+# or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+# In the absence of such an agreement, you agree to promptly notify and return
+# this Software to Ambarella, Inc.
+#
+# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+# MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+# IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+#
+# !/bin/sh
+
+[ $# -eq 0 ] && { echo "Usage: $0 dsp_cmd_log_file"; exit 1; }
+dsp_log=$1
+#determine the last occurrence of set_warp_control
+tmpline=`grep -n SET_WARP_CONTROL "$1" | tail -1 | cut -d : -f 1 `
+Beginline=$(($tmpline+1))
+Endline=$(($Beginline+31))
+i=0
+
+# fetch the specified lines and value
+results=`awk "NR==$Beginline,NR==$Endline" $dsp_log | awk '{print $NF}'`
+for item in $results
+do
+   eval "config$i=$item"
+   i=$((i+1))
+done
+
+# overwrite some of the entries
+config0=SET_WARP_CONTROL
+config16='(u32)warp_ctrl_h_table'
+config17='(u32)warp_ctrl_v_table'
+config31='(u32)warp_ctrl_me1_table'
+printf "static set_warp_control_t set_warp_control_mode4 = {
+	.cmd_code = ${config0},
+	.zoom_x = ${config1},
+	.zoom_y = ${config2},
+	.x_center_offset = ${config3},
+	.y_center_offset = ${config4},
+	.actual_left_top_x = ${config5},
+	.actual_left_top_y = ${config6},
+	.actual_right_bot_x = ${config7},
+	.actual_right_bot_y = ${config8},
+	.dummy_window_x_left = ${config9},
+	.dummy_window_y_top = ${config10},
+	.dummy_window_width = ${config11},
+	.dummy_window_height = ${config12},
+	.cfa_output_width = ${config13},
+	.cfa_output_height = ${config14},
+	.warp_control = ${config15},
+	.warp_horizontal_table_address = ${config16},
+	.warp_vertical_table_address = ${config17},
+	.grid_array_width = ${config18},
+	.grid_array_height = ${config19},
+	.horz_grid_spacing_exponent = ${config20},
+	.vert_grid_spacing_exponent = ${config21},
+	.vert_warp_enable = ${config22},
+	.vert_warp_grid_array_width = ${config23},
+	.vert_warp_grid_array_height = ${config24},
+	.vert_warp_horz_grid_spacing_exponent = ${config25},
+	.vert_warp_vert_grid_spacing_exponent = ${config26},
+	.ME1_vwarp_grid_array_width = ${config27},
+	.ME1_vwarp_grid_array_height = ${config28},
+	.ME1_vwarp_horz_grid_spacing_exponent = ${config29},
+	.ME1_vwarp_vert_grid_spacing_exponent = ${config30},
+	.ME1_vwarp_table_address = ${config31}
+};"
diff --git a/fastboot_app/elektra_tools/copyIDSPcfg.sh b/fastboot_app/elektra_tools/copyIDSPcfg.sh
new file mode 100644
index 0000000..5ece7d3
--- /dev/null
+++ b/fastboot_app/elektra_tools/copyIDSPcfg.sh
@@ -0,0 +1,69 @@
+#
+# copyIDSPcfg.sh
+#
+# History:
+#       2016/01/17 - [CZ LIN] created file
+#
+# Copyright (c) 2015 Ambarella, Inc.
+#
+# This file and its contents ("Software") are protected by intellectual
+# property rights including, without limitation, U.S. and/or foreign
+# copyrights. This Software is also the confidential and proprietary
+# information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+# disclose, distribute, modify, or otherwise prepare derivative works of this
+# Software or any portion thereof except pursuant to a signed license agreement
+# or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+# In the absence of such an agreement, you agree to promptly notify and return
+# this Software to Ambarella, Inc.
+#
+# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+# MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+# IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+#
+# !/bin/sh
+
+[ $# -ne 3 ] && { echo "Usage: $0 original_binary new_binary 720p/1080p"; exit 1; }
+OrigSrc=$1
+NewSrc=$2
+section=$3
+sizeIDsp=25704
+tmpFile=half_mode4.bin
+
+if [ ! -f $OrigSrc ]
+then
+    echo "file $OrigSrc not found"
+    exit 1
+fi
+
+if [ ! -f $NewSrc ]
+then
+   echo "file $NewSrc not found"
+   exit 1
+fi
+
+if [ "$section" = "720p" ]
+then
+   echo "copying $NewSrc to the 720p section of $OrigSrc ..."
+   dd bs=$sizeIDsp skip=0 count=1 if=$OrigSrc of=$tmpFile
+   cat $tmpFile $NewSrc > $OrigSrc
+elif [ "$section" = "1080p" ]
+then
+   echo "copying $NewSrc to the 1080p section of $OrigSrc ..."
+   dd bs=$sizeIDsp skip=1 count=1 if=$OrigSrc of=$tmpFile
+   cat $NewSrc $tmpFile > $OrigSrc
+else
+   echo "not supported argument!"
+   exit 1
+fi
+
+rm $tmpFile
+
diff --git a/fastboot_app/elektra_tools/ldc_convert.sh b/fastboot_app/elektra_tools/ldc_convert.sh
new file mode 100755
index 0000000..abe3da1
--- /dev/null
+++ b/fastboot_app/elektra_tools/ldc_convert.sh
@@ -0,0 +1,110 @@
+#
+# ldc_convert.sh
+#
+# History:
+#       2015/07/17 - [niu zhifeng] created file
+#
+# Copyright (c) 2015 Ambarella, Inc.
+#
+# This file and its contents ("Software") are protected by intellectual
+# property rights including, without limitation, U.S. and/or foreign
+# copyrights. This Software is also the confidential and proprietary
+# information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+# disclose, distribute, modify, or otherwise prepare derivative works of this
+# Software or any portion thereof except pursuant to a signed license agreement
+# or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+# In the absence of such an agreement, you agree to promptly notify and return
+# this Software to Ambarella, Inc.
+#
+# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+# MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+# IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+#
+
+#!/bin/sh
+
+#Filename:convert tables
+
+#function: this shell is to generate the arrays of ldc from the ldc table
+
+
+usage()
+{
+        echo "Usage: ldc_convert.sh htable vtable me1table result_file"
+        echo "Parameters description:"
+        echo "htable:hon_table file generated by test_ldc"
+        echo "vtable:ver_table file generated by test_ldc"
+        echo "me1table:me1_ver_table file generated by test_ldc"
+        echo "result_file:the file to save arrays"
+}
+
+
+
+run()
+{
+        htable="$1_tmp"
+        vtable="$2_tmp"
+        me1table="$3_tmp"
+        result="$4_tmp"
+
+        cp -f $1 $htable
+        cp -f $2 $vtable
+        cp -f $3 $me1table
+
+        rm -f $4
+
+        sed -i 's/\t/,/g' $htable
+        sed -i 's/\t/,/g' $vtable
+        sed -i 's/\t/,/g' $me1table
+
+        echo "static s16 warp_ctrl_h_table[] = {" >> $4
+
+        while read LINE
+        do
+        echo $LINE >> $4
+        done < $htable
+
+        echo "};" >> $4
+
+        echo "static s16 warp_ctrl_v_table[] = {" >> $4
+
+        while read LINE
+        do
+        echo $LINE >> $4
+        done < $vtable
+
+        echo "};" >> $4
+
+        echo "static s16 warp_ctrl_me1_table[] = {" >> $4
+
+        while read LINE
+        do echo $LINE >> $4
+        done < $me1table
+
+        echo "};" >> $4
+
+        rm -f $htable
+        rm -f $vtable
+        rm -f $me1table
+}
+
+if [ ! -n "$1" ] ; then
+        usage
+elif [ ! -n "$2" ] ; then
+        usage
+elif [ ! -n "$3" ] ; then
+        usage
+elif [ ! -n "$4" ] ; then
+        usage
+else
+        run $1 $2 $3 $4
+fi
diff --git a/fastboot_app/elektra_tools/make.inc b/fastboot_app/elektra_tools/make.inc
new file mode 100644
index 0000000..ba976b9
--- /dev/null
+++ b/fastboot_app/elektra_tools/make.inc
@@ -0,0 +1,55 @@
+#
+# make.inc
+#
+# History:
+#       2015/07/08 - [niu zhifeng] created file
+#
+# Copyright (c) 2015 Ambarella, Inc.
+#
+# This file and its contents ("Software") are protected by intellectual
+# property rights including, without limitation, U.S. and/or foreign
+# copyrights. This Software is also the confidential and proprietary
+# information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+# disclose, distribute, modify, or otherwise prepare derivative works of this
+# Software or any portion thereof except pursuant to a signed license agreement
+# or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+# In the absence of such an agreement, you agree to promptly notify and return
+# this Software to Ambarella, Inc.
+#
+# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+# MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+# IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+#
+ifeq ($(BUILD_AMBARELLA_BPI_TOOLS), y)
+ELEKTRA_TEST_TOOL_DIR := $(call my-dir)
+IPCAM_APP_BIN_DIR	= $(FAKEROOT_DIR)/usr/bin
+
+include $(CLEAR_VARS)
+LOCAL_TARGET    := prebuild_bpi_tools
+
+.PHONY: $(LOCAL_TARGET)
+
+include $(BUILD_PREBUILD)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(IPCAM_APP_BIN_DIR)/
+	@chmod +x $(ELEKTRA_TEST_TOOL_DIR)/ldc_convert.sh
+	@chmod +x $(ELEKTRA_TEST_TOOL_DIR)/convert_dsp_cmd.sh
+	@chmod +x $(ELEKTRA_TEST_TOOL_DIR)/power_measure_tool.sh
+	@cp -dpRf $(ELEKTRA_TEST_TOOL_DIR)/ldc_convert.sh $(IPCAM_APP_BIN_DIR)/
+	@cp -dpRf $(ELEKTRA_TEST_TOOL_DIR)/convert_dsp_cmd.sh $(IPCAM_APP_BIN_DIR)/
+	@cp -dpRf $(ELEKTRA_TEST_TOOL_DIR)/power_measure_tool.sh $(IPCAM_APP_BIN_DIR)/
+	@echo "Copy $@ Done"
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+endif
+
diff --git a/fastboot_app/network_manager/bpi_wlan.h b/fastboot_app/network_manager/bpi_wlan.h
new file mode 100644
index 0000000..762dec9
--- /dev/null
+++ b/fastboot_app/network_manager/bpi_wlan.h
@@ -0,0 +1,122 @@
+/*
+ * bpi_wlan.h
+ *
+ * History:
+ *       2016/01/18 - [CZ Lin] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef ELEKTRA_APP_WLAN_H_
+#define ELEKTRA_APP_WLAN_H_
+
+
+typedef enum {
+    EWlan_Connected = 0x11,
+    EWlan_Disconnected = 0x22,
+} EWlan;
+
+typedef enum {
+    ECloud_Connected = 0,
+    ECloud_Disconnected,
+} ECloud;
+
+typedef enum error_code {
+    ECode_Success = 0,
+    ECode_Error,
+    ECode_WlanUp_Fail,
+    ECode_WlanConfig_Fail,
+    ECode_RecordingStart_Fail,
+} ERROR_CODE;
+
+typedef enum protocol {
+    Net_UDP = 0,
+    Net_TCP,
+} PROTOCOL;
+
+typedef enum {
+    INVALID_STATE = -1,
+    WIFI_WAKE_NORMAL = 0,
+    AP_LOSS_BEACON,
+    AP_DISASSOCIATION_OR_AUTHENTICATION,
+    TCP_KEEPALIVE_TIMEOUT,
+
+    WIFI_WAKE_ERROR = INVALID_STATE
+} WIFI_WAKE_STATE;
+
+typedef struct _cooee_wlan_conf_t{
+    char ap_ssid[128];
+    char ap_password[128];
+    char ap_wpa[128];
+    char cloud_server_ip[128];
+}cooee_wlan_conf_t;
+
+// keep_alive related
+#define MAX_WAKEUP_DATA_LEN  128
+typedef struct{
+    char* server_addr;
+    int server_port;
+    int keepalive_interval/*seconds*/;
+    int dtim_interval/*mseconds*/;
+    int timeout/*seconds*/;
+    int verbose;
+    unsigned char wake_data[MAX_WAKEUP_DATA_LEN];
+    int wake_data_len;
+    char dev_category[64];
+}keep_alive_param_t;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int connect_ap(const char *ssid, const char *passwd, const char *wpa);
+int connect_ap_async(const char *ssid, const char *passwd, const char *wpa);
+
+int ap_connect_status();
+
+int wlan_conf_changed();
+void clear_wlan_flag();
+
+int connect_server(const char* server_addr, int server_port, int protocol);
+int get_fd_to_server();
+void close_fd_to_server();
+
+int save_wlan_config(const char *file_path, cooee_wlan_conf_t *sWlanConfig);
+int config_elektra_boot(cooee_wlan_conf_t *wlan_write_back);
+int udp_keep_alive(keep_alive_param_t  *param);
+void wifi_power_save();
+void wifi_host_sleep();
+void wifi_power_normal();
+int tcp_keep_alive(keep_alive_param_t *param, int fd);
+char * get_server_ip(const char * file_path);
+
+int init_wifi_param(int is_poll, char const *iface,int iface_len);
+int resume_wifi(int* wake_reason, int tcp_fix);
+#ifdef __cplusplus
+};
+#endif
+
+#endif //ELEKTRA_APP_WLAN_H_
+
diff --git a/fastboot_app/network_manager/cooee/cooee_inter.c b/fastboot_app/network_manager/cooee/cooee_inter.c
new file mode 100644
index 0000000..a75ab05
--- /dev/null
+++ b/fastboot_app/network_manager/cooee/cooee_inter.c
@@ -0,0 +1,142 @@
+#include <stdio.h>
+#include <unistd.h>
+#include "easy_setup.h"
+
+#include <string.h>
+#include "cooee.h"
+#include "akiss.h"
+#include "neeze.h"
+#include "changhong.h"
+
+int debug_enable = 0;
+char filename[256] = {0};
+void usage() {
+    printf("-h: show help message\n");
+    printf("-d: show debug message\n");
+    printf("-k <v>: set 16-char key for all protocols\n");
+    printf("-p <v>: bitmask of protocols to enable\n");
+    printf("  0x%04x - cooee\n", 1<<EASY_SETUP_PROTO_COOEE);
+    printf("  0x%04x - neeze\n", 1<<EASY_SETUP_PROTO_NEEZE);
+    printf("  0x%04x - akiss\n", 1<<EASY_SETUP_PROTO_AKISS);
+    printf("  0x%04x - changhong\n", 1<<EASY_SETUP_PROTO_CHANGHONG);
+}
+
+int cooee_interface(char *file)
+{
+    int ret;
+    int len;
+    int ret_ori = -2;
+//    uint16 val;
+
+    easy_setup_enable_cooee();
+    strcpy(filename,file);
+    ret = easy_setup_start();
+    if (ret) return -1;
+
+    /* query for result, blocks until cooee comes or times out */
+    ret = easy_setup_query();
+    ret_ori = ret;
+    if (!ret) {
+        char ssid[33]; /* ssid of 32-char length, plus trailing '\0' */
+        ret = easy_setup_get_ssid(ssid, sizeof(ssid));
+        if (!ret) {
+            printf("ssid: %s\n", ssid);
+        }
+
+        char password[65]; /* password is 64-char length, plus trailing '\0' */
+        ret = easy_setup_get_password(password, sizeof(password));
+        if (!ret) {
+            printf("password: %s\n", password);
+        }
+
+        uint8 protocol;
+        ret = easy_setup_get_protocol(&protocol);
+        if (ret) {
+            printf("failed getting protocol.\n");
+        } else if (protocol == EASY_SETUP_PROTO_COOEE) {
+            char ip[16]; /* ipv4 max length */
+            ret = cooee_get_sender_ip(ip, sizeof(ip));
+            if (!ret) {
+                printf("sender ip: %s\n", ip);
+            }
+
+            uint16 port;
+            ret = cooee_get_sender_port(&port);
+            if (!ret) {
+                printf("sender port: %d\n", port);
+            }
+        } else if (protocol == EASY_SETUP_PROTO_NEEZE) {
+            char ip[16]; /* ipv4 max length */
+            ret = neeze_get_sender_ip(ip, sizeof(ip));
+            if (!ret) {
+                printf("sender ip: %s\n", ip);
+            }
+
+            uint16 port;
+            ret = neeze_get_sender_port(&port);
+            if (!ret) {
+                printf("sender port: %d\n", port);
+            }
+        } else if (protocol == EASY_SETUP_PROTO_AKISS) {
+            uint8 random;
+            ret = akiss_get_random(&random);
+            if (!ret) {
+                printf("random: 0x%02x\n", random);
+            }
+        } else if (protocol == EASY_SETUP_PROTO_CHANGHONG) {
+            uint8 sec;
+            ret = changhong_get_sec_mode(&sec);
+            if (!ret) {
+                printf("sec mode: 0x%02x\n", sec);
+            }
+        } else {
+           printf("unknown protocol %d\n", protocol);
+        }
+
+        /* if easy_setup_get_security() returns -1, try it more times */
+        int tries = 3;
+        while (tries--) {
+            ret = easy_setup_get_security();
+            if (ret != -1) break;
+        }
+        printf("security: ");
+        if (ret == WLAN_SECURITY_WPA2) printf("wpa2\n");
+        else if (ret == WLAN_SECURITY_WPA) printf("wpa\n");
+        else if (ret == WLAN_SECURITY_WEP) printf("wep\n");
+        else if (ret == WLAN_SECURITY_NONE) printf("none\n");
+        else printf("wpa2");
+//####################
+    if ((filename[0] != '\0' ) && (ssid[0] != '\0') && (password[0] != '\0') && (protocol == EASY_SETUP_PROTO_COOEE)) {
+        int fd_conf = -1;
+        int size = 0;
+        char buf[1024];
+        do {
+            fd_conf = open(filename, O_CREAT | O_TRUNC | O_RDWR, 0666);
+            if (fd_conf < 0) {
+                perror("open");
+                break;
+            }
+            snprintf(buf, sizeof(buf), "ssid=%s\npassword=%s\n", ssid,password);
+            len = strlen(buf);
+            size = write(fd_conf, buf, len);
+            if (size != len) {
+                printf("Write error\n");
+            }
+            close(fd_conf);
+            fd_conf= -1;
+            printf("Save config [%s] done\n", filename);
+        } while (0);
+    }
+
+//####################
+}
+    /* must do this! */
+    easy_setup_stop();
+
+    if(ret_ori == -1)
+    {
+        return -1;
+    }
+    return 0;
+}
+
diff --git a/fastboot_app/network_manager/cooee/cooee_inter.h b/fastboot_app/network_manager/cooee/cooee_inter.h
new file mode 100644
index 0000000..44cdeed
--- /dev/null
+++ b/fastboot_app/network_manager/cooee/cooee_inter.h
@@ -0,0 +1,35 @@
+/*
+ * cooee_inter.h
+ *
+ * History:
+ *       2015/08/14 - [JBxing] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef cooee_h_
+#define cooee_h_
+int cooee_interface(char *file);
+#endif
diff --git a/fastboot_app/network_manager/cooee/easy_setup/common.h b/fastboot_app/network_manager/cooee/easy_setup/common.h
new file mode 100644
index 0000000..bc1870b
--- /dev/null
+++ b/fastboot_app/network_manager/cooee/easy_setup/common.h
@@ -0,0 +1,54 @@
+#ifndef __EASY_SETUP_COMMON_H__
+#define __EASY_SETUP_COMMON_H__
+
+#include <stdio.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+#define uint8 unsigned char
+#define uint16 unsigned short
+#define uint32 unsigned int
+
+#define int8 char
+#define int16 short
+#define int32 int
+
+/* direct log message to your system utils, default printf */
+extern int debug_enable;
+#define LOGE(fmt, arg...) do {if (1 | debug_enable) printf(fmt, ##arg);} while (0);
+#define LOGD(fmt, arg...) do {if (debug_enable) printf(fmt, ##arg);} while (0);
+
+typedef struct {
+    uint8 type;
+    uint8 length;
+    uint8 value[0];
+} tlv_t;
+
+/**
+ * Structure for storing a Service Set Identifier (i.e. Name of Access Point)
+ */
+typedef struct {
+    uint8 len;     /**< SSID length */
+    uint8 val[32]; /**< SSID name (AP name)  */
+} ssid_t;
+
+/**
+ * Structure for storing a MAC address (Wi-Fi Media Access Control address).
+ */
+typedef struct {
+    uint8 octet[6]; /**< Unique 6-byte MAC address */
+} mac_t;
+
+/**
+ * Structure for storing a IP address.
+ */
+typedef struct {
+    uint8 version;   /**< IPv4 or IPv6 type */
+
+    union {
+        uint32 v4;   /**< IPv4 IP address */
+        uint32 v6[4];/**< IPv6 IP address */
+    } ip;
+} ip_address_t;
+
+#endif /* __EASY_SETUP_COMMON_H__ */
diff --git a/fastboot_app/network_manager/cooee/easy_setup/easy_setup.c b/fastboot_app/network_manager/cooee/easy_setup/easy_setup.c
new file mode 100644
index 0000000..c868b35
--- /dev/null
+++ b/fastboot_app/network_manager/cooee/easy_setup/easy_setup.c
@@ -0,0 +1,69 @@
+#include "easy_setup.h"
+
+#include "cooee.h"
+#include "neeze.h"
+#include "akiss.h"
+#include "changhong.h"
+
+extern uint16 g_protocol_mask;
+
+void easy_setup_enable_cooee() {
+    g_protocol_mask |= (1<<EASY_SETUP_PROTO_COOEE);
+}
+
+void easy_setup_enable_neeze() {
+    g_protocol_mask |= (1<<EASY_SETUP_PROTO_NEEZE);
+}
+
+void easy_setup_enable_akiss() {
+    g_protocol_mask |= (1<<EASY_SETUP_PROTO_AKISS);
+}
+
+void easy_setup_enable_changhong() {
+    g_protocol_mask |= (1<<EASY_SETUP_PROTO_CHANGHONG);
+}
+
+void easy_setup_enable_protocols(uint16 proto_mask) {
+    g_protocol_mask |= proto_mask;
+}
+
+void easy_setup_get_param(uint16 proto_mask, tlv_t** pptr) {
+    tlv_t* t = *pptr;
+    int i=0;
+    for (i=0; i<EASY_SETUP_PROTO_MAX; i++) {
+        if (proto_mask & (1<<i)) {
+            t->type = i;
+
+            if (i==EASY_SETUP_PROTO_COOEE) {
+                t->length = sizeof(cooee_param_t);
+                cooee_get_param(t->value);
+            } else if (i==EASY_SETUP_PROTO_NEEZE) {
+                t->length = sizeof(neeze_param_t);
+                neeze_get_param(t->value);
+            } else if (i==EASY_SETUP_PROTO_AKISS) {
+                t->length = sizeof(akiss_param_t);
+                akiss_get_param(t->value);
+            } else {
+                t->length = 0;
+            }
+
+            t = (tlv_t*) (t->value + t->length);
+        }
+    }
+
+    *pptr = t;
+}
+
+void easy_setup_set_result(uint8 protocol, void* p) {
+    if (protocol == EASY_SETUP_PROTO_COOEE) {
+        cooee_set_result(p);
+    } else if (protocol == EASY_SETUP_PROTO_NEEZE) {
+        neeze_set_result(p);
+    } else if (protocol == EASY_SETUP_PROTO_AKISS) {
+        akiss_set_result(p);
+    } else if (protocol == EASY_SETUP_PROTO_CHANGHONG) {
+        changhong_set_result(p);
+    } else {
+        ;// nothing done
+    }
+}
diff --git a/fastboot_app/network_manager/cooee/easy_setup/easy_setup.h b/fastboot_app/network_manager/cooee/easy_setup/easy_setup.h
new file mode 100644
index 0000000..4d751c5
--- /dev/null
+++ b/fastboot_app/network_manager/cooee/easy_setup/easy_setup.h
@@ -0,0 +1,132 @@
+#ifndef __EASY_SETUP_H__
+#define __EASY_SETUP_H__
+
+#include "common.h"
+
+#define EASY_SETUP_STATE_DONE (5)
+
+/* wlan security */
+enum {
+    WLAN_SECURITY_NONE = 0,
+    WLAN_SECURITY_WEP,
+    WLAN_SECURITY_WPA,
+    WLAN_SECURITY_WPA2,
+};
+
+/* easy setup protocols */
+enum {
+    EASY_SETUP_PROTO_COOEE = 0,
+    EASY_SETUP_PROTO_NEEZE,
+    EASY_SETUP_PROTO_AKISS,
+    EASY_SETUP_PROTO_XIAOMI,
+    EASY_SETUP_PROTO_CHANGHONG,
+    EASY_SETUP_PROTO_MAX,
+};
+
+enum {
+    EASY_SETUP_STOP = 0,
+    EASY_SETUP_START,
+    EASY_SETUP_RESTART,
+};
+
+typedef struct {
+    uint8 enable;    /* START/STOP/RESTART easy setup */
+    uint16 protocol_mask;  /* set parameters to which protocol */
+    tlv_t param; /* param blocks for each protocol */
+} easy_setup_param_t;
+
+typedef struct {
+    uint8          state;
+    uint8          security_key[64];     /* target AP's password */
+    uint8          security_key_length;  /* length of password */
+    ssid_t         ap_ssid;              /* target AP's name */
+    mac_t          ap_bssid;             /* target AP's mac address */
+} easy_setup_result_t;
+
+/* internal interface */
+void easy_setup_get_param(uint16 proto_mask, tlv_t** pptr);
+void easy_setup_set_result(uint8 protocol, void* p);
+
+/*
+ * public interface here!!!
+ */
+
+/*
+ * Set decryption key, if you have set it in sender side
+ * parameter
+ *   key: null-terminated key string
+ * returns
+ *   0: succ, -1: fail
+ */
+int easy_setup_set_decrypt_key(char* key);
+
+/* enable easy setup protocols */
+void easy_setup_enable_cooee(); /* broadcom cooee */
+void easy_setup_enable_neeze(); /* broadcom neeze */
+void easy_setup_enable_akiss(); /* wechat airkiss */
+void easy_setup_enable_qqcon(); /* qq connect */
+void easy_setup_enable_changhong(); /* changhong smart link */
+
+/* enable protocols one time by bitmask
+ * 0x0001 - cooee
+ * 0x0002 - neeze
+ * 0x0004 - airkiss
+ * 0x0010 - changhong
+ */
+void easy_setup_enable_protocols(uint16 proto_mask);
+
+/*
+ * Start easy setup
+ * returns
+ *   0: succ, -1: fail
+ */
+int easy_setup_start();
+
+/*
+ * Stop easy setup
+ * returns
+ *   0: succ, -1: fail
+ */
+int easy_setup_stop();
+
+/*
+ * Query easy setup result. This function blocks for some time (see EASY_SETUP_QUERY_TIMEOUT)
+ * returns
+ *   0: succ, -1: fail
+ */
+int easy_setup_query();
+
+int easy_setup_iovar(int set, void* param, int size);
+int easy_setup_ioctl(int cmd, int set, void* param, int size);
+
+/*
+ * Get ssid. Call this after easy_setup_query() succeeds.
+ * returns
+ *   0: succ, -1: fail
+ */
+int easy_setup_get_ssid(char buff[], int buff_len);
+
+/*
+ * Get password. Call this after easy_setup_query() succeeds.
+ * returns
+ *   0: succ, -1: fail
+ */
+int easy_setup_get_password(char buff[], int buff_len);
+
+/* get protocol shot */
+int easy_setup_get_protocol(uint8* protocol);
+
+int easy_setup_get_security() ;
+#if 0
+/*
+ * Get security of configured SSID
+ * returns
+ *   WLAN_SCURITY_NONE: NONE
+ *   WLAN_SCURITY_WEP: WEP
+ *   WLAN_SCURITY_WPA: WPA
+ *
+ */
+int easy_setup_get_security(void);
+#endif
+
+#endif /* __EASY_SETUP_H__ */
diff --git a/fastboot_app/network_manager/cooee/easy_setup/scan.c b/fastboot_app/network_manager/cooee/easy_setup/scan.c
new file mode 100644
index 0000000..9963052
--- /dev/null
+++ b/fastboot_app/network_manager/cooee/easy_setup/scan.c
@@ -0,0 +1,214 @@
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "easy_setup.h"
+
+#define ETHER_ADDR_LEN    6
+#define DOT11_BSSTYPE_ANY 2
+
+#define htod32(n) (n)
+#define dtoh32(n) (n)
+#define dtoh16(n) (n)
+
+#define WLC_SCAN 50
+#define WLC_SCAN_RESULTS 51
+
+typedef struct wlc_ssid {
+    uint32      SSID_len;
+    uint8       SSID[32];
+} wlc_ssid_t;
+
+struct    ether_addr {
+    uint8 octet[ETHER_ADDR_LEN];
+};
+
+typedef struct wl_scan_params {
+    wlc_ssid_t ssid;
+    struct ether_addr bssid;
+    int8 bss_type;
+    uint8 scan_type;
+    int32 nprobes;
+    int32 active_time;
+    int32 passive_time;
+    int32 home_time;
+    int32 channel_num;
+    uint16 channel_list[1];
+} wl_scan_params_t;
+
+typedef struct wl_bss_info_107 {
+    uint32      version;
+    uint32      length;
+    struct ether_addr BSSID;
+    uint16      beacon_period;
+    uint16      capability;
+    uint8       SSID_len;
+    uint8       SSID[32];
+    struct {
+        uint    count;
+        uint8   rates[16];
+    } rateset;
+    uint8       channel;
+    uint16      atim_window;
+    uint8       dtim_period;
+    int16       RSSI;
+    int8        phy_noise;
+    uint32      ie_length;
+} wl_bss_info_107_t;
+
+typedef struct wl_bss_info {
+    uint32      version;
+    uint32      length;
+    struct ether_addr BSSID;
+    uint16      beacon_period;
+    uint16      capability;
+    uint8       SSID_len;
+    uint8       SSID[32];
+    struct {
+        uint    count;
+        uint8   rates[16];
+    } rateset;
+    uint16      chanspec;
+    uint16      atim_window;
+    uint8       dtim_period;
+    int16       RSSI;
+    int8        phy_noise;
+
+    uint8       n_cap;
+    uint32      nbss_cap;
+    uint8       ctl_ch;
+    uint8       padding1[3];
+    uint16      vht_rxmcsmap;
+    uint16      vht_txmcsmap;
+    uint8       flags;
+    uint8       vht_cap;
+    uint8       reserved[2];
+    uint8       basic_mcs[16];
+
+    uint16      ie_offset;
+    uint32      ie_length;
+    int16       SNR;
+} wl_bss_info_t;
+
+typedef struct wl_scan_results {
+    uint32 buflen;
+    uint32 version;
+    uint32 count;
+    wl_bss_info_t bss_info[1];
+} wl_scan_results_t; 
+
+static int scan_and_get_security_internal(int ch, uint8* bssid, ssid_t* ssid) {
+    int sec = -1;
+
+    int ret = 0;
+    wl_scan_params_t p;
+
+    memset(&p, 0, sizeof(p));
+    p.bss_type = DOT11_BSSTYPE_ANY;
+    p.scan_type = 0;
+    p.nprobes = -1;
+    p.active_time = 100;
+    p.passive_time = -1;
+    p.home_time = -1;
+    p.channel_num = 0;
+
+    if (ch > 0) {
+        p.channel_num = 1;
+        p.channel_list[0] = ch;
+    }
+
+    if (bssid) {
+        memcpy(&p.bssid, bssid, ETHER_ADDR_LEN);
+    } else {
+        uint8 bcast[ETHER_ADDR_LEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+        memcpy(&p.bssid, bcast, sizeof(bcast));
+    }
+
+    if (ssid) {
+        p.ssid.SSID_len = ssid->len;
+        memcpy(p.ssid.SSID, ssid->val, sizeof(ssid->val));
+    }
+
+    p.nprobes = htod32(p.nprobes);
+    p.active_time = htod32(p.active_time);
+    p.passive_time = htod32(p.passive_time);
+    p.home_time = htod32(p.home_time);
+
+    if ((ret = easy_setup_ioctl(WLC_SCAN, 1, &p, sizeof(p))) < 0) {
+        return -1;
+    }
+
+    int size = 1024;
+    uint8* ptr = malloc(size);
+    wl_scan_results_t* r;
+    r = (wl_scan_results_t*) ptr;
+    int tries = 20;
+    int delay_ms = 150;
+    while (tries--) {
+        memset(ptr, 0, size);
+        r->buflen = size;
+        ret = easy_setup_ioctl(WLC_SCAN_RESULTS, 0, r, size);
+        if (!ret && r->count) break;
+
+        //LOGD("sleep %dms\n", delay_ms);
+        usleep(delay_ms*1000);
+    }
+
+    if (!ret && r->count) {
+        wl_bss_info_t* bi = r->bss_info;
+
+        if (dtoh32(bi->version) == 107) {
+            wl_bss_info_107_t *old = (wl_bss_info_107_t *)bi;
+            bi->ie_length = old->ie_length;
+            bi->ie_offset = sizeof(wl_bss_info_107_t);
+        }
+
+        uint16 cap = dtoh16(bi->capability);
+        int totlen = dtoh32(bi->ie_length);
+//        int wpa = 0;
+        if (totlen) {
+            uint8* ie = (uint8 *)(((uint8 *)bi) + dtoh16(bi->ie_offset));
+            while (totlen>=2) {
+                int type = ie[0];
+                int len = ie[1];
+
+                if (type == 221 && len >= 4) {
+                    int v = (ie[2]<<24) | (ie[3]<<16) | (ie[4]<<8) | (ie[5]);
+                    if (v == 0x0050f201) {
+                        sec = WLAN_SECURITY_WPA;
+                        break;
+                    }
+                }
+
+                if (type == 48) {
+                    sec = WLAN_SECURITY_WPA2;
+                    break;
+                }
+
+                totlen -= (len+2);
+                ie += (len+2);
+            }
+        }
+
+        if (sec != WLAN_SECURITY_WPA && sec != WLAN_SECURITY_WPA2) {
+            if (cap & 0x10) {
+                sec = WLAN_SECURITY_WEP;
+            } else {
+                sec = WLAN_SECURITY_NONE;
+            }
+        }
+    } else {
+        LOGD("scan gets no result(ret: %d, count: %d).\n", ret, (!ret)?r->count:0);
+        sec = -1;
+    }
+
+    free(ptr);
+
+    return sec;
+}
+
+int scan_and_get_security(ssid_t* ssid) {
+    return scan_and_get_security_internal(-1, NULL, ssid);
+}
+
diff --git a/fastboot_app/network_manager/cooee/easy_setup/scan.h b/fastboot_app/network_manager/cooee/easy_setup/scan.h
new file mode 100644
index 0000000..8c89b96
--- /dev/null
+++ b/fastboot_app/network_manager/cooee/easy_setup/scan.h
@@ -0,0 +1,8 @@
+#ifndef __EASY_SETUP_SCAN_H__
+#define __EASY_SETUP_SCAN_H__
+
+#include "common.h"
+
+int scan_and_get_security(ssid_t* ssid);
+
+#endif /* __EASY_SETUP_SCAN_H__ */
diff --git a/fastboot_app/network_manager/cooee/easy_setup_linux.c b/fastboot_app/network_manager/cooee/easy_setup_linux.c
new file mode 100644
index 0000000..1b5f0bb
--- /dev/null
+++ b/fastboot_app/network_manager/cooee/easy_setup_linux.c
@@ -0,0 +1,286 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <linux/if.h>
+
+#include <easy_setup.h>
+#include <scan.h>
+
+#define ES_TARGET_VERSION "v3.2.0"
+
+#define QUERY_TIMEOUT_MS (30*1000)
+#define QUERY_INTERVAL_MS (1000)
+
+#define WLAN_IFACE "wlan0"
+
+#define PARAM_MAX_LEN (256)
+#define RESULT_MAX_LEN (256)
+
+#define WLC_GET_VAR (262)
+#define WLC_SET_VAR (263)
+
+#define DEFAULT_PROTOCOL_MASK (0x3) /* cooee */
+uint16 g_protocol_mask = 0; /* default no protocols enabled */
+
+/* Linux network driver ioctl encoding */
+typedef struct wl_ioctl {
+    uint cmd;        /* common ioctl definition */
+    void *buf;       /* pointer to user buffer */
+    uint len;        /* length of user buffer */
+    unsigned char set;  /* 1=set IOCTL; 0=query IOCTL */
+    uint used;       /* bytes read or written (optional) */
+    uint needed;     /* bytes needed (optional) */
+} wl_ioctl_t;
+
+static int g_ioc_fd = -1; /* socket fd */
+static easy_setup_result_t g_result;
+static uint8 g_protocol = 0;
+
+int easy_setup_start() {
+    int i;
+    int ret = 0;
+
+    LOGE("Easy setup target library %s\n", ES_TARGET_VERSION);
+
+    int found = 0;
+    for (i=0; i<EASY_SETUP_PROTO_MAX; i++) {
+        if (g_protocol_mask & (1<<i)) {
+            found = 1;
+            break;
+        }
+    }
+
+    if (!found) {
+        g_protocol_mask = DEFAULT_PROTOCOL_MASK;
+    }
+
+    /* open socket to kernel */
+    if ((g_ioc_fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
+        LOGE("create control socket failed: %d(%s)\n", errno, strerror(errno));
+        return -1;
+    }
+
+    easy_setup_param_t* p = (easy_setup_param_t*) malloc(PARAM_MAX_LEN);
+    memset(p, 0, PARAM_MAX_LEN);
+    p->enable = EASY_SETUP_START;
+    p->protocol_mask = g_protocol_mask;
+
+    int param_len = 0;
+    param_len += ((uint8*)&p->param-(uint8*)p);
+
+    tlv_t* t = &p->param;
+    easy_setup_get_param(g_protocol_mask, &t);
+
+    if ((ret = easy_setup_iovar(1, p, (uint8*) t - (uint8*) p)) < 0) {
+        LOGE("easy setup start failed: %d(%s)\n",
+                errno, strerror(errno));
+    }
+
+    free(p);
+    return ret;
+}
+
+int easy_setup_stop() {
+    int ret = 0;
+
+    if (g_ioc_fd < 0) {
+        LOGE("easy setup query: control socket not initialized.\n");
+        return -1;
+    }
+
+    easy_setup_param_t param;
+    memset(&param, 0, sizeof(param));
+    param.enable = EASY_SETUP_STOP;
+    param.protocol_mask = 0;
+
+    if ((ret = easy_setup_iovar(1, &param, sizeof(param))) < 0) {
+        LOGE("easy setup stop failed: %d(%s)\n",
+                errno, strerror(errno));
+    }
+
+    close(g_ioc_fd);
+
+    return ret;
+}
+
+/* query result is of tlv format
+ * type = protocol shot
+ * length = result length
+ * value = cooee_result_t/akiss_result_t ... */
+int easy_setup_query() {
+    int ret = 0;
+    tlv_t* query = NULL;
+
+    if (g_ioc_fd < 0) {
+        LOGE("easy setup query: control socket not initialized.\n");
+        return -1;
+    }
+
+    query = (tlv_t*) malloc(RESULT_MAX_LEN);
+
+    if (!query) {
+        LOGE("failed allocating result buffer.\n");
+        return -1;
+    }
+    uint last_state = 0;
+    int tries = QUERY_TIMEOUT_MS/QUERY_INTERVAL_MS;
+    while (tries--) {
+        usleep(QUERY_INTERVAL_MS * 1000);
+
+        ret = easy_setup_iovar(0, query, RESULT_MAX_LEN);
+        if (ret < 0) {
+            LOGE("easy setup query failed: %d(%s)\n", errno, strerror(errno));
+        //    free(query);
+        //    return -1;
+        } else {
+
+            /* copy common part of result to easy_setup_result_t */
+            memcpy(&g_result, query->value, sizeof(g_result));
+            if (last_state != g_result.state) {
+                LOGD("state: %d --> %d\n", last_state, g_result.state);
+                last_state = g_result.state;
+                if (last_state == EASY_SETUP_STATE_DONE) {
+                    g_protocol = query->type;
+                    easy_setup_set_result(g_protocol, query->value);
+
+                    break;
+                }
+            }
+        }
+    }
+
+    if (tries <= 0) {
+        LOGE("easy setup query timed out.\n");
+        free(query);
+        return -1;
+    }
+
+    free(query);
+    return 0;
+}
+
+int easy_setup_iovar(int set, void* param, int size) {
+    int ret = 0;
+    char* cmd = "easy_setup";
+    int cmd_len = strlen(cmd)+1;
+    int tot_len = cmd_len+size;
+    uint8* ptr = (uint8*) malloc(tot_len);
+    if (!ptr) {
+        LOGE("easy setup iovar: malloc failed\n");
+        return -1;
+    }
+
+    strcpy((char *)ptr, cmd);
+    memcpy(ptr+cmd_len, param, size);
+
+    ret = easy_setup_ioctl(set?WLC_SET_VAR:WLC_GET_VAR, set, ptr, tot_len);
+
+    /* for iovar get, copy back data */
+    if (!set) {
+        memcpy(param, ptr, size);
+    }
+
+    free(ptr);
+    return ret;
+}
+
+int easy_setup_ioctl(int cmd, int set, void* param, int size) {
+    struct ifreq ifr;
+    wl_ioctl_t ioc;
+    int ret = 0;
+
+    if (g_ioc_fd < 0) {
+        LOGE("easy setup ioctl: control socket not initialized.\n");
+        return -1;
+    }
+
+    ioc.cmd = cmd;
+    ioc.buf = param;
+    ioc.len = size;
+    ioc.set = set;
+
+    strncpy(ifr.ifr_name, WLAN_IFACE, IFNAMSIZ);
+    ifr.ifr_name[IFNAMSIZ-1] = 0;
+    ifr.ifr_data = (caddr_t) &ioc;
+
+    if ((ret = ioctl(g_ioc_fd, SIOCDEVPRIVATE, &ifr)) < 0) {
+        /* log if not WLC_SCAN_RESULTS(51) */
+        if (cmd != 51) {
+            LOGD("easy setup ioctl(cmd=%d) failed: %d(%s)\n",
+                    cmd, errno, strerror(errno));
+        }
+        return -1;
+    }
+
+    return 0;
+}
+
+int easy_setup_get_ssid(char buff[], int buff_len) {
+    int i;
+    easy_setup_result_t* r = &g_result;
+
+    if (r->state != EASY_SETUP_STATE_DONE) {
+        LOGE("easy setup data unavailable\n");
+        return -1;
+    }
+
+    if (buff_len < r->ap_ssid.len+1) {
+        LOGE("insufficient buffer provided: %d < %d\n", buff_len, r->ap_ssid.len+1);
+        return -1;
+    }
+
+    for (i=0; i<r->ap_ssid.len; i++) {
+        buff[i] = r->ap_ssid.val[i];
+    }
+    buff[i] = 0;
+
+    return 0;
+}
+
+int easy_setup_get_password(char buff[], int buff_len) {
+    int i;
+    easy_setup_result_t* r = &g_result;
+
+    if (r->state != EASY_SETUP_STATE_DONE) {
+        LOGE("easy setup data unavailable\n");
+        return -1;
+    }
+
+    if (buff_len < r->security_key_length+1) {
+        LOGE("insufficient buffer provided: %d < %d\n", buff_len, r->security_key_length+1);
+        return -1;
+    }
+
+    for (i=0; i<r->security_key_length; i++) {
+        buff[i] = r->security_key[i];
+    }
+    buff[i] = 0;
+
+    return 0;
+}
+
+int easy_setup_get_protocol(uint8* protocol) {
+    easy_setup_result_t* r = &g_result;
+
+    if (r->state != EASY_SETUP_STATE_DONE) {
+        LOGE("easy setup data unavailable\n");
+        return -1;
+    }
+
+    *protocol = g_protocol;
+
+    return 0;
+}
+
+int easy_setup_get_security() {
+    if (g_result.state != EASY_SETUP_STATE_DONE) {
+        LOGE("easy setup data unavailable\n");
+        return -1;
+    }
+
+    return scan_and_get_security(&g_result.ap_ssid);
+}
diff --git a/fastboot_app/network_manager/cooee/proto/akiss.c b/fastboot_app/network_manager/cooee/proto/akiss.c
new file mode 100644
index 0000000..587b5aa
--- /dev/null
+++ b/fastboot_app/network_manager/cooee/proto/akiss.c
@@ -0,0 +1,36 @@
+#include <string.h>
+
+#include <akiss.h>
+
+static akiss_param_t g_akiss_param;
+static akiss_result_t g_akiss_result;
+
+void akiss_get_param(void* p) {
+    memcpy(p, &g_akiss_param, sizeof(g_akiss_param));
+}
+
+void akiss_set_result(const void* p) {
+    memcpy(&g_akiss_result, p, sizeof(g_akiss_result));
+}
+
+int akiss_set_key(const char* key) {
+    if (strlen(key) < sizeof(g_akiss_param.key_bytes)) {
+        LOGE("invalid key length: %zu < %zu\n",
+                strlen(key), sizeof(g_akiss_param.key_bytes));
+        return -1;
+    }
+
+    memcpy(g_akiss_param.key_bytes, key, sizeof(g_akiss_param.key_bytes));
+
+    return 0;
+}
+
+int akiss_get_random(uint8* random) {
+    if (g_akiss_result.es_result.state != EASY_SETUP_STATE_DONE) {
+        LOGE("easy setup data unavailable\n");
+        return -1;
+    }
+
+    *random = g_akiss_result.random;
+    return 0;
+}
diff --git a/fastboot_app/network_manager/cooee/proto/akiss.h b/fastboot_app/network_manager/cooee/proto/akiss.h
new file mode 100644
index 0000000..da906e9
--- /dev/null
+++ b/fastboot_app/network_manager/cooee/proto/akiss.h
@@ -0,0 +1,23 @@
+#ifndef __AKISS_H__
+#define __AKISS_H__
+
+#include <easy_setup.h>
+
+#define AKISS_KEY_STRING_LEN (16)
+
+typedef struct {
+    uint8 key_bytes[AKISS_KEY_STRING_LEN];  /* key string for decoding */
+} akiss_param_t;
+
+typedef struct {
+    easy_setup_result_t es_result;
+    uint8 random; /* akiss random byte */
+} akiss_result_t;
+
+int akiss_set_key(const char* key);
+void akiss_get_param(void* p);
+void akiss_set_result(const void* p);
+
+int akiss_get_random(uint8* random);
+
+#endif /* __AKISS_H__ */
diff --git a/fastboot_app/network_manager/cooee/proto/changhong.c b/fastboot_app/network_manager/cooee/proto/changhong.c
new file mode 100644
index 0000000..30a5f83
--- /dev/null
+++ b/fastboot_app/network_manager/cooee/proto/changhong.c
@@ -0,0 +1,20 @@
+#include <string.h>
+
+#include <changhong.h>
+
+static changhong_result_t g_changhong_result;
+
+void changhong_set_result(const void* p) {
+    memcpy(&g_changhong_result, p, sizeof(g_changhong_result));
+    LOGE("changhong_set_result: state: %d\n", g_changhong_result.es_result.state);
+}
+
+int changhong_get_sec_mode(uint8* sec) {
+    if (g_changhong_result.es_result.state != EASY_SETUP_STATE_DONE) {
+        LOGE("easy setup data unavailable\n");
+        return -1;
+    }
+
+    *sec = g_changhong_result.sec_mode;
+    return 0;
+}
diff --git a/fastboot_app/network_manager/cooee/proto/changhong.h b/fastboot_app/network_manager/cooee/proto/changhong.h
new file mode 100644
index 0000000..d90f327
--- /dev/null
+++ b/fastboot_app/network_manager/cooee/proto/changhong.h
@@ -0,0 +1,18 @@
+#ifndef __CHANGHONG_H__
+#define __CHANGHONG_H__
+
+#include <easy_setup.h>
+
+/* no param for changhong */
+
+/* changhong result */
+typedef struct {
+    easy_setup_result_t es_result;
+    uint8 sec_mode; /* sec mode */
+} changhong_result_t;
+
+void changhong_set_result(const void* p);
+
+int changhong_get_sec_mode(uint8* sec);
+
+#endif /* __CHANGHONG_H__ */
diff --git a/fastboot_app/network_manager/cooee/proto/cooee.c b/fastboot_app/network_manager/cooee/proto/cooee.c
new file mode 100644
index 0000000..3871398
--- /dev/null
+++ b/fastboot_app/network_manager/cooee/proto/cooee.c
@@ -0,0 +1,94 @@
+#include <string.h>
+
+#include <cooee.h>
+
+static cooee_param_t g_cooee_param = {
+    .key_bytes = {
+        'a', 'b', 'c', 'd', 'a', 'b', 'c', 'd',
+        'a', 'b', 'c', 'd', 'a', 'b', 'c', 'd'},
+    .random_bytes = {
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x77, 0x69, 0x63, 0x65, 0x64},
+    .key_bytes_qqcon = {
+        'a', 'a', '6', 'b', 'c', '5', '1', '4',
+        '-', '6', 'e', '7', '2', '-', '4', 'a'},
+    .random_bytes_qqcon = {
+        0x00, 0x00, 0x00, 0x00, 0x71, 0x71, 0x63, 0x6f,
+        0x6e, 0x6e, 0x65, 0x63, 0x74},
+};
+
+static cooee_result_t g_cooee_result;
+
+void cooee_get_param(void* p) {
+    memcpy(p, (void*) &g_cooee_param, sizeof(g_cooee_param));
+}
+
+void cooee_set_result(const void* p) {
+    memcpy((void*) &g_cooee_result, p, sizeof(g_cooee_result));
+}
+
+int cooee_set_key(const char* key) {
+    if (strlen(key) < sizeof(g_cooee_param.key_bytes)) {
+        LOGE("invalid key length: %zu < %zu\n",
+                strlen(key), sizeof(g_cooee_param.key_bytes));
+        return -1;
+    }
+
+    memcpy(g_cooee_param.key_bytes, key, sizeof(g_cooee_param.key_bytes));
+
+    return 0;
+}
+
+int cooee_set_key_qqcon(const char* key) {
+    if (strlen(key) < sizeof(g_cooee_param.key_bytes_qqcon)) {
+        LOGE("invalid key length: %zu < %zu\n",
+                strlen(key), sizeof(g_cooee_param.key_bytes_qqcon));
+        return -1;
+    }
+
+    memcpy(g_cooee_param.key_bytes_qqcon, key, sizeof(g_cooee_param.key_bytes_qqcon));
+
+    return 0;
+}
+
+int cooee_get_sender_ip(char buff[], int buff_len) {
+    char ip_text[16];
+    cooee_result_t* r = &g_cooee_result;
+
+    if (g_cooee_result.es_result.state != EASY_SETUP_STATE_DONE) {
+        LOGE("easy setup data unavailable\n");
+        return -1;
+    }
+
+    if (r->host_ip_address.version != 4) {
+        return -1;
+    }
+
+    int ip = r->host_ip_address.ip.v4;
+    snprintf(ip_text, sizeof(ip_text), "%d.%d.%d.%d",
+            (ip>>24)&0xff,
+            (ip>>16)&0xff,
+            (ip>>8)&0xff,
+            (ip>>0)&0xff);
+    ip_text[16-1] = 0;
+
+    if ((size_t) buff_len < strlen(ip_text)+1) {
+        LOGE("insufficient buffer provided: %d < %zu\n", buff_len, strlen(ip_text)+1);
+        return -1;
+    }
+
+    strcpy(buff, ip_text);
+
+    return 0;
+}
+
+int cooee_get_sender_port(uint16* port) {
+    if (g_cooee_result.es_result.state != EASY_SETUP_STATE_DONE) {
+        LOGE("easy setup data unavailable\n");
+        return -1;
+    }
+
+    *port = g_cooee_result.host_port;
+
+    return 0;
+}
diff --git a/fastboot_app/network_manager/cooee/proto/cooee.h b/fastboot_app/network_manager/cooee/proto/cooee.h
new file mode 100644
index 0000000..ba387f5
--- /dev/null
+++ b/fastboot_app/network_manager/cooee/proto/cooee.h
@@ -0,0 +1,30 @@
+#ifndef __COOEE_H__
+#define __COOEE_H__
+
+#include <easy_setup.h>
+
+#define COOEE_KEY_STRING_LEN (16)
+#define COOEE_NONCE_PAD_LEN (13)
+
+typedef struct {
+    uint8 key_bytes[COOEE_KEY_STRING_LEN];  /* key string for decoding */
+    uint8 random_bytes[COOEE_NONCE_PAD_LEN]; /* random bytes */
+    uint8 key_bytes_qqcon[COOEE_KEY_STRING_LEN];  /* key string for decoding for qqcon */
+    uint8 random_bytes_qqcon[COOEE_NONCE_PAD_LEN]; /* random bytes for qqcon */
+} cooee_param_t;
+
+typedef struct {
+    easy_setup_result_t es_result;
+    ip_address_t   host_ip_address;      /* setup client's ip address */
+    uint16         host_port;            /* setup client's port */
+} cooee_result_t;
+
+void cooee_get_param(void* p);
+void cooee_set_result(const void* p);
+
+int cooee_set_key(const char* key);
+int cooee_set_key_qqcon(const char* key);
+int cooee_get_sender_ip(char buff[], int buff_len);
+int cooee_get_sender_port(uint16* port);
+
+#endif /* __COOEE_H__ */
diff --git a/fastboot_app/network_manager/cooee/proto/neeze.c b/fastboot_app/network_manager/cooee/proto/neeze.c
new file mode 100644
index 0000000..ece29fc
--- /dev/null
+++ b/fastboot_app/network_manager/cooee/proto/neeze.c
@@ -0,0 +1,94 @@
+#include <string.h>
+
+#include <neeze.h>
+
+static neeze_param_t g_neeze_param = {
+    .key_bytes = {
+        'a', 'b', 'c', 'd', 'a', 'b', 'c', 'd',
+        'a', 'b', 'c', 'd', 'a', 'b', 'c', 'd'},
+    .random_bytes = {
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x77, 0x69, 0x63, 0x65, 0x64},
+    .key_bytes_qqcon = {
+        'a', 'a', '6', 'b', 'c', '5', '1', '4',
+        '-', '6', 'e', '7', '2', '-', '4', 'a'},
+    .random_bytes_qqcon = {
+        0x00, 0x00, 0x00, 0x00, 0x71, 0x71, 0x63, 0x6f,
+        0x6e, 0x6e, 0x65, 0x63, 0x74},
+};
+
+static neeze_result_t g_neeze_result;
+
+void neeze_get_param(void* p) {
+    memcpy(p, &g_neeze_param, sizeof(g_neeze_param));
+}
+
+void neeze_set_result(const void* p) {
+    memcpy(&g_neeze_result, p, sizeof(g_neeze_result));
+}
+
+int neeze_set_key(const char* key) {
+    if (strlen(key) < sizeof(g_neeze_param.key_bytes)) {
+        LOGE("invalid key length: %zu < %zu\n",
+                strlen(key), sizeof(g_neeze_param.key_bytes));
+        return -1;
+    }
+
+    memcpy(g_neeze_param.key_bytes, key, sizeof(g_neeze_param.key_bytes));
+
+    return 0;
+}
+
+int neeze_set_key_qqcon(const char* key) {
+    if (strlen(key) < sizeof(g_neeze_param.key_bytes_qqcon)) {
+        LOGE("invalid key length: %zu < %zu\n",
+                strlen(key), sizeof(g_neeze_param.key_bytes_qqcon));
+        return -1;
+    }
+
+    memcpy(g_neeze_param.key_bytes_qqcon, key, sizeof(g_neeze_param.key_bytes_qqcon));
+
+    return 0;
+}
+
+int neeze_get_sender_ip(char buff[], int buff_len) {
+    char ip_text[16];
+    neeze_result_t* r = &g_neeze_result;
+
+    if (g_neeze_result.es_result.state != EASY_SETUP_STATE_DONE) {
+        LOGE("easy setup data unavailable\n");
+        return -1;
+    }
+
+    if (r->host_ip_address.version != 4) {
+        return -1;
+    }
+
+    int ip = r->host_ip_address.ip.v4;
+    snprintf(ip_text, sizeof(ip_text), "%d.%d.%d.%d",
+            (ip>>24)&0xff,
+            (ip>>16)&0xff,
+            (ip>>8)&0xff,
+            (ip>>0)&0xff);
+    ip_text[16-1] = 0;
+
+    if ((size_t) buff_len < strlen(ip_text)+1) {
+        LOGE("insufficient buffer provided: %d < %zu\n", buff_len, strlen(ip_text)+1);
+        return -1;
+    }
+
+    strcpy(buff, ip_text);
+
+    return 0;
+}
+
+int neeze_get_sender_port(uint16* port) {
+    if (g_neeze_result.es_result.state != EASY_SETUP_STATE_DONE) {
+        LOGE("easy setup data unavailable\n");
+        return -1;
+    }
+
+    *port = g_neeze_result.host_port;
+
+    return 0;
+}
diff --git a/fastboot_app/network_manager/cooee/proto/neeze.h b/fastboot_app/network_manager/cooee/proto/neeze.h
new file mode 100644
index 0000000..fd2ee8f
--- /dev/null
+++ b/fastboot_app/network_manager/cooee/proto/neeze.h
@@ -0,0 +1,30 @@
+#ifndef __NEEZE_H__
+#define __NEEZE_H__
+
+#include <easy_setup.h>
+
+#define NEEZE_KEY_STRING_LEN (16)
+#define NEEZE_NONCE_PAD_LEN (13)
+
+typedef struct {
+    uint8 key_bytes[NEEZE_KEY_STRING_LEN];  /* key string for decoding */
+    uint8 random_bytes[NEEZE_NONCE_PAD_LEN]; /* random bytes */
+    uint8 key_bytes_qqcon[NEEZE_KEY_STRING_LEN];  /* key string for decoding for qqcon */
+    uint8 random_bytes_qqcon[NEEZE_NONCE_PAD_LEN]; /* random bytes for qqcon */
+} neeze_param_t;
+
+typedef struct {
+    easy_setup_result_t es_result;
+    ip_address_t host_ip_address;      /* setup client's ip address */
+    uint16 host_port;            /* setup client's port */
+} neeze_result_t;
+
+void neeze_get_param(void* p);
+void neeze_set_result(const void* p);
+
+int neeze_set_key(const char* key);
+int neeze_set_key_qqcon(const char* key);
+int neeze_get_sender_ip(char buff[], int buff_len);
+int neeze_get_sender_port(uint16* port);
+
+#endif /* __NEEZE_H__ */
diff --git a/fastboot_app/network_manager/make.inc b/fastboot_app/network_manager/make.inc
new file mode 100644
index 0000000..40e3feb
--- /dev/null
+++ b/fastboot_app/network_manager/make.inc
@@ -0,0 +1,112 @@
+#
+# make.inc
+#
+# History:
+#       2016/06/01 - [cz Lin] created file
+#
+# Copyright (c) 2015 Ambarella, Inc.
+#
+# This file and its contents ("Software") are protected by intellectual
+# property rights including, without limitation, U.S. and/or foreign
+# copyrights. This Software is also the confidential and proprietary
+# information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+# disclose, distribute, modify, or otherwise prepare derivative works of this
+# Software or any portion thereof except pursuant to a signed license agreement
+# or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+# In the absence of such an agreement, you agree to promptly notify and return
+# this Software to Ambarella, Inc.
+#
+# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+# MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+# IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+#
+
+LOCAL_PATH   := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+IPCAM_APP_LIB_DIR	:= $(FAKEROOT_DIR)/usr/lib
+ELEKTRA_UTILS_DIR	:= $(LOCAL_PATH)/../utils
+COOEE_DIR	             := $(LOCAL_PATH)/cooee
+DEVICE_AGENT		:= $(LOCAL_PATH)/../device_agent
+BRCM_DIR		:= $(LOCAL_PATH)/../../wowl/brcm/inc
+WOWL_DIR		:= $(LOCAL_PATH)/../../wowl/inc
+
+LOCAL_TARGET	:= libbpiNetManager.so
+LOCAL_SRCS         := $(wildcard $(LOCAL_PATH)/src/*.c)
+LOCAL_SRCS	+= $(wildcard $(COOEE_DIR)/*.c)
+LOCAL_SRCS	+= $(wildcard $(COOEE_DIR)/proto/*.c)
+LOCAL_SRCS	+= $(wildcard $(COOEE_DIR)/easy_setup/*.c)
+
+LOCAL_CFLAGS	:= -I$(LOCAL_PATH) \
+	-I$(BRCM_DIR) \
+	-I$(WOWL_DIR) \
+	-I$(ELEKTRA_UTILS_DIR) \
+	-I$(COOEE_DIR) \
+	-I$(COOEE_DIR)/proto \
+	-I$(COOEE_DIR)/easy_setup \
+	-I$(PREBUILD_3RD_PARTY_DIR)/libpcap/include \
+	-I$(PREBUILD_3RD_PARTY_DIR)/iniparser/include \
+
+
+LOCAL_LDFLAGS	:= -lpthread -L$(PREBUILD_3RD_PARTY_DIR)/iniparser/usr/lib/ -liniparser -Wl,-rpath-link=$(FAKEROOT_DIR)/usr/lib
+
+LOCAL_SO_NAME := $(LOCAL_TARGET)
+
+LOCAL_LIBS := libaplayAudio.so libbpiUtils.so libbrcmioc.so
+
+
+include $(BUILD_APP)
+
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(IPCAM_APP_LIB_DIR)/
+	@cp -dpRf $< $(IPCAM_APP_LIB_DIR)/
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+
+#######################
+include $(CLEAR_VARS)
+
+IPCAM_APP_BIN_DIR	:= $(FAKEROOT_DIR)/usr/bin
+
+LOCAL_TARGET	:= test_NetManager
+LOCAL_SRCS        := $(wildcard $(LOCAL_PATH)/*.c)
+LOCAL_CFLAGS	:= -I$(LOCAL_PATH) \
+	-I$(PREBUILD_3RD_PARTY_DIR)/libpcap/include \
+	-I$(PREBUILD_3RD_PARTY_DIR)/iniparser/include \
+	-I$(ELEKTRA_UTILS_DIR) \
+
+LOCAL_LDFLAGS	:= -lm \
+                         -L$(PREBUILD_3RD_PARTY_DIR)/libpcap/usr/lib -lpcap \
+                         -L$(PREBUILD_3RD_PARTY_DIR)/json-c/usr/lib -ljson-c \
+                         -L$(PREBUILD_3RD_PARTY_DIR)/libev/usr/lib -lev \
+	                     -Wl,-rpath-link=$(FAKEROOT_DIR)/usr/lib
+
+ifeq ($(CONFIG_AMBARELLA_ALSA_SUPPORT), y)
+LOCAL_LDFLAGS	+= -L$(PREBUILD_3RD_PARTY_DIR)/alsa-lib/usr/lib -lasound
+endif
+
+LOCAL_LIBS := libbpiNetManager.so libbpiUtils.so
+
+include $(BUILD_APP)
+
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(IPCAM_APP_BIN_DIR)/
+	@cp -dpRf $< $(IPCAM_APP_BIN_DIR)/
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
diff --git a/fastboot_app/network_manager/src/bpi_wlan.c b/fastboot_app/network_manager/src/bpi_wlan.c
new file mode 100644
index 0000000..ca189c1
--- /dev/null
+++ b/fastboot_app/network_manager/src/bpi_wlan.c
@@ -0,0 +1,489 @@
+/*
+ * bpi_wlan.c --
+ *
+ * History:
+ *       2016/01/15 - [CZ Lin] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <pthread.h>
+#include <string.h>
+
+#include <arpa/inet.h>
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <netinet/ether.h>
+
+#include "basetypes.h"
+#include "iniparser.h"
+#include "bpi_utils.h"
+#include "audio_play.h"
+#include "bpi_wlan.h"
+#include "wpa_to_ap.h"
+#include "cooee_inter.h"
+
+#define PLAY_AUDIO
+#define USE_FIRMWARE_SUPPLICANT
+#define COOEE_MAX_TIMES 3
+typedef struct _wlan_pipe
+{
+    const  char *ssid;
+    const  char *passwd;
+    const  char *wpa;
+    int pipe_fd;
+}wrap_wlan_pipe;
+
+static int s_wlan_conf_changed = 0;
+static pthread_t wlan_thread_id = 0;
+static int socket_to_server = -1;
+// for communication between connect_ap thread and wlan_status function call.
+static int pipe_fd[2] = {-1, -1};
+
+#ifdef USE_FIRMWARE_SUPPLICANT
+// use in-firmware wpa supplicant
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int save_wlan_config(const char *file_path, cooee_wlan_conf_t *sWlanConfig)
+{
+    if(NULL == sWlanConfig || NULL == file_path)
+    {
+        LOG_DEBUG("parameter is invalid\n");
+        return -1;
+    }
+
+    dictionary* ini_dict = iniparser_load(file_path);
+    if(!ini_dict){
+        return -1;
+    }
+
+    if(NULL != iniparser_getstring(ini_dict, "wlan:ap_ssid_string", NULL)){
+        iniparser_set(ini_dict, "wlan:ap_ssid_string", sWlanConfig->ap_ssid);
+    }
+
+    if(NULL != iniparser_getstring(ini_dict, "wlan:ap_password_string", NULL)){
+        iniparser_set(ini_dict, "wlan:ap_password_string", sWlanConfig->ap_password);
+    }
+
+    if(NULL != iniparser_getstring(ini_dict, "wlan:ap_wpa_string", NULL)){
+        iniparser_set(ini_dict, "wlan:ap_wpa_string", sWlanConfig->ap_wpa);
+    }
+
+    if(NULL != iniparser_getstring(ini_dict, "wlan:cloud_server_ip_string", NULL)){
+        iniparser_set(ini_dict, "wlan:cloud_server_ip_string", sWlanConfig->cloud_server_ip);
+    }
+
+    FILE* f_ini = fopen(file_path, "w");
+    if(f_ini) {
+        iniparser_dump_ini(ini_dict, f_ini);
+        fclose(f_ini);
+    }
+    iniparser_freedict(ini_dict);
+    return 0;
+}
+
+char * get_server_ip(const char * file_path)
+{
+    static char server_ip[32] = {0};
+    const char* value = NULL;
+    char * ret = NULL;
+    dictionary* ini_dict = NULL;
+    do{
+        if(NULL == file_path)
+            ini_dict = iniparser_load("/etc/bpi/setting.ini");
+        else
+            ini_dict = iniparser_load(file_path);
+        if(!ini_dict){
+            break;
+        }
+        memset(server_ip,'\0',sizeof server_ip);
+        if((value= iniparser_getstring(ini_dict, "wlan:cloud_server_ip_string", NULL))!= NULL) {
+            snprintf(server_ip, sizeof(server_ip),"%s", value);
+            server_ip[sizeof(server_ip)-1] = '\0';
+        } else {
+            break;
+        }
+
+        ret = server_ip;
+    }while(0);
+    if(ini_dict) iniparser_freedict(ini_dict);
+    if(NULL == ret)
+        LOG_ERROR("read server url failed\n");
+    return ret;
+}
+#ifdef __cplusplus
+};
+#endif
+static int wl_setup(const char *ssid, const char *passwd)
+{
+    if (NULL == ssid || NULL == passwd) {
+        LOG_PRINT(" ssid or password should not be null pointers.\n");
+        return EWlan_Disconnected;
+    }
+    int state = EWlan_Disconnected;
+    do {
+        char cmd[256] = {0};
+        if(passwd[0] == '\0') {
+            snprintf(cmd, sizeof(cmd), "/usr/local/bin/wl_setup.sh sta '%s' 2>&1 |grep 'wl_setup' |awk '{print $2}'",ssid);
+        } else {
+            snprintf(cmd, sizeof(cmd), "/usr/local/bin/wl_setup.sh sta '%s' '%s' 2>&1 |grep 'wl_setup' |awk '{print $2}'", ssid, passwd);
+        }
+
+        char connected_ret[] = "Finished";
+        LOG_DEBUG("cmd: %s\n", cmd);
+
+        FILE* p_fd = popen((const char*)cmd, "r");
+        if (p_fd) {
+            char buf[256] = {0};
+            while(fgets(buf, sizeof(buf), p_fd)) {
+                if (strncmp(buf, connected_ret, strlen(connected_ret)) == 0) {
+                    state = EWlan_Connected;
+                    break;
+                }
+            }
+            pclose(p_fd);
+            p_fd = NULL;
+        }
+    } while (0);
+
+    return state;
+}
+#else
+// use Linux wpa supplicant
+static int wifi_setup(const char *ssid, const char *passwd, const char* ap_wpa)
+{
+    if (NULL == ssid || NULL == passwd) {
+        LOG_PRINT(" ssid or password should not be null pointers.\n");
+        return EWlan_Disconnected;
+    }
+    int state = EWlan_Disconnected;
+    do {
+        char cmd[256] = {0};
+        if (access(WPA_SUPPLICANT_CONF_PATH, 0) == 0) {
+            snprintf(cmd, sizeof(cmd), "/usr/local/bin/wifi_setup.sh sta nl80211 2>&1 |grep wifi_setup | awk '{print $2}'");
+        } else {
+            if(passwd[0] == '\0') {
+                snprintf(cmd, sizeof(cmd), "/usr/local/bin/wifi_setup.sh sta nl80211 \'%s\'  2>&1 |grep wifi_setup | awk '{print $2}'", ssid);
+            } else if(passwd[0] == '0' && strcmp(ap_wpa,"open")==0 ) {
+                snprintf(cmd, sizeof(cmd), "/usr/local/bin/wifi_setup.sh sta nl80211 \'%s\' 0 open 2>&1 |grep wifi_setup | awk '{print $2}'", ssid);
+            } else if(ap_wpa[0] == '\0') {
+                snprintf(cmd, sizeof(cmd), "/usr/local/bin/wifi_setup.sh sta nl80211 \'%s\'  \'%s\' 2>&1 |grep wifi_setup | awk '{print $2}'", ssid, passwd);
+            } else {
+                snprintf(cmd, sizeof(cmd), "/usr/local/bin/wifi_setup.sh sta nl80211 \'%s\'  \'%s\'  \'%s\' 2>&1 |grep wifi_setup | awk '{print $2}'", ssid, passwd, ap_wpa);
+            }
+        }
+        char connected_ret[] = "OK<<<";
+        LOG_DEBUG("cmd: %s\n", cmd);
+
+        FILE* p_fd = popen((const char*)cmd, "r");
+        if (p_fd) {
+            char buf[256] = {0};
+            if (fgets(buf, sizeof(buf), p_fd)) {
+                if (strncmp(buf, connected_ret, strlen(connected_ret)) == 0) {
+                    state = EWlan_Connected;
+                }
+            }
+            pclose(p_fd);
+            p_fd = NULL;
+        }
+    } while (0);
+
+    return state;
+}
+#endif
+
+int wlan_conf_changed(){
+    return s_wlan_conf_changed;
+}
+
+void clear_wlan_flag(){
+    s_wlan_conf_changed = 0;
+}
+
+int connect_ap(const char *ssid, const char *passwd, const char *wpa)
+{
+    if(NULL == ssid || NULL == passwd || NULL == wpa)
+    {
+        LOG_ERROR("connect ap info memory address invalid\n");
+        return -1;
+    }
+    LOG_PRINT("connect_ap start: %u\n", get_current_time());
+#ifdef USE_FIRMWARE_SUPPLICANT
+    int state = wl_setup(ssid, passwd);
+#else
+    int state = wifi_setup(ssid, passwd, wpa);
+#endif
+    if(0 != init_wifi_param(1, "wlan0", sizeof("wlan0"))){
+        LOG_ERROR("wifi init: load_default_param failed!\n");
+        return -1;
+    }
+    LOG_PRINT("connect_ap done: %u, state = %s\n", get_current_time(), (state == EWlan_Disconnected) ? "FAIL":"OK" );
+    return state;
+}
+
+static void* _wlan_entry(void* p)
+{
+    if(NULL == p)
+        return NULL;
+    wrap_wlan_pipe* wlan_pipe = (wrap_wlan_pipe*)p;
+
+    u8 status = (u8)connect_ap(wlan_pipe->ssid, wlan_pipe->passwd, wlan_pipe->wpa);
+    if (wlan_pipe->pipe_fd > 0) {
+        write(wlan_pipe->pipe_fd, &status, 1);
+    }
+
+    //TODO, send msg to mcu to notify wlan status
+    pthread_exit("wlan done");
+    return NULL;
+}
+
+int connect_ap_async(const char *ssid, const char *passwd, const char *wpa)
+{
+    if (pipe(pipe_fd) < 0) {
+        LOG_ERROR("pipe fail\n");
+        perror("pipe: ");
+        //pipe_fd[0] = pipe_fd[1] = -1;
+    }
+    wrap_wlan_pipe tmp = {ssid,passwd,wpa,pipe_fd[1]};
+    int ret = pthread_create(&wlan_thread_id, NULL, _wlan_entry, &tmp);
+    if (ret != 0) {
+        LOG_ERROR("pthread_create fail\n");
+        return ECode_WlanUp_Fail;
+    }
+    return ECode_Success;
+}
+
+int ap_connect_status()
+{
+    FILE *p_fd = NULL;
+    int ret = EWlan_Disconnected;
+    char wpa_state[] = "COMPLETED";
+    p_fd = popen("wpa_cli status | grep wpa_state | awk -F '=' '{print $2}' ", "r");
+    if(p_fd){
+        char buf[16] = {0};
+        if(fgets(buf, sizeof(buf), p_fd)){
+            if (strncmp(buf, wpa_state, strlen(wpa_state)) == 0){
+                ret = EWlan_Connected;
+            }
+        }
+        pclose(p_fd);
+        p_fd = NULL;
+    }else{
+        LOG_ERROR("popen failed.\n");
+    }
+    return ret;
+}
+
+#include "test_tcp_connect_nonblock.h"
+
+int connect_server(const char* server_addr, int server_port, int protocol)
+{
+    int ret = -1;
+    do {
+        if (Net_UDP == protocol) {
+            socket_to_server = socket(AF_INET, SOCK_DGRAM, 0);
+        } else if (Net_TCP == protocol) {
+            socket_to_server = socket(AF_INET, SOCK_STREAM, 0);
+        }
+        if (socket_to_server < 0) {
+            LOG_ERROR("socket fail\n");
+            perror("socket: ");
+            break;
+        }
+
+        struct sockaddr_in dest_addr;
+        memset(&dest_addr, 0x0, sizeof(dest_addr));
+        dest_addr.sin_family = AF_INET;
+        dest_addr.sin_addr.s_addr = inet_addr(server_addr);
+        dest_addr.sin_port = htons(server_port);
+        bzero(&(dest_addr.sin_zero), 8);
+
+        int err;
+        if ((err = connect_nonb(socket_to_server, &dest_addr, sizeof(dest_addr), 10)) < 0) {
+            close(socket_to_server);
+            socket_to_server = -1;
+            perror("connect: ");
+            break;
+        }
+        LOG_DEBUG("Socket [%d], Host: %s:%d, Connect OK\n", socket_to_server, server_addr, server_port);
+        ret = 0;
+    } while (0);
+
+    return ret;
+}
+
+int get_fd_to_server()
+{
+    return socket_to_server;
+}
+
+void close_fd_to_server()
+{
+    if (socket_to_server >= 0) {
+        close(socket_to_server);
+        LOG_DEBUG("Close fd [%d].\n", socket_to_server);
+        socket_to_server = -1;
+    }
+}
+
+static void play_audio(char* path)
+{
+#ifdef  PLAY_AUDIO
+    play_audio_by_aplay(path);
+#else
+    LOG_DEBUG("DEBUG: audio play diabled. %s\n", path);
+#endif
+
+}
+
+static int wait_wlan0()
+{
+    struct stat buf;
+    int count = 0;
+    while(stat("/sys/class/net/wlan0/address", &buf) < 0) {
+        usleep(10000);
+        ++count;
+        if(count > 2000) {
+            return -1;
+        }
+    }
+    return 0;
+}
+
+int config_elektra_boot(cooee_wlan_conf_t *wlan_write_back)
+{
+    int ret = -1;
+    do{
+        if(NULL == wlan_write_back)
+        {
+            break;
+        }
+        char buf[256] = {0};
+        char ssid[64] = {0};
+        char psword[32] = {0};
+        char ip[64] = {0};
+        char wpa[64] =  {0};
+        int  cooee_max_times = COOEE_MAX_TIMES;
+        char *head = ssid;
+        char *tail = ssid;
+        int len = 0;
+        int offset = 0;
+
+        system("/sbin/ifconfig wlan0 up");
+        if(wait_wlan0()) {
+            return -1;
+        }
+
+        load_audio_playback_driver();
+        play_audio("/usr/local/bin/config_mode_s16le.wav");
+
+        while(cooee_max_times-- > 0) {
+            if(!cooee_interface(COOEE_CONF_PATH))
+            {
+                play_audio("/usr/local/bin/cooee_ok_s16le.wav");
+                LOG_DEBUG("cooee ok!\n");
+                break;
+            } else {
+                play_audio("/usr/local/bin/cooee_fail_s16le.wav");
+                LOG_DEBUG("cooee fail!\n");
+            }
+        }
+
+        if(cooee_max_times < 0) {
+            play_audio("/usr/local/bin/cooee_time_out_s16le.wav");
+            LOG_DEBUG("cooee time_out !\n");
+            break;
+        }
+
+        //  parse  /tmp/config/cooee.conf
+        LOG_DEBUG(" ############# Parse result to Connect to Ap :ssid:%s,password:%s,ip:%s,wpa:%s\n",ssid,psword,ip,wpa);
+        if(!parse_cooee_conf(ssid,psword,ip,wpa)){
+            play_audio("/usr/local/bin/parse_cooee_transmitted_content_ok_s16le.wav");
+            LOG_DEBUG("Parse cooee ok\n");
+        } else {
+            play_audio("/usr/local/bin/parse_cooee_transmitted_content_fail_s16le.wav");
+            LOG_DEBUG("parse cooee fail!\n");
+            break;
+        }
+        memset(buf,0,sizeof(buf));
+        head = tail = ssid;
+        while(*head) {
+            if((tail=strchr(head,'\''))!=NULL) {
+                len = tail - head;
+                strncpy(buf+offset,"\'",1);
+                offset++;
+                strncpy(buf+offset,head,len);
+                offset+=len;
+                strncpy(buf+offset,"\'\"\'\"",4);
+                offset+=4;
+                head = ++tail;
+            } else {
+                snprintf(buf+offset,sizeof(buf)-offset,"\'%s\'",head);
+                break;
+            }
+        }
+        if(strlen(buf) < sizeof(ssid)) {
+            memset(ssid,'\0',sizeof(ssid));
+            strncpy(ssid,buf,sizeof(ssid));
+        } else {
+            LOG_ERROR("The ssid too long \n");
+            break;
+        }
+
+        if(EWlan_Connected == connect_ap(ssid, psword, wpa)) {
+            play_audio("/usr/local/bin/connecting_ap_ok_s16le.wav");
+        } else {
+            play_audio("/usr/local/bin/connecting_ap_fail_s16le.wav");
+            break;
+        }
+
+        LOG_DEBUG("ssid:%s|psword:%s|pwa:%s|server_ip:%s|\n",ssid,psword,wpa,ip);
+        memset(wlan_write_back, '\0', sizeof(cooee_wlan_conf_t));
+        strncpy(wlan_write_back->ap_ssid,ssid,strlen(ssid));
+        strncpy(wlan_write_back->ap_password,psword,strlen(psword));
+        strncpy(wlan_write_back->ap_wpa,wpa,strlen(wpa));
+        snprintf(wlan_write_back->cloud_server_ip,sizeof(wlan_write_back->cloud_server_ip),"%s",ip);
+        ret = 0;
+    } while(0);
+    if (ret == 0) {
+        play_audio("/usr/local/bin/config_mode_ok_s16le.wav");
+        LOG_DEBUG("############## Config Mode Ok !   ############### \n");
+    }
+    else{
+        play_audio("/usr/local/bin/config_mode_fail_s16le.wav");
+        LOG_DEBUG("############## Config Mode Fail !   ############### \n");
+    }
+    system("/bin/rm -rf /tmp/config/cooee.conf");
+    unload_audio_playback_driver();
+    return  ret;
+}
+
diff --git a/fastboot_app/network_manager/src/test_tcp_connect_nonblock.c b/fastboot_app/network_manager/src/test_tcp_connect_nonblock.c
new file mode 100644
index 0000000..2b50e5e
--- /dev/null
+++ b/fastboot_app/network_manager/src/test_tcp_connect_nonblock.c
@@ -0,0 +1,128 @@
+/*
+ * test_tcp_connect_nonblock.c
+ *
+ * History:
+ *       2015/06/01 - [Jian Liu] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <arpa/inet.h>
+#include <sys/socket.h>
+#include <errno.h>
+#include <poll.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <sys/time.h>
+int connect_nonb(int sockfd, const struct sockaddr_in *saptr, socklen_t salen, int nsec){
+    int flags,n,error;
+    socklen_t len;
+    fd_set rset, wset;
+    struct timeval tval;
+
+    flags = fcntl(sockfd, F_GETFL, 0);
+    fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);
+
+    error = 0;
+    if ( (n = connect(sockfd, (struct sockaddr *) saptr, salen)) < 0){
+        if (errno != EINPROGRESS){
+            return(-1);
+        }
+    }
+    /* Do whatever we want while the connect is taking place. */
+    if (n == 0){
+        goto done;/* connect completed immediately */
+    }
+
+    FD_ZERO(&rset);
+    FD_SET(sockfd, &rset);
+    wset = rset;
+    tval.tv_sec = nsec;
+    tval.tv_usec = 0;
+    while ((n = select(sockfd+1, &rset, &wset, NULL,nsec ? &tval : NULL)) < 0 && errno == EINTR);
+    if (n == 0) {
+        errno = ETIMEDOUT;
+        return(-1);
+    }
+    if (FD_ISSET(sockfd, &rset) || FD_ISSET(sockfd, &wset)) {
+        len = sizeof(error);
+        if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &error, &len) < 0){
+            return(-1);
+        }
+    } else{
+        return (-1);/*select error*/
+    }
+done:
+    fcntl(sockfd, F_SETFL, flags);/* restore file status flags */
+    if (error) {
+        errno = error;
+        return(-1);
+    }
+    return(0);
+}
+
+int test_tcp_connect_nonblock(char *ip,char *port){
+    if((ip==NULL) || (port==NULL))
+    {
+        printf("################ Please check your ip ,port ################ \n");
+        return -1;
+    }
+    struct sockaddr_in server_addr;
+    char *server_ip = ip;
+    unsigned short server_port = (unsigned short)atoi(port);
+    printf("test non-block connect [%s:%u]....\n",server_ip,server_port);
+
+    signal(SIGPIPE,SIG_IGN);
+    int fd = socket(AF_INET, SOCK_STREAM, 0);
+    if (fd < 0){
+        printf("failed to create socket, errno = %d\n",errno);
+        goto fail;
+    }
+    memset(&server_addr,0,sizeof(server_addr));
+    server_addr.sin_family = AF_INET;
+    server_addr.sin_port = htons(server_port);
+    if(inet_pton(AF_INET,server_ip,&server_addr.sin_addr) <= 0){
+        goto fail;
+    }
+    if(connect_nonb(fd,&server_addr,sizeof(server_addr),10) < 0){
+        printf("Failed to connect server,errno = %d\n",errno);
+        goto fail;
+    }
+
+    printf("connect server successfully\n");
+    close(fd);
+    return 0;
+fail:
+    if(fd >= 0){
+        close(fd);
+    }
+    return -1;
+}
+
+
diff --git a/fastboot_app/network_manager/src/test_tcp_connect_nonblock.h b/fastboot_app/network_manager/src/test_tcp_connect_nonblock.h
new file mode 100644
index 0000000..0b74a88
--- /dev/null
+++ b/fastboot_app/network_manager/src/test_tcp_connect_nonblock.h
@@ -0,0 +1,39 @@
+/*
+ * test_tcp_connect_nonblock.h
+ *
+ * History:
+ *       2015/06/01 - [JBxing] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef _test_tcp_connect_nonblock_
+#define _test_tcp_connect_nonblock_
+
+extern  int test_tcp_connect_nonblock(char*ip, char *port);
+int connect_nonb(int sockfd, const struct sockaddr_in *saptr, socklen_t salen, int nsec);
+
+
+#endif
diff --git a/fastboot_app/network_manager/src/wlan_keep_alive.c b/fastboot_app/network_manager/src/wlan_keep_alive.c
new file mode 100644
index 0000000..f35773a
--- /dev/null
+++ b/fastboot_app/network_manager/src/wlan_keep_alive.c
@@ -0,0 +1,576 @@
+/*
+ * wlan_keep_alive.c
+ *
+ * History:
+ *       2015/04/21 - [Chu Chen] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <time.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+#include <getopt.h>
+#include <errno.h>
+#include <assert.h>
+#include <unistd.h>
+#include <ctype.h>
+#include <poll.h>
+
+#include <arpa/inet.h>
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <netinet/ether.h>
+#include <pthread.h>
+#include <basetypes.h>
+
+#include <netinet/ip.h>	/* Internet Protocol 		*/
+#include <netinet/tcp.h>	/* Transmission Control Protocol	*/
+#include <pcap.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+
+#include "brcm_ioc.h"
+#include "bpi_utils.h"
+#include "bpi_wlan.h"
+
+#define DEVICE_INTERFACE "wlan0"
+#define UDP_NETWORK_FILTER_FORMAT   "udp dst port %d"
+#define TCP_NETWORK_FILTER_FORMAT   "tcp dst port %d"
+#define DEFAULT_MSG		            '*'
+#define DEFAULT_MSG_HEX	0x2a // char is DEFAULT_MSG
+#define HAS_PAYLOAD
+
+//#define PCAP_ERRBUF_SIZE             256
+#define PCAP_CAPTURE_MAX_LEN    2048
+#define PCAP_DATA_MAX_LEN          32
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+typedef enum {
+    KEEPALIVE_TCP = 0,
+    KEEPALIVE_UDP,
+} KEEPALIVE_MODE;
+
+static int _verbose = 0;
+static int _interval = 0;
+static int _timeout = 10;
+static int _mode = KEEPALIVE_TCP;
+static int _dtim_interval = 600; //mseconds
+static unsigned char _wake_data[MAX_WAKEUP_DATA_LEN];
+static int _wake_data_len = 0;
+static pcap_t* _p_pcap = NULL;
+
+#define DATA_MAXSIZE         (32)
+#define PROC_WIFI_STATE    "/proc/ambarella/wifi_pm_state"
+typedef struct net_socket_s {
+    int enable_pattern;
+    int enable_host_sleep;
+    int is_poll;
+    tcpka_conn_sess_info_t tcp_info_old;
+    char iface[IFNAMSIZ];
+    wifi_chip_t wifi_chip_id;
+    char recv_msg[DATA_MAXSIZE];
+
+} net_socket_t;
+
+static net_socket_t net_socket;
+
+//////////////////////////////////////////////////////////////
+//
+//copy from wowl.c
+#define PROP_VALUE_MAX	(16)
+#define WLC_GET_VERSION	(1)
+#define WLC_GET_REVINFO	(98)
+
+#define WLC_IOCTL_MAXLEN	(8192)
+#define WLC_GET_VAR		(262)
+#define WLC_SET_VAR		(263)
+#define WLC_GET_BCNPRD	(75)
+#define WLC_GET_DTIMPRD	(77)
+
+#define IPV4_ADDR_LEN		(4)
+static void _process_packet(u_char *arg, const struct pcap_pkthdr* pkthdr, const u_char * packet)
+{
+    int i = 0;
+    int fd = (int)(*arg);
+    char dst_mac[PCAP_DATA_MAX_LEN];
+
+    struct ip *iphdr = NULL;		/* IPv4 Header */
+
+    static int count = 0;
+    LOG_DEBUG("Packet Count: %d\n", ++count);
+
+    if (_verbose) {
+        LOG_PRINT("Received Packet Size: %d\n", pkthdr->len);
+        LOG_PRINT("Payload:\n");
+        for(i = 0; i < pkthdr->len; ++i) {
+            LOG_PRINT(" %02x", packet[i]);
+            if( (i + 1) % 16 == 0 ) {
+                LOG_PRINT("\n");
+            }
+        }
+        LOG_PRINT("\n\n");
+    }
+
+    iphdr = (struct ip *)(packet + 14);
+    if (_mode == KEEPALIVE_TCP) {
+        struct tcphdr *tcphdr = NULL;	/* TCP Header  */
+        unsigned int *tsval;			/* Time Stamp (optional) */
+        unsigned int *tsvalR;			/* Time Stamp Reply (optional) */
+        tcpka_conn_t tcpka;
+
+        tcphdr = (struct tcphdr *)(packet + 14 + 20);
+        tsval = (unsigned int *)(packet + 58);
+        tsvalR = tsval + 1;
+
+        if (tcphdr->psh && (pkthdr->len == 67) && (packet[66] == (u_char) DEFAULT_MSG)) {
+            memset(dst_mac, 0, sizeof(dst_mac));
+            sprintf(dst_mac, "%02X:%02X:%02X:%02X:%02X:%02X", packet[0], packet[1], packet[2], packet[3], packet[4], packet[5]);
+
+            if (_verbose) {
+                LOG_PRINT("	FLags: PSH [%d]\n", tcphdr->psh);
+                LOG_PRINT("	DST MAC: %s\n", dst_mac);
+                LOG_PRINT("	DST IP: %s\n", inet_ntoa(iphdr->ip_dst));
+                LOG_PRINT("	SRC IP: %s\n", inet_ntoa(iphdr->ip_src));
+                LOG_PRINT("	SRC PORT: %d\n", ntohs(tcphdr->th_sport));
+                LOG_PRINT("	DST PORT: %d\n", ntohs(tcphdr->th_dport));
+                LOG_PRINT("	ID: %d\n", ntohs(iphdr->ip_id));
+                LOG_PRINT("	SEQ: %u\n", ntohl(tcphdr->th_seq));
+                LOG_PRINT("	ACK: %u\n", ntohl(tcphdr->th_ack));
+                LOG_PRINT("	Win: %d\n", ntohs(tcphdr->th_win));
+                LOG_PRINT("	TS val: %u\n", ntohl(*tsval));
+                LOG_PRINT("	TS valR: %u\n", ntohl(*tsvalR));
+            }
+
+            /* Fill WiFi FW to KeepAlive and Wakeup Pattern, Session ID: 1 */
+            tcpka.sess_id = 1;
+            tcpka.dst_mac = (struct ether_addr)* ether_aton(dst_mac);
+
+            memcpy(&tcpka.src_ip, &iphdr->ip_src.s_addr, IPV4_ADDR_LEN);
+            memcpy(&tcpka.dst_ip, &iphdr->ip_dst.s_addr, IPV4_ADDR_LEN);
+
+            tcpka.ipid = ntohs(iphdr->ip_id);
+            tcpka.srcport = ntohs(tcphdr->th_sport);
+            tcpka.dstport = ntohs(tcphdr->th_dport);
+            tcpka.seq = ntohl(tcphdr->th_seq);
+            tcpka.ack = ntohl(tcphdr->th_ack);
+            tcpka.tcpwin = ntohs(tcphdr->th_win);
+            tcpka.tsval = ntohl(*tsval);
+            tcpka.tsecr = ntohl(*tsvalR);
+#ifdef HAS_PAYLOAD
+            tcpka.len = pkthdr->len - 66;
+            tcpka.ka_payload_len = pkthdr->len - 66; // 66 is the lenght size of IP/TCP head
+            tcpka.ka_payload[0] = DEFAULT_MSG_HEX;
+#endif
+            net_socket.tcp_info_old.tcpka_sess_ipid = tcpka.ipid;
+            net_socket.tcp_info_old.tcpka_sess_seq = tcpka.seq;
+            net_socket.tcp_info_old.tcpka_sess_ack = tcpka.ack;
+            LOG_DEBUG("Suspend TCP info: ipid[%u], seq[%u], ack[%u]\n",
+                      net_socket.tcp_info_old.tcpka_sess_ipid,
+                      net_socket.tcp_info_old.tcpka_sess_seq,
+                      net_socket.tcp_info_old.tcpka_sess_ack);
+
+            //calc mask and pattern, todo
+            int offset = 66;
+            char tcp_wowl_mask[128];
+            char tcp_wowl_pattern[1024];
+            snprintf(tcp_wowl_mask, sizeof(tcp_wowl_mask),"0x");
+            snprintf(tcp_wowl_pattern, sizeof(tcp_wowl_pattern),"0x");
+            if(_wake_data_len) {
+                int i;
+                char _data_mask[MAX_WAKEUP_DATA_LEN];
+                char *ptr_data_mask =_data_mask;
+                for(i = 0; i < _wake_data_len /8; i++) {
+                    *ptr_data_mask++ = 'f';
+                    *ptr_data_mask++ = 'f';
+                }
+                if(_wake_data_len & 0x07) {
+                    int j,last = _wake_data_len & 0x07;
+                    unsigned char last_mask = 0;
+                    for(j = 0; j < last; j++) {
+                        last_mask |= (1 << j);
+                    }
+                    char m[4];
+                    sprintf(m,"%02X",last_mask);
+                    *ptr_data_mask++ = m[0];
+                    *ptr_data_mask++ = m[1];
+                }
+                *ptr_data_mask++ = '\0';
+                char _data_pattern[MAX_WAKEUP_DATA_LEN * 2 + 1];
+                for(i = 0; i < _wake_data_len; i++) {
+                    sprintf(&_data_pattern[ 2 * i],"%02X",_wake_data[i]);
+                }
+                int mask_len = strlen(tcp_wowl_mask);
+                snprintf(&tcp_wowl_mask[mask_len],sizeof(tcp_wowl_mask) - mask_len,"%s",_data_mask);
+                int pattern_len = strlen(tcp_wowl_pattern);
+                snprintf(&tcp_wowl_pattern[pattern_len], sizeof(tcp_wowl_pattern) - pattern_len, "%s",_data_pattern);
+            }
+
+            wl_tcpka_conn_add(&tcpka);
+            wl_tcpka_conn_enable(1, 1, _interval, 1, 8);
+
+            wl_wowl_pattern(offset,tcp_wowl_mask,tcp_wowl_pattern);
+            wl_wowl(0x00016);
+            wl_wowl_activate(1);
+
+            LOG_DEBUG("Set TCP KeepAlive Done\n");
+            char msg = 's';
+            if (fd > 0) write(fd, &msg, 1);
+        }
+    }
+
+    return;
+}
+
+static int _break_pcap_entry(int fd, int timeout)
+{
+    if (fd < 0) {
+        return -1;
+    }
+
+    fd_set readfds;
+    fd_set fds;
+    FD_ZERO(&fds);
+    FD_ZERO(&readfds);
+    FD_SET(fd, &fds);
+
+    struct timeval time;
+    time.tv_sec = timeout;
+    time.tv_usec = 0;
+
+    u8 msg = 0;
+    int ret = -1;
+    while (1) {
+        readfds = fds;
+        ret = select(fd + 1, &readfds, NULL, NULL, &time);
+        if (ret > 0) {
+            read(fd, &msg, 1);
+            ret = 0;
+            break;
+        } else if (ret < 0) {
+            int err = errno;
+            if (err == EINTR || err == EAGAIN) {
+                continue;
+            }
+            LOG_ERROR("select fail, errno %d\n", err);
+            perror("select: ");
+            ret = -2;
+            break;
+        } else {
+            //timeout
+            LOG_ERROR("_break_pcap_entry timeout\n");
+            ret = -1;
+            break;
+        }
+    }
+
+    if (_p_pcap) {
+        pcap_breakloop(_p_pcap);
+    }
+
+    return ret;
+}
+
+static void* _pcap_loop_entry(void* arg)
+{
+    int* pipe_fd = (int*)arg;
+
+    do {
+        if (!pipe_fd) {
+            LOG_ERROR("_pcap_entry invalid pipe fd\n");
+            break;
+        }
+
+        if (pcap_loop(_p_pcap, -1, _process_packet, (u_char*)&pipe_fd[1]) == -1) {
+            LOG_ERROR("pcap_loop fail, %s\n", pcap_geterr(_p_pcap));
+            char msg = 's';
+            if (pipe_fd[1] > 0) write(pipe_fd[1], &msg, 1);
+            break;
+        }
+    } while (0);
+
+    LOG_DEBUG("_pcap_entry done\n");
+
+    pthread_exit(NULL);
+    return NULL;
+}
+//////////////////////////////////////////////////////////////////////////////
+void wifi_power_save()
+{
+    wl_set_dtim_interval(_dtim_interval);
+    int suspend_pm = 1;
+    wl_set_get_pm_mode(&suspend_pm, 1);
+    if (net_socket.enable_host_sleep) {
+        int host_sleep = 1;
+        wl_set_get_host_sleep(&host_sleep, 1);
+    }
+}
+
+void wifi_host_sleep()
+{
+      int host_sleep = 1;
+      wl_set_get_host_sleep(&host_sleep, 1);
+}
+
+void wifi_power_normal()
+{
+    if (net_socket.enable_host_sleep) {
+        int sleep = 0;
+        wl_set_get_host_sleep(&sleep, 1);
+    }
+    wl_set_bcn_li_dtim(0);
+    int pm = 2;
+    wl_set_get_pm_mode(&pm, 1);
+}
+int tcp_keep_alive(keep_alive_param_t  *param, int fd_client)
+{
+    char errbuf[PCAP_ERRBUF_SIZE] = {0};
+    pthread_t pcap_loop_thread_id;
+    int ret = -1;
+    int pipe_fd[2] = {-1, -1};
+    int success = 0;
+    do {
+        _interval = param->keepalive_interval;
+        _verbose = param->verbose;
+        _timeout = param->timeout;
+        _mode = KEEPALIVE_TCP;
+        _dtim_interval = param->dtim_interval;
+        _wake_data_len = param->wake_data_len;
+        memcpy(_wake_data,param->wake_data,_wake_data_len);
+
+        if (!param->server_addr) {
+            LOG_ERROR("Invalid argument\n");
+            success = -1;
+            break;
+        }
+
+        _p_pcap = pcap_open_live(DEVICE_INTERFACE, PCAP_CAPTURE_MAX_LEN, 1, 512, errbuf);
+        if (!_p_pcap) {
+            LOG_ERROR("pcap_open_live fail %s\n",errbuf);
+            success = -1;
+            break;
+        }
+
+        char net_filter[64] = {0};
+        struct bpf_program filter;
+        snprintf(net_filter, sizeof(net_filter), TCP_NETWORK_FILTER_FORMAT, param->server_port);
+        if(pcap_compile(_p_pcap, &filter, net_filter, 1, 0)==-1) {
+            LOG_ERROR("pcap_compile failed\n");
+            success = -1;
+            break;
+        }
+        if(pcap_setfilter(_p_pcap, &filter)==-1) {
+            LOG_ERROR("pcap_setfilter failed\n");
+            success = -1;
+            break;
+        }
+
+        if (pipe(pipe_fd) < 0) {
+            success = -1;
+            LOG_ERROR("pipe fail\n");
+            perror("pipe: ");
+            break;
+        }
+
+        ret = pthread_create(&pcap_loop_thread_id, NULL, _pcap_loop_entry, (void*)pipe_fd);
+        if (ret != 0) {
+            LOG_DEBUG("_pcap_loop_entry pthread_create fail\n");
+            success = -1;
+            break;
+        }
+
+        usleep(10*1000);
+        int len = writen(fd_client, (void*)"*", 1);
+        if (len != 1) {
+            LOG_ERROR("Send Msg fail\n");
+            success = -1;
+            pcap_breakloop(_p_pcap);
+            break;
+        }
+        LOG_DEBUG("Send Length[%d] OK\n", len);
+        if (_break_pcap_entry(pipe_fd[0], _timeout) < 0) {
+            LOG_ERROR("_timeout_read_pipe fail\n");
+            success = -1;
+            break;
+        }
+    } while (0);
+
+    if (ret == 0) {
+        pthread_join(pcap_loop_thread_id, NULL);
+    }
+
+    if (_p_pcap) {
+        pcap_close(_p_pcap);
+        _p_pcap = NULL;
+    }
+
+    if (pipe_fd[0] > 0) {
+        close(pipe_fd[0]);
+    }
+    if (pipe_fd[1] > 0) {
+        close(pipe_fd[1]);
+    }
+    return success;
+}
+
+typedef enum {
+    CPU_SUSPEND = 0,
+    CPU_NORMAL = 1,
+    CPU_UNKNOWN = 2,
+} cpu_state;
+
+static int wifi_enter_normal(tcpka_conn_sess_info_t *p_tcp_info, wl_wowl_wakeind_t *wakeind)
+{
+    wl_tcpka_conn_enable(1, 0, 0, 0, 0);
+    wl_tcpka_conn_sess_info(1, p_tcp_info);
+    wl_tcpka_conn_del(1);
+
+    if (net_socket.enable_pattern) {
+        wl_wowl_wakeind(wakeind);
+        wl_wowl_wakeind_clear();
+        wl_wowl_clear();
+        wl_wowl_pattern_clr();
+    }
+
+    LOG_DEBUG("Resume done: ipid[%u], seq_num[%u], ack_num[%u].\n",
+              p_tcp_info->tcpka_sess_ipid,
+              p_tcp_info->tcpka_sess_seq,
+              p_tcp_info->tcpka_sess_ack);
+    return 0;
+}
+
+static void poll_wait_system_state(void)
+{
+#define POLL_TIMEOUT (10000) // 10s
+
+    int ret = -1;
+    int state_fd = -1;
+    cpu_state curr_state = CPU_UNKNOWN;
+    struct pollfd fds;
+
+    state_fd = open(PROC_WIFI_STATE, O_RDWR);
+    if (state_fd < 0) {
+        perror("open" PROC_WIFI_STATE );
+        return;
+    }
+    fds.fd = state_fd;
+    fds.events = POLLIN;
+
+    do {
+        ret = poll(&fds, 1, POLL_TIMEOUT);
+        if(ret == 0) {
+            LOG_DEBUG("Poll Time out\n");
+        } else {
+            ret = read(state_fd, &curr_state, sizeof(curr_state));
+            if (ret < 0) {
+                perror("read\n");
+            } else {
+                LOG_DEBUG("System current state [%d]\n", curr_state);
+                break;
+            }
+        }
+    } while (0);
+
+    close(state_fd);
+    state_fd = -1;
+}
+// the following is not required if we do not want to reuse the keepalive socket
+static int fix_tcp_info(int sock_fd, tcpka_conn_sess_info_t tcp_info)
+{
+    int ret = -1;
+
+    if (sock_fd < 0) {
+        LOG_ERROR("Socket fd [%d] is invalid\n", sock_fd);
+        return -1;
+    }
+
+    LOG_DEBUG("Modify TCP info start\n");
+    ret = ioctl(sock_fd, SET_TCP_FIX, &tcp_info);
+    if (ret < 0) {
+        perror("SET_TCP_FIX");
+    } else {
+        LOG_DEBUG("Modify TCP info done\n");
+    }
+
+    return ret;
+}
+
+int init_wifi_param(int is_poll, char const *iface,int iface_len)
+{
+    if((is_poll != 1 && is_poll != 0) || NULL == iface || iface_len < 1)
+        return -1;
+    net_socket.enable_pattern = 1;
+    net_socket.enable_host_sleep = 1;
+    net_socket.is_poll = is_poll;
+    memset(net_socket.iface, 0, sizeof(net_socket.iface));
+    strncpy(net_socket.iface,iface,iface_len);
+    brcm_ioc_wowl_init(net_socket.iface, WIFI_BCM43340, 0);
+    return 0;
+}
+
+int resume_wifi(int* wake_reason, int tcp_fix)
+{
+    int ret = 0;
+    /* Resume back */
+    if (net_socket.is_poll) {
+        poll_wait_system_state();
+    } else {
+        /*  Wait system state change from respend to resume */
+        sleep(1);
+    }
+    wl_wowl_wakeind_t wakeind= {0};
+    tcpka_conn_sess_info_t tcp_info= {0};
+    if (wifi_enter_normal(&tcp_info, &wakeind) < 0) {
+        ret = -1;
+    } else {
+        if ((wakeind.ucode_wakeind & WL_WOWL_BCN) == WL_WOWL_BCN) {
+            *wake_reason = AP_LOSS_BEACON;
+        } else if((wakeind.ucode_wakeind & WL_WOWL_DIS) == WL_WOWL_DIS) {
+            *wake_reason = AP_DISASSOCIATION_OR_AUTHENTICATION;
+        }else if ((wakeind.ucode_wakeind & WL_WOWL_TCPKEEP_TIME) == WL_WOWL_TCPKEEP_TIME){
+            *wake_reason = TCP_KEEPALIVE_TIMEOUT;
+        }else{
+            *wake_reason = WIFI_WAKE_NORMAL;
+        }
+        if (tcp_fix) {
+            if ((tcp_info.tcpka_sess_ipid > (net_socket.tcp_info_old.tcpka_sess_ipid + 1)) ||
+                (tcp_info.tcpka_sess_seq > (net_socket.tcp_info_old.tcpka_sess_seq + 1)) ||
+                (tcp_info.tcpka_sess_ack > (net_socket.tcp_info_old.tcpka_sess_ack + 1))) {
+                fix_tcp_info(get_fd_to_server(), tcp_info);
+            }
+        }
+    }
+
+    return ret;
+}
+
+#ifdef __cplusplus
+};
+#endif
+
diff --git a/fastboot_app/network_manager/src/wpa_to_ap.c b/fastboot_app/network_manager/src/wpa_to_ap.c
new file mode 100644
index 0000000..f570433
--- /dev/null
+++ b/fastboot_app/network_manager/src/wpa_to_ap.c
@@ -0,0 +1,109 @@
+/*
+ * wpa_to_ap.c
+ *
+ * History:
+ *       2015/12/24 - [jbxing] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include"wpa_to_ap.h"
+#define ITEMS 4
+#define LEN 128
+#define KEY_COUNTS 4
+static void handle_error(const char*error_info)
+{
+    fprintf(stderr,"ERROR! %s\n", error_info);
+    fflush(stderr);
+}
+int parse_cooee_conf(char *ssid, char *password, char *url, char *wpa)
+{
+    int ret = -1;
+    FILE *fp = NULL;
+    do{
+        fp = fopen(COOEE_CONF_PATH,"r");
+        if(NULL == fp)
+        {
+            perror("ERROR! fopen");
+            break;
+        }
+        char buf[LEN] = {0};
+        char keys[KEY_COUNTS][32] = {{"ssid="}, {"password="}, {"url="}, {"wpa="}};
+        char *values[KEY_COUNTS]  = {ssid,password,url,wpa};
+        char *start_p = NULL;
+        char *end_p  = NULL;
+        int index = 0;
+
+        for(;index < sizeof(values)/sizeof(values[0]);index++)
+        {
+            memset(buf, '\0', sizeof(buf));
+            if(fgets(buf,sizeof(buf),fp) != NULL)
+            {
+                if((start_p=strstr(buf,keys[index])) != NULL)
+                {
+                    start_p += strlen(keys[index]);
+                    if((end_p=strchr(start_p,'\n')) != NULL)
+                    {
+                        strncpy(values[index],start_p,end_p-start_p);
+                    }
+                    else
+                    {
+                        handle_error("could not found cooee value end_indicator");
+                        break;
+                    }
+                }
+                else
+                {
+                    handle_error("could not found cooee key");
+                    break;
+                }
+            }
+            else
+            {
+                if(ferror(fp))
+                {
+                    perror("ERROR! fgets");
+                }
+                if(feof(fp))
+                {
+                    char buf[128] = {0};
+                    snprintf(buf,sizeof buf,"the %s has ended",COOEE_CONF_PATH);
+                    handle_error(buf);
+                }
+                break;
+            }
+        }
+        if(index >= sizeof(values)/sizeof(values[0]))
+        {
+            ret = 0;
+        }
+    }while(0);
+    if((NULL != fp) && (0 != fclose(fp)))
+    {
+        perror("");
+        ret = -1;
+    }
+    return ret;
+}
diff --git a/fastboot_app/network_manager/src/wpa_to_ap.h b/fastboot_app/network_manager/src/wpa_to_ap.h
new file mode 100644
index 0000000..ff4e65b
--- /dev/null
+++ b/fastboot_app/network_manager/src/wpa_to_ap.h
@@ -0,0 +1,47 @@
+/*
+ * wpa_to_ap.h
+ *
+ * History:
+ *       2015/06/01 - [jbxing] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef _WPA_TO_AP_H_
+#define _WPA_TO_AP_H_
+#include<stdio.h>
+#include<stdlib.h>
+#include<fcntl.h>
+#include<unistd.h>
+#include<ctype.h>
+#include<string.h>
+
+#define SER_PORT "6024"
+#define MAX_CONNECT_TIME 2
+#define COOEE_CONF_PATH  "/tmp/cooee.conf"
+#define WPA_SUPPLICANT_CONF_PATH "/tmp/config/wpa_supplicant.conf"
+
+int parse_cooee_conf(char *ssid, char *password, char *url, char *wpa);
+#endif
diff --git a/fastboot_app/network_manager/test_net_manager.c b/fastboot_app/network_manager/test_net_manager.c
new file mode 100644
index 0000000..fb696f0
--- /dev/null
+++ b/fastboot_app/network_manager/test_net_manager.c
@@ -0,0 +1,23 @@
+#include <stdio.h>
+#include "bpi_wlan.h"
+#include "bpi_utils.h"
+int main(){
+    keep_alive_param_t param;
+    param.server_addr = "192.168.172.25";
+    param.server_port = 6024;
+    param.keepalive_interval = 30;//seconds
+    param.dtim_interval = 600;//mseconds
+    param.timeout = 10;//seconds
+    param.verbose = 1;
+    param.wake_data_len = snprintf((char*)param.wake_data,sizeof(param.wake_data),"%s","amba_wakeup");
+    int result = -1;
+    LOG_PRINT("wifi standby TCP starts\n");
+    int fd_client = connect_server(param.server_addr, param.server_port, Net_TCP);
+    if (fd_client < 0) {
+        LOG_ERROR("connect to server fail\n");
+        result  = -1;
+        return result;
+    }
+    result = tcp_keep_alive(&param, fd_client);
+    return result;
+}
diff --git a/fastboot_app/stress_test/make.inc b/fastboot_app/stress_test/make.inc
new file mode 100644
index 0000000..5a6c67e
--- /dev/null
+++ b/fastboot_app/stress_test/make.inc
@@ -0,0 +1,162 @@
+#
+# make.inc
+#
+# History:
+#       2016/09/13 - [j Yi] created file
+#
+# Copyright (c) 2016 Ambarella, Inc.
+#
+# This file and its contents ("Software") are protected by intellectual
+# property rights including, without limitation, U.S. and/or foreign
+# copyrights. This Software is also the confidential and proprietary
+# information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+# disclose, distribute, modify, or otherwise prepare derivative works of this
+# Software or any portion thereof except pursuant to a signed license agreement
+# or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+# In the absence of such an agreement, you agree to promptly notify and return
+# this Software to Ambarella, Inc.
+#
+# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+# MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+# IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+#
+
+LOCAL_PATH   := $(call my-dir)
+
+##############################################
+#set_mcu_mode
+##############################################
+include $(CLEAR_VARS)
+
+IPCAM_APP_BIN_DIR	:= $(FAKEROOT_DIR)/usr/bin
+
+LOCAL_TARGET		:= set_mcu_mode
+LOCAL_SRCS  		:= $(LOCAL_PATH)/set_mcu_mode.cpp\
+			$(LOCAL_PATH)/../bpi_app/bpi_mcu_proxy.cpp
+
+LOCAL_CFLAGS		:= -I$(LOCAL_PATH)/../bpi_app\
+			-I$(LOCAL_PATH)/../utils
+LOCAL_CFLAGS		+= -g -std=c++11 -Werror
+
+LOCAL_LDFLAGS		:= -lpthread
+LOCAL_LIBS          := libbpiUtils.so
+
+include $(BUILD_APP)
+
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(IPCAM_APP_BIN_DIR)/
+	@cp -dpRf $< $(IPCAM_APP_BIN_DIR)/
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+
+ifeq ($(CONFIG_BPI_APP_HIBERNATION), y)
+SKIP_STRESS_TEST := yes
+endif
+
+ifeq ($(CONFIG_BSP_BOARD_S3LM_DAREDEVIL), y)
+SKIP_STRESS_TEST := yes
+endif
+
+ifeq ($(SKIP_STRESS_TEST), yes)
+else
+##############################################
+#stress_test
+##############################################
+
+
+include $(CLEAR_VARS)
+
+IPCAM_APP_BIN_DIR	:= $(FAKEROOT_DIR)/usr/bin
+UTILS_DIR		:= $(LOCAL_PATH)/../utils
+AGENT_DIR		:= $(LOCAL_PATH)/../device_agent
+NET_DIR			:= $(LOCAL_PATH)/../network_manager
+APP_DIR		:= $(LOCAL_PATH)/../bpi_app
+
+LOCAL_TARGET		:= stress_test
+LOCAL_SRCS  		:= $(LOCAL_PATH)/stress_test.cpp\
+			$(APP_DIR)/bpi_mcu_proxy.cpp\
+			$(APP_DIR)/bpi_app_config.c\
+			$(APP_DIR)/bpi_uploader.cpp\
+			$(APP_DIR)/bpi_recorder.cpp\
+			$(APP_DIR)/bpi_yuv_rotate.cpp\
+			$(APP_DIR)/cloud_comm.c
+
+LOCAL_CFLAGS		:= -I$(APP_DIR) \
+			-I$(UTILS_DIR) \
+			-I$(AGENT_DIR)/include \
+			-I$(NET_DIR) \
+			-I$(NET_DIR)/cooee \
+			-I$(PREBUILD_3RD_PARTY_DIR)/libcurl/include \
+			-I$(PREBUILD_3RD_PARTY_DIR)/iniparser/include
+
+LOCAL_CFLAGS  		+= -Werror -g -std=c++11
+
+LOCAL_CFLAGS 		+= -I$(ORYX_DIR)/include/utility \
+			-I$(ORYX_DIR)/event/include \
+			-I$(ORYX_DIR)/video/include \
+			-I$(ORYX_DIR)/include/event \
+			-I$(ORYX_DIR)/include/video \
+			-I$(ORYX_DIR)/include/services \
+			-I$(ORYX_DIR)/include/services/commands \
+			-I$(ORYX_DIR)/include/ipc        \
+			-I$(ORYX_DIR)/include/utility/jpeg_encoder \
+			-I$(ORYX_DIR)/include \
+			-I$(ORYX_DIR)/include/configure
+
+LOCAL_LDFLAGS		:= -lpthread \
+			-L$(AGENT_DIR)/deps/lib -lev -lm\
+			-L$(PREBUILD_3RD_PARTY_DIR)/libpcap/usr/lib -lpcap \
+			-L$(PREBUILD_3RD_PARTY_DIR)/json-c/usr/lib -ljson-c \
+			-L$(PREBUILD_3RD_PARTY_DIR)/libcurl/usr/lib -lcurl \
+			-L$(PREBUILD_3RD_PARTY_DIR)/iniparser/usr/lib -liniparser \
+			-Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/zlib/usr/lib \
+			-Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/openssl/usr/lib \
+			-Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/libidn/usr/lib \
+			-Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/libssh2/usr/lib  \
+			-Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/libjpeg-turbo/usr/lib \
+			-Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/libnl/usr/lib \
+			-Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/dbus/usr/lib \
+			-Wl,-rpath-link=$(FAKEROOT_DIR)/usr/lib
+
+ifeq ($(CONFIG_AMBARELLA_ALSA_SUPPORT), y)
+LOCAL_LDFLAGS		+= -L$(PREBUILD_3RD_PARTY_DIR)/alsa-lib/usr/lib -lasound
+endif
+
+ifeq ($(CONFIG_BSP_BOARD_S3LM_ELEKTRA), y)
+LOCAL_CFLAGS  += -DELEKTRA_S
+endif
+
+LOCAL_LIBS := libbpiUtils.so libbpiNetManager.so \
+			libdevice_agent.a libamvideo-reader.so libamvideo-address.so \
+			libamutil.so libamosal.so libamjpeg-encoder.so libamapi.so libamipc.so \
+			libammedia-data-struct.so libamconfig.so
+
+include $(BUILD_APP)
+
+LOCAL_SCRIPT	:= $(wildcard $(LOCAL_PATH)/*.sh)
+
+.PHONY: $(LOCAL_TARGET)
+$(LOCAL_TARGET): bpi_app
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(IPCAM_APP_BIN_DIR)/
+	@cp -dpRf $< $(IPCAM_APP_BIN_DIR)/
+	@mkdir -p  $(FAKEROOT_DIR)/usr/local/bin/
+	@cp -dpRf $(LOCAL_SCRIPT) $(FAKEROOT_DIR)/usr/local/bin/
+	@chmod +x $(FAKEROOT_DIR)/usr/local/bin/*.sh
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+endif
diff --git a/fastboot_app/stress_test/set_mcu_mode.cpp b/fastboot_app/stress_test/set_mcu_mode.cpp
new file mode 100644
index 0000000..0679e32
--- /dev/null
+++ b/fastboot_app/stress_test/set_mcu_mode.cpp
@@ -0,0 +1,84 @@
+/*
+ * set_mcu_mode.cpp
+ *
+ * History:
+ *       2016/09/13 - [j Yi] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <stdio.h>
+#include "bpi_typedefs.h"
+#include "bpi_utils.h"
+#include "bpi_mcu_proxy.h"
+
+static int is_number(void *arg)
+{
+    char *p = (char*)arg;
+    //assume *arg is not NULL
+    while(*p != '\0'){
+        if(*p < '0' || *p > '9')
+            return 0;
+        p++;
+    }
+    return 1;
+}
+
+int main(int argc, char *argv[])
+{
+    BPIMcuProxy mcu_proxy;
+    MCU_CMD_TYPE mcu_cmd = MCU_CMD_SET_STRESS_TEST_MODE;
+    int info_print = 0;
+    do{
+        if(argc != 2 || !is_number(argv[1])){
+            info_print = 1;
+            break;
+        }
+
+        if(atoi(argv[1]) == 1){
+            mcu_cmd = MCU_CMD_SET_STRESS_TEST_MODE;
+        }
+        else if(atoi(argv[1]) == 0){
+            mcu_cmd = MCU_CMD_SET_NORMAL_MODE;
+        }
+        else{
+            info_print = 1;
+            break;
+        }
+
+        if(!mcu_proxy.init()){
+            break;
+        }
+        mcu_proxy.send_cmd(mcu_cmd);
+        LOG_PRINT("set mode done\n");
+    }while(0);
+
+    if(info_print){
+        LOG_PRINT("set mcu mode: parameters wrong\n");
+        LOG_PRINT("Usgae:\n");
+        LOG_PRINT("\t[0] normal mode. [1] stress test mode\n");
+    }
+    return 0;
+}
\ No newline at end of file
diff --git a/fastboot_app/stress_test/stress_test.cpp b/fastboot_app/stress_test/stress_test.cpp
new file mode 100644
index 0000000..470b019
--- /dev/null
+++ b/fastboot_app/stress_test/stress_test.cpp
@@ -0,0 +1,462 @@
+/*
+ * stress_test.cpp
+ *
+ * History:
+ *       2016/09/13 - [j Yi] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <string.h>
+#include <signal.h>
+#include <thread>
+
+#include "bpi_typedefs.h"
+#include "bpi_app_config.h"
+#include "bpi_utils.h"
+#include "device.h"
+#include "bpi_wlan.h"
+#include "cloud_comm.h"
+#include "bpi_utils.h"
+#include "am_api_helper.h"
+#include "bpi_mcu_proxy.h"
+#include "bpi_recorder.h"
+#include "bpi_uploader.h"
+
+int pipe_fd[2] = {-1};
+fd_set fds;
+BPIMcuProxy mcu_proxy;
+
+bool stop_sig = false;
+bool ready_to_quit = true;
+const char *path = "/tmp/stress-test/";
+
+static void wait_sigstop()
+{
+    fd_set read_fd;
+    while(stop_sig){
+        char buf[1] = {0};
+        read_fd = fds;
+        int val = select(pipe_fd[1], &read_fd, NULL, NULL, NULL);
+        LOG_PRINT("select result is: %d\n", val);
+        if(val == 1 && FD_ISSET(pipe_fd[0], &read_fd)){
+            read(pipe_fd[0], buf, sizeof(buf));
+            if(buf[0] == 'q'){
+                LOG_PRINT("caught stop signal\n");
+                ready_to_quit = false;
+                break;
+            }
+        }
+        if(val < 0){
+            perror("select");
+        }
+    }
+}
+
+static int make_dir(const char *path)
+{
+    struct stat file_stat;
+    int ret;
+    ret = stat(path, &file_stat);
+    if(ret < 0){
+        if(errno == ENOENT){
+            ret = mkdir(path, 0755);
+            if(ret < 0){
+                LOG_PRINT("create directory failed\n");
+                return -1;
+            }
+        }
+        else{
+            LOG_PRINT("file path wrong\n");
+            return -1;
+        }
+    }
+
+    return 0;
+}
+static int wifi_test(void)
+{
+    int loop_total = 0;
+    int loop_count = 0;
+    int keepalive_interval = 1;
+    app_conf_t app_config = {0};
+
+    LOG_PRINT("Enter keepalive interval: ");
+    int n = scanf("%d", &keepalive_interval);
+    if(n != 1 || keepalive_interval < 1){
+        LOG_PRINT("wrong parameter.\n");
+        ready_to_quit = false;
+        return -1;
+    }
+
+    LOG_PRINT("Enter test times, -1 represents endless suspend-and-resume: ");
+    n = scanf("%d", &loop_total);
+    if(n != 1 || loop_total < -1){
+        LOG_PRINT("wrong parameter.\n");
+        ready_to_quit = false;
+        return -1;
+    }
+
+    if(load_app_conf(&app_config) < 0){
+        LOG_ERROR("load app config failed\n");
+        return -1;
+    }
+
+    if(connect_ap(app_config.ap_ssid,app_config.ap_password,app_config.ap_wpa)==EWlan_Connected){
+        LOG_DEBUG("Connect AP: OK\n");
+    }else{
+        LOG_ERROR("Connect AP: FAIL\n");
+        ready_to_quit = false;
+        return -1;
+    }
+
+    if (connect_server(app_config.cloud_server_ip, CONF_CLOUD_DEV_PORT, Net_TCP) < 0){
+        LOG_PRINT("connect to server: failed\n");
+        ready_to_quit = false;
+        return -1;
+    }
+
+    int wakeReason = 0;
+    memset(&app_config, 0, sizeof(app_config));
+    app_config.dtim_interval = 600;
+    app_config.keepalive_interval = keepalive_interval;
+    strcpy(app_config.wakeup_token, "amba_wakeup");
+    mcu_proxy.send_cmd(MCU_CMD_LED_GREEN_ON);
+    for(loop_count = 0; loop_count != loop_total; loop_count++){
+        LOG_PRINT("############################START AGAIN############################\n");
+        LOG_PRINT("This is No.%d\n", loop_count);
+        if(wlan_keepalive(app_config.keepalive_interval, app_config.dtim_interval, app_config.wakeup_token, app_config.cloud_server_ip) < 0){
+            LOG_PRINT("keep alive failed\n");
+            ready_to_quit = false;
+            return -1;
+        }
+        usleep(500000);
+        system("echo mem > /sys/power/state");
+
+        if(resume_wifi(&wakeReason, 1) == -1){
+            LOG_PRINT("resume wifi failed\n");
+            ready_to_quit = false;
+            return -1;
+        }else{
+            LOG_PRINT("resume wifi done, now you can use ctrl+C to kill the program in the following seconds.\n");
+        }
+        mcu_proxy.send_cmd(MCU_CMD_LED_GREEN_ON);
+        usleep(500000);
+        wait_sigstop();
+        if(!ready_to_quit){
+            LOG_PRINT("stop test loop\n");
+            break;
+        }
+    }
+    ready_to_quit = false;
+    return 0;
+}
+
+static int normal_test(void)
+{
+    int loop_total = 0;
+    int loop_count = 0;
+
+
+    LOG_PRINT("Enter test times, -1 represents endless suspend-and-resume: ");
+    int n = scanf("%d", &loop_total);
+    if(n != 1 || loop_total < -1){
+        LOG_PRINT("wrong parameter.\n");
+        ready_to_quit = false;
+        return -1;
+    }
+    mcu_proxy.send_cmd(MCU_CMD_LED_GREEN_ON);
+    for(loop_count = 0; loop_count != loop_total; loop_count++){
+        LOG_PRINT("############################START AGAIN############################\n");
+        LOG_PRINT("This is No.%d\n", loop_count);
+        usleep(500000);
+        system("echo mem > /sys/power/state");
+        mcu_proxy.send_cmd(MCU_CMD_LED_GREEN_ON);
+        usleep(500000);
+        wait_sigstop();
+        if(!ready_to_quit){
+            LOG_PRINT("stop test loop\n");
+            break;
+        }
+    }
+    ready_to_quit = false;
+    return 0;
+}
+
+static void run_SR_iav(char *cmd)
+{
+    LOG_PRINT("cmd_out is %s\n", cmd);
+    system(cmd);
+    ready_to_quit = false;
+}
+
+static int iav_test(void)
+{
+    int cmd_in = 0;
+    char *encode_type = NULL;
+    int loop_total = 0;
+    char cmd_out[100] = {0};
+
+    LOG_PRINT("choose encode type [1] h264, [2] h265: ");
+    int n = scanf("%d", &cmd_in);
+    if(n == 1 && cmd_in == 1){
+        encode_type = (char*)"h264";
+    }
+    else if(n == 1 && cmd_in == 2){
+        encode_type = (char*)"h265";
+    }
+    else{
+        LOG_PRINT("wrong parameter.\n");
+        ready_to_quit = false;
+        return -1;
+    }
+    LOG_PRINT("Enter test times, -1 represents endless suspend-and-resume: ");
+    n = scanf("%d", &loop_total);
+    if(n != 1 || loop_total < -1){
+        LOG_PRINT("wrong parameter.\n");
+        ready_to_quit = false;
+        return -1;
+    }
+
+    if(make_dir(path) != 0){
+        LOG_PRINT("path error\n");
+        ready_to_quit = false;
+        return -1;
+    }
+
+    sprintf(cmd_out, "test_SR_iav.sh %s %s %s %d %s", "init", encode_type, "loop", loop_total, "rm");
+    LOG_PRINT("cmd_out is %s\n", cmd_out);
+    mcu_proxy.send_cmd(MCU_CMD_LED_GREEN_ON);
+    std::thread (run_SR_iav, cmd_out).detach();
+    while(ready_to_quit){
+        mcu_proxy.send_cmd(MCU_CMD_LED_GREEN_ON);
+        wait_sigstop();
+        usleep(500000);
+    }
+    ready_to_quit = false;
+    return 0;
+}
+
+static int oryx_recording_test(void)
+{
+    //init recorder
+    BPIRecorder bpi_recorder;
+    BPIUploader bpi_uploader;
+    app_conf_t g_app_config = {0};
+
+    int loop_total = 0;
+    int loop_count = 0;
+    int rec_interval = 1;
+    char rm_cmd[128];
+
+    LOG_PRINT("Enter recording interval: ");
+    int n = scanf("%d", &rec_interval);
+    if(n != 1 || rec_interval < 1){
+        LOG_PRINT("wrong parameter.\n");
+        ready_to_quit = false;
+        return -1;
+    }
+    LOG_PRINT("Enter test times, -1 represents endless suspend-and-resume: ");
+    n = scanf("%d", &loop_total);
+    if(n != 1 || loop_total < -1){
+        LOG_PRINT("wrong parameter.\n");
+        ready_to_quit = false;
+        return -1;
+    }
+
+    if(make_dir(path) != 0){
+        LOG_PRINT("path error\n");
+        ready_to_quit = false;
+        return -1;
+    }
+    sprintf(rm_cmd, "rm -R %s*", path);
+
+    if(load_app_conf(&g_app_config) < 0){
+        LOG_ERROR("load app config failed\n");
+        return -1;
+    }
+    g_app_config.record_duration_after_motion_starts = rec_interval;
+    g_app_config.file_duration = rec_interval;
+    g_app_config.video0_enable = true;
+    g_app_config.video1_enable = false;
+    strcpy(g_app_config.storage_folder, path);
+
+    if(g_app_config.video0_enable){
+        BPIStreamConfig stream_config;
+        memset(&stream_config, 0, sizeof(stream_config));
+        stream_config.video_config.enable = true;
+        stream_config.video_config.codec_type = g_app_config.video0_fmt;
+        stream_config.video_config.rotation_type = g_app_config.rotate;
+        stream_config.video_config.width = g_app_config.video0_width;
+        stream_config.video_config.height = g_app_config.video0_height;
+        stream_config.video_config.frame_rate = g_app_config.video0_frame_rate;
+        stream_config.video_config.bitrate = g_app_config.video0_recording_bitrate;
+        stream_config.video_config.enable_two_ref = g_app_config.enable_two_ref;
+        stream_config.video_config.enable_lbr = g_app_config.smart_avc;
+        stream_config.video_config.enable_thumbnail = g_app_config.thumbnail;
+        stream_config.video_config.enable_ldc = g_app_config.enable_ldc;
+        strcpy(stream_config.video_config.osd_label, g_app_config.osd_label);
+        if(g_app_config.audio_enable){
+            stream_config.audio_config.enable = true;
+            stream_config.audio_config.codec_type = g_app_config.audio_fmt;
+        }
+        stream_config.file_muxer_config.file_muxer_type = g_app_config.file_fmt;
+        stream_config.file_muxer_config.file_duration = g_app_config.file_duration;
+        stream_config.file_muxer_config.recording_duration = g_app_config.record_duration_after_motion_starts;
+        stream_config.file_muxer_config.file_num = (g_app_config.record_duration_after_motion_starts - 1 + g_app_config.file_duration) / g_app_config.file_duration;
+        strcpy(stream_config.file_muxer_config.storage_location, g_app_config.storage_folder);
+        strcpy(stream_config.file_muxer_config.pre_fix, g_app_config.file_name_prefix);
+        if(!bpi_recorder.set_config(0, &stream_config)){
+            LOG_ERROR("bpi recorder set config failed!");
+            return false;
+        }
+    }
+
+    if(!bpi_recorder.init_engine()){
+        LOG_ERROR("bpi recorder init failed!");
+        ready_to_quit = false;
+        return -1;
+    }
+    bpi_recorder.set_data_handler(&bpi_uploader);
+    mcu_proxy.send_cmd(MCU_CMD_LED_GREEN_ON);
+    //do test loop
+    for(loop_count = 0; loop_count != loop_total; loop_count++){
+        LOG_PRINT("############################START AGAIN############################\n");
+        LOG_PRINT("This is No.%d\n", loop_count);
+        bpi_recorder.enable_file_muxer();
+        bpi_recorder.start_engine();
+        sleep(rec_interval);
+        bpi_recorder.stop_engine();
+        usleep(500000);
+        system("echo mem > /sys/power/state");
+        mcu_proxy.send_cmd(MCU_CMD_LED_GREEN_ON);
+        usleep(500000);
+        system(rm_cmd);
+        wait_sigstop();
+        if(!ready_to_quit){
+            LOG_PRINT("stop test loop\n");
+            break;
+        }
+    }
+
+    //exit
+    ready_to_quit = false;
+    return 0;
+}
+
+static void sigstop(int signum)
+{
+    LOG_PRINT("send stop signal\n");
+    stop_sig = true;
+}
+
+int main(int argc, char *argv[])
+{
+    int cmd_in = 0;
+    std::thread m_thread;
+    pipe(pipe_fd);
+    FD_ZERO(&fds);
+    FD_SET(pipe_fd[0], &fds);
+
+    LOG_PRINT("Choose mode: [1]normal linux suspend-and-resume\n");
+    LOG_PRINT("             [2]test suspend-and-resume with keep-alive releted\n");
+    LOG_PRINT("             [3]test suspend-and-resume with h264/h265 encoder running\n");
+    LOG_PRINT("             [4]test suspend-and-resume with recording mp4\n");
+    LOG_PRINT("Choose from [1/2/3/4]: ");
+    int n = scanf("%d", &cmd_in);
+    if((n != 1) || (cmd_in < 1 || cmd_in > 4)){
+        LOG_PRINT("wrong parameter.\n");
+        return 0;
+    }
+
+    bool init_val = mcu_proxy.init();
+    if(!init_val){
+        return -1;
+    }
+    //start
+    mcu_proxy.send_cmd(MCU_CMD_SET_STRESS_TEST_MODE);
+
+    signal(SIGINT, sigstop);
+    signal(SIGQUIT, sigstop);
+    signal(SIGTERM, sigstop);
+    //4 cases
+    switch(cmd_in){
+    //1.normal
+        case 1:
+            LOG_PRINT("normal linux suspend-and-resume\n");
+            m_thread = thread(normal_test);
+            break;
+    //2.wifi
+        case 2:
+            LOG_PRINT("test suspend-and-resume with keep-alive related\n");
+            m_thread = thread(wifi_test);
+            break;
+    //3.iav
+        case 3:
+            LOG_PRINT("test suspend-and-resume with h264/h265 encoder running\n");
+            m_thread = thread(iav_test);
+            break;
+    //4.oryx
+        case 4:
+            LOG_PRINT("test suspend-and-resume with recording mp4\n");
+            m_thread = thread(oryx_recording_test);
+            break;
+        default:
+            break;
+    }
+
+    while(ready_to_quit){
+        int n = 0;
+        if(stop_sig){
+            n = write(pipe_fd[1], "q", 1);
+        }
+        if(n == 1){
+            LOG_PRINT("write q to pipe\n");
+            break;
+        }
+        usleep(200000);
+    }
+
+    if(m_thread.joinable()){
+        m_thread.join();
+    }
+
+    mcu_proxy.send_cmd(MCU_CMD_LED_RED_ON);
+    do{
+        LOG_PRINT("change mcu mode to normal\n");
+        mcu_proxy.send_cmd(MCU_CMD_SET_NORMAL_MODE);
+    }while(0);
+    LOG_PRINT("exit\n");
+
+    return 0;
+}
diff --git a/fastboot_app/utils/adc/adc_util.c b/fastboot_app/utils/adc/adc_util.c
new file mode 100644
index 0000000..ef0625c
--- /dev/null
+++ b/fastboot_app/utils/adc/adc_util.c
@@ -0,0 +1,421 @@
+/**
+ * app/ipcam/fastboot_app/utils/adc_util.c
+ *
+ * Author: Caizhang Lin <czlin@ambarella.com>
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ( "Software" ) are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sys/ioctl.h>
+
+#include "config.h"
+#include "adc.h"
+#include "adc_util.h"
+#include "upgrade_partition.h"
+#include "upgrade_part_adc.h"
+
+#define UPDATED_ADC_IMAGE_PATH	"/tmp/updated_adc.bin"
+
+static int find_mtd_device_path(const char *dev_name, char *dev_info_buf,
+                                int dev_info_bufsize)
+{
+    FILE *stream = 0;
+    int device_index = -1;
+
+    if (!dev_name || !dev_info_buf || 0 == dev_info_bufsize) {
+        printf("Find mtd device path, NULL input\n");
+        return -1;
+    }
+    memset(dev_info_buf, 0, dev_info_bufsize);
+
+    //get mtd device index and path
+    sprintf(dev_info_buf, "cat /proc/mtd | grep %s | cut -d':' -f1 | cut -d'd' -f2", dev_name);
+    stream = popen(dev_info_buf , "r" );
+    if (NULL == stream) {
+        printf("Open /proc/mtd  %s  failed.\n", dev_name);
+        return -1;
+    }
+    fscanf(stream,"%d", &device_index);
+    pclose(stream);
+
+    if (device_index < 0) {
+        printf("Not found %s partition on /proc/mtd\n", dev_name);
+        return -1;
+    }
+    memset(dev_info_buf, 0, dev_info_bufsize);
+    sprintf(dev_info_buf, "/dev/mtd%d", device_index);
+
+    return 0;
+}
+
+static int load_adc_to_mem (unsigned int *adc_img_len,
+                            unsigned int *adc_img_aligned_len, void **pp_adc_aligned_mem)
+{
+    char dev_info_buf[128];
+    int ret = 0, count = 0;
+    int ptb_fd = 0;
+    unsigned int ptb_offset;
+    unsigned char *ptb_buf = NULL;
+    struct mtd_info_user ptb_meminfo;
+    loff_t ptb_bad_offset;
+    flpart_table_t *table;
+    unsigned long long blockstart = 1;
+    int fd = 0, bs, badblock = 0;
+    struct mtd_info_user meminfo;
+    unsigned long ofs;
+    void *p_adc_mem_cur = NULL;
+
+    if (!adc_img_len || !adc_img_aligned_len || !pp_adc_aligned_mem) {
+        printf("Load ADC to mem, NULL input\n");
+        ret = -1;
+        goto closeall;
+    }
+
+    ret = find_mtd_device_path("ptb", dev_info_buf, sizeof(dev_info_buf));
+    if (ret < 0) {
+        printf("Find ptb partition failed\n");
+        ret = -1;
+        goto closeall;
+    }
+
+    /* Open the PTB device */
+    if ((ptb_fd = open(dev_info_buf, O_RDONLY)) == -1) {
+        perror("open PTB");
+        ret = -1;
+        goto closeall;
+    }
+
+    /* Fill in MTD device capability structure */
+    if ((ret = ioctl(ptb_fd, MEMGETINFO, &ptb_meminfo)) != 0) {
+        perror("PTB MEMGETINFO");
+        ret = -1;
+        goto closeall;
+    }
+
+    for (ptb_offset = 0; ptb_offset < ptb_meminfo.size; ptb_offset += ptb_meminfo.erasesize) {
+        ptb_bad_offset = ptb_offset;
+        if ((ret = ioctl(ptb_fd, MEMGETBADBLOCK, &ptb_bad_offset)) < 0) {
+            perror("ioctl(MEMGETBADBLOCK)");
+            goto closeall;
+        }
+
+        if (ret == 0) {
+            break;
+        }
+    }
+    if (ptb_offset >= ptb_meminfo.size) {
+        printf("Can not find good block in PTB.\n");
+        ret = -1;
+        goto closeall;
+    }
+
+    ptb_buf = (unsigned char*)malloc(ptb_meminfo.erasesize);
+    memset(ptb_buf, 0, ptb_meminfo.erasesize);
+
+    /* Read partition table.
+    * Note: we need to read and save the entire block data, because the
+    * entire block will be erased when write partition table back to flash.
+    * BTW, flpart_meta_t is located in the same block as flpart_table_t
+    */
+    count = ptb_meminfo.erasesize;
+    if (pread(ptb_fd, ptb_buf, count, ptb_offset) != count) {
+        perror("pread PTB");
+        ret = -1;
+        goto closeall;
+    }
+
+    table = PTB_TABLE(ptb_buf);
+    *adc_img_len = table->part[PART_ADC].img_len;
+
+    ret = find_mtd_device_path("adc", dev_info_buf, sizeof(dev_info_buf));
+    if (ret < 0) {
+        printf("Find ADC partition failed\n");
+        ret = -1;
+        goto closeall;
+    }
+
+    /* Open ADC device */
+    if ((fd = open(dev_info_buf, O_RDONLY)) == -1) {
+        perror("open mtd");
+        ret = -1;
+        goto closeall;
+    }
+
+    /* Fill in MTD device capability structure */
+    if (ioctl(fd, MEMGETINFO, &meminfo) != 0) {
+        perror("MEMGETINFO");
+        ret = -1;
+        goto closeall;
+    }
+
+    bs = meminfo.writesize;
+    *adc_img_aligned_len = ((*adc_img_len)+(bs-1))&(~(bs-1));
+
+
+    printf("ADC img addr=%u, img len=%u, img aligned_len=%u\n",
+        table->part[PART_ADC].mem_addr, *adc_img_len, *adc_img_aligned_len);
+
+
+    //will be freed when process return
+    *pp_adc_aligned_mem = (void*)malloc(*adc_img_aligned_len);
+    if (!(*pp_adc_aligned_mem)) {
+        printf("Can not malloc memory for load ADC partiton!\n");
+        ret = -1;
+        goto closeall;
+    }
+    p_adc_mem_cur = *pp_adc_aligned_mem;
+
+    /* Load the flash contents */
+    for (ofs = 0; ofs < *adc_img_aligned_len ; ofs+=bs) {
+        // new eraseblock , check for bad block
+        if (blockstart != (ofs & (~meminfo.erasesize + 1))) {
+            blockstart = ofs & (~meminfo.erasesize + 1);
+            if ((badblock = ioctl(fd, MEMGETBADBLOCK, &blockstart)) < 0) {
+                perror("ioctl(MEMGETBADBLOCK)");
+                ret = -1;
+                goto closeall;
+            }
+        }
+
+        if (badblock) {
+            //memset (p_adc_mem_cur, 0xff, bs);
+            continue;
+        } else {
+            /* Read page data and exit on failure */
+            if (pread(fd, p_adc_mem_cur, bs, ofs) != bs) {
+                perror("pread");
+                ret = -1;
+                goto closeall;
+            }
+        }
+        p_adc_mem_cur= (char*)p_adc_mem_cur + bs;
+    }
+
+    /* Exit happy */
+    ret = 0;
+
+closeall:
+    if (ptb_buf) {
+        free(ptb_buf);
+        ptb_buf  = NULL;
+    }
+
+    if (ptb_fd) {
+        close(ptb_fd);
+        ptb_fd = 0;
+    }
+    if (fd) {
+        close(fd);
+        fd = 0;
+    }
+
+    return ret;
+}
+
+static int update_adc_partition()
+{
+    char cmd[256];
+    FILE   *stream = 0;
+    int device_index = -1;
+
+    memset(cmd, 0, sizeof(cmd));
+
+    stream = popen( "cat /proc/mtd | grep adc | cut -d':' -f1 | cut -d'd' -f2", "r" );
+    if (NULL == stream) {
+        printf("Open /proc/mtd failed\n");
+        return -1;
+    }
+    fscanf(stream, "%d", &device_index);
+    pclose(stream);
+    if (device_index < 0) {
+        printf("Not found ADC partition on /proc/mtd\n");
+        return -1;
+    }
+    //erase nand flash before re-write
+    sprintf(cmd, "flash_eraseall /dev/mtd%d", device_index);
+
+    system(cmd);
+    if (upgrade_partition(device_index, UPDATED_ADC_IMAGE_PATH) != 0) {
+        printf("upgrade_partition fail\n");
+        return -1;
+    }
+
+    return 0;
+}
+
+/************************************************
+* external functions of adc_util
+*************************************************/
+static unsigned int adc_img_len_s = 0;   // Lengh of image in the partition
+static unsigned int adc_img_aligned_len_s = 0;  //aligned to page size of adc parttiton
+static void* p_adc_aligned_mem_s = NULL;   //aligned to page size of adc parttiton
+struct adcfw_header * hdr_s = NULL;
+
+// load adc to mem, return mem addr
+static int  adc_util_init()
+{
+    int rval = 0;
+    do {
+        rval = load_adc_to_mem (&adc_img_len_s, &adc_img_aligned_len_s, &p_adc_aligned_mem_s);
+        if (rval < 0) {
+            printf("Load ADC to memory failed\n");
+            break;
+        }
+
+        hdr_s = (struct adcfw_header *)p_adc_aligned_mem_s;
+        if (hdr_s->magic != ADCFW_IMG_MAGIC || hdr_s->fw_size != adc_img_len_s) {
+            printf("Invalid ADC partition, magic=%u(should be %u), fw_size=%u(should be %u)\n",
+                hdr_s->magic, ADCFW_IMG_MAGIC, hdr_s->fw_size, adc_img_len_s);
+            rval = -1;
+            break;
+        }
+    } while (0);
+    return rval;
+}
+
+static void  adc_util_finish()
+{
+    if (p_adc_aligned_mem_s) {
+        free(p_adc_aligned_mem_s);
+        p_adc_aligned_mem_s  = NULL;
+    }
+    hdr_s= NULL;
+}
+
+int adc_util_update(struct amboot_params* params)
+{
+    int rval = -1;
+    rval = adc_util_init();
+    if (rval != 0){
+        printf("adc_util_init failed!\n");
+        return -1;
+    }
+    FILE *f_updated_adc = NULL;
+
+    if (NULL == hdr_s) {
+        printf("adc_util not initialized!\n");
+        return -1;
+    }
+
+    do {
+        memcpy(&(hdr_s->params_in_amboot), params, sizeof(hdr_s->params_in_amboot));
+        f_updated_adc = fopen(UPDATED_ADC_IMAGE_PATH, "wb");
+        if (f_updated_adc == NULL) {
+            printf("Open /tmp/updated_adc.bin failed\n");
+            rval = -EINVAL;
+            break;
+        }
+
+        unsigned int length = fwrite(p_adc_aligned_mem_s, 1, adc_img_aligned_len_s, f_updated_adc);
+        if (length != adc_img_aligned_len_s) {
+            printf("/tmp/updated_adc.bin size [%d] is wrong, should be %u\n", length, adc_img_aligned_len_s);
+            rval = -1;
+            break;
+        }
+
+        fclose(f_updated_adc);
+        f_updated_adc = NULL;
+
+        rval = update_adc_partition();
+        if (rval != 0) {
+            printf("update_adc_partition fail\n");
+            break;
+        }
+        rval = 0;
+    } while (0);
+
+    if (f_updated_adc) {
+        fclose(f_updated_adc);
+        f_updated_adc = NULL;
+    }
+    adc_util_finish();
+    return rval;
+}
+
+int adc_util_dump()
+{
+    int rval = -1;
+    rval = adc_util_init();
+    if (rval != 0){
+        printf("adc_util_init failed!\n");
+        return -1;
+    }
+
+    if (NULL == hdr_s) {
+        printf("adc_util not initialized!\n");
+        return -1;
+    }
+
+    do {
+        printf("adc_util_dump\n");
+        printf("params_in_amboot.enable_audio = %d\n", hdr_s->params_in_amboot.enable_audio);
+        printf("params_in_amboot.enable_ldc = %d\n", hdr_s->params_in_amboot.enable_ldc);
+        printf("params_in_amboot.rotation_mode = %d\n", hdr_s->params_in_amboot.rotation_mode);
+        printf("params_in_amboot.stream0_enable = %d\n", hdr_s->params_in_amboot.stream0_enable);
+
+        if (1 == hdr_s->params_in_amboot.stream0_resolution) {
+            printf("params_in_amboot.stream0_resolution = %d/720p\n", hdr_s->params_in_amboot.stream0_resolution);
+        }
+        else if(0 == hdr_s->params_in_amboot.stream0_resolution) {
+            printf("params_in_amboot.stream0_resolution = %d/1080p\n", hdr_s->params_in_amboot.stream0_resolution);
+        }
+        else {
+            printf("invalid params_in_amboot.stream0_resolution\n");
+        }
+
+        if (1 == hdr_s->params_in_amboot.stream0_fmt) {
+            printf("params_in_amboot.stream0_fmt = %d/h264\n", hdr_s->params_in_amboot.stream0_fmt);
+        } else {
+            printf("invalid params_in_amboot.stream0_fmt\n");
+        }
+
+        printf("params_in_amboot.stream0_fps = %d\n", hdr_s->params_in_amboot.stream0_fps);
+        printf("params_in_amboot.stream0_bitrate = %d\n", hdr_s->params_in_amboot.stream0_bitrate);
+        printf("params_in_amboot.stream1_enable = %d\n", hdr_s->params_in_amboot.stream1_enable);
+
+        if (2 == hdr_s->params_in_amboot.stream1_resolution) {
+            printf("params_in_amboot.stream1_resolution = %d/480p\n", hdr_s->params_in_amboot.stream1_resolution);
+        } else {
+            printf("invalid params_in_amboot.stream1_resolution\n");
+        }
+
+        if (1 == hdr_s->params_in_amboot.stream1_fmt) {
+            printf("params_in_amboot.stream1_fmt = %d/h264\n", hdr_s->params_in_amboot.stream1_fmt);
+        } else {
+            printf("invalid params_in_amboot.stream1_fmt\n");
+        }
+
+        printf("params_in_amboot.stream1_fps = %d\n", hdr_s->params_in_amboot.stream1_fps);
+        printf("params_in_amboot.stream1_bitrate = %d\n", hdr_s->params_in_amboot.stream1_bitrate);
+        printf("params_in_amboot.fastosd_string = %s\n", hdr_s->params_in_amboot.fastosd_string);
+        printf("params_in_amboot.enable_vca = %d\n", hdr_s->params_in_amboot.enable_vca);
+        printf("params_in_amboot.vca_frame_num = %d\n", hdr_s->params_in_amboot.vca_frame_num);
+    } while (0);
+    adc_util_finish();
+    return rval;
+}
diff --git a/fastboot_app/utils/adc/adc_util.h b/fastboot_app/utils/adc/adc_util.h
new file mode 100644
index 0000000..27d2029
--- /dev/null
+++ b/fastboot_app/utils/adc/adc_util.h
@@ -0,0 +1,69 @@
+/**
+ * app/ipcam/fastboot_smart3a/adc_util.h
+ *
+ * Author: Caizhang Lin <czlin@ambarella.com>
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ( "Software" ) are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef   _ADC_UTIL_H
+#define   _ADC_UTIL_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+// this struct should be identical to that in amboot/include/adc.h
+struct amboot_params{ /* (4 * 1) + (5 * 4) + (5 * 4) + 32 + 2 + 18= 96 */
+    unsigned char enable_audio;
+    unsigned char enable_fastosd;
+    unsigned char enable_ldc;
+    unsigned char rotation_mode;
+
+    unsigned int stream0_enable;
+    unsigned int stream0_resolution;
+    unsigned int stream0_fmt;
+    unsigned int stream0_fps;
+    unsigned int stream0_bitrate;
+
+    unsigned int stream1_enable;
+    unsigned int stream1_resolution;
+    unsigned int stream1_fmt;
+    unsigned int stream1_fps;
+    unsigned int stream1_bitrate;
+
+    char fastosd_string[32];
+    unsigned char enable_vca;
+    unsigned char vca_frame_num;
+    unsigned char reserved[18];
+}__attribute__((packed));
+/* function: update amboot parameters in ADC partition
+**
+*/
+int adc_util_update(struct amboot_params* params);
+int adc_util_dump();
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/fastboot_app/utils/adc/upgrade_part_adc.c b/fastboot_app/utils/adc/upgrade_part_adc.c
new file mode 100644
index 0000000..382308e
--- /dev/null
+++ b/fastboot_app/utils/adc/upgrade_part_adc.c
@@ -0,0 +1,456 @@
+/**
+ * upgrade_partition.c
+ *
+ * History:
+ *    2015/03/30 - [jbxing] created file which is based on Jian he's prototype
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ( "Software" ) are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/*========================== Header Files ====================================*/
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/string.h>
+#include <getopt.h>
+#include <ctype.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <basetypes.h>
+#include <mtd/mtd-user.h>
+//#include <linux/jffs2.h>
+
+#include "upgrade_part_adc.h"
+
+/*===========================================================================*/
+#define MAX_PAGE_SIZE    2048
+#define MAX_OOB_SIZE    64
+
+//#define FLPART_MAGIC    0x8732dfe6
+//#define __ARMCC_PACK__
+//#define __ATTRIB_PACK__  __attribute__ ((packed))
+//#define ETH_INSTANCES        2
+//#define USE_WIFI        1
+//#define CMD_LINE_SIZE        512
+//#define MAC_SIZE        6
+//#define SN_SIZE            32
+
+//essential
+/* mtd struct for image */
+typedef struct nand_update_file_header_s {
+    unsigned char    magic_number[8];           /*   AMBUPGD'\0'     8 chars including '\0' */
+    unsigned short    header_ver_major;
+    unsigned short    header_ver_minor;
+    unsigned int    header_size;               /* payload starts at header_start_address + header_size */
+    unsigned int  payload_type;                /* NAND_UPGRADE_FILE_TYPE_xxx */
+    unsigned char    payload_description[256];  /* payload description string, end with '\0' */
+    unsigned int  payload_size;                /* payload of upgrade file, after header */
+    unsigned int  payload_crc32;               /* payload crc32 checksum, crc calculation from
+                                                  header_start_address  + header_size,
+                                                  crc calculation size is payload_size */
+}nand_update_file_header_t;
+//essential
+typedef struct nand_update_global_s {
+    /* Buffer array used for writing data */
+    unsigned char writebuf[MAX_PAGE_SIZE];
+    unsigned char oobbuf[MAX_OOB_SIZE];
+    unsigned char oobreadbuf[MAX_OOB_SIZE];
+    /* oob layouts to pass into the kernel as default */
+    struct nand_oobinfo none_oobinfo;
+    struct nand_oobinfo jffs2_oobinfo;
+    struct nand_oobinfo yaffs_oobinfo;
+    struct nand_oobinfo autoplace_oobinfo;
+} nand_update_global_t;
+//#define PROGRAM "upgrade_partition"
+//#define VERSION "Revision: 1.310.04 "
+//#define AMB_VERSION "Ambarella: 0-20150121 "
+//#define MAX_LEVEL    32
+//#define NANDWRITE_OPTIONS_BASE        0
+//#define NETWORK_OPTION_BASE        20
+
+
+
+const unsigned int crc32_tab[] = {
+    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
+    0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
+    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
+    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
+    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
+    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
+    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
+    0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
+    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
+    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
+    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
+    0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
+    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
+    0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
+    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
+    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
+    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
+    0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
+    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
+    0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
+    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
+    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
+    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
+    0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
+    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
+    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
+    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
+    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
+    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
+    0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
+    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
+    0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
+    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
+    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
+    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
+    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
+    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
+    0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
+    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
+    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
+    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
+    0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
+    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
+};
+
+
+
+static inline unsigned int crc32( unsigned int val, const void *ss, int len)
+{
+    const unsigned char *s = (unsigned char*)ss;
+    while (--len >= 0)
+        val = crc32_tab[(val ^ *s++) & 0xff] ^ (val >> 8);
+    return val;
+}
+
+static void init_nand_update_global(nand_update_global_t *pG)
+{
+    pG->none_oobinfo.useecc = MTD_NANDECC_OFF;
+    pG->autoplace_oobinfo.useecc = MTD_NANDECC_AUTOPLACE;
+
+    pG->jffs2_oobinfo.useecc = MTD_NANDECC_PLACE;
+    pG->jffs2_oobinfo.eccbytes = 6;
+    pG->jffs2_oobinfo.eccpos[0] = 0;
+    pG->jffs2_oobinfo.eccpos[1] = 1;
+    pG->jffs2_oobinfo.eccpos[2] = 2;
+    pG->jffs2_oobinfo.eccpos[3] = 3;
+    pG->jffs2_oobinfo.eccpos[4] = 6;
+    pG->jffs2_oobinfo.eccpos[5] = 7;
+
+    pG->yaffs_oobinfo.useecc = MTD_NANDECC_PLACE;
+    pG->yaffs_oobinfo.eccbytes = 6;
+    pG->yaffs_oobinfo.eccpos[0] = 8;
+    pG->yaffs_oobinfo.eccpos[1] = 9;
+    pG->yaffs_oobinfo.eccpos[2] = 10;
+    pG->yaffs_oobinfo.eccpos[3] = 13;
+    pG->yaffs_oobinfo.eccpos[4] = 14;
+    pG->yaffs_oobinfo.eccpos[5] = 15;
+
+    memset(pG->oobbuf, 0xff, sizeof(pG->oobbuf));
+}
+
+int upgrade_partition(int index, const char* img)
+{
+    char     *mtd_device ;
+    unsigned int      mtdoffset = 0;
+    int      quiet = 0;
+    int      writeoob = 0;
+    int      skip_head = 0;
+    int      forcejffs2 = 0;
+    int      forceyaffs = 0;
+    int      pad = 0;
+    nand_update_global_t *ptr_update=NULL;
+    int      blockalign = 1; /*default to using 16K block size */ //essential
+
+    int fd, ifd, pagelen, baderaseblock, blockstart = -1;
+    unsigned cnt, readlen,  imglen= 0;
+    int ret, oobinfochanged = 0;
+    int image_crc = ~0U, image_length = 0;
+    struct nand_oobinfo old_oobinfo;
+    struct mtd_info_user meminfo;
+    struct mtd_oob_buf oob;
+    loff_t offs;
+    unsigned char readbuf[MAX_PAGE_SIZE];
+    int file_offset = mtdoffset;
+    unsigned int buf_num = 0;
+    nand_update_file_header_t image_head;
+    char device_name_convert[20]={0};
+
+    sprintf(device_name_convert,"/dev/mtd%d",index);
+    mtd_device   =device_name_convert;
+
+    ptr_update = (nand_update_global_t *)malloc(sizeof(nand_update_global_t));
+    if (!ptr_update) {
+        perror("can not malloc buffer for update global.\n");
+        exit(1);
+    }
+    init_nand_update_global(ptr_update);
+
+    if (pad && writeoob) {
+        fprintf(stderr, "Can't pad when oob data is present.\n");
+        exit(1);
+    }
+    //update_partition_with_img();
+    // Open the device
+    if ((fd = open(mtd_device, O_RDWR)) == -1) {
+        perror("open flash");
+        exit(1);
+    }
+
+    // Fill in MTD device capability structure
+    if (ioctl(fd, MEMGETINFO, &meminfo) != 0) {
+        perror("MEMGETINFO");
+        close(fd);
+        exit(1);
+    }
+
+    // Set erasesize to specified number of blocks - to match jffs2
+    // (virtual) block size
+    meminfo.erasesize *= blockalign;
+
+    // Make sure device page sizes are valid
+    if (!(meminfo.oobsize == 16 && meminfo.writesize == 512) &&
+        !(meminfo.oobsize == 8 && meminfo.writesize == 256) &&
+        !(meminfo.oobsize == 64 && meminfo.writesize == 2048)) {
+        fprintf(stderr, "Unknown flash (not normal NAND)\n");
+        close(fd);
+        exit(1);
+    }
+
+    /*
+    * force oob layout for jffs2 or yaffs ?
+    * Legacy support
+    */
+    if (forcejffs2 || forceyaffs) {
+        if (meminfo.oobsize == 8) {
+            if (forceyaffs) {
+                fprintf (stderr, "YAFSS cannot operate on 256 Byte page size");
+                goto restoreoob;
+            }
+            // Adjust number of ecc bytes
+            ptr_update->jffs2_oobinfo.eccbytes = 3;
+        }
+    }
+
+    oob.length = meminfo.oobsize;
+    oob.ptr = ptr_update->oobbuf;
+
+    // Open the input file
+    if ((ifd = open(img, O_RDONLY)) == -1) {
+         perror("open input file");
+         goto restoreoob;
+    }
+
+    // get image length
+    imglen = lseek(ifd, 0, SEEK_END);
+    lseek (ifd, 0, SEEK_SET);
+    if(skip_head)
+    {
+        if(read(ifd, &image_head, sizeof(nand_update_file_header_t))
+            != sizeof(nand_update_file_header_t)) {
+            perror ("File I/O error on input file");
+            goto closeall;
+        }
+        lseek(ifd, image_head.header_size, SEEK_SET);
+        imglen =image_head.payload_size;
+        file_offset +=image_head.header_size;
+    }
+    image_length = imglen;
+
+    pagelen = meminfo.writesize + ((writeoob == 1) ? meminfo.oobsize : 0);
+
+    // Check, if file is pagealigned
+    if ((!pad) && ((imglen % pagelen) != 0)) {
+        fprintf (stderr, "Input file is not page aligned\n");
+        goto closeall;
+    }
+
+    // Check, if length fits into device
+    if ( ((imglen / pagelen) * meminfo.writesize) > (meminfo.size - mtdoffset)) {
+        fprintf (stderr, "Image %d bytes, NAND page %d bytes, OOB area %u bytes, device size %u bytes\n",
+            imglen, pagelen, meminfo.writesize, meminfo.size);
+        perror ("Input file does not fit into device");
+        goto closeall;
+    }
+
+    //crc32_table = crc32_filltable(NULL, 0);
+
+    // Get data from input and write to the device
+    while (imglen && (mtdoffset < meminfo.size)) {
+        // new eraseblock , check for bad block(s)
+        // Stay in the loop to be sure if the mtdoffset changes because
+        // of a bad block, that the next block that will be written to
+        // is also checked. Thus avoiding errors if the block(s) after the
+        // skipped block(s) is also bad (number of blocks depending on
+        // the blockalign
+        while (blockstart != (int)(mtdoffset & (~meminfo.erasesize + 1))) {
+            blockstart = mtdoffset & (~meminfo.erasesize + 1);
+            offs = blockstart;
+            baderaseblock = 0;
+            if (!quiet)
+                fprintf (stdout, "Writing data to block %x\n", blockstart);
+
+            //Check all the blocks in an erase block for bad blocks
+            do {
+                if ((ret = ioctl(fd, MEMGETBADBLOCK, &offs)) < 0) {
+                    perror("ioctl(MEMGETBADBLOCK)");
+                    goto closeall;
+                }
+                if (ret == 1) {
+                    baderaseblock = 1;
+                    if (!quiet)
+                        fprintf (stderr, "Bad block at %x, %u block(s) "
+                        "from %x will be skipped\n",
+                        (int) offs, blockalign, blockstart);
+                }
+
+                if (baderaseblock) {
+                    mtdoffset = blockstart + meminfo.erasesize;
+                }
+                offs +=  meminfo.erasesize / blockalign ;
+            } while ( offs < blockstart + meminfo.erasesize );
+
+        }
+
+        readlen = meminfo.writesize;
+        if (pad && (imglen < readlen)) {
+            readlen = imglen;
+            memset(ptr_update->writebuf + readlen, 0xff, meminfo.writesize - readlen);
+        }
+
+        // Read Page Data from input file
+        if ((cnt = pread(ifd, ptr_update->writebuf, readlen,file_offset)) != readlen) {
+            if (cnt == 0)// EOF
+                break;
+            perror ("File I/O error on input file");
+            goto closeall;
+        }
+
+        image_crc = crc32(image_crc, ptr_update->writebuf, cnt);
+
+        if (writeoob) {
+            int i, start, len, filled;
+            // Read OOB data from input file, exit on failure
+            if ((cnt = pread(ifd, ptr_update->oobreadbuf, meminfo.oobsize,file_offset)) != meminfo.oobsize) {
+                perror ("File I/O error on input file");
+                goto closeall;
+            }
+            /*
+             *  We use autoplacement and have the oobinfo with the autoplacement
+             * information from the kernel available
+             *
+             * Modified to support out of order oobfree segments,
+             * such as the layout used by diskonchip.c
+             */
+            if (!oobinfochanged && (old_oobinfo.useecc == MTD_NANDECC_AUTOPLACE)) {
+                for (filled = 0, i = 0; old_oobinfo.oobfree[i][1] && (i < MTD_MAX_OOBFREE_ENTRIES); i++) {
+                    /* Set the reserved bytes to 0xff */
+                    start = old_oobinfo.oobfree[i][0];
+                    len = old_oobinfo.oobfree[i][1];
+                    memcpy(ptr_update->oobbuf + start,
+                        ptr_update->oobreadbuf + filled,
+                        len);
+                    filled += len;
+                }
+            } else {
+                // Set at least the ecc byte positions to 0xff
+                start = old_oobinfo.eccbytes;
+                len = meminfo.oobsize - start;
+                memcpy(ptr_update->oobbuf + start,
+                    ptr_update->oobreadbuf + start, len);
+            }
+            // Write OOB data first, as ecc will be placed in there
+            oob.start = mtdoffset;
+            if (ioctl(fd, MEMWRITEOOB, &oob) != 0) {
+                perror ("ioctl(MEMWRITEOOB)");
+                goto closeall;
+            }
+            imglen -= meminfo.oobsize;
+        }
+
+        // Write out the Page data
+
+        if (pwrite(fd, ptr_update->writebuf, meminfo.writesize, mtdoffset) != (int)meminfo.writesize) {
+            perror ("pwrite");
+            goto closeall;
+        }
+
+        // read out the Page data
+        if (pread(fd, readbuf, meminfo.writesize, mtdoffset) != (int)meminfo.writesize) {
+            perror ("pread");
+            goto closeall;
+        }
+
+        buf_num=0;
+        while ((ptr_update->writebuf[buf_num]==readbuf[buf_num]) && (buf_num < readlen)) buf_num++;
+
+        //if (((blockstart/MAX_PAGE_SIZE/64) % 10) == 9)
+        if (buf_num < readlen) {
+            //printf("offs[%x ],blockstart[%x],mtdoffset[%x],writesize[0x%x], buf_num[0x%x]\n",(int)offs,blockstart,mtdoffset,meminfo.writesize, buf_num);
+
+            // set bad blocks
+            offs = (loff_t) blockstart;
+            if ((ret = ioctl(fd, MEMSETBADBLOCK, &offs)) < 0) {
+                perror("ioctl(MEMSETBADBLOCK)");
+                goto closeall;
+            }
+            if ((ret == 0) && (!quiet)) {
+                fprintf (stdout, "set Bad block at %x !\n",blockstart);
+                file_offset = file_offset - (mtdoffset-blockstart);
+                imglen = imglen+ (mtdoffset-blockstart);;
+                mtdoffset = blockstart + meminfo.erasesize;
+            }
+        } else {
+            imglen -= readlen;
+            mtdoffset += meminfo.writesize;
+            file_offset+= meminfo.writesize;
+        }
+    }
+
+closeall: //essential
+    close(ifd);
+
+restoreoob:  //essential
+    close(fd);
+
+    if (imglen > 0) {
+        perror ("Data was only partially written due to error\n");
+        exit (1);
+    }
+
+    image_crc ^= ~0U;
+    printf ("image_length = 0x%08x\n", image_length);
+    printf ("image_crc = 0x%08x\n", image_crc);
+    free(ptr_update);
+
+    sync();
+    return 0;
+}
diff --git a/fastboot_app/utils/adc/upgrade_part_adc.h b/fastboot_app/utils/adc/upgrade_part_adc.h
new file mode 100644
index 0000000..a9437a2
--- /dev/null
+++ b/fastboot_app/utils/adc/upgrade_part_adc.h
@@ -0,0 +1,36 @@
+/**
+ * upgrade_part_adc.h
+ *
+ * History:
+ *    2015/03/30 - [jbxing] created file which is based on Jian he's prototype
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ( "Software" ) are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __SMART3A_ADC_UPGRADE_PARTITION_H__
+#define __SMART3A_ADC_UPGRADE_PARTITION_H__
+
+int upgrade_partition(int index, const char* img);
+#endif
diff --git a/fastboot_app/utils/aplay/audio_play.c b/fastboot_app/utils/aplay/audio_play.c
new file mode 100644
index 0000000..08ad377
--- /dev/null
+++ b/fastboot_app/utils/aplay/audio_play.c
@@ -0,0 +1,445 @@
+/*
+ * audio_play.c
+ *
+ * History:
+ *       2015/05/29 - [Jian Liu] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include "audio_play.h"
+
+#ifdef AUDIO_INPUT_ALSA_SUPPORTED
+#include <alsa/asoundlib.h>
+typedef struct _audio_handle_t {
+    snd_pcm_t *snd_pcm;
+    snd_output_t *mpLog;
+    snd_pcm_stream_t stream;
+    snd_pcm_format_t format;
+    unsigned int sample_rate;
+    unsigned int channel_number;
+    snd_pcm_uframes_t mChunkSize;
+    int mBitsPerFrame;
+}audio_handler_t;
+static audio_handler_t *open_audio_hal(unsigned int sample_rate,int channel_number,int frame_samples);
+static int  audio_start(audio_handler_t *handler);
+static void close_audio_hal(audio_handler_t *handler);
+static int  read_audio_stream(audio_handler_t *handler, unsigned char *data,  int size, int *frame_number);
+//static int get_data_size(audio_handler_t *handler,int frame_number);
+#else
+typedef struct _audio_handle_t {
+    void *data;
+}audio_handler_t;
+static audio_handler_t *open_audio_hal(unsigned int sample_rate,int channel_number,int frame_samples){
+    audio_handler_t *handle = NULL;
+    return handle;
+}
+static int  audio_start(audio_handler_t *handler){
+    return 0;
+}
+static void close_audio_hal(audio_handler_t *handler){
+    return;
+}
+static int  read_audio_stream(audio_handler_t *handler, unsigned char *data,  int size, int *frame_number){
+    return -1;
+}
+#endif
+
+
+#ifdef AUDIO_INPUT_ALSA_SUPPORTED
+static audio_handler_t audio_handler;
+static
+audio_handler_t *open_audio_hal(unsigned int sample_rate,int channel_number,int frame_samples)
+{
+    snd_pcm_hw_params_t *params = NULL;
+    snd_pcm_sw_params_t *swparams = NULL;
+    snd_pcm_uframes_t buffer_size;
+    unsigned int buffer_time = 0;
+    unsigned int  start_threshold, stop_threshold;
+    int err;
+
+    audio_handler_t *handler = &audio_handler;
+    memset(&audio_handler,0,sizeof(audio_handler));
+    audio_handler.stream = SND_PCM_STREAM_CAPTURE;
+    audio_handler.format = SND_PCM_FORMAT_S16_LE;
+    audio_handler.sample_rate = sample_rate;
+    audio_handler.channel_number = channel_number;
+
+    err = snd_output_stdio_attach(&handler->mpLog, stderr, 0);
+    if(err < 0){
+        perror("snd_output_stdio_attach");
+        goto exit;
+    }
+
+    err = snd_pcm_open(&handler->snd_pcm, "default", handler->stream, 0);
+    if (err < 0) {
+        err = snd_pcm_open(&handler->snd_pcm, "MICALL", handler->stream, 0);
+    }
+    if (err < 0) {
+        printf("Capture audio open error: %s\n", snd_strerror(err));
+        goto exit;
+    }
+
+    snd_pcm_hw_params_alloca(&params);
+    err = snd_pcm_hw_params_any(handler->snd_pcm, params);
+    if (err < 0) {
+        perror("Broken configuration for this PCM: no configurations available\n");
+        goto exit;
+    }
+
+    err = snd_pcm_hw_params_set_access(handler->snd_pcm, params, SND_PCM_ACCESS_RW_INTERLEAVED);
+    if (err < 0) {
+        perror("Access type not available\n");
+        goto exit;
+    }
+
+    err = snd_pcm_hw_params_set_format(handler->snd_pcm, params, handler->format);
+    if (err < 0) {
+        perror("Sample format non available\n");
+        goto exit;
+    }
+
+    err = snd_pcm_hw_params_set_channels(handler->snd_pcm, params, handler->channel_number);
+    if (err < 0) {
+        perror("Channels count non available\n");
+        goto exit;
+    }
+
+    err = snd_pcm_hw_params_set_rate_near(handler->snd_pcm, params, &handler->sample_rate, 0);
+    //AM_ASSERT(err >= 0);
+
+    err = snd_pcm_hw_params_get_buffer_time_max(params, &buffer_time, 0);
+    //AM_ASSERT(err >= 0);
+    if (buffer_time > 500000)
+        buffer_time = 500000;
+
+    handler->mChunkSize = frame_samples;
+    err = snd_pcm_hw_params_set_period_size(handler->snd_pcm, params, handler->mChunkSize, 0);
+    //AM_ASSERT(err >= 0);
+
+    err = snd_pcm_hw_params_set_buffer_time_near(handler->snd_pcm, params, &buffer_time, 0);
+    //AM_ASSERT(err >= 0);
+
+    err = snd_pcm_hw_params(handler->snd_pcm, params);
+    if (err < 0) {
+        snd_pcm_hw_params_dump(params, handler->mpLog);
+        goto exit;
+    }
+
+    snd_pcm_hw_params_get_period_size(params, &handler->mChunkSize, 0);
+    snd_pcm_hw_params_get_buffer_size(params, &buffer_size);
+    if (handler->mChunkSize == buffer_size) {
+        goto exit;
+    }
+
+    snd_pcm_sw_params_alloca(&swparams);
+    snd_pcm_sw_params_current(handler->snd_pcm, swparams);
+    err = snd_pcm_sw_params_set_avail_min(handler->snd_pcm, swparams, handler->mChunkSize);
+
+     start_threshold = 1;
+    err = snd_pcm_sw_params_set_start_threshold(handler->snd_pcm, swparams, start_threshold);
+    //AM_ASSERT(err >= 0);
+
+    stop_threshold = buffer_size;
+    err = snd_pcm_sw_params_set_stop_threshold(handler->snd_pcm, swparams, stop_threshold);
+    //AM_ASSERT(err >= 0);
+
+    if (snd_pcm_sw_params(handler->snd_pcm, swparams) < 0) {
+        //AM_ERROR("unable to install sw params:\n");
+        snd_pcm_sw_params_dump(swparams, handler->mpLog);
+        goto exit;
+    }
+    handler->mBitsPerFrame = snd_pcm_format_physical_width(handler->format) * handler->channel_number;
+    return handler;
+exit:
+    if(handler->mpLog){
+       snd_output_close(handler->mpLog);
+       handler->mpLog = NULL;
+    }
+    if (handler->snd_pcm != NULL){
+        snd_pcm_close(handler->snd_pcm);
+        handler->snd_pcm = NULL;
+    }
+    return NULL;
+}
+
+static
+void close_audio_hal(audio_handler_t *handler)
+{
+     if(handler->mpLog != NULL){
+        snd_output_close(handler->mpLog);
+        handler->mpLog = NULL;
+     }
+     if (handler->snd_pcm != NULL){
+        snd_pcm_close(handler->snd_pcm);
+        handler->snd_pcm = NULL;
+     }
+}
+
+static
+int  audio_start(audio_handler_t *handler)
+{
+    snd_pcm_status_t *status;
+    int err;
+
+    if ((err = snd_pcm_start(handler->snd_pcm)) < 0) {
+        //AM_ERROR("PCM start error: %s\n", snd_strerror(err));
+        return -1;
+    }
+
+    snd_pcm_status_alloca(&status);
+
+    if ((err = snd_pcm_status(handler->snd_pcm, status))<0) {
+        //AM_ERROR("Get PCM status error: %s\n", snd_strerror(err));
+        return -1;
+    }
+    //snd_pcm_status_get_trigger_tstamp(status, &mStartTimeStamp);
+    //AM_PRINTF("start time %d:%d\n", (AM_INT)mStartTimeStamp.tv_sec, (AM_INT)mStartTimeStamp.tv_usec);
+
+    return 0;
+}
+
+static int PcmRead(audio_handler_t *handler,unsigned char *pData, unsigned int rcount);
+static
+int  read_audio_stream(audio_handler_t *handler, unsigned char *pData,  int dataSize, int *pNumFrames)
+{
+    //snd_pcm_status_t *status;
+    //snd_timestamp_t now, diff, trigger;
+    int frm_cnt;
+
+    if(dataSize < (int)(handler->mChunkSize * handler->mBitsPerFrame / 8)){
+        // make sure buffer can hold one chunck of data
+        return -1;
+    }
+    frm_cnt = PcmRead(handler,pData, (unsigned int)handler->mChunkSize);
+
+    if (frm_cnt <= 0)
+        return -1;
+
+    //AM_ASSERT(frm_cnt == handler->mChunkSize);
+    *pNumFrames = frm_cnt;
+    //printf("read_audio_stream, chunkSize = %d, mBitsPerFrame = %d, frm_cnt = %d\n",(int)handler->mChunkSize,handler->mBitsPerFrame,frm_cnt);
+
+     return 0;
+}
+
+/*
+static
+int get_data_size(audio_handler_t *handler,int  frame_number){
+    return frame_number * handler->mBitsPerFrame / 8;
+}
+*/
+
+// I/O error handler /
+static int Xrun(audio_handler_t *handler)
+{
+    snd_pcm_status_t *status;
+    int err;
+
+    snd_pcm_status_alloca(&status);
+    if ((err = snd_pcm_status(handler->snd_pcm, status))<0) {
+        //AM_ERROR("status error: %s\n", snd_strerror(err));
+        return -1;
+    }
+
+    if (snd_pcm_status_get_state(status) == SND_PCM_STATE_XRUN) {
+        if ((err = snd_pcm_prepare(handler->snd_pcm))<0) {
+            //AM_ERROR("xrun: prepare error: %s", snd_strerror(err));
+            return -1;
+        }
+        return 0;       // ok, data should be accepted again
+    }
+
+    if (snd_pcm_status_get_state(status) == SND_PCM_STATE_DRAINING) {
+        //AM_INFO("capture stream format change? attempting recover...\n");
+        if ((err = snd_pcm_prepare(handler->snd_pcm))<0) {
+            //AM_ERROR("xrun(DRAINING): prepare error: %s\n", snd_strerror(err));
+            return -1;
+        }
+        return 0;
+    }
+    return 0;
+}
+
+static int Suspend(audio_handler_t *handler)
+{
+    int err;
+    while ((err = snd_pcm_resume(handler->snd_pcm)) == -EAGAIN)
+    //usleep(1000000);  /* wait until suspend flag is released */
+    if (err < 0) {
+        if ((err = snd_pcm_prepare(handler->snd_pcm)) < 0) {
+            return -1;
+        }
+    }
+    return 0;
+}
+
+static int PcmRead(audio_handler_t *handler,unsigned char *pData, unsigned int rcount)
+{
+    int err;
+    int  r;
+    int  result = 0;
+    unsigned int  count = rcount;
+
+    if (count != handler->mChunkSize) {
+        count = handler->mChunkSize;
+    }
+
+    while (count > 0) {
+        r = snd_pcm_readi(handler->snd_pcm, pData, count);
+
+        if (r == -EAGAIN || (r >= 0 && (unsigned int )r < count)) {
+            //if (!mbNoWait)
+            //snd_pcm_wait(handler->snd_pcm, 100);
+        } else if (r == -EPIPE) {                   // an overrun occurred
+            if ((err = Xrun(handler)) != 0)
+                return -1;
+        } else if (r == -ESTRPIPE) {            // a suspend event occurred
+            if ((err = Suspend(handler)) != 0)
+                return -1;
+        } else if (r < 0) {
+            if(r == -EIO){
+                //AM_INFO("-EIO error!\n");
+            }else if(r == -EINVAL){
+                //AM_INFO("-EINVAL error!\n");
+            } else if(r == -EINTR){
+                //AM_INFO("-EINTR error!\n");
+            }else{
+                //AM_ERROR("Read error: %s(%d)\n", snd_strerror(r), r);
+            }
+            return -1;
+        }
+        if (r > 0) {
+            result += r;
+            count -= r;
+            pData += r * handler->mBitsPerFrame / 8;      // convert frame num to bytes
+        }
+    }
+    return result;
+}
+#endif
+
+
+static volatile int audio_capture_ready_flag = 0;
+static void *workaround_routine(void *arg){
+    volatile int *exit_flag = (volatile int*)arg;
+    void *hal;
+    hal =  (void*)open_audio_hal(48000,1,1024);
+    if(!hal){
+        printf("aplay workaround_routine -- failed to open_audio caputre\n");
+        fflush(stdout);
+        audio_capture_ready_flag = 1;
+        return (void*)NULL;
+    }
+
+    audio_handler_t *handler = (audio_handler_t *)hal;
+    if(audio_start(handler) < 0){
+        printf("aplay workaround_routine -- failed to open_audio caputre\n");
+        fflush(stdout);
+        close_audio_hal(handler);
+        audio_capture_ready_flag = 1;
+        return (void*)NULL;
+    }
+
+    do{
+        unsigned char data[4096];
+        int num_frames;
+        read_audio_stream(handler, data, (int)4096, &num_frames);
+    }while(0);
+
+    audio_capture_ready_flag = 1;
+    while(!(*exit_flag)){
+        usleep(1000 * 1000);
+    }
+    close_audio_hal(handler);
+    return (void*)NULL;
+}
+
+int aplay_audio(char* filepath){
+    pthread_t thread_id;
+    volatile int exit_flag = 0;
+    audio_capture_ready_flag = 0;
+    int ret = pthread_create(&thread_id, NULL, workaround_routine, (void*)&exit_flag);
+    if (ret != 0) {
+        printf("aplay_audio pthread_create fail\n");
+        fflush(stdout);
+        return -1;
+    }
+    while(!audio_capture_ready_flag) usleep(10000);
+
+    char cmd[2048];
+    snprintf(cmd,sizeof(cmd),"/usr/bin/aplay  %s",filepath);
+    system(cmd);
+    exit_flag = 1;
+    pthread_join(thread_id,NULL);
+    return 0;
+}
+
+void load_audio_playback_driver(void)
+{
+#if defined(CONFIG_ELEKTRA_CODEC_WM8974)
+    system("/sbin/modprobe i2c-dev");
+    system("/sbin/modprobe snd-soc-core pmdown_time=300");
+    system("/sbin/modprobe snd-soc-ambarella");
+    system("/sbin/modprobe snd-soc-ambarella-i2s capture_enabled=0");
+#elif defined(CONFIG_ELEKTRA_CODEC_AK7755)
+    system("/sbin/modprobe snd-soc-core pmdown_time=500");
+    system("/sbin/modprobe snd-soc-ambarella");
+    system("/sbin/modprobe snd-soc-ambarella-i2s capture_enabled=0");
+    system("/sbin/modprobe snd-soc-ak7755 fast_boot=1");
+#endif
+    system("/sbin/modprobe snd-soc-ambdummy");
+    system("/sbin/modprobe snd-soc-amba-board");
+}
+
+void unload_audio_playback_driver(void)
+{
+    system("/sbin/modprobe -r snd-soc-amba-board");
+    system("/sbin/modprobe -r snd-soc-ambdummy");
+#if defined(CONFIG_ELEKTRA_CODEC_WM8974)
+    system("/sbin/modprobe -r snd-soc-ambarella-i2s");
+    system("/sbin/modprobe -r snd-soc-ambarella");
+    system("/sbin/modprobe -r snd-soc-core");
+    system("/sbin/modprobe -r i2c-dev");
+#elif defined(CONFIG_ELEKTRA_CODEC_AK7755)
+    system("/sbin/modprobe -r snd-soc-ak7755");
+    system("/sbin/modprobe -r snd-soc-ambarella-i2s");
+    system("/sbin/modprobe -r snd-soc-ambarella");
+    system("/sbin/modprobe -r snd-soc-core");
+#endif
+}
+
+void play_audio_by_aplay(const char *filepath)
+{
+    char spawn_aplay_input[128] = {0};
+    snprintf(spawn_aplay_input,sizeof(spawn_aplay_input),"/usr/bin/aplay %s", filepath);
+    spawn_aplay_input[sizeof(spawn_aplay_input)-1] = '\0';
+    system(spawn_aplay_input);
+}
diff --git a/fastboot_app/utils/audio_play.h b/fastboot_app/utils/audio_play.h
new file mode 100644
index 0000000..304923c
--- /dev/null
+++ b/fastboot_app/utils/audio_play.h
@@ -0,0 +1,50 @@
+/*
+ * audio_play.h
+ *
+ * History:
+ *       2016/06/16 - [CZ Lin] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef AUDIO_PLAY_H__
+#define AUDIO_PLAY_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void load_audio_playback_driver(void);
+void unload_audio_playback_driver(void);
+void play_audio_by_aplay(const char *filepath);
+// aplay_audio is a workaround working on elektra 2 board when play audio it need to run audio capture at the same time
+int aplay_audio(char *filepath);
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif
+
diff --git a/fastboot_app/utils/bpi_utils.cpp b/fastboot_app/utils/bpi_utils.cpp
new file mode 100644
index 0000000..55bd969
--- /dev/null
+++ b/fastboot_app/utils/bpi_utils.cpp
@@ -0,0 +1,397 @@
+/*
+ * bpi_utils.c
+ *
+ * History:
+ *       2015/08/27 - [Chu Chen] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <net/if.h>
+#include <time.h>
+#include <string.h>
+#include <stdio.h>
+#include <regex>
+#include <unistd.h>
+#include <errno.h>
+#include <sys/ioctl.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <stdarg.h>
+#include "basetypes.h"
+#include "bpi_utils.h"
+static int _log_options = 0;
+
+using std::string;
+using std::regex;
+using std::smatch;
+
+//utility interface
+unsigned  int get_current_time(void)
+{
+    struct timespec now;
+    clock_gettime(CLOCK_MONOTONIC,&now);
+    unsigned mseconds = now.tv_sec * 1000+ now.tv_nsec/1000000;
+    return mseconds;
+}
+
+int get_macaddress(const char *itf_name,unsigned char macAddress[6])
+{
+    struct ifreq ifreq;
+    int sock;
+    if((sock=socket(AF_INET,SOCK_STREAM,0))<0) {
+        return -1;
+    }
+    strcpy(ifreq.ifr_name,itf_name);
+    if(ioctl(sock,SIOCGIFHWADDR,&ifreq)<0) {
+        close(sock);
+        return -1;
+    }
+    LOG_DEBUG("mac address [%02x:%02x:%02x:%02x:%02x:%02x]\n",
+              (unsigned char)ifreq.ifr_hwaddr.sa_data[0],
+              (unsigned char)ifreq.ifr_hwaddr.sa_data[1],
+              (unsigned char)ifreq.ifr_hwaddr.sa_data[2],
+              (unsigned char)ifreq.ifr_hwaddr.sa_data[3],
+              (unsigned char)ifreq.ifr_hwaddr.sa_data[4],
+              (unsigned char)ifreq.ifr_hwaddr.sa_data[5]);
+    macAddress[0] = (unsigned char)ifreq.ifr_hwaddr.sa_data[0];
+    macAddress[1] = (unsigned char)ifreq.ifr_hwaddr.sa_data[1];
+    macAddress[2] = (unsigned char)ifreq.ifr_hwaddr.sa_data[2];
+    macAddress[3] = (unsigned char)ifreq.ifr_hwaddr.sa_data[3];
+    macAddress[4] = (unsigned char)ifreq.ifr_hwaddr.sa_data[4];
+    macAddress[5] = (unsigned char)ifreq.ifr_hwaddr.sa_data[5];
+    close(sock);
+    return 0;
+}
+
+char *get_device_id(void)
+{
+    //TODO
+    static char s_device_id[128];
+    unsigned char macAddress[6];
+    if(get_macaddress("wlan0",macAddress) < 0) {
+        snprintf(s_device_id,sizeof(s_device_id),"TEST_ELEKTRA_UUID");
+    } else {
+        snprintf(s_device_id,sizeof(s_device_id),"UUID_%02x:%02x:%02x:%02x:%02x:%02x",\
+                 macAddress[0],macAddress[1],macAddress[2],macAddress[3],macAddress[4],macAddress[5]);
+    }
+    return s_device_id;
+}
+
+time_t get_time_from_name(const char* filename){
+    smatch match;
+    struct tm tm;
+    const regex time_pattern("(\\d{14,14})");
+    string tmp_str(filename);
+    if(nullptr == filename){
+        return -1;
+    }
+
+    if (regex_search(tmp_str, match, time_pattern)) {
+        memset(&tm, 0, sizeof(tm));
+        tmp_str = match[0].str();
+        sscanf(tmp_str.c_str(), "%4d%2d%2d%2d%2d%2d", &tm.tm_year, &tm.tm_mon, &tm.tm_mday, &tm.tm_hour, &tm.tm_min, &tm.tm_sec);
+        tm.tm_year -= 1900;
+        tm.tm_mon -= 1;
+        return mktime(&tm);
+    }
+    else{
+        return -1;
+    }
+    return -1;
+}
+
+int get_id_from_name(const char* filename){
+    smatch match;
+    const regex stream_pattern("stream\\d");
+    string tmp_str(filename);
+    if (regex_search(tmp_str, match, stream_pattern)) {
+        const regex id_pattern("\\d");
+        tmp_str = match[0].str();
+        if (regex_search(tmp_str, match, id_pattern)) {
+            return atoi(match[0].str().c_str());
+        }
+    }
+    return -1;
+}
+
+int get_num_from_tail(const char* filename){
+    smatch match;
+    const regex stream_pattern("stream\\d_\\d_\\d");
+    string tmp_str(filename);
+    if (regex_search(tmp_str, match, stream_pattern)) {
+        tmp_str = match[0].str();
+        unsigned int i = strlen(tmp_str.c_str()) - 1;
+        while(i>0 && (tmp_str[i] >= '0' && tmp_str[i] <= '9')){
+            i--;
+        }
+        if((i == 0) || (i == (strlen(tmp_str.c_str()) - 1))) return -1;
+        return atoi(tmp_str.c_str()+i+1);
+    }else{
+        return -1;
+    }
+}
+
+//for debug, show the elektra_boot start time
+void start_time()
+{
+    time_t now = time(NULL);
+    struct tm* p_tm = localtime(&now);
+    LOG_PRINT("\t***************************************************************\n");
+    LOG_PRINT("\t******elektra_boot start at the time: %d-%02d-%02d %02d:%02d:%02d******\n",
+              (1900 + p_tm->tm_year), (1 + p_tm->tm_mon), p_tm->tm_mday, p_tm->tm_hour, p_tm->tm_min, p_tm->tm_sec);
+    LOG_PRINT("\t***************************************************************\n");
+    LOG_DEBUG("elektra_boot start: %u\n", get_current_time());
+}
+
+static int parse_ip(const char *p_str, int len, char ip[MAX_IP_LEN]) {
+    int ret = -1;
+    do {
+        const char *p = p_str;
+        int times = 0;
+        while (NULL != (p = strchr(p, '.'))) {
+            times++;
+            p++;
+        }
+
+        if (times != 3) {
+            LOG_DEBUG("invalid ip address");
+            break;
+        }
+
+        memmove(ip, p_str, len);
+        ip[len] = '\0';
+        ret = 0;
+    } while (0);
+    return ret;
+}
+
+static int parse_port(const char *p_str, int len, int *p_port) {
+    if (!p_port) { return 0; }
+
+    int ret = -1;
+    do {
+        if (len > MAX_PORT_LEN) {
+            LOG_ERROR("port len exceeds 16 bytes %d", len);
+            break;
+        }
+
+        char buf[MAX_PORT_LEN];
+        memmove(buf, p_str, len);
+        buf[len] = '\0';
+
+        int port = atoi(buf);
+        if (port == 0) {
+            LOG_ERROR("invalid port");
+            break;
+        }
+
+        *p_port = port;
+        ret = 0;
+    } while (0);
+    return ret;
+}
+
+
+int param_device_parse_server(const char *p_str, char* ip, int *p_port)
+{
+    int ret = -1;
+    do {
+        // skip protocol
+        const char *p_proto = "://";
+        const char *p = strstr(p_str, p_proto);
+        if (p) { p_str = p + strlen(p_proto); }
+
+        int len = 0;
+        p = strchr(p_str, ':');
+        if (p) {
+            // parse ip & port
+            len = (int)(p - p_str);
+            ret = parse_ip(p_str, len, ip);
+            if (ret < 0) {
+                LOG_ERROR("invalid ip");
+                break;
+            }
+
+            len = (int)(strlen(p_str) - len - 1);
+            ret = parse_port(p+1, len, p_port);
+        } else {
+            // if ip, parse ip
+            // else parse port
+            len = (int)strlen(p_str);
+            p = strchr(p_str, '.');
+            if (p) {
+                ret = parse_ip(p_str, len, ip);
+                break;
+            } else {
+                ret = parse_port(p_str, len, p_port);
+                break;
+            }
+        }
+    } while (0);
+    return ret;
+}
+
+
+/*---------------------platform_specific---------------------*/
+#include <sys/vfs.h>
+static int wait_sda(void){
+    unsigned int start = get_current_time();
+    unsigned int now = start;
+    const char *dev_sda = "/dev/sda";
+    char sd_card[16] = {0};
+
+    while(1){
+        for(int sda_suffix = 1; sda_suffix < 10; sda_suffix++){
+            sprintf(sd_card, "%s%d", dev_sda, sda_suffix);
+            if(0 == access(sd_card, F_OK)){
+                LOG_DEBUG("check %s costs = %dms\n", sd_card, now - start);
+                return sda_suffix;
+            }
+        }
+        if(0 == access(dev_sda, F_OK)){
+            LOG_DEBUG("check %s costs = %dms\n", dev_sda, now - start);
+            return 0;
+        }
+        now = get_current_time();
+        if(now - start > 3000){
+            LOG_ERROR("failed to find any sdcard, please check sdcard: %s\n", strerror(errno));
+            return -1;
+        }
+
+        usleep(100000);
+    }
+}
+
+static int showSdcardInfo(void)
+{
+    struct statfs diskInfo;
+    if(statfs("/sdcard",&diskInfo) < 0){
+        LOG_DEBUG("/sdcard statfs failed, errno = %d\n",errno);
+        return -1;
+    }
+    unsigned long long blocksize = diskInfo.f_bsize;
+    unsigned long long totalsize = blocksize * diskInfo.f_blocks;
+    LOG_DEBUG("sdcard TOTAL_SIZE == %llu MB\n",totalsize>>20);
+    unsigned long long freeDisk = diskInfo.f_bfree*blocksize;
+    LOG_DEBUG("sdcard DISK_FREE == %llu MB\n",freeDisk>>20);
+    return 0;
+}
+
+int mount_sdcard(void){
+    system("/sbin/modprobe ehci_hcd");
+    system("/sbin/modprobe ehci_ambarella");
+    system("echo host > /proc/ambarella/usbphy0");
+    system("/sbin/modprobe scsi_mod");
+    system("/sbin/modprobe usb_storage");
+    system("/sbin/modprobe sd_mod");
+    system("/sbin/modprobe fat");
+    system("/sbin/modprobe vfat");
+    int sda_suffix;
+    char m_sd_cmd[64] = {0};
+
+    if((sda_suffix = wait_sda()) < 0){
+        return -1;
+    }
+
+    if(sda_suffix > 0){
+        sprintf(m_sd_cmd, "/bin/mount -t vfat /dev/sda%d /sdcard", sda_suffix);
+    }else{
+        sprintf(m_sd_cmd, "/bin/mount -t vfat /dev/sda /sdcard");
+    }
+    system(m_sd_cmd);
+    LOG_DEBUG("run_record_mode, sdcard driver installed\n");
+    return showSdcardInfo();
+}
+
+ void umount_sdcard(void){
+    system("/bin/umount /sdcard");
+    LOG_DEBUG("run_record_mode, sdcard driver uninstalled\n");
+}
+
+void enable_usb_ethernet(void){
+   system("/sbin/modprobe ehci-hcd");
+   system("echo device > /proc/ambarella/usbphy0");
+   system("/sbin/modprobe ambarella_udc");
+   system("/sbin/modprobe g_ether");
+   system("/sbin/ifconfig usb0 10.1.0.100 netmask 255.255.255.0 up");
+}
+void install_sdcard_driver(void){
+    system("/sbin/modprobe ehci_hcd");
+    system("/sbin/modprobe ehci_ambarella");
+    system("echo host > /proc/ambarella/usbphy0");
+    system("/sbin/modprobe scsi_mod");
+    system("/sbin/modprobe usb_storage");
+    system("/sbin/modprobe sd_mod");
+    system("/sbin/modprobe fat");
+    system("/sbin/modprobe vfat");
+}
+
+void set_log_options(int log_options)
+{
+    _log_options = log_options;
+    return;
+}
+
+void bpi_log(BPI_LOG_TYPE log_type, const char *format, ...)
+{
+    char log[512]   = {0};
+    char fmt[128]   = {0};
+    char tag[16] = {0};
+    va_list vlist;
+    va_start(vlist, format);
+    if((BPI_LOG_DEBUG == log_type) && !(_log_options & BPI_LOG_ENABLE_DEBUG_LOG)){
+        return;
+    }
+
+    switch(log_type){
+        case BPI_LOG_ERROR:
+            snprintf(tag, sizeof(tag), "%s", "[bpi-error]");
+            break;
+        case BPI_LOG_WARN:
+            snprintf(tag, sizeof(tag), "%s", "[bpi-warning]");
+            break;
+        case BPI_LOG_DEBUG:
+            snprintf(tag, sizeof(tag), "%s", "[bpi-debug]");
+            break;
+        default:
+            snprintf(tag, sizeof(tag), "%s", "[bpi-info]");
+            break;
+    }
+
+    if((_log_options & BPI_LOG_ENABLE_TIMESTAMP)){
+        struct timeval tm;
+        gettimeofday(&tm, NULL);
+        snprintf(fmt, sizeof(fmt), "%s[%ld.%ld] %s", tag, tm.tv_sec, tm.tv_usec, format);
+    }else{
+        snprintf(fmt, sizeof(fmt), "%s %s", tag, format);
+    }
+    vsnprintf(log, sizeof(log), fmt, vlist);
+    va_end(vlist);
+    fprintf(stderr, "%s", log);
+    fflush(stderr);
+}
diff --git a/fastboot_app/utils/bpi_utils.h b/fastboot_app/utils/bpi_utils.h
new file mode 100644
index 0000000..88859e1
--- /dev/null
+++ b/fastboot_app/utils/bpi_utils.h
@@ -0,0 +1,89 @@
+/*
+ * bpi_utils.h
+ *
+ * History:
+ *       2015/08/03 - [Jian Liu] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef FASTBOOT_UTILS_H__
+#define FASTBOOT_UTILS_H__
+
+#include <time.h>
+#define MAX_IP_LEN                          64
+#define MAX_PORT_LEN                        12
+
+typedef enum {
+  BPI_LOG_PRINT  = 0,
+  BPI_LOG_ERROR  = 1,
+  BPI_LOG_WARN   = 2,
+  BPI_LOG_DEBUG  = 3,
+} BPI_LOG_TYPE;
+
+typedef enum {
+  BPI_LOG_ENABLE_DEBUG_LOG  = 1 << 0,
+  BPI_LOG_ENABLE_TIMESTAMP  = 1 << 1,
+} BPI_LOG_OPTIONS;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+//platform related
+int mount_sdcard(void);
+void umount_sdcard(void);
+void enable_usb_ethernet(void);
+
+
+//GPIO related
+void shut_down();
+int check_boot_mode();
+void reset_wifi_chip();
+
+//utils
+unsigned int  get_current_time(void);
+int get_macaddress(char *itf_name,unsigned char macAddress[6]);
+char *get_device_id(void);
+time_t get_time_from_name(const char* filename);
+int get_id_from_name(const char* filename);
+int get_num_from_tail(const char* filename);
+void start_time();
+
+int param_device_parse_server(const char *p_str, char* ip, int* p_port) ;
+void bpi_log(BPI_LOG_TYPE log_type, const char *format, ...);
+void set_log_options(int log_options);
+
+#ifdef __cplusplus
+};
+#endif
+
+#define COLOR_RESET "\x1B[0m"
+#define LOG_ERROR(format, args...)  bpi_log(BPI_LOG_ERROR, format, ##args)
+#define LOG_PRINT(format, args...)  bpi_log(BPI_LOG_PRINT, format, ##args)
+#define LOG_DEBUG(format, args...)  bpi_log(BPI_LOG_DEBUG, format, ##args)
+#define LOG_WARNING(format, args...)  bpi_log(BPI_LOG_WARN, format, ##args)
+
+#endif//PLATFORM_UTILS_H__
+
diff --git a/fastboot_app/utils/gpio.c b/fastboot_app/utils/gpio.c
new file mode 100644
index 0000000..21da615
--- /dev/null
+++ b/fastboot_app/utils/gpio.c
@@ -0,0 +1,190 @@
+/*
+ * gpio.c
+ *
+ * History:
+ *       2015/03/16 - [Chu Chen] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <unistd.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <basetypes.h>
+
+#include "bpi_utils.h"
+
+#define MAX_LENGTH_GPIO_PATH 128
+
+#define GPIO_PORT_SHUTDOWN 112
+#define GPIO_PORT_BOOTMOOD_0 92//PC1
+#define GPIO_PORT_BOOTMOOD_1 91//PB7
+#define GPIO_PORT_BOOTMOOD_2 38//PB8
+
+#define GPIO_SET 49
+#define GPIO_CLEAR 48
+
+static int gpio_write(int gpio, u8 value)
+{
+    int fd_gpio = -1;
+    int length = 0;
+    char path[MAX_LENGTH_GPIO_PATH] = {0};
+
+    //export gpio
+    char gpio_num[32] = {0};
+    fd_gpio = open("/sys/class/gpio/export", O_WRONLY, 0);
+    if (fd_gpio < 0) {
+        perror("open /sys/class/gpio/export");
+        return -1;
+    }
+    length = snprintf(gpio_num, 32, "%d", gpio);
+    write(fd_gpio, gpio_num, length);
+    close(fd_gpio);
+
+    //direction
+    char gpio_direction[] = "out";//sw mode
+    snprintf(path, MAX_LENGTH_GPIO_PATH, "/sys/class/gpio/gpio%d/direction", gpio);
+    fd_gpio = open(path, O_WRONLY, 0);
+    if (fd_gpio < 0) {
+        perror("open gpio direction");
+        return -1;
+    }
+    write(fd_gpio, gpio_direction, strlen(gpio_direction));
+    close(fd_gpio);
+
+    //value
+    snprintf(path, MAX_LENGTH_GPIO_PATH, "/sys/class/gpio/gpio%d/value", gpio);
+    fd_gpio = open(path, O_WRONLY, 0);
+    if (fd_gpio < 0) {
+        perror("open gpio value");
+        return -1;
+    }
+    write(fd_gpio, &value, 1);
+    close(fd_gpio);
+
+    return 0;
+}
+
+static int gpio_read(int gpio, u8* value)
+{
+    int fd_gpio = -1;
+    int length = 0;
+    char path[MAX_LENGTH_GPIO_PATH] = {0};
+
+    *value = 0;
+
+    //export gpio
+    char gpio_num[32] = {0};
+    fd_gpio = open("/sys/class/gpio/export", O_WRONLY, 0);
+    if (fd_gpio < 0) {
+        perror("open /sys/class/gpio/export");
+        return -1;
+    }
+    length = snprintf(gpio_num, 32, "%d", gpio);
+    write(fd_gpio, gpio_num, length);
+    close(fd_gpio);
+
+    //direction
+    char gpio_direction[] = "in";//sw mode
+    snprintf(path, MAX_LENGTH_GPIO_PATH, "/sys/class/gpio/gpio%d/direction", gpio);
+    fd_gpio = open(path, O_WRONLY, 0);
+    if (fd_gpio < 0) {
+        perror("open gpio direction");
+        return -1;
+    }
+    write(fd_gpio, gpio_direction, strlen(gpio_direction));
+    close(fd_gpio);
+
+    //value
+    snprintf(path, MAX_LENGTH_GPIO_PATH, "/sys/class/gpio/gpio%d/value", gpio);
+    fd_gpio = open(path, O_RDONLY, 0);
+    if (fd_gpio < 0) {
+        perror("open gpio value");
+        return -1;
+    }
+    read(fd_gpio, value, 1);
+    close(fd_gpio);
+
+    return 0;
+}
+//////////////////////////////////////////////////////////////////////
+void shut_down()
+{
+    sync();
+    usleep(500000);
+    while (1) {
+        gpio_write(GPIO_PORT_SHUTDOWN, (u8)'1');
+        usleep(50000);
+    }
+    return;
+}
+
+void reset_wifi_chip()
+{
+    gpio_write(GPIO_PORT_SHUTDOWN, (u8)'1');
+    usleep(100000);
+    gpio_write(GPIO_PORT_SHUTDOWN, (u8)'0');
+    return;
+}
+
+int check_boot_mode()
+{
+    //TODO
+    u8 value = 0;
+    int mode = 0;
+
+    if (gpio_read(GPIO_PORT_BOOTMOOD_0, &value) != 0) {
+        LOG_ERROR("gpio_read gpio 92 fail\n");
+        return mode;
+    }
+
+    if (value == GPIO_SET) {
+        mode |= 1;
+    }
+
+    if (gpio_read(GPIO_PORT_BOOTMOOD_1, &value) != 0) {
+        LOG_ERROR("gpio_read gpio 91 fail\n");
+        return mode;
+    }
+
+    if (value == GPIO_SET) {
+        mode |= 1 << 1;
+    }
+
+    if (gpio_read(GPIO_PORT_BOOTMOOD_2, &value) != 0) {
+        LOG_ERROR("gpio_read gpio 38 fail\n");
+        return mode;
+    }
+
+    if (value == GPIO_SET) {
+        mode |= 1 << 2;
+    }
+
+    return mode;
+}
diff --git a/fastboot_app/utils/make.inc b/fastboot_app/utils/make.inc
new file mode 100644
index 0000000..f0ef537
--- /dev/null
+++ b/fastboot_app/utils/make.inc
@@ -0,0 +1,151 @@
+#
+# make.inc
+#
+# History:
+#       2016/06/01 - [cz Lin] created file
+#
+# Copyright (c) 2015 Ambarella, Inc.
+#
+# This file and its contents ("Software") are protected by intellectual
+# property rights including, without limitation, U.S. and/or foreign
+# copyrights. This Software is also the confidential and proprietary
+# information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+# disclose, distribute, modify, or otherwise prepare derivative works of this
+# Software or any portion thereof except pursuant to a signed license agreement
+# or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+# In the absence of such an agreement, you agree to promptly notify and return
+# this Software to Ambarella, Inc.
+#
+# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+# MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+# IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+#
+
+LOCAL_PATH   := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+IPCAM_APP_LIB_DIR	:= $(FAKEROOT_DIR)/usr/lib
+INLCUDE			:= $(AMB_TOPDIR)/include
+
+LOCAL_TARGET	:= libbpiUtils.so
+LOCAL_SRCS  := $(wildcard $(LOCAL_PATH)/*.c*)
+
+LOCAL_CFLAGS	:= -I$(LOCAL_PATH) \
+		-I$(INLCUDE)
+LOCAL_CFLAGS	+= -std=c++11 -Werror
+LOCAL_SO_NAME := $(LOCAL_TARGET)
+
+include $(BUILD_APP)
+
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(IPCAM_APP_LIB_DIR)/
+	@cp -dpRf $< $(IPCAM_APP_LIB_DIR)/
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+
+###################
+include $(CLEAR_VARS)
+IPCAM_APP_LIB_DIR	:= $(FAKEROOT_DIR)/usr/lib
+INLCUDE			:= $(AMB_TOPDIR)/include
+
+LOCAL_TARGET	:= libaplayAudio.so
+LOCAL_SRCS  := $(wildcard $(LOCAL_PATH)/aplay/*.c)
+
+LOCAL_CFLAGS	:= -I$(LOCAL_PATH) \
+	-I$(INLCUDE)
+
+LOCAL_LDFLAGS	:= -lpthread
+ifeq ($(CONFIG_AMBARELLA_ALSA_SUPPORT), y)
+LOCAL_CFLAGS	+= -DAUDIO_INPUT_ALSA_SUPPORTED=1 -I$(PREBUILD_3RD_PARTY_DIR)/alsa-lib/include
+LOCAL_LDFLAGS	+= -L$(PREBUILD_3RD_PARTY_DIR)/alsa-lib/usr/lib -lasound
+endif
+
+ifeq ($(CONFIG_S2LMELEKTRA_WM8974), y)
+LOCAL_CFLAGS  += -DCONFIG_ELEKTRA_CODEC_WM8974
+else ifeq ($(CONFIG_ELEKTRAS_AK7755), y)
+LOCAL_CFLAGS  += -DCONFIG_ELEKTRA_CODEC_AK7755
+endif
+
+LOCAL_SO_NAME := $(LOCAL_TARGET)
+
+include $(BUILD_APP)
+
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(IPCAM_APP_LIB_DIR)/
+	@cp -dpRf $< $(IPCAM_APP_LIB_DIR)/
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+
+ifeq ($(CONFIG_BPI_APP_HIBERNATION), y)
+###################
+## libbpiUbi.so
+###################
+include $(CLEAR_VARS)
+IPCAM_APP_LIB_DIR	:= $(FAKEROOT_DIR)/usr/lib
+
+LOCAL_TARGET	:= libbpiUbi.so
+LOCAL_SRCS  := $(wildcard $(LOCAL_PATH)/ubi/*.c)
+
+LOCAL_CFLAGS	:= -I$(LOCAL_PATH)/ubi
+LOCAL_SO_NAME := $(LOCAL_TARGET)
+
+
+include $(BUILD_APP)
+
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(IPCAM_APP_LIB_DIR)/
+	@cp -dpRf $< $(IPCAM_APP_LIB_DIR)/
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+
+
+###################
+## libbpiAdc.so
+###################
+include $(CLEAR_VARS)
+IPCAM_APP_LIB_DIR	:= $(FAKEROOT_DIR)/usr/lib
+
+LOCAL_TARGET	:= libbpiAdc.so
+LOCAL_SRCS  := $(wildcard $(LOCAL_PATH)/adc/*.c)
+
+
+LOCAL_CFLAGS	:= -I$(LOCAL_PATH)/adc \
+		-I$(AMB_TOPDIR)/amboot/include \
+		-I$(AMB_TOPDIR)/app/utility/upgrade_partition
+
+LOCAL_CFLAGS	+= -Werror
+LOCAL_SO_NAME := $(LOCAL_TARGET)
+
+
+include $(BUILD_APP)
+
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(IPCAM_APP_LIB_DIR)/
+	@cp -dpRf $< $(IPCAM_APP_LIB_DIR)/
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+
+endif
+
diff --git a/fastboot_app/utils/ubi/bpi_ubi.h b/fastboot_app/utils/ubi/bpi_ubi.h
new file mode 100644
index 0000000..2bf1358
--- /dev/null
+++ b/fastboot_app/utils/ubi/bpi_ubi.h
@@ -0,0 +1,45 @@
+/*
+ * bpi_ubi.h
+ *
+ * History:
+ *       2017/03/01 - [CZ Lin] created file
+ *
+ * Copyright (c) 2017 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef BPI_UBI_H__
+#define BPI_UBI_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+int bpi_ubi_attach(int devn, int mtdn);
+int bpi_ubi_detach(int devn, int mtdn);
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif
diff --git a/fastboot_app/utils/ubi/common.h b/fastboot_app/utils/ubi/common.h
new file mode 100644
index 0000000..d0c4146
--- /dev/null
+++ b/fastboot_app/utils/ubi/common.h
@@ -0,0 +1,155 @@
+/*
+ * Copyright (c) Artem Bityutskiy, 2007, 2008
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __MTD_UTILS_COMMON_H__
+#define __MTD_UTILS_COMMON_H__
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <features.h>
+#include <inttypes.h>
+#include "version.h"
+
+#ifndef PROGRAM_NAME
+# error "You must define PROGRAM_NAME before including this header"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef MIN	/* some C lib headers define this for us */
+#define MIN(a, b) ((a) < (b) ? (a) : (b))
+#endif
+#ifndef MAX
+#define MAX(a, b) ((a) > (b) ? (a) : (b))
+#endif
+#define min(a, b) MIN(a, b) /* glue for linux kernel source */
+#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
+
+#ifndef O_CLOEXEC
+#define O_CLOEXEC 0
+#endif
+
+/* define a print format specifier for off_t */
+#ifdef __USE_FILE_OFFSET64
+#define PRIxoff_t PRIx64
+#define PRIdoff_t PRId64
+#else
+#define PRIxoff_t "l"PRIx32
+#define PRIdoff_t "l"PRId32
+#endif
+
+/* Verbose messages */
+#define bareverbose(verbose, fmt, ...) do {                        \
+	if (verbose)                                               \
+		printf(fmt, ##__VA_ARGS__);                        \
+} while(0)
+#define verbose(verbose, fmt, ...) \
+	bareverbose(verbose, "%s: " fmt "\n", PROGRAM_NAME, ##__VA_ARGS__)
+
+/* Normal messages */
+#define normsg_cont(fmt, ...) do {                                 \
+	printf("%s: " fmt, PROGRAM_NAME, ##__VA_ARGS__);           \
+} while(0)
+#define normsg(fmt, ...) do {                                      \
+	normsg_cont(fmt "\n", ##__VA_ARGS__);                      \
+} while(0)
+
+/* Error messages */
+#define errmsg(fmt, ...)  ({                                                \
+	fprintf(stderr, "%s: error!: " fmt "\n", PROGRAM_NAME, ##__VA_ARGS__); \
+	-1;                                                                 \
+})
+#define errmsg_die(fmt, ...) do {                                           \
+	exit(errmsg(fmt, ##__VA_ARGS__));                                   \
+} while(0)
+
+/* System error messages */
+#define sys_errmsg(fmt, ...)  ({                                            \
+	int _err = errno;                                                   \
+	errmsg(fmt, ##__VA_ARGS__);                                         \
+	fprintf(stderr, "%*serror %d (%s)\n", (int)sizeof(PROGRAM_NAME) + 1,\
+		"", _err, strerror(_err));                                  \
+	-1;                                                                 \
+})
+#define sys_errmsg_die(fmt, ...) do {                                       \
+	exit(sys_errmsg(fmt, ##__VA_ARGS__));                               \
+} while(0)
+
+/* Warnings */
+#define warnmsg(fmt, ...) do {                                                \
+	fprintf(stderr, "%s: warning!: " fmt "\n", PROGRAM_NAME, ##__VA_ARGS__); \
+} while(0)
+
+static inline int is_power_of_2(unsigned long long n)
+{
+	        return (n != 0 && ((n & (n - 1)) == 0));
+}
+
+/**
+ * simple_strtoX - convert a hex/dec/oct string into a number
+ * @snum: buffer to convert
+ * @error: set to 1 when buffer isn't fully consumed
+ *
+ * These functions are similar to the standard strtoX() functions, but they are
+ * a little bit easier to use if you want to convert full string of digits into
+ * the binary form. The typical usage:
+ *
+ * int error = 0;
+ * unsigned long num;
+ *
+ * num = simple_strtoul(str, &error);
+ * if (error || ... if needed, your check that num is not out of range ...)
+ * 	error_happened();
+ */
+#define simple_strtoX(func, type) \
+static inline type simple_##func(const char *snum, int *error) \
+{ \
+	char *endptr; \
+	type ret = func(snum, &endptr, 0); \
+ \
+	if (error && (!*snum || *endptr)) { \
+		errmsg("%s: unable to parse the number '%s'", #func, snum); \
+		*error = 1; \
+	} \
+ \
+	return ret; \
+}
+simple_strtoX(strtol, long int)
+simple_strtoX(strtoll, long long int)
+simple_strtoX(strtoul, unsigned long int)
+simple_strtoX(strtoull, unsigned long long int)
+
+/* Simple version-printing for utils */
+#define common_print_version() \
+do { \
+	printf("%s %s\n", PROGRAM_NAME, VERSION); \
+} while (0)
+
+#include "xalloc.h"
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !__MTD_UTILS_COMMON_H__ */
diff --git a/fastboot_app/utils/ubi/libubi.c b/fastboot_app/utils/ubi/libubi.c
new file mode 100644
index 0000000..d292bd1
--- /dev/null
+++ b/fastboot_app/utils/ubi/libubi.c
@@ -0,0 +1,1377 @@
+/*
+ * Copyright (c) International Business Machines Corp., 2006
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Author: Artem Bityutskiy
+ *
+ * UBI (Unsorted Block Images) library.
+ */
+
+#define PROGRAM_NAME "libubi"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+#include <dirent.h>
+#include <unistd.h>
+#include <limits.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <sys/sysmacros.h>
+#include <libubi.h>
+#include "libubi_int.h"
+#include "common.h"
+
+/**
+ * mkpath - compose full path from 2 given components.
+ * @path: the first component
+ * @name: the second component
+ *
+ * This function returns the resulting path in case of success and %NULL in
+ * case of failure.
+ */
+static char *mkpath(const char *path, const char *name)
+{
+	char *n;
+	int len1 = strlen(path);
+	int len2 = strlen(name);
+
+	n = malloc(len1 + len2 + 2);
+	if (!n) {
+		sys_errmsg("cannot allocate %d bytes", len1 + len2 + 2);
+		return NULL;
+	}
+
+	memcpy(n, path, len1);
+	if (n[len1 - 1] != '/')
+		n[len1++] = '/';
+
+	memcpy(n + len1, name, len2 + 1);
+	return n;
+}
+
+/**
+ * read_positive_ll - read a positive 'long long' value from a file.
+ * @file: the file to read from
+ * @value: the result is stored here
+ *
+ * This function reads file @file and interprets its contents as a positive
+ * 'long long' integer. If this is not true, it fails with %EINVAL error code.
+ * Returns %0 in case of success and %-1 in case of failure.
+ */
+static int read_positive_ll(const char *file, long long *value)
+{
+	int fd, rd;
+	char buf[50];
+
+	fd = open(file, O_RDONLY);
+	if (fd == -1)
+		return -1;
+
+	rd = read(fd, buf, sizeof(buf));
+	if (rd == -1) {
+		sys_errmsg("cannot read \"%s\"", file);
+		goto out_error;
+	}
+	if (rd == sizeof(buf)) {
+		errmsg("contents of \"%s\" is too long", file);
+		errno = EINVAL;
+		goto out_error;
+	}
+	buf[rd] = '\0';
+
+	if (sscanf(buf, "%lld\n", value) != 1) {
+		errmsg("cannot read integer from \"%s\"\n", file);
+		errno = EINVAL;
+		goto out_error;
+	}
+
+	if (*value < 0) {
+		errmsg("negative value %lld in \"%s\"", *value, file);
+		errno = EINVAL;
+		goto out_error;
+	}
+
+	if (close(fd))
+		return sys_errmsg("close failed on \"%s\"", file);
+
+	return 0;
+
+out_error:
+	close(fd);
+	return -1;
+}
+
+/**
+ * read_positive_int - read a positive 'int' value from a file.
+ * @file: the file to read from
+ * @value: the result is stored here
+ *
+ * This function is the same as 'read_positive_ll()', but it reads an 'int'
+ * value, not 'long long'.
+ */
+static int read_positive_int(const char *file, int *value)
+{
+	long long res;
+
+	if (read_positive_ll(file, &res))
+		return -1;
+
+	/* Make sure the value is not too big */
+	if (res > INT_MAX) {
+		errmsg("value %lld read from file \"%s\" is out of range",
+		       res, file);
+		errno = EINVAL;
+		return -1;
+	}
+
+	*value = res;
+	return 0;
+}
+
+/**
+ * read_data - read data from a file.
+ * @file: the file to read from
+ * @buf: the buffer to read to
+ * @buf_len: buffer length
+ *
+ * This function returns number of read bytes in case of success and %-1 in
+ * case of failure. Note, if the file contains more then @buf_len bytes of
+ * date, this function fails with %EINVAL error code.
+ */
+static int read_data(const char *file, void *buf, int buf_len)
+{
+	int fd, rd, tmp, tmp1;
+
+	fd = open(file, O_RDONLY);
+	if (fd == -1)
+		return -1;
+
+	rd = read(fd, buf, buf_len);
+	if (rd == -1) {
+		sys_errmsg("cannot read \"%s\"", file);
+		goto out_error;
+	}
+
+	if (rd == buf_len) {
+		errmsg("contents of \"%s\" is too long", file);
+		errno = EINVAL;
+		goto out_error;
+	}
+
+	((char *)buf)[rd] = '\0';
+
+	/* Make sure all data is read */
+	tmp1 = read(fd, &tmp, 1);
+	if (tmp1 == 1) {
+		sys_errmsg("cannot read \"%s\"", file);
+		goto out_error;
+	}
+	if (tmp1) {
+		errmsg("file \"%s\" contains too much data (> %d bytes)",
+		       file, buf_len);
+		errno = EINVAL;
+		goto out_error;
+	}
+
+	if (close(fd)) {
+		sys_errmsg("close failed on \"%s\"", file);
+		return -1;
+	}
+
+	return rd;
+
+out_error:
+	close(fd);
+	return -1;
+}
+
+/**
+ * read_major - read major and minor numbers from a file.
+ * @file: name of the file to read from
+ * @major: major number is returned here
+ * @minor: minor number is returned here
+ *
+ * This function returns % in case of succes, and %-1 in case of failure.
+ */
+static int read_major(const char *file, int *major, int *minor)
+{
+	int ret;
+	char buf[50];
+
+	ret = read_data(file, buf, 50);
+	if (ret < 0)
+		return ret;
+
+	ret = sscanf(buf, "%d:%d\n", major, minor);
+	if (ret != 2) {
+		errno = EINVAL;
+		return errmsg("\"%s\" does not have major:minor format", file);
+	}
+
+	if (*major < 0 || *minor < 0) {
+		errno = EINVAL;
+		return errmsg("bad major:minor %d:%d in \"%s\"",
+			      *major, *minor, file);
+	}
+
+	return 0;
+}
+
+/**
+ * dev_read_int - read a positive 'int' value from an UBI device sysfs file.
+ * @patt: file pattern to read from
+ * @dev_num: UBI device number
+ * @value: the result is stored here
+ *
+ * This function returns %0 in case of success and %-1 in case of failure.
+ */
+static int dev_read_int(const char *patt, int dev_num, int *value)
+{
+	char file[strlen(patt) + 50];
+
+	sprintf(file, patt, dev_num);
+	return read_positive_int(file, value);
+}
+
+/**
+ * vol_read_int - read a positive 'int' value from an UBI volume sysfs file.
+ * @patt: file pattern to read from
+ * @dev_num: UBI device number
+ * @vol_id: volume ID
+ * @value: the result is stored here
+ *
+ * This function returns %0 in case of success and %-1 in case of failure.
+ */
+static int vol_read_int(const char *patt, int dev_num, int vol_id, int *value)
+{
+	char file[strlen(patt) + 100];
+
+	sprintf(file, patt, dev_num, vol_id);
+	return read_positive_int(file, value);
+}
+
+/**
+ * dev_read_ll - read a positive 'long long' value from an UBI device sysfs file.
+ * @patt: file pattern to read from
+ * @dev_num: UBI device number
+ * @value: the result is stored here
+ *
+ * This function returns %0 in case of success and %-1 in case of failure.
+ */
+static int dev_read_ll(const char *patt, int dev_num, long long *value)
+{
+	char file[strlen(patt) + 50];
+
+	sprintf(file, patt, dev_num);
+	return read_positive_ll(file, value);
+}
+
+/**
+ * vol_read_ll - read a positive 'long long' value from an UBI volume sysfs file.
+ * @patt: file pattern to read from
+ * @dev_num: UBI device number
+ * @vol_id: volume ID
+ * @value: the result is stored here
+ *
+ * This function returns %0 in case of success and %-1 in case of failure.
+ */
+static int vol_read_ll(const char *patt, int dev_num, int vol_id,
+		       long long *value)
+{
+	char file[strlen(patt) + 100];
+
+	sprintf(file, patt, dev_num, vol_id);
+	return read_positive_ll(file, value);
+}
+
+/**
+ * vol_read_data - read data from an UBI volume's sysfs file.
+ * @patt: file pattern to read from
+ * @dev_num: UBI device number
+ * @vol_id: volume ID
+ * @buf: buffer to read to
+ * @buf_len: buffer length
+ *
+ * This function returns number of read bytes in case of success and %-1 in
+ * case of failure.
+ */
+static int vol_read_data(const char *patt, int dev_num, int vol_id, void *buf,
+			 int buf_len)
+{
+	char file[strlen(patt) + 100];
+
+	sprintf(file, patt, dev_num, vol_id);
+	return read_data(file, buf, buf_len);
+}
+
+/**
+ * dev_get_major - get major and minor numbers of an UBI device.
+ * @lib: libubi descriptor
+ * @dev_num: UBI device number
+ * @major: major number is returned here
+ * @minor: minor number is returned here
+ *
+ * This function returns zero in case of succes and %-1 in case of failure.
+ */
+static int dev_get_major(struct libubi *lib, int dev_num, int *major, int *minor)
+{
+	char file[strlen(lib->dev_dev) + 50];
+
+	sprintf(file, lib->dev_dev, dev_num);
+	return read_major(file, major, minor);
+}
+
+/**
+ * vol_get_major - get major and minor numbers of an UBI volume.
+ * @lib: libubi descriptor
+ * @dev_num: UBI device number
+ * @vol_id: volume ID
+ * @major: major number is returned here
+ * @minor: minor number is returned here
+ *
+ * This function returns zero in case of succes and %-1 in case of failure.
+ */
+static int vol_get_major(struct libubi *lib, int dev_num, int vol_id,
+			 int *major, int *minor)
+{
+	char file[strlen(lib->vol_dev) + 100];
+
+	sprintf(file, lib->vol_dev, dev_num, vol_id);
+	return read_major(file, major, minor);
+}
+
+/**
+ * vol_node2nums - find UBI device number and volume ID by volume device node
+ *                 file.
+ * @lib: UBI library descriptor
+ * @node: UBI character device node name
+ * @dev_num: UBI device number is returned here
+ * @vol_id: volume ID is returned hers
+ *
+ * This function returns zero in case of succes and %-1 in case of failure.
+ */
+static int vol_node2nums(struct libubi *lib, const char *node, int *dev_num,
+			 int *vol_id)
+{
+	struct stat st;
+	struct ubi_info info;
+	int i, fd, major, minor;
+	char file[strlen(lib->ubi_vol) + 100];
+
+	if (stat(node, &st))
+		return sys_errmsg("cannot get information about \"%s\"",
+				  node);
+
+	if (!S_ISCHR(st.st_mode)) {
+		errno = EINVAL;
+		return errmsg("\"%s\" is not a character device", node);
+	}
+
+	major = major(st.st_rdev);
+	minor = minor(st.st_rdev);
+
+	if (minor == 0) {
+		errno = EINVAL;
+		return errmsg("\"%s\" is not a volume character device", node);
+	}
+
+	if (ubi_get_info((libubi_t *)lib, &info))
+		return -1;
+
+	for (i = info.lowest_dev_num; i <= info.highest_dev_num; i++) {
+		int major1, minor1, ret;
+
+		ret = dev_get_major(lib, i, &major1, &minor1);
+		if (ret) {
+			if (errno == ENOENT)
+				continue;
+			return -1;
+		}
+
+		if (major1 == major)
+			break;
+	}
+
+	if (i > info.highest_dev_num) {
+		errno = ENODEV;
+		return -1;
+	}
+
+	/* Make sure this UBI volume exists */
+	sprintf(file, lib->ubi_vol, i, minor - 1);
+	fd = open(file, O_RDONLY);
+	if (fd == -1) {
+		errno = ENODEV;
+		return -1;
+	}
+
+	*dev_num = i;
+	*vol_id = minor - 1;
+	errno = 0;
+	return 0;
+}
+
+/**
+ * dev_node2num - find UBI device number by its character device node.
+ * @lib: UBI library descriptor
+ * @node: UBI character device node name
+ * @dev_num: UBI device number is returned here
+ *
+ * This function returns %0 in case of success and %-1 in case of failure.
+ */
+static int dev_node2num(struct libubi *lib, const char *node, int *dev_num)
+{
+	struct stat st;
+	struct ubi_info info;
+	int i, major, minor;
+
+	if (stat(node, &st))
+		return sys_errmsg("cannot get information about \"%s\"", node);
+
+	if (!S_ISCHR(st.st_mode)) {
+		errno = EINVAL;
+		return errmsg("\"%s\" is not a character device", node);
+	}
+
+	major = major(st.st_rdev);
+	minor = minor(st.st_rdev);
+
+	if (minor != 0) {
+		errno = EINVAL;
+		return errmsg("\"%s\" is not an UBI character device", node);
+	}
+
+	if (ubi_get_info((libubi_t *)lib, &info))
+		return -1;
+
+	for (i = info.lowest_dev_num; i <= info.highest_dev_num; i++) {
+		int major1, minor1, ret;
+
+		ret = dev_get_major(lib, i, &major1, &minor1);
+		if (ret) {
+			if (errno == ENOENT)
+				continue;
+			return -1;
+		}
+
+		if (major1 == major) {
+			if (minor1 != 0) {
+				errmsg("UBI character device minor number is "
+				       "%d, but must be 0", minor1);
+				errno = EINVAL;
+				return -1;
+			}
+			errno = 0;
+			*dev_num = i;
+			return 0;
+		}
+	}
+
+	errno = ENODEV;
+	return -1;
+}
+
+int mtd_num2ubi_dev(libubi_t desc, int mtd_num, int *dev_num)
+{
+	struct ubi_info info;
+	int i, ret, mtd_num1;
+	struct libubi *lib = desc;
+
+	if (ubi_get_info(desc, &info))
+		return -1;
+
+	for (i = info.lowest_dev_num; i <= info.highest_dev_num; i++) {
+		ret = dev_read_int(lib->dev_mtd_num, i, &mtd_num1);
+		if (ret) {
+			if (errno == ENOENT)
+				continue;
+			return -1;
+		}
+
+		if (mtd_num1 == mtd_num) {
+			errno = 0;
+			*dev_num = i;
+			return 0;
+		}
+	}
+
+	errno = 0;
+	return -1;
+}
+
+libubi_t libubi_open(void)
+{
+	int fd, version;
+	struct libubi *lib;
+
+	lib = calloc(1, sizeof(struct libubi));
+	if (!lib)
+		return NULL;
+
+	lib->sysfs_ctrl = mkpath("/sys", SYSFS_CTRL);
+	if (!lib->sysfs_ctrl)
+		goto out_error;
+
+	lib->ctrl_dev = mkpath(lib->sysfs_ctrl, CTRL_DEV);
+	if (!lib->ctrl_dev)
+		goto out_error;
+
+	lib->sysfs_ubi = mkpath("/sys", SYSFS_UBI);
+	if (!lib->sysfs_ubi)
+		goto out_error;
+
+	/* Make sure UBI is present */
+	fd = open(lib->sysfs_ubi, O_RDONLY);
+	if (fd == -1) {
+		errno = 0;
+		goto out_error;
+	}
+
+	if (close(fd)) {
+		sys_errmsg("close failed on \"%s\"", lib->sysfs_ubi);
+		goto out_error;
+	}
+
+	lib->ubi_dev = mkpath(lib->sysfs_ubi, UBI_DEV_NAME_PATT);
+	if (!lib->ubi_dev)
+		goto out_error;
+
+	lib->ubi_version = mkpath(lib->sysfs_ubi, UBI_VER);
+	if (!lib->ubi_version)
+		goto out_error;
+
+	lib->dev_dev = mkpath(lib->ubi_dev, DEV_DEV);
+	if (!lib->dev_dev)
+		goto out_error;
+
+	lib->dev_avail_ebs = mkpath(lib->ubi_dev, DEV_AVAIL_EBS);
+	if (!lib->dev_avail_ebs)
+		goto out_error;
+
+	lib->dev_total_ebs = mkpath(lib->ubi_dev, DEV_TOTAL_EBS);
+	if (!lib->dev_total_ebs)
+		goto out_error;
+
+	lib->dev_bad_count = mkpath(lib->ubi_dev, DEV_BAD_COUNT);
+	if (!lib->dev_bad_count)
+		goto out_error;
+
+	lib->dev_eb_size = mkpath(lib->ubi_dev, DEV_EB_SIZE);
+	if (!lib->dev_eb_size)
+		goto out_error;
+
+	lib->dev_max_ec = mkpath(lib->ubi_dev, DEV_MAX_EC);
+	if (!lib->dev_max_ec)
+		goto out_error;
+
+	lib->dev_bad_rsvd = mkpath(lib->ubi_dev, DEV_MAX_RSVD);
+	if (!lib->dev_bad_rsvd)
+		goto out_error;
+
+	lib->dev_max_vols = mkpath(lib->ubi_dev, DEV_MAX_VOLS);
+	if (!lib->dev_max_vols)
+		goto out_error;
+
+	lib->dev_min_io_size = mkpath(lib->ubi_dev, DEV_MIN_IO_SIZE);
+	if (!lib->dev_min_io_size)
+		goto out_error;
+
+	lib->dev_mtd_num = mkpath(lib->ubi_dev, DEV_MTD_NUM);
+	if (!lib->dev_mtd_num)
+		goto out_error;
+
+	lib->ubi_vol = mkpath(lib->sysfs_ubi, UBI_VOL_NAME_PATT);
+	if (!lib->ubi_vol)
+		goto out_error;
+
+	lib->vol_type = mkpath(lib->ubi_vol, VOL_TYPE);
+	if (!lib->vol_type)
+		goto out_error;
+
+	lib->vol_dev = mkpath(lib->ubi_vol, VOL_DEV);
+	if (!lib->vol_dev)
+		goto out_error;
+
+	lib->vol_alignment = mkpath(lib->ubi_vol, VOL_ALIGNMENT);
+	if (!lib->vol_alignment)
+		goto out_error;
+
+	lib->vol_data_bytes = mkpath(lib->ubi_vol, VOL_DATA_BYTES);
+	if (!lib->vol_data_bytes)
+		goto out_error;
+
+	lib->vol_rsvd_ebs = mkpath(lib->ubi_vol, VOL_RSVD_EBS);
+	if (!lib->vol_rsvd_ebs)
+		goto out_error;
+
+	lib->vol_eb_size = mkpath(lib->ubi_vol, VOL_EB_SIZE);
+	if (!lib->vol_eb_size)
+		goto out_error;
+
+	lib->vol_corrupted = mkpath(lib->ubi_vol, VOL_CORRUPTED);
+	if (!lib->vol_corrupted)
+		goto out_error;
+
+	lib->vol_name = mkpath(lib->ubi_vol, VOL_NAME);
+	if (!lib->vol_name)
+		goto out_error;
+
+	if (read_positive_int(lib->ubi_version, &version))
+		goto out_error;
+	if (version != LIBUBI_UBI_VERSION) {
+		errmsg("this library was made for UBI version %d, but UBI "
+		       "version %d is detected\n", LIBUBI_UBI_VERSION, version);
+		goto out_error;
+	}
+
+	return lib;
+
+out_error:
+	libubi_close((libubi_t)lib);
+	return NULL;
+}
+
+void libubi_close(libubi_t desc)
+{
+	struct libubi *lib = (struct libubi *)desc;
+
+	free(lib->vol_name);
+	free(lib->vol_corrupted);
+	free(lib->vol_eb_size);
+	free(lib->vol_rsvd_ebs);
+	free(lib->vol_data_bytes);
+	free(lib->vol_alignment);
+	free(lib->vol_dev);
+	free(lib->vol_type);
+	free(lib->ubi_vol);
+	free(lib->dev_mtd_num);
+	free(lib->dev_min_io_size);
+	free(lib->dev_max_vols);
+	free(lib->dev_bad_rsvd);
+	free(lib->dev_max_ec);
+	free(lib->dev_eb_size);
+	free(lib->dev_bad_count);
+	free(lib->dev_total_ebs);
+	free(lib->dev_avail_ebs);
+	free(lib->dev_dev);
+	free(lib->ubi_version);
+	free(lib->ubi_dev);
+	free(lib->sysfs_ubi);
+	free(lib->ctrl_dev);
+	free(lib->sysfs_ctrl);
+	free(lib);
+}
+
+/**
+ * do_attach - perform the actual attach operation.
+ * @node: name of the UBI control character device node
+ * @r: attach request
+ *
+ * This function performs the actual UBI attach operation. Returns %0 in case of
+ * success and %-1 in case of failure. @r->ubi_num contains newly created UBI
+ * device number.
+ */
+static int do_attach(const char *node, const struct ubi_attach_req *r)
+{
+	int fd, ret;
+
+	fd = open(node, O_RDONLY);
+	if (fd == -1)
+		return sys_errmsg("cannot open \"%s\"", node);
+
+	ret = ioctl(fd, UBI_IOCATT, r);
+	close(fd);
+	if (ret == -1)
+		return -1;
+
+#ifdef UDEV_SETTLE_HACK
+//	if (system("udevsettle") == -1)
+//		return -1;
+	usleep(100000);
+#endif
+	return ret;
+}
+
+#ifndef MTD_CHAR_MAJOR
+/*
+ * This is taken from kernel <linux/mtd/mtd.h> and is unlikely to change anytime
+ * soon.
+ */
+#define MTD_CHAR_MAJOR 90
+#endif
+
+/**
+ * mtd_node_to_num - converts device node to MTD number.
+ * @mtd_dev_node: path to device node to convert
+ *
+ * This function converts given @mtd_dev_node to MTD device number.
+ * @mtd_dev_node should contain path to the MTD device node. Returns MTD device
+ * number in case of success and %-1 in case of failure (errno is set).
+ */
+static int mtd_node_to_num(const char *mtd_dev_node)
+{
+	int major, minor;
+	struct stat sb;
+
+	if (stat(mtd_dev_node, &sb) < 0)
+		return sys_errmsg("cannot stat \"%s\"", mtd_dev_node);
+
+	if (!S_ISCHR(sb.st_mode)) {
+		errno = EINVAL;
+		return sys_errmsg("\"%s\" is not a character device",
+				  mtd_dev_node);
+	}
+
+	major = major(sb.st_rdev);
+	minor = minor(sb.st_rdev);
+
+	if (major != MTD_CHAR_MAJOR) {
+		errno = EINVAL;
+		return sys_errmsg("\"%s\" is not an MTD device", mtd_dev_node);
+	}
+
+	return minor / 2;
+}
+
+int ubi_attach(libubi_t desc, const char *node, struct ubi_attach_request *req)
+{
+	struct ubi_attach_req r;
+	int ret;
+
+	(void)desc;
+
+	if (req->mtd_dev_node) {
+		/*
+		 * User has passed path to device node. Lets find out MTD
+		 * device number of the device and update req->mtd_num with it
+		 */
+		req->mtd_num = mtd_node_to_num(req->mtd_dev_node);
+		if (req->mtd_num == -1)
+			return -1;
+	}
+
+	memset(&r, 0, sizeof(struct ubi_attach_req));
+	r.ubi_num = req->dev_num;
+	r.mtd_num = req->mtd_num;
+	r.vid_hdr_offset = req->vid_hdr_offset;
+
+	if (req->max_beb_per1024) {
+		/*
+		 * We first have to check if the running kernel supports the
+		 * 'max_beb_per1024' parameter. To do this, we invoke the
+		 * "attach" ioctl 2 times: first with incorrect value %-1 of
+		 * 'max_beb_per1024'.
+		 *
+		 * If the ioctl succeeds, it means that the kernel doesn't
+		 * support the feature and just ignored our 'max_beb_per1024'
+		 * value.
+		 *
+		 * If the ioctl returns -EINVAL, we assume this is because
+		 * 'max_beb_per1024' was set to -1, and we invoke the ioctl for
+		 * the second time with the 'max_beb_per1024' value.
+		 */
+		r.max_beb_per1024 = -1;
+		ret = do_attach(node, &r);
+		if (ret == 0) {
+			req->dev_num = r.ubi_num;
+			/*
+			 * The call succeeded. It means that the kernel ignored
+			 * 'max_beb_per1024' parameter. 
+			 */
+			return 1;
+		} else if (errno != EINVAL)
+			return ret;
+	}
+
+	r.max_beb_per1024 = req->max_beb_per1024;
+
+	ret = do_attach(node, &r);
+	if (ret == 0)
+		req->dev_num = r.ubi_num;
+
+	return ret;
+}
+
+int ubi_detach_mtd(libubi_t desc, const char *node, int mtd_num)
+{
+	int ret, ubi_dev;
+
+	ret = mtd_num2ubi_dev(desc, mtd_num, &ubi_dev);
+	if (ret == -1) {
+		errno = ENODEV;
+		return ret;
+	}
+
+	return ubi_remove_dev(desc, node, ubi_dev);
+}
+
+int ubi_detach(libubi_t desc, const char *node, const char *mtd_dev_node)
+{
+	int mtd_num;
+
+	if (!mtd_dev_node) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	mtd_num = mtd_node_to_num(mtd_dev_node);
+	if (mtd_num == -1)
+		return -1;
+
+	return ubi_detach_mtd(desc, node, mtd_num);
+}
+
+int ubi_remove_dev(libubi_t desc, const char *node, int ubi_dev)
+{
+	int fd, ret;
+
+	desc = desc;
+
+	fd = open(node, O_RDONLY);
+	if (fd == -1)
+		return sys_errmsg("cannot open \"%s\"", node);
+	ret = ioctl(fd, UBI_IOCDET, &ubi_dev);
+	if (ret == -1)
+		goto out_close;
+
+#ifdef UDEV_SETTLE_HACK
+//	if (system("udevsettle") == -1)
+//		return -1;
+	usleep(100000);
+#endif
+
+out_close:
+	close(fd);
+	return ret;
+}
+
+int ubi_probe_node(libubi_t desc, const char *node)
+{
+	struct stat st;
+	struct ubi_info info;
+	int i, fd, major, minor;
+	struct libubi *lib = (struct libubi *)desc;
+	char file[strlen(lib->ubi_vol) + 100];
+
+	if (stat(node, &st))
+		return sys_errmsg("cannot get information about \"%s\"", node);
+
+	if (!S_ISCHR(st.st_mode)) {
+		errmsg("\"%s\" is not a character device", node);
+		errno = EINVAL;
+		return -1;
+	}
+
+	major = major(st.st_rdev);
+	minor = minor(st.st_rdev);
+
+	if (ubi_get_info((libubi_t *)lib, &info))
+		return -1;
+
+	for (i = info.lowest_dev_num; i <= info.highest_dev_num; i++) {
+		int major1, minor1, ret;
+
+		ret = dev_get_major(lib, i, &major1, &minor1);
+		if (ret) {
+			if (errno == ENOENT)
+				continue;
+			if (!errno)
+				goto out_not_ubi;
+			return -1;
+		}
+
+		if (major1 == major)
+			break;
+	}
+
+	if (i > info.highest_dev_num)
+		goto out_not_ubi;
+
+	if (minor == 0)
+		return 1;
+
+	/* This is supposdely an UBI volume device node */
+	sprintf(file, lib->ubi_vol, i, minor - 1);
+	fd = open(file, O_RDONLY);
+	if (fd == -1)
+		goto out_not_ubi;
+
+	return 2;
+
+out_not_ubi:
+	errmsg("\"%s\" has major:minor %d:%d, but this does not correspond to "
+	       "any existing UBI device or volume", node, major, minor);
+	errno = ENODEV;
+	return -1;
+}
+
+int ubi_get_info(libubi_t desc, struct ubi_info *info)
+{
+	DIR *sysfs_ubi;
+	struct dirent *dirent;
+	struct libubi *lib = (struct libubi *)desc;
+
+	memset(info, 0, sizeof(struct ubi_info));
+
+	if (read_major(lib->ctrl_dev, &info->ctrl_major, &info->ctrl_minor)) {
+		/*
+		 * Older UBI versions did not have control device, so we do not
+		 * panic here for compatibility reasons. May be few years later
+		 * we could return -1 here, but for now just set major:minor to
+		 * -1.
+		 */
+		info->ctrl_major = info->ctrl_minor = -1;
+	}
+
+	/*
+	 * We have to scan the UBI sysfs directory to identify how many UBI
+	 * devices are present.
+	 */
+	sysfs_ubi = opendir(lib->sysfs_ubi);
+	if (!sysfs_ubi)
+		return -1;
+
+	info->lowest_dev_num = INT_MAX;
+	while (1) {
+		int dev_num, ret;
+		char tmp_buf[256];
+
+		errno = 0;
+		dirent = readdir(sysfs_ubi);
+		if (!dirent)
+			break;
+
+		if (strlen(dirent->d_name) >= 255) {
+			errmsg("invalid entry in %s: \"%s\"",
+			       lib->sysfs_ubi, dirent->d_name);
+			errno = EINVAL;
+			goto out_close;
+		}
+
+		ret = sscanf(dirent->d_name, UBI_DEV_NAME_PATT"%s",
+			     &dev_num, tmp_buf);
+		if (ret == 1) {
+			info->dev_count += 1;
+			if (dev_num > info->highest_dev_num)
+				info->highest_dev_num = dev_num;
+			if (dev_num < info->lowest_dev_num)
+				info->lowest_dev_num = dev_num;
+		}
+	}
+
+	if (!dirent && errno) {
+		sys_errmsg("readdir failed on \"%s\"", lib->sysfs_ubi);
+		goto out_close;
+	}
+
+	if (closedir(sysfs_ubi))
+		return sys_errmsg("closedir failed on \"%s\"", lib->sysfs_ubi);
+
+	if (info->lowest_dev_num == INT_MAX)
+		info->lowest_dev_num = 0;
+
+	if (read_positive_int(lib->ubi_version, &info->version))
+		return -1;
+
+	return 0;
+
+out_close:
+	closedir(sysfs_ubi);
+	return -1;
+}
+
+int ubi_mkvol(libubi_t desc, const char *node, struct ubi_mkvol_request *req)
+{
+	int fd, ret;
+	struct ubi_mkvol_req r;
+	size_t n;
+
+	memset(&r, 0, sizeof(struct ubi_mkvol_req));
+
+	desc = desc;
+	r.vol_id = req->vol_id;
+	r.alignment = req->alignment;
+	r.bytes = req->bytes;
+	r.vol_type = req->vol_type;
+
+	n = strlen(req->name);
+	if (n > UBI_MAX_VOLUME_NAME)
+		return -1;
+
+	strncpy(r.name, req->name, UBI_MAX_VOLUME_NAME + 1);
+	r.name_len = n;
+
+	desc = desc;
+	fd = open(node, O_RDONLY);
+	if (fd == -1)
+		return sys_errmsg("cannot open \"%s\"", node);
+
+	ret = ioctl(fd, UBI_IOCMKVOL, &r);
+	if (ret == -1) {
+		close(fd);
+		return ret;
+	}
+
+	close(fd);
+	req->vol_id = r.vol_id;
+
+#ifdef UDEV_SETTLE_HACK
+//	if (system("udevsettle") == -1)
+//		return -1;
+	usleep(100000);
+#endif
+
+	return 0;
+}
+
+int ubi_rmvol(libubi_t desc, const char *node, int vol_id)
+{
+	int fd, ret;
+
+	desc = desc;
+	fd = open(node, O_RDONLY);
+	if (fd == -1)
+		return sys_errmsg("cannot open \"%s\"", node);
+
+	ret = ioctl(fd, UBI_IOCRMVOL, &vol_id);
+	if (ret == -1) {
+		close(fd);
+		return ret;
+	}
+
+	close(fd);
+
+#ifdef UDEV_SETTLE_HACK
+//	if (system("udevsettle") == -1)
+//		return -1;
+	usleep(100000);
+#endif
+
+	return 0;
+}
+
+int ubi_rnvols(libubi_t desc, const char *node, struct ubi_rnvol_req *rnvol)
+{
+	int fd, ret;
+
+	desc = desc;
+	fd = open(node, O_RDONLY);
+	if (fd == -1)
+		return -1;
+
+	ret = ioctl(fd, UBI_IOCRNVOL, rnvol);
+	if (ret == -1) {
+		close(fd);
+		return ret;
+	}
+
+	close(fd);
+
+#ifdef UDEV_SETTLE_HACK
+//	if (system("udevsettle") == -1)
+//		return -1;
+	usleep(100000);
+#endif
+
+	return 0;
+}
+
+int ubi_rsvol(libubi_t desc, const char *node, int vol_id, long long bytes)
+{
+	int fd, ret;
+	struct ubi_rsvol_req req;
+
+	desc = desc;
+	fd = open(node, O_RDONLY);
+	if (fd == -1)
+		return sys_errmsg("cannot open \"%s\"", node);
+
+	req.bytes = bytes;
+	req.vol_id = vol_id;
+
+	ret = ioctl(fd, UBI_IOCRSVOL, &req);
+	close(fd);
+	return ret;
+}
+
+int ubi_update_start(libubi_t desc, int fd, long long bytes)
+{
+	desc = desc;
+	if (ioctl(fd, UBI_IOCVOLUP, &bytes))
+		return -1;
+	return 0;
+}
+
+int ubi_leb_change_start(libubi_t desc, int fd, int lnum, int bytes)
+{
+	struct ubi_leb_change_req req;
+
+	desc = desc;
+	memset(&req, 0, sizeof(struct ubi_leb_change_req));
+	req.lnum = lnum;
+	req.bytes = bytes;
+	req.dtype = 3;
+
+	if (ioctl(fd, UBI_IOCEBCH, &req))
+		return -1;
+	return 0;
+}
+
+int ubi_dev_present(libubi_t desc, int dev_num)
+{
+	struct stat st;
+	struct libubi *lib = (struct libubi *)desc;
+	char file[strlen(lib->ubi_dev) + 50];
+
+	sprintf(file, lib->ubi_dev, dev_num);
+	return !stat(file, &st);
+}
+
+int ubi_get_dev_info1(libubi_t desc, int dev_num, struct ubi_dev_info *info)
+{
+	DIR *sysfs_ubi;
+	struct dirent *dirent;
+	struct libubi *lib = (struct libubi *)desc;
+
+	memset(info, 0, sizeof(struct ubi_dev_info));
+	info->dev_num = dev_num;
+
+	if (!ubi_dev_present(desc, dev_num))
+		return -1;
+
+	sysfs_ubi = opendir(lib->sysfs_ubi);
+	if (!sysfs_ubi)
+		return -1;
+
+	info->lowest_vol_id = INT_MAX;
+
+	while (1) {
+		int vol_id, ret, devno;
+		char tmp_buf[256];
+
+		errno = 0;
+		dirent = readdir(sysfs_ubi);
+		if (!dirent)
+			break;
+
+		if (strlen(dirent->d_name) >= 255) {
+			errmsg("invalid entry in %s: \"%s\"",
+			       lib->sysfs_ubi, dirent->d_name);
+			goto out_close;
+		}
+
+		ret = sscanf(dirent->d_name, UBI_VOL_NAME_PATT"%s", &devno, &vol_id, tmp_buf);
+		if (ret == 2 && devno == dev_num) {
+			info->vol_count += 1;
+			if (vol_id > info->highest_vol_id)
+				info->highest_vol_id = vol_id;
+			if (vol_id < info->lowest_vol_id)
+				info->lowest_vol_id = vol_id;
+		}
+	}
+
+	if (!dirent && errno) {
+		sys_errmsg("readdir failed on \"%s\"", lib->sysfs_ubi);
+		goto out_close;
+	}
+
+	if (closedir(sysfs_ubi))
+		return sys_errmsg("closedir failed on \"%s\"", lib->sysfs_ubi);
+
+	if (info->lowest_vol_id == INT_MAX)
+		info->lowest_vol_id = 0;
+
+	if (dev_get_major(lib, dev_num, &info->major, &info->minor))
+		return -1;
+
+	if (dev_read_int(lib->dev_mtd_num, dev_num, &info->mtd_num))
+		return -1;
+	if (dev_read_int(lib->dev_avail_ebs, dev_num, &info->avail_lebs))
+		return -1;
+	if (dev_read_int(lib->dev_total_ebs, dev_num, &info->total_lebs))
+		return -1;
+	if (dev_read_int(lib->dev_bad_count, dev_num, &info->bad_count))
+		return -1;
+	if (dev_read_int(lib->dev_eb_size, dev_num, &info->leb_size))
+		return -1;
+	if (dev_read_int(lib->dev_bad_rsvd, dev_num, &info->bad_rsvd))
+		return -1;
+	if (dev_read_ll(lib->dev_max_ec, dev_num, &info->max_ec))
+		return -1;
+	if (dev_read_int(lib->dev_max_vols, dev_num, &info->max_vol_count))
+		return -1;
+	if (dev_read_int(lib->dev_min_io_size, dev_num, &info->min_io_size))
+		return -1;
+
+	info->avail_bytes = (long long)info->avail_lebs * info->leb_size;
+	info->total_bytes = (long long)info->total_lebs * info->leb_size;
+
+	return 0;
+
+out_close:
+	closedir(sysfs_ubi);
+	return -1;
+}
+
+int ubi_get_dev_info(libubi_t desc, const char *node, struct ubi_dev_info *info)
+{
+	int err, dev_num;
+	struct libubi *lib = (struct libubi *)desc;
+
+	err = ubi_probe_node(desc, node);
+	if (err != 1) {
+		if (err == 2)
+			errno = ENODEV;
+		return -1;
+	}
+
+	if (dev_node2num(lib, node, &dev_num))
+		return -1;
+
+	return ubi_get_dev_info1(desc, dev_num, info);
+}
+
+int ubi_get_vol_info1(libubi_t desc, int dev_num, int vol_id,
+		      struct ubi_vol_info *info)
+{
+	int ret;
+	struct libubi *lib = (struct libubi *)desc;
+	char buf[50];
+
+	memset(info, 0, sizeof(struct ubi_vol_info));
+	info->dev_num = dev_num;
+	info->vol_id = vol_id;
+
+	if (vol_get_major(lib, dev_num, vol_id, &info->major, &info->minor))
+		return -1;
+
+	ret = vol_read_data(lib->vol_type, dev_num, vol_id, buf, 50);
+	if (ret < 0)
+		return -1;
+
+	if (strncmp(buf, "static\n", ret) == 0)
+		info->type = UBI_STATIC_VOLUME;
+	else if (strncmp(buf, "dynamic\n", ret) == 0)
+		info->type = UBI_DYNAMIC_VOLUME;
+	else {
+		errmsg("bad value at \"%s\"", buf);
+		errno = EINVAL;
+		return -1;
+	}
+
+	ret = vol_read_int(lib->vol_alignment, dev_num, vol_id,
+			   &info->alignment);
+	if (ret)
+		return -1;
+	ret = vol_read_ll(lib->vol_data_bytes, dev_num, vol_id,
+			  &info->data_bytes);
+	if (ret)
+		return -1;
+	ret = vol_read_int(lib->vol_rsvd_ebs, dev_num, vol_id, &info->rsvd_lebs);
+	if (ret)
+		return -1;
+	ret = vol_read_int(lib->vol_eb_size, dev_num, vol_id, &info->leb_size);
+	if (ret)
+		return -1;
+	ret = vol_read_int(lib->vol_corrupted, dev_num, vol_id,
+			   &info->corrupted);
+	if (ret)
+		return -1;
+	info->rsvd_bytes = (long long)info->leb_size * info->rsvd_lebs;
+
+	ret = vol_read_data(lib->vol_name, dev_num, vol_id, &info->name,
+			    UBI_VOL_NAME_MAX + 2);
+	if (ret < 0)
+		return -1;
+
+	info->name[ret - 1] = '\0';
+	return 0;
+}
+
+int ubi_get_vol_info(libubi_t desc, const char *node, struct ubi_vol_info *info)
+{
+	int err, vol_id, dev_num;
+	struct libubi *lib = (struct libubi *)desc;
+
+	err = ubi_probe_node(desc, node);
+	if (err != 2) {
+		if (err == 1)
+			errno = ENODEV;
+		return -1;
+	}
+
+	if (vol_node2nums(lib, node, &dev_num, &vol_id))
+		return -1;
+
+	return ubi_get_vol_info1(desc, dev_num, vol_id, info);
+}
+
+int ubi_get_vol_info1_nm(libubi_t desc, int dev_num, const char *name,
+			 struct ubi_vol_info *info)
+{
+	int i, err;
+	unsigned int nlen = strlen(name);
+	struct ubi_dev_info dev_info;
+
+	if (nlen == 0) {
+		errmsg("bad \"name\" input parameter");
+		errno = EINVAL;
+		return -1;
+	}
+
+	err = ubi_get_dev_info1(desc, dev_num, &dev_info);
+	if (err)
+		return err;
+
+	for (i = dev_info.lowest_vol_id;
+	     i <= dev_info.highest_vol_id; i++) {
+		err = ubi_get_vol_info1(desc, dev_num, i, info);
+		if (err == -1) {
+			if (errno == ENOENT)
+				continue;
+			return -1;
+		}
+
+		if (nlen == strlen(info->name) && !strcmp(name, info->name))
+			return 0;
+	}
+
+	errno = ENOENT;
+	return -1;
+}
+
+int ubi_set_property(int fd, uint8_t property, uint64_t value)
+{
+	struct ubi_set_vol_prop_req r;
+
+	memset(&r, 0, sizeof(struct ubi_set_vol_prop_req));
+	r.property = property;
+	r.value = value;
+
+	return ioctl(fd, UBI_IOCSETVOLPROP, &r);
+}
+
+int ubi_leb_unmap(int fd, int lnum)
+{
+	return ioctl(fd, UBI_IOCEBUNMAP, &lnum);
+}
+
+int ubi_is_mapped(int fd, int lnum)
+{
+	return ioctl(fd, UBI_IOCEBISMAP, &lnum);
+}
diff --git a/fastboot_app/utils/ubi/libubi.h b/fastboot_app/utils/ubi/libubi.h
new file mode 100644
index 0000000..47f40e2
--- /dev/null
+++ b/fastboot_app/utils/ubi/libubi.h
@@ -0,0 +1,469 @@
+/*
+ * Copyright (c) International Business Machines Corp., 2006
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Author: Artem Bityutskiy
+ *
+ * UBI (Unsorted Block Images) library.
+ */
+
+#ifndef __LIBUBI_H__
+#define __LIBUBI_H__
+
+#include <ctype.h>
+#include <stdint.h>
+#include <mtd/ubi-user.h>
+#include <mtd/ubi-media.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* UBI version libubi is made for */
+#define LIBUBI_UBI_VERSION 1
+
+/* Maximum physical eraseblock size in bytes */
+#define UBI_MAX_PEB_SZ (2*1024*1024)
+
+/* UBI library descriptor */
+typedef void * libubi_t;
+
+/**
+ * struct ubi_attach_request - MTD device attachment request.
+ * @dev_num: number to assign to the newly created UBI device
+ *           (%UBI_DEV_NUM_AUTO should be used to automatically assign the
+ *           number)
+ * @mtd_num: MTD device number to attach (used if @mtd_dev_node is %NULL)
+ * @mtd_dev_node: path to MTD device node to attach
+ * @vid_hdr_offset: VID header offset (%0 means default offset and this is what
+ *                  most of the users want)
+ * @max_beb_per1024: Maximum expected bad eraseblocks per 1024 eraseblocks
+ */
+struct ubi_attach_request
+{
+	int dev_num;
+	int mtd_num;
+	const char *mtd_dev_node;
+	int vid_hdr_offset;
+	int max_beb_per1024;
+};
+
+/**
+ * struct ubi_mkvol_request - volume creation request.
+ * @vol_id: ID to assign to the new volume (%UBI_VOL_NUM_AUTO should be used to
+ *          automatically assign ID)
+ * @alignment: volume alignment
+ * @bytes: volume size in bytes
+ * @vol_type: volume type (%UBI_DYNAMIC_VOLUME or %UBI_STATIC_VOLUME)
+ * @name: volume name
+ */
+struct ubi_mkvol_request
+{
+	int vol_id;
+	int alignment;
+	long long bytes;
+	int vol_type;
+	const char *name;
+};
+
+/**
+ * struct ubi_info - general UBI information.
+ * @dev_count: count of UBI devices in system
+ * @lowest_dev_num: lowest UBI device number
+ * @highest_dev_num: highest UBI device number
+ * @version: UBI version
+ * @ctrl_major: major number of the UBI control device
+ * @ctrl_minor: minor number of the UBI control device
+ */
+struct ubi_info
+{
+	int dev_count;
+	int lowest_dev_num;
+	int highest_dev_num;
+	int version;
+	int ctrl_major;
+	int ctrl_minor;
+};
+
+/**
+ * struct ubi_dev_info - UBI device information.
+ * @dev_num: UBI device number
+ * @mtd_num: MTD device number on top of which this UBI device is working
+ * @vol_count: count of volumes on this UBI device
+ * @lowest_vol_id: lowest volume ID
+ * @highest_vol_id: highest volume ID
+ * @major: major number of corresponding character device
+ * @minor: minor number of corresponding character device
+ * @total_lebs: total number of logical eraseblocks on this UBI device
+ * @avail_lebs: how many logical eraseblocks are not used and available for new
+ *             volumes
+ * @total_bytes: @total_lebs * @leb_size
+ * @avail_bytes: @avail_lebs * @leb_size
+ * @bad_count: count of bad physical eraseblocks
+ * @leb_size: logical eraseblock size
+ * @max_ec: current highest erase counter value
+ * @bad_rsvd: how many physical eraseblocks of the underlying flash device are
+ *            reserved for bad eraseblocks handling
+ * @max_vol_count: maximum possible number of volumes on this UBI device
+ * @min_io_size: minimum input/output unit size of the UBI device
+ */
+struct ubi_dev_info
+{
+	int dev_num;
+	int mtd_num;
+	int vol_count;
+	int lowest_vol_id;
+	int highest_vol_id;
+	int major;
+	int minor;
+	int total_lebs;
+	int avail_lebs;
+	long long total_bytes;
+	long long avail_bytes;
+	int bad_count;
+	int leb_size;
+	long long max_ec;
+	int bad_rsvd;
+	int max_vol_count;
+	int min_io_size;
+};
+
+/**
+ * struct ubi_vol_info - UBI volume information.
+ * @dev_num: UBI device number the volume resides on
+ * @vol_id: ID of this volume
+ * @major: major number of corresponding volume character device
+ * @minor: minor number of corresponding volume character device
+ * @type: volume type (%UBI_DYNAMIC_VOLUME or %UBI_STATIC_VOLUME)
+ * @alignment: alignment of this volume
+ * @data_bytes: how many data bytes are stored on this volume (equivalent to
+ *              @rsvd_bytes for dynamic volumes)
+ * @rsvd_bytes: how many bytes are reserved for this volume
+ * @rsvd_lebs: how many logical eraseblocks are reserved for this volume
+ * @leb_size: logical eraseblock size of this volume (may be less then
+ *            device's logical eraseblock size due to alignment)
+ * @corrupted: non-zero if the volume is corrupted
+ * @name: volume name (null-terminated)
+ */
+struct ubi_vol_info
+{
+	int dev_num;
+	int vol_id;
+	int major;
+	int minor;
+	int type;
+	int alignment;
+	long long data_bytes;
+	long long rsvd_bytes;
+	int rsvd_lebs;
+	int leb_size;
+	int corrupted;
+	char name[UBI_VOL_NAME_MAX + 1];
+};
+
+/**
+ * libubi_open - open UBI library.
+ *
+ * This function initializes and opens the UBI library and returns UBI library
+ * descriptor in case of success and %NULL in case of failure. In case of
+ * failure, errno contains the error code or zero if UBI is not present in the
+ * system.
+ */
+libubi_t libubi_open(void);
+
+/**
+ * libubi_close - close UBI library.
+ * @desc: UBI library descriptor
+ */
+void libubi_close(libubi_t desc);
+
+/**
+ * ubi_get_info - get general UBI information.
+ * @desc: UBI library descriptor
+ * @info: pointer to the &struct ubi_info object to fill
+ *
+ * This function fills the passed @info object with general UBI information and
+ * returns %0 in case of success and %-1 in case of failure.
+ */
+int ubi_get_info(libubi_t desc, struct ubi_info *info);
+
+/**
+ * mtd_num2ubi_dev - find UBI device by attached MTD device.
+ * @@desc: UBI library descriptor
+ * @mtd_num: MTD device number
+ * @dev_num: UBI device number is returned here
+ *
+ * This function finds UBI device to which MTD device @mtd_num is attached.
+ * Returns %0 if the UBI device was found and %-1 if not.
+ */
+int mtd_num2ubi_dev(libubi_t desc, int mtd_num, int *dev_num);
+
+/**
+ * ubi_attach - attach an MTD device by its node path or bt MTD device number
+ * @desc: UBI library descriptor
+ * @node: name of the UBI control character device node
+ * @req: MTD attach request
+ *
+ * This function creates new UBI device by attaching an MTD device described by
+ * @req. If @req->mtd_dev_node is given it should contain path to the MTD
+ * device node. Otherwise @req->mtd_num will be used.
+ *
+ * Returns %0 in case of success, %-1 in case of failure (errno is set) and %1
+ * if parameter @req->max_beb_per1024 was ignored by kernel (because the kernel
+ * is old and does not support this feature, which was added in 3.7). The newly
+ * created UBI device number is returned in @req->dev_num. In the MTD device
+ * was specified by its device node path, the MTD device number is returned in
+ * @req->mtd_num.
+ */
+int ubi_attach(libubi_t desc, const char *node, struct ubi_attach_request *req);
+
+/**
+ * ubi_detach_mtd - detach an MTD device.
+ * @desc: UBI library descriptor
+ * @node: name of the UBI control character device node
+ * @mtd_num: MTD device number to detach
+ *
+ * This function detaches MTD device number @mtd_num from UBI, which means the
+ * corresponding UBI device is removed. Returns zero in case of success and %-1
+ * in case of failure.
+ */
+int ubi_detach_mtd(libubi_t desc, const char *node, int mtd_num);
+
+/**
+ * ubi_detach - detach an MTD device by its node path.
+ * @desc: UBI library descriptor
+ * @node: name of the UBI control character device node
+ * @mtd_dev_node: path to an MTD device node
+ *
+ * This function detaches an MTD device @mtd_dev_node from UBI. Returns zero in
+ * case of success and %-1 in case of failure.
+ */
+int ubi_detach(libubi_t desc, const char *node, const char *mtd_dev_node);
+
+/**
+ * ubi_remove_dev - remove an UBI device.
+ * @desc: UBI library descriptor
+ * @node: name of the UBI control character device node
+ * @ubi_dev: UBI device number to remove
+ *
+ * This function removes UBI device number @ubi_dev and returns zero in case of
+ * success and %-1 in case of failure.
+ */
+int ubi_remove_dev(libubi_t desc, const char *node, int ubi_dev);
+
+/**
+ * ubi_mkvol - create an UBI volume.
+ * @desc: UBI library descriptor
+ * @node: name of the UBI character device to create a volume at
+ * @req: UBI volume creation request
+ *
+ * This function creates a UBI volume as described at @req and returns %0 in
+ * case of success and %-1 in case of failure. The assigned volume ID is
+ * returned in @req->vol_id.
+ */
+int ubi_mkvol(libubi_t desc, const char *node, struct ubi_mkvol_request *req);
+
+/**
+ * ubi_rmvol - remove a UBI volume.
+ * @desc: UBI library descriptor
+ * @node: name of the UBI character device to remove a volume from
+ * @vol_id: ID of the volume to remove
+ *
+ * This function removes volume @vol_id from UBI device @node and returns %0 in
+ * case of success and %-1 in case of failure.
+ */
+int ubi_rmvol(libubi_t desc, const char *node, int vol_id);
+
+
+/**
+ * ubi_rnvols - rename UBI volumes.
+ * @desc: UBI library descriptor
+ * @node: name of the UBI character device to remove a volume from
+ * @rnvol: description of volumes to rename
+ *
+ * This function removes volume @vol_id from UBI device @node and returns %0 in
+ * case of success and %-1 in case of failure.
+ */
+int ubi_rnvols(libubi_t desc, const char *node, struct ubi_rnvol_req *rnvol);
+
+/**
+ * ubi_rsvol - re-size UBI volume.
+ * @desc: UBI library descriptor
+ * @node: name of the UBI character device owning the volume which should be
+ *        re-sized
+ * @vol_id: volume ID to re-size
+ * @bytes: new volume size in bytes
+ *
+ * This function returns %0 in case of success and %-1 in case of error.
+ */
+int ubi_rsvol(libubi_t desc, const char *node, int vol_id, long long bytes);
+
+/**
+ * ubi_probe_node - test UBI node.
+ * @desc: UBI library descriptor
+ * @node: the node to test
+ *
+ * This function tests whether @node is a UBI device or volume node and returns
+ * %1 if this is an UBI device node, %2 if this is a volume node, and %-1 if
+ * this is not an UBI device or volume node (errno is ENODEV in this case) or
+ * if an error occurred.
+ */
+int ubi_probe_node(libubi_t desc, const char *node);
+
+/**
+ * ubi_get_dev_info - get UBI device information.
+ * @desc: UBI library descriptor
+ * @node: name of the UBI character device to fetch information about
+ * @info: pointer to the &struct ubi_dev_info object to fill
+ *
+ * This function fills the passed @info object with UBI device information and
+ * returns %0 in case of success and %-1 in case of failure. If the UBI device
+ * corresponding to @node does not exist, errno is set to @ENODEV.
+ */
+int ubi_get_dev_info(libubi_t desc, const char *node,
+		     struct ubi_dev_info *info);
+
+/**
+ * ubi_dev_present - check whether an UBI device is present.
+ * @desc: UBI library descriptor
+ * @dev_num: UBI device number to check
+ *
+ * This function returns %1 if UBI device is present and %0 if not.
+ */
+int ubi_dev_present(libubi_t desc, int dev_num);
+
+/**
+ * ubi_get_dev_info1 - get UBI device information.
+ * @desc: UBI library descriptor
+ * @dev_num: UBI device number to fetch information about
+ * @info: pointer to the &struct ubi_dev_info object to fill
+ *
+ * This function is identical to 'ubi_get_dev_info()' except that it accepts UBI
+ * device number, not UBI character device. If the UBI device @dev_num does not
+ * exist, errno is set to @ENODEV.
+ */
+int ubi_get_dev_info1(libubi_t desc, int dev_num, struct ubi_dev_info *info);
+
+/**
+ * ubi_get_vol_info - get UBI volume information.
+ * @desc: UBI library descriptor
+ * @node: name of the UBI volume character device to fetch information about
+ * @info: pointer to the &struct ubi_vol_info object to fill
+ *
+ * This function fills the passed @info object with UBI volume information and
+ * returns %0 in case of success and %-1 in case of failure. If the UBI volume
+ * corresponding to @node does not exist, errno is set to @ENODEV.
+ */
+int ubi_get_vol_info(libubi_t desc, const char *node,
+		     struct ubi_vol_info *info);
+
+/**
+ * ubi_get_vol_info1 - get UBI volume information.
+ * @desc: UBI library descriptor
+ * @dev_num: UBI device number
+ * @vol_id: ID of the UBI volume to fetch information about
+ * @info: pointer to the &struct ubi_vol_info object to fill
+ *
+ * This function is identical to 'ubi_get_vol_info()' except that it accepts UBI
+ * volume ID, not UBI volume character device. If the UBI device @dev_num does
+ * not exist, or if the UBI volume @vol_id does not exist, errno is set to
+ * @ENODEV.
+ */
+int ubi_get_vol_info1(libubi_t desc, int dev_num, int vol_id,
+		      struct ubi_vol_info *info);
+
+/**
+ * ubi_get_vol_info1_nm - get UBI volume information by volume name.
+ * @desc: UBI library descriptor
+ * @dev_num: UBI device number
+ * @name: name of the UBI volume to fetch information about
+ * @info: pointer to the &struct ubi_vol_info object to fill
+ *
+ * This function is identical to 'ubi_get_vol_info()' except that it accepts UBI
+ * volume name, not UBI volume ID. If the UBI device @dev_num does not exist,
+ * or if the UBI volume @name does not exist, errno is set to @ENODEV.
+ */
+int ubi_get_vol_info1_nm(libubi_t desc, int dev_num, const char *name,
+			 struct ubi_vol_info *info);
+
+/**
+ * ubi_update_start - start UBI volume update.
+ * @desc: UBI library descriptor
+ * @fd: volume character device file descriptor
+ * @bytes: how many bytes will be written to the volume
+ *
+ * This function initiates UBI volume update and returns %0 in case of success
+ * and %-1 in case of error. The caller is assumed to write @bytes data to the
+ * volume @fd afterward.
+ */
+int ubi_update_start(libubi_t desc, int fd, long long bytes);
+
+/**
+ * ubi_leb_change_start - start atomic LEB change.
+ * @desc: UBI library descriptor
+ * @fd: volume character device file descriptor
+ * @lnum: LEB number to change
+ * @bytes: how many bytes of new data will be written to the LEB
+ *
+ * This function initiates atomic LEB change operation and returns %0 in case
+ * of success and %-1 in case of error. he caller is assumed to write @bytes
+ * data to the volume @fd afterward.
+ */
+int ubi_leb_change_start(libubi_t desc, int fd, int lnum, int bytes);
+
+/**
+ * ubi_set_property - set volume propety.
+ * @fd: volume character device file descriptor
+ * @property: the property to change (%UBI_VOL_PROP_DIRECT_WRITE, etc)
+ * @value: new value of the changed property
+ *
+ * This function changes a property of a volume. Returns zero in case of
+ * success and a negative error code in case of error.
+ */
+int ubi_set_property(int fd, uint8_t property, uint64_t value);
+
+/**
+ * ubi_leb_unmap - unmap a logical eraseblock.
+ * @fd: volume character device file descriptor
+ * @lnum: logical eraseblock to unmap
+ *
+ * This function unmaps LEB @lnum and returns zero in case of success and a
+ * negative error code in case of error.
+ */
+int ubi_leb_unmap(int fd, int lnum);
+
+/**
+ * ubi_is_mapped - check if logical eraseblock is mapped.
+ * @fd: volume character device file descriptor
+ * @lnum: logical eraseblock number
+ *
+ * This function checks if logical eraseblock @lnum is mapped to a physical
+ * eraseblock. If a logical eraseblock is un-mapped, this does not necessarily
+ * mean it will still be un-mapped after the UBI device is re-attached. The
+ * logical eraseblock may become mapped to the physical eraseblock it was last
+ * mapped to.
+ *
+ * This function returns %1 if the LEB is mapped, %0 if not, and %-1 in case of
+ * failure. If the volume is damaged because of an interrupted update errno
+ * set with %EBADF error code.
+ */
+int ubi_is_mapped(int fd, int lnum);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !__LIBUBI_H__ */
diff --git a/fastboot_app/utils/ubi/libubi_int.h b/fastboot_app/utils/ubi/libubi_int.h
new file mode 100644
index 0000000..c3aa37a
--- /dev/null
+++ b/fastboot_app/utils/ubi/libubi_int.h
@@ -0,0 +1,131 @@
+/*
+ * Copyright (c) International Business Machines Corp., 2006
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Author: Artem Bityutskiy
+ *
+ * UBI (Unsorted Block Images) library.
+ */
+
+#ifndef __LIBUBI_INT_H__
+#define __LIBUBI_INT_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * The below are pre-define UBI file and directory names.
+ *
+ * Note, older kernels put 'ubiX_Y' directories straight to '/sys/class/ubi/'.
+ * New kernels puts 'ubiX_Y' directories to '/sys/class/ubi/ubiX/', which is
+ * saner. And for compatibility reasons it also puts symlinks to 'ubiX_Y'
+ * directories to '/sys/class/ubi/'. For now libubi assumes old layout.
+ */
+
+#define SYSFS_UBI         "class/ubi"
+#define SYSFS_CTRL        "class/misc/ubi_ctrl/"
+
+#define CTRL_DEV          "dev"
+
+#define UBI_VER           "version"
+#define UBI_DEV_NAME_PATT "ubi%d"
+
+#define DEV_DEV           "dev"
+#define DEV_AVAIL_EBS     "avail_eraseblocks"
+#define DEV_TOTAL_EBS     "total_eraseblocks"
+#define DEV_BAD_COUNT     "bad_peb_count"
+#define DEV_EB_SIZE       "eraseblock_size"
+#define DEV_MAX_EC        "max_ec"
+#define DEV_MAX_RSVD      "reserved_for_bad"
+#define DEV_MAX_VOLS      "max_vol_count"
+#define DEV_MIN_IO_SIZE   "min_io_size"
+#define DEV_MTD_NUM       "mtd_num"
+
+#define UBI_VOL_NAME_PATT "ubi%d_%d"
+#define VOL_TYPE          "type"
+#define VOL_DEV           "dev"
+#define VOL_ALIGNMENT     "alignment"
+#define VOL_DATA_BYTES    "data_bytes"
+#define VOL_RSVD_EBS      "reserved_ebs"
+#define VOL_EB_SIZE       "usable_eb_size"
+#define VOL_CORRUPTED     "corrupted"
+#define VOL_NAME          "name"
+
+/**
+ * libubi - UBI library description data structure.
+ * @sysfs: sysfs file system path
+ * @sysfs_ctrl: UBI control device directory in sysfs
+ * @ctrl_dev: UBI control device major/minor numbers sysfs file
+ * @sysfs_ubi: UBI directory in sysfs
+ * @ubi_dev: UBI device sysfs directory pattern
+ * @ubi_version: UBI version file sysfs path
+ * @dev_dev: UBI device major/minor numbers file pattern
+ * @dev_avail_ebs: count of available eraseblocks sysfs path pattern
+ * @dev_total_ebs: total eraseblocks count sysfs path pattern
+ * @dev_bad_count: count of bad eraseblocks sysfs path pattern
+ * @dev_eb_size: size of UBI device's eraseblocks sysfs path pattern
+ * @dev_max_ec: maximum erase counter sysfs path pattern
+ * @dev_bad_rsvd: count of physical eraseblock reserved for bad eraseblocks
+ *                handling
+ * @dev_max_vols: maximum volumes number count sysfs path pattern
+ * @dev_min_io_size: minimum I/O unit size sysfs path pattern
+ * @dev_mtd_num: MTD device number
+ * @ubi_vol: UBI volume sysfs directory pattern
+ * @vol_type: volume type sysfs path pattern
+ * @vol_dev: volume major/minor numbers file pattern
+ * @vol_alignment: volume alignment sysfs path pattern
+ * @vol_data_bytes: volume data size sysfs path pattern
+ * @vol_rsvd_ebs: volume reserved size sysfs path pattern
+ * @vol_eb_size: volume eraseblock size sysfs path pattern
+ * @vol_corrupted: volume corruption flag sysfs path pattern
+ * @vol_name: volume name sysfs path pattern
+ */
+struct libubi
+{
+	char *sysfs;
+	char *sysfs_ctrl;
+	char *ctrl_dev;
+	char *sysfs_ubi;
+	char *ubi_dev;
+	char *ubi_version;
+	char *dev_dev;
+	char *dev_avail_ebs;
+	char *dev_total_ebs;
+	char *dev_bad_count;
+	char *dev_eb_size;
+	char *dev_max_ec;
+	char *dev_bad_rsvd;
+	char *dev_max_vols;
+	char *dev_min_io_size;
+	char *dev_mtd_num;
+	char *ubi_vol;
+	char *vol_type;
+	char *vol_dev;
+	char *vol_alignment;
+	char *vol_data_bytes;
+	char *vol_rsvd_ebs;
+	char *vol_eb_size;
+	char *vol_corrupted;
+	char *vol_name;
+	char *vol_max_count;
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !__LIBUBI_INT_H__ */
diff --git a/fastboot_app/utils/ubi/mtd/ubi-media.h b/fastboot_app/utils/ubi/mtd/ubi-media.h
new file mode 100644
index 0000000..08bec3e
--- /dev/null
+++ b/fastboot_app/utils/ubi/mtd/ubi-media.h
@@ -0,0 +1,378 @@
+/*
+ * Copyright (c) International Business Machines Corp., 2006
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Authors: Artem Bityutskiy ( )
+ *          Thomas Gleixner
+ *          Frank Haverkamp
+ *          Oliver Lohmann
+ *          Andreas Arnez
+ */
+
+/*
+ * This file defines the layout of UBI headers and all the other UBI on-flash
+ * data structures.
+ */
+
+#ifndef __UBI_MEDIA_H__
+#define __UBI_MEDIA_H__
+
+#include <asm/byteorder.h>
+
+/* The version of UBI images supported by this implementation */
+#define UBI_VERSION 1
+
+/* The highest erase counter value supported by this implementation */
+#define UBI_MAX_ERASECOUNTER 0x7FFFFFFF
+
+/* The initial CRC32 value used when calculating CRC checksums */
+#define UBI_CRC32_INIT 0xFFFFFFFFU
+
+/* Erase counter header magic number (ASCII "UBI#") */
+#define UBI_EC_HDR_MAGIC  0x55424923
+/* Volume identifier header magic number (ASCII "UBI!") */
+#define UBI_VID_HDR_MAGIC 0x55424921
+
+/*
+ * Volume type constants used in the volume identifier header.
+ *
+ * @UBI_VID_DYNAMIC: dynamic volume
+ * @UBI_VID_STATIC: static volume
+ */
+enum {
+	UBI_VID_DYNAMIC = 1,
+	UBI_VID_STATIC  = 2
+};
+
+/*
+ * Volume flags used in the volume table record.
+ *
+ * @UBI_VTBL_AUTORESIZE_FLG: auto-resize this volume
+ *
+ * %UBI_VTBL_AUTORESIZE_FLG flag can be set only for one volume in the volume
+ * table. UBI automatically re-sizes the volume which has this flag and makes
+ * the volume to be of largest possible size. This means that if after the
+ * initialization UBI finds out that there are available physical eraseblocks
+ * present on the device, it automatically appends all of them to the volume
+ * (the physical eraseblocks reserved for bad eraseblocks handling and other
+ * reserved physical eraseblocks are not taken). So, if there is a volume with
+ * the %UBI_VTBL_AUTORESIZE_FLG flag set, the amount of available logical
+ * eraseblocks will be zero after UBI is loaded, because all of them will be
+ * reserved for this volume. Note, the %UBI_VTBL_AUTORESIZE_FLG bit is cleared
+ * after the volume had been initialized.
+ *
+ * The auto-resize feature is useful for device production purposes. For
+ * example, different NAND flash chips may have different amount of initial bad
+ * eraseblocks, depending of particular chip instance. Manufacturers of NAND
+ * chips usually guarantee that the amount of initial bad eraseblocks does not
+ * exceed certain percent, e.g. 2%. When one creates an UBI image which will be
+ * flashed to the end devices in production, he does not know the exact amount
+ * of good physical eraseblocks the NAND chip on the device will have, but this
+ * number is required to calculate the volume sized and put them to the volume
+ * table of the UBI image. In this case, one of the volumes (e.g., the one
+ * which will store the root file system) is marked as "auto-resizable", and
+ * UBI will adjust its size on the first boot if needed.
+ *
+ * Note, first UBI reserves some amount of physical eraseblocks for bad
+ * eraseblock handling, and then re-sizes the volume, not vice-versa. This
+ * means that the pool of reserved physical eraseblocks will always be present.
+ */
+enum {
+	UBI_VTBL_AUTORESIZE_FLG = 0x01,
+};
+
+/*
+ * Compatibility constants used by internal volumes.
+ *
+ * @UBI_COMPAT_DELETE: delete this internal volume before anything is written
+ *                     to the flash
+ * @UBI_COMPAT_RO: attach this device in read-only mode
+ * @UBI_COMPAT_PRESERVE: preserve this internal volume - do not touch its
+ *                       physical eraseblocks, don't allow the wear-leveling
+ *                       sub-system to move them
+ * @UBI_COMPAT_REJECT: reject this UBI image
+ */
+enum {
+	UBI_COMPAT_DELETE   = 1,
+	UBI_COMPAT_RO       = 2,
+	UBI_COMPAT_PRESERVE = 4,
+	UBI_COMPAT_REJECT   = 5
+};
+
+/* Sizes of UBI headers */
+#define UBI_EC_HDR_SIZE  sizeof(struct ubi_ec_hdr)
+#define UBI_VID_HDR_SIZE sizeof(struct ubi_vid_hdr)
+
+/* Sizes of UBI headers without the ending CRC */
+#define UBI_EC_HDR_SIZE_CRC  (UBI_EC_HDR_SIZE  - sizeof(__be32))
+#define UBI_VID_HDR_SIZE_CRC (UBI_VID_HDR_SIZE - sizeof(__be32))
+
+/**
+ * struct ubi_ec_hdr - UBI erase counter header.
+ * @magic: erase counter header magic number (%UBI_EC_HDR_MAGIC)
+ * @version: version of UBI implementation which is supposed to accept this
+ *           UBI image
+ * @padding1: reserved for future, zeroes
+ * @ec: the erase counter
+ * @vid_hdr_offset: where the VID header starts
+ * @data_offset: where the user data start
+ * @image_seq: image sequence number
+ * @padding2: reserved for future, zeroes
+ * @hdr_crc: erase counter header CRC checksum
+ *
+ * The erase counter header takes 64 bytes and has a plenty of unused space for
+ * future usage. The unused fields are zeroed. The @version field is used to
+ * indicate the version of UBI implementation which is supposed to be able to
+ * work with this UBI image. If @version is greater than the current UBI
+ * version, the image is rejected. This may be useful in future if something
+ * is changed radically. This field is duplicated in the volume identifier
+ * header.
+ *
+ * The @vid_hdr_offset and @data_offset fields contain the offset of the the
+ * volume identifier header and user data, relative to the beginning of the
+ * physical eraseblock. These values have to be the same for all physical
+ * eraseblocks.
+ *
+ * The @image_seq field is used to validate a UBI image that has been prepared
+ * for a UBI device. The @image_seq value can be any value, but it must be the
+ * same on all eraseblocks. UBI will ensure that all new erase counter headers
+ * also contain this value, and will check the value when scanning at start-up.
+ * One way to make use of @image_seq is to increase its value by one every time
+ * an image is flashed over an existing image, then, if the flashing does not
+ * complete, UBI will detect the error when scanning.
+ */
+struct ubi_ec_hdr {
+	__be32  magic;
+	__u8    version;
+	__u8    padding1[3];
+	__be64  ec; /* Warning: the current limit is 31-bit anyway! */
+	__be32  vid_hdr_offset;
+	__be32  data_offset;
+	__be32  image_seq;
+	__u8    padding2[32];
+	__be32  hdr_crc;
+} __attribute__ ((packed));
+
+/**
+ * struct ubi_vid_hdr - on-flash UBI volume identifier header.
+ * @magic: volume identifier header magic number (%UBI_VID_HDR_MAGIC)
+ * @version: UBI implementation version which is supposed to accept this UBI
+ *           image (%UBI_VERSION)
+ * @vol_type: volume type (%UBI_VID_DYNAMIC or %UBI_VID_STATIC)
+ * @copy_flag: if this logical eraseblock was copied from another physical
+ *             eraseblock (for wear-leveling reasons)
+ * @compat: compatibility of this volume (%0, %UBI_COMPAT_DELETE,
+ *          %UBI_COMPAT_IGNORE, %UBI_COMPAT_PRESERVE, or %UBI_COMPAT_REJECT)
+ * @vol_id: ID of this volume
+ * @lnum: logical eraseblock number
+ * @padding1: reserved for future, zeroes
+ * @data_size: how many bytes of data this logical eraseblock contains
+ * @used_ebs: total number of used logical eraseblocks in this volume
+ * @data_pad: how many bytes at the end of this physical eraseblock are not
+ *            used
+ * @data_crc: CRC checksum of the data stored in this logical eraseblock
+ * @padding2: reserved for future, zeroes
+ * @sqnum: sequence number
+ * @padding3: reserved for future, zeroes
+ * @hdr_crc: volume identifier header CRC checksum
+ *
+ * The @sqnum is the value of the global sequence counter at the time when this
+ * VID header was created. The global sequence counter is incremented each time
+ * UBI writes a new VID header to the flash, i.e. when it maps a logical
+ * eraseblock to a new physical eraseblock. The global sequence counter is an
+ * unsigned 64-bit integer and we assume it never overflows. The @sqnum
+ * (sequence number) is used to distinguish between older and newer versions of
+ * logical eraseblocks.
+ *
+ * There are 2 situations when there may be more than one physical eraseblock
+ * corresponding to the same logical eraseblock, i.e., having the same @vol_id
+ * and @lnum values in the volume identifier header. Suppose we have a logical
+ * eraseblock L and it is mapped to the physical eraseblock P.
+ *
+ * 1. Because UBI may erase physical eraseblocks asynchronously, the following
+ * situation is possible: L is asynchronously erased, so P is scheduled for
+ * erasure, then L is written to,i.e. mapped to another physical eraseblock P1,
+ * so P1 is written to, then an unclean reboot happens. Result - there are 2
+ * physical eraseblocks P and P1 corresponding to the same logical eraseblock
+ * L. But P1 has greater sequence number, so UBI picks P1 when it attaches the
+ * flash.
+ *
+ * 2. From time to time UBI moves logical eraseblocks to other physical
+ * eraseblocks for wear-leveling reasons. If, for example, UBI moves L from P
+ * to P1, and an unclean reboot happens before P is physically erased, there
+ * are two physical eraseblocks P and P1 corresponding to L and UBI has to
+ * select one of them when the flash is attached. The @sqnum field says which
+ * PEB is the original (obviously P will have lower @sqnum) and the copy. But
+ * it is not enough to select the physical eraseblock with the higher sequence
+ * number, because the unclean reboot could have happen in the middle of the
+ * copying process, so the data in P is corrupted. It is also not enough to
+ * just select the physical eraseblock with lower sequence number, because the
+ * data there may be old (consider a case if more data was added to P1 after
+ * the copying). Moreover, the unclean reboot may happen when the erasure of P
+ * was just started, so it result in unstable P, which is "mostly" OK, but
+ * still has unstable bits.
+ *
+ * UBI uses the @copy_flag field to indicate that this logical eraseblock is a
+ * copy. UBI also calculates data CRC when the data is moved and stores it at
+ * the @data_crc field of the copy (P1). So when UBI needs to pick one physical
+ * eraseblock of two (P or P1), the @copy_flag of the newer one (P1) is
+ * examined. If it is cleared, the situation* is simple and the newer one is
+ * picked. If it is set, the data CRC of the copy (P1) is examined. If the CRC
+ * checksum is correct, this physical eraseblock is selected (P1). Otherwise
+ * the older one (P) is selected.
+ *
+ * There are 2 sorts of volumes in UBI: user volumes and internal volumes.
+ * Internal volumes are not seen from outside and are used for various internal
+ * UBI purposes. In this implementation there is only one internal volume - the
+ * layout volume. Internal volumes are the main mechanism of UBI extensions.
+ * For example, in future one may introduce a journal internal volume. Internal
+ * volumes have their own reserved range of IDs.
+ *
+ * The @compat field is only used for internal volumes and contains the "degree
+ * of their compatibility". It is always zero for user volumes. This field
+ * provides a mechanism to introduce UBI extensions and to be still compatible
+ * with older UBI binaries. For example, if someone introduced a journal in
+ * future, he would probably use %UBI_COMPAT_DELETE compatibility for the
+ * journal volume.  And in this case, older UBI binaries, which know nothing
+ * about the journal volume, would just delete this volume and work perfectly
+ * fine. This is similar to what Ext2fs does when it is fed by an Ext3fs image
+ * - it just ignores the Ext3fs journal.
+ *
+ * The @data_crc field contains the CRC checksum of the contents of the logical
+ * eraseblock if this is a static volume. In case of dynamic volumes, it does
+ * not contain the CRC checksum as a rule. The only exception is when the
+ * data of the physical eraseblock was moved by the wear-leveling sub-system,
+ * then the wear-leveling sub-system calculates the data CRC and stores it in
+ * the @data_crc field. And of course, the @copy_flag is %in this case.
+ *
+ * The @data_size field is used only for static volumes because UBI has to know
+ * how many bytes of data are stored in this eraseblock. For dynamic volumes,
+ * this field usually contains zero. The only exception is when the data of the
+ * physical eraseblock was moved to another physical eraseblock for
+ * wear-leveling reasons. In this case, UBI calculates CRC checksum of the
+ * contents and uses both @data_crc and @data_size fields. In this case, the
+ * @data_size field contains data size.
+ *
+ * The @used_ebs field is used only for static volumes and indicates how many
+ * eraseblocks the data of the volume takes. For dynamic volumes this field is
+ * not used and always contains zero.
+ *
+ * The @data_pad is calculated when volumes are created using the alignment
+ * parameter. So, effectively, the @data_pad field reduces the size of logical
+ * eraseblocks of this volume. This is very handy when one uses block-oriented
+ * software (say, cramfs) on top of the UBI volume.
+ */
+struct ubi_vid_hdr {
+	__be32  magic;
+	__u8    version;
+	__u8    vol_type;
+	__u8    copy_flag;
+	__u8    compat;
+	__be32  vol_id;
+	__be32  lnum;
+	__be32  leb_ver;
+	__be32  data_size;
+	__be32  used_ebs;
+	__be32  data_pad;
+	__be32  data_crc;
+	__u8    padding2[4];
+	__be64  sqnum;
+	__u8    padding3[12];
+	__be32  hdr_crc;
+} __attribute__ ((packed));
+
+/* Internal UBI volumes count */
+#define UBI_INT_VOL_COUNT 1
+
+/*
+ * Starting ID of internal volumes. There is reserved room for 4096 internal
+ * volumes.
+ */
+#define UBI_INTERNAL_VOL_START (0x7FFFFFFF - 4096)
+
+/* The layout volume contains the volume table */
+
+#define UBI_LAYOUT_VOLUME_ID     UBI_INTERNAL_VOL_START
+#define UBI_LAYOUT_VOLUME_TYPE   UBI_VID_DYNAMIC
+#define UBI_LAYOUT_VOLUME_ALIGN  1
+#define UBI_LAYOUT_VOLUME_EBS    2
+#define UBI_LAYOUT_VOLUME_NAME   "layout volume"
+#define UBI_LAYOUT_VOLUME_COMPAT UBI_COMPAT_REJECT
+
+/* The maximum number of volumes per one UBI device */
+#define UBI_MAX_VOLUMES 128
+
+/* The maximum volume name length */
+#define UBI_VOL_NAME_MAX 127
+
+/* Size of the volume table record */
+#define UBI_VTBL_RECORD_SIZE sizeof(struct ubi_vtbl_record)
+
+/* Size of the volume table record without the ending CRC */
+#define UBI_VTBL_RECORD_SIZE_CRC (UBI_VTBL_RECORD_SIZE - sizeof(__be32))
+
+/**
+ * struct ubi_vtbl_record - a record in the volume table.
+ * @reserved_pebs: how many physical eraseblocks are reserved for this volume
+ * @alignment: volume alignment
+ * @data_pad: how many bytes are unused at the end of the each physical
+ * eraseblock to satisfy the requested alignment
+ * @vol_type: volume type (%UBI_DYNAMIC_VOLUME or %UBI_STATIC_VOLUME)
+ * @upd_marker: if volume update was started but not finished
+ * @name_len: volume name length
+ * @name: the volume name
+ * @flags: volume flags (%UBI_VTBL_AUTORESIZE_FLG)
+ * @padding: reserved, zeroes
+ * @crc: a CRC32 checksum of the record
+ *
+ * The volume table records are stored in the volume table, which is stored in
+ * the layout volume. The layout volume consists of 2 logical eraseblock, each
+ * of which contains a copy of the volume table (i.e., the volume table is
+ * duplicated). The volume table is an array of &struct ubi_vtbl_record
+ * objects indexed by the volume ID.
+ *
+ * If the size of the logical eraseblock is large enough to fit
+ * %UBI_MAX_VOLUMES records, the volume table contains %UBI_MAX_VOLUMES
+ * records. Otherwise, it contains as many records as it can fit (i.e., size of
+ * logical eraseblock divided by sizeof(struct ubi_vtbl_record)).
+ *
+ * The @upd_marker flag is used to implement volume update. It is set to %1
+ * before update and set to %0 after the update. So if the update operation was
+ * interrupted, UBI knows that the volume is corrupted.
+ *
+ * The @alignment field is specified when the volume is created and cannot be
+ * later changed. It may be useful, for example, when a block-oriented file
+ * system works on top of UBI. The @data_pad field is calculated using the
+ * logical eraseblock size and @alignment. The alignment must be multiple to the
+ * minimal flash I/O unit. If @alignment is 1, all the available space of
+ * the physical eraseblocks is used.
+ *
+ * Empty records contain all zeroes and the CRC checksum of those zeroes.
+ */
+struct ubi_vtbl_record {
+	__be32  reserved_pebs;
+	__be32  alignment;
+	__be32  data_pad;
+	__u8    vol_type;
+	__u8    upd_marker;
+	__be16  name_len;
+	__u8    name[UBI_VOL_NAME_MAX+1];
+	__u8    flags;
+	__u8    padding[23];
+	__be32  crc;
+} __attribute__ ((packed));
+
+#endif /* !__UBI_MEDIA_H__ */
diff --git a/fastboot_app/utils/ubi/ubiattach.c b/fastboot_app/utils/ubi/ubiattach.c
new file mode 100644
index 0000000..44f1b51
--- /dev/null
+++ b/fastboot_app/utils/ubi/ubiattach.c
@@ -0,0 +1,190 @@
+/*
+ * Copyright (C) 2007 Nokia Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 51
+ * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/*
+ * An utility to attach MTD devices to UBI.
+ *
+ * Author: Artem Bityutskiy
+ */
+#define PROGRAM_NAME    "ubiattach"
+
+#include <stdio.h>
+#include <stdint.h>
+#include <getopt.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <libubi.h>
+#include "common.h"
+#include "ubiutils-common.h"
+
+#include "bpi_ubi.h"
+
+#define DEFAULT_CTRL_DEV "/dev/ubi_ctrl"
+
+/* The variables below are set by command line arguments */
+struct args {
+	int devn;
+	int mtdn;
+	int vidoffs;
+	const char *node;
+	const char *dev;
+	int max_beb_per1024;
+};
+
+static struct args args = {
+	.devn = UBI_DEV_NUM_AUTO,
+	.mtdn = -1,
+	.vidoffs = 0,
+	.node = DEFAULT_CTRL_DEV,
+	.dev = NULL,
+	.max_beb_per1024 = 0,
+};
+
+int bpi_ubi_attach(int devn, int mtdn)
+{
+    int err;
+    libubi_t libubi;
+    struct ubi_info ubi_info;
+    struct ubi_dev_info dev_info;
+    struct ubi_attach_request req;
+
+    libubi = libubi_open();
+    if (!libubi) {
+    	if (errno == 0){
+    		return errmsg("UBI is not present in the system");
+      }
+    	return sys_errmsg("cannot open libubi");
+    }
+
+    /*
+     * Make sure the kernel is fresh enough and this feature is supported.
+     */
+    err = ubi_get_info(libubi, &ubi_info);
+    if (err) {
+    	sys_errmsg("cannot get UBI information");
+    	goto out_libubi;
+    }
+
+    if (ubi_info.ctrl_major == -1) {
+    	errmsg("MTD attach/detach feature is not supported by your kernel");
+    	goto out_libubi;
+    }
+
+    req.dev_num = devn;
+    req.mtd_num = mtdn;
+    req.vid_hdr_offset = args.vidoffs;
+    req.mtd_dev_node = args.dev;
+    req.max_beb_per1024 = args.max_beb_per1024;
+
+    err = ubi_attach(libubi, args.node, &req);
+    if (err < 0) {
+    	if (args.dev)
+    		sys_errmsg("cannot attach \"%s\"", args.dev);
+    	else
+    		sys_errmsg("cannot attach mtd%d", args.mtdn);
+    	goto out_libubi;
+    } else if (err == 1) {
+    	/* The kernel did not support the 'max_beb_per1024' parameter */
+    	warnmsg("the --max-beb-per1024=%d parameter was ignored", args.max_beb_per1024);
+    	normsg("the UBI kernel driver does not support does not allow changing the reserved PEBs count");
+    	normsg("the support was added in kernel version 3.7, probably you are running older kernel?");
+    	goto out_libubi;
+    }
+
+    /* Print some information about the new UBI device */
+    err = ubi_get_dev_info1(libubi, req.dev_num, &dev_info);
+    if (err) {
+    	sys_errmsg("cannot get information about newly created UBI device");
+    	goto out_libubi;
+    }
+
+    printf("UBI device number %d, total %d LEBs (", dev_info.dev_num, dev_info.total_lebs);
+    ubiutils_print_bytes(dev_info.total_bytes, 0);
+    printf("), available %d LEBs (", dev_info.avail_lebs);
+    ubiutils_print_bytes(dev_info.avail_bytes, 0);
+    printf("), LEB size ");
+    ubiutils_print_bytes(dev_info.leb_size, 1);
+    printf("\n");
+
+    libubi_close(libubi);
+    return 0;
+
+out_libubi:
+    libubi_close(libubi);
+    return -1;
+
+}
+
+int bpi_ubi_detach(int devn, int mtdn){
+    int err;
+    libubi_t libubi;
+    struct ubi_info ubi_info;
+
+    libubi = libubi_open();
+    if (!libubi) {
+    	if (errno == 0){
+    		return errmsg("UBI is not present in the system");
+      }
+    	return sys_errmsg("cannot open libubi");
+    }
+
+    /*
+     * Make sure the kernel is fresh enough and this feature is supported.
+     */
+    err = ubi_get_info(libubi, &ubi_info);
+    if (err) {
+    	sys_errmsg("cannot get UBI information");
+    	goto out_libubi;
+    }
+
+    if (ubi_info.ctrl_major == -1) {
+    	errmsg("MTD detach/detach feature is not supported by your kernel");
+    	goto out_libubi;
+    }
+
+    args.devn = devn;
+    args.mtdn = mtdn;
+    if (args.devn != -1) {
+    	err = ubi_remove_dev(libubi, args.node, args.devn);
+    	if (err) {
+    		sys_errmsg("cannot remove ubi%d", args.devn);
+    		goto out_libubi;
+    	}
+    } else {
+    	if (args.dev != NULL) {
+    		err = ubi_detach(libubi, args.node, args.dev);
+    		if (err) {
+    			sys_errmsg("cannot detach \"%s\"", args.dev);
+    			goto out_libubi;
+    		}
+    	} else {
+    		err = ubi_detach_mtd(libubi, args.node, args.mtdn);
+    		if (err) {
+    			sys_errmsg("cannot detach mtd%d", args.mtdn);
+    			goto out_libubi;
+    		}
+    	}
+    }
+
+    libubi_close(libubi);
+    return 0;
+
+out_libubi:
+    libubi_close(libubi);
+    return -1;
+}
\ No newline at end of file
diff --git a/fastboot_app/utils/ubi/ubiutils-common.c b/fastboot_app/utils/ubi/ubiutils-common.c
new file mode 100644
index 0000000..6609a6b
--- /dev/null
+++ b/fastboot_app/utils/ubi/ubiutils-common.c
@@ -0,0 +1,211 @@
+/*
+ * Copyright (C) 2007, 2008 Nokia Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * This file contains various common stuff used by UBI utilities.
+ *
+ * Authors: Artem Bityutskiy
+ *          Adrian Hunter
+ */
+
+#define PROGRAM_NAME "ubiutils"
+
+#include <sys/time.h>
+#include <sys/types.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include "common.h"
+
+/**
+ * get_multiplier - convert size specifier to an integer multiplier.
+ * @str: the size specifier string
+ *
+ * This function parses the @str size specifier, which may be one of
+ * 'KiB', 'MiB', or 'GiB' into an integer multiplier. Returns positive
+ * size multiplier in case of success and %-1 in case of failure.
+ */
+static int get_multiplier(const char *str)
+{
+	if (!str)
+		return 1;
+
+	/* Remove spaces before the specifier */
+	while (*str == ' ' || *str == '\t')
+		str += 1;
+
+	if (!strcmp(str, "KiB"))
+		return 1024;
+	if (!strcmp(str, "MiB"))
+		return 1024 * 1024;
+	if (!strcmp(str, "GiB"))
+		return 1024 * 1024 * 1024;
+
+	return -1;
+}
+
+/**
+ * ubiutils_get_bytes - convert a string containing amount of bytes into an
+ * integer
+ * @str: string to convert
+ *
+ * This function parses @str which may have one of 'KiB', 'MiB', or 'GiB'
+ * size specifiers. Returns positive amount of bytes in case of success and %-1
+ * in case of failure.
+ */
+long long ubiutils_get_bytes(const char *str)
+{
+	char *endp;
+	long long bytes = strtoull(str, &endp, 0);
+
+	if (endp == str || bytes < 0) {
+		fprintf(stderr, "incorrect amount of bytes: \"%s\"\n", str);
+		return -1;
+	}
+
+	if (*endp != '\0') {
+		int mult = get_multiplier(endp);
+
+		if (mult == -1) {
+			fprintf(stderr, "bad size specifier: \"%s\" - "
+			        "should be 'KiB', 'MiB' or 'GiB'\n", endp);
+			return -1;
+		}
+		bytes *= mult;
+	}
+
+	return bytes;
+}
+
+/**
+ * ubiutils_print_bytes - print bytes.
+ * @bytes: variable to print
+ * @bracket: whether brackets have to be put or not
+ *
+ * This is a helper function which prints amount of bytes in a human-readable
+ * form, i.e., it prints the exact amount of bytes following by the approximate
+ * amount of Kilobytes, Megabytes, or Gigabytes, depending on how big @bytes
+ * is.
+ */
+void ubiutils_print_bytes(long long bytes, int bracket)
+{
+	const char *p;
+
+	if (bracket)
+		p = " (";
+	else
+		p = ", ";
+
+	printf("%lld bytes", bytes);
+
+	if (bytes > 1024 * 1024 * 1024)
+		printf("%s%.1f GiB", p, (double)bytes / (1024 * 1024 * 1024));
+	else if (bytes > 1024 * 1024)
+		printf("%s%.1f MiB", p, (double)bytes / (1024 * 1024));
+	else if (bytes > 1024 && bytes != 0)
+		printf("%s%.1f KiB", p, (double)bytes / 1024);
+	else
+		return;
+
+	if (bracket)
+		printf(")");
+}
+
+/**
+ * ubiutils_print_text - print text and fold it.
+ * @stream: file stream to print to
+ * @text: text to print
+ * @width: maximum allowed text width
+ *
+ * Print text and fold it so that each line would not have more then @width
+ * characters.
+ */
+void ubiutils_print_text(FILE *stream, const char *text, int width)
+{
+	int pos, bpos = 0;
+	const char *p;
+	char line[1024];
+
+	if (width > 1023) {
+		fprintf(stream, "%s\n", text);
+		return;
+	}
+	p = text;
+	pos = 0;
+	while (p[pos]) {
+		while (!isspace(p[pos])) {
+			line[pos] = p[pos];
+			if (!p[pos])
+				break;
+			++pos;
+			if (pos == width) {
+				line[pos] = '\0';
+				fprintf(stream, "%s\n", line);
+				p += pos;
+				pos = 0;
+			}
+		}
+		while (pos < width) {
+			line[pos] = p[pos];
+			if (!p[pos]) {
+				bpos = pos;
+				break;
+			}
+			if (isspace(p[pos]))
+				bpos = pos;
+			++pos;
+		}
+		line[bpos] = '\0';
+		fprintf(stream, "%s\n", line);
+		p += bpos;
+		pos = 0;
+		while (p[pos] && isspace(p[pos]))
+			++p;
+	}
+}
+
+/**
+ * ubiutils_srand - randomly seed the standard pseudo-random generator.
+ *
+ * This helper function seeds the standard libc pseudo-random generator with a
+ * more or less random value to make sure the 'rand()' call does not return the
+ * same sequence every time UBI utilities run. Returns zero in case of success
+ * and a %-1 in case of error.
+ */
+int ubiutils_srand(void)
+{
+	struct timeval tv;
+	struct timezone tz;
+	unsigned int seed;
+
+	/*
+	 * Just assume that a combination of the PID + current time is a
+	 * reasonably random number.
+	 */
+	if (gettimeofday(&tv, &tz))
+		return -1;
+
+	seed = (unsigned int)tv.tv_sec;
+	seed += (unsigned int)tv.tv_usec;
+	seed *= getpid();
+	seed %= RAND_MAX;
+	srand(seed);
+	return 0;
+}
diff --git a/fastboot_app/utils/ubi/ubiutils-common.h b/fastboot_app/utils/ubi/ubiutils-common.h
new file mode 100644
index 0000000..762e21f
--- /dev/null
+++ b/fastboot_app/utils/ubi/ubiutils-common.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) Artem Bityutskiy, 2007, 2008
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __UBI_UTILS_COMMON_H__
+#define __UBI_UTILS_COMMON_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+long long ubiutils_get_bytes(const char *str);
+void ubiutils_print_bytes(long long bytes, int bracket);
+void ubiutils_print_text(FILE *stream, const char *txt, int len);
+int ubiutils_srand(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !__UBI_UTILS_COMMON_H__ */
+
diff --git a/fastboot_app/utils/ubi/version.h b/fastboot_app/utils/ubi/version.h
new file mode 100644
index 0000000..2ed1b2c
--- /dev/null
+++ b/fastboot_app/utils/ubi/version.h
@@ -0,0 +1 @@
+#define VERSION "1.5.0"
diff --git a/fastboot_app/utils/ubi/xalloc.h b/fastboot_app/utils/ubi/xalloc.h
new file mode 100644
index 0000000..f1cc8d4
--- /dev/null
+++ b/fastboot_app/utils/ubi/xalloc.h
@@ -0,0 +1,106 @@
+/*
+ * memory wrappers
+ *
+ * Copyright (c) Artem Bityutskiy, 2007, 2008
+ * Copyright 2001, 2002 Red Hat, Inc.
+ *           2001 David A. Schleef <ds@lineo.com>
+ *           2002 Axis Communications AB
+ *           2001, 2002 Erik Andersen <andersen@codepoet.org>
+ *           2004 University of Szeged, Hungary
+ *           2006 KaiGai Kohei <kaigai@ak.jp.nec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __MTD_UTILS_XALLOC_H__
+#define __MTD_UTILS_XALLOC_H__
+
+#include <stdlib.h>
+#include <string.h>
+
+/*
+ * Mark these functions as unused so that gcc does not emit warnings
+ * when people include this header but don't use every function.
+ */
+
+__attribute__((unused))
+static void *xmalloc(size_t size)
+{
+	void *ptr = malloc(size);
+
+	if (ptr == NULL && size != 0)
+		sys_errmsg_die("out of memory");
+	return ptr;
+}
+
+__attribute__((unused))
+static void *xcalloc(size_t nmemb, size_t size)
+{
+	void *ptr = calloc(nmemb, size);
+
+	if (ptr == NULL && nmemb != 0 && size != 0)
+		sys_errmsg_die("out of memory");
+	return ptr;
+}
+
+__attribute__((unused))
+static void *xzalloc(size_t size)
+{
+	return xcalloc(1, size);
+}
+
+__attribute__((unused))
+static void *xrealloc(void *ptr, size_t size)
+{
+	ptr = realloc(ptr, size);
+	if (ptr == NULL && size != 0)
+		sys_errmsg_die("out of memory");
+	return ptr;
+}
+
+__attribute__((unused))
+static char *xstrdup(const char *s)
+{
+	char *t;
+
+	if (s == NULL)
+		return NULL;
+	t = strdup(s);
+	if (t == NULL)
+		sys_errmsg_die("out of memory");
+	return t;
+}
+
+#ifdef _GNU_SOURCE
+#include <stdarg.h>
+
+__attribute__((unused))
+static int xasprintf(char **strp, const char *fmt, ...)
+{
+	int cnt;
+	va_list ap;
+
+	va_start(ap, fmt);
+	cnt = vasprintf(strp, fmt, ap);
+	va_end(ap);
+
+	if (cnt == -1)
+		sys_errmsg_die("out of memory");
+
+	return cnt;
+}
+#endif
+
+#endif /* !__MTD_UTILS_XALLOC_H__ */
diff --git a/fastboot_app/utils/xmodem/xmodem.c b/fastboot_app/utils/xmodem/xmodem.c
new file mode 100644
index 0000000..82a8526
--- /dev/null
+++ b/fastboot_app/utils/xmodem/xmodem.c
@@ -0,0 +1,1778 @@
+//////////////////////////////////////////////////////////////////////////////
+//                                                                          //
+//                                      _                                   //
+//         __  __ _ __ ___    ___    __| |  ___  _ __ ___      ___          //
+//         \ \/ /| '_ ` _ \  / _ \  / _` | / _ \| '_ ` _ \    / __|         //
+//          >  < | | | | | || (_) || (_| ||  __/| | | | | | _| (__          //
+//         /_/\_\|_| |_| |_| \___/  \__,_| \___||_| |_| |_|(_)\___|         //
+//                                                                          //
+//                                                                          //
+//////////////////////////////////////////////////////////////////////////////
+//                                                                          //
+//          Copyright (c) 2012 by S.F.T. Inc. - All rights reserved         //
+//  Use, copying, and distribution of this software are licensed according  //
+//    to the GPLv2, LGPLv2, or BSD license, as appropriate (see COPYING)    //
+//                                                                          //
+//////////////////////////////////////////////////////////////////////////////
+
+
+// XMODEM adapted for arduino and POSIX systems.  Windows code incomplete
+
+#include "xmodem.h"
+
+// internal structure definitions
+
+// Windows requires a different way of specifying structure packing
+#ifdef WIN32
+#define PACKED
+#pragma pack(push,1)
+#else // POSIX, ARDUINO
+#define PACKED __attribute__((__packed__))
+#endif // WIN32 vs THE REST OF THE WORLD
+
+#define _SOH_ 1 /* start of packet - note XMODEM-1K uses '2' */
+#define _EOT_ 4
+#define _ENQ_ 5
+#define _ACK_ 6
+#define _NAK_ 21 /* NAK character */
+#define _CAN_ 24 /* CAN character CTRL+X */
+
+/** \file xmodem.c
+  * \brief main source file for S.F.T. XMODEM library
+  *
+  * S.F.T. XMODEM library
+**/
+
+/** \ingroup xmodem_internal
+  * \brief Structure defining an XMODEM CHECKSUM packet
+  *
+\code
+typedef struct _XMODEM_BUF_
+{
+   char cSOH;                   // ** SOH byte goes here             **
+   unsigned char aSEQ, aNotSEQ; // ** 1st byte = seq#, 2nd is ~seq#  **
+   char aDataBuf[128];          // ** the actual data itself!        **
+   unsigned char bCheckSum;     // ** checksum gets 1 byte           **
+} PACKED XMODEM_BUF;
+
+\endcode
+  *
+**/
+typedef struct _XMODEM_BUF_
+{
+   char cSOH;                   ///< SOH byte goes here
+   unsigned char aSEQ, aNotSEQ; ///< 1st byte = seq#, 2nd is ~seq#
+   char aDataBuf[128];          ///< the actual data itself!
+   unsigned char bCheckSum;     ///< checksum gets 1 byte
+} PACKED XMODEM_BUF;
+
+/** \ingroup xmodem_internal
+  * \brief Structure defining an XMODEM CRC packet
+  *
+\code
+typedef struct _XMODEMC_BUF_
+{
+   char cSOH;                   // ** SOH byte goes here             **
+   unsigned char aSEQ, aNotSEQ; // ** 1st byte = seq#, 2nd is ~seq#  **
+   char aDataBuf[128];          // ** the actual data itself!        **
+   unsigned short wCRC;         // ** CRC gets 2 bytes, high endian  **
+} PACKED XMODEMC_BUF;
+
+\endcode
+  *
+**/
+typedef struct _XMODEMC_BUF_
+{
+   char cSOH;                   ///< SOH byte goes here
+   unsigned char aSEQ, aNotSEQ; ///< 1st byte = seq#, 2nd is ~seq#
+   char aDataBuf[128];          ///< the actual data itself!
+   unsigned short wCRC;         ///< CRC gets 2 bytes, high endian
+} PACKED XMODEMC_BUF;
+
+#ifdef WIN32
+// restore default packing
+#pragma pack(pop)
+#endif // WIN32
+
+/** \ingroup xmodem_internal
+  * \brief Structure that identifies the XMODEM communication state
+  *
+\code
+typedef struct _XMODEM_
+{
+  SERIAL_TYPE ser;     // identifies the serial connection, data type is OS-dependent
+  FILE_TYPE file;      // identifies the file handle, data type is OS-dependent
+
+  union
+  {
+    XMODEM_BUF xbuf;   // XMODEM CHECKSUM buffer
+    XMODEMC_BUF xcbuf; // XMODEM CRC buffer
+  } buf;               // union of both buffers, total length 133 bytes
+
+  unsigned char bCRC;  // non-zero for CRC, zero for checksum
+
+} XMODEM;
+
+\endcode
+  *
+**/
+typedef struct _XMODEM_
+{
+  SERIAL_TYPE ser;     ///< identifies the serial connection, data type is OS-dependent
+  FILE_TYPE file;      ///< identifies the file handle, data type is OS-dependent
+
+  union
+  {
+    XMODEM_BUF xbuf;   ///< XMODEM CHECKSUM buffer
+    XMODEMC_BUF xcbuf; ///< XMODEM CRC buffer
+  } buf;               ///< union of both buffers, total length 133 bytes
+
+  unsigned char bCRC;  ///< non-zero for CRC, zero for checksum
+
+} XMODEM;
+
+
+#ifdef DEBUG_CODE
+static char szERR[32]; // place for error messages, up to 16 characters
+
+const char *XMGetError(void)
+{
+  return szERR;
+}
+#endif // DEBUG_CODE
+
+#if defined(STAND_ALONE) && defined(DEBUG_CODE)
+void debug_dump_buffer(int iDir, const void *pBuf, int cbBuf)
+{
+int i1, i2;
+const unsigned char *p1, *p2;
+
+  if(cbBuf <= 0)
+  {
+    return;
+  }
+
+  p1 = p2 = (const unsigned char *)pBuf;
+
+  for(i1=0, i2=0; i1 <= cbBuf; i1++, p1++)
+  {
+    if(!i1 || i2 >= 16 || i1 == cbBuf)
+    {
+      if(i1)
+      {
+        while(i2 < 16)
+        {
+          fputs("    ", stderr); // fill up spaces where data would be
+          i2++;
+        }
+
+        fputs(" : ", stderr);
+
+        while(p2 < p1)
+        {
+          if(*p2 >= 32 && *p2 <= 127)
+          {
+            fputc(*p2, stderr);
+          }
+          else
+          {
+            fputc('.', stderr);
+          }
+
+          p2++;
+        }
+
+        fputc('\n', stderr);
+      }
+
+      if(!i1 && iDir > 0)
+      {
+        fputs("--> ", stderr);
+      }
+      else if(!i1 && iDir < 0)
+      {
+        fputs("<-- ", stderr);
+      }
+      else
+      {
+        fputs("    ", stderr);
+      }
+
+      i2 = 0;
+      p2 = p1; // make sure
+    }
+
+    if(i1 < cbBuf)
+    {
+      if(!i2)
+      {
+        fprintf(stderr, "%02x: %02x", i1, *p1);
+      }
+      else
+      {
+        fprintf(stderr, ", %02x", *p1);
+      }
+
+      i2++;
+    }
+  }
+
+  fputc('\n', stderr);
+  fflush(stderr);
+}
+#endif // STAND_ALONE, DEBUG_CODE
+
+
+//char iBinaryTransfer = 0, iDisableRXOVER = 0;
+
+/** \ingroup xmodem_internal
+  * \brief Calculate checksum for XMODEM packet
+  *
+  * \param lpBuf A pointer to the XMODEM data buffer
+  * \param cbBuf The length of the XMODEM data buffer (typically 128)
+  * \return An unsigned char value to be assigned to the 'checksum' element in the XMODEM packet
+  *
+**/
+unsigned char CalcCheckSum(const char *lpBuf, short cbBuf)
+{
+short iC, i1;
+
+  iC = 0;
+
+  for(i1 = 0; i1 < cbBuf; i1++)
+  {
+    iC += lpBuf[i1];
+  }
+
+  return (unsigned char)(iC & 0xff);
+}
+
+/** \ingroup xmodem_internal
+  * \brief Calculate checksum for XMODEM packet
+  *
+  * \param sVal An unsigned short integer to be made 'high endian' by flipping bytes (as needed)
+  * \return A (possibly) byte-flipped high-endian unsigned short integer
+  *
+  * This function assumes low-endian for Arduino, and performs a universal operation
+  * for 'indeterminate' architectures.
+**/
+static unsigned short my_htons(unsigned short sVal)
+{
+  union
+  {
+    unsigned char aVal[2];
+    unsigned short sVal;
+  } a;
+
+  // tweeked for size and speed.  enjoy.
+
+#ifdef ARDUINO
+
+  a.aVal[0] = b.aVal[1]; // no math involved, pre-optimized code
+  a.aVal[1] = b.aVal[0];
+
+#else
+
+  a.aVal[0] = (unsigned char)(sVal >> 8); // less optimized but universal code
+  a.aVal[1] = (unsigned char)(sVal & 0xff);
+
+#endif // ARDUINO
+
+  return a.sVal;
+}
+
+/** \ingroup xmodem_internal
+  * \brief Calculate 16-bit CRC for XMODEM packet
+  *
+  * \param lpBuf A pointer to the XMODEM data buffer
+  * \param cbBuf The length of the XMODEM data buffer (typically 128)
+  * \return A high-endian 16-bit (unsigned short) value to be assigned to the 'CRC' element in the XMODEM packet
+  *
+  * This method uses the 'long way' which is SMALLER CODE for microcontrollers, but eats up a bit more CPU.
+  * Otherwise, you'd have to pre-build the 256 byte table and use "the table lookup" method.
+**/
+unsigned short CalcCRC(const char *lpBuf, short cbBuf)
+{
+unsigned short wCRC;
+short i1, i2, iAX;
+char cAL;
+
+  // ** this function returns 2-byte string containing
+  // ** the CRC calculation result, as high endian
+
+  wCRC = 0;
+
+  for(i1=0; i1 < cbBuf; i1++)
+  {
+    cAL = lpBuf[i1];
+
+    iAX = (unsigned short)cAL << 8;
+
+    wCRC = iAX ^ wCRC;
+
+    for(i2=0; i2 < 8; i2++)
+    {
+      iAX = wCRC;
+
+      if(iAX & 0x8000)
+      {
+        wCRC <<= 1;
+        wCRC ^= 0x1021;
+      }
+      else
+      {
+        wCRC <<= 1;
+      }
+    }
+  }
+
+  return my_htons(wCRC);
+}
+
+//void WaitASecond()
+//{
+//#ifdef ARDUINO
+//  delay(1000);
+//#elif defined(WIN32)
+//  Sleep(1000);
+//#else //
+//  usleep(1000000);
+//#endif // ARDUINO
+//}
+
+#ifndef ARDUINO
+#ifdef WIN32
+#define MyMillis GetTickCount
+#else // WIN32
+
+/** \ingroup xmodem_internal
+  * \brief Return internal 'milliseconds' value for timing purposes
+  *
+  * \return A calculated 'milliseconds' value as an unsigned long integer
+  *
+  * This function returns the 'unsigned long' integer value for elapsed time based
+  * on the result of the 'gettimeofday()' API function.  On 32-bit and Windows systems
+  * the value might wrap around, so you should be careful with your time comparisons (see the
+  * code _I_ wrote for the right way to do it). On 64-bit POSIX systems, this value will
+  * always increase.\n
+  * NOTE:  Win32 defines this as a macro (see above) for the 'GetTickCount()' api, which
+  *        returns a 32-bit value.  POSIX x86 returns 32-bit, x64 returns 64-bit.  YMMV.
+**/
+unsigned long MyMillis(void)
+{
+struct timeval tv;
+
+  gettimeofday(&tv, NULL); // 2nd parameter is obsolete anyway
+
+  // NOTE:  this won't roll over the way 'GetTickCount' does in WIN32 so I'll truncate it
+  //        down to a 32-bit value to make it happen.  Everything that uses 'MyGetTickCount'
+  //        must handle this rollover properly using 'int' and not 'long' (or cast afterwards)
+  return((unsigned int)((unsigned long)tv.tv_sec * 1000L + (unsigned long)tv.tv_usec / 1000L));
+}
+#endif // WIN32
+#endif // ARDUINO
+
+//Function GenerateSEQ (wSeq%) As String
+//
+//   GenerateSEQ = Chr$(wSeq%) + Chr$(Not (wSeq%) And &HFF)
+//
+//End Function
+
+/** \ingroup xmodem_internal
+  * \brief Generate a sequence number pair, place into XMODEM_BUF
+  *
+  * \param pBuf A pointer to an XMODEM_BUF structure
+  * \param bSeq An unsigned char, typically cast from an unsigned long 'block number'
+  *
+  * This function generates the sequence pair for the XMODEM packet.  The 'block number'
+  * is initially assigned a value of '1', and increases by 1 for each successful packet.
+  * That value is 'truncated' to a single byte and assigned as a sequence number for the
+  * packet itself.
+**/
+void GenerateSEQ(XMODEM_BUF *pBuf, unsigned char bSeq)
+{
+  pBuf->aSEQ = bSeq;
+  pBuf->aNotSEQ = ~bSeq;
+}
+
+/** \ingroup xmodem_internal
+  * \brief Generate a sequence number pair, place into XMODEMC_BUF (the CRC version)
+  *
+  * \param pBuf A pointer to an XMODEM_BUF structure
+  * \param bSeq An unsigned char, typically cast from an unsigned long 'block number'
+  *
+  * This function generates the sequence pair for the XMODEM packet.  The 'block number'
+  * is initially assigned a value of '1', and increases by 1 for each successful packet.
+  * That value is 'truncated' to a single byte and assigned as a sequence number for the
+  * packet itself.
+**/
+void GenerateSEQC(XMODEMC_BUF *pBuf, unsigned char bSeq)
+{
+  pBuf->aSEQ = bSeq;
+  pBuf->aNotSEQ = (255 - bSeq);//~bSeq; these should be the same but for now I do this...
+}
+
+/** \ingroup xmodem_internal
+  * \brief Get an XMODEM block from the serial device
+  *
+  * \param ser A 'SERIAL_TYPE' identifier for the serial connection
+  * \param pBuf A pointer to the buffer that receives the data
+  * \param cbSize The number of bytes/chars to read
+  * \return The number of bytes/chars read, 0 if timed out (no data), < 0 on error
+  *
+  * Call this function to read data from the serial port, specifying the number of
+  * bytes to read.  This function times out after no data transferred (silence) for
+  * a period of 'SILENCE_TIMEOUT' milliseconds.  This allows spurious data transfers
+  * to continue as long as there is LESS THAN 'SILENCE_TIMEOUT' between bytes, and
+  * also allows VERY SLOW BAUD RATES (as needed).  However, if the transfer takes longer
+  * than '10 times SILENCE_TIMEOUT', the function will return the total number of bytes
+  * that were received within that time.\n
+  * The default value of 5 seconds, extended to 50 seconds, allows a worst-case baud
+  * rate of about 20.  This should not pose a problem.  If it does, edit the code.
+**/
+short GetXmodemBlock(SERIAL_TYPE ser, char *pBuf, short cbSize)
+{
+unsigned long ulCur;
+short cb1;
+char *p1;
+
+// ** This function obtains a buffer of 'wSize%' bytes,      **
+// ** waiting a maximum of 5 seconds (of silence) to get it. **
+// ** It returns this block as a string of 'wSize%' bytes,   **
+// ** or a zero length string on error.                      **
+
+//   iDisableRXOVER% = 1; // bug workaround
+
+#ifdef ARDUINO
+short i1;
+
+  p1 = pBuf;
+  cb1 = 0;
+
+  ulCur = millis();
+  ser->setTimeout(SILENCE_TIMEOUT); // 5 seconds [of silence]
+
+  for(i1=0; i1 < cbSize; i1++)
+  {
+    if(ser->readBytes(p1, 1) != 1) // 5 seconds of "silence" is what fails this
+    {
+      break;
+    }
+
+    cb1++;
+    p1++;
+
+    if((millis() - ulCur) > (unsigned long)(10L * SILENCE_TIMEOUT)) // 10 times SILENCE TIMEOUT for TOTAL TIMEOUT
+    {
+      break; // took too long, I'm going now
+    }
+  }
+
+#elif defined(WIN32)
+
+#error no win32 code yet
+
+#else // POSIX
+int i1, i2;
+unsigned long ulStart;
+
+
+  if(fcntl(ser, F_SETFL, O_NONBLOCK) == -1)
+  {
+    static int iFailFlag = 0;
+
+    if(!iFailFlag)
+    {
+      fprintf(stderr, "Warning:  'fcntl(O_NONBLOCK)' failed, errno = %d\n", errno);
+      fflush(stderr);
+      iFailFlag = 1;
+    }
+  }
+
+  p1 = pBuf;
+  cb1 = 0;
+
+  ulStart = ulCur = MyMillis();
+
+  for(i1=0; i1 < cbSize; i1++)
+  {
+    while((i2 = read(ser, p1, 1)) != 1)
+    {
+      if(i2 < 0 && errno != EAGAIN)
+      {
+        // read error - exit now
+//        return cb1; // how many bytes I actually read
+        goto the_end;
+      }
+      else
+      {
+        usleep(1000); // 1 msec
+
+        if((MyMillis() - ulCur) > SILENCE_TIMEOUT || // too much silence?
+           (MyMillis() - ulStart) > 10 * SILENCE_TIMEOUT) // too long for transfer
+        {
+//          return cb1; // finished (return how many bytes I actually read)
+          goto the_end;
+        }
+      }
+    }
+
+    // here it succeeds
+
+    cb1++;
+    p1++;
+
+    if((MyMillis() - ulStart) > 10 * SILENCE_TIMEOUT) // 10 times SILENCE TIMEOUT for TOTAL TIMEOUT
+    {
+      break; // took too long, I'm going now
+    }
+  }
+
+the_end:
+
+#ifdef STAND_ALONE
+  fprintf(stderr, "GetXmodemBlock - request %d, read %d  errno=%d\n", cbSize, cb1, errno);
+  fflush(stderr);
+#ifdef DEBUG_CODE
+  debug_dump_buffer(-1, pBuf, cb1);
+#endif // DEBUG_CODE
+#endif // STAND_ALONE
+
+#endif // ARDUINO
+
+  return cb1; // what I actually read
+}
+
+/** \ingroup xmodem_internal
+  * \brief Write a single character to the serial device
+  *
+  * \param ser A 'SERIAL_TYPE' identifier for the serial connection
+  * \param bVal The byte to send
+  * \return The number of bytes/chars written, or < 0 on error
+  *
+  * Call this function to write one byte of data to the serial port.  Typically
+  * this is used to send things like an ACK or NAK byte.
+**/
+int WriteXmodemChar(SERIAL_TYPE ser, unsigned char bVal)
+{
+int iRval;
+#ifdef ARDUINO
+
+  iRval = ser->write(bVal);
+//  ser->flush(); // force sending it
+
+#elif defined(WIN32)
+
+#error no win32 code yet
+
+#else // POSIX
+char buf[2]; // use size of '2' to avoid warnings about array size of '1'
+
+  if(fcntl(ser, F_SETFL, 0) == -1) // set blocking mode
+  {
+    static int iFailFlag = 0;
+
+    if(!iFailFlag)
+    {
+      fprintf(stderr, "Warning:  'fcntl(O_NONBLOCK)' failed, errno = %d\n", errno);
+      iFailFlag = 1;
+    }
+  }
+
+  buf[0] = bVal; // in case args are passed by register
+
+  iRval = write(ser, buf, 1);
+
+#if defined(STAND_ALONE) && defined(DEBUG_CODE)
+  fprintf(stderr, "WriteXmodemChar - returns %d\n", iRval);
+  if(iRval > 0)
+  {
+    debug_dump_buffer(1, buf, 1);
+  }
+#endif // STAND_ALONE, DEBUG_CODE
+#endif // ARDUINO
+
+  return iRval;
+}
+
+/** \ingroup xmodem_internal
+  * \brief Send an XMODEM block via the serial device
+  *
+  * \param ser A 'SERIAL_TYPE' identifier for the serial connection
+  * \param pBuf A pointer to the buffer that receives the data
+  * \param cbSize The number of bytes/chars to write
+  * \return The number of bytes/chars written, < 0 on error
+  *
+  * Call this function to write data via the serial port, specifying the number of
+  * bytes to write.
+**/
+int WriteXmodemBlock(SERIAL_TYPE ser, const void *pBuf, int cbSize)
+{
+int iRval;
+#ifdef ARDUINO
+
+  iRval = ser->write((const uint8_t *)pBuf, cbSize);
+//  ser->flush(); // force sending it before returning
+
+#elif defined(WIN32)
+
+#error no win32 code yet
+
+#else // POSIX
+
+
+  if(fcntl(ser, F_SETFL, 0) == -1) // set blocking mode
+  {
+    static int iFailFlag = 0;
+
+    if(!iFailFlag)
+    {
+      fprintf(stderr, "Warning:  'fcntl(O_NONBLOCK)' failed, errno = %d\n", errno);
+      fflush(stderr);
+      iFailFlag = 1;
+    }
+  }
+
+  iRval = write(ser, pBuf, cbSize);
+
+#if defined(STAND_ALONE) && defined(DEBUG_CODE)
+  fprintf(stderr, "\r\nWriteXmodemBlock - returns %d\n", iRval);
+  fflush(stderr);
+
+  if(iRval > 0)
+  {
+    debug_dump_buffer(1, pBuf, cbSize);
+  }
+#endif // STAND_ALONE, DEBUG_CODE
+#endif
+
+  return iRval;
+}
+
+/** \ingroup xmodem_internal
+  * \brief Read all input from the serial port until there is 1 second of 'silence'
+  *
+  * \param ser A 'SERIAL_TYPE' identifier for the serial connection
+  *
+  * Call this function to read ALL data from the serial port, until there is a period
+  * with no data (i.e. 'silence') for 1 second.  At that point the function will return.\n
+  * Some operations require that any bad data be flushed out of the input to prevent
+  * synchronization problems.  By using '1 second of silence' it forces re-synchronization
+  * to occur in one shot, with the possible exception of VERY noisy lines.  The down side
+  * is that it may slow down transfers with a high data rate.
+**/
+void XModemFlushInput(SERIAL_TYPE ser)
+{
+unsigned long ulStart;
+#ifdef ARDUINO
+
+  ulStart = millis();
+
+  do
+  {
+    if(ser->available())
+    {
+      ser->read(); // don't care about the data
+      ulStart = millis(); // reset time
+    }
+    else
+    {
+      delay(1);
+    }
+
+  } while((millis() - ulStart) < 1000);
+
+#elif defined(WIN32)
+
+#error no win32 code yet
+
+#else // POSIX
+int i1;
+#ifdef DEBUG_CODE
+unsigned char buf[16];
+int cbBuf;
+#else // DEBUG_CODE
+unsigned char buf[2];
+#endif // DEBUG_CODE
+
+  if(fcntl(ser, F_SETFL, O_NONBLOCK) == -1)
+  {
+    static int iFailFlag = 0;
+
+    if(!iFailFlag)
+    {
+      fprintf(stderr, "Warning:  'fcntl(O_NONBLOCK)' failed, errno = %d\n", errno);
+      iFailFlag = 1;
+    }
+  }
+
+  ulStart = MyMillis();
+#ifdef DEBUG_CODE
+  cbBuf = 0;
+#endif // DEBUG_CODE
+  while((MyMillis() - ulStart) < 1000)
+  {
+#ifdef DEBUG_CODE
+    i1 = read(ser, &(buf[cbBuf]), 1);
+#else // DEBUG_CODE
+    i1 = read(ser, buf, 1);
+#endif // DEBUG_CODE
+    if(i1 == 1)
+    {
+#if defined(STAND_ALONE) && defined(DEBUG_CODE)
+      cbBuf++;
+      if(cbBuf >= sizeof(buf))
+      {
+        debug_dump_buffer(-1, buf, cbBuf);
+        cbBuf = 0;
+      }
+#endif // STAND_ALONE, DEBUG_CODE
+      ulStart = MyMillis();
+    }
+    else
+    {
+      usleep(1000);
+    }
+  }
+
+#if defined(STAND_ALONE) && defined(DEBUG_CODE)
+  if(cbBuf > 0)
+  {
+    debug_dump_buffer(-1, buf, cbBuf);
+  }
+#endif // STAND_ALONE, DEBUG_CODE
+
+#endif // ARDUINO
+}
+
+/** \ingroup xmodem_internal
+  * \brief Terminate the XMODEM connection
+  *
+  * \param pX A pointer to the 'XMODEM' object identifying the transfer
+  *
+  * Call this function prior to ending the XMODEM transfer.  Currently the only
+  * thing it does is flush the input.
+**/
+void XmodemTerminate(XMODEM *pX)
+{
+  XModemFlushInput(pX->ser);
+
+  // TODO:  close files?
+}
+
+
+/** \ingroup xmodem_internal
+  * \brief Validate the sequence number of a received XMODEM block
+  *
+  * \param pX A pointer to an 'XMODEM_BUF'
+  * \param bSeq The expected sequence number (block & 255)
+  * \return A zero value on success, non-zero otherwise
+  *
+  * Call this function to validate a packet's sequence number against the block number
+**/
+short ValidateSEQ(XMODEM_BUF *pX, unsigned char bSeq)
+{
+  return pX->aSEQ != 255 - pX->aNotSEQ || // ~(pX->aNotSEQ) ||
+         pX->aSEQ != bSeq; // returns TRUE if not valid
+}
+
+/** \ingroup xmodem_internal
+  * \brief Validate the sequence number of a received XMODEM block (CRC version)
+  *
+  * \param pX A pointer to an 'XMODEMC_BUF'
+  * \param bSeq The expected sequence number (block & 255)
+  * \return A zero value on success, non-zero otherwise
+  *
+  * Call this function to validate a packet's sequence number against the block number
+**/
+short ValidateSEQC(XMODEMC_BUF *pX, unsigned char bSeq)
+{
+  return pX->aSEQ != 255 - pX->aNotSEQ || // ~(pX->aNotSEQ) ||
+         pX->aSEQ != bSeq; // returns TRUE if not valid
+}
+
+/** \ingroup xmodem_internal
+  * \brief Generic function to receive a file via XMODEM (CRC or Checksum)
+  *
+  * \param pX A pointer to an 'XMODEM_BUF' with valid bCRC, ser, and file members
+  * \return A zero value on success, negative on error, positive on cancel
+  *
+  * The calling function will need to poll for an SOH from the server using 'C' and 'NAK'
+  * characters (as appropriate) until an SOH is received.  That value must be assigned
+  * to the 'buf' union (as appropriate), and the bCRC member assigned to non-zero if
+  * the server responded to 'C', or zero if it responded to 'NAK'.  With the bCRC,
+  * ser, and file members correctly assigned, call THIS function to receive content
+  * via XMODEM and write it to 'file'.\n
+  * This function will return zero on success, a negative value on error, and a positive
+  * value if the transfer was canceled by the server.
+**/
+int ReceiveXmodem(XMODEM *pX)
+{
+int ecount, ec2;
+long etotal, filesize, block;
+unsigned char cY; // the char to send in response to a packet
+// NOTE:  to allow debugging the CAUSE of an xmodem block's failure, i1, i2, and i3
+//        are assigned to function return values and reported in error messages.
+#ifdef DEBUG_CODE
+short i1, i2, i3;
+#define DEBUG_I1 i1 =
+#define DEBUG_I2 i2 =
+#define DEBUG_I3 i3 =
+#else // DEBUG_CODE
+#define DEBUG_I1 /*normally does nothing*/
+#define DEBUG_I2 /*normally does nothing*/
+#define DEBUG_I3 /*normally does nothing*/
+#endif // DEBUG_CODE
+
+  ecount = 0;
+  etotal = 0;
+  filesize = 0;
+  block = 1;
+
+  // ** already got the first 'SOH' character on entry to this function **
+
+  //   Form2.Show 0      '** modeless show of form2 (CANSEND) **
+  //   Form2!Label1.FloodType = 0
+  //   Form2.Caption = "* XMODEM(Checksum) BINARY RECEIVE *"
+  //   Form2!Label1.Caption = "Errors: 0  Bytes: 0"
+
+  pX->buf.xbuf.cSOH = (char)1; // assumed already got this, put into buffer
+
+  do
+  {
+    if(!pX->bCRC &&
+       ((DEBUG_I1 GetXmodemBlock(pX->ser, ((char *)&(pX->buf.xbuf)) + 1, sizeof(pX->buf.xbuf) - 1))
+        != sizeof(pX->buf.xbuf) - 1 ||
+        (DEBUG_I2 ValidateSEQ(&(pX->buf.xbuf), block & 255)) ||
+        (DEBUG_I3 CalcCheckSum(pX->buf.xbuf.aDataBuf, sizeof(pX->buf.xbuf.aDataBuf)) != pX->buf.xbuf.bCheckSum)))
+    {
+      // did not receive properly
+      // TODO:  deal with repeated packet, sequence number for previous packet
+
+#ifdef DEBUG_CODE
+      sprintf(szERR,"A%ld,%d,%d,%d,%d,%d",block,i1,i2,i3,pX->buf.xbuf.aSEQ, pX->buf.xbuf.aNotSEQ);
+//#ifdef STAND_ALONE
+//      fprintf(stderr, "TEMPORARY (csum):  seq=%x, ~seq=%x  i1=%d, i2=%d, i3=%d\n", pX->buf.xbuf.aSEQ, pX->buf.xbuf.aNotSEQ, i1, i2, i3);
+//#endif // STAND_ALONE
+#endif // DEBUG_CODE
+
+      XModemFlushInput(pX->ser);  // necessary to avoid problems
+
+      cY = _NAK_; // send NAK (to get the checksum version)
+      ecount ++; // for this packet
+      etotal ++;
+    }
+    else if(pX->bCRC &&
+            ((DEBUG_I1 GetXmodemBlock(pX->ser, ((char *)&(pX->buf.xcbuf)) + 1, sizeof(pX->buf.xcbuf) - 1))
+             != sizeof(pX->buf.xcbuf) - 1 ||
+            (DEBUG_I2 ValidateSEQC(&(pX->buf.xcbuf), block & 255)) ||
+            (DEBUG_I3 CalcCRC(pX->buf.xcbuf.aDataBuf, sizeof(pX->buf.xbuf.aDataBuf)) != pX->buf.xcbuf.wCRC)))
+    {
+      // did not receive properly
+      // TODO:  deal with repeated packet, sequence number for previous packet
+
+#ifdef DEBUG_CODE
+      sprintf(szERR,"B%ld,%d,%d,%d,%d,%d",block,i1,i2,i3,pX->buf.xcbuf.aSEQ, pX->buf.xcbuf.aNotSEQ);
+//#ifdef STAND_ALONE
+//      fprintf(stderr, "TEMPORARY (CRC):  seq=%x, ~seq=%x  i1=%d, i2=%d, i3=%d\n", pX->buf.xcbuf.aSEQ, pX->buf.xcbuf.aNotSEQ, i1, i2, i3);
+//#endif // STAND_ALONE
+#endif // DEBUG_CODE
+
+      XModemFlushInput(pX->ser);  // necessary to avoid problems
+
+      if(block > 1)
+      {
+        cY = _NAK_; // TODO do I need this?
+      }
+      else
+      {
+        cY = 'C'; // send 'CRC' NAK (the character 'C') (to get the CRC version)
+      }
+      ecount ++; // for this packet
+      etotal ++;
+    }
+    else
+    {
+#ifdef ARDUINO
+      if(pX->file.write((const uint8_t *)&(pX->buf.xbuf.aDataBuf), sizeof(pX->buf.xbuf.aDataBuf)) != sizeof(pX->buf.xbuf.aDataBuf))
+      {
+        return -2; // write error on output file
+      }
+#else // ARDUINO
+      if(write(pX->file, &(pX->buf.xbuf.aDataBuf), sizeof(pX->buf.xbuf.aDataBuf)) != sizeof(pX->buf.xbuf.aDataBuf))
+      {
+        XmodemTerminate(pX);
+        return -2; // write error on output file
+      }
+#endif // ARDUINO
+      cY = _ACK_; // send ACK
+      block ++;
+      filesize += sizeof(pX->buf.xbuf.aDataBuf); // TODO:  need method to avoid extra crap at end of file
+      ecount = 0; // zero out error count for next packet
+    }
+
+#ifdef STAND_ALONE
+    fprintf(stderr, "block %ld  %ld bytes  %d errors\r\n", block, filesize, ecount);
+#endif // STAND_ALONE
+
+    ec2 = 0;   //  ** error count #2 **
+
+    while(ecount < TOTAL_ERROR_COUNT && ec2 < ACK_ERROR_COUNT) // ** loop to get SOH or EOT character **
+    {
+      WriteXmodemChar(pX->ser, cY); // ** output appropriate command char **
+
+      if(GetXmodemBlock(pX->ser, &(pX->buf.xbuf.cSOH), 1) == 1)
+      {
+        if(pX->buf.xbuf.cSOH == _CAN_) // ** CTRL-X 'CAN' - terminate
+        {
+          XmodemTerminate(pX);
+          return 1; // terminated
+        }
+        else if(pX->buf.xbuf.cSOH == _EOT_) // ** EOT - end
+        {
+          WriteXmodemChar(pX->ser, _ACK_); // ** send an ACK (most XMODEM protocols expect THIS)
+//          WriteXmodemChar(pX->ser, _ENQ_); // ** send an ENQ
+
+          return 0; // I am done
+        }
+        else if(pX->buf.xbuf.cSOH == _SOH_) // ** SOH - sending next packet
+        {
+          break; // leave this loop
+        }
+        else
+        {
+          // TODO:  deal with repeated packet, i.e. previous sequence number
+
+          XModemFlushInput(pX->ser);  // necessary to avoid problems (since the character was unexpected)
+          // if I was asking for the next block, and got an unexpected character, do a NAK; otherwise,
+          // just repeat what I did last time
+
+          if(cY == _ACK_) // ACK
+          {
+            cY = _NAK_; // NACK
+          }
+
+          ec2++;
+        }
+      }
+      else
+      {
+        ecount++; // increase total error count, and try writing the 'ACK' or 'NACK' again
+      }
+    }
+
+    if(ec2 >= ACK_ERROR_COUNT) // wasn't able to get a packet
+    {
+      break;
+    }
+
+  } while(ecount < TOTAL_ERROR_COUNT);
+
+  XmodemTerminate(pX);
+  return 1; // terminated
+}
+
+
+/** \ingroup xmodem_internal
+  * \brief Generic function to send a file via XMODEM (CRC or Checksum)
+  *
+  * \param pX A pointer to an 'XMODEM_BUF' with valid ser, and file members, and the polled
+  * 'NAK' value assigned to the cSOH member (first byte) within the 'buf' union.
+  * \return A zero value on success, negative on error, positive on cancel
+  *
+  * The calling function will need to poll for a 'C' or NAK from the client (as appropriate)
+  * and assign that character to the cSOH member in the 'buf' union (either xbuf or xcbuf since
+  * the 'cSOH' will always be the first byte).  Then call this function to send content
+  * via XMODEM from 'file'.\n
+  * It is important to record the NAK character before calling this function since the 'C' or
+  * 'NAK' value will be used to determine whether to use CRC or CHECKSUM.\n
+  * This function will return zero on success, a negative value on error, and a positive
+  * value if the transfer was canceled by the receiver.
+**/
+int SendXmodem(XMODEM *pX)
+{
+int ecount, ec2;
+short i1;
+long filesize, filepos, block;
+
+
+  ecount = 0;
+  filesize = 0;
+  filepos = 0;
+  block = 1;
+
+  pX->bCRC = 0; // MUST ASSIGN TO ZERO FIRST or XMODEM-CHECKSUM may not work properly
+
+  // ** already got first 'NAK' character on entry as pX->buf.xbuf.cSOH  **
+
+#ifdef ARDUINO
+
+  filesize = pX->file.size();
+
+#else // ARDUINO
+
+  filesize = (long)lseek(pX->file, 0, SEEK_END);
+  if(filesize < 0) // not allowed
+  {
+#ifdef STAND_ALONE
+    fputs("SendXmodem fail (file size)\n", stderr);
+#endif // STAND_ALONE
+    return -1;
+  }
+
+  lseek(pX->file, 0, SEEK_SET); // position at beginning
+
+#endif // ARDUINO
+
+  do
+  {
+    // ** depending on type of transfer, place the packet
+    // ** into pX->buf with all fields appropriately filled.
+
+    if(filepos >= filesize) // end of transfer
+    {
+      for(i1=0; i1 < 8; i1++)
+      {
+        WriteXmodemChar(pX->ser, _EOT_); // ** send an EOT marking end of transfer
+
+        if(GetXmodemBlock(pX->ser, &(pX->buf.xbuf.cSOH), 1) != 1) // this takes up to 5 seconds
+        {
+          // nothing returned - try again?
+          // break; // for now I loop, uncomment to bail out
+        }
+        else if(pX->buf.xbuf.cSOH == _ENQ_    // an 'ENQ' (apparently some expect this)
+                || pX->buf.xbuf.cSOH == _ACK_ // an 'ACK' (most XMODEM implementations expect this)
+                || pX->buf.xbuf.cSOH == _CAN_) // CTRL-X = TERMINATE
+        {
+          // both normal and 'abnormal' termination.
+          break;
+        }
+      }
+
+      XmodemTerminate(pX);
+
+#ifdef STAND_ALONE
+      fprintf(stderr, "SendXmodem return %d\n", i1 >= 8 ? 1 : 0);
+#endif // STAND_ALONE
+      return i1 >= 8 ? 1 : 0; // return 1 if receiver choked on the 'EOT' marker, else 0 for 'success'
+    }
+
+//  TODO:  progress indicator [can be LCD for arduino, blinky lights, ???  and of course stderr for everyone else]
+//  If filesize& <> 0 Then Form2!Label1.FloodPercent = 100 * filepos& / filesize&
+
+#ifdef STAND_ALONE
+    fprintf(stderr, "block %ld  %ld of %ld bytes  %d errors\r\n", block, filepos, filesize, ecount);
+#endif // STAND_ALONE
+
+    if(pX->buf.xbuf.cSOH != 'C' // XMODEM CRC
+       && pX->buf.xbuf.cSOH != (char)_NAK_) // NAK
+    {
+      // increase error count, bail if it's too much
+
+      ec2++;
+    }
+
+
+#ifdef ARDUINO
+    pX->file.seek(filepos); // in case I'm doing a 'retry' and I have to re-read part of the file
+#else  // ARDUINO
+    lseek(pX->file, filepos, SEEK_SET); // same reason as above
+#endif // ARDUINO
+
+    // fortunately, xbuf and xcbuf are the same through the end of 'aDataBuf' so
+    // I can read the file NOW using 'xbuf' for both CRC and CHECKSUM versions
+
+    if((filesize - filepos) >= (long)(sizeof(pX->buf.xbuf.aDataBuf)))
+    {
+#ifdef ARDUINO
+      i1 = pX->file.read(pX->buf.xbuf.aDataBuf, sizeof(pX->buf.xcbuf.aDataBuf));
+#else  // ARDUINO
+      i1 = read(pX->file, pX->buf.xbuf.aDataBuf, sizeof(pX->buf.xcbuf.aDataBuf));
+#endif // ARDUINO
+
+      if(i1 != sizeof(pX->buf.xcbuf.aDataBuf))
+      {
+        // TODO:  read error - send a ctrl+x ?
+      }
+    }
+    else
+    {
+      memset(pX->buf.xcbuf.aDataBuf, '\x1a', sizeof(pX->buf.xcbuf.aDataBuf)); // fill with ctrl+z which is what the spec says
+#ifdef ARDUINO
+      i1 = pX->file.read(pX->buf.xbuf.aDataBuf, filesize - filepos);
+#else  // ARDUINO
+      i1 = read(pX->file, pX->buf.xbuf.aDataBuf, filesize - filepos);
+#endif // ARDUINO
+
+      if(i1 != (filesize - filepos))
+      {
+        // TODO:  read error - send a ctrl+x ?
+      }
+    }
+
+    if(pX->buf.xbuf.cSOH == 'C' ||  // XMODEM CRC 'NAK' (first time only, typically)
+       ((pX->buf.xbuf.cSOH == _ACK_ || pX->buf.xbuf.cSOH == _NAK_) && pX->bCRC)) // identifies ACK/NACK with XMODEM CRC
+    {
+      pX->bCRC = 1; // make sure (only matters the first time, really)
+
+      // calculate the CRC, assign to the packet, and then send it
+
+      pX->buf.xcbuf.cSOH = 1; // must send SOH as 1st char
+      pX->buf.xcbuf.wCRC = CalcCRC(pX->buf.xcbuf.aDataBuf, sizeof(pX->buf.xcbuf.aDataBuf));
+
+      GenerateSEQC(&(pX->buf.xcbuf), block);
+
+      // send it
+
+      i1 = WriteXmodemBlock(pX->ser, &(pX->buf.xcbuf), sizeof(pX->buf.xcbuf));
+      if(i1 != sizeof(pX->buf.xcbuf)) // write error
+      {
+        // TODO:  handle write error (send ctrl+X ?)
+      }
+    }
+    else if(pX->buf.xbuf.cSOH == _NAK_ || // 'NAK' (checksum method, may also be with CRC method)
+            (pX->buf.xbuf.cSOH == _ACK_ && !pX->bCRC)) // identifies ACK with XMODEM CHECKSUM
+    {
+      pX->bCRC = 0; // make sure (this ALSO allows me to switch modes on error)
+
+      // calculate the CHECKSUM, assign to the packet, and then send it
+
+      pX->buf.xbuf.cSOH = 1; // must send SOH as 1st char
+      pX->buf.xbuf.bCheckSum = CalcCheckSum(pX->buf.xbuf.aDataBuf, sizeof(pX->buf.xbuf.aDataBuf));
+
+      GenerateSEQ(&(pX->buf.xbuf), block);
+
+      // send it
+
+      i1 = WriteXmodemBlock(pX->ser, &(pX->buf.xbuf), sizeof(pX->buf.xbuf));
+      if(i1 != sizeof(pX->buf.xbuf)) // write error
+      {
+        // TODO:  handle write error (send ctrl+X ?)
+      }
+    }
+
+    ec2 = 0;
+
+    while(ecount < TOTAL_ERROR_COUNT && ec2 < ACK_ERROR_COUNT) // loop to get ACK or NACK
+    {
+      if(GetXmodemBlock(pX->ser, &(pX->buf.xbuf.cSOH), 1) == 1)
+      {
+        if(pX->buf.xbuf.cSOH == _CAN_) // ** CTRL-X - terminate
+        {
+          XmodemTerminate(pX);
+
+          return 1; // terminated
+        }
+        else if(pX->buf.xbuf.cSOH == _NAK_ || // ** NACK
+                pX->buf.xbuf.cSOH == 'C') // ** CRC NACK
+        {
+          break;  // exit inner loop and re-send packet
+        }
+        else if(pX->buf.xbuf.cSOH == _ACK_) // ** ACK - sending next packet
+        {
+          filepos += sizeof(pX->buf.xbuf.aDataBuf);
+          block++; // increment file position and block count
+
+          break; // leave inner loop, send NEXT packet
+        }
+        else
+        {
+          XModemFlushInput(pX->ser);  // for now, do this here too
+          ec2++;
+        }
+      }
+      else
+      {
+        ecount++; // increase total error count, then loop back and re-send packet
+        break;
+      }
+    }
+
+    if(ec2 >= ACK_ERROR_COUNT)
+    {
+      break;  // that's it, I'm done with this
+    }
+
+  } while(ecount < TOTAL_ERROR_COUNT * 2); // twice error count allowed for sending
+
+// TODO: progress indicator
+//   If filesize& <> 0 And filepos& <= filesize& Then
+//      Form2!Label1.FloodPercent = 100 * filepos& / filesize&
+//   Else
+//      Form2!Label1.FloodPercent = 100
+//   End If
+
+
+   // ** at this point it is important to indicate the errors
+   // ** and flush all buffers, and terminate process!
+
+  XmodemTerminate(pX);
+#ifdef STAND_ALONE
+  fputs("SendXmodem fail (total error count)\n", stderr);
+#endif // STAND_ALONE
+  return -2; // exit on error
+}
+
+
+/** \ingroup xmodem_internal
+  * \brief Calling function for ReceiveXmodem
+  *
+  * \param pX A pointer to an 'XMODEM_BUF' with valid ser, and file members
+  * \return A zero value on success, negative on error, positive on cancel
+  *
+  * This is a generic 'calling function' for ReceiveXmodem that checks for
+  * a response to 'C' and 'NAK' characters, and sets up the XMODEM transfer
+  * for either CRC or CHECKSUM mode.\n
+  * This function will return zero on success, a negative value on error, and a positive
+  * value if the transfer was canceled by the receiver.
+**/
+int XReceiveSub(XMODEM *pX)
+{
+int i1;
+
+  // start with CRC mode [try 8 times to get CRC]
+
+  pX->bCRC = 1;
+
+  for(i1=0; i1 < 8; i1++)
+  {
+    WriteXmodemChar(pX->ser, 'C'); // start with NAK for XMODEM CRC
+
+    if(GetXmodemBlock(pX->ser, &(pX->buf.xbuf.cSOH), 1) == 1)
+    {
+      if(pX->buf.xbuf.cSOH == _SOH_) // SOH - packet is on its way
+      {
+        return ReceiveXmodem(pX);
+      }
+      else if(pX->buf.xbuf.cSOH == _EOT_) // an EOT [blank file?  allow this?]
+      {
+        return 0; // for now, do this
+      }
+      else if(pX->buf.xbuf.cSOH == _CAN_) // cancel
+      {
+        return 1; // canceled
+      }
+    }
+  }
+
+  pX->bCRC = 0;
+
+  // try again, this time using XMODEM CHECKSUM
+  for(i1=0; i1 < 8; i1++)
+  {
+    WriteXmodemChar(pX->ser, _NAK_); // switch to NAK for XMODEM Checksum
+
+    if(GetXmodemBlock(pX->ser, &(pX->buf.xbuf.cSOH), 1) == 1)
+    {
+      if(pX->buf.xbuf.cSOH == _SOH_) // SOH - packet is on its way
+      {
+        return ReceiveXmodem(pX);
+      }
+      else if(pX->buf.xbuf.cSOH == _EOT_) // an EOT [blank file?  allow this?]
+      {
+        return 0; // for now, do this
+      }
+      else if(pX->buf.xbuf.cSOH == _CAN_) // cancel
+      {
+        return 1; // canceled
+      }
+    }
+  }
+
+
+  XmodemTerminate(pX);
+
+  return -3; // fail
+}
+
+
+/** \ingroup xmodem_internal
+  * \brief Calling function for SendXmodem
+  *
+  * \param pX A pointer to an 'XMODEM_BUF' with valid ser, and file members
+  * \return A zero value on success, negative on error, positive on cancel
+  *
+  * This is a generic 'calling function' for SendXmodem that checks for polls by the
+  * receiver, and places the 'NAK' or 'C' character into the 'buf' member of the XMODEM
+  * structure so that SendXmodem can use the correct method, either CRC or CHECKSUM mode.\n
+  * This function will return zero on success, a negative value on error, and a positive
+  * value if the transfer was canceled by the receiver.
+**/
+int XSendSub(XMODEM *pX)
+{
+unsigned long ulStart;
+
+  // waiting up to 30 seconds for transfer to start.  this is part of the spec?
+
+
+#ifdef ARDUINO
+  ulStart = millis();
+#else // ARDUINO
+  ulStart = MyMillis();
+#endif // ARDUINO
+
+  do
+  {
+    if(GetXmodemBlock(pX->ser, &(pX->buf.xbuf.cSOH), 1) == 1)
+    {
+      if(pX->buf.xbuf.cSOH == 'C' || // XMODEM CRC
+         pX->buf.xbuf.cSOH == _NAK_) // NAK - XMODEM CHECKSUM
+      {
+#ifdef STAND_ALONE
+        fprintf(stderr, "Got %d, continuing\n", pX->buf.xbuf.cSOH);
+#endif // STAND_ALONE
+        return SendXmodem(pX);
+      }
+      else if(pX->buf.xbuf.cSOH == _CAN_) // cancel
+      {
+#ifdef STAND_ALONE
+        fputs("XSendSub fail (cancel)\n", stderr);
+#endif // STAND_ALONE
+        return 1; // canceled
+      }
+    }
+  }
+#ifdef ARDUINO
+  while((short)(millis() - ulStart) < 30000);   // 30 seconds
+#else // ARDUINO
+  while((int)(MyMillis() - ulStart) < 30000);
+#endif // ARDUINO
+
+  XmodemTerminate(pX);
+
+#ifdef STAND_ALONE
+  fputs("XSendSub fail (timeout)\n", stderr);
+#endif // STAND_ALONE
+  return -3; // fail
+}
+
+//typedef struct _XMODEM_
+//{
+//  SERIAL_TYPE ser;
+//  FILE_TYPE file;
+//
+//  union
+//  {
+//    XMODEM_BUF xbuf;
+//    XMODEMC_BUF xcbuf;
+//  } buf; // 133 bytes
+//
+//  unsigned char bCRC; // non-zero for CRC, zero for checksum
+//
+//}  __attribute__((__packed__)) XMODEM;
+
+#ifdef ARDUINO
+
+short XReceive(SDClass *pSD, HardwareSerial *pSer, const char *szFilename)
+{
+short iRval;
+XMODEM xx;
+
+  memset(&xx, 0, sizeof(xx));
+
+  xx.ser = pSer;
+
+  if(pSD->exists((char *)szFilename))
+  {
+    pSD->remove((char *)szFilename);
+  }
+
+  xx.file = pSD->open((char *)szFilename, FILE_WRITE);
+  if(!xx.file)
+  {
+    return -9; // can't create file
+  }
+
+  iRval = XReceiveSub(&xx);
+
+  xx.file.close();
+
+  if(iRval)
+  {
+    WriteXmodemChar(pSer, _CAN_); // cancel (make sure)
+
+    pSD->remove((char *)szFilename); // delete file on error
+  }
+
+  return iRval;
+}
+
+int XSend(SDClass *pSD, HardwareSerial *pSer, const char *szFilename)
+{
+short iRval;
+XMODEM xx;
+
+  memset(&xx, 0, sizeof(xx));
+
+  xx.ser = pSer;
+
+  xx.file = pSD->open(szFilename, FILE_READ);
+  if(!xx.file)
+  {
+    return -9; // can't open file
+  }
+
+  iRval = XSendSub(&xx);
+
+  xx.file.close();
+
+  return iRval;
+}
+
+#else // ARDUINO
+
+int XReceive(SERIAL_TYPE hSer, const char *szFilename, int nMode)
+{
+int iRval;
+XMODEM xx;
+#ifndef ARDUINO
+int iFlags;
+#endif // !ARDUINO
+
+#ifdef DEBUG_CODE
+  szERR[0]=0;
+#endif // DEBUG_CODE
+  memset(&xx, 0, sizeof(xx));
+
+  xx.ser = hSer;
+
+  unlink(szFilename); // make sure it does not exist, first
+  xx.file = open(szFilename, O_CREAT | O_TRUNC | O_WRONLY, nMode);
+
+  if(!xx.file)
+  {
+#ifdef STAND_ALONE
+    fprintf(stderr, "XReceive fail \"%s\"  errno=%d\n", szFilename, errno);
+#endif // STAND_ALONE
+    return -9; // can't create file
+  }
+
+#ifndef ARDUINO
+  iFlags = fcntl(hSer, F_GETFL);
+#endif // !ARDUINO
+
+  iRval = XReceiveSub(&xx);
+
+#ifndef ARDUINO
+  if(iFlags == -1 || fcntl(hSer, F_SETFL, iFlags) == -1)
+  {
+    fprintf(stderr, "Warning:  'fcntl' call to restore flags failed, errno=%d\n", errno);
+  }
+#endif // !ARDUINO
+
+  close(xx.file);
+
+  if(iRval)
+  {
+    unlink(szFilename); // delete file on error
+  }
+
+#ifdef STAND_ALONE
+  fprintf(stderr, "XReceive returns %d\n", iRval);
+#endif // STAND_ALONE
+  return iRval;
+}
+
+int XSend(SERIAL_TYPE hSer, const char *szFilename)
+{
+int iRval;
+XMODEM xx;
+#ifndef ARDUINO
+int iFlags;
+#endif // !ARDUINO
+
+#ifdef DEBUG_CODE
+  szERR[0]=0;
+#endif // DEBUG_CODE
+  memset(&xx, 0, sizeof(xx));
+
+  xx.ser = hSer;
+
+  xx.file = open(szFilename, O_RDONLY, 0);
+
+  if(!xx.file)
+  {
+#ifdef STAND_ALONE
+    fprintf(stderr, "XSend fail \"%s\"  errno=%d\n", szFilename, errno);
+#endif // STAND_ALONE
+    return -9; // can't open file
+  }
+
+#ifndef ARDUINO
+  iFlags = fcntl(hSer, F_GETFL);
+#endif // !ARDUINO
+
+  iRval = XSendSub(&xx);
+
+  if(iFlags == -1 || fcntl(hSer, F_SETFL, iFlags) == -1)
+  {
+    fprintf(stderr, "Warning:  'fcntl' call to restore flags failed, errno=%d\n", errno);
+  }
+
+  close(xx.file);
+
+#ifdef STAND_ALONE
+  fprintf(stderr, "XSend returning %d\n", iRval);
+#endif // STAND_ALONE
+  return iRval;
+}
+
+#endif // ARDUINO
+
+
+
+#ifdef STAND_ALONE
+
+static const char szSER[]="/dev/ttyU0";
+
+#include <termios.h>
+
+/** \ingroup xmodem_standalone
+  * \brief Terminal configuration (POSIX only)
+  *
+  * \param iFile The open file handle for the serial connection
+  * \param iBaud The baud rate for the connection
+  * \param iParity The parity, < 0 for even, > 0 for odd, 0 for none
+  * \param iBits The number of bits (5, 6, 7, 8)
+  * \param iStop The number of stop bits (1 or 2)
+  *
+  * This is a sample tty config function to CORRECTLY set up a serial connection
+  * to allow XMODEM transfer.  The important details here are the use of the
+  * 'termios' structure and utility functions to DISABLE all of the things that
+  * would otherwise cause trouble, like CRLF translation, CTRL+C handling, etc.
+**/
+void ttyconfig(int iFile, int iBaud, int iParity, int iBits, int iStop)
+{
+int i1;
+struct termios sIOS;
+
+  i1 = fcntl(iFile, F_GETFL);
+
+  i1 |= O_NONBLOCK; // i1 &= ~O_NONBLOCK); // turn OFF non-blocking?
+
+	fcntl(iFile, F_SETFL, i1);
+
+  if(!tcgetattr(iFile, &sIOS))
+  {
+    cfsetspeed(&sIOS, iBaud);
+    sIOS.c_cflag &= ~(CSIZE|PARENB|CS5|CS6|CS7|CS8);
+	  sIOS.c_cflag |= iBits == 5 ? CS5 : iBits == 6 ? CS6 : iBits == 7 ? CS7 : CS8; // 8 is default
+	  if(iStop == 2)
+	  {
+	    sIOS.c_cflag |= CSTOPB;
+	  }
+	  else
+	  {
+	    sIOS.c_cflag &= ~CSTOPB;
+	  }
+
+    sIOS.c_cflag &= ~CRTSCTS; // hardware flow control _DISABLED_ (so I can do the reset)
+    sIOS.c_cflag |= CLOCAL; // ignore any modem status lines
+
+    if(!iParity)
+    {
+      sIOS.c_cflag &= ~(PARENB | PARODD);
+    }
+    else if(iParity > 0) // odd
+    {
+      sIOS.c_cflag |= (PARENB | PARODD);
+    }
+    else // even (negative)
+    {
+      sIOS.c_cflag &= PARODD;
+      sIOS.c_cflag |= PARENB;
+    }
+
+//    sIOS.c_iflag |= IGNCR; // ignore CR
+
+    // do not translate characters or xon/xoff and ignore break
+    sIOS.c_iflag &= ~(IGNBRK | INLCR | IGNCR | ICRNL | IXON | IXOFF | IXANY | IMAXBEL | ISTRIP); // turn these off
+
+#if defined(__FreeBSD__)
+    sIOS.c_oflag &= ~(OPOST | ONLCR | OCRNL | TABDLY | ONOEOT | ONOCR | ONLRET); // FreeBSD version
+#else // Linux? YMMV
+    sIOS.c_oflag &= ~(OPOST | ONLCR | OCRNL | TABDLY | ONOCR | ONLRET); // turn these off too (see man termios)
+#endif // FBSD vs Linux
+
+    // make sure echoing is disabled and control chars aren't translated or omitted
+#if defined(__FreeBSD__)
+    sIOS.c_lflag &= ~(ECHO | ECHOKE | ECHOE | ECHONL | ECHOPRT | ECHOCTL | ICANON | IEXTEN | ISIG | ALTWERASE);
+#else // Linux? YMMV
+    sIOS.c_lflag &= ~(ECHO | ECHOKE | ECHOE | ECHONL | ECHOPRT | ECHOCTL | ICANON | IEXTEN | ISIG);
+#endif // FBSD vs Linux
+    sIOS.c_cc[VMIN] = 0;  // ensures no 'grouping' of input
+    sIOS.c_cc[VTIME] = 0; // immediate return
+
+    if(tcsetattr(iFile, TCSANOW, &sIOS))
+    {
+      fprintf(stderr, "error %d setting attributes\n", errno);
+    }
+  }
+  else
+  {
+    fprintf(stderr, "error %d getting attributes\n", errno);
+  }
+}
+
+/** \ingroup xmodem_standalone
+  * \brief Arduino 'reset' function
+  *
+  * \param iFile The open file handle for the serial connection
+  *
+  * The Arduino serial port typically has the DTR/RTS lines configured so that
+  * a proper 'pulse' will cause a hardware reset of the device.  This function will
+  * send that pulse to the Arduino, and wait for a short time afterwards for the
+  * hardware reset to take place.
+**/
+void reset_arduino(int iFile)
+{
+unsigned int sFlags;
+unsigned long ulStart;
+int i1;
+
+// toggle the RTS and DTR high, low, then high - so much easier via POSIX-compatible OS!
+
+  ioctl(iFile, TIOCMGET, &sFlags);
+
+  sFlags &= ~(TIOCM_DTR | TIOCM_RTS); // the high to low transition discharges the capacitor (signal is inverted on board)
+  if(ioctl(iFile, TIOCMSET, &sFlags) < 0)
+  {
+    fprintf(stderr, "WARNING:  ioctl() returns < 0, errno=%d (%xH)\n", errno, errno);
+  }
+
+  usleep(250000); // avrdude does this for 50 msecs, my change has it at 50msecs
+
+  sFlags |= TIOCM_DTR | TIOCM_RTS; // leave it in THIS state when I'm done
+  if(ioctl(iFile, TIOCMSET, &sFlags) < 0)
+  {
+    fprintf(stderr, "WARNING:  ioctl() returns < 0, errno=%d (%xH)\n", errno, errno);
+  }
+
+  usleep(50000); // avrdude does this for 50 msecs (no change)
+
+  ulStart = MyMillis();
+
+  // flush whatever is there, (5 seconds)
+
+  while((MyMillis() - ulStart) < 5000)
+  {
+    i1 = read(iFile, &i1, 1);
+    if(i1 == 1)
+    {
+      ulStart = MyMillis();
+    }
+    else
+    {
+      usleep(1000);
+    }
+  }
+
+}
+
+int main(int argc, char *argv[])
+{
+int hSer;
+char tbuf[256];
+int i1, iSR = 0;
+
+
+  if(argc < 3)
+  {
+    fputs("Usage:  [prog] [S|R] filename\n", stderr);
+    return 1;
+  }
+
+  if(argv[1][0] == 'R' || argv[1][1]=='r')
+  {
+    iSR = -1;
+  }
+  else if(argv[1][0] == 'S' || argv[1][1]=='s')
+  {
+    iSR = 1;
+  }
+  else if(argv[1][0] == 'X' || argv[1][1]=='x')
+  {
+    iSR = 0; // test function
+  }
+  else
+  {
+    fputs("Usage:  [prog] [S|R] filename     (b)\n", stderr);
+    return 1;
+  }
+
+  hSer = open(szSER, (O_RDWR | O_NONBLOCK), 0);
+  if(hSer == -1)
+  {
+    fprintf(stderr, "Unable to open \"%s\" errno=%d\n", szSER, errno);
+    return 3;
+  }
+
+  fputs("TTYCONFIG\n", stderr);
+  ttyconfig(hSer, 9600, 0, 8, 1);
+
+  reset_arduino(hSer);
+
+  fprintf(stderr, "Sleeping for 10 seconds to allow reset\n");
+
+//  usleep(10000000);
+  for(i1=0; i1 < 10; i1++)
+  {
+    XModemFlushInput(hSer);
+  }
+
+  for(i1=0; i1 < 3; i1++)
+  {
+    sprintf(tbuf, "X%c%s", argv[1][0], argv[2]);
+
+    fprintf(stderr, "writing: \"%s\"\n", tbuf);
+    strcat(tbuf, "\r");
+    WriteXmodemBlock(hSer, tbuf, strlen(tbuf));
+
+    fputs("flush input\n", stderr);
+    XModemFlushInput(hSer);
+
+    // wait for an LF response
+
+    if(iSR > 0)
+    {
+      fputs("XSEND\n", stderr);
+      if(XSend(hSer, argv[2]))
+      {
+        fputs("ERROR\n", stderr);
+      }
+      else
+      {
+        fputs("SUCCESS!\n", stderr);
+        i1 = 0;
+        break;
+      }
+    }
+    else if(iSR < 0)
+    {
+      fputs("XRECEIVE\n", stderr);
+      if(XReceive(hSer, argv[2], 0664))
+      {
+        fputs("ERROR\n", stderr);
+      }
+      else
+      {
+        fputs("SUCCESS!\n", stderr);
+        i1 = 0;
+        break;
+      }
+    }
+    else
+    {
+      // test function
+      XModemFlushInput(hSer); // continue doing this
+      break; // done (once only)
+    }
+  }
+
+  fputs("EXIT\n", stderr);
+  close(hSer);
+
+  return i1 ? 1 : -1;
+}
+#endif // STAND_ALONE
+
diff --git a/fastboot_app/utils/xmodem/xmodem.h b/fastboot_app/utils/xmodem/xmodem.h
new file mode 100644
index 0000000..b0e3be2
--- /dev/null
+++ b/fastboot_app/utils/xmodem/xmodem.h
@@ -0,0 +1,286 @@
+//////////////////////////////////////////////////////////////////////////////
+//                                                                          //
+//                                     _                      _             //
+//        __  __ _ __ ___    ___    __| |  ___  _ __ ___     | |__          //
+//        \ \/ /| '_ ` _ \  / _ \  / _` | / _ \| '_ ` _ \    | '_ \         //
+//         >  < | | | | | || (_) || (_| ||  __/| | | | | | _ | | | |        //
+//        /_/\_\|_| |_| |_| \___/  \__,_| \___||_| |_| |_|(_)|_| |_|        //
+//                                                                          //
+//                                                                          //
+//////////////////////////////////////////////////////////////////////////////
+//                                                                          //
+//          Copyright (c) 2012 by S.F.T. Inc. - All rights reserved         //
+//  Use, copying, and distribution of this software are licensed according  //
+//    to the LGPLv2.1, or a BSD-like license, as appropriate (see below)    //
+//                                                                          //
+//////////////////////////////////////////////////////////////////////////////
+
+#ifdef ARDUINO
+/** \mainpage S.F.T. XMODEM library (ARDUINO version)
+  *
+  * Copyright (c) 2012 by S.F.T. Inc. - All rights reserved\n
+  *
+  * The source files include DOXYGEN SUPPORT to properly document the library
+  * Please excuse the additional comments necessary to make this work.
+  * Instead, build the doxygen output and view the documentation, as
+  * well as the code itself WITHOUT all of the doxygen markup comments.
+  * \n
+  * \n
+  * This library was designed to work with POSIX-compliant operating systems
+  * such as Linux, FreeBSD, and OSX, and also on Arduino microcontrollers.
+  * The intent was to provide an identical code base for both ends of the
+  * XMODEM transfer, compilable as either C or C++ code for maximum flexibility.
+  *
+  * Normally you will only need to use one of these two functions:\n
+  * \n
+  * \ref XSend() - send a file via XMODEM\n
+  * \ref XReceive() - receive a file via XMODEM\n
+  * \n
+  * The rest of the documentation was provided to help you debug any problems,
+  * or even to write your own library (as appropriate).\n
+  *
+  * LICENSE
+  *
+  * This software is licensed under either the LGPLv2 or a BSD-like license.
+  * For more information, see\n
+  *   http://opensource.org/licenses/BSD-2-Clause\n
+  *   http://www.gnu.org/licenses/lgpl-2.1.html\n
+  * and the above copyright notice.\n
+  * \n
+  * In short, you may use this software anyway you like, provided that you
+  * do not hold S.F.T. Inc. responsible for consequential or inconsequential
+  * damages resulting from use, modification, abuse, or anything else done
+  * with this software, and you include the appropriate license (either LGPLv2
+  * or a BSD-like license) and comply with the requirements of said license.\n
+  * So, if you use a BSD-like license, you can copy the license template at
+  * the abovementioned URL and sub in the copyright notice as shown above.
+  * Or, you may use an LGPLv2 license, and then provide source files with a
+  * re-distributed or derived work (including a complete re-write with this
+  * library as a template).  A link back to the original source, of course,
+  * would be appreciated but is not required.
+**/
+#else // ARDUINO
+/** \mainpage S.F.T. XMODEM library
+  *
+  * Copyright (c) 2012 by S.F.T. Inc. - All rights reserved\n
+  *
+  * The source files include DOXYGEN SUPPORT to properly document the library
+  * Please excuse the additional comments necessary to make this work.
+  * Instead, build the doxygen output and view the documentation, as
+  * well as the code itself WITHOUT all of the doxygen markup comments.
+  * \n
+  * \n
+  * This library was designed to work with POSIX-compliant operating systems
+  * such as Linux, FreeBSD, and OSX, and also on Arduino microcontrollers.
+  * The intent was to provide an identical code base for both ends of the
+  * XMODEM transfer, compilable as either C or C++ code for maximum flexibility.
+  *
+  * Normally you will only need to use one of these two functions:\n
+  * \n
+  * \ref XSend() - send a file via XMODEM\n
+  * \ref XReceive() - receive a file via XMODEM\n
+  * \n
+  * The rest of the documentation was provided to help you debug any problems,
+  * or even to write your own library (as appropriate).\n
+  *
+  * LICENSE
+  *
+  * This software is licensed under either the LGPLv2 or a BSD-like license.
+  * For more information, see\n
+  *   http://opensource.org/licenses/BSD-2-Clause\n
+  *   http://www.gnu.org/licenses/lgpl-2.1.html\n
+  * and the above copyright notice.\n
+  * \n
+  * In short, you may use this software anyway you like, provided that you
+  * do not hold S.F.T. Inc. responsible for consequential or inconsequential
+  * damages resulting from use, modification, abuse, or anything else done
+  * with this software, and you include the appropriate license (either LGPLv2
+  * or a BSD-like license) and comply with the requirements of said license.\n
+  * So, if you use a BSD-like license, you can copy the license template at
+  * the abovementioned URL and sub in the copyright notice as shown above.
+  * Or, you may use an LGPLv2 license, and then provide source files with a
+  * re-distributed or derived work (including a complete re-write with this
+  * library as a template).  A link back to the original source, of course,
+  * would be appreciated but is not required.
+**/
+#endif // ARDUINO
+
+/** \file xmodem.h
+  * \brief main header file for S.F.T. XMODEM library
+  *
+  * S.F.T. XMODEM library
+**/
+
+/** \defgroup xmodem_api XModem API
+  * high-level API functions
+*/
+
+/** \defgroup xmodem_internal XModem Internal
+  * internal support functions
+*/
+
+#ifdef STANDALONE
+/** \defgroup xmodem_standalone XModem Stand-alone
+  * internal 'standalone' functions, an example for POSIX implementation
+*/
+#endif // STANDALONE
+
+
+// determine if arduino build, define ARDUINO if not already done
+
+#if defined(__AVR__) || defined(AVR) || defined(__AVR) || defined(__AVR_ARCH__)
+#ifndef ARDUINO
+#define ARDUINO /* hopefully I cover all compiler variations */
+#endif // ARDUINO
+#endif // __AVR__
+
+
+#include <stdlib.h>
+
+// required include files
+#ifdef ARDUINO
+// arduino includes
+#include <Arduino.h>
+#include <SD.h>
+#include <HardwareSerial.h> /* may already be included by 'Arduino.h' */
+#include <avr/pgmspace.h>
+
+#elif WIN32
+// win32 includes
+#include <Windows.h>
+#include <io.h>
+#else // POSIX
+// posix includes
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/time.h>
+#include <sys/ioctl.h> // for IOCTL definitions
+#include <memory.h>
+#endif // OS-dependent includes
+
+
+// required per-OS definitions
+#ifdef ARDUINO
+
+// file and serial types for Arduino
+#define FILE_TYPE File
+#define SERIAL_TYPE HardwareSerial *
+
+#elif defined(WIN32) // WINDOWS
+
+// file and serial types for WIN32
+#define FILE_TYPE HANDLE
+#define SERIAL_TYPE HANDLE
+
+#else // POSIX
+
+// file and serial types for POSIX
+#define FILE_TYPE int
+#define SERIAL_TYPE int
+
+#endif // ARDUINO
+
+
+// common definitions
+
+#define SILENCE_TIMEOUT 5000 /* 5 seconds */
+#define TOTAL_ERROR_COUNT 32
+#define ACK_ERROR_COUNT 8
+
+
+// Arduino build uses C++ so I must define functions properly
+
+#ifdef ARDUINO
+
+/** \ingroup xmodem_api
+  * \brief Receive a file using XMODEM protocol (ARDUINO version)
+  *
+  * \param pSD A pointer to an SDClass object, such as &SD (the default SD library object is 'SD')
+  * \param pSer A pointer to a HardwareSerial object, such as &Serial
+  * \param szFilename A pointer to a (const) 0-byte terminated string containing the file name
+  * \return A value of zero on success, negative on failure, positive if canceled
+  *
+  * Call this function to receive a file, passing the SD card's initialized SDClass object pointer,
+  * and the pointer to the 'HardwareSerial' object to be used for serial communication, and the
+  * name of the file to create from the XMODEM stream.  The function will return a value of zero on
+  * success.  On failure or cancelation, the file will be deleted.\n
+  * If the specified file exists before calling this function, it will be overwritten.  If you do not
+  * want to unconditionally overwrite an existing file, you should test to see if it exists first
+  * using the SD library.
+  *
+**/
+short XReceive(SDClass *pSD, HardwareSerial *pSer, const char *szFilename);
+
+/** \ingroup xmodem_api
+  * \brief Send a file using XMODEM protocol (ARDUINO version)
+  *
+  * \param pSD A pointer to an SDClass object, such as &SD (the default SD library object is 'SD')
+  * \param pSer A pointer to a HardwareSerial object, such as &Serial
+  * \param szFilename A pointer to a (const) 0-byte terminated string containing the file name
+  * \return A value of zero on success, negative on failure, positive if canceled
+  *
+  * Call this function to send a file, passing the SD card's initialized SDClass object pointer,
+  * and the pointer to the 'HardwareSerial' object to be used for serial communication, and the
+  * name of the file to send via the XMODEM stream.  The function will return a value of zero on
+  * success.  If the file does not exist, the function will return a 'failure' value and cancel
+  * the transfer.
+  *
+**/
+int XSend(SDClass *pSD, HardwareSerial *pSer, const char *szFilename);
+
+#ifdef DEBUG_CODE
+const char *XMGetError(void);
+#endif // DEBUG_CODE
+
+#else // ARDUINO
+
+#ifdef __cplusplus
+extern "C" {
+#endif // __cplusplus
+
+/** \ingroup xmodem_api
+  * \brief Receive a file using XMODEM protocol
+  *
+  * \param hSer A 'HANDLE' for the open serial connection
+  * \param szFilename A pointer to a (const) 0-byte terminated string containing the file name
+  * \param nMode The file mode to be used on create (RWX bits)
+  * \return A value of zero on success, negative on failure, positive if canceled
+  *
+  * Call this function to receive a file, passing the handle to the open serial connection, and the
+  * name and mode of the file to create from the XMODEM stream.  The function will return a value of zero on
+  * success.  On failure or cancelation, the file will be deleted.\n
+  * If the specified file exists before calling this function, it will be overwritten.  If you do not
+  * want to unconditionally overwrite an existing file, you should test to see if it exists first.
+  *
+**/
+int XReceive(SERIAL_TYPE hSer, const char *szFilename, int nMode);
+
+/** \ingroup xmodem_api
+  * \brief Send a file using XMODEM protocol
+  *
+  * \param hSer A 'HANDLE' for the open serial connection
+  * \param szFilename A pointer to a (const) 0-byte terminated string containing the file name
+  * \return A value of zero on success, negative on failure, positive if canceled
+  *
+  * Call this function to receive a file, passing the handle to the open serial connection, and the
+  * name and mode of the file to send via the XMODEM stream.  The function will return a value of zero on
+  * success.  If the file does not exist, the function will return a 'failure' value and cancel
+  * the transfer.
+  *
+**/
+int XSend(SERIAL_TYPE hSer, const char *szFilename);
+
+#ifdef DEBUG_CODE
+const char *XMGetError(void);
+#endif // DEBUG_CODE
+
+#ifdef __cplusplus
+};
+#endif // __cplusplus
+
+#endif // ARDUINO
+
+
diff --git a/fastboot_app/vca/bpi_vca.cpp b/fastboot_app/vca/bpi_vca.cpp
new file mode 100644
index 0000000..8417d03
--- /dev/null
+++ b/fastboot_app/vca/bpi_vca.cpp
@@ -0,0 +1,538 @@
+/*
+ * bpi_vca.cpp
+ *
+ * History:
+ *       2016/09/13 - [niu zhifeng] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <pthread.h>
+#include <assert.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/time.h>
+#include <iav_ioctl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+
+#include "bpi_vca.h"
+#include "bpi_typedefs.h"
+#include "bpi_app_config.h"
+#include "bpi_utils.h"
+
+#ifdef PRE_STORED_YUV
+#ifndef ROUND_UP
+#define ROUND_UP(size, align) (((size) + ((align) - 1)) & ~((align) - 1))
+#endif
+
+#define S2LM_READ_IAV_VCA
+#ifdef S2LM_READ_IAV_VCA
+const unsigned int pts_line_gap = 1;
+#else
+const unsigned int pts_line_gap = 0;
+#endif
+
+int VCA::query_yuv_info()
+{
+#if 0
+    AM_RESULT ret = AM_RESULT_OK;
+    do {
+        AMQueryFrameDesc frame_desc;
+        AMBufferInfo binfo;
+        AM_SOURCE_BUFFER_ID id = AM_SOURCE_BUFFER_ID(m_buffer_id);
+        if (AM_RESULT_OK != m_video_reader->query_yuv_frame(frame_desc, id, false)) {
+            ret = AM_RESULT_ERR_INVALID;
+            LOG_ERROR("Query yuv frame failed.\n");
+            break;
+        }
+        if(frame_desc.yuv.width != m_buffer_width || frame_desc.yuv.height != m_buffer_height){
+            LOG_ERROR("width/height error, actual buffer [%dx%d], was set [%dx%d]\n", frame_desc.yuv.width,frame_desc.yuv.height, m_buffer_width, m_buffer_height);
+              ret = AM_RESULT_ERR_INVALID;
+            break;
+        }
+        binfo.buf_id = id;
+        if (AM_RESULT_OK != m_video_reader->query_buffer_info(binfo)) {
+            ret = AM_RESULT_ERR_INVALID;
+            LOG_ERROR("Query buffer info failed.\n");
+            break;
+        }
+
+        const AMAddress addr =  m_video_address->addr_get(AM_DATA_FRAME_TYPE_YUV, 0, id);
+        if (!addr.data) {
+            LOG_ERROR("Failed get buffer:%d address!\n", m_buffer_id);
+            ret = AM_RESULT_ERR_MEM;
+            break;
+        }
+        m_yuv_src_addr = addr.data + addr.offset;
+        m_remain_size = addr.max_size - addr.offset;
+
+        m_frame_width = frame_desc.yuv.width;
+        m_frame_height = frame_desc.yuv.height;
+        m_frame_pitch = frame_desc.yuv.pitch;
+        m_max_height = ROUND_UP(binfo.max_size.height, 16);
+        LOG_PRINT("width=%d, height= %d, pitch=%d, max_height=%d, rounded max_height=%d\n", m_frame_width, m_frame_height, m_frame_pitch, binfo.max_size.height, m_max_height);
+        if (frame_desc.yuv.format == AM_CHROMA_FORMAT_YUV420) {
+            m_uv_height = frame_desc.yuv.height / 2;
+            m_src_size = m_frame_pitch * m_max_height * 3 / 2;
+            LOG_PRINT("The yuv format is 420.\n");
+        }else {
+            ret = AM_RESULT_ERR_INVALID;
+            LOG_ERROR("Unsupported chroma format in YUV dump.\n");
+            break;
+        }
+    }while(0);
+#endif
+
+#ifdef S2LM_READ_IAV_VCA
+
+    int ret = 0;
+    do
+    {
+        iav_fd = open("/dev/iav", O_RDWR, 0);
+        if (iav_fd < 0) {
+            perror("fail to open iav\n");
+            break;
+        }
+
+        struct iav_querybuf querybuf;
+        querybuf.buf = IAV_BUFFER_VCA;
+        if (ioctl(iav_fd, IAV_IOC_QUERY_BUF, &querybuf) < 0) {
+            perror("IAV_IOC_QUERY_BUF");
+            break;
+        }
+        m_remain_size = querybuf.length;
+        m_yuv_src_addr = (unsigned char *)mmap(NULL, m_remain_size,
+                                               PROT_READ, MAP_SHARED,
+                                               iav_fd, querybuf.offset);
+        if (m_yuv_src_addr == MAP_FAILED) {
+            perror("mmap failed\n");
+            break;
+        }
+    }while(0);
+    m_frame_width = m_buffer_width;  // 720
+    m_frame_height = m_buffer_height;  // 480
+    m_frame_pitch = m_buffer_width + 16;  // 736
+    m_uv_height = m_frame_height / 2;
+    m_max_height = m_frame_height + m_uv_height + pts_line_gap;
+    m_src_size = m_frame_pitch * m_max_height;
+
+#endif
+    return ret;
+}
+#endif
+
+/* FIXME: read fps from configuration file or somewhere else */
+#define VCA_FPS 15
+VCA::VCA():
+    m_buffer_width(0),
+    m_buffer_height(0),
+    m_frame_number(-1),
+    m_time_out(-1),
+    m_buffer_data(nullptr),
+    m_buffer_y(nullptr),
+    m_buffer_uv(nullptr),
+    m_video_reader(nullptr),
+    m_video_address(nullptr),
+    iav_fd(-1),
+#ifdef PRE_STORED_YUV
+    m_yuv_src_addr(nullptr),
+    m_remain_size(0),
+    m_src_size(0),
+    m_frame_width(0),
+    m_frame_height(0),
+    m_frame_pitch(0),
+    m_max_height(0),
+    m_uv_height(0),
+#endif
+    m_mtx(PTHREAD_MUTEX_INITIALIZER),
+    m_cond(PTHREAD_COND_INITIALIZER),
+    m_is_thread_created(false),
+    m_is_thread_started(false),
+    m_buffer_id(0),
+    m_detected_cb(NULL),
+    m_detected_cb_arg(NULL)
+{
+    // m_video_reader = AMIVideoReader::get_instance();
+    // m_video_address = AMIVideoAddress::get_instance();
+
+    // assert(m_video_reader && m_video_address);
+}
+
+VCA::~VCA()
+{
+    if (m_is_thread_created)
+        pthread_cancel(m_tid);
+
+    if (m_buffer_data) {
+        delete [] m_buffer_data;
+        m_buffer_data = nullptr;
+    }
+
+    if(iav_fd > 0) close(iav_fd);
+    munmap(m_yuv_src_addr, m_remain_size);
+
+    m_buffer_y = nullptr;
+    m_buffer_uv = nullptr;
+    m_video_reader = nullptr;
+    m_video_address = nullptr;
+}
+
+void VCA::set_buffer_id(int id)
+{
+    m_buffer_id = id;
+}
+
+void VCA::set_frame_size(unsigned int width, unsigned int height)
+{
+    if (m_buffer_data && m_buffer_width == width && m_buffer_height == height)
+        return;
+
+    if (m_buffer_data) {
+        delete [] m_buffer_data;
+        m_buffer_data = nullptr;
+    }
+
+    m_buffer_width = width;
+    m_buffer_height = height;
+    m_buffer_data = new unsigned char[m_buffer_width * m_buffer_height * 3 / 2];
+    m_buffer_y = m_buffer_data;
+    m_buffer_uv = m_buffer_data + m_buffer_width * m_buffer_height;
+}
+
+void VCA::set_frame_number(int frames)
+{
+    m_frame_number = frames;
+}
+
+void VCA::set_time_out(int time_out)
+{
+    m_time_out = time_out;
+}
+
+void VCA::set_detected_callback(detected_callback_t cb, void *arg)
+{
+    m_detected_cb = cb;
+    m_detected_cb_arg = arg;
+}
+
+int VCA::read_yuv()
+{
+    int ret = 0;
+#ifdef PRE_STORED_YUV
+    do {
+        if (m_remain_size > m_src_size){
+            // copy Y
+            unsigned char *y_out = m_buffer_y;
+            unsigned char *y_in = m_yuv_src_addr + pts_line_gap * m_frame_pitch;
+            for (unsigned int line = 0; line < m_frame_height; ++line) {
+                memcpy(y_out, y_in, m_frame_width);
+                y_in += m_frame_pitch;
+                y_out += m_frame_width;
+            }
+            // copy UV
+            unsigned char *uv_out = m_buffer_uv;
+            unsigned char *uv_in = m_yuv_src_addr + (m_max_height - m_uv_height)
+                                   * m_frame_pitch;
+            for (unsigned int line = 0; line < m_uv_height; line++) {
+                memcpy(uv_out, uv_in, m_frame_width);
+                uv_in += m_frame_pitch;
+                uv_out += m_frame_width;
+            }
+            m_yuv_src_addr += m_src_size;
+            m_remain_size -= m_src_size;
+        }
+    } while (0);
+
+#else
+    AMQueryFrameDesc frame_desc;
+    AMAddress y_addr;
+    AMAddress uv_addr;
+
+    do {
+        if (AM_RESULT_OK != m_video_reader->query_yuv_frame(frame_desc,
+                    (enum AM_SOURCE_BUFFER_ID)m_buffer_id, false)) {
+            LOG_ERROR("failed to query yuv frame\n");
+            ret = -1;
+            break;
+        }
+
+        if (AM_RESULT_OK != m_video_address->yuv_y_addr_get(frame_desc, y_addr)) {
+            LOG_ERROR("failed to get y address\n");
+            ret = -1;
+            break;
+        }
+
+        if (AM_RESULT_OK != m_video_address->yuv_uv_addr_get(frame_desc, uv_addr)) {
+            LOG_ERROR("failed to get uv address\n");
+            ret = -1;
+            break;
+        }
+
+        if (frame_desc.yuv.pitch != (unsigned)m_buffer_width) {
+            unsigned char *y_in = y_addr.data;
+            unsigned char *y_out = m_buffer_y;
+            unsigned char *uv_in = uv_addr.data;
+            unsigned char *uv_out = m_buffer_uv;
+            for (unsigned int i = 0; i < m_buffer_height; i++) {
+                memcpy(y_out, y_in, m_buffer_width);
+                y_in += frame_desc.yuv.pitch;
+                y_out += m_buffer_width;
+            }
+            for (unsigned int i = 0; i < m_buffer_height / 2; i++) {
+                memcpy(uv_out, uv_in, m_buffer_width);
+                uv_in += frame_desc.yuv.pitch;
+                uv_out += m_buffer_width;
+            }
+        } else {
+            memcpy(m_buffer_y, y_addr.data, m_buffer_width * m_buffer_height);
+            memcpy(m_buffer_uv, uv_addr.data, m_buffer_width * m_buffer_height / 2);
+        }
+    } while (0);
+#endif
+
+    return ret;
+}
+
+int VCA::run()
+{
+    int frame_cnt = 0;
+    unsigned int start;
+    //unsigned int prev;
+    unsigned int curr;
+    int ret = -1;
+
+    if (m_time_out <= 0) {
+        LOG_ERROR("invalid parameter: time_out = %d\n", m_time_out);
+        return ret;
+    }
+
+    if (m_frame_number <= 0) {
+        LOG_ERROR("invalid parameter: frame_number = %d\n", m_frame_number);
+        return ret;
+    }
+
+    LOG_PRINT("vca detecting...\n");
+    do {
+        start = get_current_time();
+        curr = start;
+        char * p;
+        FILE * fp = nullptr;
+
+#ifdef PRE_STORED_YUV
+        query_yuv_info();
+#endif
+        if (pre_vca() < 0) {
+            LOG_ERROR("pre_vca() failed\n");
+            return ret;
+        }
+
+        if((p=getenv("DUMP_VCA_BUF"))){
+            if(!strcmp("true", p)){
+                char vca_buf_dump_file[128];
+                snprintf(vca_buf_dump_file, sizeof(vca_buf_dump_file), "/tmp/vca_nv12_%dx%d_%d.yuv", m_buffer_width, m_buffer_height, get_current_time());
+                fp = fopen(vca_buf_dump_file,"wb");
+                if (!fp){
+                    LOG_ERROR("open file %s failed\n", vca_buf_dump_file);
+                }
+            }
+        }
+
+        while (frame_cnt < m_frame_number) {
+            //prev = get_current_time();
+
+            if (read_yuv() != 0) {
+                LOG_ERROR("read_frame failed\n");
+                break;
+            }
+
+            if(fp){
+                fwrite(m_buffer_y, 1, m_buffer_width * m_buffer_height, fp);
+                fwrite(m_buffer_uv, 1, m_buffer_width * m_buffer_height/2, fp);
+            }
+
+            if (do_vca() == 0) {
+                ret = 0;
+                break;
+            }
+
+            curr = get_current_time();
+
+            if (curr - start > (unsigned)m_time_out) {
+                LOG_PRINT("VCA timeout\n");
+                break;
+            }
+            //disable VCA FPS control
+           // if (curr - prev < 1000 / VCA_FPS) {
+           //     usleep(1000 * (curr - prev));
+          //  }
+            frame_cnt++;
+        }
+        if(fp) fclose(fp);
+    } while (0);
+
+    if (post_vca() < 0) {
+        LOG_ERROR("post_vca() failed\n");
+        /* fall through */
+    }
+
+    LOG_PRINT("VCA done with object %sdetected, spent %d ms, "
+                "processed %d frames\n", ret == 0 ? "" : "not ",
+                curr - start, frame_cnt+1);
+    return ret;
+}
+
+void cleanup(void *arg);
+void *worker(void *arg);
+
+int VCA::run_async()
+{
+    int ret = 0;
+
+    LOG_PRINT("vca detecting...\n");
+
+    do {
+        if (!m_is_thread_created) {
+            pthread_create(&m_tid, NULL, worker, this);
+            m_is_thread_created = true;
+        }
+
+        if (m_is_thread_started) {
+            LOG_ERROR("vca thread is already running\n");
+            ret = -1;
+            break;
+        }
+
+        pthread_mutex_lock(&m_mtx);
+        if (pre_vca() < 0) {
+            LOG_ERROR("pre_vca() failed\n");
+            ret = -1;
+            break;
+        }
+        m_is_thread_started = true;
+        pthread_cond_signal(&m_cond);
+        pthread_mutex_unlock(&m_mtx);
+    } while (0);
+
+    return ret;
+}
+
+int VCA::pause()
+{
+    int ret = 0;
+
+    do {
+        if (!m_is_thread_started) {
+            LOG_ERROR("vca thread is already paused\n");
+            ret = -1;
+            break;
+        }
+
+        pthread_mutex_lock(&m_mtx);
+        m_is_thread_started = false;
+        if (post_vca() < 0) {
+                LOG_ERROR("post_vca() failed\n");
+        }
+        pthread_mutex_unlock(&m_mtx);
+    } while (0);
+
+    return ret;
+}
+
+int VCA::pre_vca()
+{
+    return 0;
+}
+
+int VCA::post_vca()
+{
+    return 0;
+}
+
+void cleanup(void *arg)
+{
+    assert(arg);
+
+    VCA *vca = (VCA *)arg;
+
+    if (vca->post_vca() < 0) {
+        LOG_ERROR("post_vca() failed\n");
+    }
+
+    pthread_mutex_unlock(&vca->m_mtx);
+
+    return;
+}
+
+void *worker(void *arg)
+{
+    assert(arg);
+
+    VCA *vca = (VCA *)arg;
+#ifdef PRE_STORED_YUV
+    vca->query_yuv_info();
+#endif
+    pthread_cleanup_push(cleanup, arg);
+
+    bool unlimited = vca->m_frame_number == -1 ? true : false;
+    bool pause_on_detected = false;
+    unsigned int prev;
+    unsigned int curr;
+    int i = 0;
+
+    while (unlimited || i++ < vca->m_frame_number) {
+        pthread_mutex_lock(&vca->m_mtx);
+
+        while (!vca->m_is_thread_started)
+            pthread_cond_wait(&vca->m_cond, &vca->m_mtx);
+
+        prev = get_current_time();
+
+        if (vca->read_yuv() != 0) {
+            LOG_ERROR("read_yuv() failed\n");
+            pthread_mutex_unlock(&vca->m_mtx);
+            continue;
+        }
+        if (vca->do_vca() == 0) {
+            pause_on_detected = vca->m_detected_cb(vca->m_detected_cb_arg);
+            if (pause_on_detected)
+                vca->m_is_thread_started = false;
+        }
+
+        pthread_mutex_unlock(&vca->m_mtx);
+
+        curr = get_current_time();
+        if (curr - prev < 1000 / VCA_FPS) {
+            usleep(1000 * (curr - prev));
+        }
+
+    };
+
+    pthread_cleanup_pop(0);
+
+    return NULL;
+}
diff --git a/fastboot_app/vca/bpi_vca.h b/fastboot_app/vca/bpi_vca.h
new file mode 100644
index 0000000..6c73c2d
--- /dev/null
+++ b/fastboot_app/vca/bpi_vca.h
@@ -0,0 +1,107 @@
+/*
+ * bpi_vca.h
+ *
+ * History:
+ *       2016/09/13 - [niu zhifeng] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __BPI_VCA_H_
+#define __BPI_VCA_H_
+
+#include "am_video_reader_if.h"
+#include "am_video_address_if.h"
+
+typedef bool (*detected_callback_t)(void *);
+
+class VCA {
+public:
+    virtual ~VCA();
+    static VCA *get_instance();
+
+    /* common for sync & async run */
+    void set_buffer_id(int buffer_id);
+    void set_frame_size(unsigned int width, unsigned int height);
+    void set_frame_number(int frames);
+    void set_time_out(int time_out);
+
+    /* specific for async run */
+    void set_detected_callback(detected_callback_t cb, void *arg);
+
+    /* run vca synchronously */
+    virtual int run();
+
+    /* run & pause vca asynchronously */
+    virtual int run_async();
+    virtual int pause();
+
+protected:
+    VCA();
+
+    virtual int read_yuv();
+    virtual int pre_vca();
+    virtual int do_vca() = 0;
+    virtual int post_vca();
+
+    unsigned int m_buffer_width;
+    unsigned int m_buffer_height;
+    int m_frame_number;
+    int m_time_out;
+    unsigned char *m_buffer_data;
+    unsigned char *m_buffer_y;
+    unsigned char *m_buffer_uv;
+    AMIVideoReaderPtr m_video_reader;
+    AMIVideoAddressPtr m_video_address;
+    int iav_fd;
+#ifdef PRE_STORED_YUV
+    /*For fastboot,  yuv data has been captured already*/
+    unsigned char* m_yuv_src_addr;
+    unsigned int m_remain_size;
+    unsigned int m_src_size;
+    unsigned int m_frame_width;
+    unsigned int m_frame_height;
+    unsigned int m_frame_pitch;
+    unsigned int m_max_height;
+    unsigned int m_uv_height;
+    int query_yuv_info();
+#endif
+
+    /* specific for async run */
+    friend void cleanup(void *);
+    friend void *worker(void *);
+
+    pthread_t m_tid;
+    pthread_mutex_t m_mtx;
+    pthread_cond_t m_cond;
+    bool m_is_thread_created;
+    bool m_is_thread_started;
+    int m_buffer_id;
+    detected_callback_t m_detected_cb;
+    void *m_detected_cb_arg;
+};
+
+#endif /* __BPI_VCA_H_ */
diff --git a/fastboot_app/vca/dummy/bpi_vca_dummy.cpp b/fastboot_app/vca/dummy/bpi_vca_dummy.cpp
new file mode 100644
index 0000000..4e100bb
--- /dev/null
+++ b/fastboot_app/vca/dummy/bpi_vca_dummy.cpp
@@ -0,0 +1,66 @@
+/*
+ * bpi_vca_dummy.cpp
+ *
+ * History:
+ *       2016/09/13 - [niu zhifeng] created file
+ *       2016/10/24 - [yuan xiaojie] modified file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <stdio.h>
+#include <unistd.h>
+#include "bpi_vca_dummy.h"
+
+/* report human detected every 30 frames */
+#define DUMMY_VCA_DETECTED_PERIOD 30
+
+VCA *VCA::get_instance()
+{
+    static DummyVCA instance;
+    printf("DummyVCA instance\n");
+    return &instance;
+}
+
+DummyVCA::DummyVCA():
+    m_frame_cnt(1)
+{
+}
+
+DummyVCA::~DummyVCA()
+{
+}
+
+int DummyVCA::do_vca()
+{
+    if (m_frame_cnt++ % DUMMY_VCA_DETECTED_PERIOD == 0) {
+        printf("test true\n");
+        usleep(2000000);
+        return 0;
+    } else {
+        printf("test false\n");
+        return 1;
+    }
+}
diff --git a/fastboot_app/vca/dummy/bpi_vca_dummy.h b/fastboot_app/vca/dummy/bpi_vca_dummy.h
new file mode 100644
index 0000000..014d46b
--- /dev/null
+++ b/fastboot_app/vca/dummy/bpi_vca_dummy.h
@@ -0,0 +1,48 @@
+/*
+ * bpi_vca_dummy.h
+ *
+ * History:
+ *       2016/09/13 - [niu zhifeng] created file
+ *       2016/10/24 - [yuan xiaojie] modified file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef __BPI_VCA_DUMMY_H_
+#define __BPI_VCA_DUMMY_H_
+
+#include "bpi_vca.h"
+
+class DummyVCA: public VCA {
+public:
+    DummyVCA();
+    virtual ~DummyVCA();
+
+private:
+    virtual int do_vca();
+    int m_frame_cnt;
+};
+
+#endif /* __BPI_VCA_DUMMY_H_ */
diff --git a/fastboot_app/vca/dummy/make.inc b/fastboot_app/vca/dummy/make.inc
new file mode 100644
index 0000000..89d14b1
--- /dev/null
+++ b/fastboot_app/vca/dummy/make.inc
@@ -0,0 +1,57 @@
+#
+# make.inc
+#
+# History:
+#       2016/10/25 - [yuan xiaojie] created file
+#
+# Copyright (c) 2016 Ambarella, Inc.
+#
+# This file and its contents ("Software") are protected by intellectual
+# property rights including, without limitation, U.S. and/or foreign
+# copyrights. This Software is also the confidential and proprietary
+# information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+# disclose, distribute, modify, or otherwise prepare derivative works of this
+# Software or any portion thereof except pursuant to a signed license agreement
+# or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+# In the absence of such an agreement, you agree to promptly notify and return
+# this Software to Ambarella, Inc.
+#
+# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+# MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+# IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+#
+
+LOCAL_PATH   := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+include $(LOCAL_PATH)/../make.common
+
+LOCAL_TARGET	:= libvca.so
+LOCAL_SRCS	+= $(LOCAL_PATH)/bpi_vca_dummy.cpp
+LOCAL_CFLAGS    +=
+LOCAL_LDFLAGS   +=
+
+DUMMY_VCA_SO_TARGET	:= libvca_dummy.so
+
+include $(BUILD_APP)
+
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(IPCAM_APP_LIB_DIR)
+	@cp -dpRf $< $(IPCAM_APP_LIB_DIR)/$(DUMMY_VCA_SO_TARGET)
+	@ln -sf $(DUMMY_VCA_SO_TARGET) $(IPCAM_APP_LIB_DIR)/$(VCA_SO_NAME)
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+
diff --git a/fastboot_app/vca/hawxeye_qmd/ChangeLog.rst b/fastboot_app/vca/hawxeye_qmd/ChangeLog.rst
new file mode 100644
index 0000000..dc163a3
--- /dev/null
+++ b/fastboot_app/vca/hawxeye_qmd/ChangeLog.rst
@@ -0,0 +1,22 @@
+2017-04-11 (Version 1.8.0)
+    * Classifier sensitivity may be set outside [0.0, 1.0] bounds
+
+2017-03-15 (Version 1.7.0)
+    * Moved classifier and detector config references to client config
+    * Model search path can be set in client config
+    * Reorganized config files by platform
+    * Samples build and run from same directory.  No need to install.
+    * Renamed all sample sources to sample.cpp
+    * No longer need to link clients against libtextinsert.a libz.so, libbz2.so, libfreetype.so, tuffy.ttf
+    * Removed package and engine ROIs from sample client config
+    * Updated documentation
+    * Better integration error logging
+
+2017-02-15 (Version 1.6.0)
+    * Added file system logging
+    * Add qmd reference document
+
+2017-01-18 (Version 1.4.5)
+    * qmd: Initial release.
+
+:Copyright: 2016 HawXeye, Inc. All rights reserved.
diff --git a/fastboot_app/vca/hawxeye_qmd/README.md b/fastboot_app/vca/hawxeye_qmd/README.md
new file mode 100644
index 0000000..04e0c33
--- /dev/null
+++ b/fastboot_app/vca/hawxeye_qmd/README.md
@@ -0,0 +1,22 @@
+libhawxeyeqmd | HawXeye Quick Motion Detection Library
+==========================================
+
+USAGE
+-----
+
+Before running the sample, you must manually enter the compiler flag in `set_env.sh` to point to the appropriate compiler, see the TODO: tag in this script.
+
+In order to run the sample, copy sample, models/ and configs/ to the same directory on the device.  Copy libhawxeye.qmd to the library path on the device.  Then, run "./sample".
+
+The client configuration (client.xml) can be updated with non-default
+parameters.  For more information on engine configuration, please see the
+accompanying HTML documentation, section "Parameter Tuning".
+
+
+DOCUMENTATION
+-------------
+
+For documentation regarding how to use the library, please see the documentation under `docs/`.  There are three different forms of documentation: a PDF API reference manual, an html documentation containing a more in-depth introduction and tutorial, as well as the API documentation.
+
+
+Copyright 2017 HawXeye, Inc.  All rights reserved.
diff --git a/fastboot_app/vca/hawxeye_qmd/bpi_vca_hawxeye.cpp b/fastboot_app/vca/hawxeye_qmd/bpi_vca_hawxeye.cpp
new file mode 100644
index 0000000..83bc50c
--- /dev/null
+++ b/fastboot_app/vca/hawxeye_qmd/bpi_vca_hawxeye.cpp
@@ -0,0 +1,104 @@
+/*
+ * bpi_vca_hawxeye.cpp
+ *
+ * History:
+ *       2016/09/13 - [niu zhifeng] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+ //hawxeye library is built with gcc4.x, the abi format is different when use c++11, so use the older abi format here
+#define _GLIBCXX_USE_CXX11_ABI 0
+
+#include <unistd.h>
+#include <stdio.h>
+#include <string.h>
+#include <string>
+#include <vector>
+
+#include "bpi_utils.h"
+#include "bpi_vca_hawxeye.h"
+#include "hreturn.hpp"
+#include "QuickMotionDetector.h"
+
+VCA *VCA::get_instance()
+{
+    static HawxeyeVCA instance;
+    LOG_PRINT("HawxeyeVCA instance\n");
+    return &instance;
+}
+
+HawxeyeVCA::HawxeyeVCA() {
+        LOG_DEBUG("%s entered\n", __FUNCTION__);
+}
+
+HawxeyeVCA::~HawxeyeVCA() {
+    LOG_DEBUG("%s entered \n", __FUNCTION__);
+}
+
+int HawxeyeVCA::pre_vca()
+{
+    // Initialize
+    if (QuickMotionDetectorInitialize("/usr/bin/configs/client.xml") != RETURN_SUCCESS) {
+        LOG_ERROR("QuickMotionDetector initialize failed\n");
+        return -1;
+    }
+    LOG_PRINT("VCA initialized \n");
+    return 0;
+}
+#include <sys/time.h>
+
+int HawxeyeVCA::do_vca()
+{
+    struct timeval tm, tm1;
+    gettimeofday(&tm, NULL);
+
+    bool detections;
+    if (QuickMotionDetectorExecute(&detections, m_buffer_y, m_buffer_width, m_buffer_height) != RETURN_SUCCESS) {
+        LOG_ERROR("QuickMotionDetector execute failed\n");
+        return -1;
+    }
+    gettimeofday(&tm1, NULL);
+    LOG_DEBUG("hawxeye do vca done, cost-> %ld ms\n", tm1.tv_sec*1000+tm1.tv_usec/1000-tm.tv_sec*1000-tm.tv_usec/1000);
+
+    if (detections) {
+        LOG_PRINT("object detected.");
+        return 0;
+    }
+
+    return 1;
+}
+
+int HawxeyeVCA::post_vca()
+{
+    // Destroy VideoAnalysisManager regardless of whether object was detected
+    if (RETURN_SUCCESS != QuickMotionDetectorDestroy()) {
+        LOG_ERROR("QuickMotionDetector destroy failed\n");
+        return -1;
+    }
+
+    return 0;
+}
diff --git a/fastboot_app/vca/hawxeye_qmd/bpi_vca_hawxeye.h b/fastboot_app/vca/hawxeye_qmd/bpi_vca_hawxeye.h
new file mode 100644
index 0000000..58c249d
--- /dev/null
+++ b/fastboot_app/vca/hawxeye_qmd/bpi_vca_hawxeye.h
@@ -0,0 +1,49 @@
+/*
+ * bpi_vca_dummy.h
+ *
+ * History:
+ *       2016/09/13 - [niu zhifeng] created file
+ *       2016/10/24 - [yuan xiaojie] modified file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef __BPI_VCA_HAWXEYE_H_
+#define __BPI_VCA_HAWXEYE_H_
+
+#include "bpi_vca.h"
+
+class HawxeyeVCA: public VCA {
+public:
+    HawxeyeVCA();
+    virtual ~HawxeyeVCA();
+
+private:
+    virtual int pre_vca();
+    virtual int do_vca();
+    virtual int post_vca();
+};
+
+#endif /* __BPI_VCA_HAWXEYE_H_ */
diff --git a/fastboot_app/vca/hawxeye_qmd/configs/classifier.bin b/fastboot_app/vca/hawxeye_qmd/configs/classifier.bin
new file mode 100644
index 0000000..731298b
--- /dev/null
+++ b/fastboot_app/vca/hawxeye_qmd/configs/classifier.bin
@@ -0,0 +1,4 @@
+69U}ANFm#D<p$Nl&w97zlc7'/@.nUnD<*yjsuE~ysAu7w@B_
+hhrc4l8]Ki8kZL+dzz4{H)M\1vCV"sQr^2920sLu^%3.Q2/-|u}Y
+(I@	YO6 g	k{ls@
+ -.?J^w5i^BvMg]CQN?sjsP+Or v0-|'VJNfk$YB{m
\ No newline at end of file
diff --git a/fastboot_app/vca/hawxeye_qmd/configs/client.xml b/fastboot_app/vca/hawxeye_qmd/configs/client.xml
new file mode 100644
index 0000000..0c56208
--- /dev/null
+++ b/fastboot_app/vca/hawxeye_qmd/configs/client.xml
@@ -0,0 +1,33 @@
+<?xml version='1.0' encoding='utf-8'?>
+<videoAnalysisManagerParams>
+    <version>
+        <majorVersion>1</majorVersion>
+        <minorVersion>8</minorVersion>
+        <patchVersion>0</patchVersion>
+    </version>
+    <engineConfig>/usr/bin/configs/config.dat</engineConfig>
+    <classifierConfig>/usr/bin/configs/classifier.bin</classifierConfig>
+    <detectorConfig>/usr/bin/configs/detector.bin</detectorConfig>
+    <modelRoot>/usr/bin/</modelRoot>
+    <defaultValues>
+        <enableUnclassified>1</enableUnclassified>
+        <enablePedestrian>1</enablePedestrian>
+        <daytimeSetting>day</daytimeSetting>
+        <locationSetting>outdoor</locationSetting>
+        <motionSensitivityThreshold>0.5</motionSensitivityThreshold>
+        <pedestrianAspectRatioThreshold>1.8</pedestrianAspectRatioThreshold>
+        <unclassifiedMinNormalizedArea>0.010</unclassifiedMinNormalizedArea>
+        <pedestrianMinNormalizedArea>0.015</pedestrianMinNormalizedArea>
+        <unclassifiedTrackAcceptanceThreshold>0.5</unclassifiedTrackAcceptanceThreshold>
+        <pedestrianTrackAcceptanceThreshold>0.5</pedestrianTrackAcceptanceThreshold>
+        <lostTrackDropThreshold>0.5</lostTrackDropThreshold>
+        <stopGoJoinSensitivity>0.5</stopGoJoinSensitivity>
+        <pedestrianClassifierSensitivity>0.5</pedestrianClassifierSensitivity>
+        <filesystemLogging>
+            <enable>0</enable>
+            <configDir>/tmp</configDir>
+            <logDir>/tmp</logDir>
+            <maxBytes>2000000</maxBytes>
+        </filesystemLogging>
+    </defaultValues>
+</videoAnalysisManagerParams>
diff --git a/fastboot_app/vca/hawxeye_qmd/configs/config.dat b/fastboot_app/vca/hawxeye_qmd/configs/config.dat
new file mode 100644
index 0000000..7ac6e93
--- /dev/null
+++ b/fastboot_app/vca/hawxeye_qmd/configs/config.dat
@@ -0,0 +1,113 @@
+1
+0
+15
+0
+0
+0
+0
+0
+0
+day
+outdoor
+320
+180
+0.0833
+0.0469
+1.25
+1.5
+0
+1.0
+-10.0
+25.0
+0
+15
+2
+1
+0
+15
+5
+9
+0.2
+0.5
+0.5
+75
+0
+6
+2
+65
+accept
+0
+1.8
+0.01
+0.015
+2
+0.0
+20
+3.3333
+20
+1000
+2
+30
+200
+9
+0.05
+10
+0.04
+0.74
+0.4
+0.7
+10
+3.3333
+20
+200
+2
+30
+200
+9
+0.05
+10
+0.04
+0.74
+0.4
+0.7
+7
+3.3333
+8
+500
+2
+30
+200
+9
+0.05
+10
+0.04
+0.95
+0.9
+0.2
+7
+3.3333
+8
+200
+2
+30
+200
+9
+0.05
+10
+0.04
+0.95
+0.9
+0.2
+0
+0
+1
+1
+1
+1
+-1.75
+0.25
+0.333333333
+0.25
+0.25
+0.125
+0.125
diff --git a/fastboot_app/vca/hawxeye_qmd/include/QuickMotionDetector.h b/fastboot_app/vca/hawxeye_qmd/include/QuickMotionDetector.h
new file mode 100644
index 0000000..66e81d5
--- /dev/null
+++ b/fastboot_app/vca/hawxeye_qmd/include/QuickMotionDetector.h
@@ -0,0 +1,62 @@
+/**
+ * @file QuickMotionDetector.h
+ *
+ * @brief Header file for HawXeye's Quick Motion Detection engine.
+ *
+ * @copyright 2016 HawXeye, Inc.  All rights reserved.
+ */
+
+#ifndef QMD_QUICKMOTIONDETECTOR_H_
+#define QMD_QUICKMOTIONDETECTOR_H_
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include <stdint.h>
+
+    /**
+     * @brief Initialize Quick Motion Detection engine.
+     *
+     * @param[in] configFileName path to client configuration XML file
+     *
+     * @return <code>RETURN_SUCCESS</code> upon successful execution, and
+     *         <code>RETURN_FAILURE</code> upon failure.
+     */
+int32_t QuickMotionDetectorInitialize(const char* configFileName);
+
+    /**
+     * @brief Execute the core functionality of Quick Motion Detection.
+     *
+     * <p>This function performs object detection using the input 8-bit
+     * Y-component frame.  Once an object is detected, this function will
+     * continue to return true.</p>
+     *
+     * @param[out] detected TRUE if an object was detected.
+     * @param[in] frame Y-component frame to run object detection on.
+     * @param[in] width width of the frame in pixels.
+     * @param[in] height height of the frame in pixels.
+     *
+     * @return <code>RETURN_SUCCESS</code> upon successful execution, and
+     *         <code>RETURN_FAILURE</code> upon failure.
+     */
+int32_t QuickMotionDetectorExecute(bool* detected,
+                                   unsigned char* frame,
+                                   uint32_t width,
+                                   uint32_t height);
+
+    /**
+     * @brief Destroy Quick Motion Detection engine.
+     *
+     * @return <code>RETURN_SUCCESS</code> upon successful execution, and
+     *         <code>RETURN_FAILURE</code> upon failure.
+     */
+int32_t QuickMotionDetectorDestroy();
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
diff --git a/fastboot_app/vca/hawxeye_qmd/include/hreturn.hpp b/fastboot_app/vca/hawxeye_qmd/include/hreturn.hpp
new file mode 100644
index 0000000..872b0b7
--- /dev/null
+++ b/fastboot_app/vca/hawxeye_qmd/include/hreturn.hpp
@@ -0,0 +1,22 @@
+/**
+ * @file hreturn.hpp
+ *
+ * @brief Header file containing return types used throughout HawXeye's vision
+ *        engine.
+ *
+ * <p>This is the header file containing the core macros used throughout
+ * HawXeye's vision engine.</p>
+ *
+ * @copyright 2016 HawXeye, Inc.  All rights reserved.
+ */
+
+#ifndef RETURN_HPP_
+#define RETURN_HPP_
+
+/** Value to return upon successfull function execution. */
+#define RETURN_SUCCESS 0
+
+/** Value to return upon failed function execution. */
+#define RETURN_FAILURE -1
+
+#endif
diff --git a/fastboot_app/vca/hawxeye_qmd/make.inc b/fastboot_app/vca/hawxeye_qmd/make.inc
new file mode 100644
index 0000000..30100db
--- /dev/null
+++ b/fastboot_app/vca/hawxeye_qmd/make.inc
@@ -0,0 +1,68 @@
+#
+# make.inc
+#
+# History:
+#       2016/10/25 - [yuan xiaojie] created file
+#
+# Copyright (c) 2016 Ambarella, Inc.
+#
+# This file and its contents ("Software") are protected by intellectual
+# property rights including, without limitation, U.S. and/or foreign
+# copyrights. This Software is also the confidential and proprietary
+# information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+# disclose, distribute, modify, or otherwise prepare derivative works of this
+# Software or any portion thereof except pursuant to a signed license agreement
+# or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+# In the absence of such an agreement, you agree to promptly notify and return
+# this Software to Ambarella, Inc.
+#
+# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+# MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+# IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+#
+
+ifneq ($(CONFIG_BSP_BOARD_S3LM_DAREDEVIL), y)
+LOCAL_PATH   := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+include $(LOCAL_PATH)/../make.common
+
+
+LOCAL_TARGET	:= libvca_hawxeye_qmd.so
+IPCAM_APP_BIN_DIR   := $(FAKEROOT_DIR)/usr/bin
+LOCAL_QMD_DIR     := $(LOCAL_PATH)
+LOCAL_SRCS	+= $(LOCAL_PATH)/bpi_vca_hawxeye.cpp
+
+LOCAL_CFLAGS    += -I$(LOCAL_PATH)/include
+
+LOCAL_CFLAGS	+= -std=c++11 -Werror -g
+
+LOCAL_LDFLAGS   += -L$(LOCAL_QMD_DIR)/lib -lhawxeyeqmd
+
+HAWXEYE_VCA_SO_TARGET	:= libvca_hawxeye_qmd.so
+
+include $(BUILD_APP)
+
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(IPCAM_APP_LIB_DIR)
+	@cp -dpRf $< $(IPCAM_APP_LIB_DIR)/$(HAWXEYE_VCA_SO_TARGET)
+	@cp -dpRf $(LOCAL_QMD_DIR)/lib/libhawxeyeqmd.so $(IPCAM_APP_LIB_DIR)/
+	@cp -dpRf $(LOCAL_QMD_DIR)/configs $(IPCAM_APP_BIN_DIR)/
+	@cp -dpRf $(LOCAL_QMD_DIR)/models $(IPCAM_APP_BIN_DIR)/
+	@ln -sf $(HAWXEYE_VCA_SO_TARGET) $(IPCAM_APP_LIB_DIR)/$(VCA_SO_NAME)
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+endif
diff --git a/fastboot_app/vca/hawxeye_qmd/samples/qmd/configs b/fastboot_app/vca/hawxeye_qmd/samples/qmd/configs
new file mode 100644
index 0000000..5992d10
--- /dev/null
+++ b/fastboot_app/vca/hawxeye_qmd/samples/qmd/configs
@@ -0,0 +1 @@
+../../configs
\ No newline at end of file
diff --git a/fastboot_app/vca/hawxeye_qmd/samples/qmd/models b/fastboot_app/vca/hawxeye_qmd/samples/qmd/models
new file mode 100644
index 0000000..9e68e99
--- /dev/null
+++ b/fastboot_app/vca/hawxeye_qmd/samples/qmd/models
@@ -0,0 +1 @@
+../../models
\ No newline at end of file
diff --git a/fastboot_app/vca/hawxeye_qmd/samples/qmd/sample.cpp b/fastboot_app/vca/hawxeye_qmd/samples/qmd/sample.cpp
new file mode 100644
index 0000000..4ce516c
--- /dev/null
+++ b/fastboot_app/vca/hawxeye_qmd/samples/qmd/sample.cpp
@@ -0,0 +1,67 @@
+/**
+ * @copyright 2016 HawXeye, Inc.  All rights reserved.
+ */
+#include <iostream>
+#include <stdlib.h>
+
+#include "hreturn.hpp"
+
+extern "C" {
+#include "QuickMotionDetector.h"
+}
+
+/**
+ * @brief Test function that shows functionality of the
+ *        <code>QuickMotionDetector</code>.
+ *
+ * @return Exit code for the process - 0 for success, else an error code.
+ */
+int main(int argc, char* argv[]) {
+    // Initialize QuickMotionDetector
+    int32_t retval = QuickMotionDetectorInitialize("./configs/s2lm/client.xml");
+    if (retval != RETURN_SUCCESS) {
+        std::cerr << "Engine initialization failed" << std::endl;
+        return EXIT_FAILURE;
+    }
+    std::cout << "Engine initialized\n";
+
+    // TODO: Replace these static frames with input queried
+    // from camera, file, stream, etc.
+    const int FRAME_WIDTH = 8;
+    const int FRAME_HEIGHT = 8;
+    unsigned char frame[] = {0, 0, 0, 0, 0, 0, 0, 0,
+                             0, 0, 0, 0, 0, 0, 0, 0,
+                             0, 0, 0, 0, 0, 0, 0, 0,
+                             0, 0, 0, 0, 0, 0, 0, 0,
+                             0, 0, 0, 0, 0, 0, 0, 0,
+                             0, 0, 0, 0, 0, 0, 0, 0,
+                             0, 0, 0, 0, 0, 0, 0, 0,
+                             0, 0, 0, 0, 0, 0, 0, 0};
+
+    // Run detection on a frame.  Normally, QuickMotionDetectorExecute()
+    // should be run in a tight loop, after the next frame is retrieved.
+    // This function will return false until the first detection is found,
+    // after which it will always return true.
+    // Note: This is not enough input to return any detections.
+    bool detections;
+    retval = QuickMotionDetectorExecute(&detections, frame, FRAME_WIDTH, FRAME_HEIGHT);
+    if (retval != RETURN_SUCCESS) {
+        std::cerr << "QuickMotionDetectorExecute() failed" << std::endl;
+        return EXIT_FAILURE;
+    }
+
+    if (detections) {
+        std::cout << "Object detected\n";
+    } else {
+        std::cout << "Object not detected\n";
+    }
+
+    std::cout << "Exiting engine\n";
+    retval = QuickMotionDetectorDestroy();
+    if (retval != RETURN_SUCCESS) {
+        std::cerr << "Engine exit failed" << std::endl;
+        return EXIT_FAILURE;
+    }
+
+    return EXIT_SUCCESS;
+}
diff --git a/fastboot_app/vca/make.common b/fastboot_app/vca/make.common
new file mode 100644
index 0000000..f446c94
--- /dev/null
+++ b/fastboot_app/vca/make.common
@@ -0,0 +1,18 @@
+LOCAL_SRCS      := $(LOCAL_PATH)/../bpi_vca.cpp
+LOCAL_CFLAGS	:= -I$(LOCAL_PATH)/.. \
+                   -I$(LOCAL_PATH)/../../bpi_app \
+                   -I$(LOCAL_PATH)/../../utils \
+                   -I$(ORYX_DIR)/include \
+                   -I$(ORYX_DIR)/include/utility \
+                   -I$(ORYX_DIR)/include/video \
+                   -std=c++11 -Werror
+LOCAL_LIBS      := libamvideo-reader.so libamvideo-address.so
+LOCAL_LDFLAGS   :=
+
+IPCAM_APP_LIB_DIR         := $(FAKEROOT_DIR)/usr/lib
+VCA_SO_NAME     := libvca.so.0
+LOCAL_SO_NAME   := $(VCA_SO_NAME)
+
+ifeq ($(CONFIG_BPI_APP_HIBERNATION), y)
+LOCAL_CFLAGS += -DPRE_STORED_YUV=1
+endif
diff --git a/fastboot_app/vca/make.inc b/fastboot_app/vca/make.inc
new file mode 100644
index 0000000..3ef99f3
--- /dev/null
+++ b/fastboot_app/vca/make.inc
@@ -0,0 +1,32 @@
+#
+# make.inc
+#
+# History:
+#       2016/10/25 - [yuan xiaojie] created file
+#
+# Copyright (c) 2016 Ambarella, Inc.
+#
+# This file and its contents ("Software") are protected by intellectual
+# property rights including, without limitation, U.S. and/or foreign
+# copyrights. This Software is also the confidential and proprietary
+# information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+# disclose, distribute, modify, or otherwise prepare derivative works of this
+# Software or any portion thereof except pursuant to a signed license agreement
+# or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+# In the absence of such an agreement, you agree to promptly notify and return
+# this Software to Ambarella, Inc.
+#
+# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+# MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+# IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+#
+include $(call all-subdir-makefiles)
diff --git a/fastboot_audio/AmbaConfig b/fastboot_audio/AmbaConfig
index 0e37ea4..fd169c6 100644
--- a/fastboot_audio/AmbaConfig
+++ b/fastboot_audio/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/12/12 - [Jian Liu] Create
 ##
-## Copyright (C) 2014, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 
diff --git a/fastboot_audio/fastboot_audio.c b/fastboot_audio/fastboot_audio.c
index 53791d4..a6f4b61 100644
--- a/fastboot_audio/fastboot_audio.c
+++ b/fastboot_audio/fastboot_audio.c
@@ -5,14 +5,33 @@
  * History:
  *	2014/12/12 - [Jian Liu] create this file
  *
- * Copyright (C) 2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
diff --git a/fastboot_audio/getopt_s.c b/fastboot_audio/getopt_s.c
index 136f830..5d6d224 100644
--- a/fastboot_audio/getopt_s.c
+++ b/fastboot_audio/getopt_s.c
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 /*
  * getopt.c
  *
diff --git a/fastboot_audio/getopt_s.h b/fastboot_audio/getopt_s.h
index 3eb8681..f51c6bb 100644
--- a/fastboot_audio/getopt_s.h
+++ b/fastboot_audio/getopt_s.h
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 /*
  * getopt.h
  *
diff --git a/fastboot_audio/make.inc b/fastboot_audio/make.inc
index 6954486..41d231c 100644
--- a/fastboot_audio/make.inc
+++ b/fastboot_audio/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/12/12 - [Jian Liu] Created file
 ##
-## Copyright (C) 2014, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_APP_FASTBOOT_AUDIO), y)
diff --git a/fastboot_smart3a/AmbaConfig b/fastboot_smart3a/AmbaConfig
index f6b246b..a9b677a 100644
--- a/fastboot_smart3a/AmbaConfig
+++ b/fastboot_smart3a/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2015/01/21 - [Roy Su] Created file
 ##
-## Copyright (C) 2014-2018, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 config BUILD_AMBARELLA_APP_FASTBOOT_SMART3A
diff --git a/fastboot_smart3a/adc_io.c b/fastboot_smart3a/adc_io.c
new file mode 100644
index 0000000..6c240ba
--- /dev/null
+++ b/fastboot_smart3a/adc_io.c
@@ -0,0 +1,214 @@
+/**
+ * app/ipcam/fastboot_smart3a/adc_iol.c
+ *
+ * Author: Caizhang Lin <czlin@ambarella.com>
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ( "Software" ) are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <iav_ioctl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <string.h>
+#include "adc_io.h"
+#include "adc_util.h"
+#include "iav_fastboot.h"
+
+/* external interfaces of adc_util.lib */
+#define PRELOAD_PARAMS_IN_AMBOOT_FILE    "/tmp/params_in_amboot.conf"
+static int print_amboot_params(struct params_info* params)
+{
+    FILE *fp = fopen(PRELOAD_PARAMS_IN_AMBOOT_FILE, "wb");
+    if (fp) {
+        fprintf(fp, "enable_params=%u\n"
+                "    stream0_recording_mode=%u\n"
+                "    stream0_recording_bitrate=%u\n"
+                "    enable_stream0_recording_smartavc=%u\n"
+                "    enable_dual_stream=%u\n"
+                "    stream1_recording_mode=%u\n"
+                "    stream1_recording_bitrate=%u\n"
+                "    enable_stream1_recording_smartavc=%u\n"
+                "    stream0_streaming_resolution=%u\n"
+                "    stream0_streaming_bitrate=%u\n"
+                "    enable_stream0_streaming_smartavc=%u\n"
+                "    enable_stream0_streaming_svct=%u\n"
+                "    rotation_mode=%d\n"
+                "### end of enable_params control ####\n"
+                "enable_fastosd=%u\n"
+                "fastosd_string=%s\n"
+                "timezone=%d\n"
+                "smart3a_strategy=%d\n"
+                "enable_ldc=%d\n"
+                "enable_vca=%d\n"
+                "vca_frame_num=%d\n",
+                params->enable_params,
+                params->stream0_recording_mode,
+                params->stream0_recording_bitrate,
+                params->enable_stream0_recording_smartavc,
+                params->enable_dual_stream,
+                params->stream1_recording_mode,
+                params->stream1_recording_bitrate,
+                params->enable_stream1_recording_smartavc,
+                params->stream0_streaming_resolution,
+                params->stream0_streaming_bitrate,
+                params->enable_stream0_streaming_smartavc,
+                params->enable_stream0_streaming_svct,
+                params->rotation_mode,
+                params->enable_fastosd,
+                params->fastosd_string,
+                params->timezone,
+                params->smart3a_strategy,
+                params->enable_ldc,
+                params->enable_vca,
+                params->vca_frame_num);
+        fclose(fp);
+    } else {
+        printf("open %s failed!\n", PRELOAD_PARAMS_IN_AMBOOT_FILE);
+        return -1;
+    }
+    return 0;
+}
+
+int adc_io_mem_dump()
+{
+    char aaa_content[32];
+    int fd_iav = open("/dev/iav", O_RDWR, 0);
+    if(fd_iav < 0) {
+        return -1;
+    }
+    u8* smart3A_mem;
+    struct iav_querybuf querybuf;
+    querybuf.buf = IAV_BUFFER_FB_DATA;
+check_again:
+    if (ioctl(fd_iav, IAV_IOC_QUERY_BUF, &querybuf) < 0) {
+        if(errno == EINTR) goto check_again;
+        perror("IAV_IOC_QUERY_BUF");
+        return -1;
+    }
+    smart3A_mem = (u8*)mmap(NULL,  querybuf.length, PROT_READ, MAP_SHARED, fd_iav, querybuf.offset);
+    if (smart3A_mem == MAP_FAILED) {
+        perror("AE AWB mmap failed\n");
+        return -1;
+    }
+    close(fd_iav);
+
+    struct params_info* amboot_params = (struct params_info*) (smart3A_mem + FASTBOOT_USER_DATA_OFFSET);
+    print_amboot_params(amboot_params);
+    // TODO:why 4 bytes offset
+    struct  smart3a_file_info* aaa_param = (struct smart3a_file_info*) (smart3A_mem + FASTBOOT_USER_DATA_OFFSET + sizeof(struct params_info)-4);
+
+    memset(aaa_content, 0, sizeof(aaa_content));
+    snprintf(aaa_content, sizeof(aaa_content), "%d,%d\n",
+             aaa_param->r_gain,
+             aaa_param->b_gain);
+    save_content_file(PRELOAD_AWB_FILE, aaa_content);
+
+    memset(aaa_content, 0, sizeof(aaa_content));
+    snprintf(aaa_content, sizeof(aaa_content), "%d,%d,%d\n",
+             aaa_param->d_gain,
+             aaa_param->shutter,
+             aaa_param->agc);
+    save_content_file(PRELOAD_AE_FILE, aaa_content);
+
+    return 0;
+}
+
+int adc_io_read(int verbose, int mode)
+{
+    int  rval = 0;
+    struct params_info amboot_params = {0};
+    do {
+        rval = adc_util_init(verbose);
+        if (rval < 0) {
+            printf("adc_util_init failed\n");
+            break;
+        }
+        if (mode & AMBOOT_PARAMETERS) {
+            rval = adc_util_get_amboot_params(&amboot_params);
+            if (rval < 0) {
+                printf("adc_util_get_amboot_params failed\n");
+                break;
+            }
+            if (print_amboot_params(&amboot_params)<0) {
+                break;
+            }
+
+        }
+        if (mode & SMART3A_PARAMETERS) {
+            rval = adc_util_read_3a_params(verbose);
+            if (rval < 0) {
+                break;
+            }
+        }
+    } while (0);
+
+    adc_util_finish();
+    return rval;
+}
+
+int adc_io_write(int verbose, int mode, struct params_info* params)
+{
+    int rval = 0;
+    do {
+        rval = adc_util_init(verbose);
+        if (rval < 0) {
+            printf("adc_util_init failed\n");
+            break;
+        }
+
+        if ((mode & AMBOOT_PARAMETERS) && (params != NULL)) {
+            //udpate params_in_amboot
+            rval = adc_util_set_amboot_params(params);
+            if (rval < 0) {
+                printf("adc_util_set_amboot_params failed\n");
+                break;
+            }
+        }
+        switch(mode) {
+            case SMART3A_PARAMETERS:
+                rval = adc_util_write(verbose, 0);
+                break;
+            case AMBOOT_PARAMETERS:
+                rval = adc_util_write(verbose, 1);        //skip updating 3a parameters, only update amboot_arams
+                break;
+            case AMBOOT_PARAMETERS | SMART3A_PARAMETERS:
+                rval = adc_util_write(verbose, 0);
+                break;
+            default:
+                printf("Unknown adc write mode.\n");
+                rval = -1;
+                break;
+        }
+        if (rval < 0) {
+            break;
+        }
+    } while (0);
+    adc_util_finish();
+    return rval;
+}
diff --git a/fastboot_smart3a/adc_io.h b/fastboot_smart3a/adc_io.h
new file mode 100644
index 0000000..f11cc58
--- /dev/null
+++ b/fastboot_smart3a/adc_io.h
@@ -0,0 +1,43 @@
+/**
+ * app/ipcam/fastboot_smart3a/adc_iol.h
+ *
+ * Author: Caizhang Lin <czlin@ambarella.com>
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ( "Software" ) are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef   _ADC_IO_H_
+#define   _ADC_IO_H_
+
+#include "adc.h"
+
+#define SMART3A_PARAMETERS  (1 << 0)
+#define AMBOOT_PARAMETERS (1 << 1)
+
+int adc_io_mem_dump();
+int adc_io_read(int verbose, int mode);
+int adc_io_write(int verbose, int mode, struct params_info* params);
+
+#endif
diff --git a/fastboot_smart3a/adc_util.c b/fastboot_smart3a/adc_util.c
new file mode 100644
index 0000000..8debd04
--- /dev/null
+++ b/fastboot_smart3a/adc_util.c
@@ -0,0 +1,1028 @@
+/**
+ * app/ipcam/fastboot_smart3a/adc_util.c
+ *
+ * Author: Caizhang Lin <czlin@ambarella.com>
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ( "Software" ) are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <unistd.h>
+#include <errno.h>
+#include <linux/rtc.h>
+#include <sys/time.h>
+#include <sys/ioctl.h>
+#include <time.h>
+
+#include "AmbaDataType.h"
+#include "ambas_imgproc_arch.h"
+#include "ambas_imgproc_ioctl_arch.h"
+
+#include "config.h"
+#include "adc.h"
+#include "upgrade_partition.h"
+#include "upgrade_part_adc.h"
+
+#include "iav_ioctl.h"
+#include "adc_util.h"
+#include "iav_fastboot.h"
+
+#define UPDATED_ADC_IMAGE_PATH	"/tmp/updated_adc.bin"
+
+static uint32_t idspcfg_dump_bin(int fd_iav, uint8_t *bin_buffer)
+{
+    idsp_config_info_t dump_idsp_info;
+    int rval = -1;
+
+    dump_idsp_info.id_section = 0;
+    dump_idsp_info.addr = bin_buffer;
+
+    rval = ioctl(fd_iav, IAV_IOC_IMG_DUMP_IDSP_SEC, &dump_idsp_info);
+    if (rval < 0) {
+        perror("IAV_IOC_IMG_DUMP_IDSP_SEC");
+        return 0;
+    }
+    printf("idspcfg size=%u\n", dump_idsp_info.addr_long);
+    return dump_idsp_info.addr_long;
+}
+
+static void rtc_read_tm(struct tm *ptm, int fd)
+{
+    memset(ptm, 0, sizeof(*ptm));
+    ioctl(fd, RTC_RD_TIME, ptm);
+    ptm->tm_isdst = -1; /* "not known" */
+}
+
+static int select_idsp_cfg_via_rtc_hour()
+{
+    struct tm tm_time;
+    time_t timer;
+    struct tm s_tblock = {0};
+    struct tm *tblock = NULL;
+    int fd = 0;
+    char *oldtz = NULL;
+
+    //get RTC time
+    fd = open("/dev/rtc", O_RDONLY);
+    if (fd < 0) {
+        fd = open("/dev/rtc0", O_RDONLY);
+        if (fd < 0) {
+            fd = open("/dev/misc/rtc", O_RDONLY);
+            if (fd < 0) {
+                printf("Open RTC failed\n");
+                return -1;
+            }
+        }
+    }
+    rtc_read_tm(&tm_time, fd);
+    close(fd);
+
+    //save old local time zone
+    oldtz = getenv("TZ");
+
+    //set local time zone to UTC
+    putenv((char*)"TZ=UTC0");
+    tzset();
+
+    //get local time(now is UTC)
+    timer = mktime(&tm_time);
+
+    //parse local time(now is UTC)
+    localtime_r(&timer, &s_tblock);
+
+    //restore old local time zone
+    unsetenv("TZ");
+    if (oldtz) {
+        putenv(oldtz - 3);
+    }
+    tzset();
+
+    tblock = &s_tblock;
+    if (tblock->tm_hour < 0 || tblock->tm_hour >= 24) {
+        printf("RTC hour is invalid\n");
+        return -1;
+    } else {
+        return tblock->tm_hour;
+    }
+}
+
+// the first one is used for 3A parameters write back is required
+static int select_idsp_cfg(enum idsp_cfg_select_policy policy)
+{
+    switch (policy) {
+    case IDSP_CFG_SELECT_ONLY_ONE:
+        return 0;
+        break;
+
+    case IDSP_CFG_SELECT_VIA_UTC_HOUR:
+        return select_idsp_cfg_via_rtc_hour();
+        break;
+
+    case IDSP_CFG_SELECT_VIA_ENV_BRIGHTNESS:
+        printf("Policy BRIGHTNESS not supported yet\n");
+        return -1;
+        break;
+
+    default:
+        printf("Invalid policy %d\n", policy);
+        return -1;
+        break;
+    }
+}
+
+static int find_mtd_device_path(const char *dev_name, char *dev_info_buf,
+                                int dev_info_bufsize)
+{
+    FILE *stream = 0;
+    int device_index = -1;
+
+    if (!dev_name || !dev_info_buf || 0 == dev_info_bufsize) {
+        printf("Find mtd device path, NULL input\n");
+        return -1;
+    }
+    memset(dev_info_buf, 0, dev_info_bufsize);
+
+    //get mtd device index and path
+    sprintf(dev_info_buf, "cat /proc/mtd | grep %s | cut -d':' -f1 | cut -d'd' -f2", dev_name);
+    stream = popen(dev_info_buf , "r" );
+    if (NULL == stream) {
+        printf("Open /proc/mtd  %s  failed.\n", dev_name);
+        return -1;
+    }
+    fscanf(stream,"%d", &device_index);
+    pclose(stream);
+
+    if (device_index < 0) {
+        printf("Not found %s partition on /proc/mtd\n", dev_name);
+        return -1;
+    }
+    memset(dev_info_buf, 0, dev_info_bufsize);
+    sprintf(dev_info_buf, "/dev/mtd%d", device_index);
+
+    return 0;
+}
+
+static int load_adc_to_mem (uint32_t *adc_img_len,
+                            uint32_t *adc_img_aligned_len, void **pp_adc_aligned_mem, int verbose)
+{
+    char dev_info_buf[128];
+    int ret = 0, count = 0;
+    int ptb_fd = 0, ptb_offset;
+    uint8_t *ptb_buf = NULL;
+    struct mtd_info_user ptb_meminfo;
+    loff_t ptb_bad_offset;
+    flpart_table_t *table;
+    unsigned long long blockstart = 1;
+    int fd = 0, bs, badblock = 0;
+    struct mtd_info_user meminfo;
+    unsigned long ofs;
+    void *p_adc_mem_cur = NULL;
+
+    if (!adc_img_len || !adc_img_aligned_len || !pp_adc_aligned_mem) {
+        printf("Load ADC to mem, NULL input\n");
+        ret = -1;
+        goto closeall;
+    }
+
+    ret = find_mtd_device_path("ptb", dev_info_buf, sizeof(dev_info_buf));
+    if (ret < 0) {
+        printf("Find ptb partition failed\n");
+        ret = -1;
+        goto closeall;
+    }
+
+    /* Open the PTB device */
+    if ((ptb_fd = open(dev_info_buf, O_RDONLY)) == -1) {
+        perror("open PTB");
+        ret = -1;
+        goto closeall;
+    }
+
+    /* Fill in MTD device capability structure */
+    if ((ret = ioctl(ptb_fd, MEMGETINFO, &ptb_meminfo)) != 0) {
+        perror("PTB MEMGETINFO");
+        ret = -1;
+        goto closeall;
+    }
+
+    for (ptb_offset = 0; ptb_offset < ptb_meminfo.size; ptb_offset += ptb_meminfo.erasesize) {
+        ptb_bad_offset = ptb_offset;
+        if ((ret = ioctl(ptb_fd, MEMGETBADBLOCK, &ptb_bad_offset)) < 0) {
+            perror("ioctl(MEMGETBADBLOCK)");
+            goto closeall;
+        }
+
+        if (ret == 0) {
+            break;
+        }
+    }
+    if (ptb_offset >= ptb_meminfo.size) {
+        printf("Can not find good block in PTB.\n");
+        ret = -1;
+        goto closeall;
+    }
+
+    ptb_buf = malloc(ptb_meminfo.erasesize);
+    memset(ptb_buf, 0, ptb_meminfo.erasesize);
+
+    /* Read partition table.
+    * Note: we need to read and save the entire block data, because the
+    * entire block will be erased when write partition table back to flash.
+    * BTW, flpart_meta_t is located in the same block as flpart_table_t
+    */
+    count = ptb_meminfo.erasesize;
+    if (pread(ptb_fd, ptb_buf, count, ptb_offset) != count) {
+        perror("pread PTB");
+        ret = -1;
+        goto closeall;
+    }
+
+    table = PTB_TABLE(ptb_buf);
+    *adc_img_len = table->part[PART_ADC].img_len;
+
+    ret = find_mtd_device_path("adc", dev_info_buf, sizeof(dev_info_buf));
+    if (ret < 0) {
+        printf("Find ADC partition failed\n");
+        ret = -1;
+        goto closeall;
+    }
+
+    /* Open ADC device */
+    if ((fd = open(dev_info_buf, O_RDONLY)) == -1) {
+        perror("open mtd");
+        ret = -1;
+        goto closeall;
+    }
+
+    /* Fill in MTD device capability structure */
+    if (ioctl(fd, MEMGETINFO, &meminfo) != 0) {
+        perror("MEMGETINFO");
+        ret = -1;
+        goto closeall;
+    }
+
+    bs = meminfo.writesize;
+    *adc_img_aligned_len = ((*adc_img_len)+(bs-1))&(~(bs-1));
+
+    if (verbose) {
+        printf("ADC img addr=%u, img len=%u, img aligned_len=%u\n",
+            table->part[PART_ADC].mem_addr, *adc_img_len, *adc_img_aligned_len);
+    }
+
+    //will be freed when process return
+    *pp_adc_aligned_mem = (void*)malloc(*adc_img_aligned_len);
+    if (!(*pp_adc_aligned_mem)) {
+        printf("Can not malloc memory for load ADC partiton!\n");
+        ret = -1;
+        goto closeall;
+    }
+    p_adc_mem_cur = *pp_adc_aligned_mem;
+
+    if (verbose) {
+        /* Print informative message */
+        printf("Total size %u, Block size %u, page size %u, OOB size %u\n",
+            meminfo.size,meminfo.erasesize, meminfo.writesize, meminfo.oobsize);
+        printf("Loading data starting at 0x%08x and ending at 0x%08x\n",
+            table->part[PART_ADC].mem_addr,
+            table->part[PART_ADC].mem_addr+(*adc_img_aligned_len));
+    }
+
+    /* Load the flash contents */
+    for (ofs = 0; ofs < *adc_img_aligned_len ; ofs+=bs) {
+        // new eraseblock , check for bad block
+        if (blockstart != (ofs & (~meminfo.erasesize + 1))) {
+            blockstart = ofs & (~meminfo.erasesize + 1);
+            if ((badblock = ioctl(fd, MEMGETBADBLOCK, &blockstart)) < 0) {
+                perror("ioctl(MEMGETBADBLOCK)");
+                ret = -1;
+                goto closeall;
+            }
+        }
+
+        if (badblock) {
+            //memset (p_adc_mem_cur, 0xff, bs);
+            continue;
+        } else {
+            /* Read page data and exit on failure */
+            if (pread(fd, p_adc_mem_cur, bs, ofs) != bs) {
+                perror("pread");
+                ret = -1;
+                goto closeall;
+            }
+        }
+        p_adc_mem_cur+=bs;
+    }
+
+    /* Exit happy */
+    ret = 0;
+
+closeall:
+    if (ptb_buf) {
+        free(ptb_buf);
+        ptb_buf  = NULL;
+    }
+
+    if (ptb_fd) {
+        close(ptb_fd);
+        ptb_fd = 0;
+    }
+    if (fd) {
+        close(fd);
+        fd = 0;
+    }
+
+    return ret;
+}
+
+static int update_adc_partition(int verbose)
+{
+    char cmd[256];
+    FILE   *stream = 0;
+    int device_index = -1;
+
+    memset(cmd, 0, sizeof(cmd));
+
+    stream = popen( "cat /proc/mtd | grep adc | cut -d':' -f1 | cut -d'd' -f2", "r" );
+    if (NULL == stream) {
+        printf("Open /proc/mtd failed\n");
+        return -1;
+    }
+    fscanf(stream, "%d", &device_index);
+    pclose(stream);
+    if (device_index < 0) {
+        printf("Not found ADC partition on /proc/mtd\n");
+        return -1;
+    }
+    //erase nand flash before re-write
+    sprintf(cmd, "flash_eraseall /dev/mtd%d", device_index);
+
+    if (verbose) {
+        printf("CMD: %s\n", cmd);
+    }
+    system(cmd);
+    if (upgrade_partition(device_index, UPDATED_ADC_IMAGE_PATH) != 0) {
+        printf("upgrade_partition fail\n");
+        return -1;
+    }
+
+    return 0;
+}
+
+static int get_reg_data(const uint16_t reg_addr, int fd_iav)
+{
+    struct vindev_reg reg;
+    reg.vsrc_id = 0;
+    reg.addr = reg_addr;
+    int rval = ioctl(fd_iav, IAV_IOC_VIN_GET_REG, &reg);
+    if (rval < 0) {
+        printf("addr 0x%04x, read fail\n", reg_addr);
+        return -1;
+    }
+
+    return reg.data;
+}
+
+int save_content_file(char *filename, char *content)
+{
+    FILE *fp;
+    int ret = -1;
+
+    fp = fopen(filename, "wb");
+    if (fp == NULL) {
+        perror("fopen");
+        return ret;
+    }
+
+    ret = fwrite(content, strlen(content), 1, fp);
+    fclose(fp);
+    fp = NULL;
+
+    return ret;
+}
+
+static void read_awb_ae_config(struct smart3a_file_info *info, const char*  awb_filename, const char* ae_filename)
+{
+    FILE *fp_ae;
+    FILE *fp_awb;
+    char content[64];
+    char *content_c = NULL;
+
+    fp_awb = fopen(awb_filename, "r");
+    if (fp_awb != NULL) {
+        fseek(fp_awb, 0, SEEK_SET);
+        memset(content, 0, sizeof(content));
+        fread(content, sizeof(content) + 1, 1, fp_awb);
+        fclose(fp_awb);
+        fp_awb = NULL;
+
+        content_c = strtok(content, ",");
+        if (content_c) {
+            info->r_gain = atoi(content_c);
+        }
+        content_c = strtok(NULL, ",");
+        if (content_c) {
+            info->b_gain = atoi(content_c);
+        }
+    }
+
+    fp_ae = fopen(ae_filename, "r");
+    if (fp_ae != NULL) {
+        fseek(fp_ae, 0, SEEK_SET);
+        memset(content, 0, sizeof(content));
+        fread(content, sizeof(content) + 1, 1, fp_ae);
+        fclose(fp_ae);
+        fp_ae = NULL;
+
+        content_c = strtok(content, ",");
+        if (content_c) {
+            info->d_gain= atoi(content_c);
+        }
+        content_c = strtok(NULL, ",");
+        if (content_c) {
+            info->shutter = atoi(content_c);
+        }
+        content_c = strtok(NULL, ",");
+        if (content_c) {
+            info->agc = atoi(content_c);
+        }
+    }
+
+}
+
+
+/************************************************
+* external functions of adc_util
+*************************************************/
+static uint32_t adc_img_len_s = 0;   // Lengh of image in the partition
+static uint32_t adc_img_aligned_len_s = 0;  //aligned to page size of adc parttiton
+static void* p_adc_aligned_mem_s = NULL;   //aligned to page size of adc parttiton
+struct adcfw_header * hdr_s = NULL;
+
+// load adc to mem, return mem addr
+int  adc_util_init(int verbose)
+{
+    int rval = 0;
+    struct timeval time1 = {0, 0};
+    struct timeval time2 = {0, 0};
+    signed long long  time1_US = 0;
+    signed long long  time2_US = 0;
+
+    do {
+        if (verbose) {
+            gettimeofday(&time1, NULL);
+        }
+        //step 1: load whole adc partition to mem
+        rval = load_adc_to_mem (&adc_img_len_s, &adc_img_aligned_len_s, &p_adc_aligned_mem_s, verbose);
+        if (rval < 0) {
+            printf("Load ADC to memory failed\n");
+            break;
+        }
+
+        if (verbose) {
+            gettimeofday(&time2, NULL);
+            time1_US = ((signed long long)(time1.tv_sec) * 1000000 + (signed long long)(time1.tv_usec));
+            time2_US = ((signed long long)(time2.tv_sec) * 1000000 + (signed long long)(time2.tv_usec));
+            printf("[TIME]: <Load ADC partition to image> cost %lld US!\n", time2_US-time1_US);
+        }
+
+        hdr_s = (struct adcfw_header *)p_adc_aligned_mem_s;
+        if (hdr_s->magic != ADCFW_IMG_MAGIC || hdr_s->fw_size != adc_img_len_s) {
+            printf("Invalid ADC partition, magic=%u(should be %u), fw_size=%u(should be %u)\n",
+                hdr_s->magic, ADCFW_IMG_MAGIC, hdr_s->fw_size, adc_img_len_s);
+            rval = -1;
+            break;
+        }
+    } while (0);
+
+    return rval;
+}
+
+void  adc_util_finish()
+{
+    if (p_adc_aligned_mem_s) {
+        free(p_adc_aligned_mem_s);
+        p_adc_aligned_mem_s  = NULL;
+    }
+    hdr_s= NULL;
+}
+
+int adc_util_get_amboot_params(struct params_info* params)
+{
+    int rval = 0;
+    do {
+        if (NULL == hdr_s) {
+            printf("adc_util not initialized!");
+            rval =  -1;
+            break;
+        }
+        *params = hdr_s->params_in_amboot;
+    } while (0);
+    return rval;
+}
+
+int adc_util_set_amboot_params(struct params_info* params)
+{
+    int rval = 0;
+    do {
+        if (NULL == hdr_s) {
+            printf("adc_util not initialized!");
+            rval =  -1;
+            break;
+        }
+        hdr_s->params_in_amboot = *params;
+    } while (0);
+    return rval;
+}
+
+int adc_util_read_3a_params(int verbose)
+{
+    int rval = 0;
+    int idsp_cfg_index = -1;
+    enum idsp_cfg_select_policy policy = IDSP_CFG_SELECT_ONLY_ONE;
+    uint32_t addr = 0, size = 0;
+    char aaa_content[32];
+
+    if (NULL == hdr_s) {
+        printf("adc_util not initialized!");
+        return -1;
+    }
+    do {
+        //step 2: find the mem address of the selected section among adc image
+        idsp_cfg_index = select_idsp_cfg(policy);
+        if (idsp_cfg_index < 0 || idsp_cfg_index >= hdr_s->smart3a_num) {
+            printf("Wrong idspcfg section via policy 0x%x, idspcfg index=%d, should in [0, %u)\n",
+                policy, idsp_cfg_index, hdr_s->smart3a_num);
+            rval = -1;
+            break;
+        }
+
+        addr = (uint32_t)hdr_s + hdr_s->smart3a[idsp_cfg_index].offset;
+        size = hdr_s->smart3a_size;
+
+        if (size <= IDSPCFG_BINARY_HEAD_SIZE || 0 == addr) {
+            printf("Invalid idspcfg section %d, addr=%u, size=%u!\n", idsp_cfg_index, addr, size);
+            rval = -1;
+            break;
+        }
+
+        printf("ADC 3A info: r_gain=%d, b_gain=%d. d_gain=%d, shutter=%d, agc=%d.\n",
+             hdr_s->smart3a[idsp_cfg_index].r_gain, hdr_s->smart3a[idsp_cfg_index].b_gain,
+             hdr_s->smart3a[idsp_cfg_index].d_gain, hdr_s->smart3a[idsp_cfg_index].shutter,
+             hdr_s->smart3a[idsp_cfg_index].agc);
+
+        memset(aaa_content, 0, sizeof(aaa_content));
+        snprintf(aaa_content, sizeof(aaa_content), "%d,%d\n",
+             hdr_s->smart3a[idsp_cfg_index].r_gain,
+             hdr_s->smart3a[idsp_cfg_index].b_gain);
+
+        save_content_file(PRELOAD_AWB_FILE, aaa_content);
+
+        memset(aaa_content, 0, sizeof(aaa_content));
+        snprintf(aaa_content, sizeof(aaa_content), "%d,%d,%d\n",
+             hdr_s->smart3a[idsp_cfg_index].d_gain,
+             hdr_s->smart3a[idsp_cfg_index].shutter,
+             hdr_s->smart3a[idsp_cfg_index].agc);
+        save_content_file(PRELOAD_AE_FILE, aaa_content);
+    } while (0);
+
+    return rval;
+}
+
+
+#define VIDEO_MODE_H264_1080P     0
+#define VIDEO_MODE_H264_720P       1
+#if defined(CONFIG_ISO_TYPE_ADVANCED)
+struct idsp_cfg_file_info file_info[MAX_IMAGE_BINARY_NUM] = {
+    {"01_cc_reg.bin",				2304},
+    {"02_cc_3d_A.bin",				16384},
+    {"03_cc_3d_C.bin",				0},
+    {"04_cc_out.bin",				1024},
+    {"05_thresh_dark.bin",			768},
+    {"06_thresh_hot.bin",			768},
+    {"07_local_exposure_gain.bin",		512},
+    {"08_cmf_table.bin",			48},
+    {"09_chroma_scale_gain.bin",		256},
+    {"10_fir1_A.bin",				256},
+    {"11_fir2_A.bin",				256},
+    {"12_coring_A.bin",				256},
+    {"13_fir1_B.bin",				256},
+    {"14_fir2_B.bin",				256},
+    {"15_coring_B.bin",				256},
+    {"16_wide_chroma_mctf.bin",			528},
+    {"17_fir1_motion_detection.bin",		256},
+    {"18_fir1_motion_detection_map.bin",	256},
+    {"19_coring_motion_detection_map.bin",	256},
+    {"20_video_mctf.bin",			528},
+    {"21_md_fir1.bin",				256},
+    {"22_md_map_fir1.bin",			256},
+    {"23_md_map_coring.bin",			256},
+    {"24_cc_reg_combine.bin",			0},
+    {"25_cc_3d_combine.bin",			0},
+    {"26_thresh_dark_mo.bin",			0},
+    {"27_thresh_hot_mo.bin",			0},
+    {"28_cmf_table_mo.bin",			0},
+    {"29_fir1_mo.bin",				0},
+    {"30_fir2_mo.bin",				0},
+    {"31_coring_mo.bin",			0},
+};
+#else
+struct idsp_cfg_file_info file_info[MAX_IMAGE_BINARY_NUM] = {
+    {"01_cc_reg.bin",				2304},
+    {"02_cc_3d_A.bin",				16384},
+    {"03_cc_3d_C.bin",				0},
+    {"04_cc_out.bin",				1024},
+    {"05_thresh_dark.bin",			768},
+    {"06_thresh_hot.bin",			768},
+    {"07_local_exposure_gain.bin",		512},
+    {"08_cmf_table.bin",			48},
+    {"09_chroma_scale_gain.bin",		256},
+    {"10_fir1_A.bin",				256},
+    {"11_fir2_A.bin",				256},
+    {"12_coring_A.bin",				256},
+    {"13_fir1_B.bin",				0},
+    {"14_fir2_B.bin",				0},
+    {"15_coring_B.bin",				0},
+    {"16_wide_chroma_mctf.bin",			0},
+    {"17_fir1_motion_detection.bin",		256},
+    {"18_fir1_motion_detection_map.bin",	256},
+    {"19_coring_motion_detection_map.bin",	256},
+    {"20_video_mctf.bin",			528},
+    {"21_md_fir1.bin",				256},
+    {"22_md_map_fir1.bin",			256},
+    {"23_md_map_coring.bin",			256},
+    {"24_cc_reg_combine.bin",			0},
+    {"25_cc_3d_combine.bin",			0},
+    {"26_thresh_dark_mo.bin",			0},
+    {"27_thresh_hot_mo.bin",			0},
+    {"28_cmf_table_mo.bin",			0},
+    {"29_fir1_mo.bin",				0},
+    {"30_fir2_mo.bin",				0},
+    {"31_coring_mo.bin",			0},
+};
+#endif
+
+// in-memory update idsp config when in mode 4
+static int adc_util_update_idsp_cfg_mode4(uint8_t *idspCfg_buffer, uint8_t section_index, int section_size, int base)
+{
+    uint32_t adc_idsp_mode4_addr = 0;
+    int rval = -1;
+    do {
+        if (NULL == idspCfg_buffer) {
+            break;
+        }
+        adc_idsp_mode4_addr = (uint32_t)hdr_s + hdr_s->smart3a[section_index].offset + base*IDSP_CFG_BIN_SIZE;
+        memcpy((void *)adc_idsp_mode4_addr, (void *)idspCfg_buffer, section_size);
+        rval = 0;
+    } while (0);
+    return rval;
+}
+static int adc_util_read_idspcfg_file(const char* dir,  uint8_t *dest_idspCfg_buffer, int idsp_cfg_index, int resolution_mode)
+{
+    FILE *f_idspCfg = NULL;
+    int f = 0;
+    char file_name_tmp[128];
+    int rval = -1;
+    uint8_t* tmp_buffer_p = dest_idspCfg_buffer;
+    int base = 0;
+    // if 720p, load the 2nd half of 3A config bin. 1080p and 720p idsp cfgs are packed in one bin
+    if ( resolution_mode == VIDEO_MODE_H264_720P) {
+        base = 1;
+    }
+
+    do {
+        if (NULL == tmp_buffer_p) {
+            break;
+        }
+        for (f = 0; f < MAX_IMAGE_BINARY_NUM; f++) {
+            if (file_info[f].size == 0) {
+                continue;
+            }
+            sprintf(file_name_tmp, "%s/%s", dir, file_info[f].name);
+            f_idspCfg = fopen(file_name_tmp, "rb");
+            if (f_idspCfg == NULL) {
+                printf("Open %s failed\n", file_name_tmp);
+                rval = -EINVAL;
+                break;
+            }
+
+            int ret_size = fread(tmp_buffer_p, 1, file_info[f].size, f_idspCfg);
+            if (ret_size != file_info[f].size) {
+                printf("idspcfg dump bin size[%u] invalid, should be %u as specified\n", ret_size, file_info[f].size);
+                rval = -EINVAL;
+                break;
+            }
+            tmp_buffer_p += file_info[f].size;
+            fclose(f_idspCfg);
+        }
+        if (rval == -EINVAL) {
+            break;
+        }
+        rval= adc_util_update_idsp_cfg_mode4(dest_idspCfg_buffer, idsp_cfg_index, SIZE_IDSP_CFG_ADV_ISO, base);
+        if (rval < 0) {
+            printf("adc_util_update_idsp_cfg_mode4 idsp_params failed\n");
+        }
+
+        // read liso_cfg.bin, which contains paramters
+        sprintf(file_name_tmp, "%s/%s", dir, IDSP_LISO_DUMP_FILE);
+        f_idspCfg = fopen(file_name_tmp, "rb");
+        if (f_idspCfg == NULL) {
+            printf("Open %s failed\n", file_name_tmp);
+            rval = -EINVAL;
+            break;
+        }
+
+        // move tmp_buffer_p to point to the start of the buffer
+        tmp_buffer_p = dest_idspCfg_buffer;
+        int ret_size = fread(tmp_buffer_p, 1, SIZE_LISO_CFG_ADV_ISO, f_idspCfg);
+        if (ret_size != SIZE_LISO_CFG_ADV_ISO) {
+            printf("Low iso dump bin size[%u] invalid, should be %u as specified\n", ret_size, SIZE_LISO_CFG_ADV_ISO);
+            rval = -EINVAL;
+            break;
+        }
+        uint32_t adc_liso_cfg_addr = (uint32_t)hdr_s + hdr_s->smart3a[idsp_cfg_index].offset +  base*IDSP_CFG_BIN_SIZE + SIZE_IDSP_CFG_ADV_ISO;
+        memcpy((void *)adc_liso_cfg_addr, (void *)tmp_buffer_p, SIZE_LISO_CFG_ADV_ISO);
+    } while (0);
+
+    if (f_idspCfg != NULL) {
+        fclose(f_idspCfg);
+        f_idspCfg = NULL;
+    }
+
+    return rval;
+}
+
+int adc_util_write(int verbose, int skip3a)
+{
+    int rval = -1;
+    int fd_iav = -1;
+    int value;
+    int idsp_cfg_index = -1;
+    uint32_t addr = 0, size = 0;
+    uint32_t idsp_bin_size = 0;
+    uint8_t *bin_buffer = NULL;
+    FILE *f_updated_adc = NULL;
+    enum idsp_cfg_select_policy policy = IDSP_CFG_SELECT_ONLY_ONE;
+    struct iav_system_resource resource;
+    struct vindev_devinfo vsrc_info;
+
+    struct timeval time2 = {0, 0};
+    struct timeval time3 = {0, 0};
+    struct timeval time4 = {0, 0};
+    struct timeval time5 = {0, 0};
+    struct timeval time6 = {0, 0};
+    struct timeval time7 = {0, 0};
+    signed long long  time2_US = 0;
+    signed long long  time3_US = 0;
+    signed long long  time4_US = 0;
+    signed long long  time5_US = 0;
+    signed long long  time6_US = 0;
+    signed long long  time7_US = 0;
+
+    if (NULL == hdr_s) {
+        printf("adc_util not initialized!");
+        return -1;
+    }
+    do {
+        if (verbose) {
+            gettimeofday(&time2, NULL);
+        }
+
+        //step 2: find the mem address of the selected section among adc image
+        if (!skip3a) {
+            idsp_cfg_index = select_idsp_cfg(policy);
+            if (idsp_cfg_index < 0 || idsp_cfg_index >= hdr_s->smart3a_num) {
+                printf("Wrong idspcfg section via policy 0x%x, idspcfg index=%d, should in [0, %u)\n", policy, idsp_cfg_index, hdr_s->smart3a_num);
+                break;
+            }
+
+            addr = (uint32_t)hdr_s + hdr_s->smart3a[idsp_cfg_index].offset;
+            size = hdr_s->smart3a_size;
+
+            if (size <= IDSPCFG_BINARY_HEAD_SIZE || 0 == addr) {
+                printf("Invalid idspcfg section %d, addr=%u, size=%u!\n", idsp_cfg_index, addr, size);
+                break;
+            }
+
+            if (verbose) {
+                gettimeofday(&time3, NULL);
+            }
+
+            //step 3: dump 3a date to mem
+            if ((fd_iav = open("/dev/iav", O_RDWR, 0)) < 0) {
+                printf("open /dev/iav fail\n");
+                break;
+            }
+
+            bin_buffer = (uint8_t*)malloc(MAX_DUMP_BUFFER_SIZE);
+            if (!bin_buffer) {
+                printf("Can not malloc idspcfg buffer\n");
+                break;
+            }
+            memset(bin_buffer, 0, MAX_DUMP_BUFFER_SIZE);
+
+            memset(&resource, 0, sizeof(resource));
+            resource.encode_mode = DSP_CURRENT_MODE;
+            if (ioctl(fd_iav, IAV_IOC_GET_SYSTEM_RESOURCE, &resource) < 0) {
+                perror("IAV_IOC_GET_SYSTEM_RESOURCE\n");
+                break;
+            }
+            if (resource.encode_mode == DSP_ADVANCED_ISO_MODE) {
+                // query buffer size
+                struct iav_srcbuf_format  srcBufFormat;
+                srcBufFormat.buf_id = 0;
+                if (ioctl(fd_iav, IAV_IOC_GET_SOURCE_BUFFER_FORMAT, &srcBufFormat) < 0) {
+                    perror("IAV_IOC_GET_SOURCE_BUFFER_FORMAT\n");
+                }
+
+                if (srcBufFormat.size.width == 1280 && srcBufFormat.size.height == 720) {
+                    rval =adc_util_read_idspcfg_file(IDSP_LISO_DUMP_DIR, bin_buffer, idsp_cfg_index, VIDEO_MODE_H264_720P);
+                } else if (srcBufFormat.size.width == 1920 && srcBufFormat.size.height == 1080) {
+                    rval =adc_util_read_idspcfg_file(IDSP_LISO_DUMP_DIR, bin_buffer, idsp_cfg_index, VIDEO_MODE_H264_1080P);
+                } else {
+                    printf("Unknown resolution, should be 720p or 1080p\n");
+                }
+
+                if (rval < 0) {
+                    printf("adc_util_read_idspcfg_file  failed\n");
+                }
+            } else {
+                idsp_bin_size = idspcfg_dump_bin(fd_iav, bin_buffer);
+                if (size != idsp_bin_size) {
+                    printf("idspcfg dump bin size[%u] invalid, should be %u as saved in adcfw_header\n", idsp_bin_size, size);
+                    break;
+                }
+
+#if 0
+            FILE* f_idsp_cfg = NULL;
+            f_idsp_cfg = fopen("/tmp/sdcard/idsp_cfg.bin", "wb");
+            if (f_idsp_cfg == NULL) {
+                printf("Open /tmp/sdcard/idsp_cfg.bin failed\n");
+                rval = -EINVAL;
+                break;
+            }
+            rval = fwrite(bin_buffer, 1, idsp_bin_size, f_idsp_cfg);
+            fclose(f_idsp_cfg);
+#endif
+
+                //step 4: save 3a data to selected section of adc image
+                memcpy((void *)addr, (void *)bin_buffer, size);//TODO:  how to check success
+
+            }
+	     if (verbose) {
+                gettimeofday(&time4, NULL);
+            }
+
+            //step 5: dump and save shutter and gain params to selected section of adc image
+            read_awb_ae_config(&(hdr_s->smart3a[idsp_cfg_index]), PRELOAD_AWB_FILE, PRELOAD_AE_FILE);
+
+            vsrc_info.vsrc_id = 0;
+            if (ioctl(fd_iav, IAV_IOC_VIN_GET_DEVINFO, &vsrc_info) < 0) {
+                perror("IAV_IOC_VIN_GET_DEVINFO");
+                break;
+            }
+            if (vsrc_info.sensor_id == SENSOR_IMX322) {
+                value = get_reg_data(0x0202, fd_iav);
+                if (value >= 0) {
+                    hdr_s->smart3a[idsp_cfg_index].para0 = value;
+                }
+
+                value = get_reg_data(0x0203, fd_iav);
+                if (value >= 0) {
+                    hdr_s->smart3a[idsp_cfg_index].para1 = value;
+                }
+                value = get_reg_data(0x301E, fd_iav);
+                if (value >= 0) {
+                    hdr_s->smart3a[idsp_cfg_index].para2 = value;
+                }
+                printf("Read sensor IMX322 register: shutter0202=0x%04x, shutter0203=0x%04x, gain301E=0x%04x\n",
+                     hdr_s->smart3a[idsp_cfg_index].para0,
+                     hdr_s->smart3a[idsp_cfg_index].para1,
+                     hdr_s->smart3a[idsp_cfg_index].para2);
+            } else if (vsrc_info.sensor_id == SENSOR_OV4689) {
+                value = get_reg_data(0x3500, fd_iav);
+                if (value >= 0) {
+                    hdr_s->smart3a[idsp_cfg_index].para0 = value;
+                }
+
+                value = get_reg_data(0x3501, fd_iav);
+                if (value >= 0) {
+                    hdr_s->smart3a[idsp_cfg_index].para1 = value;
+                }
+                value = get_reg_data(0x3502, fd_iav);
+                if (value >= 0) {
+                    hdr_s->smart3a[idsp_cfg_index].para2 = value;
+                }
+                value = get_reg_data(0x3508, fd_iav);
+                if (value >= 0) {
+                    hdr_s->smart3a[idsp_cfg_index].para3 = value;
+                }
+                value = get_reg_data(0x3509, fd_iav);
+                if (value >= 0) {
+                    hdr_s->smart3a[idsp_cfg_index].para4 = value;
+                }
+                printf("Read sensor OV4689 register: shutter3500=0x%04x, shutter3501=0x%04x, shutter3502=0x%04x," \
+                    "  gain3508=0x%04x, gain3509=0x%04x\n",
+                    hdr_s->smart3a[idsp_cfg_index].para0,
+                    hdr_s->smart3a[idsp_cfg_index].para1,
+                    hdr_s->smart3a[idsp_cfg_index].para2,
+                    hdr_s->smart3a[idsp_cfg_index].para3,
+                    hdr_s->smart3a[idsp_cfg_index].para4);
+            } else {
+                printf("This sensor type %d is not supported yet.\n", vsrc_info.sensor_id);
+                break;
+            }
+
+            printf("Read AAA param: r_gain=%d, b_gain=%d, dgain=%d, shutter=%d, agc=%d\n",
+                 hdr_s->smart3a[idsp_cfg_index].r_gain,
+                 hdr_s->smart3a[idsp_cfg_index].b_gain,
+                 hdr_s->smart3a[idsp_cfg_index].d_gain,
+                 hdr_s->smart3a[idsp_cfg_index].shutter,
+                 hdr_s->smart3a[idsp_cfg_index].agc);
+
+            if (verbose) {
+                gettimeofday(&time5, NULL);
+            }
+        }
+
+        //step 6: save the whole updated adc image to file
+        f_updated_adc = fopen(UPDATED_ADC_IMAGE_PATH, "wb");
+        if (f_updated_adc == NULL) {
+            printf("Open /tmp/updated_adc.bin failed\n");
+            rval = -EINVAL;
+            break;
+        }
+
+        rval = fwrite(p_adc_aligned_mem_s, 1, adc_img_aligned_len_s, f_updated_adc);
+        if (rval != adc_img_aligned_len_s) {
+            printf("/tmp/updated_adc.bin size [%d] is wrong, should be %u\n", rval, adc_img_aligned_len_s);
+            break;
+        }
+
+        fclose(f_updated_adc);
+        f_updated_adc = NULL;
+
+        if (verbose) {
+            gettimeofday(&time6, NULL);
+        }
+
+        //step 7: update adc partition with adc image file
+        rval = update_adc_partition(verbose);
+        if (rval != 0) {
+            printf("update_adc_partition fail\n");
+            break;
+        }
+
+        if (verbose) {
+            gettimeofday(&time7, NULL);
+            time2_US = ((signed long long)(time2.tv_sec) * 1000000 + (signed long long)(time2.tv_usec));
+            time3_US = ((signed long long)(time3.tv_sec) * 1000000 + (signed long long)(time3.tv_usec));
+            time4_US = ((signed long long)(time4.tv_sec) * 1000000 + (signed long long)(time4.tv_usec));
+            time5_US = ((signed long long)(time5.tv_sec) * 1000000 + (signed long long)(time5.tv_usec));
+            time6_US = ((signed long long)(time6.tv_sec) * 1000000 + (signed long long)(time6.tv_usec));
+            time7_US = ((signed long long)(time7.tv_sec) * 1000000 + (signed long long)(time7.tv_usec));
+            printf("[TIME]: <Find selected section of ADC image> cost %lld US!\n", time3_US-time2_US);
+            printf("[TIME]: <Dump 3A date to mem> cost %lld US!\n", time4_US-time3_US);
+            printf("[TIME]: <Dump&save shutter and gain params to selected section of ADC image> cost %lld US!\n", time5_US-time4_US);
+            printf("[TIME]: <Save the updated ADC image to file> cost %lld US!\n", time6_US-time5_US);
+            printf("[TIME]: <Update ADC partition from file> cost %lld US!\n", time7_US-time6_US);
+        }
+        rval = 0;
+    } while (0);
+
+    if (bin_buffer != NULL) {
+        free(bin_buffer);
+        bin_buffer = NULL;
+    }
+
+    if (f_updated_adc) {
+        fclose(f_updated_adc);
+        f_updated_adc = NULL;
+    }
+
+    if (fd_iav > 0) {
+        close(fd_iav);
+        fd_iav = -1;
+    }
+    return rval;
+}
diff --git a/fastboot_smart3a/adc_util.h b/fastboot_smart3a/adc_util.h
new file mode 100644
index 0000000..b2501d1
--- /dev/null
+++ b/fastboot_smart3a/adc_util.h
@@ -0,0 +1,61 @@
+/**
+ * app/ipcam/fastboot_smart3a/adc_util.h
+ *
+ * Author: Caizhang Lin <czlin@ambarella.com>
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ( "Software" ) are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef   _ADC_UTIL_H
+#define   _ADC_UTIL_H
+
+#include "adc.h"
+
+enum idsp_cfg_select_policy {
+    IDSP_CFG_SELECT_ONLY_ONE = 0,
+    IDSP_CFG_SELECT_VIA_UTC_HOUR,
+    IDSP_CFG_SELECT_VIA_ENV_BRIGHTNESS,
+};
+
+/* function: Load adc partition to memory,
+**                must be called before any adc_util_read
+**               or adc_util_write
+*/
+int  adc_util_init(int verbose);
+
+/* function: clean up memoy, must be called when
+**              we finish adc_util_read/write
+**
+*/
+void  adc_util_finish();
+
+int save_content_file(char *filename, char *content);
+int adc_util_get_amboot_params(struct params_info* params);
+int adc_util_set_amboot_params(struct params_info* params);
+
+int adc_util_read_3a_params(int verbose);
+int adc_util_write(int verbose, int skip3a);
+
+#endif
diff --git a/fastboot_smart3a/make.inc b/fastboot_smart3a/make.inc
index db68b93..f1330d0 100644
--- a/fastboot_smart3a/make.inc
+++ b/fastboot_smart3a/make.inc
@@ -1,27 +1,78 @@
 ##
 ## app/ipcam/fastboot_smart3a/make.inc
 ##
-## History:
-##    2015/01/21 - [Roy Su] Created file
+## Author: Caizhang Lin <czlin@ambarella.com>
 ##
-## Copyright (C) 2014-2016, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
-ifeq ($(BUILD_AMBARELLA_APP_FASTBOOT_SMART3A), y)
-
+ifeq ($(BUILD_AMBARELLA_APP_FASTBOOT_SMART3A), n)
 LOCAL_PATH	:= $(call my-dir)
+##############################
+# adc_util.so
+###
+include $(CLEAR_VARS)
+LOCAL_TARGET	:= libadc_io.so
+LOCAL_SRCS	:= $(LOCAL_PATH)/adc_io.c \
+		$(LOCAL_PATH)/upgrade_part_adc.c \
+		$(LOCAL_PATH)/adc_util.c
 
-##
+LOCAL_CFLAGS	:= -I$(LOCAL_PATH) \
+		-I$(AMB_TOPDIR)/amboot/include \
+		-I$(AMB_TOPDIR)/include/arch_$(AMBARELLA_ARCH) \
+		-I$(AMB_TOPDIR)/app/utility/upgrade_partition
+
+LOCAL_LDFLAG 	:= -O3 -Wall
+
+include $(BUILD_APP)
+
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(FAKEROOT_DIR)/usr/lib
+	@cp -dpRf $< $(FAKEROOT_DIR)/usr/lib
+	@echo "Build $@ Done."
+
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+
+########################################################
+# smart3a_adc tool
+###
 include $(CLEAR_VARS)
 
 LOCAL_TARGET	:= smart3a_adc
 LOCAL_SRCS	:= $(LOCAL_PATH)/smart3a_adc.c
+
+LOCAL_CFLAGS	:= -I$(LOCAL_PATH) \
+		-I$(AMB_TOPDIR)/amboot/include \
+		-I$(AMB_TOPDIR)/include/arch_$(AMBARELLA_ARCH) \
+		-I$(AMB_TOPDIR)/app/utility/upgrade_partition
+
 LOCAL_LDFLAG 	:= -O3 -Wall
+LOCAL_LIBS	:= libadc_io.so
 
 include $(BUILD_APP)
 
diff --git a/fastboot_smart3a/smart3a_adc.c b/fastboot_smart3a/smart3a_adc.c
index 63a7356..36ccb92 100644
--- a/fastboot_smart3a/smart3a_adc.c
+++ b/fastboot_smart3a/smart3a_adc.c
@@ -1,843 +1,149 @@
 /**
  * app/ipcam/fastboot_smart3a/smart3a_adc.c
  *
- * Author: Roy Su <qiangsu@ambarella.com>
+ * Author: Caizhang Lin <czlin@ambarella.com>
  *
- * Copyright (C) 2014-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ( "Software" ) are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include <unistd.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <stdlib.h>
+
 #include <stdio.h>
-#include <string.h>
-#include <libgen.h>
-#include <linux/rtc.h>
-#include <sys/time.h>
-#include <sys/ioctl.h>
-#include <time.h>
 #include <getopt.h>
-#include "config.h"
-#include "../../utility/upgrade_partition/upgrade_partition.h"
-#include "../../../amboot/include/adc.h"
-#include "../../../include/arch_s2l/ambas_imgproc_arch.h"
-#include "../../../include/arch_s2l/ambas_imgproc_ioctl_arch.h"
-#include "iav_common.h"
-#include "iav_vin_ioctl.h"
-
-#define PRELOAD_AWB_FILE	"/tmp/awb"
-#define PRELOAD_AE_FILE	"/tmp/ae"
-#define PRELOAD_VIDEOPARAM_FILE	"/tmp/video_param.conf"
+#include <ctype.h>
+#include "adc_io.h"
 
 #define NO_ARG		0
 #define HAS_ARG		1
 
 struct hint_s {
-	const char *arg;
-	const char *str;
-};
-
-enum idsp_cfg_select_policy {
-	IDSP_CFG_SELECT_ONLY_ONE = 0,
-	IDSP_CFG_SELECT_VIA_UTC_HOUR,
-	IDSP_CFG_SELECT_VIA_ENV_BRIGHTNESS,
+    const char *arg;
+    const char *str;
 };
 
-#define IDSPCFG_BINARY_HEAD_SIZE	(64)
-#define UPDATED_ADC_IMAGE_PATH	"/tmp/updated_adc.bin"
-
 static int select_read_3a = 1;
+static int dump_from_mem = 0;
 static int verbose = 0;
 
-static const char *short_options = "rwv";
+static const char *short_options = "rwvm";
 
 static struct option long_options[] = {
-	{"read",	NO_ARG, 0, 'r'},
-	{"write",	NO_ARG, 0, 'w'},
-	{"verbose", NO_ARG, 0, 'v'},
-
-	{0, 0, 0, 0}
+    {"read",    NO_ARG,        0,    'r'},
+    {"write",    NO_ARG,        0,    'w'},
+    {"verbose",    NO_ARG,        0,    'v'},
+    {"memory",    NO_ARG,        0,    'm'},
+    {0, 0, 0, 0}
 };
 
 static const struct hint_s hint[] = {
-	{"", "Read out the 3A config from ADC (At the begin of Linux)"},
-	{"", "Write 3A config into ADC which from 3A process (In the end of Linux)"},
-	{"",	"print debug info"},
+    {"", "Read out the 3A config from ADC (At the begin of Linux)"},
+    {"", "Write 3A config into ADC which from 3A process (In the end of Linux)"},
+    {"", "print debug info"},
+    {"", "copy parmas info from memory, only when fastboot has copied data to specific memory"},
 };
 
 static void usage(void)
 {
-	u32 i;
-	char *itself = "smart_3a";
-	printf("This program used to read/write 3A config from/into ADC partition\n");
-	printf("\n");
-	for (i = 0; i < sizeof(long_options) / sizeof(long_options[0]) - 1; i++) {
-		if (isalpha(long_options[i].val))
-			printf("-%c ", long_options[i].val);
-		else
-			printf("   ");
-		printf("--%s", long_options[i].name);
-		if (hint[i].arg[0] != 0)
-			printf(" [%s]", hint[i].arg);
-		printf("\t%s\n", hint[i].str);
-	}
-
-	printf("Example:\n\tRead # %s -r\n", itself);
-	printf("\tWrite # %s -w -v\n", itself);
+    unsigned int i;
+    char *itself = "smart_3a";
+
+    printf("This program used to read/write 3A config from/into ADC partition\n");
+    printf("\n");
+    for (i = 0; i < sizeof(long_options) / sizeof(long_options[0]) - 1; i++) {
+        if (isalpha(long_options[i].val))
+            printf("-%c ", long_options[i].val);
+        else
+            printf("   ");
+        printf("--%s", long_options[i].name);
+        if (hint[i].arg[0] != 0)
+            printf(" [%s]", hint[i].arg);
+        printf("\t%s\n", hint[i].str);
+    }
+
+    printf("Example:\n\tRead # %s -r\n", itself);
+    printf("\tWrite # %s -w -v\n", itself);
 }
 
 static int init_param(int argc, char **argv)
 {
-	int ch;
-	int option_index = 0;
-
-	opterr = 0;
-	while ((ch = getopt_long(argc, argv, short_options, long_options, &option_index)) != -1) {
-		switch (ch) {
-		case 'r':
-			select_read_3a = 1;
-			break;
-		case 'w':
-			select_read_3a = 0;
-			break;
-		case 'v':
-			verbose = 1;
-			break;
-		default:
-			printf("unknown option found: %c\n", ch);
-			return -1;
-		}
-	}
-
-	return 0;
-}
-
-uint32_t idspcfg_dump_bin(int fd_iav, uint8_t *bin_buffer)
-{
-	idsp_config_info_t	dump_idsp_info;
-	int rval = -1;
-
-	dump_idsp_info.id_section = 0;
-	dump_idsp_info.addr = bin_buffer;
-
-	rval = ioctl(fd_iav, IAV_IOC_IMG_DUMP_IDSP_SEC, &dump_idsp_info);
-	if (rval < 0) {
-		perror("IAV_IOC_IMG_DUMP_IDSP_SEC");
-		return 0;
-	}
-	printf("idspcfg size=%u\n", dump_idsp_info.addr_long);
-	return dump_idsp_info.addr_long;
-}
-
-static void rtc_read_tm(struct tm *ptm, int fd)
-{
-	memset(ptm, 0, sizeof(*ptm));
-	ioctl(fd, RTC_RD_TIME, ptm);
-	ptm->tm_isdst = -1; /* "not known" */
-}
-
-static int select_idsp_cfg_via_rtc_hour()
-{
-	struct tm tm_time;
-	time_t timer;
-	struct tm s_tblock = {0};
-	struct tm *tblock = NULL;
-	int fd = 0;
-	char *oldtz = NULL;
-
-	//get RTC time
-	fd = open("/dev/rtc", O_RDONLY);
-	if (fd < 0) {
-		fd = open("/dev/rtc0", O_RDONLY);
-		if (fd < 0) {
-			fd = open("/dev/misc/rtc", O_RDONLY);
-			if (fd < 0) {
-				printf("Open RTC failed\n");
-				return -1;
-			}
-		}
-	}
-	rtc_read_tm(&tm_time, fd);
-	close(fd);
-
-	//save old local time zone
-	oldtz = getenv("TZ");
-
-	//set local time zone to UTC
-	putenv((char*)"TZ=UTC0");
-	tzset();
-
-	//get local time(now is UTC)
-	timer = mktime(&tm_time);
-
-	//parse local time(now is UTC)
-	localtime_r(&timer, &s_tblock);
-
-	//restore old local time zone
-	unsetenv("TZ");
-	if (oldtz) {
-		putenv(oldtz - 3);
-	}
-	tzset();
-
-	tblock = &s_tblock;
-	if (tblock->tm_hour < 0 || tblock->tm_hour >= 24) {
-		printf("RTC hour is invalid\n");
-		return -1;
-	} else {
-		return tblock->tm_hour;
-	}
-}
-
-static int select_idsp_cfg(enum idsp_cfg_select_policy policy)
-{
-	switch (policy) {
-	case IDSP_CFG_SELECT_ONLY_ONE:
-		return 0;
-		break;
-
-	case IDSP_CFG_SELECT_VIA_UTC_HOUR:
-		return select_idsp_cfg_via_rtc_hour();
-		break;
-
-	case IDSP_CFG_SELECT_VIA_ENV_BRIGHTNESS:
-		printf("Policy BRIGHTNESS not supported yet\n");
-		return -1;
-		break;
-
-	default:
-		printf("Invalid policy %d\n", policy);
-		return -1;
-		break;
-	}
-}
-
-static int find_mtd_device_path(const char *dev_name, char *dev_info_buf,
-	int dev_info_bufsize)
-{
-	FILE   *stream = 0;
-	int device_index = -1;
-
-	if (!dev_name || !dev_info_buf || 0 == dev_info_bufsize) {
-		printf("Find mtd device path, NULL input\n");
-		return -1;
-	}
-	memset(dev_info_buf, 0, dev_info_bufsize);
-
-	//get mtd device index and path
-	sprintf(dev_info_buf, "cat /proc/mtd | grep %s | cut -d':' -f1 | cut -d'd' -f2", dev_name);
-	stream = popen(dev_info_buf , "r" );
-	if (NULL == stream) {
-		printf("Open /proc/mtd  %s  failed.\n", dev_name);
-		return -1;
-	}
-	fscanf(stream,"%d", &device_index);
-	pclose(stream);
-
-	if (device_index < 0) {
-		printf("Not found %s partition on /proc/mtd\n", dev_name);
-		return -1;
-	}
-	memset(dev_info_buf, 0, dev_info_bufsize);
-	sprintf(dev_info_buf, "/dev/mtd%d", device_index);
-
-	return 0;
-}
-
-static int get_reg_data(const uint16_t reg_addr, int fd_iav)
-{
-	struct vindev_reg reg;
-	reg.vsrc_id = 0;
-	reg.addr = reg_addr;
-	int rval = ioctl(fd_iav, IAV_IOC_VIN_GET_REG, &reg);
-	if (rval < 0) {
-	    printf("addr 0x%04x, read fail\n", reg_addr);
-	    return -1;
-	}
-
-	return reg.data;
-}
-
-static int load_adc_to_mem (uint32_t *adc_img_len,
-	uint32_t *adc_img_aligned_len, void **pp_adc_aligned_mem)
-{
-	char dev_info_buf[128];
-	int ret = 0, count = 0;
-	int ptb_fd = 0, ptb_offset;
-	uint8_t *ptb_buf = NULL;
-	struct mtd_info_user ptb_meminfo;
-	loff_t ptb_bad_offset;
-	flpart_table_t *table;
-	unsigned long long blockstart = 1;
-	int fd = 0, bs, badblock = 0;
-	struct mtd_info_user meminfo;
-	unsigned long ofs;
-	void *p_adc_mem_cur = NULL;
-
-	if (!adc_img_len || !adc_img_aligned_len || !pp_adc_aligned_mem) {
-		printf("Load ADC to mem, NULL input\n");
-		ret = -1;
-		goto closeall;
-	}
-
-	ret = find_mtd_device_path("ptb", dev_info_buf, sizeof(dev_info_buf));
-	if (ret < 0) {
-		printf("Find ptb partition failed\n");
-		ret = -1;
-		goto closeall;
-	}
-
-	/* Open the PTB device */
-	if ((ptb_fd = open(dev_info_buf, O_RDONLY)) == -1) {
-		perror("open PTB");
-		ret = -1;
-		goto closeall;
-	}
-
-	/* Fill in MTD device capability structure */
-	if ((ret = ioctl(ptb_fd, MEMGETINFO, &ptb_meminfo)) != 0) {
-		perror("PTB MEMGETINFO");
-		ret = -1;
-		goto closeall;
-	}
-
-	for (ptb_offset = 0; ptb_offset < ptb_meminfo.size; ptb_offset += ptb_meminfo.erasesize) {
-		ptb_bad_offset = ptb_offset;
-		if ((ret = ioctl(ptb_fd, MEMGETBADBLOCK, &ptb_bad_offset)) < 0) {
-			perror("ioctl(MEMGETBADBLOCK)");
-			goto closeall;
-		}
-
-		if (ret == 0) {
-			break;
-		}
-	}
-	if (ptb_offset >= ptb_meminfo.size) {
-		printf("Can not find good block in PTB.\n");
-		ret = -1;
-		goto closeall;
-	}
-
-	ptb_buf = malloc(ptb_meminfo.erasesize);
-	memset(ptb_buf, 0, ptb_meminfo.erasesize);
-
-	/* Read partition table.
-	* Note: we need to read and save the entire block data, because the
-	* entire block will be erased when write partition table back to flash.
-	* BTW, flpart_meta_t is located in the same block as flpart_table_t
-	*/
-	count = ptb_meminfo.erasesize;
-	if (pread(ptb_fd, ptb_buf, count, ptb_offset) != count) {
-		perror("pread PTB");
-		ret = -1;
-		goto closeall;
-	}
-
-	table = PTB_TABLE(ptb_buf);
-	*adc_img_len = table->part[PART_ADC].img_len;
-
-	ret = find_mtd_device_path("adc", dev_info_buf, sizeof(dev_info_buf));
-	if (ret < 0) {
-		printf("Find ADC partition failed\n");
-		ret = -1;
-		goto closeall;
-	}
-
-	/* Open ADC device */
-	if ((fd = open(dev_info_buf, O_RDONLY)) == -1) {
-		perror("open mtd");
-		ret = -1;
-		goto closeall;
-	}
-
-	/* Fill in MTD device capability structure */
-	if (ioctl(fd, MEMGETINFO, &meminfo) != 0) {
-		perror("MEMGETINFO");
-		ret = -1;
-		goto closeall;
-	}
-
-	bs = meminfo.writesize;
-	*adc_img_aligned_len = ((*adc_img_len)+(bs-1))&(~(bs-1));
-
-	if (verbose) {
-		printf("ADC img addr=%u, img len=%u, img aligned_len=%u\n",
-			table->part[PART_ADC].mem_addr, *adc_img_len, *adc_img_aligned_len);
-	}
-
-	//will be freed when process return
-	*pp_adc_aligned_mem = (void*)malloc(*adc_img_aligned_len);
-	if (!(*pp_adc_aligned_mem)) {
-		printf("Can not malloc memory for load ADC partiton!\n");
-		ret = -1;
-		goto closeall;
-	}
-	p_adc_mem_cur = *pp_adc_aligned_mem;
-
-	if (verbose) {
-		/* Print informative message */
-		printf("Total size %u, Block size %u, page size %u, OOB size %u\n",
-			meminfo.size,meminfo.erasesize, meminfo.writesize, meminfo.oobsize);
-		printf("Loading data starting at 0x%08x and ending at 0x%08x\n",
-			table->part[PART_ADC].mem_addr,
-			table->part[PART_ADC].mem_addr+(*adc_img_aligned_len));
-	}
-
-	/* Load the flash contents */
-	for (ofs = 0; ofs < *adc_img_aligned_len ; ofs+=bs) {
-		// new eraseblock , check for bad block
-		if (blockstart != (ofs & (~meminfo.erasesize + 1))) {
-			blockstart = ofs & (~meminfo.erasesize + 1);
-			if ((badblock = ioctl(fd, MEMGETBADBLOCK, &blockstart)) < 0) {
-				perror("ioctl(MEMGETBADBLOCK)");
-				ret = -1;
-				goto closeall;
-			}
-		}
-
-		if (badblock) {
-				//memset (p_adc_mem_cur, 0xff, bs);
-				continue;
-		} else {
-			/* Read page data and exit on failure */
-			if (pread(fd, p_adc_mem_cur, bs, ofs) != bs) {
-				perror("pread");
-				ret = -1;
-				goto closeall;
-			}
-		}
-		p_adc_mem_cur+=bs;
-	}
-
-	/* Exit happy */
-	ret = 0;
-
-	closeall:
-	if (ptb_buf) {
-		free(ptb_buf);
-		ptb_buf  = NULL;
-	}
-
-	if (ptb_fd) {
-		close(ptb_fd);
-		ptb_fd = 0;
-	}
-	if (fd) {
-		close(fd);
-		fd = 0;
-	}
-
-	return ret;
-}
-
-static int update_adc_partition()
-{
-	char cmd[256];
-	FILE   *stream = 0;
-	int device_index = -1;
-
-	memset(cmd, 0, sizeof(cmd));
-
-	stream = popen( "cat /proc/mtd | grep adc | cut -d':' -f1 | cut -d'd' -f2", "r" );
-	if (NULL == stream) {
-		printf("Open /proc/mtd failed\n");
-		return -1;
-	}
-	fscanf(stream, "%d", &device_index);
-	pclose(stream);
-	if (device_index < 0) {
-		printf("Not found ADC partition on /proc/mtd\n");
-		return -1;
-	}
-	//erase nand flash before re-write
-	sprintf(cmd, "flash_eraseall /dev/mtd%d", device_index);
-
-	if (verbose) {
-		printf("CMD: %s\n", cmd);
-	}
-	system(cmd);
-
-	sprintf(cmd, "upgrade_partition /dev/mtd%d %s", device_index, UPDATED_ADC_IMAGE_PATH);
-
-	if (verbose) {
-		printf("CMD: %s\n", cmd);
-	}
-	system(cmd);
-
-	return 0;
-}
-
-static int save_content_file(char *filename, char *content)
-{
-	FILE *fp;
-	int ret = -1;
-
-	fp = fopen(filename, "wb");
-	if (fp == NULL) {
-		perror("fopen");
-		return ret;
-	}
-
-	ret = fwrite(content, strlen(content), 1, fp);
-	fclose(fp);
-	fp = NULL;
-
-	return ret;
+    int ch;
+    int option_index = 0;
+
+    while ((ch = getopt_long(argc, argv, short_options, long_options, &option_index)) != -1) {
+        switch (ch) {
+            case 'r':
+                select_read_3a = 1;
+                break;
+            case 'w':
+                select_read_3a = 0;
+                break;
+            case 'v':
+                verbose = 1;
+                break;
+            case 'm':
+                dump_from_mem = 1;
+                break;
+            default:
+                printf("unknown option found: %c\n", ch);
+                return -1;
+        }
+    }
+
+    return 0;
 }
-
-static void read_awb_ae_config(struct smart3a_file_info *info)
-{
-	FILE *fp_ae;
-	FILE *fp_awb;
-	char content[64];
-	char *content_c = NULL;
-
-	fp_awb = fopen(PRELOAD_AWB_FILE, "r");
-	if (fp_awb != NULL) {
-		fseek(fp_awb, 0, SEEK_SET);
-		memset(content, 0, sizeof(content));
-		fread(content, sizeof(content) + 1, 1, fp_awb);
-		fclose(fp_awb);
-		fp_awb = NULL;
-
-		content_c = strtok(content, ",");
-		if (content_c) {
-			info->r_gain = atoi(content_c);
-		}
-		content_c = strtok(NULL, ",");
-		if (content_c) {
-			info->b_gain = atoi(content_c);
-		}
-	}
-
-	fp_ae = fopen(PRELOAD_AE_FILE, "r");
-	if (fp_ae != NULL) {
-		fseek(fp_ae, 0, SEEK_SET);
-		memset(content, 0, sizeof(content));
-		fread(content, sizeof(content) + 1, 1, fp_ae);
-		fclose(fp_ae);
-		fp_ae = NULL;
-
-		content_c = strtok(content, ",");
-		if (content_c) {
-			info->d_gain= atoi(content_c);
-		}
-		content_c = strtok(NULL, ",");
-		if (content_c) {
-			info->shutter = atoi(content_c);
-		}
-		content_c = strtok(NULL, ",");
-		if (content_c) {
-			info->agc = atoi(content_c);
-		}
-	}
-
-}
-
 /* ==========================================================================*/
 int main(int argc, char **argv)
 {
-	int rval = 0;
-	struct adcfw_header *hdr;
-	uint32_t addr = 0, size = 0;
-	enum idsp_cfg_select_policy policy = IDSP_CFG_SELECT_ONLY_ONE;
-	int idsp_cfg_index = -1;
-	int fd_iav = 0;
-	uint8_t *bin_buffer = NULL;
-	uint32_t idsp_bin_size = 0;
-	FILE *f_updated_adc = NULL;
-	uint32_t adc_img_len = 0;	/**< Lengh of image in the partition */
-	uint32_t adc_img_aligned_len = 0;//aligned to page size of adc parttiton
-	void *p_adc_aligned_mem = NULL;//aligned to page size of adc parttiton
-
-	char aaa_content[32];
-
-	struct timeval time1 = { 0, 0 };
-	struct timeval time2 = { 0, 0 };
-	struct timeval time3 = { 0, 0 };
-	struct timeval time4 = { 0, 0 };
-	struct timeval time5 = { 0, 0 };
-	struct timeval time6 = { 0, 0 };
-	struct timeval time7 = { 0, 0 };
-	struct timeval time8 = { 0, 0 };
-	signed long long  time1_US = 0;
-	signed long long  time2_US = 0;
-	signed long long  time3_US = 0;
-	signed long long  time4_US = 0;
-	signed long long  time5_US = 0;
-	signed long long  time6_US = 0;
-	signed long long  time7_US = 0;
-	signed long long  time8_US = 0;
-
-	if (argc < 2) {
-		usage();
-		return -1;
-	}
-	if (init_param(argc, argv) < 0) {
-		usage();
-		return -1;
-	}
-
-	if (verbose) {
-		gettimeofday(&time1, NULL);
-	}
-
-	//step 1: load whole adc partition to mem
-	rval = load_adc_to_mem (&adc_img_len, &adc_img_aligned_len, &p_adc_aligned_mem);
-	if (rval < 0) {
-		printf("Load ADC to memory failed\n");
-		goto main_exit;
-	}
-
-	if (verbose) {
-		gettimeofday(&time2, NULL);
-	}
-
-	//step 2: find the mem address of the selected section among adc image
-	hdr = (struct adcfw_header *)p_adc_aligned_mem;
-	if (hdr->magic != ADCFW_IMG_MAGIC || hdr->fw_size != adc_img_len) {
-		printf("Invalid ADC partition, magic=%u(should be %u), fw_size=%u(should be %u)\n",
-		hdr->magic, ADCFW_IMG_MAGIC, hdr->fw_size, adc_img_len);
-		goto main_exit;
-	}
-	idsp_cfg_index = select_idsp_cfg(policy);
-	if (idsp_cfg_index < 0 || idsp_cfg_index >= hdr->smart3a_num) {
-		printf("Wrong idspcfg section via policy 0x%x, idspcfg index=%d, should in [0, %u)\n",
-		policy, idsp_cfg_index, hdr->smart3a_num);
-		goto main_exit;
-	}
-	addr = (uint32_t)hdr + hdr->smart3a[idsp_cfg_index].offset;
-	size = hdr->smart3a_size;
-
-	if (size <= IDSPCFG_BINARY_HEAD_SIZE || 0 == addr) {
-		printf("Invalid idspcfg section %d, addr=%u, size=%u!\n", idsp_cfg_index, addr, size);
-		goto main_exit;
-	}
-
-	if (select_read_3a) {
-		printf("ADC 3A info: r_gain=%d, b_gain=%d. d_gain=%d, shutter=%d, agc=%d.\n",
-			hdr->smart3a[idsp_cfg_index].r_gain, hdr->smart3a[idsp_cfg_index].b_gain,
-			hdr->smart3a[idsp_cfg_index].d_gain, hdr->smart3a[idsp_cfg_index].shutter,
-			hdr->smart3a[idsp_cfg_index].agc);
-
-		memset(aaa_content, 0, sizeof(aaa_content));
-		snprintf(aaa_content, sizeof(aaa_content), "%d,%d\n",
-			hdr->smart3a[idsp_cfg_index].r_gain,
-			hdr->smart3a[idsp_cfg_index].b_gain);
-		save_content_file(PRELOAD_AWB_FILE, aaa_content);
-
-		memset(aaa_content, 0, sizeof(aaa_content));
-		snprintf(aaa_content, sizeof(aaa_content), "%d,%d,%d\n",
-			hdr->smart3a[idsp_cfg_index].d_gain,
-			hdr->smart3a[idsp_cfg_index].shutter,
-			hdr->smart3a[idsp_cfg_index].agc);
-		save_content_file(PRELOAD_AE_FILE, aaa_content);
-
-              do{
-                  FILE *fp = fopen(PRELOAD_VIDEOPARAM_FILE, "wb");
-                  if (fp) {
-                      fprintf(fp,"enable_video_param=%d\n", hdr->video_param.enable_video_param);
-                      fprintf(fp,"mode=%d\n", hdr->video_param.video_mode);
-                      fprintf(fp,"bitrate_quality=%d\n",hdr->video_param.bitrate_quality);
-                      fprintf(fp,"enable_smartavc=%d\n",hdr->video_param.res);
-                      fclose(fp);
-                  }
-              }while(0);
-
-		goto main_exit;
-	}
-
-	if (verbose) {
-		gettimeofday(&time3, NULL);
-	}
-
-	//step 3: dump 3a date to mem
-	if ((fd_iav = open("/dev/iav", O_RDWR, 0)) < 0) {
-		perror("open /dev/iav");
-		goto main_exit;
-	}
-
-	bin_buffer = (uint8_t*)malloc(MAX_DUMP_BUFFER_SIZE);
-	if (bin_buffer == NULL) {
-		printf("Can not malloc idspcfg buffer\n");
-		goto main_exit;
-	}
-
-	memset(bin_buffer, 0, MAX_DUMP_BUFFER_SIZE);
-	idsp_bin_size = idspcfg_dump_bin(fd_iav, bin_buffer);
-	if (size != idsp_bin_size) {
-		printf("idspcfg dump bin size[%u] invalid, should be %u as saved in adcfw_header\n",
-			idsp_bin_size, size);
-		goto main_exit;
-	}
-
-	if (verbose) {
-		gettimeofday(&time4, NULL);
-	}
-
-	//step 4: save 3a data to selected section of adc image
-	memcpy((void *)addr, (void *)bin_buffer, size);//TODO:  how to check success
-	//printf("Update idsp cfg section %d done!\n", idsp_cfg_index);
-
-	if (verbose) {
-		gettimeofday(&time5, NULL);
-	}
-
-	//step 5: dump and save shutter and gain params to selected section of adc image
-	read_awb_ae_config(&(hdr->smart3a[idsp_cfg_index]));
-#if defined(CONFIG_BOARD_VERSION_S2LMELEKTRA_OV4689_S2L22M) || defined (CONFIG_BOARD_VERSION_S2LMELEKTRA_OV4689_S2L55M)
-	int value = get_reg_data(0x3500, fd_iav);
-	if (value >= 0) {
-	    hdr->smart3a[idsp_cfg_index].para0 = value;
-	}
-	value = get_reg_data(0x3501, fd_iav);
-	if (value >= 0) {
-	    hdr->smart3a[idsp_cfg_index].para1 = value;
-	}
-	value = get_reg_data(0x3502, fd_iav);
-	if (value >= 0) {
-	    hdr->smart3a[idsp_cfg_index].para2 = value;
-	}
-	value = get_reg_data(0x3508, fd_iav);
-	if (value >= 0) {
-	    hdr->smart3a[idsp_cfg_index].para3 = value;
-	}
-	value = get_reg_data(0x3509, fd_iav);
-	if (value >= 0) {
-	    hdr->smart3a[idsp_cfg_index].para4 = value;
-	}
-	printf("Read sensor OV4689 register: shutter3500=0x%04x, shutter3501=0x%04x, shutter3502=0x%04x," \
-	    "  gain3508=0x%04x, gain3509=0x%04x\n",
-	    hdr->smart3a[idsp_cfg_index].para0,
-	    hdr->smart3a[idsp_cfg_index].para1,
-	    hdr->smart3a[idsp_cfg_index].para2,
-	    hdr->smart3a[idsp_cfg_index].para3,
-	    hdr->smart3a[idsp_cfg_index].para4);
-#elif defined (CONFIG_BOARD_VERSION_S2LMELEKTRA_IMX322_S2L22M) || defined (CONFIG_BOARD_VERSION_S2LMELEKTRA_IMX322_S2L55M)
-	int value = get_reg_data(0x0202, fd_iav);
-	if (value >= 0) {
-	    hdr->smart3a[idsp_cfg_index].para0 = value;
-	}
-	value = get_reg_data(0x0203, fd_iav);
-	if (value >= 0) {
-	    hdr->smart3a[idsp_cfg_index].para1 = value;
-	}
-	value = get_reg_data(0x301E, fd_iav);
-	if (value >= 0) {
-	    hdr->smart3a[idsp_cfg_index].para2 = value;
-	}
-	printf("Read sensor IMX322 register: shutter0202=0x%04x, shutter0203=0x%04x, gain301E=0x%04x\n",
-	    hdr->smart3a[idsp_cfg_index].para0,
-	    hdr->smart3a[idsp_cfg_index].para1,
-	    hdr->smart3a[idsp_cfg_index].para2);
-#else
-	int value = get_reg_data(0x3500, fd_iav);
-	if (value >= 0) {
-		hdr->smart3a[idsp_cfg_index].para0 = value;
-	}
-	value = get_reg_data(0x3501, fd_iav);
-	if (value >= 0) {
-		hdr->smart3a[idsp_cfg_index].para1 = value;
-	}
-	value = get_reg_data(0x3502, fd_iav);
-	if (value >= 0) {
-		hdr->smart3a[idsp_cfg_index].para2 = value;
-	}
-	value = get_reg_data(0x3508, fd_iav);
-	if (value >= 0) {
-		hdr->smart3a[idsp_cfg_index].para3 = value;
-	}
-	value = get_reg_data(0x3509, fd_iav);
-	if (value >= 0) {
-		hdr->smart3a[idsp_cfg_index].para4 = value;
-	}
-	printf("Read sensor OV4689 register: shutter3500=0x%04x, shutter3501=0x%04x, shutter3502=0x%04x," \
-	"  gain3508=0x%04x, gain3509=0x%04x\n",
-		hdr->smart3a[idsp_cfg_index].para0,
-		hdr->smart3a[idsp_cfg_index].para1,
-		hdr->smart3a[idsp_cfg_index].para2,
-		hdr->smart3a[idsp_cfg_index].para3,
-		hdr->smart3a[idsp_cfg_index].para4);
-#endif
-	printf("Read AAA param: r_gain=%d, b_gain=%d, dgain=%d, shutter=%d, agc=%d\n",
-		hdr->smart3a[idsp_cfg_index].r_gain,
-		hdr->smart3a[idsp_cfg_index].b_gain,
-		hdr->smart3a[idsp_cfg_index].d_gain,
-		hdr->smart3a[idsp_cfg_index].shutter,
-		hdr->smart3a[idsp_cfg_index].agc);
-
-	if (verbose) {
-		gettimeofday(&time6, NULL);
-	}
-
-	//step 6: save the whole updated adc image to file
-	f_updated_adc = fopen(UPDATED_ADC_IMAGE_PATH, "wb");
-	if (f_updated_adc == NULL) {
-		printf("Open /tmp/updated_adc.bin failed\n");
-		rval = -EINVAL;
-		goto main_exit;
-	}
-	rval = fwrite(p_adc_aligned_mem, 1, adc_img_aligned_len, f_updated_adc);
-	if (rval != adc_img_aligned_len) {
-		printf("/tmp/updated_adc.bin size [%d] is wrong, should be %u\n", rval, adc_img_aligned_len);
-		goto main_exit;
-	}
-
-	if (verbose) {
-		gettimeofday(&time7, NULL);
-	}
-
-	//step 7: update adc partition with adc image file
-	rval = update_adc_partition();
-	if (0 != rval) {
-		printf("Update adc partition failed\n");
-		goto main_exit;
-	}
-
-	if (verbose) {
-		//printf("[IMPORT3A]: export Updated idsp cfg image to /tmp/updated_adc.bin done!\n");
-		gettimeofday(&time8, NULL);
-		time1_US = ((signed long long)(time1.tv_sec) * 1000000 + (signed long long)(time1.tv_usec));
-		time2_US = ((signed long long)(time2.tv_sec) * 1000000 + (signed long long)(time2.tv_usec));
-		time3_US = ((signed long long)(time3.tv_sec) * 1000000 + (signed long long)(time3.tv_usec));
-		time4_US = ((signed long long)(time4.tv_sec) * 1000000 + (signed long long)(time4.tv_usec));
-		time5_US = ((signed long long)(time5.tv_sec) * 1000000 + (signed long long)(time5.tv_usec));
-		time6_US = ((signed long long)(time6.tv_sec) * 1000000 + (signed long long)(time6.tv_usec));
-		time7_US = ((signed long long)(time7.tv_sec) * 1000000 + (signed long long)(time7.tv_usec));
-		time8_US = ((signed long long)(time8.tv_sec) * 1000000 + (signed long long)(time8.tv_usec));
-		printf("[TIME]: <Load ADC partition to image> cost %lld US!\n", time2_US-time1_US);
-		printf("[TIME]: <Find selected section of ADC image> cost %lld US!\n", time3_US-time2_US);
-		printf("[TIME]: <Dump 3A date to mem> cost %lld US!\n", time4_US-time3_US);
-		printf("[TIME]: <Copy 3A mem to selected section of ADC image> cost %lld US!\n", time5_US-time4_US);
-		printf("[TIME]: <Dump&save shutter and gain params to selected section of ADC image> cost %lld US!\n", time6_US-time5_US);
-		printf("[TIME]: <Save the updated ADC image to file> cost %lld US!\n", time7_US-time6_US);
-		printf("[TIME]: <Update ADC partition from file> cost %lld US!\n", time8_US-time7_US);
-	}
-
-main_exit:
-	if (bin_buffer != NULL) {
-		free(bin_buffer);
-		bin_buffer = NULL;
-	}
-	if (p_adc_aligned_mem) {
-		free(p_adc_aligned_mem);
-		p_adc_aligned_mem  = NULL;
-	}
-	if (fd_iav != 0) {
-		close(fd_iav);
-		fd_iav = 0;
-	}
-	if (f_updated_adc) {
-		fclose(f_updated_adc);
-		f_updated_adc = NULL;
-	}
-
-	return rval;
+    int rval = 0;
+
+    if (argc < 2) {
+        usage();
+        return -1;
+    }
+
+    if (init_param(argc, argv) < 0) {
+        usage();
+        return -1;
+    }
+
+    do {
+        if (select_read_3a) {
+            if (dump_from_mem) {
+                rval = adc_io_mem_dump();
+            } else {
+                rval = adc_io_read(verbose,  SMART3A_PARAMETERS | AMBOOT_PARAMETERS);
+            }
+        } else {
+            rval = adc_io_write(verbose, SMART3A_PARAMETERS, NULL);
+        }
+
+        if (rval < 0) {
+            printf("smart3a_adc_read/write failed\n");
+            break;
+        }
+    } while (0);
+
+    return rval;
 }
 
diff --git a/fastboot_smart3a/upgrade_part_adc.c b/fastboot_smart3a/upgrade_part_adc.c
new file mode 100644
index 0000000..cd319cd
--- /dev/null
+++ b/fastboot_smart3a/upgrade_part_adc.c
@@ -0,0 +1,454 @@
+/**
+ * upgrade_partition.c
+ *
+ * History:
+ *    2015/03/30 - [jbxing] created file which is based on Jian he's prototype
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ( "Software" ) are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/*========================== Header Files ====================================*/
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/string.h>
+#include <getopt.h>
+#include <ctype.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <basetypes.h>
+#include <mtd/mtd-user.h>
+//#include <linux/jffs2.h>
+
+#include "upgrade_part_adc.h"
+
+/*===========================================================================*/
+#define MAX_PAGE_SIZE    2048
+#define MAX_OOB_SIZE    64
+
+//#define FLPART_MAGIC    0x8732dfe6
+//#define __ARMCC_PACK__
+//#define __ATTRIB_PACK__  __attribute__ ((packed))
+//#define ETH_INSTANCES        2
+//#define USE_WIFI        1
+//#define CMD_LINE_SIZE        512
+//#define MAC_SIZE        6
+//#define SN_SIZE            32
+
+//essential
+/* mtd struct for image */
+typedef struct nand_update_file_header_s {
+    unsigned char    magic_number[8];           /*   AMBUPGD'\0'     8 chars including '\0' */
+    unsigned short    header_ver_major;
+    unsigned short    header_ver_minor;
+    unsigned int    header_size;               /* payload starts at header_start_address + header_size */
+    unsigned int  payload_type;                /* NAND_UPGRADE_FILE_TYPE_xxx */
+    unsigned char    payload_description[256];  /* payload description string, end with '\0' */
+    unsigned int  payload_size;                /* payload of upgrade file, after header */
+    unsigned int  payload_crc32;               /* payload crc32 checksum, crc calculation from
+                                                  header_start_address  + header_size,
+                                                  crc calculation size is payload_size */
+}nand_update_file_header_t;
+//essential
+typedef struct nand_update_global_s {
+    /* Buffer array used for writing data */
+    unsigned char writebuf[MAX_PAGE_SIZE];
+    unsigned char oobbuf[MAX_OOB_SIZE];
+    unsigned char oobreadbuf[MAX_OOB_SIZE];
+    /* oob layouts to pass into the kernel as default */
+    struct nand_oobinfo none_oobinfo;
+    struct nand_oobinfo jffs2_oobinfo;
+    struct nand_oobinfo yaffs_oobinfo;
+    struct nand_oobinfo autoplace_oobinfo;
+} nand_update_global_t;
+//#define PROGRAM "upgrade_partition"
+//#define VERSION "Revision: 1.310.04 "
+//#define AMB_VERSION "Ambarella: 0-20150121 "
+//#define MAX_LEVEL    32
+//#define NANDWRITE_OPTIONS_BASE        0
+//#define NETWORK_OPTION_BASE        20
+
+
+
+const uint32_t crc32_tab[] = {
+    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
+    0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
+    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
+    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
+    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
+    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
+    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
+    0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
+    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
+    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
+    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
+    0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
+    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
+    0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
+    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
+    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
+    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
+    0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
+    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
+    0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
+    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
+    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
+    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
+    0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
+    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
+    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
+    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
+    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
+    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
+    0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
+    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
+    0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
+    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
+    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
+    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
+    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
+    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
+    0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
+    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
+    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
+    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
+    0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
+    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
+};
+
+
+
+static inline uint32_t crc32(uint32_t val, const void *ss, int len)
+{
+    const unsigned char *s = ss;
+    while (--len >= 0)
+        val = crc32_tab[(val ^ *s++) & 0xff] ^ (val >> 8);
+    return val;
+}
+
+static void init_nand_update_global(nand_update_global_t *pG)
+{
+    pG->none_oobinfo.useecc = MTD_NANDECC_OFF;
+    pG->autoplace_oobinfo.useecc = MTD_NANDECC_AUTOPLACE;
+
+    pG->jffs2_oobinfo.useecc = MTD_NANDECC_PLACE;
+    pG->jffs2_oobinfo.eccbytes = 6;
+    pG->jffs2_oobinfo.eccpos[0] = 0;
+    pG->jffs2_oobinfo.eccpos[1] = 1;
+    pG->jffs2_oobinfo.eccpos[2] = 2;
+    pG->jffs2_oobinfo.eccpos[3] = 3;
+    pG->jffs2_oobinfo.eccpos[4] = 6;
+    pG->jffs2_oobinfo.eccpos[5] = 7;
+
+    pG->yaffs_oobinfo.useecc = MTD_NANDECC_PLACE;
+    pG->yaffs_oobinfo.eccbytes = 6;
+    pG->yaffs_oobinfo.eccpos[0] = 8;
+    pG->yaffs_oobinfo.eccpos[1] = 9;
+    pG->yaffs_oobinfo.eccpos[2] = 10;
+    pG->yaffs_oobinfo.eccpos[3] = 13;
+    pG->yaffs_oobinfo.eccpos[4] = 14;
+    pG->yaffs_oobinfo.eccpos[5] = 15;
+
+    memset(pG->oobbuf, 0xff, sizeof(pG->oobbuf));
+}
+
+int upgrade_partition(int index, const char* img)
+{
+    char     *mtd_device ;
+    int      mtdoffset = 0;
+    int      quiet = 0;
+    int      writeoob = 0;
+    int      skip_head = 0;
+    int      forcejffs2 = 0;
+    int      forceyaffs = 0;
+    int      pad = 0;
+    nand_update_global_t *ptr_update=NULL;
+    int      blockalign = 1; /*default to using 16K block size */ //essential
+
+    int cnt, fd, ifd, pagelen, baderaseblock, blockstart = -1;
+    int ret, readlen, oobinfochanged = 0;
+    int image_crc = ~0U, image_length = 0, imglen = 0;
+    struct nand_oobinfo old_oobinfo;
+    struct mtd_info_user meminfo;
+    struct mtd_oob_buf oob;
+    loff_t offs;
+    unsigned char readbuf[MAX_PAGE_SIZE];
+    int file_offset = mtdoffset;
+    int buf_num = 0;
+    nand_update_file_header_t image_head;
+    char device_name_convert[20]={0};
+
+    sprintf(device_name_convert,"/dev/mtd%d",index);
+    mtd_device   =device_name_convert;
+
+    ptr_update = malloc(sizeof(nand_update_global_t));
+    if (!ptr_update) {
+        perror("can not malloc buffer for update global.\n");
+        exit(1);
+    }
+    init_nand_update_global(ptr_update);
+
+    if (pad && writeoob) {
+        fprintf(stderr, "Can't pad when oob data is present.\n");
+        exit(1);
+    }
+    //update_partition_with_img();
+    // Open the device
+    if ((fd = open(mtd_device, O_RDWR)) == -1) {
+        perror("open flash");
+        exit(1);
+    }
+
+    // Fill in MTD device capability structure
+    if (ioctl(fd, MEMGETINFO, &meminfo) != 0) {
+        perror("MEMGETINFO");
+        close(fd);
+        exit(1);
+    }
+
+    // Set erasesize to specified number of blocks - to match jffs2
+    // (virtual) block size
+    meminfo.erasesize *= blockalign;
+
+    // Make sure device page sizes are valid
+    if (!(meminfo.oobsize == 16 && meminfo.writesize == 512) &&
+        !(meminfo.oobsize == 8 && meminfo.writesize == 256) &&
+        !(meminfo.oobsize == 64 && meminfo.writesize == 2048)) {
+        fprintf(stderr, "Unknown flash (not normal NAND)\n");
+        close(fd);
+        exit(1);
+    }
+
+    /*
+    * force oob layout for jffs2 or yaffs ?
+    * Legacy support
+    */
+    if (forcejffs2 || forceyaffs) {
+        if (meminfo.oobsize == 8) {
+            if (forceyaffs) {
+                fprintf (stderr, "YAFSS cannot operate on 256 Byte page size");
+                goto restoreoob;
+            }
+            // Adjust number of ecc bytes
+            ptr_update->jffs2_oobinfo.eccbytes = 3;
+        }
+    }
+
+    oob.length = meminfo.oobsize;
+    oob.ptr = ptr_update->oobbuf;
+
+    // Open the input file
+    if ((ifd = open(img, O_RDONLY)) == -1) {
+         perror("open input file");
+         goto restoreoob;
+    }
+
+    // get image length
+    imglen = lseek(ifd, 0, SEEK_END);
+    lseek (ifd, 0, SEEK_SET);
+    if(skip_head)
+    {
+        if(read(ifd, &image_head, sizeof(nand_update_file_header_t))
+            != sizeof(nand_update_file_header_t)) {
+            perror ("File I/O error on input file");
+            goto closeall;
+        }
+        lseek(ifd, image_head.header_size, SEEK_SET);
+        imglen =image_head.payload_size;
+        file_offset +=image_head.header_size;
+    }
+    image_length = imglen;
+
+    pagelen = meminfo.writesize + ((writeoob == 1) ? meminfo.oobsize : 0);
+
+    // Check, if file is pagealigned
+    if ((!pad) && ((imglen % pagelen) != 0)) {
+        fprintf (stderr, "Input file is not page aligned\n");
+        goto closeall;
+    }
+
+    // Check, if length fits into device
+    if ( ((imglen / pagelen) * meminfo.writesize) > (meminfo.size - mtdoffset)) {
+        fprintf (stderr, "Image %d bytes, NAND page %d bytes, OOB area %u bytes, device size %u bytes\n",
+            imglen, pagelen, meminfo.writesize, meminfo.size);
+        perror ("Input file does not fit into device");
+        goto closeall;
+    }
+
+    //crc32_table = crc32_filltable(NULL, 0);
+
+    // Get data from input and write to the device
+    while (imglen && (mtdoffset < meminfo.size)) {
+        // new eraseblock , check for bad block(s)
+        // Stay in the loop to be sure if the mtdoffset changes because
+        // of a bad block, that the next block that will be written to
+        // is also checked. Thus avoiding errors if the block(s) after the
+        // skipped block(s) is also bad (number of blocks depending on
+        // the blockalign
+        while (blockstart != (mtdoffset & (~meminfo.erasesize + 1))) {
+            blockstart = mtdoffset & (~meminfo.erasesize + 1);
+            offs = blockstart;
+            baderaseblock = 0;
+            if (!quiet)
+                fprintf (stdout, "Writing data to block %x\n", blockstart);
+
+            //Check all the blocks in an erase block for bad blocks
+            do {
+                if ((ret = ioctl(fd, MEMGETBADBLOCK, &offs)) < 0) {
+                    perror("ioctl(MEMGETBADBLOCK)");
+                    goto closeall;
+                }
+                if (ret == 1) {
+                    baderaseblock = 1;
+                    if (!quiet)
+                        fprintf (stderr, "Bad block at %x, %u block(s) "
+                        "from %x will be skipped\n",
+                        (int) offs, blockalign, blockstart);
+                }
+
+                if (baderaseblock) {
+                    mtdoffset = blockstart + meminfo.erasesize;
+                }
+                offs +=  meminfo.erasesize / blockalign ;
+            } while ( offs < blockstart + meminfo.erasesize );
+
+        }
+
+        readlen = meminfo.writesize;
+        if (pad && (imglen < readlen)) {
+            readlen = imglen;
+            memset(ptr_update->writebuf + readlen, 0xff, meminfo.writesize - readlen);
+        }
+
+        // Read Page Data from input file
+        if ((cnt = pread(ifd, ptr_update->writebuf, readlen,file_offset)) != readlen) {
+            if (cnt == 0)// EOF
+                break;
+            perror ("File I/O error on input file");
+            goto closeall;
+        }
+
+        image_crc = crc32(image_crc, ptr_update->writebuf, cnt);
+
+        if (writeoob) {
+            int i, start, len, filled;
+            // Read OOB data from input file, exit on failure
+            if ((cnt = pread(ifd, ptr_update->oobreadbuf, meminfo.oobsize,file_offset)) != meminfo.oobsize) {
+                perror ("File I/O error on input file");
+                goto closeall;
+            }
+            /*
+             *  We use autoplacement and have the oobinfo with the autoplacement
+             * information from the kernel available
+             *
+             * Modified to support out of order oobfree segments,
+             * such as the layout used by diskonchip.c
+             */
+            if (!oobinfochanged && (old_oobinfo.useecc == MTD_NANDECC_AUTOPLACE)) {
+                for (filled = 0, i = 0; old_oobinfo.oobfree[i][1] && (i < MTD_MAX_OOBFREE_ENTRIES); i++) {
+                    /* Set the reserved bytes to 0xff */
+                    start = old_oobinfo.oobfree[i][0];
+                    len = old_oobinfo.oobfree[i][1];
+                    memcpy(ptr_update->oobbuf + start,
+                        ptr_update->oobreadbuf + filled,
+                        len);
+                    filled += len;
+                }
+            } else {
+                // Set at least the ecc byte positions to 0xff
+                start = old_oobinfo.eccbytes;
+                len = meminfo.oobsize - start;
+                memcpy(ptr_update->oobbuf + start,
+                    ptr_update->oobreadbuf + start, len);
+            }
+            // Write OOB data first, as ecc will be placed in there
+            oob.start = mtdoffset;
+            if (ioctl(fd, MEMWRITEOOB, &oob) != 0) {
+                perror ("ioctl(MEMWRITEOOB)");
+                goto closeall;
+            }
+            imglen -= meminfo.oobsize;
+        }
+
+        // Write out the Page data
+        if (pwrite(fd, ptr_update->writebuf, meminfo.writesize, mtdoffset) != meminfo.writesize) {
+            perror ("pwrite");
+            goto closeall;
+        }
+
+        // read out the Page data
+        if (pread(fd, readbuf, meminfo.writesize, mtdoffset) != meminfo.writesize) {
+            perror ("pread");
+            goto closeall;
+        }
+
+        buf_num=0;
+        while ((ptr_update->writebuf[buf_num]==readbuf[buf_num]) && (buf_num < readlen)) buf_num++;
+
+        //if (((blockstart/MAX_PAGE_SIZE/64) % 10) == 9)
+        if (buf_num < readlen) {
+            //printf("offs[%x ],blockstart[%x],mtdoffset[%x],writesize[0x%x], buf_num[0x%x]\n",(int)offs,blockstart,mtdoffset,meminfo.writesize, buf_num);
+
+            // set bad blocks
+            offs = (loff_t) blockstart;
+            if ((ret = ioctl(fd, MEMSETBADBLOCK, &offs)) < 0) {
+                perror("ioctl(MEMSETBADBLOCK)");
+                goto closeall;
+            }
+            if ((ret == 0) && (!quiet)) {
+                fprintf (stdout, "set Bad block at %x !\n",blockstart);
+                file_offset = file_offset - (mtdoffset-blockstart);
+                imglen = imglen+ (mtdoffset-blockstart);;
+                mtdoffset = blockstart + meminfo.erasesize;
+            }
+        } else {
+            imglen -= readlen;
+            mtdoffset += meminfo.writesize;
+            file_offset+= meminfo.writesize;
+        }
+    }
+
+closeall: //essential
+    close(ifd);
+
+restoreoob:  //essential
+    close(fd);
+
+    if (imglen > 0) {
+        perror ("Data was only partially written due to error\n");
+        exit (1);
+    }
+
+    image_crc ^= ~0U;
+    printf ("image_length = 0x%08x\n", image_length);
+    printf ("image_crc = 0x%08x\n", image_crc);
+    free(ptr_update);
+
+    sync();
+    return 0;
+}
diff --git a/fastboot_smart3a/upgrade_part_adc.h b/fastboot_smart3a/upgrade_part_adc.h
new file mode 100644
index 0000000..a9437a2
--- /dev/null
+++ b/fastboot_smart3a/upgrade_part_adc.h
@@ -0,0 +1,36 @@
+/**
+ * upgrade_part_adc.h
+ *
+ * History:
+ *    2015/03/30 - [jbxing] created file which is based on Jian he's prototype
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ( "Software" ) are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __SMART3A_ADC_UPGRADE_PARTITION_H__
+#define __SMART3A_ADC_UPGRADE_PARTITION_H__
+
+int upgrade_partition(int index, const char* img);
+#endif
diff --git a/http_uploader/AmbaConfig b/http_uploader/AmbaConfig
index 9048412..e53b3d4 100644
--- a/http_uploader/AmbaConfig
+++ b/http_uploader/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/12/08 - [Chu Chen] Create
 ##
-## Copyright (C) 2014, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 
diff --git a/http_uploader/http_uploader.c b/http_uploader/http_uploader.c
index c3390cb..4973023 100644
--- a/http_uploader/http_uploader.c
+++ b/http_uploader/http_uploader.c
@@ -4,14 +4,33 @@
  * History:
  *	2014/12/03 - [Chu Chen] create this file base on test_encode.c
  *
- * Copyright (C) 2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <unistd.h>
 #include <fcntl.h>
 #include <stdio.h>
diff --git a/http_uploader/make.inc b/http_uploader/make.inc
index 06ece46..0c140fe 100644
--- a/http_uploader/make.inc
+++ b/http_uploader/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/12/03 - [Chu Chen] Created file
 ##
-## Copyright (C) 2014, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_APP_HTTP_UPLOADER), y)
diff --git a/smart_ldc/AmbaConfig b/smart_ldc/AmbaConfig
index 76e149e..c828e35 100644
--- a/smart_ldc/AmbaConfig
+++ b/smart_ldc/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2010/02/04 - [Jian Tang] Create
 ##
-## Copyright (C) 2004-2010, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 config BUILD_AMBARELLA_APP_IPCAM_SMART_LDC
@@ -18,7 +35,7 @@ config BUILD_AMBARELLA_APP_IPCAM_SMART_LDC
 	depends on BUILD_AMBARELLA_APP_IPCAM
 	select CONFIG_AMBARELLA_LIBJPEG_TURBO_SUPPORT
 	select CONFIG_AMBARELLA_CLEARSILVER_SUPPORT
-	select BUILD_AMBARELLA_DEWARP_PACKAGE
+	select CONFIG_AMBARELLA_DEWARP_LIBRARY
 	select CONFIG_AMBARELLA_WEB_SERVICE_SUPPORT
 	help
 		Build Smart LDC Tool
diff --git a/smart_ldc/chrome_convert.S b/smart_ldc/chrome_convert.S
index a61e5eb..96f1da7 100644
--- a/smart_ldc/chrome_convert.S
+++ b/smart_ldc/chrome_convert.S
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 /* Zhikan */
 
 .fpu neon
diff --git a/smart_ldc/make.inc b/smart_ldc/make.inc
index 88f27d5..f34f840 100644
--- a/smart_ldc/make.inc
+++ b/smart_ldc/make.inc
@@ -3,12 +3,29 @@
 ## History:
 ##    2012/06/25 - [Jian Tang] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 ifeq ($(BUILD_AMBARELLA_APP_IPCAM_SMART_LDC), y)
 
@@ -44,7 +61,7 @@ include $(CLEAR_VARS)
 LOCAL_TARGET	:= ldc.cgi
 LOCAL_SRCS	:= $(LOCAL_PATH)/web/cgi-bin/ldc.c
 LOCAL_CFLAGS	:= -I$(PREBUILD_3RD_PARTY_DIR)/clearsilver/include/ClearSilver
-LOCAL_LDFLAGS	:= -L$(PREBUILD_3RD_PARTY_DIR)/clearsilver/usr/lib -lneo_cgi -lneo_cs -lneo_utl
+LOCAL_LDFLAGS	:= -L$(PREBUILD_3RD_PARTY_DIR)/clearsilver/usr/lib -lneo_cgi -lneo_cs -lneo_utl -Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/zlib/usr/lib
 
 include $(BUILD_APP)
 
@@ -65,7 +82,7 @@ include $(CLEAR_VARS)
 LOCAL_TARGET	:= get_vin.cgi
 LOCAL_SRCS	:= $(LOCAL_PATH)/web/cgi-bin/get_vin.c
 LOCAL_CFLAGS	:= -I$(PREBUILD_3RD_PARTY_DIR)/clearsilver/include/ClearSilver
-LOCAL_LDFLAGS	:= -L$(PREBUILD_3RD_PARTY_DIR)/clearsilver/usr/lib -lneo_cgi -lneo_cs -lneo_utl
+LOCAL_LDFLAGS	:= -L$(PREBUILD_3RD_PARTY_DIR)/clearsilver/usr/lib -lneo_cgi -lneo_cs -lneo_utl -Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/zlib/usr/lib
 
 include $(BUILD_APP)
 
diff --git a/smart_ldc/smart_ldc.c b/smart_ldc/smart_ldc.c
index dd8d0a9..45e63ce 100644
--- a/smart_ldc/smart_ldc.c
+++ b/smart_ldc/smart_ldc.c
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
diff --git a/smart_ldc/web/cgi-bin/get_vin.c b/smart_ldc/web/cgi-bin/get_vin.c
index 3f40b91..265ab1c 100644
--- a/smart_ldc/web/cgi-bin/get_vin.c
+++ b/smart_ldc/web/cgi-bin/get_vin.c
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
diff --git a/smart_ldc/web/cgi-bin/ldc.c b/smart_ldc/web/cgi-bin/ldc.c
index 7b69b3f..92b17c4 100644
--- a/smart_ldc/web/cgi-bin/ldc.c
+++ b/smart_ldc/web/cgi-bin/ldc.c
@@ -1,3 +1,33 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
diff --git a/wowl/AmbaConfig b/wowl/AmbaConfig
new file mode 100644
index 0000000..a247001
--- /dev/null
+++ b/wowl/AmbaConfig
@@ -0,0 +1,72 @@
+##
+## app/ipcam/wowl/AmbaConfig
+##
+## History:
+##    2015/11/10 - [Tao Wu] Created file
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+
+menuconfig BUILD_AMBARELLA_APP_WIFI_UTILITY
+	bool "Build WiFi ioctl library and tools "
+	default n
+	help
+		Build WiFi ioctl library and tools
+
+if BUILD_AMBARELLA_APP_WIFI_UTILITY
+
+config BUILD_AMBARELLA_APP_WIFI_WOWL
+	bool "Build APP wowl (Wakeup on Wireless) base on WiFi"
+	select CONFIG_AMBARELLA_LIBPCAP_SUPPORT
+	default n
+
+choice
+	prompt "WiFi Chip"
+	depends on BUILD_AMBARELLA_APP_WIFI_WOWL
+	default BUILD_AMBARELLA_APP_WIFI_WOWL_BRCM
+
+config BUILD_AMBARELLA_APP_WIFI_WOWL_BRCM
+	bool "Broadcom WiFi"
+
+config BUILD_AMBARELLA_APP_WIFI_WOWL_MRVL
+	bool "Marvell WiFi"
+endchoice
+
+config BUILD_AMBARELLA_APP_WIFI_LIBRARY_BRCM
+	bool "Build Broadcom ioctl library"
+	depends on BUILD_AMBARELLA_APP_WIFI_UTILITY
+	default n
+	help
+		Build BRCM ioctl library
+
+config BUILD_AMBARELLA_APP_WIFI_LIBRARY_MRVL
+	bool "Build Marvell ioctl library"
+	depends on BUILD_AMBARELLA_APP_WIFI_UTILITY
+	default n
+	help
+		Build Marvell ioctl library
+
+endif
diff --git a/wowl/brcm/brcm_ioc.c b/wowl/brcm/brcm_ioc.c
new file mode 100644
index 0000000..57d91ec
--- /dev/null
+++ b/wowl/brcm/brcm_ioc.c
@@ -0,0 +1,1126 @@
+/*******************************************************************************
+ * brcm_ioc.c
+ *
+ * History:
+ *    2015/8/8 - [Tao Wu] Create
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ( "Software" ) are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+******************************************************************************/
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <assert.h>
+
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <netinet/ether.h>
+
+#include <brcm_ioc.h>
+
+static char G_iface[IFNAMSIZ] = "wlan0";
+static wifi_chip_t G_brcm_chip = WIFI_BCM43340;
+static int G_sys_exec = 0;
+
+static int wl_pattern_atoh(char *src, char *dst)
+{
+	int i = 0;
+
+	if (strncmp(src, "0x", 2) != 0 && strncmp(src, "0X", 2) != 0) {
+		loge("Data invalid format. Needs to start with 0x\n");
+		return -1;
+	}
+	src = src + 2; /* Skip past 0x */
+	if (strlen(src) % 2 != 0) {
+		loge("Data invalid format. Needs to be of even length\n");
+		return -1;
+	}
+	for (i = 0; *src != '\0'; i++) {
+		char num[3];
+		strncpy(num, src, 2);
+		num[2] = '\0';
+		dst[i] = (uint8)strtoul(num, NULL, 16);
+		src += 2;
+	}
+
+	return i;
+}
+
+static uint wl_iovar_mkbuf(const char *name, char *data, uint datalen,
+	char *iovar_buf, uint buflen, int *perr)
+{
+	uint iovar_len = 0;
+
+	iovar_len = strlen(name) + 1;
+
+	/* check for overflow */
+	if ((iovar_len + datalen) > buflen) {
+		*perr = -1;
+		loge("Buffer overflow, iovar_len[%u] + datalen[%u] > buflen[%u]\n",
+			iovar_len, datalen, buflen);
+		return 0;
+	}
+
+	/* copy data to the buffer past the end of the iovar name string */
+	if (datalen > 0 && data) {
+		memmove(&iovar_buf[iovar_len], data, datalen);
+		iovar_len += datalen;
+	}
+
+	/* copy the name to the beginning of the buffer */
+	strcpy(iovar_buf, name);
+
+	*perr = 0;
+	return iovar_len;
+}
+
+static int wl_ioctl(int cmd, void *buf, uint len, uint8 set)
+{
+	struct ifreq ifr;
+	wl_ioctl_t ioc;
+	int ret = -1;
+	int s = -1;
+
+	strncpy(ifr.ifr_name, G_iface, IFNAMSIZ);
+
+	s = socket(AF_INET, SOCK_DGRAM, 0);
+	if (s < 0) {
+		loge("cannot open socket: %s\n", strerror(errno));
+		return -1;
+	}
+
+	ioc.cmd = cmd;
+	ioc.buf = buf;
+	ioc.len = len;
+	ioc.set = set;
+	ifr.ifr_data = (caddr_t) &ioc;
+
+	ret = ioctl(s, SIOCDEVPRIVATE, &ifr);
+	if (ret < 0) {
+		loge("IOCTL SIOCDEVPRIVATE:%s. if[%s], fd[%d], cmd[%d], buf[%s], len[%d], set[%d]\n",
+			strerror(errno), ifr.ifr_name, s, cmd, (char *)buf, len, set);
+	}
+
+	close(s);
+	return ret;
+}
+
+/*  TCP Keep alive */
+int wl_tcpka_conn_add(tcpka_conn_t *p_tcpka)
+{
+	uint buf_len = 0;
+	char bufdata[WLC_IOCTL_MEDLEN];
+	char buf_src_addr[IPV4_ADDR_STR_LEN];
+	char buf_dst_addr[IPV4_ADDR_STR_LEN];
+	char CMD[CMD_MINSIZE];
+	int ret = -1;
+	int i = 0;
+
+	memset(buf_src_addr, 0, sizeof(buf_src_addr));
+	memset(buf_dst_addr, 0, sizeof(buf_dst_addr));
+	strncpy(buf_src_addr, iptoa(&p_tcpka->src_ip), sizeof(buf_src_addr));
+	strncpy(buf_dst_addr, iptoa(&p_tcpka->dst_ip), sizeof(buf_dst_addr));
+	memset(CMD, 0, sizeof(CMD));
+	snprintf(CMD, sizeof(CMD),
+		"tcpka_conn_add %s %s %s %d %d %d %u %u %d %u %u %u %u \"%s\"",
+		ether_ntoa(&p_tcpka->dst_mac), buf_src_addr, buf_dst_addr,
+		p_tcpka->ipid, p_tcpka->srcport, p_tcpka->dstport, p_tcpka->seq, p_tcpka->ack,
+		p_tcpka->tcpwin, p_tcpka->tsval, p_tcpka->tsecr, p_tcpka->len,
+		p_tcpka->ka_payload_len, p_tcpka->ka_payload);
+
+	if (G_sys_exec) {
+		snprintf(CMD, sizeof(CMD), "%s %s", BRCM_TOOL, CMD);
+		system(CMD);
+		logi("CMD: %s\n", CMD);
+		return 0;
+	}
+
+	buf_len = wl_iovar_mkbuf("tcpka_conn_add", (char *)p_tcpka,
+		(sizeof(tcpka_conn_t) + p_tcpka->ka_payload_len - 1),
+		bufdata, sizeof(bufdata), &ret);
+	if (ret) {
+		loge("Failed to build buffer, %s.\n", __FUNCTION__);
+		return -1;
+	}
+
+	ret = wl_ioctl(WLC_GET_VAR, bufdata, buf_len, 0);
+	if (!ret) {
+		logi("TCP KeepAlive Add: ID [%d], %s\n", p_tcpka->sess_id, CMD);
+	} else {
+		loge("TCP KeepAlive Add Failed: ID [%d], %s, %s\n",
+			p_tcpka->sess_id, CMD, strerror(errno));
+		logw("TCP KeepAlive Add: CMD DUMP=");
+		for ( i = 0; i < buf_len; i++ ) {
+			logw("%02x", bufdata[i]);
+		}
+		logw("\n");
+	}
+	return ret;
+}
+
+int wl_tcpka_conn_enable(uint32 sess_id, uint32 is_enable , uint16 itrvl,
+	uint16 retry_itrvl, uint16 rety_cnt)
+{
+	uint buf_len = 0;
+	char bufdata[WLC_IOCTL_SMLEN];
+	char CMD[CMD_MINSIZE];
+	tcpka_conn_sess_t tcpka_conn;
+	int ret = -1;
+
+	tcpka_conn.sess_id = sess_id;
+	tcpka_conn.flag = is_enable;
+	if (tcpka_conn.flag) {
+		tcpka_conn.tcp_keepalive_timers.interval = itrvl;
+		tcpka_conn.tcp_keepalive_timers.retry_interval = retry_itrvl;
+		tcpka_conn.tcp_keepalive_timers.retry_count = rety_cnt;
+	} else {
+		tcpka_conn.tcp_keepalive_timers.interval = 0;
+		tcpka_conn.tcp_keepalive_timers.retry_interval = 0;
+		tcpka_conn.tcp_keepalive_timers.retry_count = 0;
+	}
+
+	memset(CMD, 0, sizeof(CMD));
+	snprintf(CMD, sizeof(CMD), "tcpka_conn_enable %u %u %u %u %u",
+		tcpka_conn.sess_id, tcpka_conn.flag,
+		tcpka_conn.tcp_keepalive_timers.interval,
+		tcpka_conn.tcp_keepalive_timers.retry_interval,
+		tcpka_conn.tcp_keepalive_timers.retry_count);
+
+	if (G_sys_exec) {
+		snprintf(CMD, sizeof(CMD), "%s %s", BRCM_TOOL, CMD);
+		system(CMD);
+		logi("CMD: %s\n", CMD);
+		return 0;
+	}
+
+	buf_len = wl_iovar_mkbuf("tcpka_conn_enable", (char *)&tcpka_conn,
+		sizeof(tcpka_conn_sess_t), bufdata, sizeof(bufdata), &ret);
+	if (ret) {
+		loge("Failed to build buffer, %s.\n", __FUNCTION__);
+		return -1;
+	}
+
+	ret = wl_ioctl(WLC_SET_VAR, bufdata, buf_len, 1);
+	if (!ret) {
+		logi("TCP KeepAlive Enable: %s\n", CMD);
+	} else {
+		loge("TCP KeepAlive Enable Failed: %s, %s\n", CMD, strerror(errno));
+	}
+	return ret;
+}
+
+int wl_tcpka_conn_sess_info(uint sess_id, tcpka_conn_sess_info_t *tcpka_sess_info)
+{
+	uint buf_len = 0;
+	char bufdata[WLC_IOCTL_SMLEN];
+	tcpka_conn_sess_info_t *info = NULL;
+	uint id = 0;
+	int ret = -1;
+
+	id = sess_id;
+	buf_len = wl_iovar_mkbuf("tcpka_conn_sess_info", (char *)&id, sizeof(uint32),
+		bufdata, sizeof(bufdata), &ret);
+	if (ret) {
+		loge("Failed to build buffer, %s.\n", __FUNCTION__);
+		return -1;
+	}
+
+	ret = wl_ioctl(WLC_GET_VAR, bufdata, buf_len, 0);
+	if (!ret) {
+		info = (tcpka_conn_sess_info_t *) bufdata;
+		tcpka_sess_info->tcpka_sess_ipid = info->tcpka_sess_ipid;
+		tcpka_sess_info->tcpka_sess_seq = info->tcpka_sess_seq;
+		tcpka_sess_info->tcpka_sess_ack = info->tcpka_sess_ack;
+		logi("TCP KeepAlive Get Session: Id [%d] info: ipid[%u], seq[%u], ack[%u]\n", id,
+			tcpka_sess_info->tcpka_sess_ipid,
+			tcpka_sess_info->tcpka_sess_seq,
+			tcpka_sess_info->tcpka_sess_ack);
+	} else {
+		loge("TCP KeepAlive Get Session Failed: Id [%d], %s\n", id, strerror(errno));
+	}
+	return ret;
+}
+
+int wl_tcpka_conn_del(uint sess_id)
+{
+	uint buf_len = 0;
+	char bufdata[WLC_IOCTL_SMLEN];
+	char CMD[CMD_MINSIZE];
+	uint id = 0;
+	int ret = -1;
+
+	id = sess_id;
+	memset(CMD, 0, sizeof(CMD));
+	snprintf(CMD, sizeof(CMD), "tcpka_conn_del %u", id);
+
+	if (G_sys_exec) {
+		snprintf(CMD, sizeof(CMD), "%s %s", BRCM_TOOL, CMD);
+		system(CMD);
+		logi("CMD: %s\n", CMD);
+		return 0;
+	}
+
+	buf_len = wl_iovar_mkbuf("tcpka_conn_del", (char *)&id, sizeof(int32),
+		bufdata, sizeof(bufdata), &ret);
+	if (ret) {
+		loge("Failed to build buffer, %s.\n", __FUNCTION__);
+		return -1;
+	}
+
+	ret = wl_ioctl(WLC_SET_VAR, bufdata, buf_len, 1);
+	if (!ret) {
+		logi("TCP KeepAlive Del: %s\n", CMD);
+	} else {
+		loge("TCP KeepAlive Del Failed: %s, %s\n", CMD, strerror(errno));
+	}
+	return ret;
+}
+
+int wl_wowl_pattern_bcm43340(int offset, char *mask, char *wowl_pattern)
+{
+	uint buf_len = 0;
+	char bufdata[WLC_IOCTL_SMLEN];
+	char CMD[CMD_MINSIZE];
+
+	const char *str;
+	wl_wowl_pattern_t *wl_pattern;
+	char *buf, *mask_and_pattern;
+	char *pattern;
+	uint str_len = 0;
+	int ret = -1;
+	int i = 0;
+
+	memset(CMD, 0, sizeof(CMD));
+	snprintf(CMD, sizeof(CMD), "wowl_pattern add %d %s %s",
+		offset, mask, wowl_pattern);
+
+	if (G_sys_exec) {
+		snprintf(CMD, sizeof(CMD), "%s %s", BRCM_TOOL, CMD);
+		system(CMD);
+		logi("CMD: %s\n", CMD);
+		return 0;
+	}
+
+	/* wl wowl_pattern add 0 0x0f 0x77616b65 : Receive "wake" tcp data */
+	str = "wowl_pattern";
+	str_len = strlen(str);
+	strncpy(bufdata, str, str_len);
+	bufdata[str_len] = '\0';
+	buf = bufdata + strlen(str) + 1;
+	buf_len = str_len + 1;
+
+	str = "add";
+	strncpy(buf, str, strlen(str));
+	buf_len += strlen(str) + 1;
+
+	wl_pattern = (wl_wowl_pattern_t *)(buf + strlen(str) + 1);
+	mask_and_pattern = (char*)wl_pattern + sizeof(wl_wowl_pattern_t);
+	wl_pattern->offset = offset;
+
+	/* Parse the mask */
+	wl_pattern->masksize = (strlen(mask) -2)/2;
+	wl_pattern_atoh(mask, mask_and_pattern);
+	mask_and_pattern += wl_pattern->masksize;
+	wl_pattern->patternoffset = sizeof(wl_wowl_pattern_t) +	wl_pattern->masksize;
+
+	/* Parse the pattern */
+	pattern = wowl_pattern;
+	wl_pattern->patternsize = (strlen(pattern)-2)/2;
+	wl_pattern_atoh(pattern, mask_and_pattern);
+	buf_len += sizeof(wl_wowl_pattern_t) + wl_pattern->patternsize + wl_pattern->masksize;
+
+	ret = wl_ioctl(WLC_SET_VAR, bufdata, buf_len, 1);
+	if (!ret) {
+		logi("WOWL Pattern: %s\n", CMD);
+	} else {
+		loge("WOWL Pattern Failed: %s, %s\n", CMD, strerror(errno));
+		logw("WOWL Pattern: wowl_pattern[%d]=%s\n", strlen(pattern), pattern);
+		logw("WOWL Pattern: CMD DUMP=");
+		for ( i = 0; i < buf_len; i++ ) {
+			logw("%02x", bufdata[i]);
+		}
+		logw("\n");
+	}
+	return ret;
+}
+
+int wl_wowl_pattern_bcm43438(int offset, char *mask, char *wowl_pattern)
+{
+	uint buf_len = 0;
+	char bufdata[WLC_IOCTL_SMLEN];
+	char CMD[CMD_MINSIZE];
+
+	const char *str;
+	wl_wowl_pattern_t_bcm43438 *wl_pattern;
+	char *buf, *mask_and_pattern;
+	char *pattern;
+	uint str_len = 0;
+	int ret = -1;
+	int i = 0;
+
+	memset(CMD, 0, sizeof(CMD));
+	snprintf(CMD, sizeof(CMD), "wowl_pattern add %d %s %s",
+		offset, mask, wowl_pattern);
+
+	if (G_sys_exec) {
+		snprintf(CMD, sizeof(CMD), "%s %s", BRCM_TOOL, CMD);
+		system(CMD);
+		logi("CMD: %s\n", CMD);
+		return 0;
+	}
+
+	/* wl wowl_pattern add 0 0x0f 0x77616b65 : Receive "wake" tcp data */
+	str = "wowl_pattern";
+	str_len = strlen(str);
+	strncpy(bufdata, str, str_len);
+	bufdata[str_len] = '\0';
+	buf = bufdata + strlen(str) + 1;
+	buf_len = str_len + 1;
+
+	str = "add";
+	strncpy(buf, str, strlen(str));
+	buf_len += strlen(str) + 1;
+	wl_pattern = (wl_wowl_pattern_t_bcm43438 *)(buf + strlen(str) + 1);
+	mask_and_pattern = (char*)wl_pattern + sizeof(wl_wowl_pattern_t_bcm43438);
+	wl_pattern->type = 0;
+	wl_pattern->offset = offset;
+
+	/* Parse the mask */
+	wl_pattern->masksize = (strlen(mask) -2)/2;
+	wl_pattern_atoh(mask, mask_and_pattern);
+
+	mask_and_pattern += wl_pattern->masksize;
+	wl_pattern->patternoffset = sizeof(wl_wowl_pattern_t_bcm43438) + wl_pattern->masksize;
+
+	/* Parse the pattern */
+	pattern = wowl_pattern;
+	wl_pattern->patternsize = (strlen(pattern)-2)/2;
+	wl_pattern_atoh(pattern, mask_and_pattern);
+	buf_len += sizeof(wl_wowl_pattern_t_bcm43438) + wl_pattern->patternsize +
+		wl_pattern->masksize;
+
+	ret = wl_ioctl(WLC_SET_VAR, bufdata, buf_len, 1);
+	if (!ret) {
+		logi("WOWL Pattern: %s\n", CMD);
+	} else {
+		loge("WOWL Pattern Failed: %s, %s\n", CMD, strerror(errno));
+		logw("WOWL Pattern: wowl_pattern[%d]=%s\n", strlen(pattern), pattern);
+		logw("WOWL Pattern: CMD DUMP=");
+		for ( i = 0; i < buf_len; i++ ) {
+			logw("%02x", bufdata[i]);
+		}
+		logw("\n");
+	}
+	return ret;
+}
+
+int wl_wowl_pattern(int offset, char *mask, char *wowl_pattern)
+{
+	if (G_brcm_chip == WIFI_BCM43438) {
+		return wl_wowl_pattern_bcm43438(offset, mask, wowl_pattern);
+	} else {
+		return wl_wowl_pattern_bcm43340(offset, mask, wowl_pattern);
+	}
+}
+
+int wl_wowl_pattern_clr(void)
+{
+	uint buf_len = 0;
+	char bufdata[WLC_IOCTL_SMLEN];
+	char CMD[CMD_MINSIZE];
+	int ret = -1;
+	char str[] = "clr";
+
+	memset(CMD, 0, sizeof(CMD));
+	snprintf(CMD, sizeof(CMD), "wowl_pattern %s", str);
+
+	if (G_sys_exec) {
+		snprintf(CMD, sizeof(CMD), "%s %s", BRCM_TOOL, CMD);
+		system(CMD);
+		logi("CMD: %s\n", CMD);
+		return 0;
+	}
+
+	buf_len = wl_iovar_mkbuf("wowl_pattern", str, sizeof(str),
+		bufdata, sizeof(bufdata), &ret);
+	if (ret) {
+		loge("Failed to build buffer, %s.\n", __FUNCTION__);
+		return -1;
+	}
+
+	ret = wl_ioctl(WLC_SET_VAR, bufdata, buf_len, 1);
+	if (!ret) {
+		logi("WOWL Pattern Clear: %s\n", CMD);
+	} else {
+		loge("WOWL Pattern Clear Failed: %s, %s\n", CMD, strerror(errno));
+	}
+	return ret;
+}
+
+int wl_wowl_wakeind(wl_wowl_wakeind_t *wakeind)
+{
+	uint buf_len = 0;
+	char bufdata[WLC_IOCTL_SMLEN];
+	char CMD[CMD_MINSIZE];
+	wl_wowl_wakeind_t *wake = NULL;
+	int ret = -1;
+
+	memset(CMD, 0, sizeof(CMD));
+	snprintf(CMD, sizeof(CMD), "wowl_wakeind");
+
+	if (G_sys_exec) {
+		snprintf(CMD, sizeof(CMD), "%s %s", BRCM_TOOL, CMD);
+		system(CMD);
+		logi("CMD: %s\n", CMD);
+		return 0;
+	}
+
+	buf_len = wl_iovar_mkbuf("wowl_wakeind", NULL, 0, bufdata, sizeof(bufdata), &ret);
+	if (ret) {
+		loge("Failed to build buffer, %s.\n", __FUNCTION__);
+		return -1;
+	}
+
+	ret = wl_ioctl(WLC_GET_VAR, bufdata, buf_len, 0);
+	if (!ret) {
+		wake = (wl_wowl_wakeind_t *) bufdata;
+		memcpy(wakeind, wake, sizeof(wl_wowl_wakeind_t));
+		logi("WOWL Wakeind: %s. [0x%08x] Reason:\n", CMD, wake->ucode_wakeind);
+		if (wake->ucode_wakeind != 0) {
+			if ((wake->ucode_wakeind & WL_WOWL_MAGIC) == WL_WOWL_MAGIC)
+				logi("\tMAGIC packet received\n");
+			if ((wake->ucode_wakeind & WL_WOWL_NET) == WL_WOWL_NET)
+				logi("\tPacket received with Netpattern\n");
+			if ((wake->ucode_wakeind & WL_WOWL_DIS) == WL_WOWL_DIS)
+				logi("\tDisassociation/Deauth received\n");
+			if ((wake->ucode_wakeind & WL_WOWL_RETR) == WL_WOWL_RETR)
+				logi("\tRetrograde TSF detected\n");
+			if ((wake->ucode_wakeind & WL_WOWL_BCN) == WL_WOWL_BCN)
+				logi("\tBeacons Lost\n");
+			if ((wake->ucode_wakeind & WL_WOWL_TCPKEEP_DATA) == WL_WOWL_TCPKEEP_DATA)
+				logi("\tWake on TCP Keepalive Data\n");
+			if ((wake->ucode_wakeind & WL_WOWL_TCPKEEP_TIME) == WL_WOWL_TCPKEEP_TIME)
+				logi("\tWake on TCP Keepalive Timeout\n");
+			if ((wake->ucode_wakeind & WL_WOWL_TCPFIN) == WL_WOWL_TCPFIN)
+				logi("\tWake on TCP FIN\n");
+			if ((wake->ucode_wakeind & (WL_WOWL_NET | WL_WOWL_MAGIC))) {
+				if ((wake->ucode_wakeind & WL_WOWL_BCAST) == WL_WOWL_BCAST)
+					logi("\t\tBroadcast/Mcast frame received\n");
+				else
+					logi("\t\tUnicast frame received\n");
+			}
+		} else {
+			logi("\tWake on other event\n");
+		}
+	} else {
+		loge("WOWL Wakeind Failed: %s\n", strerror(errno));
+	}
+	return ret;
+}
+
+int wl_wowl_wakeind_clear(void)
+{
+	uint buf_len = 0;
+	char bufdata[WLC_IOCTL_SMLEN];
+	char CMD[CMD_MINSIZE];
+	int ret = -1;
+	char str[]="clear";
+
+	memset(CMD, 0, sizeof(CMD));
+	snprintf(CMD, sizeof(CMD), "wowl_wakeind %s", str);
+
+	if (G_sys_exec) {
+		snprintf(CMD, sizeof(CMD), "%s %s", BRCM_TOOL, CMD);
+		system(CMD);
+		logi("CMD: %s\n", CMD);
+		return 0;
+	}
+
+	buf_len = wl_iovar_mkbuf("wowl_wakeind", str, sizeof(str) + sizeof(wl_wowl_wakeind_t),
+		bufdata, sizeof(bufdata), &ret);
+	if (ret) {
+		loge("Failed to build buffer, %s.\n", __FUNCTION__);
+		return -1;
+	}
+
+	ret = wl_ioctl(WLC_SET_VAR, bufdata, buf_len, 1);
+	if (!ret) {
+		logi("WOWL Wakeind Clear: %s\n", CMD);
+	} else {
+		loge("WOWL Wakeind Clear Failed: %s, %s\n", CMD, strerror(errno));
+	}
+
+	return 1;
+}
+
+int wl_wowl(uint32 flag)
+{
+	uint buf_len = 0;
+	char bufdata[WLC_IOCTL_SMLEN];
+	char CMD[CMD_MINSIZE];
+	int ret = -1;
+	uint32 wowl = 0;
+
+	wowl = flag;
+	memset(CMD, 0, sizeof(CMD));
+	snprintf(CMD, sizeof(CMD), "wowl 0x%x", wowl);
+
+	if (G_sys_exec) {
+		snprintf(CMD, sizeof(CMD), "%s %s", BRCM_TOOL, CMD);
+		system(CMD);
+		logi("CMD: %s\n", CMD);
+		return 0;
+	}
+
+	buf_len = wl_iovar_mkbuf("wowl", (char *)&wowl, sizeof(uint32),
+		bufdata, sizeof(bufdata), &ret);
+	if (ret) {
+		loge("Failed to build buffer, %s.\n", __FUNCTION__);
+		return -1;
+	}
+
+	ret = wl_ioctl(WLC_SET_VAR, bufdata, buf_len, 1);
+	if (!ret) {
+		logi("WOWL Flag: %s\n", CMD);
+	} else {
+		loge("WOWL Flag Failed: %s, %s\n", CMD, strerror(errno));
+	}
+	return ret;
+}
+
+int wl_wowl_activate(uint32 is_enable)
+{
+	uint buf_len = 0;
+	char bufdata[WLC_IOCTL_SMLEN];
+	char CMD[CMD_MINSIZE];
+	int ret = -1;
+
+	uint32 wowl_activate = is_enable;
+	memset(CMD, 0, sizeof(CMD));
+	snprintf(CMD, sizeof(CMD), "wowl_activate %u", wowl_activate);
+
+	if (G_sys_exec) {
+		snprintf(CMD, sizeof(CMD), "%s %s", BRCM_TOOL, CMD);
+		system(CMD);
+		logi("CMD: %s\n", CMD);
+		return 0;
+	}
+
+	buf_len = wl_iovar_mkbuf("wowl_activate", (char *)&wowl_activate, sizeof(uint32),
+		bufdata, sizeof(bufdata), &ret);
+	if (ret) {
+		loge("Failed to build buffer, %s.\n", __FUNCTION__);
+		return -1;
+	}
+
+	ret = wl_ioctl(WLC_SET_VAR, bufdata, buf_len, 1);
+	if (!ret) {
+		logi("WOWL Active: %s\n", CMD);
+	} else {
+		loge("WOWL Active Failed: %s, %s\n", CMD, strerror(errno));
+	}
+	return ret;
+}
+
+int wl_wowl_clear(void)
+{
+	uint buf_len = 0;
+	char bufdata[WLC_IOCTL_SMLEN];
+	char CMD[CMD_MINSIZE];
+	int ret = -1;
+
+	memset(CMD, 0, CMD_MINSIZE);
+	snprintf(CMD, sizeof(CMD), "wowl_clear");
+
+	if (G_sys_exec) {
+		snprintf(CMD, sizeof(CMD), "%s %s", BRCM_TOOL, CMD);
+		system(CMD);
+		logi("CMD: %s\n", CMD);
+		return 0;
+	}
+
+	buf_len = wl_iovar_mkbuf("wowl_clear", NULL, 0, bufdata, sizeof(bufdata), &ret);
+	if (ret) {
+		loge("Failed to build buffer, %s.\n", __FUNCTION__);
+		return -1;
+	}
+
+	/* FIXME: why need add 4 byte more */
+	ret = wl_ioctl(WLC_SET_VAR, bufdata, buf_len + 4, 1);
+	if (!ret) {
+		logi("WOWL Clear: %s\n", CMD);
+	} else {
+		loge("WOWL Clear Failed: %s, %s\n", CMD, strerror(errno));
+	}
+	return ret;
+}
+
+/*  UDP Keep alive */
+int wl_mkeep_alive(uint8 sess_id, uint32 interval, uint32 length, const u_char *packet)
+{
+	uint buf_len = 0;
+	char bufdata[WLC_IOCTL_MEDLEN];
+	char CMD[CMD_MAXSIZE];
+	char CMD_BAK[CMD_MAXSIZE];
+
+	const char *str;
+	wl_mkeep_alive_pkt_t  mkeep_alive_pkt;
+	wl_mkeep_alive_pkt_t  *p_mkeep_alive_pkt;
+	uint str_len = 0;
+	int ret = -1;
+	int i = 0;
+
+	memset(CMD, 0, sizeof(CMD));
+	memset(CMD_BAK, 0, sizeof(CMD));
+	snprintf(CMD, sizeof(CMD), "mkeep_alive %u %u", sess_id, interval * 1000);
+	strcat(CMD, " 0x");
+	for (i = 0; i < length; i++) {
+		strcpy(CMD_BAK, CMD);
+		snprintf(CMD, sizeof(CMD), "%s%02x", CMD_BAK, packet[i]);
+	}
+
+	if (G_sys_exec) {
+		snprintf(CMD, sizeof(CMD), "%s %s", BRCM_TOOL, CMD);
+		system(CMD);
+		logi("CMD: %s\n", CMD);
+		return 0;
+	}
+
+	str = "mkeep_alive";
+	str_len = strlen(str);
+	strncpy(bufdata, str, str_len);
+	bufdata[ str_len ] = '\0';
+	buf_len = str_len + 1;
+	p_mkeep_alive_pkt = (wl_mkeep_alive_pkt_t *) (bufdata + str_len + 1);
+
+	memset(&mkeep_alive_pkt, 0, sizeof(wl_mkeep_alive_pkt_t));
+	mkeep_alive_pkt.period_msec = interval * 1000; // milliseconds
+	mkeep_alive_pkt.version = WL_MKEEP_ALIVE_VERSION;
+	mkeep_alive_pkt.length = WL_MKEEP_ALIVE_FIXED_LEN;
+	mkeep_alive_pkt.keep_alive_id = sess_id;
+	mkeep_alive_pkt.len_bytes = length;
+	memcpy(p_mkeep_alive_pkt->data, packet, length);
+	buf_len += WL_MKEEP_ALIVE_FIXED_LEN + mkeep_alive_pkt.len_bytes;
+	memcpy((char *)p_mkeep_alive_pkt, &mkeep_alive_pkt, WL_MKEEP_ALIVE_FIXED_LEN);
+
+	ret = wl_ioctl(WLC_SET_VAR, bufdata, buf_len, 0);
+	if (!ret) {
+		logi("UDP KeepAlive: %s\n", CMD);
+	} else {
+		loge("UDP KeepAlive Failed: %s, %s\n", CMD, strerror(errno));
+	}
+	return ret;
+}
+
+int wl_pkt_filter_add(int id, int offset, char *mask, char *filter_pattern)
+{
+	uint buf_len = 0;
+	char bufdata[WLC_IOCTL_SMLEN];
+	char CMD[CMD_MINSIZE];
+
+	const char *str;
+	char *pattern;
+	wl_pkt_filter_t	 pkt_filter;
+	wl_pkt_filter_t	 *pkt_filterp;
+	uint32 mask_size = 0;
+	uint32 pattern_size = 0;
+	int ret = -1;
+	int str_len = 0;
+
+	/* wl pkt_filter_add 200 0 0 36 0xffff 0x1EC5 : Receive UDP from port 7877 */
+	str = "pkt_filter_add";
+	str_len = strlen(str);
+	strncpy(bufdata, str, str_len);
+	bufdata[ str_len ] = '\0';
+	buf_len = str_len + 1;
+	pkt_filterp = (wl_pkt_filter_t *) (bufdata + str_len + 1);
+
+	pkt_filter.id = id;
+	pkt_filter.negate_match = 0;
+	pkt_filter.type = 0;
+	pkt_filter.u.pattern.offset = offset;
+
+	mask_size = (strlen(mask) -2)/2;
+	wl_pattern_atoh(mask, (char*) pkt_filterp->u.pattern.mask_and_pattern);
+	pattern = filter_pattern;
+	pattern_size = (strlen(pattern)-2)/2;
+	wl_pattern_atoh(pattern, (char*) &pkt_filterp->u.pattern.mask_and_pattern[mask_size]);
+
+	pkt_filter.u.pattern.size_bytes = pattern_size;
+	buf_len += WL_PKT_FILTER_FIXED_LEN;
+	buf_len += (WL_PKT_FILTER_PATTERN_FIXED_LEN + 2 * mask_size);
+
+	memcpy((char *)pkt_filterp, &pkt_filter,
+		WL_PKT_FILTER_FIXED_LEN + WL_PKT_FILTER_PATTERN_FIXED_LEN);
+
+	memset(CMD, 0, sizeof(CMD));
+	snprintf(CMD, sizeof(CMD), "pkt_filter_add %u %u %u %u %s %s", pkt_filter.id,
+		 pkt_filter.negate_match, pkt_filter.type, pkt_filter.u.pattern.offset, mask, filter_pattern);
+
+	if (G_sys_exec) {
+		snprintf(CMD, sizeof(CMD), "%s %s", BRCM_TOOL, CMD);
+		system(CMD);
+		logi("CMD: %s\n", CMD);
+		return 0;
+	}
+
+	ret = wl_ioctl(WLC_SET_VAR, bufdata, buf_len, 1);
+	if (!ret) {
+		logi("Pkt Filter Add: %s\n", CMD);
+	} else {
+		loge("Pkt Filter Add Failed: %s, %s\n", CMD, strerror(errno));
+		logw("Pkt Filter Add: filter_pattern[%d]=%s\n", strlen(pattern), pattern);
+	}
+	return ret;
+}
+
+int wl_pkt_filter_enable(uint32 id, uint32 is_enable)
+{
+	int ret = -1;
+	uint buf_len = 0;
+	char bufdata[WLC_IOCTL_SMLEN];
+	char CMD[CMD_MINSIZE];
+	wl_pkt_filter_enable_t enable_parm;
+
+	/* Init pkt_filter data */
+	enable_parm.id = id;
+	enable_parm.enable = is_enable;
+	memset(CMD, 0, sizeof(CMD));
+	snprintf(CMD, sizeof(CMD), "pkt_filter_enable %u %u", enable_parm.id, enable_parm.enable);
+
+	if (G_sys_exec) {
+		snprintf(CMD, sizeof(CMD), "%s %s", BRCM_TOOL, CMD);
+		system(CMD);
+		logi("CMD: %s\n", CMD);
+		return 0;
+	}
+
+	buf_len = wl_iovar_mkbuf("pkt_filter_enable", (char *)&enable_parm,
+		sizeof(wl_pkt_filter_enable_t), bufdata, sizeof(bufdata), &ret);
+	if (ret) {
+		loge("Failed to build buffer, %s.\n", __FUNCTION__);
+		return -1;
+	}
+	ret = wl_ioctl(WLC_SET_VAR, bufdata, buf_len, 1);
+	if (!ret){
+		logi("Pkt Filter Enable: %s\n", CMD);
+	} else {
+		loge("Pkt Filter Enable Failed: %s, %s\n", CMD, strerror(errno));
+	}
+	return ret;
+}
+
+int wl_pkt_filter_delete(uint32 id)
+{
+	uint buf_len = 0;
+	char bufdata[WLC_IOCTL_SMLEN];
+	char CMD[CMD_MINSIZE];
+	int ret = -1;
+
+	uint32 filter_id = id;
+	memset(CMD, 0, sizeof(CMD));
+	snprintf(CMD, sizeof(CMD), "pkt_filter_delete %u", filter_id);
+
+	if (G_sys_exec) {
+		snprintf(CMD, sizeof(CMD), "%s %s", BRCM_TOOL, CMD);
+		system(CMD);
+		logi("CMD: %s\n", CMD);
+		return 0;
+	}
+
+	buf_len = wl_iovar_mkbuf("pkt_filter_delete", (char *)&filter_id, sizeof(uint32),
+		bufdata, sizeof(bufdata), &ret);
+	if (ret) {
+		loge("Failed to build buffer, %s.\n", __FUNCTION__);
+		return -1;
+	}
+
+	ret = wl_ioctl(WLC_SET_VAR, bufdata, buf_len, 1);
+	if (!ret) {
+		logi("Pkt Filter Del: %s\n", CMD);
+	} else {
+		loge("Pkt Filter Del Failed: %s, %s\n", CMD, strerror(errno));
+	}
+	return ret;
+}
+
+int wl_pkt_filter_stats(uint32 id, wl_pkt_filter_stats_t *filter_stats)
+{
+	int ret = -1;
+	uint buf_len = 0;
+	char bufdata[WLC_IOCTL_SMLEN];
+	wl_pkt_filter_stats_t *stats = NULL;
+	uint32 filter_id;
+
+	filter_id = id;
+	buf_len = wl_iovar_mkbuf("pkt_filter_stats", (char *)&filter_id, sizeof(uint32),
+		bufdata, sizeof(bufdata), &ret);
+	if (ret) {
+		loge("Failed to build buffer, %s.\n", __FUNCTION__);
+		return -1;
+	}
+
+	ret = wl_ioctl(WLC_GET_VAR, bufdata, buf_len, 0);
+	if (!ret) {
+		stats = (wl_pkt_filter_stats_t *) bufdata;
+		filter_stats->num_pkts_matched = stats->num_pkts_matched;
+		filter_stats->num_pkts_discarded = stats->num_pkts_discarded;
+		filter_stats->num_pkts_forwarded = stats->num_pkts_forwarded;
+		logi("Pkt Filter State Get: Id [%d]: matched[%d], discarded[%d], forwarded[%d]\n", filter_id,
+			filter_stats->num_pkts_matched,
+			filter_stats->num_pkts_discarded,
+			filter_stats->num_pkts_forwarded);
+	} else {
+		loge("Pkt Filter State Get Failed: Id [%d], %s\n", filter_id, strerror(errno));
+	}
+
+	return ret;
+}
+
+int wl_set_get_pm_mode(int *mode, int is_set)
+{
+	int cmd_op = 0;
+	int power = 0;
+	int set = -1;
+	int ret = -1;
+
+	if (is_set) {
+		cmd_op = WLC_SET_PM;
+		set = 1;
+		power = *mode;
+	} else {
+		cmd_op = WLC_GET_PM;
+		set = 0;
+	}
+
+	ret = wl_ioctl(cmd_op, &power, sizeof(int), set);
+	if (!ret) {
+		if (is_set)
+			logi("PM Set [%d]\n", power);
+		else {
+			*mode = power;
+			logi("PM Get [%d]\n", *mode);
+		}
+	} else {
+		loge("PM %d [%d] Failed: %s\n", is_set, power, strerror(errno));
+	}
+	return ret;
+}
+
+int wl_set_get_host_sleep(int *sleep, int is_set)
+{
+	int buf_len = 0;
+	char bufdata[WLC_IOCTL_SMLEN];
+	int cmd_op = 0;
+	int mode = 0;
+	int set = 0;
+	int ret = -1;
+	int *p_value = NULL;
+
+	if (is_set) {
+		cmd_op = WLC_SET_VAR;
+		set = 1;
+		mode = *sleep;
+	} else {
+		cmd_op = WLC_GET_VAR;
+		set = 0;
+	}
+
+	buf_len = wl_iovar_mkbuf("hostsleep", (char *)&mode, sizeof(int),
+		bufdata, sizeof(bufdata), &ret);
+	if (ret) {
+		loge("Failed to build buffer, %s.\n", __FUNCTION__);
+		return -1;
+	}
+
+	ret = wl_ioctl(cmd_op, bufdata, buf_len, set);
+	if (!ret) {
+		if (is_set) {
+			logi("Hostsleep set [%d]\n", mode);
+		} else {
+			p_value = (int *)(&bufdata[0]);
+			*sleep = *p_value;
+			logi("Hostsleep get [%d]\n", *sleep);
+		}
+	} else {
+		loge("Hostsleep %d [%d] Failed: %s\n", is_set, *sleep, strerror(errno));
+	}
+	return ret;
+}
+
+int wl_set_get_host_cipher(uint8 *cipher_str, uint32 len, int is_set)
+{
+	uint buf_len = 0;
+	char bufdata[WLC_IOCTL_SMLEN];
+	int cmd_op = 0;
+	int ret = -1;
+	int set = 0;
+	int i = 0;
+	wlc_host_cipher_t cipher1;
+
+	memset(&cipher1, 0, sizeof(cipher1));
+	if (is_set) {
+		cmd_op = WLC_SET_VAR;
+		set = 1;
+		cipher1.len = len;
+		memcpy(&cipher1.payload[0], cipher_str, len);
+	} else {
+		cmd_op = WLC_GET_VAR;
+		set = 0;
+	}
+
+	buf_len = wl_iovar_mkbuf("host_cipher", (char *)&cipher1, sizeof(wlc_host_cipher_t),
+		bufdata, sizeof(bufdata), &ret);
+	if (ret) {
+		loge("Failed to build buffer, %s.\n", __FUNCTION__);
+		return -1;
+	}
+
+	ret = wl_ioctl(cmd_op, bufdata, buf_len, set);
+	if (!ret) {
+		if (is_set) {
+			logi("Host_cipher[%d]: Set OK\n", cipher1.len);
+		} else {
+			memcpy(&cipher1, bufdata, sizeof(wlc_host_cipher_t));
+			logi("Host_cipher[%d]: Get OK\n", cipher1.len);
+			logv("Host_cipher dump:\n");
+			for(i = 0; i < cipher1.len; i++) {
+				logv("%02x,", cipher1.payload[i]);
+				if((i + 1) % 8 == 0)
+					logv("\n");
+			}
+		}
+	} else {
+		loge("Host_cipher Failed: %d, %s\n", is_set, strerror(errno));
+	}
+	return ret;
+}
+
+int wl_get_ap_beacon_interval(int *ap_beacon_interval)
+{
+	int ret = -1;
+
+	ret = wl_ioctl(WLC_GET_BCNPRD, ap_beacon_interval, sizeof(int), 0);
+	if (!ret) {
+		logi("AP Beacon interval get [%d]\n", *ap_beacon_interval);
+	} else {
+		loge("AP Beacon interval get failed: %s\n", strerror(errno));
+	}
+	return ret;
+}
+
+int wl_get_ap_dtim(int *ap_dtim)
+{
+	int ret = -1;
+
+	ret = wl_ioctl(WLC_GET_DTIMPRD, ap_dtim, sizeof(int), 0);
+	if (!ret) {
+		logi("AP DTIM get [%d]\n", *ap_dtim);
+	} else {
+		loge("AP DTIM get failed: %s\n", strerror(errno));
+	}
+	return ret;
+}
+
+int wl_set_bcn_li_dtim(int bcn_li_dtim)
+{
+	int ret = -1;
+	uint buf_len = 0;
+	char bufdata[WLC_IOCTL_SMLEN];
+	char CMD[CMD_MINSIZE];
+
+	memset(CMD, 0, sizeof(CMD));
+	snprintf(CMD, sizeof(CMD), "bcn_li_dtim %d", bcn_li_dtim);
+
+	if (G_sys_exec) {
+		snprintf(CMD, sizeof(CMD), "%s %s", BRCM_TOOL, CMD);
+		system(CMD);
+		logi("CMD: %s\n", CMD);
+		return 0;
+	}
+
+	buf_len = wl_iovar_mkbuf("bcn_li_dtim", (char *)&bcn_li_dtim, sizeof(int),
+		bufdata, sizeof(bufdata), &ret);
+	if (ret) {
+		printf("Failed to build buffer, %s.\n", __FUNCTION__);
+		return -1;
+	}
+
+	ret = wl_ioctl(WLC_SET_VAR, bufdata, buf_len, 1);
+	if (!ret) {
+		logi("Bcn li DTIM set: %s\n", CMD);
+	} else {
+		loge("Bcn li DTIM set failed: %s, %s\n", CMD, strerror(errno));
+	}
+	return ret;
+}
+
+int wl_set_dtim_interval(int dtim_interval)
+{
+	int ret = -1;
+	int ap_beacon_interval = 100;
+	int ap_dtim = 1;
+	int sta_bcn_li_dtim = 3;
+
+	ret = wl_get_ap_beacon_interval(&ap_beacon_interval);
+	if (ret) {
+		loge("Get AP bi failed\n");
+	}
+	ret = wl_get_ap_dtim(&ap_dtim);
+	if (ret) {
+		loge("Get AP dtim failed\n");
+	}
+	if ((ap_beacon_interval == 0) || (ap_dtim == 0)) {
+		logw("Get AP beacon abnormal. ap_beacon_interval[%d], ap_dtim[%d]\n",
+			ap_beacon_interval, ap_dtim);
+		return -1;
+	}
+
+	sta_bcn_li_dtim = (int)(dtim_interval/( ap_beacon_interval * ap_dtim));
+	if (sta_bcn_li_dtim > 0) {
+		ret = wl_set_bcn_li_dtim(sta_bcn_li_dtim);
+	}
+	logd("ap_beacon_interval[%d], ap_dtim[%d], bcn_li_dtim[%d]. Result: DTIM Interval is [%d] ms\n",
+		ap_beacon_interval, ap_dtim, sta_bcn_li_dtim, (sta_bcn_li_dtim) ?
+		 (ap_beacon_interval * ap_dtim * sta_bcn_li_dtim):(ap_beacon_interval * ap_dtim));
+
+	return ret;
+}
+
+void brcm_ioc_wowl_init(const char* iface, wifi_chip_t chip, int sys_exec)
+{
+	logi("BRCM Ioctl Library Version: %s, Compile time: %s\n", BRCM_IOCTL_VERSION, __TIME__);
+
+	strncpy(G_iface, iface, sizeof(G_iface));
+	G_brcm_chip = chip;
+	G_sys_exec = sys_exec;
+
+	logi("BRCM Ioctl Library Config: Iface[%s], Chip[%d], Exec[%d].\n",
+		G_iface, G_brcm_chip, G_sys_exec);
+}
+
diff --git a/wowl/brcm/inc/brcm_ioc.h b/wowl/brcm/inc/brcm_ioc.h
new file mode 100644
index 0000000..a655d36
--- /dev/null
+++ b/wowl/brcm/inc/brcm_ioc.h
@@ -0,0 +1,259 @@
+/*******************************************************************************
+ * brcm_ioc.h
+ *
+ * History:
+ *    2015/8/8 - [Tao Wu] Create
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ( "Software" ) are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+******************************************************************************/
+
+#ifndef _BRCM_IOCTL_H_
+#define _BRCM_IOCTL_H_
+
+#include <log_level.h>
+#include <net_util.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <brcm_types.h>
+
+#define BRCM_IOCTL_VERSION	"1.0.5"
+#define BRCM_TOOL		"wl"
+
+#define CMD_MAXSIZE		(512)
+#define CMD_MINSIZE		(128)
+
+#define WLC_IOCTL_MAXLEN	(8192)	/* max length ioctl buffer required */
+#define WLC_IOCTL_SMLEN	(256)	/* "small" length ioctl buffer required */
+#define WLC_IOCTL_MEDLEN	(1536)    /* "med" length ioctl buffer required */
+
+#define WLC_GET_VAR		(262)
+#define WLC_SET_VAR		(263)
+
+#define WLC_GET_VERSION	(1)
+#define WLC_GET_REVINFO	(98)
+
+#define WLC_GET_BCNPRD	(75)
+#define WLC_GET_DTIMPRD	(77)
+
+#define WLC_GET_PM			(85)
+#define WLC_SET_PM			(86)
+
+/* Linux network driver ioctl encoding */
+typedef struct wl_ioctl {
+	uint cmd;	/* common ioctl definition */
+	void *buf;	/* pointer to user buffer */
+	uint len;		/* length of user buffer */
+	unsigned char set;		/* 1=set IOCTL; 0=query IOCTL */
+	uint used;	/* bytes read or written (optional) */
+	uint needed;	/* bytes needed (optional) */
+} wl_ioctl_t;
+
+#pragma pack(4)
+typedef struct tcpka_conn {
+	uint32 sess_id;
+	struct ether_addr dst_mac; /* Destinition Mac */
+	struct ipv4_addr  src_ip;   	/* Sorce IP */
+	struct ipv4_addr  dst_ip;   	/* Destinition IP */
+
+	uint16 ipid;		/* Ip Identification */
+	uint16 srcport;	/* Source Port Address */
+	uint16 dstport;	/* Destination Port Address */
+	uint32 seq;		/* TCP Sequence Number */
+	uint32 ack;		/* TCP Ack Number */
+	uint16 tcpwin;	/* TCP window */
+	uint32 tsval;		/* Timestamp Value */
+	uint32 tsecr;		/* Timestamp Echo Reply */
+	uint32 len;                /* last packet payload len */
+	uint32 ka_payload_len;     /* keep alive payload length */
+	uint8  ka_payload[1];      /* keep alive payload */
+} tcpka_conn_t;
+
+#pragma pack(1)
+typedef struct wl_mtcpkeep_alive_timers_pkt {
+	uint16 interval;		/* interval timer, unit: senconds */
+	uint16 retry_interval;	/* retry_interval timer */
+	uint16 retry_count;	/* retry_count */
+} wl_mtcpkeep_alive_timers_pkt_t;
+
+typedef struct tcpka_conn_sess_ctl {
+	uint32 sess_id;	/* session id */
+	uint32 flag;		/* enable/disable flag */
+} tcpka_conn_sess_ctl_t;
+
+typedef struct tcpka_conn_sess {
+	uint32 sess_id;	/* session id */
+	uint32 flag;		/* enable/disable flag */
+	wl_mtcpkeep_alive_timers_pkt_t  tcp_keepalive_timers;
+} tcpka_conn_sess_t;
+
+#define WL_PKT_FILTER_FIXED_LEN		  OFFSETOF(wl_pkt_filter_t, u)
+#define WL_PKT_FILTER_PATTERN_FIXED_LEN	  OFFSETOF(wl_pkt_filter_pattern_t, mask_and_pattern)
+
+typedef enum {
+	wowl_pattern_type_bitmap = 0,
+	wowl_pattern_type_arp,
+	wowl_pattern_type_na
+} wowl_pattern_type_t;
+
+typedef struct wl_wowl_pattern_s {
+	uint		masksize;	/* Size of the mask in #of bytes */
+	uint		offset;		/* Pattern byte offset in packet */
+	uint		patternoffset;/* Offset of start of pattern in the structure */
+	uint		patternsize;	/* Size of the pattern itself in #of bytes */
+	ulong	id;			/* id */
+	uint		reasonsize;	/* Size of the wakeup reason code */
+	//wowl_pattern_type_t type;		/* Type of pattern */
+	/* Mask follows the structure above */
+	/* Pattern follows the mask is at 'patternoffset' from the start */
+} wl_wowl_pattern_t;
+
+typedef struct wl_wowl_pattern_s_bcm43438 {
+	uint		masksize;	/* Size of the mask in #of bytes */
+	uint		offset;		/* Pattern byte offset in packet */
+	uint		patternoffset;/* Offset of start of pattern in the structure */
+	uint		patternsize;	/* Size of the pattern itself in #of bytes */
+	ulong	id;			/* id */
+	uint		reasonsize;	/* Size of the wakeup reason code */
+	wowl_pattern_type_t type;		/* Type of pattern */
+	/* Mask follows the structure above */
+	/* Pattern follows the mask is at 'patternoffset' from the start */
+} wl_wowl_pattern_t_bcm43438;
+
+#define	OFFSETOF(type, member)	((uint)(uintptr)&((type *)0)->member)
+typedef struct wl_mkeep_alive_pkt {
+	uint16	version;		/* Version for mkeep_alive */
+	uint16	length;		/* length of fixed parameters in the structure */
+	uint32	period_msec;/* milliseconds */
+	uint16	len_bytes;
+	uint8	keep_alive_id; /* 0 - 3 for N = 4 */
+	uint8	data[1];
+} wl_mkeep_alive_pkt_t;
+
+#define WL_MKEEP_ALIVE_VERSION		1
+#define WL_MKEEP_ALIVE_FIXED_LEN	OFFSETOF(wl_mkeep_alive_pkt_t, data)
+typedef struct wl_pkt_filter_pattern {
+	uint32	offset;	/* Offset within received packet to start pattern matching.
+					 * Offset '0' is the first byte of the ethernet header.*/
+	uint32	size_bytes;	/* Size of the pattern.  Bitmask must be the same size. */
+	uint8   mask_and_pattern[1]; /* Variable length mask and pattern data.  mask starts
+								* at offset 0.  Pattern immediately follows mask.*/
+} wl_pkt_filter_pattern_t;
+
+typedef struct wl_pkt_filter {
+	uint32	id;		/* Unique filter id, specified by app. */
+	uint32	type;	/* Filter type (WL_PKT_FILTER_TYPE_xxx). */
+	uint32	negate_match;	/* Negate the result of filter matches */
+	union {			/* Filter definitions */
+		wl_pkt_filter_pattern_t pattern;	/* Pattern matching filter */
+	} u;
+} wl_pkt_filter_t;
+
+#define WL_PKT_FILTER_FIXED_LEN		  OFFSETOF(wl_pkt_filter_t, u)
+#define WL_PKT_FILTER_PATTERN_FIXED_LEN	  OFFSETOF(wl_pkt_filter_pattern_t, mask_and_pattern)
+typedef struct wl_pkt_filter_enable {
+	uint32	id;		/* Unique filter id */
+	uint32	enable;	/* Enable/disable bool */
+} wl_pkt_filter_enable_t;
+
+typedef struct wl_pkt_filter_stats {
+	uint32	num_pkts_matched;		/* # filter matches for specified filter id */
+	uint32	num_pkts_forwarded;	/* # packets fwded from dongle to host for all filters */
+	uint32	num_pkts_discarded;	/* # packets discarded by dongle for all filters */
+} wl_pkt_filter_stats_t;
+
+typedef struct tcpka_conn_info {
+	uint32 tcpka_sess_ipid;
+	uint32 tcpka_sess_seq;
+	uint32 tcpka_sess_ack;
+} tcpka_conn_sess_info_t;
+
+#pragma pack(4)
+
+#define WL_WOWL_MAGIC	(1 << 0)	/* Wakeup on Magic packet */
+#define WL_WOWL_NET	(1 << 1)	/* Wakeup on Netpattern */
+#define WL_WOWL_DIS	(1 << 2)	/* Wakeup on loss-of-link due to Disassoc/Deauth */
+#define WL_WOWL_RETR	(1 << 3)	/* Wakeup on retrograde TSF */
+#define WL_WOWL_BCN	(1 << 4)	/* Wakeup on loss of beacon */
+#define WL_WOWL_BCAST	(1 << 15)	/* If the bit is set, frm received was bcast frame */
+#define WL_WOWL_TCPKEEP_TIME    (1 << 17)   /* Wakeup on tcpkeep alive timeout */
+#define WL_WOWL_TCPKEEP_DATA    (1 << 20)   /* tcp keepalive got data */
+#define WL_WOWL_TCPFIN                  (1 << 26)   /* tcp keepalive got FIN */
+
+typedef struct wl_wowl_wakeind {
+	uint32	pci_wakeind;	/* Whether PCI PMECSR PMEStatus bit was set */
+	uint32	ucode_wakeind;	/* What wakeup-event indication was set by ucode */
+} wl_wowl_wakeind_t;
+
+#define MAX_CIPHER_LEN (64)
+typedef struct wlc_host_cipher {
+    int len;
+    uint8 payload[MAX_CIPHER_LEN];
+}wlc_host_cipher_t;
+
+int wl_tcpka_conn_add(tcpka_conn_t *p_tcpka);
+int wl_tcpka_conn_enable(uint32 sess_id, uint32 is_enable,
+	uint16 itrvl, uint16 retry_itrvl, uint16 rety_cnt);
+int wl_tcpka_conn_sess_info(uint sess_id, tcpka_conn_sess_info_t *tcpka_sess_info);
+int wl_tcpka_conn_del(uint sess_id);
+
+int wl_wowl_pattern_bcm43340(int offset, char *mask, char *wowl_pattern);
+int wl_wowl_pattern_bcm43438(int offset, char *mask, char *wowl_pattern);
+int wl_wowl_pattern(int offset, char *mask, char *wowl_pattern);
+int wl_wowl_pattern_clr(void);
+int wl_wowl_wakeind(wl_wowl_wakeind_t *wakeind);
+int wl_wowl_wakeind_clear(void);
+
+int wl_wowl(uint32 flag);
+int wl_wowl_activate(uint32 is_enable);
+int wl_wowl_clear(void);
+
+int wl_mkeep_alive(uint8 sess_id, uint32 interval, uint32 length, const u_char *packet);
+int wl_pkt_filter_add(int id, int offset, char *mask, char *filter_pattern);
+int wl_pkt_filter_enable(uint32 id, uint32 is_enable);
+int wl_pkt_filter_delete(uint32 id);
+int wl_pkt_filter_stats(uint32 id, wl_pkt_filter_stats_t *filter_stats);
+
+int wl_set_get_pm_mode(int *mode, int is_set);
+int wl_set_get_host_sleep(int *sleep, int is_set);
+int wl_set_get_host_cipher(uint8 *cipher_str, uint32 len, int is_set);
+
+int wl_get_ap_beacon_interval(int *ap_beacon_interval);
+int wl_get_ap_dtim(int *ap_dtim);
+int wl_set_bcn_li_dtim(int bcn_li_dtim);
+int wl_set_dtim_interval(int dtim_interval);
+
+void brcm_ioc_wowl_init(const char* iface, wifi_chip_t chip, int sys_exec);
+
+#pragma pack()
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/wowl/brcm/inc/brcm_types.h b/wowl/brcm/inc/brcm_types.h
new file mode 100644
index 0000000..ee22317
--- /dev/null
+++ b/wowl/brcm/inc/brcm_types.h
@@ -0,0 +1,45 @@
+/*******************************************************************************
+ * brcm_types.h
+ *
+ * History:
+ *    2015/8/8 - [Tao Wu] Create
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ( "Software" ) are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+******************************************************************************/
+
+#ifndef _BRCM_TYPES_H_
+#define _BRCM_TYPES_H_
+
+//typedef unsigned char	bool;
+//typedef unsigned char	u8;
+typedef unsigned char	uint8;	/**< UNSIGNED 8-bit data type */
+typedef unsigned short	uint16;/**< UNSIGNED 16-bit data type */
+typedef unsigned int	uint;	/**< UNSIGNED 32-bit data type */
+typedef unsigned int 	uint32;/**< UNSIGNED 32-bit data type */
+typedef signed int		int32;	/**< SIGNED 32-bit data type */
+typedef unsigned int	uintptr;
+
+#endif
diff --git a/wowl/inc/log_level.h b/wowl/inc/log_level.h
new file mode 100644
index 0000000..df46c56
--- /dev/null
+++ b/wowl/inc/log_level.h
@@ -0,0 +1,96 @@
+/*******************************************************************************
+ * log_level.h
+ *
+ * History:
+ *    2015/8/8 - [Tao Wu] Create
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ( "Software" ) are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+******************************************************************************/
+
+#ifndef __LOG_LEVEL_H_
+#define __LOG_LEVEL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef enum {
+	LOG_ERROR = 0,
+	LOG_WARN,
+	LOG_INFO,
+	LOG_DEBUG,
+	LOG_VERBOSE,
+
+	LOG_LEVEL_NUM,
+	LOG_LEVEL_FIRST = LOG_ERROR,
+	LOG_LEVEL_LAST =  LOG_VERBOSE,
+} log_level_t;
+
+static log_level_t G_current_level = LOG_INFO;
+
+#define log_print(_level_, _str_, _arg_...) do {\
+	if (_level_ <= G_current_level ) {\
+		printf(_str_, ##_arg_);	\
+	}							\
+}while(0)
+
+#define loge(_str_, _arg_...) do {		\
+	log_print(LOG_ERROR, _str_, ##_arg_);\
+}while(0)
+
+#define logw(_str_, _arg_...) do {		\
+	log_print(LOG_WARN, _str_, ##_arg_);\
+}while(0)
+
+#define logi(_str_, _arg_...) do {		\
+	log_print(LOG_INFO, _str_, ##_arg_); \
+}while(0)
+
+#define logd(_str_, _arg_...) do {		\
+	log_print(LOG_DEBUG, _str_, ##_arg_);\
+}while(0)
+
+#define logv(_str_, _arg_...) do {		\
+	log_print(LOG_VERBOSE, _str_, ##_arg_);\
+}while(0)
+
+void set_log_level(int level)
+{
+	G_current_level = level;
+	printf("Log Level Set: %d\n", G_current_level);
+}
+
+int get_log_level(void)
+{
+	printf("Log Level Get: %d\n", G_current_level);
+	return G_current_level;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/wowl/inc/net_util.h b/wowl/inc/net_util.h
new file mode 100644
index 0000000..85d9dc6
--- /dev/null
+++ b/wowl/inc/net_util.h
@@ -0,0 +1,169 @@
+/*******************************************************************************
+ * net_util.h
+ *
+ * History:
+ *    2015/8/8 - [Tao Wu] Create
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ( "Software" ) are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+******************************************************************************/
+
+#ifndef __NET_UTIL_H_
+#define __NET_UTIL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <basetypes.h>
+#include <unistd.h>
+
+#define SET_TCP_FIX		(0xBADBEEF) /* Fix TCP Session Ipid, Seq, Ack */
+
+#define TCP_PL_OFFSET 	(66)	 /* 66 is the offset of TCP payload */
+#define UDP_PL_OFFSET 	(42)	 /* 42 is the offset of UDP payload */
+
+#define IPV4_ADDR_STR_LEN (32)
+#define IPV4_ADDR_LEN		(4)
+#define IPV4_PORT_LEN			(2)
+
+typedef enum {
+	WIFI_BCM43340 = 0,
+	WIFI_BCM43438 = 1,
+
+	WIFI_SD8977 = 10,
+	WIFI_SD8801 = 11,
+
+	WIFI_CHIP_TOTAL,
+	WIFI_CHIP_FIRST = WIFI_BCM43340,
+	WIFI_CHIP_LAST = WIFI_SD8801,
+} wifi_chip_t;
+
+typedef struct ipv4_addr {
+        u8   addr[IPV4_ADDR_LEN];
+} ipv4_addr_t;
+
+typedef struct ipv4_port {
+        u8   data[IPV4_PORT_LEN];
+} ipv4_port_t;
+
+char *iptoa(const struct ipv4_addr *n)
+{
+	static char iptoa_buf[IPV4_ADDR_LEN * 4];
+	sprintf(iptoa_buf, "%u.%u.%u.%u", n->addr[0], n->addr[1], n->addr[2], n->addr[3]);
+
+	return iptoa_buf;
+}
+
+int atoip(const char *a, struct ipv4_addr *n)
+{
+	char *c = NULL;
+	int i = 0;
+
+	for (;;) {
+		n->addr[i++] = (u8)strtoul(a, &c, 0);
+		if (*c++ != '.' || i == IPV4_ADDR_LEN)
+			break;
+		a = c;
+	}
+
+	return (i == IPV4_ADDR_LEN);
+}
+
+void in_addr_to_ipv4(struct ipv4_addr *ipa, u32 ip)
+{
+	ipa->addr[0] = (u8)(ip >> 0) & 0xFF;
+	ipa->addr[1] = (u8)(ip >> 8) & 0xFF;
+	ipa->addr[2] = (u8)(ip >> 16) & 0xFF;
+	ipa->addr[3] = (u8)(ip >> 24) & 0xFF;
+}
+
+ssize_t readn( int inSock, void *outBuf, size_t inLen )
+{
+	size_t  nleft = 0;
+	ssize_t nread = 0;
+	char *ptr;
+
+	assert( inSock >= 0 );
+	assert( outBuf != NULL );
+	assert( inLen > 0 );
+
+	ptr   = (char*) outBuf;
+	nleft = inLen;
+
+	while ( nleft > 0 ) {
+		nread = read( inSock, ptr, nleft );
+		if ( nread < 0 ) {
+			if ( errno == EINTR ) {
+				nread = 0;  /* interupted, call read again */
+			}
+			else{
+				return -1;  /* error */
+			}
+		} else if ( nread == 0 ) {
+			break;        /* EOF */
+		}
+		nleft -= nread;
+		ptr   += nread;
+	}
+
+	return(inLen - nleft);
+} /* end readn */
+
+ssize_t writen( int inSock, const void *inBuf, size_t inLen )
+{
+	size_t  nleft = 0;
+	ssize_t nwritten = 0;
+	const char *ptr;
+
+	assert( inSock >= 0 );
+	assert( inBuf != NULL );
+	assert( inLen > 0 );
+
+	ptr   = (char*) inBuf;
+	nleft = inLen;
+
+	while ( nleft > 0 ) {
+		nwritten = write( inSock, ptr, nleft );
+		if ( nwritten <= 0 ) {
+			if ( errno == EINTR ) {
+				nwritten = 0; /* interupted, call write again */
+			} else {
+				return -1;    /* error */
+			}
+		}
+
+		nleft -= nwritten;
+		ptr   += nwritten;
+	}
+
+	return inLen;
+} /* end writen */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/wowl/make.inc b/wowl/make.inc
new file mode 100644
index 0000000..e356135
--- /dev/null
+++ b/wowl/make.inc
@@ -0,0 +1,129 @@
+##
+## app/ipcam/wowl/make.inc
+##
+## History:
+##    2015/04/03 - [Tao Wu] Created file
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+ifeq ($(BUILD_AMBARELLA_APP_WIFI_UTILITY), y)
+
+WOWL_PATH   := $(call my-dir)
+
+WOWL_APP_DIR = $(FAKEROOT_DIR)/usr/bin
+WOWL_LIB_DIR = $(FAKEROOT_DIR)/usr/lib
+
+#################################
+
+ifeq ($(BUILD_AMBARELLA_APP_WIFI_LIBRARY_BRCM), y)
+
+include $(CLEAR_VARS)
+
+LOCAL_TARGET	:= libbrcmioc.so
+LOCAL_SRCS	:= $(WOWL_PATH)/brcm/brcm_ioc.c
+LOCAL_CFLAGS 	:= -I$(WOWL_PATH)/inc \
+		-I$(WOWL_PATH)/brcm/inc
+
+LOCAL_SO_NAME := $(LOCAL_TARGET)
+
+include $(BUILD_APP)
+
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(WOWL_LIB_DIR)/
+	@cp -dpRf $< $(WOWL_LIB_DIR)/
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+
+endif ## BUILD_AMBARELLA_APP_WIFI_LIBRARY_BRCM
+
+#################################
+
+ifeq ($(BUILD_AMBARELLA_APP_WIFI_LIBRARY_MRVL), y)
+
+include $(CLEAR_VARS)
+
+LOCAL_TARGET	:= libmrvlioc.so
+LOCAL_SRCS	:= $(WOWL_PATH)/mrvl/mrvl_ioc.c
+LOCAL_CFLAGS 	:= -I$(WOWL_PATH)/inc \
+		-I$(WOWL_PATH)/mrvl/inc
+
+LOCAL_SO_NAME := $(LOCAL_TARGET)
+
+include $(BUILD_APP)
+
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(WOWL_LIB_DIR)/
+	@cp -dpRf $< $(WOWL_LIB_DIR)/
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+
+endif ## BUILD_AMBARELLA_APP_WIFI_LIBRARY_MRVL
+
+#################################
+
+ifeq ($(BUILD_AMBARELLA_APP_WIFI_WOWL), y)
+
+include $(CLEAR_VARS)
+
+LOCAL_TARGET	:= wowl
+LOCAL_CFLAGS 	:= -I$(WOWL_PATH)/inc \
+		-I$(PREBUILD_3RD_PARTY_DIR)/libpcap/include
+
+ifeq ($(BUILD_AMBARELLA_APP_WIFI_WOWL_BRCM), y)
+LOCAL_SRCS	:= $(WOWL_PATH)/wowl.c
+LOCAL_LIBS   	:= libbrcmioc.so
+LOCAL_CFLAGS 	+= -I$(WOWL_PATH)/brcm/inc
+else ifeq ($(BUILD_AMBARELLA_APP_WIFI_WOWL_MRVL), y)
+LOCAL_SRCS	:= $(WOWL_PATH)/wowl_mrvl.c
+LOCAL_LIBS   	:= libmrvlioc.so
+LOCAL_CFLAGS 	+= -I$(WOWL_PATH)/mrvl/inc
+endif
+
+LOCAL_LDFLAGS 	:= -L$(PREBUILD_3RD_PARTY_DIR)/libpcap/usr/lib -lpcap \
+		-Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/libnl/usr/lib \
+		-Wl,-rpath-link=$(PREBUILD_3RD_PARTY_DIR)/dbus/usr/lib \
+		-lpthread
+
+include $(BUILD_APP)
+
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(WOWL_APP_DIR)/
+	@cp -dpRf $< $(WOWL_APP_DIR)/
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+
+endif ## BUILD_AMBARELLA_APP_WIFI_WOWL
+
+endif ## BUILD_AMBARELLA_APP_WIFI_UTILITY
diff --git a/wowl/net_socket.c b/wowl/net_socket.c
new file mode 100644
index 0000000..806ad8b
--- /dev/null
+++ b/wowl/net_socket.c
@@ -0,0 +1,1586 @@
+/*
+* History:
+*  2016/12/30 - [Tao Wu] Created file
+*
+* Copyright (c) 2016 Ambarella, Inc.
+*
+* This file and its contents ("Software") are protected by intellectual
+* property rights including, without limitation, U.S. and/or foreign
+* copyrights. This Software is also the confidential and proprietary
+* information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+* disclose, distribute, modify, or otherwise prepare derivative works of this
+* Software or any portion thereof except pursuant to a signed license agreement
+* or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+* In the absence of such an agreement, you agree to promptly notify and return
+* this Software to Ambarella, Inc.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+* MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+* POSSIBILITY OF SUCH DAMAGE.
+*
+*/
+
+#define __USE_BSD		/* Using BSD IP header 	*/
+#include <netinet/ip.h>	/* Internet Protocol 		*/
+#define __FAVOR_BSD	/* Using BSD TCP header	*/
+#include <netinet/tcp.h>	/* Transmission Control Protocol	*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <getopt.h>
+#include <errno.h>
+#include <signal.h>
+#include <time.h>
+#include <stdarg.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <netinet/if_ether.h>
+#include <arpa/inet.h>
+#include <linux/sockios.h>
+#include <sys/socket.h>
+
+#include <fcntl.h>
+#include <assert.h>
+#include <string.h>
+#include <pthread.h>
+#include  <time.h>
+
+typedef struct _iphdr
+{
+    unsigned char h_verlen;
+    unsigned char tos;
+    unsigned short total_len;
+    unsigned short ident;
+    unsigned short frag_and_flags;
+    unsigned char ttl;
+    unsigned char proto;
+    unsigned short checksum;
+    unsigned int sourceIP;
+    unsigned int destIP;
+}IP_HEADER;
+
+typedef struct _tcphdr
+{
+    unsigned short th_sport;
+    unsigned short th_dport;
+    unsigned int th_seq;
+    unsigned int th_ack;
+    unsigned char th_lenres;
+    unsigned char th_flag;
+    unsigned short th_win;
+    unsigned short th_sum;
+    unsigned short th_urp;
+}TCP_HEADER;
+
+//#define CONFIG_CURL 1
+
+#if CONFIG_CURL
+#include <curl/curl.h>
+#endif
+
+#define APP_VERSION	"1.0.1"
+
+#define DEFAULT_HOST	"127.0.0.1"
+#define DEFAULT_MSG	"*"
+#define DEFAULT_REPLY	"Reply Done"
+#define DEFAULT_QUIT	"q"
+
+#define STR_MAC		"MAC"
+#define STR_STATUS	"STATUS"
+
+#define POST_PATH 	"?object=device&action=update&backdoor=1"
+
+#define SERVER_IP 			"10.0.0.4"
+#define SERVER_PORT 		(80)
+#define DEVICE_IP			"10.0.0.100"
+#define DEVICE_PORT			(2048)
+#define DEVICE_MAC			"00:00:00:00:00:00"
+
+#define SUSPEND_INPUT		"suspend"
+#define SUSPEND_CMD		"echo mem > /sys/power/state"
+
+#define RESPONSE_FILE 		"response.xml"
+
+#define DEFAULT_PORT		(7877)
+#define DATA_MAXSIZE		(32)
+#define PAYLOAD_MAXSIZE 	(256)
+
+#define MAXCONN			(10)
+
+#define Conn(x, y) x##y
+#define ToString(x) #x
+
+#ifndef DIVIDING_LINE
+#define DIVIDING_LINE() do {	\
+	printf("-------------------------------------\n"); \
+} while(0)
+#endif
+
+#ifndef LOGT
+#define LOGT(str, arg...) do {	\
+	time_t timep;		\
+	time (&timep);	\
+	printf(str" [ %s", ##arg, ctime(&timep)); \
+} while(0)
+#endif
+
+#define CLOCKID CLOCK_MONOTONIC
+#define SIG SIGRTMIN
+
+typedef struct timer_info_s{
+	int timeout_seconds;
+	int timer_id_valid;
+	timer_t timer_id;
+	volatile int disconnect;
+} timer_info_t;
+
+typedef struct net_socket_s
+{
+	int is_close;
+	int is_server;
+	int is_tcp;
+	int is_tcpka;
+	int is_reply;
+	int is_auto_reply;
+	int is_update;
+	int is_resume;
+	int port;
+	int fd_net;
+	int fd_raw;
+	int fd_clnt;
+
+	timer_info_t client_timer;
+
+	char srv_ip[DATA_MAXSIZE];
+	char client_ip[DATA_MAXSIZE];
+
+	char send_msg[PAYLOAD_MAXSIZE];
+	char recv_msg[PAYLOAD_MAXSIZE];
+} net_socket_t;
+
+typedef struct thread_data_s
+{
+	int fd;
+	struct sockaddr_in addr;
+}thread_data_t;
+
+typedef struct auto_reply_s
+{
+	unsigned int interval_sencods;
+	int wakeup_times;
+	int unexpt_times;
+	int close_times;
+}auto_reply_t;
+
+typedef struct device_s
+{
+	int port;
+	int status;
+
+	char ip_addr[DATA_MAXSIZE];
+	char mac_addr[DATA_MAXSIZE];
+	char uid[DATA_MAXSIZE];
+} device_t;
+
+#if CONFIG_CURL
+typedef struct {
+	CURL 		*p_curl;
+} Context;
+#endif
+
+static net_socket_t net_socket;
+static auto_reply_t auto_reply;
+static auto_reply_t auto_curr;
+static thread_data_t timer_data;
+
+static int is_suspend = 0;
+static int running = 1;
+
+#if CONFIG_CURL
+static Context ctx;
+#endif
+
+#define NO_ARG		0
+#define HAS_ARG		1
+
+struct hint_s {
+	const char *arg;
+	const char *str;
+};
+
+static const char *short_options = "tusc:kp:m:ra:qed";
+
+static struct option long_options[] = {
+	{"server",	NO_ARG, 0, 's'},
+	{"client",		HAS_ARG, 0, 'c'},
+	{"tcp", 		NO_ARG, 0, 't'},
+	{"udp",		NO_ARG, 0,'u'},
+	{"keepalive", 		NO_ARG, 0, 'k'},
+	{"port",		HAS_ARG, 0, 'p'},
+	{"msg",		HAS_ARG, 0, 'm'},
+	{"reply",		NO_ARG, 0, 'r'},
+	{"auto",		HAS_ARG, 0, 'a'},
+	{"resume",	NO_ARG, 0, 'q'},
+	{"close",	NO_ARG, 0, 'e'},
+	{"update",	NO_ARG, 0, 'd'},
+
+	{0, 0, 0, 0}
+};
+
+static const struct hint_s hint[] = {
+	{"", "\trun in server mode"},
+	{"host", "run in client mode, connecting to [host]"},
+	{"",	"\tuse TCP"},
+	{"",	"\tuse UDP"},
+	{"", "\trun tcp keepalive, open raw socket. Use Root right"},
+	{"port", "server port to listen on/connect to, default is [7877]"},
+	{"",	"\tclient send messages to server, default is [" DEFAULT_MSG "]\n"\
+		"\t\t\t type ["DEFAULT_QUIT"] to quit process\n"\
+		"\t\t\t type ["SUSPEND_INPUT"] to suspend board\n"\
+		"\t\tserver used to suspend client"},
+	{"",	"\treply message"},
+	{"",	"\t server: auto reply client in timer <timer sencods>/<wake times>/<close times>/<unexpected times>\n"
+		"\t\t\t client: auto connect to server when dissconnected."},
+	{"",	"\treset IP/TCP header after resume, seq/ack "},
+	{"",	"\tclose fd after exit, it is disable by default"},
+	{"",	"\tupdate database via curl"},
+};
+
+static void usage(void)
+{
+	int i;
+	char *itself = "net_socket";
+	printf("Usage:\nThis program is used for send/receive net socket\n");
+	printf("net_socket version : %s, compile time : %s .\n", APP_VERSION, __TIME__);
+	printf("\n");
+	for (i = 0; i < sizeof(long_options) / sizeof(long_options[0]) - 1; i++) {
+		if (isalpha(long_options[i].val))
+			printf("-%c ", long_options[i].val);
+		else
+			printf("   ");
+		printf("--%s", long_options[i].name);
+		if (hint[i].arg[0] != 0)
+			printf(" [%s]", hint[i].arg);
+		printf("\t%s\n", hint[i].str);
+	}
+
+	printf("\nExample:\n");
+
+	printf("[TCP-KeepAlive]\tServer:\t# %s -s -k -p 7877 -r -e\n", itself);
+	printf("\tClient:\t# %s -k -c 127.0.0.1 -p 7877 -m Hi -r -e\n\n", itself);
+
+	printf("[TCP]\tServer:\t# %s -s -p 7877 -r -e\n", itself);
+	printf("\tClient:\t# %s -c 127.0.0.1 -p 7877 -m Hi -r -e [-q]\n\n", itself);
+
+	printf("Autoreply Server:# %s -s -p 7877 -a 18/10/5/1 -e\n", itself);
+	printf("Autoconn Client:# %s -c 127.0.0.1 -p 7877 -m Hi -r -a 1 -e \n\n", itself);
+
+	printf("[UDP]\tServer:\t# %s -s -u -p 7877 -r -e\n", itself);
+	printf("\tClient:\t# %s -c 127.0.0.1 -u -p 7877 -m Hi -r\n\n", itself);
+
+	printf("Autoreply Server:# %s -s -p 7877 -a 18/10/1/0 -e\n", itself);
+	printf("Autoconn Client:# %s -c 127.0.0.1 -p 7877 -m Hi -r -a 1 -e \n\n", itself);
+}
+
+static int init_param(int argc, char **argv)
+{
+	int ch, value;
+	int option_index = 0;
+	char auto_reply_str[256];
+	char *cut_str = NULL;
+
+	opterr = 0;
+	while ((ch = getopt_long(argc, argv, short_options, long_options, &option_index)) != -1) {
+		switch (ch) {
+		case 't':
+			net_socket.is_tcp = 1;
+			break;
+		case 'k':
+			net_socket.is_tcpka = 1;
+			break;
+		case 'u':
+			net_socket.is_tcp = 0;
+			break;
+		case 's':
+			net_socket.is_server = 1;
+			break;
+		case 'c':
+			net_socket.is_server = 0;
+			strncpy(net_socket.srv_ip, optarg, sizeof(net_socket.srv_ip));
+			break;
+		case 'p':
+			value = atoi(optarg);
+			if ((value < 0) || (value > 65535)) {
+				printf("Please set port in %d ~ %d.\n",
+					0, 65535);
+				return -1;
+			}
+			net_socket.port = value;
+			break;
+		case 'm':
+			strncpy(net_socket.send_msg, optarg, sizeof(net_socket.send_msg));
+			break;
+		case 'r':
+			net_socket.is_reply = 1;
+			break;
+		case 'a':
+			strncpy(auto_reply_str, optarg, sizeof(auto_reply_str));
+			if (strlen(auto_reply_str) >= 7) {
+				cut_str = strtok(auto_reply_str, "/");
+				auto_reply.interval_sencods = atoi(cut_str);
+				cut_str = strtok(NULL, "/");
+				auto_reply.wakeup_times = atoi(cut_str);
+				cut_str = strtok(NULL, "/");
+				auto_reply.unexpt_times= atoi(cut_str);
+				cut_str = strtok(NULL, "/");
+				auto_reply.close_times = atoi(cut_str);
+				printf("Auto Reply Param: interval[%u], wakeup[%u], close[%u], unexpected[%u]\n",
+					auto_reply.interval_sencods, auto_reply.wakeup_times,
+					auto_reply.unexpt_times, auto_reply.close_times);
+			}
+			net_socket.is_auto_reply = 1;
+			break;
+		case 'q':
+			net_socket.is_resume = 1;
+			break;
+		case 'e':
+			net_socket.is_close = 1;
+			break;
+		case 'd':
+			net_socket.is_update = 1;
+			break;
+		default:
+			printf("unknown option found: %c\n", ch);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static void close_fd(int *fd)
+{
+	if (net_socket.is_close && (*fd >= 0)) {
+		close(*fd);
+		printf("Close fd [%d].\n", *fd);
+		*fd = -1;
+	}
+}
+
+#if CONFIG_CURL
+/* Start of curl update database */
+
+static int ctx_init(Context *p_ctx)
+{
+	p_ctx->p_curl = curl_easy_init();
+	return ;
+}
+
+static void ctx_deinit(Context *p_ctx)
+{
+	curl_easy_cleanup(p_ctx->p_curl);
+}
+
+// for receive response
+static size_t write_callback(void *ptr, size_t size, size_t nmemb, void *stream)
+{
+	int len = size * nmemb;
+	int written = len;
+	FILE *fp = NULL;
+	if (access((char*) stream, 0) == -1) {
+		fp = fopen((char*) stream, "wb");
+	} else {
+		fp = fopen((char*) stream, "ab");
+	}
+	if (fp) {
+		fwrite(ptr, size, nmemb, fp);
+	}
+	// printf("%s\n",ptr);
+	fclose(fp);
+	return written;
+}
+
+static void device_udpate(Context *p_ctx, const char *server_ip, int server_port,
+	const char *mac, const char *ip, int port, int status)
+{
+	char buf[512];
+	char *p_str = buf;
+
+	int len = sprintf(p_str, "http://%s:%d%s", server_ip, server_port, POST_PATH);
+	p_str = p_str + len;
+
+	if (mac) {
+		len = sprintf(p_str, "&mac=%s", mac);
+		p_str += len;
+	}
+
+	if (ip) {
+		len = sprintf(p_str, "&ip=%s", ip);
+		p_str += len;
+	}
+
+	if (port > 0) {
+		len = sprintf(p_str, "&port=%d", port);
+		p_str += len;
+	}
+
+	if (status >= 0) {
+		len = sprintf(p_str, "&status=%d", status);
+		p_str += len;
+	}
+
+	curl_easy_setopt(p_ctx->p_curl, CURLOPT_URL, buf);
+	curl_easy_setopt(p_ctx->p_curl, CURLOPT_WRITEFUNCTION, write_callback);
+	curl_easy_setopt(p_ctx->p_curl, CURLOPT_WRITEDATA, RESPONSE_FILE);
+
+	CURLcode res = curl_easy_perform(p_ctx->p_curl);
+	if (res == CURLE_OK) {
+		printf("Curl OK: %s \n", buf);
+	} else {
+		printf("Curl ERROR: %s\n", buf);
+	}
+}
+/* END of curl update database */
+#endif
+
+static int parse_msg_device(const char *msg, device_t *dev)
+{
+	#define MAC_LEN 17
+
+	int ret = 0;
+	char *p_str = NULL;
+	char data[8];
+
+	p_str = strstr(msg, STR_MAC);
+	if (p_str) {
+		strncpy(dev->mac_addr, p_str + strlen(STR_MAC), MAC_LEN);
+	} else {
+		ret = -1;
+	}
+
+	p_str = strstr(msg, STR_STATUS);
+	if (p_str) {
+		memset(data, 0, sizeof(data));
+		strncpy(data, p_str + strlen(STR_STATUS), sizeof(data)-1);
+		dev->status = atoi(data);
+	} else {
+		ret = -1;
+	}
+
+	return ret;
+}
+
+/* -------------------------------------------------------------------
+ * Attempts to reads n bytes from a socket.
+ * Returns number actually read, or -1 on error.
+ * If number read < inLen then we reached EOF.
+ *
+ * from Stevens, 1998, section 3.9
+ * ------------------------------------------------------------------- */
+
+static ssize_t readn( int inSock, void *outBuf, size_t inLen )
+{
+    size_t  nleft;
+    ssize_t nread;
+    char *ptr;
+
+    assert( inSock >= 0 );
+    assert( outBuf != NULL );
+    assert( inLen > 0 );
+
+    ptr   = (char*) outBuf;
+    nleft = inLen;
+
+    while ( nleft > 0 ) {
+        nread = read( inSock, ptr, nleft );
+        if ( nread < 0 ) {
+            if ( errno == EINTR )
+                nread = 0;  /* interupted, call read again */
+            else
+                return -1;  /* error */
+        } else if ( nread == 0 )
+            break;        /* EOF */
+
+        nleft -= nread;
+        ptr   += nread;
+    }
+
+    return(inLen - nleft);
+} /* end readn */
+
+/* -------------------------------------------------------------------
+ * Attempts to write  n bytes to a socket.
+ * returns number actually written, or -1 on error.
+ * number written is always inLen if there is not an error.
+ *
+ * from Stevens, 1998, section 3.9
+ * ------------------------------------------------------------------- */
+
+static ssize_t writen( int inSock, const void *inBuf, size_t inLen )
+{
+    size_t  nleft;
+    ssize_t nwritten;
+    const char *ptr;
+
+    assert( inSock >= 0 );
+    assert( inBuf != NULL );
+    assert( inLen > 0 );
+
+    ptr   = (char*) inBuf;
+    nleft = inLen;
+
+    while ( nleft > 0 ) {
+        nwritten = write( inSock, ptr, nleft );
+        if ( nwritten <= 0 ) {
+            if ( errno == EINTR )
+                nwritten = 0; /* interupted, call write again */
+            else
+                return -1;    /* error */
+        }
+
+        nleft -= nwritten;
+        ptr   += nwritten;
+    }
+
+    return inLen;
+} /* end writen */
+
+static void auto_reply_action(int signo)
+{
+	int ret = -1;
+	int len = -1;
+	socklen_t sock_len = sizeof(struct sockaddr_in);
+	static unsigned int auto_susp_cnt = 0;
+
+	char msg[PAYLOAD_MAXSIZE];
+
+	if (signo != SIGALRM) {
+		return ;
+	}
+	if (!running) {
+		return;
+	}
+	if (timer_data.fd < 0) {
+		printf("Auto reply socket fd [%d] is invalid\n", timer_data.fd);
+		return ;
+	}
+
+	DIVIDING_LINE();
+	memset(msg, 0, sizeof(msg));
+	if (is_suspend) {
+		strncpy(msg, net_socket.send_msg, sizeof(msg));
+		printf("Auto Action (suspend) count [%u]\n", auto_susp_cnt++);
+	} else {
+		printf("Auto Action : wakeup [%u], unexpected [%u], close [%u]\n",
+			auto_curr.wakeup_times, auto_curr.unexpt_times, auto_curr.close_times);
+		if (auto_curr.wakeup_times > 0) {
+			strncpy(msg, "wake", sizeof(msg));
+			printf("Auto Action (wake) count [%u]\n", auto_curr.wakeup_times--);
+		} else if (auto_curr.unexpt_times > 0) {
+			strncpy(msg, "unexpt", sizeof(msg));
+			printf("Auto Action (unexpt) count [%u]\n", auto_curr.unexpt_times--);
+		} else if (auto_curr.close_times > 0) {
+			close_fd(&timer_data.fd);
+			printf("Auto Action (close) count [%u]\n", auto_curr.close_times--);
+			return;
+		}
+		if ((auto_curr.wakeup_times == 0) &&
+			(auto_curr.unexpt_times == 0) &&
+			(auto_curr.close_times == 0)) {
+			auto_curr = auto_reply;
+			printf("Auto Action Reload Timers\n");
+		}
+	}
+	is_suspend = ~is_suspend;
+	len = strlen(msg);
+	if (len < 1) {
+		return;
+	}
+	if (net_socket.is_tcp) {
+		ret = writen(timer_data.fd, msg, strlen(msg));
+	} else {
+		ret = sendto(timer_data.fd, msg, strlen(msg),
+			0, (struct sockaddr *)&(timer_data.addr), sock_len);
+	}
+	if (ret == strlen(msg)) {
+		printf("Auto Send [%s] Length [%d] OK\n", msg, ret);
+	} else {
+		perror("Auto Send");
+	}
+}
+
+static int set_timer(int sec, int usec)
+{
+	int ret = -1;
+	struct itimerval value, ovalue;
+
+	is_suspend = 0;
+	auto_curr = auto_reply;
+	signal(SIGALRM, auto_reply_action);
+	value.it_value.tv_sec = sec;
+	value.it_value.tv_usec = usec;
+	value.it_interval = value.it_value;
+	ret = setitimer(ITIMER_REAL, &value, &ovalue);
+	if (ret < 0) {
+		perror("setitimer");
+	} else {
+		printf("Set Timer: [%d] sec, [%d] usec done.\n", sec, usec);
+	}
+	return ret;
+}
+
+/* Created by Server */
+static void read_console_reply_send(const void *args)
+{
+	int ret = -1;
+	int len = -1;
+	char msg[PAYLOAD_MAXSIZE];
+	socklen_t sock_len = sizeof(struct sockaddr_in);
+	thread_data_t *pData = NULL;
+
+	printf("Create Reply Thread\n");
+	pData = (thread_data_t *)args;
+	if (pData->fd < 0) {
+		printf("Reply send fd [%d] is invalid\n", pData->fd);
+		return ;
+	}
+	memset(msg, 0, sizeof(msg));
+	while (running && (fgets(msg, sizeof(msg), stdin) != NULL)) {
+		len = strlen(msg);
+		if (len < 2) {
+			printf("Continue\n");
+			continue;
+		}
+		msg[len-1] = '\0';
+
+		if (strncmp(msg, DEFAULT_QUIT, sizeof(msg)) == 0) {
+			printf("Quit\n");
+			running = 0;
+			break;
+		} else if (strncmp(msg, SUSPEND_INPUT, sizeof(msg)) == 0) {
+			printf("Go to suspend mode\n");
+			printf("...\n");
+			system(SUSPEND_CMD);
+			//break;
+		}
+
+		if (net_socket.is_tcp) {
+			ret = writen(pData->fd, msg, strlen(msg));
+		} else {
+			ret = sendto(pData->fd, msg, strlen(msg), 0,
+				(struct sockaddr *)&(pData->addr), sock_len);
+		}
+
+		if (ret == strlen(msg)) {
+			printf("Reply Send [%s] Length [%d] OK\n", msg, ret);
+		} else {
+			perror("Reply Send");
+		}
+		memset(msg, 0, sizeof(msg));
+	}
+	printf("Exit Reply Thread\n");
+}
+
+/* Created by Client */
+static void read_socket( const void *args )
+{
+	int ret = -1;
+	socklen_t sock_len = sizeof(struct sockaddr_in);
+	thread_data_t *pData = (thread_data_t *)args;
+	char msg[PAYLOAD_MAXSIZE];
+
+	printf("Create Read Thread\n");
+	while (running) {
+		memset(msg, 0, sizeof(msg));
+		if (net_socket.is_tcp) {
+			ret = read(pData->fd, msg, sizeof(msg));
+		} else {
+			ret = recvfrom(pData->fd, msg, sizeof(msg), 0,
+				(struct sockaddr *)&(pData->addr), &sock_len);
+		}
+		if (ret == 0) {
+			printf("==== disconnect ====\n");
+			break;
+		} else if (ret < 0) {
+			perror("recv");
+			break;
+		} else{
+			printf("Receive Server MSG [%lu]: %s.\n", strlen(msg), msg);
+		}
+	}
+	printf("Exit Read Thread\n");
+}
+
+static int setsockopt_seq(int fd)
+{
+	int ret = -1;
+	char msg[DATA_MAXSIZE];
+	int reset_domain = 0;
+	int seq_num = 0;
+
+	printf("Please insert seq_num >\n");
+	if (fgets(msg, sizeof(msg), stdin) != NULL) {
+		reset_domain = 1;
+		seq_num = atoi(msg);
+
+		printf("Replace domain [%d], seq_num [%d]\n", reset_domain, seq_num);
+		ret = setsockopt(fd, IPPROTO_TCP, TCP_REPAIR, &reset_domain, sizeof(reset_domain));
+		if (ret) {
+			perror("setsockopt TCP_REPAIR ");
+			return ret;
+		}
+		reset_domain = 1;
+		ret = setsockopt(fd, IPPROTO_TCP, TCP_REPAIR_QUEUE, &reset_domain, sizeof(reset_domain));
+		if (ret) {
+			perror("setsockopt TCP_REPAIR_QUEUE ");
+			return ret;
+		}
+		ret = setsockopt(fd, IPPROTO_TCP, TCP_QUEUE_SEQ, &seq_num, sizeof(seq_num));
+		if (ret) {
+			perror("setsockopt TCP_QUEUE_SEQ");
+			return ret;
+		}
+		printf("Set seq[%d] Done\n", seq_num);
+	}
+	return ret;
+}
+
+static int net_socket_server_tcpka(void)
+{
+	int fd_raw = -1;
+	int fd_srv = -1;
+	int fd_client = -1;
+	int max_fd = -1;
+	int new_fd = -1;
+	int yes = 1;
+	int ret = -1;
+	ssize_t recv_len = 0;
+	pthread_t tid = 0;
+
+	fd_set fdset;
+	char buf[PAYLOAD_MAXSIZE];
+	socklen_t sock_len = -1;
+	struct timeval tv;
+	struct sockaddr_in addr_srv;
+	struct sockaddr_in addr_client;
+	thread_data_t thread_data;
+	//timer_info_t timer_tcpka;
+	device_t device;
+
+	signal(SIGPIPE, SIG_IGN);
+	memset(&addr_srv, 0, sizeof(addr_srv));
+	memset(&addr_client, 0, sizeof(addr_client));
+	addr_srv.sin_family = AF_INET;
+	addr_srv.sin_port = htons(net_socket.port);
+	addr_srv.sin_addr.s_addr = INADDR_ANY;
+	sock_len = sizeof(addr_srv);
+
+	/* capture ip datagram without ethernet header */
+	if ((fd_raw = socket(PF_PACKET,  SOCK_DGRAM, htons(ETH_P_IP))) < 0){
+		perror("raw socket");
+		goto err_exit;
+	}
+	if ((fd_srv = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
+		perror("socket");
+		goto err_exit;
+	}
+	if (setsockopt(fd_srv, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) < 0) {
+		perror("setsockopt");
+		goto err_exit;
+	}
+	if (bind(fd_srv, (struct sockaddr *)&addr_srv, sizeof(addr_srv)) < 0) {
+		perror("bind");
+		goto err_exit;
+	}
+	if (listen(fd_srv, MAXCONN) < 0) {
+		perror("listen");
+		goto err_exit;
+	}
+	net_socket.fd_net = fd_srv;
+	net_socket.fd_raw = fd_raw;
+
+	printf("TCP-KeepAlive: Raw [%d], Socket [%d], Port [%d], Bind OK, Accept ...\n",
+		fd_raw, fd_srv, net_socket.port);
+	DIVIDING_LINE();
+
+	while (running) {
+		FD_ZERO(&fdset);
+		FD_SET(fd_raw, &fdset);
+		FD_SET(fd_srv, &fdset);
+		max_fd = (fd_raw > fd_srv) ? fd_raw : fd_srv;
+
+		/* Add Client fd */
+		if (fd_client > 0) {
+			max_fd = (max_fd > fd_client) ? max_fd: fd_client;
+			FD_SET(fd_client, &fdset);
+		}
+
+		tv.tv_sec = 30;
+		tv.tv_usec = 0;
+		ret = select(max_fd + 1, &fdset, NULL, NULL, &tv);
+		if (ret < 0) {
+			perror("select");
+			running = 0;
+			break;
+		} else if (ret == 0) {
+			printf("Timeout\n");
+			continue;
+		}
+
+		if (FD_ISSET(fd_srv, &fdset)) {
+			new_fd = accept(fd_srv, (struct sockaddr *)&addr_client, &sock_len);
+			if (new_fd == 0) {
+				printf("accept zero\n");
+			} else if (ret < 0) {
+				perror("accept");
+				//running = 0;
+				break;
+			} else {
+				if (fd_client != new_fd) {
+					if (net_socket.is_reply && (tid > 0) && (fd_client > 0)) {
+						printf("Cancel pthread [%lu]\n", (unsigned long int)tid);
+						pthread_cancel(tid);
+						tid = 0;
+						printf("Accpet new client [%d], close old client [%d]\n", new_fd, fd_client);
+						close_fd(&fd_client);
+					}
+				}
+				fd_client = new_fd;
+				net_socket.fd_clnt = fd_client;
+
+				strncpy(device.mac_addr, DEVICE_MAC, sizeof(device.mac_addr));
+				strncpy(device.ip_addr, inet_ntoa(addr_client.sin_addr), sizeof(device.ip_addr));
+				device.port = ntohs(addr_client.sin_port);
+
+				LOGT("Receive Client[%d], Src[%s # %s:%d], Status:%d, MSG[%d].",
+					fd_client, device.mac_addr, device.ip_addr, device.port, device.status, ret);
+
+				/* Reply send */
+				if (net_socket.is_reply) {
+					thread_data.fd = fd_client;
+					ret = pthread_create(&tid, NULL, (void *)read_console_reply_send,
+						(void *)&thread_data);
+					if (ret < 0) {
+						perror("pthread_create");
+					}
+				}
+
+				/* Auto Reply send */
+				if (net_socket.is_auto_reply && auto_reply.interval_sencods > 0) {
+					timer_data.fd = fd_client;
+					ret = set_timer(auto_reply.interval_sencods, 0);
+					if (ret != 0) {
+						printf("Set timer error\n");
+					}
+				}
+
+				#if 0
+				/* Create timer */
+				memset(&timer_tcpka, 0, sizeof(timer_tcpka));
+				timer_tcpka.timer_id_valid = 0;
+				timer_tcpka.timeout_seconds = 15;
+				timer_tcpka.disconnect = 1;
+				if (create_posix_timer(&timer_tcpka) < 0) {
+					printf("Failed to create timer for this client, close it, TODO\n");
+					memset(&timer_tcpka, 0, sizeof(timer_tcpka));
+				}
+				#endif
+
+			}
+		}
+
+		if (FD_ISSET(fd_client, &fdset)) {
+			memset(buf, 0, sizeof(buf));
+			recv_len = recv(fd_client, buf, sizeof(buf), 0);
+			if (recv_len <= 0) {
+				if (recv_len < 0) {
+					perror("client recv");
+				}
+				/* Destory dead Client send data thread*/
+				if (net_socket.is_reply && (tid > 0)) {
+					printf("Cancel pthread [%lu]\n", (unsigned long int)tid);
+					pthread_cancel(tid);
+					tid = 0;
+				}
+				if (net_socket.is_auto_reply && auto_reply.interval_sencods > 0) {
+					set_timer(0, 0);
+				}
+				printf("=== Client [%d] recv zero, disconnect ===\n", fd_client);
+				//stop_posix_timer(&timer_tcpka);
+				close_fd(&fd_client);
+			} else {
+				//start_posix_timer(&timer_tcpka);
+				printf("Receive Client MSG[%d]: %s.\n", (int)recv_len, buf);
+			}
+		}
+
+		if (FD_ISSET(fd_raw, &fdset)) {
+			recv_len = recv(fd_raw, buf, sizeof(buf), 0);
+			if (recv_len == 0) {
+				printf("raw recv zero\n");
+				break;
+			} else if (recv_len < 0) {
+				perror("raw recv");
+				//running = 0;
+				break;
+			} else {
+				if (fd_client <= 0) {
+					continue;
+				}
+				IP_HEADER *ip = ( IP_HEADER *)(buf);
+				size_t iplen =	(ip->h_verlen&0x0f)*4;
+				if (ip->proto == IPPROTO_TCP) {
+					TCP_HEADER *tcp = (TCP_HEADER *)(buf +iplen);
+					size_t tcplen = ((tcp->th_lenres >> 4)& 0x0f) * 4;
+					if ( (recv_len <= iplen + tcplen + 1) && ( (tcp->th_flag & 0x3F) == 0x10/*ACK*/)
+						&& ( addr_client.sin_addr.s_addr == ip->sourceIP)
+						&& ( addr_client.sin_port == tcp->th_sport)) {
+						//start_posix_timer(&timer_tcpka);
+						LOGT("Raw client [%d] KeepAlive received", fd_client);
+					} else {
+						//printf("FIN/RST\n");
+					}
+				}
+			}
+		}
+	}
+
+err_exit:
+	if (net_socket.is_reply && (tid > 0)) {
+		pthread_cancel(tid);
+		pthread_join(tid, NULL);
+		tid = 0;
+	}
+	close_fd(&fd_client);
+	close_fd(&fd_srv);
+	close_fd(&fd_raw);
+	//stop_posix_timer(&timer_tcpka);
+	printf("%s exit\n", __FUNCTION__);
+	return ret;
+}
+
+static int net_socket_server_tcp(void)
+{
+	int ret = -1;
+	int len = 0;
+	int fd_srv = -1;
+	int fd_client = -1;
+	pthread_t tid = 0;
+	socklen_t sock_len = 0;
+	thread_data_t thread_data;
+	struct sockaddr_in addr_srv, addr_client;
+	char msg[PAYLOAD_MAXSIZE];
+	device_t device;
+
+	if ((fd_srv = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
+		perror("socket");
+		return -1;
+	}
+	net_socket.fd_net = fd_srv;
+	memset(&addr_srv, 0, sizeof(addr_srv));
+	memset(&addr_client, 0, sizeof(addr_client));
+	addr_srv.sin_family = AF_INET;
+	addr_srv.sin_port = htons(net_socket.port);
+	addr_srv.sin_addr.s_addr = INADDR_ANY;
+	sock_len = sizeof(addr_srv);
+
+	if (bind(fd_srv, (struct sockaddr *)&addr_srv, sock_len) < 0) {
+		perror("bind");
+		close_fd(&fd_srv);
+		return -1;
+	}
+	if (listen(fd_srv, MAXCONN) < 0 ) {
+		perror("listen");
+		close_fd(&fd_srv);
+		return -1;
+	}
+	printf("TCP: Socket [%d], Port [%d], Bind OK. Accept ...\n", fd_srv, net_socket.port);
+	DIVIDING_LINE();
+
+	do {
+		if ((fd_client = accept(fd_srv, (struct sockaddr *)&addr_client, &sock_len)) < 0) {
+			perror("accept");
+			break;
+		}
+		net_socket.fd_clnt = fd_client;
+
+		/* Reply send */
+		if (net_socket.is_reply) {
+			thread_data.fd = fd_client;
+			ret = pthread_create(&tid, NULL, (void *)read_console_reply_send,
+				(void *)&thread_data);
+			if (ret < 0) {
+				perror("pthread_create");
+			}
+		}
+
+		/* Auto Reply send */
+		if (net_socket.is_auto_reply && auto_reply.interval_sencods > 0) {
+			timer_data.fd = fd_client;
+			ret = set_timer(auto_reply.interval_sencods, 0);
+			if (ret != 0) {
+				printf("Set timer error\n");
+			}
+		}
+
+		while (running && fd_client > 0) {
+			/* Receive */
+			memset(msg, 0, sizeof(msg));
+			ret = read(fd_client, msg, sizeof(msg));
+			if (ret <= 0) {
+				if (ret < 0) {
+					perror("read");
+				}
+				if (net_socket.is_reply && (tid > 0)) {
+					printf("Cancel pthread [%lu]\n", (unsigned long int)tid);
+					pthread_cancel(tid);
+					tid = 0;
+				}
+				if (net_socket.is_auto_reply && auto_reply.interval_sencods > 0) {
+					set_timer(0, 0);
+				}
+				close_fd(&fd_client);
+				printf("==== Client disconnect. Accept ... ====\n");
+				break;
+			} else {
+				strncpy(device.mac_addr, DEVICE_MAC, sizeof(device.mac_addr));
+				strncpy(device.ip_addr, inet_ntoa(addr_client.sin_addr), sizeof(device.ip_addr));
+				device.port = ntohs(addr_client.sin_port);
+
+				LOGT("Receive Client[%d], Src[%s # %s:%d], Status:%d, MSG[%d]: %s.",
+					fd_client, device.mac_addr, device.ip_addr, device.port, device.status,
+					ret, msg);
+
+				#if CONFIG_CURL
+				/* Update database */
+				if (net_socket.is_update) {
+					parse_msg_device(msg, &device);
+					device_udpate(&ctx, SERVER_IP, SERVER_PORT, device.mac_addr,
+						device.ip_addr, device.port, device.status);
+				}
+				#endif
+			}
+		}
+	}while (running);
+
+	if (net_socket.is_reply && (tid > 0)) {
+		pthread_cancel(tid);
+		pthread_join(tid, NULL);
+		tid = 0;
+	}
+	close_fd(&fd_client);
+	close_fd(&fd_srv);
+	printf("%s exit\n", __FUNCTION__);
+	return ret;
+}
+
+static int net_socket_server_udp(void)
+{
+	int fd_srv = -1;
+	int ret = -1;
+	int reply_update = 0;
+	int auto_reply_update = 0;
+	pthread_t tid = 0;
+	socklen_t sock_len = -1;
+	thread_data_t thread_data;
+	char msg[PAYLOAD_MAXSIZE];
+	struct sockaddr_in addr_srv, addr_client, addr_client_old;
+	device_t device;
+
+	memset(&addr_srv, 0, sizeof(addr_srv));
+	memset(&addr_client, 0, sizeof(addr_client));
+	addr_srv.sin_family = AF_INET;
+	addr_srv.sin_port = htons(net_socket.port);
+	addr_srv.sin_addr.s_addr = INADDR_ANY;
+	sock_len = sizeof(addr_srv);
+
+	do {
+		if ((fd_srv = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
+			perror("socket");
+			break;
+		}
+		net_socket.fd_net = fd_srv;
+		if (bind(fd_srv, (struct sockaddr *)&addr_srv, sock_len) < 0 ) {
+			perror("bind");
+			close_fd(&fd_srv);
+			break;
+		}
+		printf("UDP: Socket [%d], Port [%d], Bind OK, Recvfrom ...\n", fd_srv,net_socket.port);
+
+		while (running && fd_srv > 0) {
+			/* Receive */
+			memset(msg, 0, sizeof(msg));
+			ret = recvfrom(fd_srv, msg, sizeof(msg), 0,
+				(struct sockaddr *)&addr_client, &sock_len);
+
+			if (ntohs(addr_client.sin_port) != ntohs(addr_client_old.sin_port)) {
+				reply_update = 1;
+				auto_reply_update = 1;
+				addr_client_old = addr_client;
+				if (net_socket.is_reply && (tid > 0)) {
+					printf("Cancel pthread [%lu]\n", (unsigned long int)tid);
+					pthread_cancel(tid);
+					tid = 0;
+				}
+				if (net_socket.is_auto_reply && auto_reply.interval_sencods > 0) {
+					set_timer(0, 0);
+				}
+				DIVIDING_LINE();
+				printf("New Device\n");
+			}
+
+			if (ret <= 0) {
+				if (ret < 0) {
+					perror("recvfrom");
+				}
+				if (net_socket.is_reply && (tid > 0)) {
+					printf("Cancel pthread [%lu]\n", (unsigned long int)tid);
+					pthread_cancel(tid);
+					tid = 0;
+				}
+				if (net_socket.is_auto_reply && auto_reply.interval_sencods > 0) {
+					set_timer(0, 0);
+				}
+				close_fd(&fd_srv);
+				printf("==== Client disconnect, Recvfrom ... ====\n");
+				break;
+			} else {
+				strncpy(device.mac_addr, DEVICE_MAC, sizeof(device.mac_addr));
+				strncpy(device.ip_addr, inet_ntoa(addr_client.sin_addr), sizeof(device.ip_addr));
+				device.port = ntohs(addr_client.sin_port);
+				parse_msg_device(msg, &device);
+
+				LOGT("Receive Src[%s # %s:%d], Status:%d, MSG[%d]: %s.",
+					device.mac_addr, device.ip_addr, device.port, device.status,
+					ret, msg);
+
+				#if CONFIG_CURL
+				/* Update database */
+				if (net_socket.is_update) {
+					device_udpate(&ctx, SERVER_IP, SERVER_PORT, device.mac_addr,
+						device.ip_addr, device.port, device.status);
+				}
+				#endif
+
+				/* Reply send */
+				if (net_socket.is_reply && reply_update) {
+					thread_data.fd = fd_srv;
+					thread_data.addr = addr_client;
+					ret = pthread_create(&tid, NULL, (void *)read_console_reply_send,
+						(void *)&thread_data);
+					if (ret < 0) {
+						perror("pthread_create");
+					}
+					reply_update = 0;
+				}
+
+				/* Auto reply send */
+				if (net_socket.is_auto_reply && auto_reply.interval_sencods > 0 &&
+					auto_reply_update) {
+					timer_data.fd = fd_srv;
+					timer_data.addr = addr_client;
+					ret = set_timer(auto_reply.interval_sencods, 0);
+					if (ret != 0) {
+						printf("Set timer error\n");
+					}
+					auto_reply_update = 0;
+				}
+			}
+		}
+	}while (running);
+
+	if (net_socket.is_reply && (tid > 0)) {
+		pthread_cancel(tid);
+		pthread_join(tid, NULL);
+		tid = 0;
+	}
+
+	close_fd(&fd_srv);
+	printf("%s exit\n", __FUNCTION__);
+	return ret;
+}
+
+static int net_socket_client_tcpka(void)
+{
+	int ret = -1;
+	int len = 0;
+	int fd_client = -1;
+	pthread_t tid = 0;
+	thread_data_t thread_data;
+	struct sockaddr_in addr_srv;
+	char msg[PAYLOAD_MAXSIZE];
+
+	memset(&addr_srv, 0, sizeof(addr_srv));
+	addr_srv.sin_family = AF_INET;
+	addr_srv.sin_port = htons(net_socket.port);
+
+	do {
+		if ((fd_client = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
+			perror("socket");
+			break;
+		}
+		net_socket.fd_clnt = fd_client;
+		if (inet_pton(AF_INET, net_socket.srv_ip, &addr_srv.sin_addr) < 0 ) {
+			perror("inet_pton");
+			break;
+		}
+
+		/* TCP KeepAlive */
+		int keepalive = 1;
+		int keepidle = 15;
+		int keepinterval = 5;
+		int keepcount = 3;
+		setsockopt(fd_client, SOL_SOCKET, SO_KEEPALIVE, (void *)&keepalive, sizeof(keepalive));
+		setsockopt(fd_client, IPPROTO_TCP, TCP_KEEPIDLE, (void*)&keepidle, sizeof(keepidle));
+		setsockopt(fd_client, IPPROTO_TCP, TCP_KEEPINTVL, (void *)&keepinterval, sizeof(keepinterval));
+		setsockopt(fd_client, IPPROTO_TCP, TCP_KEEPCNT, (void *)&keepcount, sizeof(keepcount));
+
+		if (connect(fd_client, (struct sockaddr *)&addr_srv, sizeof(struct sockaddr)) < 0) {
+			perror("connect");
+			break;
+		}
+		printf("TCP-KeepAlive: Socket [%d], Port [%d], Connect OK\n", fd_client, net_socket.port);
+
+		/* Send once */
+		ret = writen(fd_client, net_socket.send_msg, strlen(net_socket.send_msg));
+		if (ret == strlen(net_socket.send_msg)) {
+			printf("Send [%s] Length [%d] OK\n", net_socket.send_msg, ret);
+		} else {
+			perror("Send Failed");
+		}
+
+		/* Create receive thread */
+		if (net_socket.is_reply) {
+			thread_data.fd = fd_client;
+			ret = pthread_create(&tid, NULL, (void *)read_console_reply_send,
+				(void *)&thread_data);
+			if (ret < 0) {
+				perror("pthread_create");
+			}
+		}
+
+		while (running && fd_client > 0) {
+			/* Receive */
+			memset(msg, 0, sizeof(msg));
+			ret = read(fd_client, msg, sizeof(msg));
+			if (ret <= 0) {
+				if (ret < 0) {
+					perror("read");
+				}
+				if (net_socket.is_reply && (tid > 0)) {
+					printf("Cancel pthread [%lu]\n", (unsigned long int)tid);
+					pthread_cancel(tid);
+					tid = 0;
+				}
+				close_fd(&fd_client);
+				printf("==== Client disconnect. %s ====\n",
+					net_socket.is_auto_reply ? "Connect ..." : "Exit.");
+				break;
+			} else {
+				printf("Receive Server MSG[%lu]: %s.\n", strlen(msg), msg);
+			}
+		}
+	}while(running && net_socket.is_auto_reply);
+
+	if (net_socket.is_reply && (tid > 0)) {
+		pthread_cancel(tid);
+		pthread_join(tid, NULL);
+		tid = 0;
+	}
+
+	close_fd(&fd_client);
+	printf("%s exit\n", __FUNCTION__);
+	return ret;
+}
+
+static int net_socket_client_tcp(void)
+{
+	int ret = -1;
+	int len = 0;
+	int fd_client = -1;
+	pthread_t tid = 0;
+	thread_data_t thread_data;
+	struct sockaddr_in addr_srv;
+	char msg[PAYLOAD_MAXSIZE];
+
+	memset(&addr_srv,0, sizeof(addr_srv));
+	addr_srv.sin_family = AF_INET;
+	addr_srv.sin_port = htons(net_socket.port);
+
+	do {
+		if ((fd_client = socket(AF_INET, SOCK_STREAM,
+			(net_socket.is_resume ) ? IPPROTO_TCP : 0)) < 0) {
+			perror("socket");
+			break;
+		}
+		net_socket.fd_clnt = fd_client;
+		if (inet_pton(AF_INET, net_socket.srv_ip, &addr_srv.sin_addr) < 0 ) {
+			perror("inet_pton");
+			break;
+		}
+		if (connect(fd_client, (struct sockaddr *)&addr_srv, sizeof(struct sockaddr)) < 0) {
+			perror("connect");
+			break;
+		}
+		printf("TCP: Socket [%d], Port [%d], Connect OK\n", fd_client, net_socket.port);
+
+		/* Send once */
+		ret = writen(fd_client, net_socket.send_msg, strlen(net_socket.send_msg));
+		if (ret == strlen(net_socket.send_msg)) {
+			printf("Send [%s] Length [%d] OK\n", net_socket.send_msg, ret);
+		} else {
+			perror("Send Failed");
+		}
+
+		/* Replace seq, ack after resume */
+		if (net_socket.is_resume) {
+			setsockopt_seq(fd_client);
+		}
+
+		/* Create reply thread */
+		if (net_socket.is_reply) {
+			thread_data.fd = fd_client;
+			ret = pthread_create(&tid, NULL, (void *)read_console_reply_send,
+				(void *)&thread_data);
+			if (ret < 0) {
+				perror("pthread_create");
+			}
+		}
+
+		while (running && fd_client > 0) {
+			/* Receive */
+			memset(msg, 0, sizeof(msg));
+			ret = read(fd_client, msg, sizeof(msg));
+			if (ret <= 0) {
+				if (ret < 0) {
+					perror("read");
+				}
+				if (net_socket.is_reply && (tid > 0)) {
+					printf("Cancel pthread [%lu]\n", (unsigned long int)tid);
+					pthread_cancel(tid);
+					tid = 0;
+				}
+				close_fd(&fd_client);
+				printf("==== Client disconnect. %s ====\n",
+					net_socket.is_auto_reply ? "Connect ..." : "Exit.");
+				break;
+			} else {
+				printf("Receive Server MSG[%lu]: %s.\n", strlen(msg), msg);
+			}
+		}
+	}while (running && net_socket.is_auto_reply);
+
+	if (net_socket.is_reply && (tid > 0)) {
+		pthread_cancel(tid);
+		pthread_join(tid, NULL);
+		tid = 0;
+	}
+
+	close_fd(&fd_client);
+	printf("%s exit\n", __FUNCTION__);
+	return ret;
+}
+
+static int net_socket_client_udp(void)
+{
+	int ret = -1;
+	int len = -1;
+	int fd_client = -1;
+	pthread_t tid = 0;
+	socklen_t sock_len = -1;
+	thread_data_t thread_data;
+	struct sockaddr_in addr_srv;
+	char msg[PAYLOAD_MAXSIZE];
+
+	memset(&addr_srv, 0, sizeof(addr_srv));
+	addr_srv.sin_family = AF_INET;
+	addr_srv.sin_port = htons(net_socket.port);
+	sock_len = sizeof(addr_srv);
+
+	do {
+		if ((fd_client = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
+			perror("socket");
+			break;
+		}
+		net_socket.fd_clnt = fd_client;
+		if (inet_pton(AF_INET, net_socket.srv_ip, &addr_srv.sin_addr) < 0 ) {
+			perror("inet_pton");
+			break;
+		}
+		printf("UDP: Socket [%d], Port [%d] OK\n", fd_client, net_socket.port);
+
+		/* Send once */
+		ret = sendto(fd_client, net_socket.send_msg, strlen(net_socket.send_msg), 0,
+				(struct sockaddr *)&(addr_srv), sock_len);
+		if (ret == strlen(net_socket.send_msg)) {
+			printf("Send [%s] Length [%d] OK\n", net_socket.send_msg, ret);
+		} else {
+			perror("Send Failed");
+		}
+
+		/* Create Receive thread */
+		if (net_socket.is_reply) {
+			thread_data.fd = fd_client;
+			thread_data.addr = addr_srv;
+			ret = pthread_create(&tid, NULL, (void *)read_console_reply_send,
+				(void *)&thread_data);
+			if (ret < 0) {
+				perror("pthread_create");
+			}
+		}
+
+		while (running && fd_client > 0) {
+			/* Read */
+			memset(msg, 0 , sizeof(msg));
+			ret = recvfrom(fd_client, msg, sizeof(msg), 0,
+				(struct sockaddr *)&(addr_srv), &sock_len);
+			if (ret <= 0) {
+				if (ret < 0) {
+					perror("recvfrom");
+				}
+				close_fd(&fd_client);
+				printf("==== Client disconnect. %s ====\n",
+					net_socket.is_auto_reply ? "Connect ..." : "Exit.");
+			} else {
+				printf("Receive Server MSG[%lu]: %s.\n", strlen(msg), msg);
+			}
+		}
+	} while (running && net_socket.is_auto_reply);
+
+	if (net_socket.is_reply && (tid > 0)) {
+		pthread_cancel(tid);
+		pthread_join(tid, NULL);
+		tid = 0;
+	}
+
+	close_fd(&fd_client);
+	printf("%s exit\n", __FUNCTION__);
+	return ret;
+}
+
+static void default_param(void)
+{
+	/* Init net_socket */
+	net_socket.is_close = 0;
+	net_socket.is_server = 1;
+	net_socket.is_tcp = 1;
+	net_socket.is_tcpka = 0;
+	net_socket.is_reply = 0;
+	net_socket.is_auto_reply = 0;
+	net_socket.is_resume = 0;
+	net_socket.is_update = 0;
+	net_socket.fd_net = -1;
+	net_socket.fd_raw = -1;
+	net_socket.port = DEFAULT_PORT;
+
+	timer_data.fd = -1;
+	auto_reply.interval_sencods = 0;
+	auto_reply.wakeup_times = 0;
+	auto_reply.unexpt_times = 0;
+	auto_reply.close_times = 0;
+
+	memset(net_socket.recv_msg, 0, sizeof(net_socket.recv_msg));
+	memset(net_socket.send_msg, 0, sizeof(net_socket.send_msg));
+	memset(net_socket.srv_ip, 0, sizeof(net_socket.srv_ip));
+	memset(net_socket.client_ip, 0, sizeof(net_socket.client_ip));
+
+	strncpy(net_socket.srv_ip, DEFAULT_HOST, sizeof(net_socket.srv_ip));
+	strncpy(net_socket.send_msg, DEFAULT_MSG, sizeof(net_socket.send_msg));
+
+#if CONFIG_CURL
+	/* Init curl */
+	ctx.p_curl = NULL;
+#endif
+}
+
+static void sigstop()
+{
+	running = 0;
+	close_fd(&net_socket.fd_clnt);
+	close_fd(&net_socket.fd_net);
+	close_fd(&net_socket.fd_raw);
+
+#if CONFIG_CURL
+	if (ctx.p_curl != NULL) {
+		ctx_deinit(&ctx);
+	}
+#endif
+	printf("GG!\n");
+}
+
+int main(int argc, char ** argv)
+{
+	int rval = 0;
+
+	/* register signal handler for Ctrl+C,	Ctrl+'\'  ,  and "kill" sys cmd */
+	signal(SIGINT, sigstop);
+	signal(SIGQUIT, sigstop);
+	signal(SIGTERM, sigstop);
+
+	if (argc < 2) {
+		usage();
+		return -1;
+	}
+	default_param();
+	if (init_param(argc, argv) < 0) {
+		usage();
+		return -1;
+	}
+
+#if CONFIG_CURL
+	if (net_socket.is_server && net_socket.is_update) {
+		rval = ctx_init(&ctx);
+		if (rval < 0) {
+			printf("curl init failed\n");
+			return -1;
+		}
+	}
+#endif
+
+	if (net_socket.is_server) {
+		if (net_socket.is_tcp) {
+			if (net_socket.is_tcpka) {
+				rval = net_socket_server_tcpka();
+			} else {
+				rval = net_socket_server_tcp();
+			}
+		} else {
+			rval = net_socket_server_udp();
+		}
+	} else {
+		if (net_socket.is_tcp) {
+			if (net_socket.is_tcpka) {
+				rval = net_socket_client_tcpka();
+			} else {
+				rval = net_socket_client_tcp();
+			}
+		} else {
+			rval = net_socket_client_udp();
+		}
+	}
+
+#if CONFIG_CURL
+	if (ctx.p_curl != NULL) {
+		ctx_deinit(&ctx);
+	}
+#endif
+
+	if (rval < 0) {
+		printf("Failed to create net socket\n");
+	}
+	printf("Exit Process\n");
+
+	return rval;
+}
diff --git a/wowl/wowl.c b/wowl/wowl.c
new file mode 100644
index 0000000..45211f6
--- /dev/null
+++ b/wowl/wowl.c
@@ -0,0 +1,1138 @@
+/*******************************************************************************
+ * wowl.c
+ *
+ * History:
+ *    2015/4/1 - [Tao Wu] Create
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ( "Software" ) are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+******************************************************************************/
+
+#define __USE_BSD		/* Using BSD IP header 	*/
+#include <netinet/ip.h>	/* Internet Protocol 		*/
+#define __FAVOR_BSD	/* Using BSD TCP header	*/
+#include <netinet/tcp.h>	/* Transmission Control Protocol	*/
+
+#include <pcap.h>
+#include <time.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+#include <getopt.h>
+#include <errno.h>
+#include <assert.h>
+#include <unistd.h>
+#include <ctype.h>
+#include <poll.h>
+
+#include <arpa/inet.h>
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <netinet/ether.h>
+#include <pthread.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <signal.h>
+
+#include <log_level.h>
+#include <net_util.h>
+#include <brcm_ioc.h>
+#include <basetypes.h>
+
+#define WOWL_VERSION		"1.1.3"
+
+#define MAXBYTES2CAPTURE	(2048)
+#define DATA_MAXSIZE 		(32)
+#define PAYLOAD_MAXSIZE 	(256)
+#define FILTER_MAXSIZE		(512)
+
+#define DEFAULT_HOST		"127.0.0.1"
+#define DEFAULT_PORT		(7877)
+#define DEFAULT_INTERVAL	(10)
+#define DEFAULT_DTIM_INTERVAL	(1000)
+#define DEFAULT_MSG		"*"
+#define WAKE_PAYLOAD_HEX 	"77616b65" // the ascii of "wake"
+
+#define DEFAULT_NET_FILTER	"tcp src port 7877"
+
+#define SUSPEND_CMD		"echo mem > /sys/power/state"
+
+#define PROC_WIFI_STATE	"/proc/ambarella/wifi_pm_state"
+
+unsigned char cipher_str1[] = {
+	0x0F,0x62,0xB5,0x08,0x5B,0xAE,0x01,0x54,
+	0xA7,0xFA,0x4D,0xA0,0xF3,0x46,0x99,0xEC,
+	0x28,0x8F,0xF6,0x5D,0xC4,0x2B,0x92,0xF9,
+	0x60,0xC7,0x2E,0x95,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+};
+
+unsigned char cipher_str2[] = {
+	0x0F,0x62,0xB5,0x08,0x5B,0xAE,0x01,0x54,
+	0xA7,0xFA,0x4D,0xA0,0xF3,0x46,0x99,0xEC,
+	0x28,0x8F,0xF6,0x5D,0xC4,0x2B,0x92,0xF9,
+	0x60,0xC7,0x2E,0x95,0xFF,0x00,0x00,0x00,
+	0xAA,0x00,0x00,0x00,0x00,0x00,0x00,0x11
+};
+
+unsigned char cipher_str3[] = {
+	0x05,0x58,0xAB,0xFE,0x51,0xA4,0xF7,0x4A,
+	0x9D,0xF0,0x43,0x96,0xE9,0x3C,0x8F,0xE2,
+	0x16,0x7D,0xE4,0x4B,0xB2,0x19,0x80,0xE7,
+	0x4E,0xB5,0x1C,0x83,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+};
+
+#define NO_ARG		(0)
+#define HAS_ARG		(1)
+
+typedef enum {
+	CPU_SUSPEND = 0,
+	CPU_NORMAL = 1,
+	CPU_UNKNOWN = 2,
+} cpu_state;
+
+typedef struct net_socket_s
+{
+	int fd;
+	int is_session;
+	int is_close;
+	int is_tcp;
+
+	int is_add_tcp_payload;
+	int is_enable_pattern;
+	int is_enable_filter;
+	int is_enable_host_cipher;
+	int is_enable_host_sleep;
+
+	int is_enable_suspend;
+	int is_poll;
+	int is_add_resume;
+	int is_reconn;
+
+	int is_sys_exec;
+	int suspend_pm;
+	int port;
+	int interval;
+	int dtim_interval;
+
+	wifi_chip_t wifi_chip_id;
+	log_level_t log_level;
+
+	char iface[IFNAMSIZ];
+	char srv_ip[DATA_MAXSIZE];
+	char send_msg[PAYLOAD_MAXSIZE];
+	unsigned int send_msg_len;
+} net_socket_t;
+
+static net_socket_t net_socket;
+
+static pcap_t *pG_pcap = NULL;
+static pthread_t G_pcap_tid = 0;
+static tcpka_conn_sess_info_t G_tcp_info_old = {0, 0, 0};
+static int G_pm_pipefd[2] = {-1, -1};
+static int G_running = 1;
+
+#define COLOR_PRINT0(msg)		printf("\033[34m"msg"\033[39m")
+
+struct hint_s {
+	const char *arg;
+	const char *str;
+};
+
+static const char *short_options = "i:c:p:tusm:d:k:bnrqP:yloeagxw:v:h";
+static struct option long_options[] = {
+	{"interface",	HAS_ARG, 0, 'i'},
+	{"host",		HAS_ARG, 0, 'c'},
+	{"port",		HAS_ARG, 0, 'p'},
+	{"udp",			NO_ARG,  0, 'u'},
+	{"tcp",			NO_ARG,  0, 't'},
+	{"session",		NO_ARG,  0, 's'},
+	{"kalive-tvl",	HAS_ARG, 0, 'm'},
+	{"dtim-tvl",	HAS_ARG, 0, 'd'},
+	{"payload",		HAS_ARG, 0, 'k'},
+	{"no-payload", 	NO_ARG,  0, 'b'},
+	{"wowl-pattern",	NO_ARG,  0, 'n'},
+	{"pkt-filter",	NO_ARG,  0, 'y'},
+	{"host-cipher",	NO_ARG,  0, 'r'},
+	{"host-sleep",	NO_ARG,  0, 'q'},
+	{"PM",			HAS_ARG, 0, 'P'},
+	{"suspend", 	NO_ARG,  0, 'l'},
+	{"poll", 		NO_ARG,  0, 'o'},
+	{"resume",		NO_ARG,  0, 'a'},
+	{"reconn",		NO_ARG,  0, 'g'},
+	{"close",		NO_ARG,  0, 'e'},
+	{"system",		NO_ARG,  0, 'x'},
+	{"wifi-chip",	HAS_ARG, 0, 'w'},
+	{"loglevel",	HAS_ARG, 0, 'v'},
+	{"help",		NO_ARG,  0, 'h'},
+
+	{0, 0, 0, 0}
+};
+
+static const struct hint_s hint[] = {
+	{"", "Listen on interface"},
+	{"", "Host IP address"},
+	{"", "Host Port, default is [7877]"},
+	{"", "UDP Keep Alive"},
+	{"", "TCP Keep Alive"},
+	{"", "Create one TCP/UDP session"},
+	{"", "Keep Alive interval time, in seconds. Disable KeepAlive when set 0"},
+	{"", "DTIM interval time, in mseconds. Equal to AP's DTIM when set 0"},
+	{"", "Add Payload. Default is '*' "},
+	{"", "Do not add Payload in TCP KeepAlive"},
+	{"", "Set wowl pattern when do TCP/UDP KeepAlive. Default is disable"},
+	{"", "Set pkt filter when do UDP KeepAlive. Default is disable"},
+	{"", "Add Host Cipher"},
+	{"", "Add Host Sleep, enable by default (Discard All packet finally avoid WiFi memory overflow)"},
+	{"", "\tSet PM value before suspend. 0: CAM, 1: PS, 2: FAST PS. Default is 1"},
+	{"", "Add suspend after set TCP KeepAlive"},
+	{"", "Use poll to detect Wifi driver resume state, otherwise use sleep after suspend"},
+	{"", "Add TCP resume and transfer data"},
+	{"", "Reconnect to server when TCP is disconnect"},
+	{"", "Close fd after exit. Default is disable"},
+	{"", "Using system exec to call wl(Keep-alive, Wakeup Pattern)"},
+	{"", "WiFi chip ID. 0:BCM43340; 1:BCM43438A0/BCM43438A1/BCM43455/BCM43436. Default is 0"},
+	{"", "Set Log Level. 0:ERROR, 1:WAR, 2:INFO, 3:DEBUG, 4:VERBOSE. Default is 2"},
+	{"", "Show usage"},
+};
+
+static void usage(void)
+{
+	u32 i = 0;
+	char *itself = "wowl";
+
+	printf("This program used to set KeepAlive and Wakeup on wireless base on Broadom WiFi.\n");
+	printf("\n");
+
+	for (i = 0; i < sizeof(long_options) / sizeof(long_options[0]) - 1; i++) {
+		if (isalpha(long_options[i].val))
+			printf("-%c ", long_options[i].val);
+		else
+			printf("   ");
+		printf("--%s", long_options[i].name);
+		if (hint[i].arg[0] != 0)
+			printf(" [%s]", hint[i].arg);
+		printf("\t%s\n", hint[i].str);
+	}
+
+	COLOR_PRINT0("\n[Example Commands]:\n");
+	printf("Notes: Demo Remote IP is 10.0.0.4 and Port is 7877, change it in according to environment.\n\n");
+
+	COLOR_PRINT0("Suspend + Resume TCP/UDP session (DRAM-Refresh): \n");
+	printf("(1) TCP with BCM43340: \n");
+	printf("    # %s -w 0 -i wlan0 -c 10.0.0.4 -p 7877 -t -s -m 50 -d 600 -e -n -l -o -a -P 1 -q \n\n", itself);
+	printf("(2) TCP with BCM43438: \n");
+	printf("    # %s -w 1 -i wlan0 -c 10.0.0.4 -p 7877 -t -s -m 50 -d 600 -e -n -l -o -a -P 1 -q \n\n", itself);
+	printf("(3) UDP: \n");
+	printf("    # %s -w 1 -i wlan0 -c 10.0.0.4 -p 7877 -u -s -m 50 -d 600 -e -n -l -o -a -P 1 -q \n\n", itself);
+	printf("(4) No KeepAlive before suspend: \n");
+	printf("    # %s -w 1 -i wlan0 -c 10.0.0.4 -p 7877 -u -s -m  0 -d 600 -e -n -l -o -a -P 1 -q \n\n", itself);
+
+	COLOR_PRINT0("No suspend after set KeepAlive (Hibernation or Shutdown-CPU): \n");
+	printf("(1) TCP: \n");
+	printf("    # %s -w 1 -i wlan0 -c 10.0.0.4 -p 7877 -t -s -m 50 -d 600 -n -a -P 1 -q \n\n", itself);
+	printf("(2) UDP: \n");
+	printf("    # %s -w 1 -i wlan0 -c 10.0.0.4 -p 7877 -u -s -m 50 -d 600 -n -a -P 1 -q \n\n", itself);
+
+	COLOR_PRINT0("Wakeup with Packet Filter Setting (Legacy): \n");
+	printf("(1) UDP: \n");
+	printf("    # %s -w 1 -i wlan0 -c 10.0.0.4 -p 7877 -u -s -m 50 -d 600 -y -a -P 1 -q \n\n", itself);
+
+}
+
+static int init_param(int argc, char **argv)
+{
+	int ch = 0;
+	int value = 0;
+	int option_index = 0;
+
+	opterr = 0;
+	while ((ch = getopt_long(argc, argv, short_options, long_options, &option_index)) != -1) {
+		switch (ch) {
+		case 'i':
+			strncpy(net_socket.iface, optarg, sizeof(net_socket.iface));
+			break;
+		case 'c':
+			strncpy(net_socket.srv_ip, optarg, sizeof(net_socket.srv_ip));
+			break;
+		case 'p':
+			value = atoi(optarg);
+			if ((value < 0) || (value > 65535)) {
+				printf("Please set port in %d ~ %d.\n", 0, 65535);
+				return -1;
+			}
+			net_socket.port = value;
+			break;
+		case 'm':
+			value = atoi(optarg);
+			if ((value < 0) || (value > 65535)) {
+				printf("Please set interval in %d ~ %d.\n", 0, 65535);
+				return -1;
+			}
+			net_socket.interval = value;
+			break;
+		case 'd':
+			value = atoi(optarg);
+			if ((value < 0) || (value > 65535)) {
+				printf("Please set DTIM interval in %d ~ %d.\n", 0, 65535);
+				return -1;
+			}
+			net_socket.dtim_interval = value;
+			break;
+		case 't':
+			net_socket.is_tcp = 1;
+			break;
+		case 'u':
+			net_socket.is_tcp = 0;
+			break;
+		case 's':
+			net_socket.is_session = 1;
+			break;
+		case 'k':
+			strncpy(net_socket.send_msg, optarg, sizeof(net_socket.send_msg));
+			net_socket.send_msg_len = strlen(net_socket.send_msg);
+			break;
+		case 'b':
+			net_socket.is_add_tcp_payload = 0;
+			break;
+		case 'n':
+			net_socket.is_enable_pattern = 1;
+			break;
+		case 'y':
+			net_socket.is_enable_filter= 1;
+			break;
+		case 'r':
+			net_socket.is_enable_host_cipher = 1;
+			break;
+		case 'q':
+			net_socket.is_enable_host_sleep = 1;
+			break;
+		case 'P':
+			value = atoi(optarg);
+			if (value != 0 && value != 1 && value != 2) {
+				printf("Please set PM in 0|1|2.\n");
+				return -1;
+			}
+			net_socket.suspend_pm = value;
+			break;
+		case 'l':
+			net_socket.is_enable_suspend = 1;
+			break;
+		case 'o':
+			net_socket.is_poll = 1;
+			break;
+		case 'a':
+			net_socket.is_add_resume = 1;
+			break;
+		case 'g':
+			net_socket.is_reconn = 1;
+			break;
+		case 'e':
+			net_socket.is_close = 1;
+			break;
+		case 'x':
+			net_socket.is_sys_exec = 1;
+			break;
+		case 'w':
+			value = atoi(optarg);
+			if ((value < WIFI_CHIP_FIRST) || (value > WIFI_CHIP_LAST)) {
+				printf("Please chosse WiFi Chip ID in [%d, %d].\n",
+					WIFI_CHIP_FIRST, WIFI_CHIP_LAST);
+				return -1;
+			}
+			net_socket.wifi_chip_id = value;
+			break;
+		case 'v':
+			value = atoi(optarg);
+			if ((value < LOG_LEVEL_FIRST) || (value > LOG_LEVEL_LAST)) {
+				printf("Please chosse Log Level in [%d, %d].\n",
+					LOG_LEVEL_FIRST, LOG_LEVEL_LAST);
+				return -1;
+			}
+			net_socket.log_level= value;
+			break;
+		case 'h':
+			usage();
+			return -1;
+			break;
+		default:
+			printf("unknown option found: %c.\n", ch);
+			return -1;
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static void close_fd(int *fd)
+{
+	if (net_socket.is_close && (*fd >= 0)) {
+		close(*fd);
+		logi("Close fd [%d].\n", *fd);
+		*fd = -1;
+	}
+}
+
+static void sys_enter_suspend(void)
+{
+#define SLEEP_BEFORE_SUSPEND (200000)
+
+	static u32 suspend_count = 0;
+	logd("Go to suspend mode, count [%u] \n", suspend_count++);
+	system("sync");
+	fflush(stdin);
+	fflush(stdout);
+
+	usleep(SLEEP_BEFORE_SUSPEND);
+	logd("Sleep %d us done\n", SLEEP_BEFORE_SUSPEND);
+	system("sync");
+	fflush(stdin);
+	fflush(stdout);
+
+	system(SUSPEND_CMD);
+}
+
+static void poll_wait_sys_state(void)
+{
+#define POLL_TIMEOUT (3000) // 3s
+
+	int ret = -1;
+	int state_fd = -1;
+	cpu_state curr_state = CPU_UNKNOWN;
+	struct pollfd fds;
+
+	state_fd = open(PROC_WIFI_STATE, O_RDWR);
+	if (state_fd < 0) {
+		perror("open" PROC_WIFI_STATE );
+		return;
+	}
+	fds.fd = state_fd;
+	fds.events = POLLIN;
+
+	do {
+		ret = poll(&fds, 1, POLL_TIMEOUT);
+		if(ret == 0) {
+			printf("Poll time out\n");
+		} else {
+			ret = read(state_fd, &curr_state, sizeof(curr_state));
+			if (ret < 0) {
+				perror("read\n");
+			} else {
+				logd("Poll system current state [%d]\n", curr_state);
+				break;
+			}
+		}
+	} while (0);
+
+	close(state_fd);
+	state_fd = -1;
+}
+
+/* Do call this function before suspend in every case, whatever AP or Server APP is connected */
+static void wifi_enter_sleep(void)
+{
+	int hostsleep = 1;
+
+	wl_set_dtim_interval(net_socket.dtim_interval);
+	wl_set_get_pm_mode(&net_socket.suspend_pm, 1);
+	if (net_socket.is_enable_host_sleep) {
+		wl_set_get_host_sleep(&hostsleep, 1);
+	}
+}
+
+static void wifi_exit_sleep(void)
+{
+	int pm = 2;
+	int hostsleep = 0;
+
+	if (net_socket.is_enable_host_sleep) {
+		wl_set_get_host_sleep(&hostsleep, 1);
+	}
+	wl_set_get_pm_mode(&pm, 1);
+	wl_set_bcn_li_dtim(0);
+}
+
+static void wifi_enter_normal(tcpka_conn_sess_info_t *p_tcp_info,
+	wl_wowl_wakeind_t *p_wakeind, wl_pkt_filter_stats_t *p_filter_stats)
+{
+	logd("WiFi Normal Mode Start\n");
+
+	wifi_exit_sleep();
+	if (net_socket.interval > 0) {
+		if (net_socket.is_tcp) {
+			wl_tcpka_conn_enable(1, 0, 0, 0, 0);
+			wl_tcpka_conn_sess_info(1, p_tcp_info);
+			wl_tcpka_conn_del(1);
+		} else {
+			wl_mkeep_alive(1, 0, 0, NULL);
+		}
+	}
+	if (net_socket.is_enable_pattern) {
+		wl_wowl_wakeind(p_wakeind);
+		wl_wowl_wakeind_clear();
+		wl_wowl_clear();
+		wl_wowl_pattern_clr();
+	} else if (net_socket.is_enable_filter) {
+		wl_pkt_filter_stats(200, p_filter_stats);
+		wl_pkt_filter_enable(200, 0);
+		wl_pkt_filter_delete(200);
+	}
+
+	logd("WiFi Normal Mode Done\n");
+}
+
+static int fix_tcp_info(int sock_fd, tcpka_conn_sess_info_t tcp_info)
+{
+	int ret = -1;
+
+	if (sock_fd < 0) {
+		loge("Socket fd [%d] is invalid\n", sock_fd);
+		return -1;
+	}
+
+	logd("Modify TCP info start\n");
+	ret = ioctl(sock_fd, SET_TCP_FIX, &tcp_info);
+	if (ret < 0) {
+		perror("SET_TCP_FIX");
+	} else {
+		logi("Modify TCP info done\n");
+	}
+
+	return ret;
+}
+
+static void suspend_and_resume(int sockfd, int wpipefd)
+{
+#define WAIT_REMAIN_CMD_SECONDS		(20)
+#define WAIT_APP_SECONDS	(1)
+
+	int ret = 0;
+	cpu_state sys_state = CPU_NORMAL;
+	tcpka_conn_sess_info_t tcp_info = {0, 0, 0};
+	wl_wowl_wakeind_t wakeind;
+	wl_pkt_filter_stats_t filter_stats;
+	static u32 resume_count = 0;
+
+	/* Prepare suspend */
+	sys_state = CPU_SUSPEND;
+	ret = write(wpipefd, &sys_state, sizeof(sys_state));
+	if (ret < 0) {
+		perror("write pipe");
+		return;
+	}
+	logd("Notify pipe SUSPEND mode\n");
+
+	/* Execute suspend */
+	if (net_socket.is_enable_suspend) {
+		sys_enter_suspend();
+	} else {
+		logi("Wait %d seconds to type remaining command\n", WAIT_REMAIN_CMD_SECONDS);
+		sleep(WAIT_REMAIN_CMD_SECONDS);
+	}
+
+	/* Wait Resume back */
+	if (net_socket.is_poll) {
+		poll_wait_sys_state();
+	} else {
+		logi("Wait %d seconds to enter app\n", WAIT_APP_SECONDS);
+		sleep(WAIT_APP_SECONDS);
+	}
+	logi("Back from resume mode, count [%u] ...\n", resume_count++);
+
+	wifi_enter_normal(&tcp_info, &wakeind, &filter_stats);
+
+	if (net_socket.is_tcp) {
+		logi("Resume TCP info: ipid[%u], seq[%u], ack[%u].\n",
+			tcp_info.tcpka_sess_ipid, tcp_info.tcpka_sess_seq, tcp_info.tcpka_sess_ack);
+		if ((tcp_info.tcpka_sess_ipid > (G_tcp_info_old.tcpka_sess_ipid + 1)) ||
+			(tcp_info.tcpka_sess_seq > (G_tcp_info_old.tcpka_sess_seq + 1)) ||
+			(tcp_info.tcpka_sess_ack > (G_tcp_info_old.tcpka_sess_ack + 1))) {
+			fix_tcp_info(sockfd, tcp_info);
+		}
+	}
+
+	/* Resume done */
+	sys_state = CPU_NORMAL;
+	ret = write(wpipefd, &sys_state, sizeof(sys_state));
+	if (ret < 0) {
+		perror("write pipe");
+		return;
+	}
+	logd("Notify pipe NORMAL mode\n");
+
+	if ((wakeind.ucode_wakeind & WL_WOWL_TCPFIN) == WL_WOWL_TCPFIN) {
+		logi("Wake on TCP FIN packet\n");
+		/* TODO: Close fd if not send "Online" pkt to server after resume,
+		 * beacuse server will send RST pkt when receive PSH pkt in half close state.
+		 * Otherwise, please need close fd after resume when no pkt send to server. */
+	}
+	if (((wakeind.ucode_wakeind & WL_WOWL_DIS) == WL_WOWL_DIS) ||
+		((wakeind.ucode_wakeind & WL_WOWL_BCN) == WL_WOWL_BCN) ) {
+		logi("Wake on disconnect with AP\n");
+		/* TODO: Resume connect to AP */
+	}
+}
+
+static void transfer_data(int rpipefd, int sock_fd, struct sockaddr_in *addr)
+{
+#define SELECT_TIMEOUT (30)
+
+	int ret = 0;
+	int max_fd = -1;
+	fd_set fdset;
+	struct timeval tv;
+	socklen_t sock_len = sizeof(struct sockaddr_in);
+	cpu_state curr_state = CPU_UNKNOWN;
+	char online[32] = "Online";
+	char msg[PAYLOAD_MAXSIZE];
+	logd("Transfer data. Pipe fd [%d], Sockt fd [%d], Addr[%p]\n", rpipefd, sock_fd, addr);
+
+	while (G_running) {
+		FD_ZERO(&fdset);
+		FD_SET(rpipefd, &fdset);
+		FD_SET(sock_fd, &fdset);
+		max_fd = (rpipefd > sock_fd) ? rpipefd : sock_fd;
+		tv.tv_sec = SELECT_TIMEOUT;
+		tv.tv_usec = 0;
+
+		ret = select(max_fd + 1, &fdset, NULL, NULL, &tv);
+		if (ret < 0) {
+			perror("select");
+			break;
+		} else if (ret == 0) {
+			//printf("Select timeout\n");
+			continue;
+		}
+
+		if (FD_ISSET(rpipefd, &fdset)) {
+			ret = read(rpipefd, &curr_state, sizeof(curr_state));
+			if (ret < 0) {
+				perror("read pipe");
+				break;
+			}
+			logd("Read pipe msg state [%d]\n", curr_state);
+			if (curr_state == CPU_NORMAL) {
+				if (addr) { /* UDP */
+					ret = sendto(sock_fd, online, strlen(online), 0, (struct sockaddr *) addr, sock_len);
+				} else { /* TCP */
+					ret = writen(sock_fd, online, strlen(online));
+				}
+
+				if (ret == strlen(online)) {
+					logd("Send [%s] Length [%d] OK\n", online, ret);
+				} else {
+					logd("Send [%s] Length [%d] Error: %s\n", online, ret, strerror(errno));
+					break;
+				}
+			}
+		}
+
+		if (FD_ISSET(sock_fd, &fdset)) {
+			/*
+			if (curr_state != CPU_NORMAL) {
+				loge("System is not in NORMAL mode");
+				continue;
+			}*/
+			memset(msg, 0, sizeof(msg));
+			if (addr) { /* UDP */
+				ret = recvfrom(sock_fd, msg, sizeof(msg), 0, (struct sockaddr *) addr, &sock_len);
+			} else { /* TCP */
+				ret = read(sock_fd, msg, sizeof(msg));
+			}
+
+			if (ret == 0) {
+				logw("==== disconnect ====\n");
+				break;
+			} else if (ret < 0) {
+				perror("recv");
+				break;
+			} else {
+				logd("Receive Server MSG[%d]:%s.\n", strlen(msg), msg);
+				if (addr) { /* UDP */
+					ret = sendto(sock_fd, msg, strlen(msg), 0, (struct sockaddr *) addr, sock_len);
+				} else { /* TCP */
+					ret = writen(sock_fd, msg, strlen(msg));
+				}
+				if (ret == strlen(msg)) {
+					logd("Send [%s] Length [%d] OK\n", msg, ret);
+				} else {
+					logd("Send [%s] Length [%d] Error: %s\n", msg, ret, strerror(errno));
+					break;
+				}
+			}
+		}
+	}
+
+	logd("%s exit\n", __FUNCTION__);
+	return;
+}
+
+static int socket_client_tcp(void)
+{
+	int fd_client = -1;
+	int ret = -1;
+	struct sockaddr_in addr_srv;
+
+	memset(&addr_srv, 0, sizeof(addr_srv));
+	addr_srv.sin_family = AF_INET;
+	addr_srv.sin_port = htons(net_socket.port);
+
+	do {
+		if ((fd_client = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
+			perror("socket");
+			break;
+		}
+		net_socket.fd = fd_client;
+
+		if (inet_pton(AF_INET, net_socket.srv_ip, &addr_srv.sin_addr) < 0 ) {
+			perror("inet_pton");
+			break;
+		}
+		if (connect(fd_client, (struct sockaddr *)&addr_srv, sizeof(struct sockaddr)) < 0) {
+			perror("connect");
+			break;
+		}
+		logd("Socket fd [%d], Host: %s:%d, Connect OK\n",
+			fd_client, net_socket.srv_ip, net_socket.port);
+
+		/* Fixme: send once, need send twice if pcap have not capture it */
+		ret = writen(fd_client, net_socket.send_msg, strlen(net_socket.send_msg));
+		if (ret == strlen(net_socket.send_msg)) {
+			logd("Send [%s] Length [%d] OK\n", net_socket.send_msg, ret);
+		} else {
+			logd("Send [%s] Length [%d] Error: %s\n", net_socket.send_msg, ret, strerror(errno));
+		}
+
+		if (net_socket.is_add_resume) {
+			transfer_data(G_pm_pipefd[0], fd_client, NULL);
+		}
+		close_fd(&fd_client);
+		net_socket.fd = -1;
+		logi("TCP Socket Dissconnect\n");
+	} while (G_running && net_socket.is_reconn);
+
+	logw("%s exit\n", __FUNCTION__);
+	return ret;
+}
+
+static int socket_client_udp(void)
+{
+	int fd_client = -1;
+	int ret = -1;
+	struct sockaddr_in addr_srv;
+
+	memset(&addr_srv, 0, sizeof(addr_srv));
+	addr_srv.sin_family = AF_INET;
+	addr_srv.sin_port = htons(net_socket.port);
+
+	do {
+		if ((fd_client = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
+			perror("socket");
+			break;
+		}
+		net_socket.fd = fd_client;
+		if (inet_pton(AF_INET, net_socket.srv_ip, &addr_srv.sin_addr) < 0 ) {
+			perror("inet_pton");
+			break;
+		}
+		logi("Socket fd [%d], Port [%d] OK\n", fd_client, net_socket.port);
+
+		/* Send */
+		ret = sendto(fd_client, net_socket.send_msg, strlen(net_socket.send_msg),
+			0, (struct sockaddr *)&addr_srv, sizeof(addr_srv));
+		if (ret == strlen(net_socket.send_msg)) {
+			logd("Send [%s] Length [%d] OK\n", net_socket.send_msg, ret);
+		} else {
+			logd("Send [%s] Length [%d] Error: %s\n", net_socket.send_msg, ret, strerror(errno));
+		}
+
+		if (net_socket.is_add_resume) {
+			transfer_data(G_pm_pipefd[0], fd_client, &addr_srv);
+		}
+		close_fd(&fd_client);
+		net_socket.fd = -1;
+		logi("UDP Socket Dissconnect\n");
+	} while (G_running && net_socket.is_reconn);
+
+	logw("%s exit\n", __FUNCTION__);
+	return ret;
+}
+
+void process_tcp(const struct pcap_pkthdr *pkthdr, const u_char *packet)
+{
+	int i = 0;
+	tcpka_conn_t *p_tcpka = NULL;
+	char tcp_wowl_pattern[FILTER_MAXSIZE];
+	char dst_mac[DATA_MAXSIZE];
+	char src_mac[DATA_MAXSIZE];
+
+	struct ip *iphdr = NULL;		/* IPv4 Header */
+	struct tcphdr *tcphdr = NULL;	/* TCP Header  */
+	unsigned int *tsval = NULL;		/* Time Stamp (optional) */
+	unsigned int *tsvalR = NULL;	/* Time Stamp Reply (optional) */
+
+	iphdr = (struct ip *)(packet + 14);
+	tcphdr = (struct tcphdr *)(packet + 14 + 20);
+	tsval = (unsigned int *)(packet + 58);
+	tsvalR = tsval + 1;
+
+	/* 1. Filter PSH flag.
+	 *  2. Filter total size is (66 + payload length) byte for when send tcp data.
+	 *  3. Filter payload memory.
+	 */
+	if (tcphdr->psh && pkthdr->len == (net_socket.send_msg_len + TCP_PL_OFFSET) &&
+		(!memcmp((void *)(packet + TCP_PL_OFFSET), (void *)net_socket.send_msg,
+			net_socket.send_msg_len))) {
+
+		memset(dst_mac, 0, sizeof(dst_mac));
+		sprintf(dst_mac, "%02x:%02x:%02x:%02x:%02x:%02x",
+			packet[0], packet[1], packet[2], packet[3], packet[4], packet[5]);
+
+		memset(src_mac, 0, sizeof(src_mac));
+		sprintf(src_mac, "%02x:%02x:%02x:%02x:%02x:%02x",
+			packet[6], packet[7], packet[8], packet[9], packet[10], packet[11]);
+
+		logv("	FLags: PSH [%d]\n", tcphdr->psh);
+		logv("	DST MAC: %s\n", dst_mac);
+		logv("	SRC MAC: %s\n", src_mac);
+		logv("	DST IP: %s\n", inet_ntoa(iphdr->ip_dst));
+		logv("	SRC IP: %s\n", inet_ntoa(iphdr->ip_src));
+		logv("	SRC PORT: %d\n", ntohs(tcphdr->th_sport));
+		logv("	DST PORT: %d\n", ntohs(tcphdr->th_dport));
+		logv("	ID: %d\n", ntohs(iphdr->ip_id));
+		logv("	SEQ: %u\n", ntohl(tcphdr->th_seq));
+		logv("	ACK: %u\n", ntohl(tcphdr->th_ack));
+		logv("	Win: %d\n", ntohs(tcphdr->th_win));
+		logv("	TS val: %u\n", ntohl(*tsval));
+		logv("	TS valR: %u\n", ntohl(*tsvalR));
+		logv("	Data (Hex): ");
+		for ( i = TCP_PL_OFFSET; i < pkthdr->len; i++ ) {
+			logv("%02x ", packet[i]);
+		}
+		logv("\n");
+
+		/* Fill WiFi FW to KeepAlive and Wakeup Pattern, Session ID: 1 */
+		if (net_socket.interval > 0) {
+			do {
+				int tcpka_len = sizeof (tcpka_conn_t) + pkthdr->len - TCP_PL_OFFSET;
+				if (p_tcpka == NULL) {
+					p_tcpka = malloc(tcpka_len);
+				}
+				if (p_tcpka == NULL) {
+					perror("malloc tcpka");
+					break;
+				} else {
+					memset(p_tcpka, 0, tcpka_len);
+				}
+				p_tcpka->sess_id = 1;
+				p_tcpka->dst_mac = (struct ether_addr)* ether_aton(dst_mac);
+				memcpy(&p_tcpka->src_ip, &iphdr->ip_src.s_addr, IPV4_ADDR_LEN);
+				memcpy(&p_tcpka->dst_ip, &iphdr->ip_dst.s_addr, IPV4_ADDR_LEN);
+				p_tcpka->ipid = ntohs(iphdr->ip_id);
+				p_tcpka->srcport = ntohs(tcphdr->th_sport);
+				p_tcpka->dstport = ntohs(tcphdr->th_dport);
+				p_tcpka->seq = ntohl(tcphdr->th_seq);
+				p_tcpka->ack = ntohl(tcphdr->th_ack);
+				p_tcpka->tcpwin = ntohs(tcphdr->th_win);
+				p_tcpka->tsval = ntohl(*tsval);
+				p_tcpka->tsecr = ntohl(*tsvalR);
+				if (net_socket.is_add_tcp_payload) {
+					p_tcpka->len = pkthdr->len - TCP_PL_OFFSET;
+					p_tcpka->ka_payload_len = pkthdr->len - TCP_PL_OFFSET;
+				} else {
+					p_tcpka->len = 0;
+					p_tcpka->ka_payload_len = 0;
+				}
+				memcpy ((void *)&p_tcpka->ka_payload[0], (void *)&net_socket.send_msg[0],
+					net_socket.send_msg_len);
+
+				G_tcp_info_old.tcpka_sess_ipid = p_tcpka->ipid;
+				G_tcp_info_old.tcpka_sess_seq = p_tcpka->seq;
+				G_tcp_info_old.tcpka_sess_ack = p_tcpka->ack;
+				logi("Suspend TCP info: ipid[%u], seq[%u], ack[%u]\n",
+					G_tcp_info_old.tcpka_sess_ipid,
+					G_tcp_info_old.tcpka_sess_seq,
+					G_tcp_info_old.tcpka_sess_ack);
+
+				if (net_socket.is_enable_host_cipher) {
+					wl_set_get_host_cipher(cipher_str1, sizeof(cipher_str1), 1);
+				}
+				wl_tcpka_conn_add(p_tcpka);
+				wl_tcpka_conn_enable(1, 1, net_socket.interval, 1, 8);
+				if (p_tcpka) {
+					free(p_tcpka);
+					p_tcpka = NULL;
+				}
+			}while (0);
+		}
+
+		if (net_socket.is_enable_pattern) {
+			memset(tcp_wowl_pattern, 0, sizeof(tcp_wowl_pattern));
+			snprintf(tcp_wowl_pattern, sizeof(tcp_wowl_pattern),
+				"0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"\
+				"00000000000000000000000000000000000000000000000000000000%s",
+				packet[30], packet[31], packet[32], packet[33],
+				packet[26], packet[27], packet[28], packet[29],
+				packet[36], packet[37], packet[34], packet[35], WAKE_PAYLOAD_HEX);
+
+			wl_wowl_pattern(26, "0xff0f0000000f", tcp_wowl_pattern);
+			wl_wowl(0x00016);
+			wl_wowl_activate(1);
+		}
+		wifi_enter_sleep();
+
+		logi("Set WiFi %s %s Done\n",
+			net_socket.interval ? "TCP KeepAlive" : "",
+			net_socket.is_enable_pattern ? "Wowl Pattern" : "");
+
+		if (net_socket.is_add_resume) {
+			suspend_and_resume(net_socket.fd, G_pm_pipefd[1]);
+		}
+	}
+}
+
+void process_udp(const struct pcap_pkthdr* pkthdr, const u_char * packet)
+{
+	char udp_wowl_pattern[FILTER_MAXSIZE];
+	char pattern_type[64]= {0};
+
+	if (!memcmp((void *)(packet + UDP_PL_OFFSET), (void *)net_socket.send_msg,
+		net_socket.send_msg_len)) {
+
+		if (net_socket.interval > 0) {
+			wl_mkeep_alive(1, net_socket.interval, pkthdr->len, packet);
+		}
+		memset(udp_wowl_pattern, 0, sizeof(udp_wowl_pattern));
+		snprintf(udp_wowl_pattern, sizeof(udp_wowl_pattern),
+			"0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
+			packet[30], packet[31], packet[32], packet[33],
+			packet[26], packet[27], packet[28], packet[29],
+			packet[36], packet[37], packet[34], packet[35]);
+
+		if (net_socket.is_enable_pattern) {
+			wl_wowl_pattern(26, "0xff0f", udp_wowl_pattern);
+			wl_wowl(0x00016);
+			wl_wowl_activate(1);
+			snprintf(pattern_type, sizeof(pattern_type), "Wowl Pattern");
+		} else if (net_socket.is_enable_filter) {
+			wl_pkt_filter_add(200, 26, "0xffffffffffffffffffffffff", udp_wowl_pattern);
+			wl_pkt_filter_enable(200, 1);
+			snprintf(pattern_type, sizeof(pattern_type), "Pkt Filter");
+		}
+		wifi_enter_sleep();
+
+		logi("Set %s %s Done\n", net_socket.interval ? "UDP KeepAlive" : "", pattern_type);
+
+		if (net_socket.is_add_resume) {
+			suspend_and_resume(net_socket.fd, G_pm_pipefd[1]);
+		}
+	}
+}
+
+void process_packet(u_char *arg, const struct pcap_pkthdr* pkthdr, const u_char * packet)
+{
+	int i = 0;
+	int *counter = (int *)arg;
+
+	logd("Packet[%d] Count: %d.\n", pkthdr->len, ++(*counter));
+	logv("Packet DUMP:\n");
+	for(i = 0; i < pkthdr->len; ++i) {
+		logv(" %02x", packet[i]);
+		if( (i + 1) % 16 == 0 ) {
+			logv("\n");
+		}
+	}
+	logv("\n\n");
+
+	if (net_socket.is_tcp) {
+		process_tcp(pkthdr, packet);
+	} else {
+		process_udp(pkthdr, packet);
+	}
+	return;
+}
+
+void start_pcap(void)
+{
+	int count = 0;
+	if (pcap_loop(pG_pcap, -1, process_packet, (u_char *)&count) == -1) {
+		loge("ERROR pcap_loop: %s\n", pcap_geterr(pG_pcap) );
+	}
+	pcap_close(pG_pcap);
+	pG_pcap = NULL;
+}
+
+static void default_param(void)
+{
+	net_socket.fd = -1;
+	net_socket.is_session = 0;
+	net_socket.is_close = 0;
+	net_socket.is_tcp = 1;
+	net_socket.is_add_tcp_payload = 1;
+	net_socket.is_enable_pattern = 0;
+	net_socket.is_enable_filter= 0;
+	net_socket.is_enable_host_cipher = 0;
+	net_socket.is_enable_host_sleep = 0;
+	net_socket.is_enable_suspend = 0;
+	net_socket.is_poll = 0;
+	net_socket.is_add_resume = 0;
+	net_socket.is_reconn= 0;
+
+	net_socket.is_sys_exec = 0;
+	net_socket.suspend_pm = 1;
+	net_socket.wifi_chip_id = WIFI_BCM43340;
+	net_socket.log_level = LOG_INFO;
+	net_socket.port = DEFAULT_PORT;
+	net_socket.interval = DEFAULT_INTERVAL;
+	net_socket.dtim_interval = DEFAULT_DTIM_INTERVAL;
+
+	memset(net_socket.iface, 0, sizeof(net_socket.iface));
+	memset(net_socket.srv_ip, 0, sizeof(net_socket.srv_ip));
+	strncpy(net_socket.srv_ip, DEFAULT_HOST, sizeof(net_socket.srv_ip));
+	strncpy(net_socket.send_msg, DEFAULT_MSG, sizeof(net_socket.send_msg));
+	net_socket.send_msg_len = strlen(net_socket.send_msg);
+}
+
+static void show_wifi_chip()
+{
+	char wifi_chip_str[32];
+
+	switch(net_socket.wifi_chip_id) {
+	case WIFI_BCM43340:
+		sprintf(wifi_chip_str, "BCM43340");
+		break;
+	case WIFI_BCM43438:
+		sprintf(wifi_chip_str, "BCM43438/BCM43455");
+		break;
+	default:
+		sprintf(wifi_chip_str, "Unknown");
+		break;
+	}
+	logd("WiFi Chip ID: %s\n", wifi_chip_str);
+}
+
+static void sigstop()
+{
+	G_running = 0;
+	close_fd(&net_socket.fd);
+
+	if (pG_pcap) {
+		pcap_close(pG_pcap);
+		pG_pcap = NULL;
+	}
+	pthread_cancel(G_pcap_tid);
+}
+
+int main(int argc, char *argv[])
+{
+	int ret = -1;
+
+	char *device = NULL;
+	char errbuf[PCAP_ERRBUF_SIZE];
+	char sniffer_filter[FILTER_MAXSIZE];
+	struct bpf_program filter;
+
+	printf("wowl version : %s, compile time : %s .\n", WOWL_VERSION, __TIME__);
+
+	if (argc < 2) {
+		usage();
+		return -1;
+	}
+
+	signal(SIGINT, sigstop);
+	signal(SIGQUIT, sigstop);
+	signal(SIGTERM, sigstop);
+
+	default_param();
+	if (init_param(argc, argv) < 0) {
+		usage();
+		return -1;
+	}
+
+	set_log_level(net_socket.log_level);
+	show_wifi_chip();
+	brcm_ioc_wowl_init(net_socket.iface, net_socket.wifi_chip_id, net_socket.is_sys_exec);
+
+	if (pipe(G_pm_pipefd) < 0) {
+		perror("pipe");
+		return -1;
+	}
+	logd("Pipe.0[%d], Pipe.1[%d]\n", G_pm_pipefd[0], G_pm_pipefd[1]);
+
+	memset(errbuf, 0, PCAP_ERRBUF_SIZE);
+	if (net_socket.iface[0] != '\0') {
+		device = net_socket.iface;
+	} else {
+		if ((device = pcap_lookupdev(errbuf)) == NULL) {
+			loge("ERROR pcap_lookupdev: %s\n", errbuf);
+			return -1;
+		}
+	}
+	logd("Libpcap iface: %s\n", device);
+	if (net_socket.is_tcp) {
+		snprintf(sniffer_filter, sizeof(sniffer_filter), "tcp dst port %d", net_socket.port);
+	} else {
+		snprintf(sniffer_filter, sizeof(sniffer_filter), "udp dst port %d", net_socket.port);
+	}
+	if ((pG_pcap = pcap_open_live(device, MAXBYTES2CAPTURE, 1,
+		FILTER_MAXSIZE, errbuf)) == NULL) {
+		loge("ERROR pcap_live : %s\n", errbuf);
+		return -1;
+	}
+	pcap_compile(pG_pcap, &filter, sniffer_filter, 1, 0);
+	pcap_setfilter(pG_pcap, &filter);
+	logi("Set Sniffer Network Filter [%s]\n", sniffer_filter);
+	ret = pthread_create(&G_pcap_tid, NULL, (void *)start_pcap, NULL);
+	if (ret != 0) {
+		perror("Create pthread pcap");
+		return -1;
+	}
+
+	if (net_socket.is_session) {
+		if (net_socket.is_tcp) {
+			ret = socket_client_tcp();
+		} else {
+			ret = socket_client_udp();
+		}
+	}
+
+	/* Exit Process */
+	if (G_pcap_tid) {
+		pthread_join(G_pcap_tid, NULL);
+		G_pcap_tid = -1;
+	}
+	if (pG_pcap) {
+		pcap_close(pG_pcap);
+		pG_pcap = NULL;
+	}
+	close_fd(&G_pm_pipefd[0]);
+	close_fd(&G_pm_pipefd[1]);
+	close_fd(&net_socket.fd);
+
+	return ret;
+}
diff --git a/fastboot_app/device_agent/include/defs.h b/fastboot_app/device_agent/include/defs.h
new file mode 100644
index 0000000..5bf2521
--- /dev/null
+++ b/fastboot_app/device_agent/include/defs.h
@@ -0,0 +1,279 @@
+/*
+ * defs.h
+ *
+ * History:
+ *       2015/03/10 - [jywang] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef __DEFS_H__
+#define __DEFS_H__
+
+// #define NDEBUG
+
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <string.h>
+#include <assert.h>
+
+#include <unistd.h>
+#include <errno.h>
+
+#ifndef NDEBUG
+#define LOGI(fmt, ...)      fprintf(stdout, "[I] %s(%d): " fmt "\n", __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__)
+#define LOGD(fmt, ...)      fprintf(stdout, "[D] %s(%d): " fmt "\n", __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__)
+#define LOGE(fmt, ...)      fprintf(stdout, "[E] %s(%d): " fmt "\n", __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__)
+#define LOGW(fmt, ...)      fprintf(stdout, "[W] %s(%d): " fmt "\n", __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__)
+#define LOGV(fmt, ...)      fprintf(stdout, "[V] %s(%d): " fmt "\n", __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__)
+#define ASSERT(x)			assert(x);
+#else
+#define LOGI(fmt, ...)
+#define LOGD(fmt, ...)
+#define LOGE(fmt, ...)
+#define LOGW(fmt, ...)
+#define LOGV(fmt, ...)
+#define ASSERT(x)
+#endif
+
+#define MAJOR_VERSION       1
+#define MINOR_VERSION       1
+
+typedef void    *handle_t, **handle_ptr_t;
+typedef void    *void_ptr_t, **void_pptr_t;
+
+void_ptr_t 	mem_allocz(int32_t size);
+void		mem_free_ptr(void_ptr_t p);
+void		mem_free_pptr(void_pptr_t pp);
+
+#define MEM_ALLOCZ(type)	(type*)mem_allocz(sizeof(type))
+#define MEM_FREE_PTR(p)		mem_free_ptr((void_ptr_t)p)
+#define MEM_FREE_PPTR(pp)	mem_free_pptr((void_pptr_t)pp)
+
+#define INVALID_FD          -1
+#define INVALID_ID          -1
+
+#define MAX_IP_LEN                          64
+#define MAX_PORT_LEN                        12
+#define MAX_PATH_LEN                        256
+#define BUF_SIZE_2048                       2048
+#define FLAG_IO_READ_WRITE                  0x03
+#define MAX_UID_LEN                         64
+#define MAX_WAKE_TOKEN_LEN                  128
+#define MAX_CATEGORY_NAME_LEN               64
+
+#define CONF_DEVICE_APP_PORT                7777
+#define CONF_CLOUD_APP_PORT                 8000
+#define CONF_CLOUD_DEV_PORT                 8888
+#define CONF_DEV_WAKEUP_PORT                7877
+#define CONF_WDOG_TIME_PERIOD               4                               // unit: sec
+#define CONF_DEV_CLIENT_ONLINE_TIMOUT       (16/CONF_WDOG_TIME_PERIOD)      // unit: CONF_WDOG_TIME_PERIOD sec
+#define CONF_DEV_CLIENT_STANDBY_TIMOUT      (16/CONF_WDOG_TIME_PERIOD)      // unit: CONF_WDOG_TIME_PERIOD sec
+#define CONF_APP_CLIENT_TIMEOUT             (3600/CONF_WDOG_TIME_PERIOD)    // unit: CONF_WDOG_TIME_PERIOD sec
+#define CONF_APP_CONNECT_TIMEOUT            4
+
+
+#define MSG_COMMON          \
+    uint32_t    what;       \
+    handle_t    obj;        \
+    int32_t     para1;      \
+    int32_t     para2;
+
+typedef struct {
+    MSG_COMMON
+} msg_t, *msg_ptr_t, **msg_pptr_t;
+
+#define RESULT_COMMON       \
+    int32_t     ret;        \
+    handle_t    obj;        \
+    int32_t     para1;      \
+    int32_t     para2;
+
+typedef struct {
+    RESULT_COMMON
+} result_t, *result_ptr_t, **result_pptr_t;
+
+typedef void (*msg_notify_cb_t)(handle_t h, msg_ptr_t p_msg, result_ptr_t p_result);
+typedef void (*msg_proc_cb_t)(handle_t h, msg_ptr_t p_msg, result_ptr_t p_result);
+
+enum {
+    STATE_INVALID,
+    STATE_CREATED,
+    STATE_INITIALIZED,
+    STATE_STARTED,
+    STATE_STOPPED,
+    STATE_ERROR_INIT,
+    STATE_ERROR_START,
+};
+
+/* msg */
+// |--8--|--8--|-----16-----|
+//
+// |-reserved-|-catgory-|-detail-|
+
+#define MSG_RESERVED_OFFSET             24
+#define MSG_CAT_OFFSET                  16
+#define MSG_VALUE_OFFSET                0
+
+#define MSG_RESERVED_MASK               (0xFF<<MSG_RESERVED_OFFSET)
+#define MSG_CAT_MASK                    (0xFF<<MSG_CAT_OFFSET)
+#define MSG_VALUE_MASK                  (0xFFFF<<MSG_VALUE_OFFSET)
+
+#define MSG_CAT(what)                   ( ((what) & MSG_CAT_MASK) >> MSG_CAT_OFFSET)
+#define MSG_VALUE(what)                 ( ((what) & MSG_VALUE_MASK) >> MSG_VALUE_OFFSET)
+#define MSG_WHAT(cat, value)            ((cat)<<MSG_CAT_OFFSET | (value)<<MSG_VALUE_OFFSET)
+#define MSG_DELIMITER                   '\n'
+
+enum {
+    MSG_CAT_RESERVED                = 0x00,
+    MSG_CAT_CLOUD                   = 0x01,
+    MSG_CAT_DEVICE                  = 0x02,
+    MSG_CAT_APP                     = 0x03,
+    MSG_CAT_WEB                     = 0x04,
+
+    MSG_CAT_DBG                     = 0xFE,
+    MSG_CAT_SELF                    = 0xFF,
+};
+
+enum {
+    RET_OK                          = 0,
+    //
+
+    RET_ERROR                       = -1,
+    RET_ERROR_BUSY                  = -2,
+    RET_ERROR_INVLAID_STATE         = -3,
+    RET_ERROR_READ                  = -4,
+    RET_ERROR_WRITE                 = -5,
+    RET_ERROR_EOF                   = -6,
+    RET_ERROR_IN_BUF_FULL           = -7,
+    RET_ERROR_OUT_BUF_FULL          = -8,
+    RET_ERROR_CLIENT                = -9,
+    RET_ERROR_INVLAID_MSG           = -10,
+    RET_ERROR_NOT_FOUND             = -11,
+    RET_ERROR_NO_HANDLER            = -12,
+    RET_ERROR_MEM_NOT_ENOUGH        = -13,
+};
+
+typedef struct ctx ctx_t, *ctx_ptr_t, **ctx_pptr_t;
+
+#define CTX_COMMON                                                          \
+    int32_t (*start)(ctx_ptr_t p_ctx);                                      \
+    int32_t (*stop)(ctx_ptr_t p_ctx);                                       \
+    void    (*destroy)(ctx_pptr_t pp_ctx);
+
+#define CTX_PPTR_DESTROY(ctx_pptr)                                          \
+    if (ctx_pptr) (*(ctx_pptr))->destroy(ctx_pptr);
+
+
+struct ctx {
+    CTX_COMMON
+};
+
+
+#define KEY_WHAT                        "what"
+#define KEY_RET                         "ret"
+#define KEY_ERROR                       "error"
+#define KEY_STAT                        "stat"
+#define KEY_QUANTITY                    "quantity"
+#define KEY_STATE                       "state"
+#define KEY_IP                          "ip"
+#define KEY_PORT                        "port"
+#define KEY_UID                         "uid"
+#define KEY_MODE                        "mode"
+#define KEY_TOKEN                       "token"
+#define KEY_CATEGORY                    "category"
+
+#define KEY_PIR_STAT                    "pir_stat"
+#define KEY_BATTERY_STAT                "battery_stat"
+#define KEY_BATTERY_QUANTITY            "battery_quantity"
+#define KEY_CHARGE_STAT                 "charge_stat"
+#define KEY_DC_STAT                     "dc_stat"
+#define KEY_CLOUD                       "cloud"
+#define KEY_STREAM_ID                   "stream_id"
+
+
+enum {
+    MSG_RESERVED_HOME               = MSG_WHAT(MSG_CAT_RESERVED, 0),
+    MSG_RESERVED_SYNC               = MSG_RESERVED_HOME,
+    MSG_RESERVED_PLAY_AUDIO,
+    MSG_RESERVED_SHUTDOWN,
+    MSG_RESERVED_END,
+
+    MSG_DEVICE_HOME                 = MSG_WHAT(MSG_CAT_DEVICE, 0),
+    MSG_DEVICE_LOGIN,
+    MSG_DEVICE_LOGOUT,
+    MSG_DEVICE_BATTERY,
+    MSG_DEVICE_CHARGE,
+    MSG_DEVICE_DC,
+    MSG_DEVICE_PIR,
+    MSG_DEVICE_ALARM,
+    MSG_DEVICE_SHUTDOWN,
+    MSG_DEVICE_STANDBY_TCP,
+    MSG_DEVICE_STANDBY_UDP,
+    MSG_DEVICE_WAKEUP_TCP,
+    MSG_DEVICE_WAKEUP_UDP,
+    MSG_DEVICE_STATUS_UPDATE,
+    MSG_DEVICE_AGENT_CONNECTED,
+    MSG_DEVICE_SYNC,
+    MSG_DEVICE_AGENT_CANNOT_CONNECT,
+    MSG_FAST_STREAMING              = MSG_WHAT(MSG_CAT_DEVICE, 0x12),
+    MSG_DEVICE_END,
+
+    MSG_APP_HOME                    = MSG_WHAT(MSG_CAT_APP, 0),
+    MSG_APP_LOGIN,
+    MSG_APP_LOGOUT,
+    MSG_APP_GET_DEVICE_LIST,
+    MSG_APP_GET_DEVICE_DETAIL,
+    MSG_APP_GET_EVENT_LIST,
+    MSG_APP_GET_EVENT_DETAIL,
+    MSG_APP_END,
+
+    MSG_CLOUD_HOME                  = MSG_WHAT(MSG_CAT_CLOUD, 0),
+    MSG_CLOUD_END,
+
+    MSG_DBG_HOME                    = MSG_WHAT(MSG_CAT_DBG, 0),
+    MSG_DBG_CANNOT_CONNECT_CLOUD,
+    MSG_DBG_START_RTSP_INJECTOR,
+    MSG_DBG_END,
+};
+
+enum {
+    DEVICE_STATE_OFFLINE,
+    DEVICE_STATE_ONLINE,
+    DEVICE_STATE_STANDBY,
+};
+
+enum {
+    DEVICE_MODE_INVALID,
+    DEVICE_MODE_RECORDING,
+    DEVICE_MODE_STREAMING,
+    DEVICE_MODE_STANDBY_TCP,
+    DEVICE_MODE_STANDBY_UDP,
+};
+
+#endif
diff --git a/fastboot_app/device_agent/include/device.h b/fastboot_app/device_agent/include/device.h
new file mode 100644
index 0000000..708b567
--- /dev/null
+++ b/fastboot_app/device_agent/include/device.h
@@ -0,0 +1,80 @@
+/*
+ * device.h
+ *
+ * History:
+ *       2015/03/10 - [jywang] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef __DEVICE_H__
+#define __DEVICE_H__
+
+#include "defs.h"
+
+typedef struct {
+    char        srv_ip[MAX_IP_LEN];
+    int32_t     srv_dev_port;
+    char        dev_uid[MAX_UID_LEN];
+    int32_t     dev_mode;
+    char        dev_category[MAX_CATEGORY_NAME_LEN];
+    char        dev_token[MAX_WAKE_TOKEN_LEN];
+} param_device_t, *param_device_ptr_t;
+#ifdef __cplusplus
+extern "C" {
+#endif
+handle_t device_create(param_device_ptr_t p_param);
+void     device_destroy(handle_ptr_t h_ptr);
+
+int32_t  device_init(handle_t h_device);
+int32_t  device_deinit(handle_t h_device);
+
+int32_t  device_start(handle_t h_device);
+int32_t  device_stop(handle_t h_device);
+
+int32_t  device_state(handle_t h_device);
+bool     device_is_running(handle_t h_device);
+
+int32_t  device_msg_post(handle_t h_device, int32_t what);
+int32_t  device_msg_request(handle_t h_device, msg_ptr_t p_msg, msg_notify_cb_t notify_cb);
+int32_t  device_msg_cancel(handle_t h_device, int32_t msg_id);
+
+void device_set_msg_notify_cb(handle_t h_device, handle_t h_opaque, msg_notify_cb_t notify_cb);
+void device_set_device_mode(handle_t h_device,int32_t  dev_mode);
+
+void device_connect_cloud(handle_t h_device);
+void device_connect_cloud_fd(handle_t h_device, int32_t fd);
+void device_disconnect_cloud(handle_t h_device);
+void device_standby(handle_t h_device);
+void device_online_streaming(handle_t h_device);
+
+int32_t device_standby_tcp(int32_t fd, const char *uid, const char *category, unsigned char *p_token, int32_t token_len);
+int32_t device_standby_udp(int32_t fd, const char *uid, const char *category, unsigned char *p_token, int32_t token_len);
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif
diff --git a/fastboot_app/device_agent/make.inc b/fastboot_app/device_agent/make.inc
new file mode 100644
index 0000000..552c276
--- /dev/null
+++ b/fastboot_app/device_agent/make.inc
@@ -0,0 +1,99 @@
+#
+# make.inc
+#
+# History:
+#       2015/03/10 - [jywang] created file
+#
+# Copyright (c) 2015 Ambarella, Inc.
+#
+# This file and its contents ("Software") are protected by intellectual
+# property rights including, without limitation, U.S. and/or foreign
+# copyrights. This Software is also the confidential and proprietary
+# information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+# disclose, distribute, modify, or otherwise prepare derivative works of this
+# Software or any portion thereof except pursuant to a signed license agreement
+# or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+# In the absence of such an agreement, you agree to promptly notify and return
+# this Software to Ambarella, Inc.
+#
+# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+# MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+# IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+#
+########################################################
+# libdevice_agent.a
+########################################################
+
+LOCAL_PATH   := $(call my-dir)
+include $(CLEAR_VARS)
+
+SRC_DIR = $(LOCAL_PATH)/src
+INC_DIR = -I$(LOCAL_PATH)/include \
+		-I$(SRC_DIR) \
+		-I$(PREBUILD_3RD_PARTY_DIR)/libev/include \
+		-I$(PREBUILD_3RD_PARTY_DIR)/json-c/include
+
+LOCAL_TARGET	:= libdevice_agent.a
+LOCAL_SRCS := $(SRC_DIR)/defs.c \
+		$(SRC_DIR)/queue.c	\
+		$(SRC_DIR)/channel.c	\
+		$(SRC_DIR)/impl_dev.c	\
+		$(SRC_DIR)/agent_dev.c	\
+		$(SRC_DIR)/proc_dev.c
+
+LOCAL_CFLAGS   := $(INC_DIR) -Wall -O2 -std=c99 -ffast-math -Wno-unused-parameter -fno-strict-aliasing -Wno-missing-field-initializers
+ifeq ($(CONFIG_AMBARELLA_ALSA_SUPPORT), y)
+LOCAL_CFLAGS += -DAUDIO_INPUT_ALSA_SUPPORTED=1
+endif
+
+include $(BUILD_APP)
+
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+
+
+########################################################
+# test_device_agent
+########################################################
+include $(CLEAR_VARS)
+
+SRC_DIR = $(LOCAL_PATH)/src
+INC_DIR = -I$(LOCAL_PATH)/include
+
+IPCAM_APP_BIN_DIR = $(FAKEROOT_DIR)/usr/bin
+IPCAM_APP_LOCAL_BIN_DIR := $(FAKEROOT_DIR)/usr/local/bin
+
+LOCAL_TARGET	:= test_device_agent
+LOCAL_SRCS	:= $(LOCAL_PATH)/test_device_agent.c
+LOCAL_CFLAGS  	:= $(INC_DIR) -Wall -O2 -std=c99 -ffast-math -Wno-unused-parameter -fno-strict-aliasing -Wno-missing-field-initializers
+LOCAL_LIBS	:= libdevice_agent.a
+LOCAL_LDFLAGS	:= -L$(PREBUILD_3RD_PARTY_DIR)/json-c/usr/lib \
+		-L$(PREBUILD_3RD_PARTY_DIR)/libev/usr/lib \
+		-lev -ljson-c  -lpthread -lm \
+		-Wl,-rpath-link=$(FAKEROOT_DIR)/usr/lib
+
+include $(BUILD_APP)
+
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(IPCAM_APP_BIN_DIR)/
+	@cp -dpRf $< $(IPCAM_APP_BIN_DIR)/
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+
+###
diff --git a/fastboot_app/device_agent/src/agent_dev.c b/fastboot_app/device_agent/src/agent_dev.c
new file mode 100644
index 0000000..fb6ea55
--- /dev/null
+++ b/fastboot_app/device_agent/src/agent_dev.c
@@ -0,0 +1,820 @@
+/*
+ * agent_dev.c
+ *
+ * History:
+ *       2015/03/10 - [jywang] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include "device.h"
+#include "impl_dev.h"
+#include "agent_dev.h"
+#include "proc_dev.h"
+
+#include <semaphore.h>
+#include <unistd.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+
+#include <sys/time.h>
+
+typedef struct {
+    CTX_COMMON
+
+    pthread_t           thread;
+    pthread_mutex_t     lock;
+    sem_t               sem;
+
+    device_ptr_t        p_device;
+
+    loop_ptr_t          p_loop;
+    channel_ptr_t       p_channel_agent;
+    channel_ptr_t       p_channel_task;
+
+    int32_t             agent_reconnect_times;
+    handle_t            h_opaque;
+    msg_notify_cb_t     msg_notify_cb;
+} agent_dev_t, *agent_dev_ptr_t, **agent_dev_pptr_t;
+
+typedef struct {
+    queue_elem_t        elem;
+
+    ctx_ptr_t           p_ctx;
+    int32_t             task_id;
+    msg_t               msg;
+    msg_notify_cb_t     msg_notify_cb;
+} task_entry_t, *task_entry_ptr_t;
+
+typedef struct {
+    CHANNEL_COMMON
+
+    pthread_mutex_t     lock;
+
+    agent_dev_ptr_t     p_agent_dev;
+    queue_t             queue_task;
+    int32_t             task_id;
+} channel_task_t, *channel_task_ptr_t, **channel_task_pptr_t;
+
+// channel_agent_dev
+static int32_t channel_agent_dev_handle_read(channel_agent_dev_ptr_t p_client) {
+    if (p_client->r_off == p_client->buf_size) {
+        LOGD("buf full");
+        return RET_ERROR_IN_BUF_FULL;
+    }
+
+    int32_t len = (int32_t)read(p_client->watcher.io.fd, p_client->r_buf + p_client->r_off, p_client->buf_size - p_client->r_off);
+    if (len > 0) {
+        p_client->r_off += len;
+
+        // loop
+        // 1. find next sync byte
+        // 2. check whether it is a message indeed.
+        //    if NO, log error and skip, goto 1;
+        //    if YES, parse message -> handle it -> output
+        // 3. send output
+
+        int32_t beg, end;
+        beg = end = len = 0;
+
+        while (beg < p_client->r_off) {
+            char *p_end = (char *)memchr(p_client->r_buf + beg, MSG_DELIMITER, p_client->r_off - beg);
+            if (!p_end) { break; }
+
+            end = (int32_t)(p_end - p_client->r_buf);
+            len = end - beg;
+
+            if (agent_cloud_msg_proc((channel_ptr_t)p_client, p_client->r_buf + beg, len) < 0) {
+                return RET_ERROR_CLIENT;
+            }
+
+            beg = end + 1;
+        }
+
+        while (beg < p_client->r_off && p_client->r_buf[beg] == '\0') { beg++; }
+
+        int32_t left = p_client->r_off - beg;
+        if (beg != 0 && left > 0) {
+            // skip zero
+            memmove(p_client->r_buf, p_client->r_buf + beg, left);
+        }
+        p_client->r_off = left;
+    } else if (len == 0) {
+        return RET_ERROR_EOF;
+    } else {
+        if (errno != EINTR && errno != EAGAIN) { return RET_ERROR_READ; }
+    }
+    return RET_OK;
+}
+
+static int32_t channel_agent_dev_handle_write(channel_agent_dev_ptr_t p_client) {
+    if (p_client->w_off == 0) { return RET_OK; }
+
+    int32_t ret = (int32_t)write(p_client->watcher.io.fd, p_client->w_buf, p_client->w_off);
+    if (ret == -1) {
+        if (errno != EINTR && errno != EAGAIN) { return RET_ERROR_WRITE; }
+    } else {
+        int32_t left = p_client->w_off - ret;
+        if (left > 0) { memmove(p_client->w_buf, p_client->w_buf + ret, left); }
+        p_client->w_off = left;
+    }
+    return RET_OK;
+}
+
+static void channel_agent_dev_cb(EV_P_ ev_io *watcher, int32_t revents) {
+    if (EV_ERROR & revents) {
+        LOGE("revents:%x", revents);
+        return ;
+    }
+
+    channel_agent_dev_ptr_t p_client = (channel_agent_dev_ptr_t)(((char*)watcher) - offsetof(channel_t, watcher));
+    agent_dev_ptr_t p_agent_dev = (agent_dev_ptr_t)p_client->p_ctx;
+
+    int32_t ret;
+    if (EV_READ & revents) {
+        ret = channel_agent_dev_handle_read(p_client);
+        if (ret < 0) {
+            LOGD("read_error: fd=%d ret=%d", watcher->fd, ret);
+            p_agent_dev->p_channel_agent->destroy(&p_agent_dev->p_channel_agent);
+            return ;
+        }
+    }
+
+    if (EV_WRITE & revents) {
+        ret = channel_agent_dev_handle_write(p_client);
+        if (ret < 0) {
+            LOGD("write_error: fd=%d ret=%d", watcher->fd, ret);
+            p_agent_dev->p_channel_agent->destroy(&p_agent_dev->p_channel_agent);
+            return ;
+        }
+    }
+
+    int32_t flags = EV_READ;
+    if (p_client->w_off > 0) { flags |= EV_WRITE; }
+    channel_io_update((channel_ptr_t)p_client, flags);
+}
+
+static channel_ptr_t channel_agent_dev_create(agent_dev_ptr_t p_ctx, int32_t fd) {
+    channel_agent_dev_ptr_t p_channel = MEM_ALLOCZ(channel_agent_dev_t);
+    do {
+        if (!p_channel) {
+            LOGE("alloc failure");
+            break;
+        }
+
+        p_channel->buf_size = BUF_SIZE_2048;
+        p_channel->start = channel_io_start;
+        p_channel->stop = channel_io_stop;
+        p_channel->destroy = channel_io_destroy;
+
+        p_channel->p_ctx = (ctx_ptr_t) p_ctx;
+
+        int32_t flag = fcntl(fd, F_GETFL);
+        fcntl(fd, F_SETFL, flag | O_NONBLOCK);
+
+        ev_io_init(&p_channel->watcher.io, channel_agent_dev_cb, fd, EV_READ);
+        return (channel_ptr_t)p_channel;
+    } while (0);
+
+    if (p_channel) { p_channel->destroy((channel_pptr_t)&p_channel); }
+    return NULL;
+}
+
+// channel_task
+static void task_init(task_entry_ptr_t p_task,
+                      ctx_ptr_t        p_ctx,
+                      int32_t          task_id,
+                      msg_ptr_t        p_msg,
+                      msg_notify_cb_t  msg_notify_cb)
+{
+    p_task->p_ctx = p_ctx;
+    p_task->task_id = task_id;
+    memmove(&p_task->msg, p_msg, sizeof(msg_t));
+    p_task->msg_notify_cb = msg_notify_cb;
+}
+
+static int connect_non_blocking(int sockfd, const struct sockaddr_in *saptr, socklen_t salen, int nsec) {
+    int flags,n,error;
+    socklen_t len;
+    fd_set rset, wset;
+    struct timeval tval;
+
+    flags = fcntl(sockfd, F_GETFL, 0);
+    fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);
+
+    error = 0;
+    if ((n = connect(sockfd, (struct sockaddr *) saptr, salen)) < 0){
+        if (errno != EINPROGRESS){
+            return(-1);
+        }
+    }
+    /* Do whatever we want while the connect is taking place. */
+    if (n == 0) {
+        goto done;/* connect completed immediately */
+    }
+
+    FD_ZERO(&rset);
+    FD_SET(sockfd, &rset);
+    wset = rset;
+    tval.tv_sec = nsec;
+    tval.tv_usec = 0;
+    while ((n = select(sockfd+1, &rset, &wset, NULL,nsec ? &tval : NULL)) < 0 && errno == EINTR);
+    if (n == 0) {
+        errno = ETIMEDOUT;
+        return(-1);
+    }
+    if (FD_ISSET(sockfd, &rset) || FD_ISSET(sockfd, &wset)) {
+        len = sizeof(error);
+        if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &error, &len) < 0){
+            return(-1);
+        }
+    } else{
+        return (-1);/*select error*/
+    }
+done:
+    fcntl(sockfd, F_SETFL, flags);/* restore file status flags */
+    if (error) {
+        errno = error;
+        return(-1);
+    }
+    return(0);
+}
+
+static int32_t task_proc(task_entry_ptr_t p_task_entry) {
+    agent_dev_ptr_t p_agent_dev = (agent_dev_ptr_t)p_task_entry->p_ctx;
+
+    switch (p_task_entry->msg.what) {
+        case MSG_SELF_BREAK_LOOP: {
+            ev_break (p_agent_dev->p_loop, EVBREAK_ALL);
+        } break;
+        case MSG_SELF_CHANNEL_UPDATE: {
+            channel_agent_dev_ptr_t p_client = (channel_agent_dev_ptr_t)p_task_entry->msg.obj;
+            int32_t flags = EV_READ;
+            if (p_client->w_off > 0) { flags |= EV_WRITE; }
+            channel_io_update((channel_ptr_t)p_client, flags);
+        } break;
+        case MSG_SELF_CONNECT_CLOUD: {
+            const char *p_ip = (const char*) p_agent_dev->p_device->param.srv_ip;
+            int port = p_agent_dev->p_device->param.srv_dev_port;
+
+            int sock = 0;
+            do {
+                sock = socket(AF_INET, SOCK_STREAM, 0);
+                if (sock < 0) {
+                    LOGE("create socket failure");
+                    break;
+                }
+
+                //query wlan0 address
+                struct ifreq ifr;
+                strcpy(ifr.ifr_name, "wlan0");
+                if (ioctl(sock, SIOCGIFADDR, &ifr) <  0) {
+                    LOGE("failed to query wlan0 address\n");
+                    msg_t msg;
+                    msg.what = MSG_DEVICE_AGENT_CANNOT_CONNECT;
+                    agent_dev_notify(p_task_entry->p_ctx, &msg, NULL);
+                    break;
+                }
+                struct sockaddr_in clientAddr;
+                int flag=1;
+                clientAddr.sin_family = AF_INET;
+                clientAddr.sin_addr.s_addr = ((struct sockaddr_in*)&(ifr.ifr_addr))->sin_addr.s_addr;
+                clientAddr.sin_port = htons(CONF_DEVICE_APP_PORT);
+                setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &flag, sizeof(flag));
+                if(bind(sock, (struct sockaddr*)&clientAddr, sizeof(clientAddr)) < 0) {
+                    LOGE("failed to bind %s:%d\n", inet_ntoa(((struct sockaddr_in*)&(ifr.ifr_addr))->sin_addr), CONF_DEVICE_APP_PORT);
+                    msg_t msg;
+                    msg.what = MSG_DEVICE_AGENT_CANNOT_CONNECT;
+                    agent_dev_notify(p_task_entry->p_ctx, &msg, NULL);
+                    break;
+                }
+
+                struct sockaddr_in srvAddr;
+                srvAddr.sin_family = AF_INET;
+                srvAddr.sin_addr.s_addr = inet_addr(p_ip);
+                srvAddr.sin_port = htons(port);
+
+                int ret = connect_non_blocking(sock, &srvAddr, sizeof(srvAddr), CONF_APP_CONNECT_TIMEOUT);
+                if (ret < 0) {
+                    LOGE("can't connect cloud %s:%d\n", p_ip, port);
+                    msg_t msg;
+                    msg.what = MSG_DEVICE_AGENT_CANNOT_CONNECT;
+                    agent_dev_notify(p_task_entry->p_ctx, &msg, NULL);
+                    break;
+                }
+
+                {
+                    msg_t msg;
+                    msg.what = MSG_DEVICE_AGENT_CONNECTED;
+                    agent_dev_notify(p_task_entry->p_ctx, &msg, NULL);
+                }
+
+                channel_t *p_channel = channel_agent_dev_create(p_agent_dev, sock);
+                if (!p_channel) {
+                    LOGE("create agent_dev failure");
+                    break;
+                }
+
+                p_agent_dev->p_channel_agent = p_channel;
+                p_channel->start(p_channel, p_agent_dev->p_loop);
+
+                sprintf(g_tmp_buf, "{\"%s\":%d, \"%s\":\"%s\", \"%s\":%d, \"%s\":%d, \"%s\":\"%s\"}\n",
+                        KEY_WHAT, MSG_DEVICE_LOGIN,
+                        KEY_UID, p_agent_dev->p_device->param.dev_uid,
+                        KEY_STATE, DEVICE_STATE_ONLINE,
+                        KEY_MODE, p_agent_dev->p_device->param.dev_mode,
+                        KEY_CATEGORY, p_agent_dev->p_device->param.dev_category);
+                agent_dev_cloud_send_sync(p_agent_dev->p_channel_agent, g_tmp_buf, (int32_t)strlen(g_tmp_buf));
+                LOGD("MSG_SELF_CONNECT_CLOUD %s:%d Done\n", p_ip, port);
+                return 0;
+            } while (0);
+
+            if (sock > 0) { close(sock); }
+
+            // TODO
+            // use timer instead
+            /*
+            if (p_agent_dev->agent_reconnect_times < AGENT_RECONNECT_TIMES_THRESHOLD) {
+                p_agent_dev->agent_reconnect_times++;
+
+                sleep(1);
+                agent_dev_msg_post(p_task_entry->p_ctx, MSG_SELF_CONNECT_CLOUD);
+            } else {
+                p_agent_dev->agent_reconnect_times = 0;
+            }
+            */
+        } break;
+        case MSG_SELF_CONNECT_CLOUD_FD:{
+            const char *p_ip = (const char*) p_agent_dev->p_device->param.srv_ip;
+            int port = p_agent_dev->p_device->param.srv_dev_port;
+            do {
+                {
+                    msg_t msg;
+                    msg.what = MSG_DEVICE_AGENT_CONNECTED;
+                    agent_dev_notify(p_task_entry->p_ctx, &msg, NULL);
+                }
+
+                channel_t *p_channel = channel_agent_dev_create(p_agent_dev, p_task_entry->msg.para1);
+                if (!p_channel) {
+                    LOGE("create agent_dev failure");
+                    break;
+                }
+
+                p_agent_dev->p_channel_agent = p_channel;
+                p_channel->start(p_channel, p_agent_dev->p_loop);
+
+                sprintf(g_tmp_buf, "{\"%s\":%d, \"%s\":\"%s\", \"%s\":%d, \"%s\":%d, \"%s\":\"%s\"}\n",
+                        KEY_WHAT, MSG_DEVICE_LOGIN,
+                        KEY_UID, p_agent_dev->p_device->param.dev_uid,
+                        KEY_STATE, DEVICE_STATE_ONLINE,
+                        KEY_MODE, p_agent_dev->p_device->param.dev_mode,
+                        KEY_CATEGORY, p_agent_dev->p_device->param.dev_category);
+                agent_dev_cloud_send_sync(p_agent_dev->p_channel_agent, g_tmp_buf, (int32_t)strlen(g_tmp_buf));
+                LOGD("MSG_SELF_CONNECT_CLOUD %s:%d Done\n", p_ip, port);
+            } while (0);
+        }break;
+        case MSG_SELF_DISCONNECT_CLOUD: {
+            if (p_agent_dev->p_channel_agent) {
+                p_agent_dev->p_channel_agent->destroy(&p_agent_dev->p_channel_agent);
+            }
+        } break;
+        case MSG_SELF_STANDBY_TCP: {
+            if (!p_agent_dev->p_channel_agent) {
+                LOGE("can't notify cloud");
+                break;
+            }
+            sprintf(g_tmp_buf, "{\"%s\":%d, \"%s\":\"%s\", \"%s\":%d, \"%s\":%d, \"%s\":\"%s\", \"%s\":\"%s\"}\n",
+                    KEY_WHAT, MSG_DEVICE_STANDBY_TCP,
+                    KEY_UID, p_agent_dev->p_device->param.dev_uid,
+                    KEY_STATE, DEVICE_STATE_STANDBY,
+                    KEY_MODE, p_agent_dev->p_device->param.dev_mode,
+                    KEY_TOKEN, p_agent_dev->p_device->param.dev_token,
+                    KEY_CATEGORY, p_agent_dev->p_device->param.dev_category);
+            agent_dev_cloud_send_sync(p_agent_dev->p_channel_agent, g_tmp_buf, (int32_t)strlen(g_tmp_buf));
+        }
+        break;
+        case MSG_SELF_STREAMING: {
+            if (!p_agent_dev->p_channel_agent) {
+                LOGE("can't notify cloud");
+                break;
+            }
+            sprintf(g_tmp_buf, "{\"%s\":%d, \"%s\":\"%s\", \"%s\":%d, \"%s\":%d, \"%s\":\"%s\", \"%s\":\"%s\"}\n",
+                    KEY_WHAT, MSG_DEVICE_LOGIN,
+                    KEY_UID, p_agent_dev->p_device->param.dev_uid,
+                    KEY_STATE, DEVICE_STATE_ONLINE,
+                    KEY_MODE, p_agent_dev->p_device->param.dev_mode,
+                    KEY_TOKEN, p_agent_dev->p_device->param.dev_token,
+                    KEY_CATEGORY, p_agent_dev->p_device->param.dev_category);
+            agent_dev_cloud_send_sync(p_agent_dev->p_channel_agent, g_tmp_buf, (int32_t)strlen(g_tmp_buf));
+        }
+        break;
+        case MSG_DEVICE_BATTERY: {
+            if (!p_agent_dev->p_channel_agent) {
+                LOGE("can't notify cloud");
+                break;
+            }
+
+            json_object *p_out_json = NULL;
+            json_object *p_json_what = NULL;
+            json_object *p_json_stat = NULL;
+            json_object *p_json_quantity = NULL;
+            do {
+                msg_ptr_t p_msg = &p_task_entry->msg;
+
+                p_json_what = json_object_new_int(p_msg->what);
+                if (!p_json_what) {
+                    LOGE("create what object failure: msg:%d", p_msg->what);
+                    break;
+                }
+
+                p_json_stat = json_object_new_int(p_msg->para1);
+                if (!p_json_stat) {
+                    LOGE("create stat object failure: msg:%d", p_msg->what);
+                    break;
+                }
+
+                p_json_quantity = json_object_new_int(p_msg->para2);
+                if (!p_json_quantity) {
+                    LOGE("create quantity object failure: msg:%d", p_msg->what);
+                    break;
+                }
+
+                p_out_json = json_object_new_object();
+                if (!p_out_json) {
+                    LOGE("create object failure: msg:%d", p_msg->what);
+                    break;
+                }
+
+                json_object_object_add(p_out_json, KEY_WHAT, p_json_what);
+                json_object_object_add(p_out_json, KEY_STAT, p_json_stat);
+                json_object_object_add(p_out_json, KEY_QUANTITY, p_json_quantity);
+
+                const char *p_str = json_object_to_json_string(p_out_json);
+                sprintf(g_tmp_buf, "%s\n", p_str);
+                agent_dev_cloud_send_sync(p_agent_dev->p_channel_agent, g_tmp_buf, (int32_t)strlen(g_tmp_buf));
+            } while (0);
+
+            if (p_out_json) {
+                json_object_put(p_out_json);
+            } else {
+                if (p_json_what) { json_object_put(p_json_what); }
+                if (p_json_stat) { json_object_put(p_json_stat); }
+                if (p_json_quantity) { json_object_put(p_json_quantity); }
+            }
+        } break;
+        case MSG_DEVICE_CHARGE:
+        case MSG_DEVICE_DC:
+        case MSG_DEVICE_PIR: {
+            if (!p_agent_dev->p_channel_agent) {
+                LOGE("can't notify cloud");
+                break;
+            }
+
+            json_object *p_out_json = NULL;
+            json_object *p_json_what = NULL;
+            json_object *p_json_stat = NULL;
+            do {
+                msg_ptr_t p_msg = &p_task_entry->msg;
+
+                p_json_what = json_object_new_int(p_msg->what);
+                if (!p_json_what) {
+                    LOGE("create what object failure: msg:%d", p_msg->what);
+                    break;
+                }
+
+                p_json_stat = json_object_new_int(p_msg->para1);
+                if (!p_json_stat) {
+                    LOGE("create stat object failure: msg:%d", p_msg->what);
+                    break;
+                }
+
+                p_out_json = json_object_new_object();
+                if (!p_out_json) {
+                    LOGE("create object failure: msg:%d", p_msg->what);
+                    break;
+                }
+
+                json_object_object_add(p_out_json, KEY_WHAT, p_json_what);
+                json_object_object_add(p_out_json, KEY_STAT, p_json_stat);
+
+                const char *p_str = json_object_to_json_string(p_out_json);
+                sprintf(g_tmp_buf, "%s\n", p_str);
+                agent_dev_cloud_send_sync(p_agent_dev->p_channel_agent, g_tmp_buf, (int32_t)strlen(g_tmp_buf));
+            } while (0);
+
+            if (p_out_json) {
+                json_object_put(p_out_json);
+            } else {
+                if (p_json_what) { json_object_put(p_json_what); }
+                if (p_json_stat) { json_object_put(p_json_stat); }
+            }
+        } break;
+    }
+
+    return RET_OK;
+}
+
+static void channel_task_cb (EV_P_ ev_async *watcher, int32_t revents) {
+    channel_task_ptr_t p_channel_task = (channel_task_ptr_t)(((char*)watcher) - offsetof(channel_task_t, watcher));
+
+    queue_t queue;
+    pthread_mutex_lock(&p_channel_task->lock);
+    queue_swap(&queue, &p_channel_task->queue_task);
+    pthread_mutex_unlock(&p_channel_task->lock);
+
+    do {
+        task_entry_ptr_t p_task = QUEUE_DEQ(&queue, task_entry_ptr_t);
+        if (!p_task) { break; }
+
+        task_proc(p_task);
+        MEM_FREE_PTR(p_task);
+    } while (1);
+}
+
+channel_ptr_t channel_task_create(agent_dev_ptr_t p_agent_dev) {
+    channel_task_ptr_t p_channel = MEM_ALLOCZ(channel_task_t);
+    do {
+        if (!p_channel) {
+            LOGE("alloc failure");
+            break;
+        }
+
+        p_channel->p_agent_dev = p_agent_dev;
+        p_channel->start = channel_async_start;
+        p_channel->stop = channel_async_stop;
+        p_channel->destroy = channel_async_destroy;
+
+        pthread_mutex_init(&p_channel->lock, NULL);
+        queue_init(&p_channel->queue_task);
+
+        ev_async_init(&p_channel->watcher.async, channel_task_cb);
+        return (channel_ptr_t)p_channel;
+    } while (0);
+
+    if (p_channel) { p_channel->destroy((channel_pptr_t)&p_channel); }
+    return NULL;
+}
+
+int32_t agent_dev_msg_post(ctx_ptr_t p_ctx, int32_t what) {
+    msg_t msg;
+    msg.what = what;
+    return agent_dev_msg_request(p_ctx, &msg, NULL);
+}
+
+int32_t agent_dev_msg_request(ctx_ptr_t p_ctx, msg_ptr_t p_msg, msg_notify_cb_t msg_proc_cb) {
+    agent_dev_ptr_t p_agent_dev = (agent_dev_ptr_t) p_ctx;
+    channel_task_ptr_t p_channel_task = (channel_task_ptr_t)p_agent_dev->p_channel_task;
+
+    int32_t task_id = task_id = p_channel_task->task_id + 1;
+    task_entry_ptr_t p_task_entry = MEM_ALLOCZ(task_entry_t);
+    if (!p_task_entry) {
+        LOGE("create task failure");
+        return RET_ERROR;
+    }
+
+    pthread_mutex_lock(&p_channel_task->lock);
+    task_init(p_task_entry, p_ctx, task_id, p_msg, msg_proc_cb);
+    QUEUE_ENQ(&p_channel_task->queue_task, p_task_entry);
+    pthread_mutex_unlock(&p_channel_task->lock);
+
+    ev_async_send(p_channel_task->p_loop, &p_channel_task->watcher.async);
+    p_channel_task->task_id++;
+    return task_id;
+}
+
+int32_t agent_dev_msg_cancel(ctx_ptr_t p_ctx, int32_t task_id) {
+    agent_dev_ptr_t p_agent_dev = (agent_dev_ptr_t) p_ctx;
+    channel_task_ptr_t p_channel_task = (channel_task_ptr_t)p_agent_dev->p_channel_task;
+
+    pthread_mutex_lock(&p_channel_task->lock);
+    task_entry_ptr_t p_task_entry = QUEUE_HEAD(&p_channel_task->queue_task, task_entry_ptr_t);
+    while (p_task_entry) {
+        if (p_task_entry->task_id == task_id) {
+            QUEUE_REMOVE(&p_task_entry->elem);
+            MEM_FREE_PTR(p_task_entry);
+            break;
+        }
+        p_task_entry = QUEUE_NEXT(&p_task_entry->elem, task_entry_ptr_t);
+    }
+    pthread_mutex_unlock(&p_channel_task->lock);
+    return RET_OK;
+}
+
+static void agent_init(agent_dev_ptr_t p_agent_dev) {
+    channel_ptr_t p_channel = p_agent_dev->p_channel_task;
+    p_channel->start(p_channel, p_agent_dev->p_loop);
+}
+
+static void agent_deinit(agent_dev_ptr_t p_agent_dev) {
+    channel_ptr_t p_channel = p_agent_dev->p_channel_agent;
+    if (p_channel) { p_channel->stop(p_channel); }
+
+    p_channel = p_agent_dev->p_channel_task;
+    if (p_channel) { p_channel->stop(p_channel); }
+
+    // purge task-related
+    channel_task_ptr_t p_channel_task = (channel_task_ptr_t)p_agent_dev->p_channel_task;
+    pthread_mutex_lock(&p_channel_task->lock);
+    queue_purge(&p_channel_task->queue_task);
+    pthread_mutex_unlock(&p_channel_task->lock);
+
+    p_agent_dev->agent_reconnect_times = 0;
+}
+
+void* agent_dev_thread(void *arg) {
+    LOGD("thread start");
+
+    agent_dev_ptr_t p_agent_dev = (agent_dev_ptr_t)arg;
+
+    // start
+    agent_init(p_agent_dev);
+
+    sem_post(&p_agent_dev->sem);
+
+    // running
+    ev_loop(p_agent_dev->p_loop, 0);
+
+    // stop
+    agent_deinit(p_agent_dev);
+
+    LOGD("thread end");
+
+    return NULL;
+}
+
+static int32_t agent_start(ctx_ptr_t p_ctx) {
+    // TODO: for safe init later
+
+    agent_dev_ptr_t p_agent_dev = (agent_dev_ptr_t)p_ctx;
+    LOGD("before agent_dev_thread create");
+    pthread_create(&p_agent_dev->thread, NULL, agent_dev_thread, p_agent_dev);
+    LOGD("before agent_dev_thread created and waiting sem");
+    sem_wait(&p_agent_dev->sem);
+    LOGD("init sem gotten");
+    return RET_OK;
+}
+
+static int32_t agent_stop(ctx_ptr_t p_ctx) {
+    // TODO: for safe deinit later
+
+    agent_dev_ptr_t p_agent_dev = (agent_dev_ptr_t)p_ctx;
+    if (p_agent_dev->thread != (pthread_t)INVALID_ID) {
+        channel_task_ptr_t p_channel_task = (channel_task_ptr_t)p_agent_dev->p_channel_task;
+        if (p_channel_task) {
+            agent_dev_msg_post(p_ctx, MSG_SELF_BREAK_LOOP);
+            pthread_join(p_agent_dev->thread, NULL);
+            p_agent_dev->thread = (pthread_t) INVALID_ID;
+        }
+    }
+    return RET_OK;
+}
+
+static void agent_destroy(ctx_pptr_t pp_ctx) {
+    if (pp_ctx && *pp_ctx) {
+        agent_dev_ptr_t p_agent_dev = (agent_dev_ptr_t)*pp_ctx;
+        p_agent_dev->stop((ctx_ptr_t)p_agent_dev);
+
+        channel_pptr_t pp_channel = &p_agent_dev->p_channel_agent;
+        if (*pp_channel) { (*pp_channel)->destroy(pp_channel); }
+
+        pp_channel = &p_agent_dev->p_channel_task;
+        if (*pp_channel) { (*pp_channel)->destroy(pp_channel); }
+
+        ev_loop_destroy(p_agent_dev->p_loop);
+
+        pthread_mutex_destroy(&p_agent_dev->lock);
+        sem_destroy(&p_agent_dev->sem);
+
+        MEM_FREE_PPTR(pp_ctx);
+    }
+}
+
+ctx_ptr_t agent_dev_create(device_ptr_t p_device) {
+    agent_dev_ptr_t p_agent_dev = MEM_ALLOCZ(agent_dev_t);
+    do {
+        if (!p_agent_dev) {
+            LOGE("alloc failure");
+            break;
+        }
+
+        p_agent_dev->start = agent_start;
+        p_agent_dev->stop = agent_stop;
+        p_agent_dev->destroy = agent_destroy;
+
+        p_agent_dev->thread = (pthread_t) INVALID_ID;
+        pthread_mutex_init(&p_agent_dev->lock, NULL);
+        sem_init(&p_agent_dev->sem, 0, 0);
+
+        p_agent_dev->p_device = p_device;
+
+        p_agent_dev->p_loop = ev_loop_new(0);
+        if (!p_agent_dev->p_loop) {
+            LOGE("create loop failure");
+            break;
+        }
+
+        p_agent_dev->p_channel_task = channel_task_create(p_agent_dev);
+        if (!p_agent_dev->p_channel_task) {
+            LOGE("create task failure");
+            break;
+        }
+        return (ctx_ptr_t)p_agent_dev;
+    } while (0);
+
+    if (p_agent_dev) { p_agent_dev->destroy((ctx_pptr_t)&p_agent_dev); }
+    return NULL;
+}
+
+void agent_dev_set_msg_notify_cb(ctx_ptr_t p_ctx, handle_t h_opaque, msg_notify_cb_t notify_cb) {
+    agent_dev_ptr_t p_agent_dev = (agent_dev_ptr_t) p_ctx;
+    p_agent_dev->h_opaque = h_opaque;
+    p_agent_dev->msg_notify_cb = notify_cb;
+}
+
+void agent_dev_notify(ctx_ptr_t p_ctx, msg_ptr_t p_msg, result_ptr_t p_result) {
+    agent_dev_ptr_t p_agent_dev = (agent_dev_ptr_t) p_ctx;
+    if (p_agent_dev->msg_notify_cb) {
+        p_agent_dev->msg_notify_cb(p_agent_dev->h_opaque, p_msg, p_result);
+    }
+}
+
+static int _do_write( int sockfd, const unsigned char  *inBuf, size_t inBufLen,int timeout/*seconds*/){
+    ssize_t writeResult;
+    size_t numWritten;
+    fd_set writeSet;
+    int selectResult;
+    struct timeval tv;
+
+    numWritten = 0;
+    do {
+select_again_:
+        FD_ZERO( &writeSet );
+        FD_SET( sockfd, &writeSet );
+        tv.tv_sec = timeout;
+        tv.tv_usec = 0;
+        selectResult = select(sockfd + 1, NULL, &writeSet, NULL, &tv);
+        if(selectResult < 0 && errno == EINTR) goto select_again_;
+        if(selectResult == 0/*Timeout*/) return -1;
+write_again_:
+        writeResult = write( sockfd, ( inBuf + numWritten ), ( inBufLen - numWritten ) );
+        if(writeResult < 0 && (errno == EINTR)){
+            goto write_again_;
+        }
+        if(writeResult < 0 &&( errno == EAGAIN || errno == EWOULDBLOCK)){
+            usleep(1000);
+            goto write_again_;
+        }
+        if(writeResult < 0){
+            return -1;
+        }
+        numWritten += writeResult;
+    } while( numWritten < inBufLen );
+
+    if(numWritten == inBufLen){
+        return numWritten;
+    }
+    return -1;
+}
+
+int32_t agent_dev_standby(int32_t fd, const char *uid, const char *category, int32_t mode, unsigned char *p_token, int32_t token_len) {
+    char token[MAX_WAKE_TOKEN_LEN+1];
+    snprintf(token, MAX_WAKE_TOKEN_LEN, "%s", p_token);
+
+    char data[MAX_DBG_BUF_SIZE];
+    sprintf(data, "{\"%s\":%d, \"%s\":\"%s\", \"%s\":%d, \"%s\":%d, \"%s\":\"%s\", \"%s\":\"%s\"}\n",
+        KEY_WHAT, MSG_DEVICE_STANDBY_TCP,
+        KEY_UID, uid,
+        KEY_STATE, DEVICE_STATE_STANDBY,
+        KEY_MODE, mode,
+        KEY_TOKEN, token,
+        KEY_CATEGORY,category);
+    int32_t data_len = (int32_t)strlen(data);
+    int32_t ret = (int32_t)_do_write(fd, (unsigned char *)data, data_len,5);
+    return ((ret == data_len) ? RET_OK : RET_ERROR);
+}
diff --git a/fastboot_app/device_agent/src/agent_dev.h b/fastboot_app/device_agent/src/agent_dev.h
new file mode 100644
index 0000000..908f5eb
--- /dev/null
+++ b/fastboot_app/device_agent/src/agent_dev.h
@@ -0,0 +1,59 @@
+/*
+ * agent_dev.h
+ *
+ * History:
+ *       2015/03/10 - [jywang] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef __AGENT_DEV_H__
+#define __AGENT_DEV_H__
+
+ctx_ptr_t agent_dev_create(device_ptr_t p_device);
+
+int32_t  agent_dev_msg_post(ctx_ptr_t p_ctx, int32_t msg);
+int32_t  agent_dev_msg_request(ctx_ptr_t p_ctx, msg_ptr_t p_msg, msg_notify_cb_t notify_cb);
+int32_t  agent_dev_msg_cancel(ctx_ptr_t p_ctx, int32_t msg_id);
+
+void agent_dev_set_msg_notify_cb(ctx_ptr_t p_ctx, handle_t h_opaque, msg_notify_cb_t notify_cb);
+void agent_dev_notify(ctx_ptr_t p_ctx, msg_ptr_t p_msg, result_ptr_t p_result);
+
+int32_t agent_dev_standby(int32_t fd, const char *uid, const char *category, int32_t mode, unsigned char *p_token, int32_t token_len);
+
+typedef struct {
+    CHANNEL_COMMON
+
+    int32_t             buf_size;
+    int32_t             w_off;
+    char                w_buf[BUF_SIZE_2048];
+    int32_t             r_off;
+    char                r_buf[BUF_SIZE_2048];
+
+    ctx_ptr_t           p_ctx;
+} channel_agent_dev_t, *channel_agent_dev_ptr_t, **channel_agent_dev_pptr_t;
+
+
+#endif
diff --git a/fastboot_app/device_agent/src/channel.c b/fastboot_app/device_agent/src/channel.c
new file mode 100644
index 0000000..765f6e3
--- /dev/null
+++ b/fastboot_app/device_agent/src/channel.c
@@ -0,0 +1,150 @@
+/*
+ * channel.c
+ *
+ * History:
+ *       2015/03/10 - [jywang] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <ev.h>
+
+#include "defs.h"
+#include "channel.h"
+
+int32_t channel_io_start(channel_ptr_t p_channel, loop_ptr_t p_loop) {
+    ASSERT(p_channel && p_loop && !p_channel->p_loop);
+    ev_io_start(p_loop, &p_channel->watcher.io);
+    p_channel->p_loop = p_loop;
+    return RET_OK;
+}
+
+int32_t channel_io_stop(channel_ptr_t p_channel) {
+    ASSERT(p_channel);
+    if (p_channel->p_loop && p_channel->watcher.io.fd > 0) {
+        ev_io_stop(p_channel->p_loop, &p_channel->watcher.io);
+    }
+    p_channel->p_loop = NULL;
+    return RET_OK;
+}
+
+void channel_io_destroy(channel_pptr_t pp_channel) {
+    ASSERT(pp_channel);
+    channel_ptr_t p_channel = *pp_channel;
+    ASSERT(p_channel);
+
+    if (p_channel->watcher.io.fd > 0) {
+        channel_io_stop(p_channel);
+        close(p_channel->watcher.io.fd);
+    }
+
+    MEM_FREE_PPTR(pp_channel);
+}
+
+int32_t channel_io_update(channel_ptr_t p_channel, int32_t flags) {
+    ev_io *watcher = &p_channel->watcher.io;
+
+    if ((watcher->fd > 0) && ((watcher->events&FLAG_IO_READ_WRITE) != flags)) {
+        ev_io_stop(p_channel->p_loop, watcher);
+        ev_io_set(watcher, watcher->fd, flags);
+        ev_io_start(p_channel->p_loop, watcher);
+    }
+    return RET_OK;
+}
+
+int32_t channel_async_start(channel_ptr_t p_channel, loop_ptr_t p_loop) {
+    ASSERT(p_channel && p_loop && !p_channel->p_loop);
+    ev_async_start(p_loop, &p_channel->watcher.async);
+    p_channel->p_loop = p_loop;
+    return RET_OK;
+}
+
+int32_t channel_async_stop(channel_ptr_t p_channel) {
+    if (p_channel->p_loop) {
+        ev_async_stop(p_channel->p_loop, &p_channel->watcher.async);
+        p_channel->p_loop = NULL;
+    }
+    return RET_OK;
+}
+
+void channel_async_destroy(channel_pptr_t pp_channel) {
+    ASSERT(pp_channel);
+    channel_ptr_t p_channel = *pp_channel;
+    ASSERT(p_channel);
+
+    channel_async_stop(p_channel);
+
+    MEM_FREE_PPTR(pp_channel);
+}
+
+int32_t channel_timer_start(channel_ptr_t p_channel, loop_ptr_t p_loop) {
+    ASSERT(p_channel && p_loop && !p_channel->p_loop);
+    ev_timer_start(p_loop, &p_channel->watcher.timer);
+    p_channel->p_loop = p_loop;
+    return RET_OK;
+}
+
+int32_t channel_timer_stop(channel_ptr_t p_channel) {
+    if (p_channel->p_loop) {
+        ev_timer_stop(p_channel->p_loop, &p_channel->watcher.timer);
+        p_channel->p_loop = NULL;
+    }
+    return RET_OK;
+}
+
+void channel_timer_destroy(channel_pptr_t pp_channel) {
+    ASSERT(pp_channel);
+    channel_ptr_t p_channel = *pp_channel;
+    ASSERT(p_channel);
+
+    channel_timer_stop(p_channel);
+
+    MEM_FREE_PPTR(pp_channel);
+}
+
+int32_t channel_periodic_start(channel_ptr_t p_channel, loop_ptr_t p_loop) {
+    ASSERT(p_channel && p_loop && !p_channel->p_loop);
+    ev_periodic_start(p_loop, &p_channel->watcher.periodic);
+    p_channel->p_loop = p_loop;
+    return RET_OK;
+}
+
+int32_t channel_periodic_stop(channel_ptr_t p_channel) {
+    if (p_channel->p_loop) {
+        ev_periodic_stop(p_channel->p_loop, &p_channel->watcher.periodic);
+        p_channel->p_loop = NULL;
+    }
+    return RET_OK;
+}
+
+void channel_periodic_destroy(channel_pptr_t pp_channel) {
+    ASSERT(pp_channel);
+    channel_ptr_t p_channel = *pp_channel;
+    ASSERT(p_channel);
+
+    channel_periodic_stop(p_channel);
+
+    MEM_FREE_PPTR(pp_channel);
+}
diff --git a/fastboot_app/device_agent/src/channel.h b/fastboot_app/device_agent/src/channel.h
new file mode 100644
index 0000000..a7c24d3
--- /dev/null
+++ b/fastboot_app/device_agent/src/channel.h
@@ -0,0 +1,67 @@
+/*
+ * channel.h
+ *
+ * History:
+ *       2015/03/10 - [jywang] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef __CHANNEL_H__
+#define __CHANNEL_H__
+
+typedef struct ev_loop loop_t, *loop_ptr_t;
+
+typedef struct channel channel_t, *channel_ptr_t, **channel_pptr_t;
+
+#define CHANNEL_COMMON                                                          \
+    loop_ptr_t      p_loop;                                                     \
+    union ev_any_watcher  watcher;                                                    \
+    int32_t         (*start)(channel_ptr_t p_channel, loop_ptr_t p_loop);       \
+    int32_t         (*stop)(channel_ptr_t p_channel);                           \
+    void            (*destroy)(channel_pptr_t pp_channel);
+
+struct channel {
+    CHANNEL_COMMON
+};
+
+int32_t channel_io_start(channel_ptr_t p_channel, loop_ptr_t p_loop);
+int32_t channel_io_stop(channel_ptr_t p_channel);
+void    channel_io_destroy(channel_pptr_t pp_channel);
+int32_t channel_io_update(channel_ptr_t p_channel, int32_t flags);
+
+int32_t channel_async_start(channel_ptr_t p_channel, loop_ptr_t p_loop);
+int32_t channel_async_stop(channel_ptr_t p_channel);
+void    channel_async_destroy(channel_pptr_t pp_channel);
+
+int32_t channel_timer_start(channel_ptr_t p_channel, loop_ptr_t p_loop);
+int32_t channel_timer_stop(channel_ptr_t p_channel);
+void    channel_timer_destroy(channel_pptr_t pp_channel);
+
+int32_t channel_periodic_start(channel_ptr_t p_channel, loop_ptr_t p_loop);
+int32_t channel_periodic_stop(channel_ptr_t p_channel);
+void    channel_periodic_destroy(channel_pptr_t pp_channel);
+
+#endif
diff --git a/fastboot_app/device_agent/src/defs.c b/fastboot_app/device_agent/src/defs.c
new file mode 100644
index 0000000..095ee4e
--- /dev/null
+++ b/fastboot_app/device_agent/src/defs.c
@@ -0,0 +1,46 @@
+/*
+ * defs.c
+ *
+ * History:
+ *       2015/03/10 - [jywang] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include "defs.h"
+
+void_ptr_t mem_allocz(int32_t size) {
+	void_ptr_t p = malloc(size);
+	if (p) { memset(p, 0, size); }
+	return p;
+}
+
+void mem_free_ptr(void_ptr_t p) {
+	if (p) { free(p); }
+}
+
+void mem_free_pptr(void_pptr_t pp) {
+	if (pp && *pp) { free(*pp); *pp = NULL; }
+}
diff --git a/fastboot_app/device_agent/src/impl_dev.c b/fastboot_app/device_agent/src/impl_dev.c
new file mode 100644
index 0000000..50e97bb
--- /dev/null
+++ b/fastboot_app/device_agent/src/impl_dev.c
@@ -0,0 +1,332 @@
+/*
+ * impl_dev.c
+ *
+ * History:
+ *       2015/03/10 - [jywang] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include "device.h"
+#include "impl_dev.h"
+#include "agent_dev.h"
+
+char g_tmp_buf[MAX_DBG_BUF_SIZE+1];
+#ifdef __cplusplus
+extern "C"{
+#endif
+handle_t device_create(param_device_ptr_t p_param) {
+    device_ptr_t p_device = MEM_ALLOCZ(device_t);
+    if (p_device) {
+        p_device->state = STATE_CREATED;
+        memmove(&p_device->param, p_param, sizeof(*p_param));
+    }
+    return p_device;
+}
+
+void device_destroy(handle_ptr_t h_ptr_device) {
+    device_stop(*h_ptr_device);
+    device_deinit(*h_ptr_device);
+    MEM_FREE_PPTR(h_ptr_device);
+}
+
+int32_t device_init(handle_t h_device) {
+    int32_t ret = RET_ERROR;
+
+    device_ptr_t p_device = (device_ptr_t)h_device;
+    int32_t state = p_device->state;
+    if (state == STATE_INITIALIZED) {
+        ret = RET_OK;
+        LOGW("duplicated");
+    } else if (p_device->state == STATE_CREATED) {
+        do {
+            pthread_mutex_init(&p_device->lock, NULL);
+
+            p_device->p_agent_dev = agent_dev_create(p_device);
+            if (!p_device->p_agent_dev) {
+                LOGE("create agent_dev failure");
+                p_device->state = STATE_ERROR_INIT;
+                break;
+            }
+
+            p_device->state = STATE_INITIALIZED;
+            ret = RET_OK;
+        } while (0);
+    } else {
+        ret = RET_ERROR_INVLAID_STATE;
+        LOGE("invalid state: %d", state);
+    }
+    return ret;
+}
+
+int32_t device_deinit(handle_t h_device) {
+    int32_t ret = RET_ERROR;
+
+    device_ptr_t p_device = (device_ptr_t)h_device;
+    int32_t state = p_device->state;
+    if (state == STATE_CREATED) {
+        ret = RET_OK;
+        LOGW("duplicated");
+    } else if (state == STATE_INITIALIZED || state == STATE_STOPPED || state == STATE_ERROR_INIT) {
+        if (p_device->p_agent_dev) {
+            p_device->p_agent_dev->destroy(&p_device->p_agent_dev);
+        }
+
+        pthread_mutex_destroy(&p_device->lock);
+
+        p_device->state = STATE_CREATED;
+        ret = RET_OK;
+    } else {
+        ret = RET_ERROR_INVLAID_STATE;
+        LOGE("invalid state: %d", state);
+    }
+    return ret;
+}
+
+int32_t device_start(handle_t h_device) {
+    int32_t ret = RET_ERROR;
+
+    device_ptr_t p_device = (device_ptr_t)h_device;
+    int32_t state = p_device->state;
+    if (state == STATE_STARTED) {
+        ret = RET_OK;
+        LOGW("duplicated");
+    } else if (state == STATE_INITIALIZED || state == STATE_STOPPED) {
+        if (p_device->b_busy) {
+            LOGW("busy");
+            ret = RET_ERROR_BUSY;
+        } else {
+            pthread_mutex_lock(&p_device->lock);
+            p_device->b_busy = true;
+            do {
+                ctx_ptr_t p_ctx = p_device->p_agent_dev;
+                ret = p_ctx->start(p_ctx);
+                if (ret != RET_OK) {
+                    LOGE("start agent_dev failure");
+                    p_device->state = STATE_ERROR_START;
+                    break;
+                }
+
+                p_device->state = STATE_STARTED;
+                ret = RET_OK;
+            } while (0);
+            p_device->b_busy = false;
+            pthread_mutex_unlock(&p_device->lock);
+        }
+    } else {
+        ret = RET_ERROR_INVLAID_STATE;
+        LOGE("invalid state: %d", state);
+    }
+    return ret;
+}
+
+int32_t device_stop(handle_t h_device) {
+    int32_t ret = RET_ERROR;
+
+    device_ptr_t p_device = (device_ptr_t)h_device;
+    int32_t state = p_device->state;
+    if (state == STATE_STOPPED) {
+        ret = RET_OK;
+        LOGW("duplicated");
+    } else if (state == STATE_STARTED || state == STATE_ERROR_START) {
+        if (p_device->b_busy) {
+            LOGW("busy");
+            ret = RET_ERROR_BUSY;
+        } else {
+            pthread_mutex_lock(&p_device->lock);
+            p_device->b_busy = true;
+
+            // stop agent_dev
+            ctx_ptr_t p_ctx = p_device->p_agent_dev;
+            if (p_ctx) { p_ctx->stop(p_ctx); }
+
+            p_device->state = STATE_STOPPED;
+            ret = RET_OK;
+
+            p_device->b_busy = false;
+            pthread_mutex_unlock(&p_device->lock);
+        }
+    } else {
+        ret = RET_ERROR_INVLAID_STATE;
+        LOGE("invalid state: %d", state);
+    }
+    return ret;
+}
+
+int32_t device_state(handle_t h_device) {
+    ASSERT(h_device);
+    device_ptr_t p_device = (device_ptr_t)h_device;
+    return p_device->state;
+}
+
+bool device_is_running(handle_t h_device) {
+    ASSERT(h_device);
+    device_ptr_t p_device = (device_ptr_t)h_device;
+    return (p_device->state == STATE_STARTED);
+}
+
+void device_set_msg_notify_cb(handle_t h_device, handle_t h_opaque, msg_notify_cb_t notify_cb) {
+    device_ptr_t p_device = (device_ptr_t)h_device;
+    agent_dev_set_msg_notify_cb(p_device->p_agent_dev, h_opaque, notify_cb);
+}
+
+void device_set_device_mode(handle_t h_device, int32_t  dev_mode){
+    device_ptr_t p_device = (device_ptr_t)h_device;
+    p_device ->param.dev_mode = dev_mode;
+}
+int32_t  device_msg_post(handle_t h_device, int32_t what) {
+    device_ptr_t p_device = (device_ptr_t)h_device;
+    return agent_dev_msg_post(p_device->p_agent_dev, what);
+}
+
+int32_t device_msg_request(handle_t h_device, msg_ptr_t p_msg, msg_notify_cb_t notify_cb) {
+    device_ptr_t p_device = (device_ptr_t)h_device;
+    return agent_dev_msg_request(p_device->p_agent_dev, p_msg, notify_cb);
+}
+
+int32_t device_msg_cancel(handle_t h_device, int32_t msg_id) {
+    device_ptr_t p_device = (device_ptr_t)h_device;
+    return agent_dev_msg_cancel(p_device->p_agent_dev, msg_id);
+}
+
+void device_connect_cloud(handle_t h_device) {
+    device_msg_post(h_device, MSG_SELF_CONNECT_CLOUD);
+}
+
+void device_connect_cloud_fd(handle_t h_device, int32_t fd) {
+    msg_t msg = {0};
+    msg.what = MSG_SELF_CONNECT_CLOUD_FD;
+    msg.para1 = fd;
+    device_msg_request(h_device, &msg, NULL);
+}
+
+void device_disconnect_cloud(handle_t h_device) {
+    device_msg_post(h_device, MSG_SELF_DISCONNECT_CLOUD);
+}
+
+void device_standby(handle_t h_device) {
+    device_msg_post(h_device, MSG_SELF_STANDBY_TCP);
+}
+
+void device_online_streaming(handle_t h_device) {
+    device_msg_post(h_device, MSG_SELF_STREAMING);
+}
+
+int32_t device_standby_tcp(int32_t fd, const char *uid, const char *category, unsigned char *p_token, int32_t token_len) {
+    return agent_dev_standby(fd, uid, category, DEVICE_MODE_STANDBY_TCP, p_token, token_len);
+}
+
+int32_t device_standby_udp(int32_t fd, const char *uid, const char *category, unsigned char *p_token, int32_t token_len) {
+    return agent_dev_standby(fd, uid, category, DEVICE_MODE_STANDBY_UDP, p_token, token_len);
+}
+#ifdef __cplusplus
+};
+#endif
+
+static int32_t parse_ip(const char *p_str, int32_t len, char ip[MAX_IP_LEN]) {
+    int32_t ret = -1;
+    do {
+        const char *p = p_str;
+        int32_t times = 0;
+        while (NULL != (p = strchr(p, '.'))) {
+            times++;
+            p++;
+        }
+
+        if (times != 3) {
+            LOGW("invalid ip address");
+            break;
+        }
+
+        memmove(ip, p_str, len);
+        ip[len] = '\0';
+        ret = 0;
+    } while (0);
+    return ret;
+}
+
+static int32_t parse_port(const char *p_str, int32_t len, int32_t *p_port) {
+    if (!p_port) { return RET_OK; }
+
+    int32_t ret = -1;
+    do {
+        if (len > MAX_PORT_LEN) {
+            LOGE("port len exceeds 16 bytes %d", len);
+            break;
+        }
+
+        char buf[MAX_PORT_LEN];
+        memmove(buf, p_str, len);
+        buf[len] = '\0';
+
+        int32_t port = atoi(buf);
+        if (port == 0) {
+            LOGE("invalid port");
+            break;
+        }
+
+        *p_port = port;
+        ret = 0;
+    } while (0);
+    return ret;
+}
+
+int32_t param_device_parse_server(const char *p_str, char ip[MAX_IP_LEN], int32_t *p_port) {
+    int32_t ret = -1;
+    do {
+        // skip protocol
+        const char *p_proto = "://";
+        char *p = strstr(p_str, p_proto);
+        if (p) { p_str = p + strlen(p_proto); }
+
+        int32_t len = 0;
+        p = strchr(p_str, ':');
+        if (p) {
+            // parse ip & port
+            len = (int32_t)(p - p_str);
+            ret = parse_ip(p_str, len, ip);
+            if (ret < 0) {
+                LOGE("invalid ip");
+                break;
+            }
+
+            len = (int32_t)(strlen(p_str) - len - 1);
+            ret = parse_port(p+1, len, p_port);
+        } else {
+            // if ip, parse ip
+            // else parse port
+            len = (int32_t)strlen(p_str);
+            p = strchr(p_str, '.');
+            if (p) {
+                ret = parse_ip(p_str, len, ip);
+                break;
+            } else {
+                ret = parse_port(p_str, len, p_port);
+                break;
+            }
+        }
+    } while (0);
+    return ret;
+}
diff --git a/fastboot_app/device_agent/src/impl_dev.h b/fastboot_app/device_agent/src/impl_dev.h
new file mode 100644
index 0000000..c54f5db
--- /dev/null
+++ b/fastboot_app/device_agent/src/impl_dev.h
@@ -0,0 +1,68 @@
+/*
+ * impl_dev.h
+ *
+ * History:
+ *       2015/03/10 - [jywang] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef __IMPL_DEV_H__
+#define __IMPL_DEV_H__
+
+#include <pthread.h>
+#include <ev.h>
+#include <json-c/json.h>
+
+#include "queue.h"
+#include "channel.h"
+
+enum {
+    MSG_SELF_HOME                   = MSG_WHAT(MSG_CAT_SELF, 0),
+    MSG_SELF_BREAK_LOOP,
+    MSG_SELF_CHANNEL_UPDATE,
+    MSG_SELF_CONNECT_CLOUD,
+    MSG_SELF_CONNECT_CLOUD_FD,
+    MSG_SELF_DISCONNECT_CLOUD,
+    MSG_SELF_SYNC_CLOUD,
+    MSG_SELF_STANDBY_TCP,
+    MSG_SELF_STREAMING,
+    MSG_SELF_END,
+};
+
+typedef struct {
+    param_device_t      param;
+
+    int32_t             state;
+    pthread_mutex_t     lock;
+    bool                b_busy;
+
+    ctx_ptr_t           p_agent_dev;
+} device_t, *device_ptr_t, **device_pptr_t;
+
+#define MAX_DBG_BUF_SIZE    512
+extern char g_tmp_buf[MAX_DBG_BUF_SIZE+1];
+
+#endif
diff --git a/fastboot_app/device_agent/src/proc_dev.c b/fastboot_app/device_agent/src/proc_dev.c
new file mode 100644
index 0000000..822d01f
--- /dev/null
+++ b/fastboot_app/device_agent/src/proc_dev.c
@@ -0,0 +1,211 @@
+/*
+ * proc_dev.c
+ *
+ * History:
+ *       2015/03/10 - [jywang] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include "device.h"
+#include "impl_dev.h"
+#include "agent_dev.h"
+#include "proc_dev.h"
+
+static int32_t agent_dev_request_proc(channel_ptr_t p_channel, int32_t what, json_object *p_in_json, char *p_data, int32_t data_len) {
+    int32_t ret = RET_OK;
+    int32_t cat = MSG_CAT(what);
+
+    (void)ret;
+
+    msg_t msg;
+    msg.what = what;
+
+    channel_agent_dev_ptr_t p_client = (channel_agent_dev_ptr_t)p_channel;
+    if (cat == MSG_CAT_DEVICE) {
+        switch (what) {
+        case MSG_DEVICE_LOGIN: {
+            json_object *p_json_cloud = NULL;
+            if (json_object_object_get_ex(p_in_json, KEY_CLOUD, &p_json_cloud) != TRUE) {
+                LOGE("get cloud failure: %s", p_data);
+                break;
+            }
+
+            json_object *p_json_stream_id = NULL;
+            if (json_object_object_get_ex(p_in_json, KEY_STREAM_ID, &p_json_stream_id) != TRUE) {
+                LOGE("get stream_id failure: %s", p_data);
+                break;
+            }
+
+            if (json_object_get_boolean(p_json_cloud)) {
+                msg.what = MSG_DBG_START_RTSP_INJECTOR;
+                msg.para1 = json_object_get_int(p_json_stream_id);
+                agent_dev_notify(p_client->p_ctx, &msg, NULL);
+            }
+        } break;
+        case MSG_DEVICE_ALARM:
+        case MSG_DEVICE_STANDBY_TCP:
+        case MSG_DEVICE_STANDBY_UDP:
+            agent_dev_notify(p_client->p_ctx, &msg, NULL);
+            break;
+        case MSG_DEVICE_SYNC: {
+            sprintf(g_tmp_buf, "{\"%s\":%d, \"%s\":%d}\n",
+                        KEY_WHAT, MSG_DEVICE_SYNC,
+                        KEY_RET, 0);
+            agent_dev_cloud_send_sync(p_channel, g_tmp_buf, (int32_t)strlen(g_tmp_buf));
+        } break;
+        case MSG_FAST_STREAMING: {
+            LOGD("======= MSG_FAST_STREAMING 0x%x=======\n", MSG_FAST_STREAMING);
+            json_object *p_json_ip = NULL;
+            result_t p_result;
+            if (json_object_object_get_ex(p_in_json, KEY_IP, &p_json_ip) != TRUE) {
+                LOGE("get cloud failure: %s", p_data);
+                break;
+            }
+            strcpy(g_tmp_buf, json_object_get_string(p_json_ip));
+            p_result.obj = (void*)g_tmp_buf;
+            agent_dev_notify(p_client->p_ctx, &msg, &p_result);
+        } break;
+        default:
+            LOGD("default handler, what:%d", what);
+            agent_dev_notify(p_client->p_ctx, &msg, NULL);
+            break;
+        }
+    } else if (cat == MSG_CAT_DBG) {
+        agent_dev_notify(p_client->p_ctx, &msg, NULL);
+    } else if (cat == MSG_CAT_RESERVED) {
+        switch (what) {
+        case MSG_RESERVED_SYNC: {
+            agent_dev_cloud_send_sync(p_channel, p_data, data_len+1);
+        } break;
+        case MSG_RESERVED_PLAY_AUDIO:
+        case MSG_RESERVED_SHUTDOWN:
+            agent_dev_notify(p_client->p_ctx, &msg, NULL);
+            break;
+        default:
+            LOGD("default handler, what:%d", what);
+            agent_dev_notify(p_client->p_ctx, &msg, NULL);
+            break;
+        }
+    }
+    return ret;
+}
+
+int32_t agent_dev_cloud_send_sync(channel_ptr_t p_channel, const char *p_data, int32_t data_len) {
+    channel_agent_dev_ptr_t p_client = (channel_agent_dev_ptr_t)p_channel;
+    if (!p_client) { return RET_ERROR; }
+
+    int32_t ret = (int32_t)write(p_client->watcher.io.fd, p_data, data_len);
+    if (ret > 0) {
+        if (ret == data_len) { return RET_OK; }
+
+        int32_t left = data_len - ret;
+        if (left > p_client->buf_size) {
+            LOGD("buf full");
+            return RET_ERROR_OUT_BUF_FULL;
+        }
+
+        memmove(p_client->w_buf, p_data + ret, left);
+        p_client->w_off = left;
+    } else {
+        if (errno != EINTR && errno != EAGAIN) { return RET_ERROR_WRITE; }
+
+        if (data_len > p_client->buf_size) {
+            LOGD("buf full");
+            return RET_ERROR_OUT_BUF_FULL;
+        }
+
+        memmove(p_client->w_buf, p_data, data_len);
+        p_client->w_off = data_len;
+    }
+
+    int32_t flags = EV_READ;
+    if (p_client->w_off > 0) { flags |= EV_WRITE; }
+    channel_io_update((channel_ptr_t)p_client, flags);
+
+    return RET_OK;
+}
+
+int32_t agent_dev_cloud_send_async(channel_ptr_t p_channel, const char *p_data, int32_t data_len) {
+    channel_agent_dev_ptr_t p_client = (channel_agent_dev_ptr_t)p_channel;
+    if (!p_client) { return RET_ERROR; }
+
+    if (p_client->w_off + data_len > p_client->buf_size) {
+        LOGE("buf full");
+        return RET_ERROR_OUT_BUF_FULL;
+    }
+    memmove(p_client->w_buf + p_client->w_off, p_data, data_len);
+    p_client->w_off += data_len;
+
+    msg_t msg;
+    msg.what = MSG_SELF_CHANNEL_UPDATE;
+    msg.obj = p_client;
+    agent_dev_msg_request(p_client->p_ctx, &msg, NULL);
+    return RET_OK;
+}
+
+int32_t agent_cloud_msg_proc(channel_ptr_t p_channel, char *p_data, int32_t data_len) {
+    int32_t ret = RET_OK;
+
+    json_tokener *p_tokener = NULL;
+    json_object *p_in_json = NULL;
+
+    do {
+        p_tokener = json_tokener_new();
+        if (!p_tokener) {
+            LOGE("new tokener failure");
+            break;
+        }
+
+        p_in_json = json_tokener_parse_ex(p_tokener, p_data, data_len);
+        if (!p_in_json) {
+            LOGE("parse json failure: %s", p_data);
+            // TODO: change daredevil wakeup event to json
+            if(!strncmp(p_data, "amba_wakeup", 11)){
+                channel_agent_dev_ptr_t p_client = (channel_agent_dev_ptr_t)p_channel;
+                msg_t msg;
+                msg.what = MSG_DEVICE_WAKEUP_TCP;
+                agent_dev_notify(p_client->p_ctx, &msg, NULL);
+            }
+            break;
+        }
+
+        LOGD("recv: %s", p_data);
+
+        json_object *p_json_what = NULL;
+        if (json_object_object_get_ex(p_in_json, KEY_WHAT, &p_json_what) != TRUE) {
+            LOGE("get object failure: %s", p_data);
+            break;
+        }
+
+        int32_t what = json_object_get_int(p_json_what);
+        ret = agent_dev_request_proc(p_channel, what, p_in_json, p_data, data_len);
+    } while (0);
+
+    if (p_in_json) { json_object_put(p_in_json); }
+    if (p_tokener) { json_tokener_free(p_tokener); }
+
+    return ret;
+}
diff --git a/fastboot_app/device_agent/src/proc_dev.h b/fastboot_app/device_agent/src/proc_dev.h
new file mode 100644
index 0000000..ff3aeb1
--- /dev/null
+++ b/fastboot_app/device_agent/src/proc_dev.h
@@ -0,0 +1,40 @@
+/*
+ * proc_dev.h
+ *
+ * History:
+ *       2015/03/10 - [jywang] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef __PROC_AGENT_H__
+#define __PROC_AGENT_H__
+
+int32_t agent_dev_cloud_send_sync(channel_ptr_t p_channel, const char *p_data, int32_t data_len);
+int32_t agent_dev_cloud_send_async(channel_ptr_t p_channel, const char *p_data, int32_t data_len);
+
+int32_t agent_cloud_msg_proc(channel_ptr_t p_channel, char *p_data, int32_t data_len);
+
+#endif
diff --git a/fastboot_app/device_agent/src/queue.c b/fastboot_app/device_agent/src/queue.c
new file mode 100644
index 0000000..f9fad96
--- /dev/null
+++ b/fastboot_app/device_agent/src/queue.c
@@ -0,0 +1,175 @@
+/*
+ * queue.c
+ *
+ * History:
+ *       2015/03/10 - [jywang] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include "defs.h"
+#include "queue.h"
+
+static void elem_destroy_cb_default(queue_elem_pptr_t pp_elem) {
+    MEM_FREE_PPTR(pp_elem);
+}
+
+queue_ptr_t queue_create() {
+    queue_ptr_t p_queue = MEM_ALLOCZ(queue_t);
+    return p_queue;
+}
+
+void queue_destroy(queue_pptr_t pp_queue) {
+    ASSERT(pp_queue);
+    ASSERT(*pp_queue);
+    queue_deinit(*pp_queue);
+    MEM_FREE_PPTR(pp_queue);
+}
+
+int32_t queue_init(queue_ptr_t p_queue) {
+    ASSERT(p_queue);
+    p_queue->sentinel.p_next = &p_queue->sentinel;
+    p_queue->sentinel.p_prev = &p_queue->sentinel;
+    p_queue->length = 0;
+    return RET_OK;
+}
+
+void queue_deinit(queue_ptr_t p_queue) {
+    queue_purge(p_queue);
+}
+
+void queue_set_elem_destroy_cb(queue_ptr_t p_queue, elem_destroy_cb_t cb) {
+    ASSERT(p_queue);
+    p_queue->destroy_cb = cb;
+}
+
+void queue_enq(queue_ptr_t p_queue, queue_elem_ptr_t p_elem) {
+    ASSERT(p_queue);
+    ASSERT(p_elem);
+    if (p_elem->p_queue == p_queue) {
+        return ;
+    }
+
+    ASSERT(p_elem->p_queue == NULL);
+    p_elem->p_next = p_queue->sentinel.p_next;
+    p_elem->p_prev = &p_queue->sentinel;
+    p_elem->p_queue = p_queue;
+    p_queue->sentinel.p_next->p_prev = p_elem;
+    p_queue->sentinel.p_next = p_elem;
+    p_queue->length++;
+}
+
+queue_elem_ptr_t queue_deq(queue_ptr_t p_queue) {
+    ASSERT(p_queue);
+    if (p_queue->length > 0) {
+        queue_elem_ptr_t p_elem = p_queue->sentinel.p_prev;
+        ASSERT(p_elem);
+        ASSERT(p_queue->sentinel.p_prev != &p_queue->sentinel);
+        p_elem->p_prev->p_next = &p_queue->sentinel;
+        p_queue->sentinel.p_prev = p_elem->p_prev;
+        p_elem->p_queue = NULL;
+        p_queue->length--;
+        return p_elem;
+    }
+    return NULL;
+}
+
+queue_elem_ptr_t queue_head(queue_ptr_t p_queue) {
+    ASSERT(p_queue);
+    return (p_queue->length > 0 ? p_queue->sentinel.p_prev : NULL);
+}
+
+queue_elem_ptr_t queue_tail(queue_ptr_t p_queue) {
+    ASSERT(p_queue);
+    return (p_queue->length > 0 ? p_queue->sentinel.p_next : NULL);
+}
+
+int32_t queue_length(queue_ptr_t p_queue) {
+    ASSERT(p_queue);
+    return p_queue->length;
+}
+
+void queue_purge(queue_ptr_t p_queue) {
+    ASSERT(p_queue);
+    
+    elem_destroy_cb_t elem_destroy_cb = p_queue->destroy_cb;
+    if (!elem_destroy_cb) { elem_destroy_cb = elem_destroy_cb_default; }
+    
+    do {
+        queue_elem_t *p_elem = queue_deq(p_queue);
+        if (!p_elem) { break; }
+        
+        elem_destroy_cb(&p_elem);
+    } while (0);
+}
+
+void queue_remove(queue_ptr_t p_queue, queue_elem_ptr_t p_elem) {
+    ASSERT(p_queue);
+    ASSERT(p_elem);
+    ASSERT(p_elem != &p_queue->sentinel);
+
+    if (p_elem->p_queue == p_queue) {
+        p_elem->p_next->p_prev = p_elem->p_prev;
+        p_elem->p_prev->p_next = p_elem->p_next;
+        p_elem->p_prev = NULL;
+        p_elem->p_next = NULL;
+        p_elem->p_queue = NULL;
+        p_queue->length--;
+    }
+}
+
+void queue_swap(queue_ptr_t p_dst_queue, queue_ptr_t p_src_queue) {
+    ASSERT(p_src_queue);
+    ASSERT(p_dst_queue);
+
+    queue_init(p_dst_queue);
+    if (p_src_queue->length > 0) {
+        queue_elem_ptr_t p_head = queue_head(p_src_queue);
+        p_head->p_next = &p_dst_queue->sentinel;
+        p_dst_queue->sentinel.p_prev = p_head;
+
+        queue_elem_ptr_t p_tail = queue_tail(p_src_queue);
+        p_tail->p_prev = &p_dst_queue->sentinel;
+        p_dst_queue->sentinel.p_next = p_tail;
+
+        p_dst_queue->length = p_src_queue->length;
+
+        queue_init(p_src_queue);
+    }
+}
+
+queue_elem_ptr_t queue_elem_next(queue_elem_ptr_t p_elem) {
+    ASSERT(p_elem);
+    
+    return ((p_elem->p_prev == (queue_elem_ptr_t)p_elem->p_queue) ? NULL : p_elem->p_prev);
+}
+
+void queue_elem_remove(queue_elem_ptr_t p_elem) {
+    ASSERT(p_elem);
+    if (p_elem->p_queue) {
+        queue_remove(p_elem->p_queue, p_elem);
+    }
+}
+
diff --git a/fastboot_app/device_agent/src/queue.h b/fastboot_app/device_agent/src/queue.h
new file mode 100644
index 0000000..7d53021
--- /dev/null
+++ b/fastboot_app/device_agent/src/queue.h
@@ -0,0 +1,81 @@
+/*
+ * queue.h
+ *
+ * History:
+ *       2015/03/10 - [jywang] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef __QUEUE_H__
+#define __QUEUE_H__
+
+struct queue;
+
+typedef struct queue_elem {
+    struct queue      	*p_queue;
+    struct queue_elem	*p_next;
+    struct queue_elem	*p_prev;
+} queue_elem_t, *queue_elem_ptr_t, **queue_elem_pptr_t;
+
+
+typedef void (*elem_destroy_cb_t)(queue_elem_pptr_t pp_elem);
+typedef struct queue {
+    queue_elem_t        sentinel;
+    int32_t             length;
+    elem_destroy_cb_t   destroy_cb;
+} queue_t, *queue_ptr_t, **queue_pptr_t;
+
+queue_ptr_t			queue_create();
+void				queue_destroy(queue_pptr_t pp_queue);
+
+int32_t             queue_init(queue_ptr_t p_queue);
+void 				queue_deinit(queue_ptr_t p_queue);
+void                queue_set_elem_destroy_cb(queue_ptr_t p_queue, elem_destroy_cb_t cb);
+
+void           	 	queue_enq(queue_ptr_t p_queue, queue_elem_ptr_t p_elem);
+queue_elem_ptr_t    queue_deq(queue_ptr_t p_queue);
+
+queue_elem_ptr_t   	queue_head(queue_ptr_t p_queue);
+queue_elem_ptr_t   	queue_tail(queue_ptr_t p_queue);
+
+int32_t  			queue_length(queue_ptr_t p_queue);
+void                queue_purge(queue_ptr_t p_queue);
+void 				queue_remove(queue_ptr_t p_queue, queue_elem_ptr_t p_elem);
+void 				queue_swap(queue_ptr_t p_src_queue, queue_ptr_t p_dst_queue);
+
+queue_elem_ptr_t 	queue_elem_next(queue_elem_ptr_t p_elem);
+void 			 	queue_elem_remove(queue_elem_ptr_t p_elem);
+
+#define QUEUE_ENQ(p_queue, p_elem)      queue_enq(p_queue, (queue_elem_ptr_t)p_elem)
+#define QUEUE_DEQ(p_queue, ptr_type)    (ptr_type)queue_deq(p_queue)
+
+#define QUEUE_HEAD(p_queue, ptr_type)   (ptr_type)queue_head(p_queue)
+#define QUEUE_TAIL(p_queue, ptr_type)   (ptr_type)queue_tail(p_queue)
+
+#define QUEUE_NEXT(p_elem, ptr_type)    (ptr_type)queue_elem_next((queue_elem_ptr_t)p_elem)
+#define QUEUE_REMOVE(p_elem)            queue_elem_remove((queue_elem_ptr_t)p_elem)
+
+#endif
diff --git a/fastboot_app/device_agent/test_device_agent.c b/fastboot_app/device_agent/test_device_agent.c
new file mode 100644
index 0000000..07323b1
--- /dev/null
+++ b/fastboot_app/device_agent/test_device_agent.c
@@ -0,0 +1,68 @@
+/*
+ * test_device_agent.c
+ *
+ * History:
+ *       2015/03/10 - [jywang] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include "device.h"
+
+int main(int argc, char **argv) {
+    if (argc < 2) {
+        LOGE("%s ip", argv[0]);
+        return -1;
+    }
+
+    param_device_t param;
+    strcpy(param.srv_ip, argv[1]);
+    param.srv_dev_port = 8888;
+
+    handle_t h_device = device_create(&param);
+    if (!h_device) {
+        LOGE("create device failure");
+        return RET_ERROR;
+    }
+
+    int32_t ret = device_init(h_device);
+    if (ret < 0) {
+        LOGE("init device failure");
+        goto EXIT;
+    }
+
+    ret = device_start(h_device);
+    if (ret < 0) {
+        LOGE("start failure");
+        goto EXIT;
+    }
+
+    while (getchar() != 'q') ;
+
+EXIT:
+    if (h_device) device_destroy(&h_device);
+
+    return RET_OK;
+}
diff --git a/fastboot_app/make.inc b/fastboot_app/make.inc
new file mode 100644
index 0000000..7c47652
--- /dev/null
+++ b/fastboot_app/make.inc
@@ -0,0 +1,35 @@
+#
+# make.inc
+#
+# History:
+#       2014/12/22 - [Jian Liu] created file
+#
+# Copyright (c) 2014 Ambarella, Inc.
+#
+# This file and its contents ("Software") are protected by intellectual
+# property rights including, without limitation, U.S. and/or foreign
+# copyrights. This Software is also the confidential and proprietary
+# information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+# disclose, distribute, modify, or otherwise prepare derivative works of this
+# Software or any portion thereof except pursuant to a signed license agreement
+# or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+# In the absence of such an agreement, you agree to promptly notify and return
+# this Software to Ambarella, Inc.
+#
+# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+# MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+# IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+#
+ifeq ($(BUILD_AMBARELLA_BPI_APP), y)
+include $(call all-subdir-makefiles)
+endif
+
