diff --git a/AmbaConfig b/AmbaConfig
index 6a7c62b..21702fd 100644
--- a/AmbaConfig
+++ b/AmbaConfig
@@ -21,7 +21,7 @@ menuconfig BUILD_AMBARELLA_PUBLIC_LINUX_UNIT_TESTS
 
 if BUILD_AMBARELLA_PUBLIC_LINUX_UNIT_TESTS
 
-config BUILD_AMBARELLA_UNIT_TESTS_AUDIO
+config BUILD_AMBARELLA_PUBLIC_UNIT_TESTS_AUDIO
 	bool "Build Ambarella Public Linux Audio unit tests"
 	default n
 	help
@@ -86,5 +86,17 @@ config BUILD_AMBARELLA_UNIT_TESTS_I2C_TOOL
 	default n
 	help
 		Build unit tests for I2C test.
+
+config BUILD_AMBARELLA_UNIT_TESTS_IIO
+	bool "Build Linux IIO tool unit tests"
+	default n
+	help
+		Build unit tests for IIO test.
+
+config BUILD_AMBARELLA_UNIT_TESTS_EVTEST
+	bool "Build Linux evtest tool unit tests"
+	default n
+	help
+		Build unit tests for INPUT device test.
 endif
 
diff --git a/audio/audio_encode.h b/audio/audio_encode.h
index 559fc3a..7ef4cff 100644
--- a/audio/audio_encode.h
+++ b/audio/audio_encode.h
@@ -27,7 +27,7 @@ THE SOFTWARE.
 #ifndef __AUDIOENCODE_H__
 #define __AUDIOENCODE_H__
 
-
+#include <alsa/asoundlib.h>
 #if _DEBUG
 #undef DEBUG
 #define DEBUG	/**< Defined when compiling code for debugging */
@@ -135,17 +135,17 @@ typedef ulonglong			uint64_t;		/**< An 64 bit unsigned integer */
 typedef signed char			int8_t;			/**< An 8 bit signed integer (2s complement) */
 typedef signed short		int16_t;		/**< An 16 bit signed integer (2s complement) */
 typedef signed int			int32_t;		/**< An 32 bit signed integer (2s complement) */
-typedef longlong			int64_t;		/**< An 64 bit signed integer (2s complement) */
-typedef int					intptr_t;		/**< An signed integer of the same size as a pointer type */
-typedef unsigned int		uintptr_t;		/**< An unsigned integer of the same size as a pointer type */
+//typedef longlong			int64_t;		/**< An 64 bit signed integer (2s complement) */
+//typedef int					intptr_t;		/**< An signed integer of the same size as a pointer type */
+//typedef unsigned int		uintptr_t;		/**< An unsigned integer of the same size as a pointer type */
 typedef int64_t				intmax_t;		/**< Largest signed integer type */
 typedef uint64_t			uintmax_t;		/**< Largest unsigned integer type */
-typedef uintptr_t			size_t;			/**< A size of an object or memory region */
+//typedef uintptr_t			size_t;			/**< A size of an object or memory region */
 typedef intptr_t			ptrdiff_t;		/**< A signed integer which can hold the different between two pointer */
 
 /** @} */ // End of group
 
-ASSERT_COMPILE(sizeof(uintptr_t)==sizeof(void*));
+//ASSERT_COMPILE(sizeof(uintptr_t)==sizeof(void*));
 ASSERT_COMPILE(sizeof(intptr_t)==sizeof(void*));
 
 
diff --git a/audio/make.inc b/audio/make.inc
index a61ed75..9ee39d6 100644
--- a/audio/make.inc
+++ b/audio/make.inc
@@ -12,7 +12,7 @@
 ## without the prior consent of Ambarella, Inc.
 ##
 
-ifeq ($(BUILD_AMBARELLA_UNIT_TESTS_AUDIO), y)
+ifeq ($(BUILD_AMBARELLA_PUBLIC_UNIT_TESTS_AUDIO), y)
 
 LOCAL_PATH	:= $(call my-dir)
 
@@ -23,6 +23,7 @@ LOCAL_TARGET	:= test_audio
 LOCAL_SRCS	:= $(LOCAL_PATH)/test_audio.cpp \
 			$(LOCAL_PATH)/audio_encode.cpp
 LOCAL_CFLAGS	:= -I$(PREBUILD_3RD_PARTY_DIR)/alsa-lib/include \
+				-I$(PREBUILD_3RD_PARTY_DIR)/alsa-lib/usr/include \
 				-I$(LOCAL_PATH)/alsautils
 LOCAL_LDFLAGS	:= -L$(PREBUILD_3RD_PARTY_DIR)/alsa-lib/usr/lib -lasound \
                  -lpthread -lrt -ldl
diff --git a/audio/test_audio.cpp b/audio/test_audio.cpp
index e9ea00e..992dc23 100644
--- a/audio/test_audio.cpp
+++ b/audio/test_audio.cpp
@@ -193,16 +193,11 @@ static snd_pcm_uframes_t set_params(snd_pcm_t *handle, snd_pcm_stream_t stream)
 	}
 
 	printf("%s: %s\n", stream == SND_PCM_STREAM_PLAYBACK ? "Playback" : "Capture", file_name);
-	printf("format = %s, channels = %d, rate = %d\n",
+	printf("format = %s, channels = %d, rate = %d,%d\n",
 		snd_pcm_format_name(hwparams.format),
-		hwparams.channels, hwparams.rate);
+		hwparams.channels, hwparams.rate,hwparams.format);
 
-	//err = snd_pcm_hw_params_set_format(handle, params, hwparams.format);
-	if (hwparams.format == SND_PCM_FORMAT_U8) {
-		err = snd_pcm_hw_params_set_format(handle, params, SND_PCM_FORMAT_U8);
-	} else {
-		err = snd_pcm_hw_params_set_format(handle, params, SND_PCM_FORMAT_S16_LE);
-	}
+	err = snd_pcm_hw_params_set_format(handle, params, hwparams.format);
 	if (err < 0) {
 		printf("Sample format non available");
 		exit(EXIT_FAILURE);
@@ -269,11 +264,8 @@ static snd_pcm_uframes_t set_params(snd_pcm_t *handle, snd_pcm_stream_t stream)
 		printf("unable to install sw params:");
 		exit(EXIT_FAILURE);
 	}
-	if (hwparams.format == SND_PCM_FORMAT_U8) {
-		bits_per_sample = snd_pcm_format_physical_width(SND_PCM_FORMAT_U8);
-	} else {
-		bits_per_sample = snd_pcm_format_physical_width(SND_PCM_FORMAT_S16_LE);
-	}
+
+	bits_per_sample = snd_pcm_format_physical_width(hwparams.format);
 
 	bits_per_frame = bits_per_sample * hwparams.channels;
 
@@ -281,7 +273,7 @@ static snd_pcm_uframes_t set_params(snd_pcm_t *handle, snd_pcm_stream_t stream)
 	chunk_bytes = chunk_size * bits_per_frame / 8;
 
 	printf("chunk_size = %d,chunk_bytes = %d,buffer_size = %d\n\n",
-		(int)chunk_size,chunk_bytes,(int)buffer_size);
+		(int)chunk_size,(int)chunk_bytes,(int)buffer_size);
 
 	return chunk_size;
 }
@@ -338,12 +330,19 @@ static snd_pcm_uframes_t handle_data_pb(ssize_t count, u_char *data, u_char *tmp
 					*((u_short *)tmp + i) = *((u_short *)data + i / 2 + 1);
 				else
 					*((u_short *)tmp + i) = *((u_short *)data + i / 2);
-		} else {
+		} else if (hwparams.format == SND_PCM_FORMAT_U8){
 			for (i = 0; i < count << 1; i++)
 				if(channel_id)
 					*(tmp + i) = *(data + i / 2 + 1);
 				else
 					*(tmp + i) = *(data + i / 2);
+		} else if ((hwparams.format == SND_PCM_FORMAT_S24_LE) ||
+			(hwparams.format == SND_PCM_FORMAT_S32_LE)){
+			for (i = 0;i < count >> 1 ; i++)
+				if(channel_id)
+					*((u32 *)tmp + i) = *((u32 *)data + i / 2 + 1);
+				else
+					*((u32 *)tmp + i) = *((u32 *)data + i / 2);
 		}
 		tmp_cnt = count << 1;
 	} else if (hwparams.channels == 2) {
@@ -366,6 +365,8 @@ static snd_pcm_uframes_t handle_data_pb(ssize_t count, u_char *data, u_char *tmp
 	case SND_PCM_FORMAT_MU_LAW:
 		bfcount = G711::ULawDecode((s16 *)data, tmp, tmp_cnt);
 		break;
+	case SND_PCM_FORMAT_S32_LE:
+	case SND_PCM_FORMAT_S24_LE:
 	case SND_PCM_FORMAT_S16_LE:
 	case SND_PCM_FORMAT_U8:
 		memcpy(data, tmp, tmp_cnt);
@@ -425,13 +426,21 @@ static size_t handle_data_cp(snd_pcm_uframes_t chunk_size, u_char *data, u_char
 				else
 					*(tmp + i) = *(data + i * 2);
 			}
-		} else {
+		} else if (hwparams.format == SND_PCM_FORMAT_S16_LE){
 			for (i = 0;i < tmp_cnt; i++) {
 				if(channel_id)
 					*((u_short *)tmp + i) = *((u_short *)data + i * 2 + 1);
 				else
 					*((u_short *)tmp + i) = *((u_short *)data + i * 2);
 			}
+		} else if ((hwparams.format == SND_PCM_FORMAT_S24_LE) ||
+			(hwparams.format == SND_PCM_FORMAT_S32_LE)) {
+			for (i = 0;i < tmp_cnt; i++) {
+				if(channel_id)
+					*((u_int *)tmp + i) = *((u_int *)data + i * 2 + 1);
+				else
+					*((u_int *)tmp + i) = *((u_int *)data + i * 2);
+			}
 		}
 	} else if (hwparams.channels == 2){
 		if ((hwparams.format == SND_PCM_FORMAT_A_LAW) ||
@@ -453,6 +462,8 @@ static size_t handle_data_cp(snd_pcm_uframes_t chunk_size, u_char *data, u_char
 	case SND_PCM_FORMAT_MU_LAW:
 		bfcount = G711::ULawEncode(data, (s16 *)tmp, tmp_cnt);
 		break;
+	case SND_PCM_FORMAT_S32_LE:
+	case SND_PCM_FORMAT_S24_LE:
 	case SND_PCM_FORMAT_S16_LE:
 	case SND_PCM_FORMAT_U8:
 		memcpy(data, tmp, tmp_cnt);
@@ -703,7 +714,9 @@ static int check_output_format(WaveContainer *inputContainer)
 		printf("Unsupported output channel count!\n");
 		return -1;
 	}
-	if (hwparams.format != SND_PCM_FORMAT_S16_LE &&
+	if (hwparams.format != SND_PCM_FORMAT_S32_LE &&
+		hwparams.format != SND_PCM_FORMAT_S24_LE &&
+		hwparams.format != SND_PCM_FORMAT_S16_LE &&
 		hwparams.format != SND_PCM_FORMAT_U8) {
 		printf("Unsupported output wave format!\n");
 		return -1;
@@ -713,11 +726,23 @@ static int check_output_format(WaveContainer *inputContainer)
 		return -1;
 	}
 
-	if (hwparams.format == SND_PCM_FORMAT_S16_LE) {
+	switch (hwparams.format) {
+	case SND_PCM_FORMAT_S16_LE:
 		bit_p_spl = 16;
-	} else if (hwparams.format == SND_PCM_FORMAT_U8) {
+		break;
+	case SND_PCM_FORMAT_U8:
 		bit_p_spl = 8;
+		break;
+	case SND_PCM_FORMAT_S24_LE:
+		bit_p_spl = 24;
+		break;
+	case SND_PCM_FORMAT_S32_LE:
+		bit_p_spl = 32;
+		break;
+	default:
+		printf("Not supporting format:%d!\n",hwparams.format);
 	}
+
 	if (inputContainer->waveFmt.fmtBody.bit_p_spl < bit_p_spl) {
 		printf("Not supporting upsample for bit per sample!\n");
 		ret = -1;
@@ -750,7 +775,12 @@ static WaveContainer gen_wave_header(WaveContainer *inputContainer)
 		outputContainer.waveFmt.fmtBody.bit_p_spl = 16;
 	} else if (hwparams.format == SND_PCM_FORMAT_U8){
 		outputContainer.waveFmt.fmtBody.bit_p_spl = 8;
+	} else if (hwparams.format == SND_PCM_FORMAT_S24_LE) {
+		outputContainer.waveFmt.fmtBody.bit_p_spl = 24;
+	} else if (hwparams.format == SND_PCM_FORMAT_S32_LE) {
+		outputContainer.waveFmt.fmtBody.bit_p_spl = 32;
 	}
+
 	outputContainer.waveFmt.fmtBody.sample_fq = hwparams.rate;
 	outputContainer.waveFmt.fmtBody.channels = hwparams.channels;
 
diff --git a/benchmark/AmbaConfig b/benchmark/AmbaConfig
index c3d322a..08da3d1 100644
--- a/benchmark/AmbaConfig
+++ b/benchmark/AmbaConfig
@@ -56,6 +56,12 @@ config BUILD_AMBARELLA_UNIT_TESTS_SD_TEST
 	help
 		Build unit tests for sd_test test
 
+config BUILD_AMBARELLA_UNIT_TESTS_SD_BENCHMARK
+	bool "Build unit tests for sd_benchmark test"
+	default n
+	help
+		Build unit tests for sd_benchmark test
+
 config BUILD_AMBARELLA_UNIT_TESTS_NET_TEST
 	bool "Build unit tests for net_test test"
 	default n
@@ -63,9 +69,15 @@ config BUILD_AMBARELLA_UNIT_TESTS_NET_TEST
 		Build unit tests for net_test test
 
 config BUILD_AMBARELLA_UNIT_TESTS_MEMTESTER
-	bool "Build unit tests for memory test"
+	bool "Build unit tests for memory stability test"
 	default n
 	help
 		Build unit tests for memory test
+
+config BUILD_AMBARELLA_UNIT_TESTS_TINYMEMBENCH
+	bool "Build Simple memory benchmark for Bandwidth and Latency"
+	default n
+	help
+		Build unit tests for memory benchmark
 endif
 
diff --git a/benchmark/bandwidth/main.c b/benchmark/bandwidth/main.c
index 7bc130e..8847a7f 100644
--- a/benchmark/bandwidth/main.c
+++ b/benchmark/bandwidth/main.c
@@ -128,7 +128,7 @@ static int chunk_sizes[] = {
 	1 << 22,	// 4 MB
 	5242880,	// 5 megs
 	6291456,	// 6 megs (std L2 cache size)
-#ifndef __arm__
+#if !defined(__arm__) && !defined(__aarch64__)
 	7 * 1024 * 1024,	// 7 megs
 	8 * 1024 * 1024,
 	16 * 1024 * 1024,
@@ -181,7 +181,7 @@ static double chunk_sizes_log2[] =
 	22,		// 4 MB
 	22.3219,
 	22.585,
-#ifndef __arm__
+#if !defined(__arm__) && !defined(__aarch64__)
 	22.8074,
 	23,
 	24,
@@ -477,7 +477,7 @@ void println (wchar_t *s)
 
 void print_int (int d)
 {
-#if defined(__WIN32__) && defined(__arm__)
+#if defined(__WIN32__) && (defined(__arm__) || defined(__aarch64__))
 	swprintf (msg + wcslen (msg), L"%d", d);
 #else
 	swprintf (msg + wcslen (msg), MSGLEN, L"%d", d);
@@ -492,7 +492,7 @@ void println_int (int d)
 
 void print_result (long double result)
 {
-#if defined(__WIN32__) && defined(__arm__)
+#if defined(__WIN32__) && (defined(__arm__) || defined(__aarch64__))
 	swprintf (msg + wcslen (msg), L"%.1Lf MB/s", result);
 #else
 	swprintf (msg + wcslen (msg), MSGLEN, L"%.1Lf MB/s", result);
@@ -516,7 +516,7 @@ void dump (FILE *f)
 
 void flush ()
 {
-#if defined(__WIN32__) && defined(__arm__)
+#if defined(__WIN32__) && (defined(__arm__) || defined(__aarch64__))
 	MessageBeep (MB_OK);
 #else
 	dump (NULL);
@@ -608,7 +608,7 @@ do_write (unsigned long size, int mode, bool random)
 	unsigned char *chunk0;
 	unsigned long loops;
 	unsigned long long total_count=0;
-#ifdef __x86_64__
+#if defined(__x86_64__) || defined(__aarch64__)
 	unsigned long value = 0x1234567689abcdef;
 #else
 	unsigned long value = 0x12345678;
@@ -679,7 +679,7 @@ do_write (unsigned long size, int mode, bool random)
 	if (mode == SSE2_BYPASS) {
 		print (L"bypassing cache (128-bit), size = ");
 	} else {
-#ifdef __x86_64__
+#if defined(__x86_64__) || defined(__aarch64__)
 		print (L"(64-bit), size = ");
 #else
 		print (L"(32-bit), size = ");
@@ -696,7 +696,7 @@ do_write (unsigned long size, int mode, bool random)
 	while (diff < usec_per_test) {
 		total_count += loops;
 
-#ifndef __arm__
+#if !defined(__arm__) && !defined(__aarch64__)
 		if (mode == SSE2) {
 			if (random)
 				RandomWriterSSE2 (chunk_ptrs, size/256, loops, value);
@@ -814,7 +814,7 @@ do_read (unsigned long size, bool use_sse2, bool random)
 	if (use_sse2) {
 		print (L"(128-bit), size = ");
 	} else {
-#ifdef __x86_64__
+#if defined(__x86_64__) || defined(__aarch64__)
 		print (L"(64-bit), size = ");
 #else
 		print (L"(32-bit), size = ");
@@ -833,7 +833,7 @@ do_read (unsigned long size, bool use_sse2, bool random)
 	while (diff < usec_per_test) {
 		total_count += loops;
 
-#ifndef __arm__
+#if !defined(__arm__) && !defined(__aarch64__)
 		if (use_sse2) {
 			if (random)
 				RandomReaderSSE2 (chunk_ptrs, size/256, loops);
@@ -919,7 +919,7 @@ do_copy (unsigned long size, int mode)
 		print (L"(128-bit), size = ");
 	}
 	else {
-#ifdef __x86_64__
+#if defined(__x86_64__) || defined(__aarch64__)
 		print (L"(64-bit), size = ");
 #else
 		print (L"(32-bit), size = ");
@@ -938,7 +938,7 @@ do_copy (unsigned long size, int mode)
 	while (diff < usec_per_test) {
 		total_count += loops;
 
-#ifndef __arm__
+#if !defined(__arm__) && !defined(__aarch64__)
 		if (mode == SSE2)
 			CopySSE (chunk_dest, chunk_src, size, loops);
 #if 0
@@ -984,7 +984,7 @@ fb_readwrite (bool use_sse2)
 	//unsigned long datum;
 	int fd;
 	//register unsigned long foo;
-#ifdef __x86_64__
+#if defined(__x86_64__) || defined(__aarch64__)
 	unsigned long value = 0x1234567689abcdef;
 #else
 	unsigned long value = 0x12345678;
@@ -1058,7 +1058,7 @@ fb_readwrite (bool use_sse2)
 
 	total_count = FBLOOPS_R;
 
-#ifndef __arm__
+#if !defined(__arm__) && !defined(__aarch64__)
 	if (use_sse2)
 		ReaderSSE2 (fb, length, FBLOOPS_R);
 	else
@@ -1080,7 +1080,7 @@ fb_readwrite (bool use_sse2)
 
 	total_count = FBLOOPS_W;
 
-#ifndef __arm__
+#if !defined(__arm__) && !defined(__aarch64__)
 	if (use_sse2)
 		WriterSSE2_bypass (fb, length, FBLOOPS_W, value);
 	else
@@ -1106,7 +1106,7 @@ register_test ()
 	unsigned long diff = 0;
 
 	//--------------------------------------
-#ifdef __x86_64__
+#if defined(__x86_64__) || defined(__aarch64__)
 	print (L"Main register to main register transfers (64-bit) ");
 #else
 	print (L"Main register to main register transfers (32-bit) ");
@@ -1127,7 +1127,7 @@ register_test ()
 	newline ();
 	flush ();
 
-#ifndef __arm__
+#if !defined(__arm__) && !defined(__aarch64__)
 	//--------------------------------------
 #ifdef __x86_64__
 	print (L"Main register to vector register transfers (64-bit) ");
@@ -1371,7 +1371,7 @@ stack_test ()
 	unsigned long t0;
 	unsigned long diff = 0;
 
-#ifdef __x86_64__
+#if defined(__x86_64__) || defined(__aarch64__)
 	print (L"Stack-to-register transfers (64-bit) ");
 #else
 	print (L"Stack-to-register transfers (32-bit) ");
@@ -1394,7 +1394,7 @@ stack_test ()
 	newline ();
 	flush ();
 
-#ifdef __x86_64__
+#if defined(__x86_64__) || defined(__aarch64__)
 	print (L"Register-to-stack transfers (64-bit) ");
 #else
 	print (L"Register-to-stack transfers (32-bit) ");
@@ -1430,10 +1430,10 @@ library_test ()
 	int i;
 
 
-#if defined(__WIN32__) && defined(__arm__)
+#if defined(__WIN32__) && (defined(__arm__) || defined(__aarch64__))
 	#define NT_SIZE (1024*1024)
 	#define NT_SIZE2 (50)
-#elif !defined(__WIN32__) && defined(__arm__)
+#elif !defined(__WIN32__) && (defined(__arm__) || defined(__aarch64__))
 #if defined(DRAM_SIZE_SMALL)
 	#define NT_SIZE (16*1024*1024)
 #else
@@ -1883,7 +1883,7 @@ main (int argc, char **argv)
 
 	msg[0] = 0;
 
-#if !(defined(__WIN32__) && defined(__arm__))
+#if !(defined(__WIN32__) && (defined(__arm__) || defined(__aarch64__)))
 	printf ("This is bandwidth version %s.\n", VERSION);
 	printf ("Copyright (C) 2005-2010 by Zack T Smith.\n\n");
 	printf ("This software is covered by the GNU Public License.\n");
@@ -1912,26 +1912,33 @@ main (int argc, char **argv)
 		return 0;
 	}
 
-#ifndef __arm__
+#if !defined(__arm__) && !defined(__aarch64__)
 	if (!has_sse2 ()) {
 		puts ("Processor does not have SSE2.");
 		use_sse2 = false;
 		use_sse4 = false;
 	}
 
-	#ifdef __x86_64__
+#ifdef __x86_64__
 	if (use_sse2)
 		println (L"Using 128-bit and 64-bit data transfers.");
 	else
 		println (L"Using 64-bit data transfers.");
-	#else
+#else
 	if (use_sse2)
 		println (L"Using 128-bit and 32-bit data transfers.");
 	else
 		println (L"Using 32-bit data transfers.");
-	#endif
+#endif
+
+#else
+
+#if defined(__aarch64__)
+	println (L"Using 64-bit transfers.");
 #else
 	println (L"Using 32-bit transfers.");
+#endif
+
 	use_sse2 = false;
 #endif
 
@@ -1961,7 +1968,7 @@ main (int argc, char **argv)
 			fclose (f);
 		}
 
-#ifndef __arm__
+#if !defined(__arm__) && !defined(__aarch64__)
 		unlink (TMPFILE);
 		if (-1 == system ("grep -i sse4 /proc/cpuinfo > "TMPFILE))
 			perror ("system");
@@ -1995,7 +2002,7 @@ main (int argc, char **argv)
 	graph = BMP_new (graph_width, graph_height);
 	graph_init ();
 
-#if !defined(__arm__)
+#if !defined(__arm__) && !defined(__aarch64__)
 	//------------------------------------------------------------
 	// SSE2 sequential reads.
 	//
@@ -2100,7 +2107,7 @@ main (int argc, char **argv)
 	// Sequential non-SSE2 reads.
 	//
 	newline ();
-#ifdef __x86_64__
+#if defined(__x86_64__) || defined(__aarch64__)
 	graph_new_line ("Sequential 64-bit reads", RGB_BLUE);
 #else
 	graph_new_line ("Sequential 32-bit reads", RGB_BLUE);
@@ -2117,7 +2124,7 @@ main (int argc, char **argv)
 	// Random non-SSE2 reads.
 	//
 	newline ();
-#ifdef __x86_64__
+#if defined(__x86_64__) || defined(__aarch64__)
 	graph_new_line ("Random 64-bit reads", RGB_CYAN);
 #else
 	graph_new_line ("Random 32-bit reads", RGB_CYAN);
@@ -2134,7 +2141,7 @@ main (int argc, char **argv)
 	//------------------------------------------------------------
 	// Sequential non-SSE2 writes.
 	//
-#ifdef __x86_64__
+#if defined(__x86_64__) || defined(__aarch64__)
 	graph_new_line ("Sequential 64-bit writes", RGB_DARKGREEN);
 #else
 	graph_new_line ("Sequential 32-bit writes", RGB_DARKGREEN);
@@ -2152,7 +2159,7 @@ main (int argc, char **argv)
 	//------------------------------------------------------------
 	// Random non-SSE2 writes.
 	//
-#ifdef __x86_64__
+#if defined(__x86_64__) || defined(__aarch64__)
 	graph_new_line ("Random 64-bit writes", RGB_GREEN);
 #else
 	graph_new_line ("Random 32-bit writes", RGB_GREEN);
@@ -2168,7 +2175,7 @@ main (int argc, char **argv)
 		graph_add_point (chunk_size, amount);
 	}
 
-#ifndef __arm__
+#if !defined(__arm__) && !defined(__aarch64__)
 	//------------------------------------------------------------
 	// SSE2 sequential copy.
 	//
@@ -2212,7 +2219,7 @@ main (int argc, char **argv)
 	fb_readwrite (true);
 #endif
 
-#if defined(__WIN32__) && defined(__arm__)
+#if defined(__WIN32__) && (defined(__arm__) || defined(__aarch64__))
 	MessageBoxW (0, msg, APPNAME, 0);
 
 	FILE *of = fopen ("bandwidth.log", "w");
diff --git a/benchmark/bandwidth/main_thread.c b/benchmark/bandwidth/main_thread.c
new file mode 100644
index 0000000..99e6078
--- /dev/null
+++ b/benchmark/bandwidth/main_thread.c
@@ -0,0 +1,2379 @@
+/*============================================================================
+  bandwidth 0.24, a benchmark to estimate memory transfer bandwidth.
+  Copyright (C) 2005-2010 by Zack T Smith.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+  The author may be reached at fbui@comcast.net.
+ *===========================================================================*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <sys/param.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <wchar.h>
+#include <math.h>
+#include <pthread.h>
+
+#include <netdb.h> // gethostbyname
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+#include "defs.h"
+#include "BMP.h"
+#include "config.h"
+
+#ifdef __WIN32__
+#include <windows.h>
+#endif
+
+#ifdef __linux__
+#include <linux/fb.h>
+#include <sys/mman.h>
+#endif
+
+#ifdef CONFIG_ARCH_S2L
+#if  defined(CONFIG_BSP_BOARD_S2LM_KIWI) || defined(CONFIG_BSP_BOARD_STRAWBERRY)
+#define DRAM_SIZE_SMALL
+#endif
+#endif
+
+//----------------------------------------
+// Graphing data.
+//
+static char graph_title [500];
+#define TITLE "Results from bandwidth " VERSION " by Zack Smith, http://caladan.tk"
+static BMP *graph;	// Graph of results.
+static int graph_width = 1280;
+static int graph_height = 720;
+static int graph_left_margin = 100;
+static int graph_margin = 50; // top/bottom/right
+static int graph_x_span = 1;
+static int graph_y_span = 1;
+static int graph_last_x = -1;
+static int graph_last_y = -1;
+static unsigned long graph_fg = RGB_BLACK;
+static int legend_y;
+#define MAX_GRAPH_DATA 5000
+static long graph_data [MAX_GRAPH_DATA];
+static int graph_data_index = 0;
+enum {
+	DATUM_SIZE=0,
+	DATUM_AMOUNT=1,
+	DATUM_COLOR=2,
+};
+static int max_bandwidth = 0;	// Always 10 times the # of megabyte/sec.
+
+static bool use_sse2 = true;
+static bool use_sse4 = true;
+
+static int goon_flag = 1;
+static int thread_num = 4;
+static int chunk_index = 0;
+static int cpu_num = 0;
+
+struct thread_params {
+	int id;
+	unsigned long size;
+	bool random;
+	unsigned long **chunk_ptrs;
+	unsigned char *chunk;
+	unsigned long loops;
+};
+
+//----------------------------------------
+// Parameters for the tests.
+//
+static long usec_per_test = 5000000;	// 5 seconds per test.
+
+static int chunk_sizes[] = {
+	256,
+	512,
+	768,
+	1024,
+	2048,
+	3072,
+	4096,
+	6144,
+	8192,	// Some processors' L1 data caches are only 8kB.
+	12288,
+	16384,
+	20480,
+	24576,
+	28672,
+	32768,	// Common L1 data cache size.
+	40960,
+	49152,
+	65536,
+	131072,	// Old L2 cache size.
+	192 * 1024,
+	256 * 1024,	// Old L2 cache size.
+	384 * 1024,
+	512 * 1024,	// Old L2 cache size.
+	768 * 1024,
+	1 << 20,	// 1 MB = common L2 cache size.
+	(1024 + 256) * 1024,	// 1.25
+	(1024 + 512) * 1024,	// 1.5
+	(1024 + 768) * 1024,	// 1.75
+	1 << 21,	// 2 MB = common L2 cache size.
+	(2048 + 256) * 1024,	// 2.25
+	(2048 + 512) * 1024,	// 2.5
+	(2048 + 768) * 1024,	// 2.75
+	3072 * 1024,	// 3 MB = common L2 cache sized.
+	1 << 22,	// 4 MB
+	5242880,	// 5 megs
+	6291456,	// 6 megs (std L2 cache size)
+	16 * 1024 * 1024,
+	64 * 1024 * 1024,
+	0
+};
+
+//----------------------------------------
+// Under CeGCC, the math.h log2() function
+// turned out to be very inaccurate e.g.
+// log2(8)=1.44, so I have here hard-coded
+// the logarithms.
+//
+static double chunk_sizes_log2[] =
+{
+	8,
+	9,
+	9.585,
+	10,
+	11,
+	11.585,
+	12,
+	12.585,
+	13,		// 8 kB
+	13.585,
+	14,		// 16 kB
+	14.3219,	// 20 kB
+	14.585,		// 24 kB
+	14.8074,	// 28 kB
+	15,		// 32 kB
+	15.3219,	// 40 kB
+	15.585,		// 48 kB
+	16,		// 64 kB
+	17,		// 128 kB
+	17.585,		// 192 kB
+	18,		// 256 kB
+	18.585,		// 385 kB
+	19,		// 512 kB
+	19.585,		// 768 kB
+	20,		// 1 MB
+	20.3219,	// 1.25
+	20.585,		// 1.5
+	20.8074,	// 1.75
+	21,		// 2 MB
+	21.1699,	// 2.25 MB
+	21.3219,	// 2.5 MB
+	21.4594,	// 2.75 MB
+	21.585,		// 3 MB
+	22,		// 4 MB
+	22.3219,
+	22.585,
+	24,
+	26,
+	0
+};
+
+static int min_chunk_size = 1;	// These are determined in graph_draw_labels().
+static int max_chunk_size = 1;
+
+//----------------------------------------------------------------------------
+// Name:	error
+// Purpose:	Complain and exit.
+//----------------------------------------------------------------------------
+void error (char *s)
+{
+#ifndef __WIN32__
+	fprintf (stderr, "Error: %s\n", s);
+	exit (1);
+#else
+	wchar_t tmp [200];
+	int i;
+	for (i = 0; s[i]; i++)
+		tmp[i] = s[i];
+	tmp[i] = 0;
+	MessageBoxW (0, tmp, L"Error", 0);
+	ExitProcess (0);
+#endif
+}
+
+void
+dump_hex64 (unsigned long long value)
+{
+	unsigned long long v2 = value;
+	int i = 16;
+	while (i--) {
+		unsigned long long tmp = v2 >> 60;
+		unsigned int tmp2 = (unsigned int) tmp;
+		printf ("%1x", tmp2);
+		v2 <<= 4;
+	}
+}
+
+//============================================================================
+// Graphing logic.
+//============================================================================
+
+//----------------------------------------------------------------------------
+// Name:	graph_draw_labels
+// Purpose:	Draw the labels and ticks.
+//----------------------------------------------------------------------------
+void
+graph_draw_labels ()
+{
+	int i;
+
+	//----------------------------------------
+	// Horizontal
+	//
+	//--------------------
+	// Establish min & max.
+	//
+	min_chunk_size = 1000;
+	max_chunk_size = 0;
+	i = 0;
+	int j;
+	while ((j = chunk_sizes_log2 [i])) {
+		if (j < min_chunk_size)
+			min_chunk_size = j;
+		if (j > max_chunk_size)
+			max_chunk_size = j;
+		i++;
+	}
+
+	for (i = min_chunk_size; i <= max_chunk_size; i++) {
+		char str[20];
+		int x = graph_left_margin +
+			((i-min_chunk_size) * graph_x_span) /
+			(max_chunk_size - min_chunk_size);
+		int y = graph_height - graph_margin + 10;
+
+		unsigned long amt = 1 << i;
+		if (amt < 1024)
+			sprintf (str, "%ld B", amt);
+		else if (amt < (1<<20)) {
+			sprintf (str, "%ld kB", amt >> 10);
+		}
+		else {
+			j = amt >> 20;
+			switch ((amt >> 18) & 3) {
+			case 0: sprintf (str, "%d MB", j); break;
+			case 1: sprintf (str, "%d.25 MB", j); break;
+			case 2: sprintf (str, "%d.5 MB", j); break;
+			case 3: sprintf (str, "%d.75 MB", j); break;
+			}
+		}
+
+		BMP_vline (graph, x, y, y-10, RGB_BLACK);
+		BMP_draw_mini_string (graph, str, x - 10, y+8, RGB_BLACK);
+	}
+
+	//----------------------------------------
+	// Vertical
+	//
+	for (i = 0; i <= (max_bandwidth/10000); i++) {
+		char str[20];
+		int x = graph_left_margin - 10;
+		int y = graph_height - graph_margin -
+			(i * graph_y_span) / (max_bandwidth/10000);
+
+		BMP_hline (graph, x, x+10, y, RGB_BLACK);
+
+		sprintf (str, "%d GB/s", i);
+		BMP_draw_mini_string (graph, str,
+			x - 40, y - MINIFONT_HEIGHT/2, RGB_BLACK);
+	}
+}
+
+void
+graph_init ()
+{
+	if (!graph)
+		return;
+
+	BMP_clear (graph, RGB_WHITE);
+
+	BMP_hline (graph, graph_left_margin, graph_width - graph_margin,
+			graph_height - graph_margin, RGB_BLACK);
+	BMP_vline (graph, graph_left_margin, graph_margin,
+			graph_height - graph_margin, RGB_BLACK);
+
+	graph_x_span = graph_width - (graph_margin + graph_left_margin);
+	graph_y_span = graph_height - 2 * graph_margin;
+
+	BMP_draw_mini_string (graph, graph_title,
+		graph_left_margin, graph_margin/2, RGB_BLACK);
+
+	legend_y = graph_margin;
+}
+
+void
+graph_new_line (char *str, unsigned long color)
+{
+	BMP_draw_mini_string (graph, str,
+		graph_width - graph_margin - 200, legend_y, color);
+
+	legend_y += 10;
+
+	graph_fg = color;
+	graph_last_x = graph_last_y = -1;
+
+	if (graph_data_index >= MAX_GRAPH_DATA-2)
+		error ("Too many graph data.");
+
+	graph_data [graph_data_index++] = DATUM_COLOR;
+	graph_data [graph_data_index++] = (long) color;
+}
+
+//----------------------------------------------------------------------------
+// Name:	graph_add_point
+// Purpose:	Adds a point to this list to be drawn.
+//----------------------------------------------------------------------------
+void
+graph_add_point (int size, int amount)
+{
+	if (graph_data_index >= MAX_GRAPH_DATA-4)
+		error ("Too many graph data.");
+
+	graph_data [graph_data_index++] = DATUM_SIZE;
+	graph_data [graph_data_index++] = size;
+	graph_data [graph_data_index++] = DATUM_AMOUNT;
+	graph_data [graph_data_index++] = amount;
+}
+
+//----------------------------------------------------------------------------
+// Name:	graph_plot
+// Purpose:	Plots a point on the current graph.
+//----------------------------------------------------------------------------
+void
+graph_plot (int size, int amount)
+{
+	//----------------------------------------
+	// Get the log2 of the chunk size.
+	// We cannot rely on the libm math.h log2
+	// function, because under CeGCC,
+	// log2(8) = 1.44.
+	//
+	int i = chunk_index;
+	while (chunk_sizes [i] && chunk_sizes [i] != size)
+		i++;
+	if (!chunk_sizes [i])
+		error ("Lookup of chunk size failed.");
+	double tmp = chunk_sizes_log2 [i];
+
+	//----------------------------------------
+	// Plot the point. The x axis is
+	// logarithmic, base 2.
+	//
+	tmp -= (double) min_chunk_size;
+	tmp *= (double) graph_x_span;
+	tmp /= (double) (max_chunk_size - min_chunk_size);
+
+	int x = graph_left_margin + (int) tmp;
+	int y = graph_height - graph_margin -
+		(amount * graph_y_span) / max_bandwidth;
+
+// Really I ought to save all data points, take max of everything, then plot.
+
+	if (graph_last_x != -1 && graph_last_y != -1) {
+		BMP_line (graph, graph_last_x, graph_last_y, x, y, graph_fg);
+	}
+
+	graph_last_x = x;
+	graph_last_y = y;
+}
+
+//----------------------------------------------------------------------------
+// Name:	graph_make
+// Purpose:	Plots all lines.
+//----------------------------------------------------------------------------
+void
+graph_make ()
+{
+	int i;
+
+	//----------------------------------------
+	// Get the maximum bandwidth in order to
+	// properly scale the graph vertically.
+	//
+	max_bandwidth = 0;
+	for (i = 0; i < graph_data_index; i += 2) {
+		if (graph_data[i] == DATUM_AMOUNT) {
+			int amt = graph_data[i+1];
+			if (amt > max_bandwidth)
+				max_bandwidth = amt;
+		}
+	}
+	max_bandwidth /= 10000;
+	max_bandwidth *= 10000;
+	max_bandwidth += 10000;
+
+	graph_draw_labels ();
+
+	//----------------------------------------
+	// OK, now draw the lines.
+	//
+	int size = -1, amt = -1;
+	for (i = 0; i < graph_data_index; i += 2)
+	{
+		int type = graph_data[i];
+		long value = graph_data[i+1];
+
+		switch (type) {
+		case DATUM_AMOUNT:	amt = value; break;
+		case DATUM_SIZE:	size = value; break;
+		case DATUM_COLOR:
+			graph_fg = (unsigned long) value;
+			graph_last_x = -1;
+			graph_last_y = -1;
+			break;
+		}
+
+		if (amt != -1 && size != -1) {
+			graph_plot (size, amt);
+			amt = size = -1;
+		}
+	}
+}
+
+//============================================================================
+// Output buffer logic.
+//============================================================================
+
+#define MSGLEN 10000
+static wchar_t msg [MSGLEN];
+
+void print (wchar_t *s)
+{
+	wcscat (msg, s);
+}
+
+void newline ()
+{
+	wcscat (msg, L"\n");
+}
+
+void println (wchar_t *s)
+{
+	wcscat (msg, s);
+	newline ();
+}
+
+void print_int (int d)
+{
+#if defined(__WIN32__) && (defined(__arm__) || defined(__aarch64__))
+	swprintf (msg + wcslen (msg), L"%d", d);
+#else
+	swprintf (msg + wcslen (msg), MSGLEN, L"%d", d);
+#endif
+}
+
+void println_int (int d)
+{
+	print_int (d);
+	newline ();
+}
+
+void print_result (long double result)
+{
+#if defined(__WIN32__) && (defined(__arm__) || defined(__aarch64__))
+	swprintf (msg + wcslen (msg), L"%.1Lf MB/s", result);
+#else
+	swprintf (msg + wcslen (msg), MSGLEN, L"%.1Lf MB/s", result);
+#endif
+}
+
+void dump (FILE *f)
+{
+	if (!f)
+		f = stdout;
+
+	int i = 0;
+	while (msg[i]) {
+		char ch = (char) msg[i];
+		fputc (ch, f);
+		i++;
+	}
+
+	msg [0] = 0;
+}
+
+void flush ()
+{
+#if defined(__WIN32__) && (defined(__arm__) || defined(__aarch64__))
+	MessageBeep (MB_OK);
+#else
+	dump (NULL);
+	fflush (stdout);
+#endif
+}
+
+void print_size (unsigned long size)
+{
+	if (size < 1024) {
+		print_int (size);
+		print (L" B");
+	}
+	else if (size < (1<<20)) {
+		print_int (size >> 10);
+		print (L" kB");
+	} else {
+		print_int (size >> 20);
+		switch ((size >> 18) & 3) {
+		case 1: print (L".25"); break;
+		case 2: print (L".5"); break;
+		case 3: print (L".75"); break;
+		}
+		print (L" MB");
+	}
+}
+
+//============================================================================
+// Timing logic.
+//============================================================================
+
+//----------------------------------------------------------------------------
+// Name:	mytime
+// Purpose:	Reports time in microseconds.
+//----------------------------------------------------------------------------
+unsigned long mytime ()
+{
+#ifndef __WIN32__
+	struct timeval tv;
+	struct timezone tz;
+	memset (&tz, 0, sizeof(struct timezone));
+	gettimeofday (&tv, &tz);
+	return 1000000 * tv.tv_sec + tv.tv_usec;
+#else
+	return 1000 * GetTickCount ();	// accurate enough.
+#endif
+}
+
+//----------------------------------------------------------------------------
+// Name:	calculate_result
+// Purpose:	Calculates and prints a result.
+// Returns:	10 times the number of megabytes per second.
+//----------------------------------------------------------------------------
+int
+calculate_result (unsigned long chunk_size, long long total_count, long diff)
+{
+	if (!diff)
+		error ("Zero time difference.");
+
+// printf ("\nIn calculate_result, chunk_size=%ld, total_count=%lld, diff=%ld\n", chunk_size, total_count, diff);
+	long double result = (long double) chunk_size;
+	result *= (long double) total_count;
+	result *= 1000000.;
+	result /= 1048576.;
+	result /= (long double) diff;
+
+	print_result (result);
+
+	return (long) (10.0 * result);
+}
+
+//============================================================================
+// Tests.
+//============================================================================
+
+//----------------------------------------------------------------------------
+// Name:	do_write
+// Purpose:	Performs write on chunk of memory of specified size.
+//----------------------------------------------------------------------------
+enum {
+	NO_SSE2,
+	SSE2,
+	SSE2_BYPASS,
+};
+
+static void *do_thread_write(void *arg)
+{
+	struct thread_params *params = (struct thread_params *)arg;
+	unsigned long total_count = 0;
+#if defined(__x86_64__) || defined(__aarch64__)
+	unsigned long value = 0x1234567689abcdef;
+#else
+	unsigned long value = 0x12345678;
+#endif
+	cpu_set_t mask;
+
+	CPU_ZERO(&mask);
+	CPU_SET(params->id % cpu_num, &mask);
+
+	if (pthread_setaffinity_np(pthread_self(), sizeof(mask), &mask) < 0)
+		fprintf(stderr, "set thread %d affinity failed\n", params->id);
+
+	while(goon_flag) {
+		total_count += params->loops;
+
+		if (params->random)
+			RandomWriter (params->chunk_ptrs, params->size/256, params->loops, value);
+		else
+			Writer (params->chunk, params->size, params->loops, value);
+	}
+
+	params->loops = total_count;
+
+	 pthread_exit(NULL);
+
+         return NULL;
+}
+
+
+int
+do_write (unsigned long size, int mode, bool random)
+{
+	unsigned char *chunk;
+	unsigned char *chunk0;
+	unsigned long loops;
+	unsigned long long total_count=0;
+	unsigned long diff=0, t0;
+	unsigned long tmp;
+	unsigned long **chunk_ptrs = NULL;
+	struct thread_params *params;
+	pthread_t *tid;
+	int i, rval;
+
+	if (size & 255)
+		error ("do_write(): chunk size is not multiple of 256.");
+
+	params = malloc(sizeof(struct thread_params) * thread_num);
+	if (!params)
+		error ("Out of memory");
+
+	tid = malloc(sizeof(pthread_t) * thread_num);
+	if (!tid)
+		error ("Out of memory");
+
+	//-------------------------------------------------
+	chunk0 = malloc (size+32);
+	chunk = chunk0;
+	if (!chunk)
+		error ("Out of memory");
+
+	tmp = (unsigned long) chunk;
+	if (tmp & 15) {
+		tmp -= (tmp & 15);
+		tmp += 16;
+		chunk = (unsigned char*) tmp;
+	}
+
+	//----------------------------------------
+	// Set up random pointers to chunks.
+	//
+	if (random) {
+		tmp = size/256;
+		chunk_ptrs = (unsigned long**) malloc (sizeof (unsigned long*) * tmp);
+		if (!chunk_ptrs)
+			error ("Out of memory.");
+
+		//----------------------------------------
+		// Store pointers to all chunks into array.
+		//
+		int i;
+		for (i = 0; i < tmp; i++) {
+			chunk_ptrs [i] = (unsigned long*) (chunk + 256 * i);
+		}
+
+		//----------------------------------------
+		// Randomize the array of chunk pointers.
+		//
+		int k = 100;
+		while (k--) {
+			for (i = 0; i < tmp; i++) {
+				int j = rand() % tmp;
+				if (i != j) {
+					unsigned long *ptr = chunk_ptrs [i];
+					chunk_ptrs [i] = chunk_ptrs [j];
+					chunk_ptrs [j] = ptr;
+				}
+			}
+		}
+	}
+
+	//-------------------------------------------------
+	if (random)
+		print (L"Random write ");
+	else
+		print (L"Sequential write ");
+
+	if (mode == SSE2) {
+		print (L"(128-bit), size = ");
+	}
+	else
+	if (mode == SSE2_BYPASS) {
+		print (L"bypassing cache (128-bit), size = ");
+	} else {
+#if defined(__x86_64__) || defined(__aarch64__)
+		print (L"(64-bit), size = ");
+#else
+		print (L"(32-bit), size = ");
+#endif
+	}
+
+	print_size (size);
+	print (L", ");
+
+	loops = (1 << 26) / size;// XX need to adjust for CPU MHz
+
+	tmp = size / thread_num;
+
+	for (i = 0; i < thread_num; i++) {
+		params[i].id = i;
+		params[i].random = random;
+		params[i].size = tmp < 1024 ? size : tmp;
+		if (random)
+			params[i].chunk_ptrs = tmp < 1024 ? chunk_ptrs : chunk_ptrs + i * (tmp / 256);
+		else
+			params[i].chunk = tmp < 1024 ? chunk : chunk + i * tmp;
+		params[i].loops = loops;
+	}
+
+	t0 = mytime ();
+
+	goon_flag = 1;
+
+	for (i = 0; i < thread_num; i++) {
+		rval = pthread_create(&tid[i] ,NULL, do_thread_write, &params[i]);
+		if (rval < 0) {
+			perror("can't create pthread\n");
+			return rval;
+		}
+	}
+
+	usleep(usec_per_test);
+
+	goon_flag = 0;
+
+	for (i = 0; i < thread_num; i++) {
+		pthread_join(tid[i], NULL);
+		total_count += params[i].loops;
+	}
+
+	diff = mytime () - t0;
+
+	total_count /= thread_num;
+
+	print (L"loops = ");
+	print_int (total_count);
+	print (L", ");
+
+	flush ();
+
+	int result = calculate_result (size, total_count, diff);
+	newline ();
+
+	flush ();
+
+	free ((void*)chunk0);
+
+	if (chunk_ptrs)
+		free (chunk_ptrs);
+
+	return result;
+}
+
+static void *do_thread_read(void *arg)
+{
+	struct thread_params *params = (struct thread_params *)arg;
+	unsigned long total_count = 0;
+	cpu_set_t mask;
+
+	CPU_ZERO(&mask);
+	CPU_SET(params->id % cpu_num, &mask);
+
+	if (pthread_setaffinity_np(pthread_self(), sizeof(mask), &mask) < 0)
+		fprintf(stderr, "set thread %d affinity failed\n", params->id);
+
+	while(goon_flag) {
+		total_count += params->loops;
+
+		if (params->random)
+			RandomReader (params->chunk_ptrs, params->size/256, params->loops);
+		else
+			Reader (params->chunk, params->size, params->loops);
+	}
+
+	params->loops = total_count;
+
+	 pthread_exit(NULL);
+
+         return NULL;
+}
+
+//----------------------------------------------------------------------------
+// Name:	do_read
+// Purpose:	Performs sequential read on chunk of memory of specified size.
+//----------------------------------------------------------------------------
+int
+do_read (unsigned long size, bool use_sse2, bool random)
+{
+	unsigned long diff=0;
+	unsigned long long total_count = 0;
+	unsigned char *chunk;
+	unsigned char *chunk0;
+	unsigned long tmp;
+	unsigned long **chunk_ptrs = NULL;
+	unsigned long t0, loops = (1 << 26) / size;	// XX need to adjust for CPU MHz
+	struct thread_params *params;
+	pthread_t *tid;
+	int i, rval;
+
+	if (size & 255)
+		error ("do_read(): chunk size is not multiple of 256.");
+
+	params = malloc(sizeof(struct thread_params) * thread_num);
+	if (!params)
+		error ("Out of memory");
+
+	tid = malloc(sizeof(pthread_t) * thread_num);
+	if (!tid)
+		error ("Out of memory");
+
+	//-------------------------------------------------
+	if (random)
+		print (L"Random read ");
+	else
+		print (L"Sequential read ");
+
+	if (use_sse2) {
+		print (L"(128-bit), size = ");
+	} else {
+#if defined(__x86_64__) || defined(__aarch64__)
+		print (L"(64-bit), size = ");
+#else
+		print (L"(32-bit), size = ");
+#endif
+	}
+
+	print_size (size);
+	print (L", ");
+
+	flush ();
+
+	//-------------------------------------------------
+	chunk0 = chunk = malloc (size+32);
+	if (!chunk)
+		error ("Out of memory");
+
+	memset (chunk, 0, size);
+
+	tmp = (unsigned long) chunk;
+	if (tmp & 15) {
+		tmp -= (tmp & 15);
+		tmp += 16;
+		chunk = (unsigned char*) tmp;
+	}
+
+	//----------------------------------------
+	// Set up random pointers to chunks.
+	//
+	if (random) {
+		int tmp = size/256;
+		chunk_ptrs = (unsigned long**) malloc (sizeof (unsigned long*) * tmp);
+		if (!chunk_ptrs)
+			error ("Out of memory.");
+
+		//----------------------------------------
+		// Store pointers to all chunks into array.
+		//
+		int i;
+		for (i = 0; i < tmp; i++) {
+			chunk_ptrs [i] = (unsigned long*) (chunk + 256 * i);
+		}
+
+		//----------------------------------------
+		// Randomize the array of chunk pointers.
+		//
+		int k = 100;
+		while (k--) {
+			for (i = 0; i < tmp; i++) {
+				int j = rand() % tmp;
+				if (i != j) {
+					unsigned long *ptr = chunk_ptrs [i];
+					chunk_ptrs [i] = chunk_ptrs [j];
+					chunk_ptrs [j] = ptr;
+				}
+			}
+		}
+	}
+
+	tmp = size / thread_num;
+
+	for (i = 0; i < thread_num; i++) {
+		params[i].id = i;
+		params[i].random = random;
+		params[i].size = tmp < 1024 ? size : tmp;
+		if (random)
+			params[i].chunk_ptrs = tmp < 1024 ? chunk_ptrs : chunk_ptrs + i * (tmp / 256);
+		else
+			params[i].chunk = tmp < 1024 ? chunk : chunk + i * tmp;
+		params[i].loops = loops;
+	}
+
+	t0 = mytime ();
+
+	goon_flag = 1;
+
+	for (i = 0; i < thread_num; i++) {
+		rval = pthread_create(&tid[i] ,NULL, do_thread_read, &params[i]);
+		if (rval < 0) {
+			perror("can't create pthread\n");
+			return rval;
+		}
+	}
+
+	usleep(usec_per_test);
+
+	goon_flag = 0;
+
+	for (i = 0; i < thread_num; i++) {
+		pthread_join(tid[i], NULL);
+		total_count += params[i].loops;
+	}
+
+	diff = mytime () - t0;
+
+	total_count /= thread_num;
+
+	print (L"loops = ");
+	print_int (total_count);
+	print (L", ");
+
+	int result = calculate_result (size, total_count, diff);
+	newline ();
+
+	flush ();
+
+	free (chunk0);
+
+	if (chunk_ptrs)
+		free (chunk_ptrs);
+
+	free(params);
+	free(tid);
+
+	return result;
+}
+
+
+
+//----------------------------------------------------------------------------
+// Name:	do_copy
+// Purpose:	Performs sequential memory copy.
+//----------------------------------------------------------------------------
+int
+do_copy (unsigned long size, int mode)
+{
+	unsigned long loops;
+	unsigned long long total_count = 0;
+	unsigned long t0, diff=0;
+	unsigned char *chunk_src;
+	unsigned char *chunk_dest;
+	unsigned char *chunk_src0;
+	unsigned char *chunk_dest0;
+	unsigned long tmp;
+
+	if (size & 255)
+		error ("do_copy(): chunk size is not multiple of 256.");
+
+	//-------------------------------------------------
+	chunk_src0 = chunk_src = malloc (size+32);
+	if (!chunk_src)
+		error ("Out of memory");
+	chunk_dest0 = chunk_dest = malloc (size+32);
+	if (!chunk_dest)
+		error ("Out of memory");
+
+	memset (chunk_src, 100, size);
+	memset (chunk_dest, 200, size);
+
+	tmp = (unsigned long) chunk_src;
+	if (tmp & 15) {
+		tmp -= (tmp & 15);
+		tmp += 16;
+		chunk_src = (unsigned char*) tmp;
+	}
+	tmp = (unsigned long) chunk_dest;
+	if (tmp & 15) {
+		tmp -= (tmp & 15);
+		tmp += 16;
+		chunk_dest = (unsigned char*) tmp;
+	}
+
+	//-------------------------------------------------
+	print (L"Sequential copy ");
+
+	if (mode == SSE2) {
+		print (L"(128-bit), size = ");
+	}
+	else {
+#if defined(__x86_64__) || defined(__aarch64__)
+		print (L"(64-bit), size = ");
+#else
+		print (L"(32-bit), size = ");
+#endif
+	}
+
+	print_size (size);
+	print (L", ");
+
+	flush ();
+
+	loops = (1 << 26) / size;	// XX need to adjust for CPU MHz
+
+	t0 = mytime ();
+
+	while (diff < usec_per_test) {
+		total_count += loops;
+
+#if !defined(__arm__) && !defined(__aarch64__)
+		if (mode == SSE2)
+			CopySSE (chunk_dest, chunk_src, size, loops);
+#if 0
+		else
+			Copy (chunk_dest, chunk_src, size, loops);
+#endif
+#endif
+
+		diff = mytime () - t0;
+	}
+
+	print (L"loops = ");
+	print_int (total_count);
+	print (L", ");
+
+	int result = calculate_result (size, total_count, diff);
+	newline ();
+
+	flush ();
+
+	free (chunk_src0);
+	free (chunk_dest0);
+
+	return result;
+}
+
+
+//----------------------------------------------------------------------------
+// Name:	fb_readwrite
+// Purpose:	Performs sequential read & write tests on framebuffer memory.
+//----------------------------------------------------------------------------
+#if defined(__linux__) && defined(FBIOGET_FSCREENINFO)
+void
+fb_readwrite (bool use_sse2)
+{
+	//unsigned long counter, total_count;
+  unsigned long total_count;
+	unsigned long length;
+	unsigned long diff, t0;
+	static struct fb_fix_screeninfo fi;
+	static struct fb_var_screeninfo vi;
+	unsigned long *fb = NULL;
+	//unsigned long datum;
+	int fd;
+	//register unsigned long foo;
+#if defined(__x86_64__) || defined(__aarch64__)
+	unsigned long value = 0x1234567689abcdef;
+#else
+	unsigned long value = 0x12345678;
+#endif
+
+	//-------------------------------------------------
+
+	fd = open ("/dev/fb0", O_RDWR);
+	if (fd < 0)
+		fd = open ("/dev/fb/0", O_RDWR);
+	if (fd < 0) {
+		println (L"Cannot open framebuffer device.");
+		return;
+	}
+
+	if (ioctl (fd, FBIOGET_FSCREENINFO, &fi)) {
+		close (fd);
+		println (L"Cannot get framebuffer info");
+		return;
+	}
+	else
+	if (ioctl (fd, FBIOGET_VSCREENINFO, &vi)) {
+		close (fd);
+		println (L"Cannot get framebuffer info");
+		return;
+	}
+	else
+	{
+		if (fi.visual != FB_VISUAL_TRUECOLOR &&
+		    fi.visual != FB_VISUAL_DIRECTCOLOR ) {
+			close (fd);
+			println (L"Need direct/truecolor framebuffer device.");
+			return;
+		} else {
+			unsigned long fblen;
+
+			print (L"Framebuffer resolution: ");
+			print_int (vi.xres);
+			print (L"x");
+			print_int (vi.yres);
+			print (L", ");
+			print_int (vi.bits_per_pixel);
+			println (L" bpp\n");
+
+			fb = (unsigned long*) fi.smem_start;
+			fblen = fi.smem_len;
+
+			fb = mmap (fb, fblen,
+				PROT_WRITE | PROT_READ,
+				MAP_SHARED, fd, 0);
+			if (fb == MAP_FAILED) {
+				close (fd);
+				println (L"Cannot access framebuffer memory.");
+				return;
+			}
+		}
+	}
+
+	//-------------------
+	// Use only the upper half of the display.
+	//
+	length = FB_SIZE;
+
+	//-------------------
+	// READ
+	//
+	print (L"Framebuffer memory sequential read ");
+	flush ();
+
+	t0 = mytime ();
+
+	total_count = FBLOOPS_R;
+
+#if !defined(__arm__) && !defined(__aarch64__)
+	if (use_sse2)
+		ReaderSSE2 (fb, length, FBLOOPS_R);
+	else
+#endif
+		Reader (fb, length, FBLOOPS_R);
+
+	diff = mytime () - t0;
+
+	calculate_result (length, total_count, diff);
+	newline ();
+
+	//-------------------
+	// WRITE
+	//
+	print (L"Framebuffer memory sequential write ");
+	flush ();
+
+	t0 = mytime ();
+
+	total_count = FBLOOPS_W;
+
+#if !defined(__arm__) && !defined(__aarch64__)
+	if (use_sse2)
+		WriterSSE2_bypass (fb, length, FBLOOPS_W, value);
+	else
+#endif
+		Writer (fb, length, FBLOOPS_W, value);
+
+	diff = mytime () - t0;
+
+	calculate_result (length, total_count, diff);
+	newline ();
+}
+#endif
+
+//----------------------------------------------------------------------------
+// Name:	register_test
+// Purpose:	Determines bandwidth of register-to-register transfers.
+//----------------------------------------------------------------------------
+void
+register_test ()
+{
+	long long total_count = 0;
+	unsigned long t0;
+	unsigned long diff = 0;
+
+	//--------------------------------------
+#if defined(__x86_64__) || defined(__aarch64__)
+	print (L"Main register to main register transfers (64-bit) ");
+#else
+	print (L"Main register to main register transfers (32-bit) ");
+#endif
+	flush ();
+#define REGISTER_COUNT 10000
+
+	t0 = mytime ();
+	while (diff < usec_per_test)
+	{
+		RegisterToRegister (REGISTER_COUNT);
+		total_count += REGISTER_COUNT;
+
+		diff = mytime () - t0;
+	}
+
+	calculate_result (256, total_count, diff);
+	newline ();
+	flush ();
+
+#if !defined(__arm__) && !defined(__aarch64__)
+	//--------------------------------------
+#ifdef __x86_64__
+	print (L"Main register to vector register transfers (64-bit) ");
+#else
+	print (L"Main register to vector register transfers (32-bit) ");
+#endif
+	flush ();
+#define VREGISTER_COUNT 3333
+
+	t0 = mytime ();
+	diff = 0;
+	total_count = 0;
+	while (diff < usec_per_test)
+	{
+		RegisterToVector (VREGISTER_COUNT);
+		total_count += VREGISTER_COUNT;
+
+		diff = mytime () - t0;
+	}
+
+	calculate_result (256, total_count, diff);
+	newline ();
+	flush ();
+
+	//--------------------------------------
+#ifdef __x86_64__
+	print (L"Vector register to main register transfers (64-bit) ");
+#else
+	print (L"Vector register to main register transfers (32-bit) ");
+#endif
+	flush ();
+
+	t0 = mytime ();
+	diff = 0;
+	total_count = 0;
+	while (diff < usec_per_test)
+	{
+		VectorToRegister (VREGISTER_COUNT);
+		total_count += VREGISTER_COUNT;
+
+		diff = mytime () - t0;
+	}
+
+	calculate_result (256, total_count, diff);
+	newline ();
+	flush ();
+
+	//--------------------------------------
+	print (L"Vector register to vector register transfers (128-bit) ");
+	flush ();
+
+	t0 = mytime ();
+	diff = 0;
+	total_count = 0;
+	while (diff < usec_per_test)
+	{
+		VectorToVector (VREGISTER_COUNT);
+		total_count += VREGISTER_COUNT;
+
+		diff = mytime () - t0;
+	}
+
+	calculate_result (256, total_count, diff);
+	newline ();
+	flush ();
+
+	//--------------------------------------
+	if (use_sse4) {
+		print (L"Vector 8-bit datum to main register transfers ");
+		flush ();
+
+		t0 = mytime ();
+		diff = 0;
+		total_count = 0;
+		while (diff < usec_per_test)
+		{
+			Vector8ToRegister (VREGISTER_COUNT);
+			total_count += VREGISTER_COUNT;
+
+			diff = mytime () - t0;
+		}
+
+		calculate_result (256, total_count, diff);
+		newline ();
+		flush ();
+	}
+
+	//--------------------------------------
+	print (L"Vector 16-bit datum to main register transfers ");
+	flush ();
+
+	t0 = mytime ();
+	diff = 0;
+	total_count = 0;
+	while (diff < usec_per_test)
+	{
+		Vector16ToRegister (VREGISTER_COUNT);
+		total_count += VREGISTER_COUNT;
+
+		diff = mytime () - t0;
+	}
+
+	calculate_result (256, total_count, diff);
+	newline ();
+	flush ();
+
+	//--------------------------------------
+	if (use_sse4) {
+		print (L"Vector 32-bit datum to main register transfers ");
+		flush ();
+
+		t0 = mytime ();
+		diff = 0;
+		total_count = 0;
+		while (diff < usec_per_test)
+		{
+			Vector32ToRegister (VREGISTER_COUNT);
+			total_count += VREGISTER_COUNT;
+
+			diff = mytime () - t0;
+		}
+
+		calculate_result (256, total_count, diff);
+		newline ();
+		flush ();
+	}
+
+#ifdef __x86_64__
+	//--------------------------------------
+	print (L"Vector 64-bit datum to main register transfers ");
+	flush ();
+
+	t0 = mytime ();
+	diff = 0;
+	total_count = 0;
+	while (diff < usec_per_test)
+	{
+		Vector64ToRegister (VREGISTER_COUNT);
+		total_count += VREGISTER_COUNT;
+
+		diff = mytime () - t0;
+	}
+
+	calculate_result (256, total_count, diff);
+	newline ();
+	flush ();
+#endif
+
+	//--------------------------------------
+	if (use_sse4) {
+		print (L"Main register 8-bit datum to vector register transfers ");
+		flush ();
+
+		t0 = mytime ();
+		diff = 0;
+		total_count = 0;
+		while (diff < usec_per_test)
+		{
+			Register8ToVector (VREGISTER_COUNT);
+			total_count += VREGISTER_COUNT;
+
+			diff = mytime () - t0;
+		}
+
+		calculate_result (256, total_count, diff);
+		newline ();
+		flush ();
+	}
+
+	//--------------------------------------
+	print (L"Main register 16-bit datum to vector register transfers ");
+	flush ();
+
+	t0 = mytime ();
+	diff = 0;
+	total_count = 0;
+	while (diff < usec_per_test)
+	{
+		Register16ToVector (VREGISTER_COUNT);
+		total_count += VREGISTER_COUNT;
+
+		diff = mytime () - t0;
+	}
+
+	calculate_result (256, total_count, diff);
+	newline ();
+	flush ();
+
+	//--------------------------------------
+	if (use_sse4) {
+		print (L"Main register 32-bit datum to vector register transfers ");
+		flush ();
+
+		t0 = mytime ();
+		diff = 0;
+		total_count = 0;
+		while (diff < usec_per_test)
+		{
+			Register32ToVector (VREGISTER_COUNT);
+			total_count += VREGISTER_COUNT;
+
+			diff = mytime () - t0;
+		}
+
+		calculate_result (256, total_count, diff);
+		newline ();
+		flush ();
+	}
+
+#ifdef __x86_64__
+	//--------------------------------------
+	print (L"Main register 64-bit datum to vector register transfers ");
+	flush ();
+
+	t0 = mytime ();
+	diff = 0;
+	total_count = 0;
+	while (diff < usec_per_test)
+	{
+		Register64ToVector (VREGISTER_COUNT);
+		total_count += VREGISTER_COUNT;
+
+		diff = mytime () - t0;
+	}
+
+	calculate_result (256, total_count, diff);
+	newline ();
+	flush ();
+#endif
+#endif
+}
+
+//----------------------------------------------------------------------------
+// Name:	stack_test
+// Purpose:	Determines bandwidth of stack-to/from-register transfers.
+//----------------------------------------------------------------------------
+void
+stack_test ()
+{
+	long long total_count = 0;
+	unsigned long t0;
+	unsigned long diff = 0;
+
+#if defined(__x86_64__) || defined(__aarch64__)
+	print (L"Stack-to-register transfers (64-bit) ");
+#else
+	print (L"Stack-to-register transfers (32-bit) ");
+#endif
+	flush ();
+
+	//--------------------------------------
+	diff = 0;
+	total_count = 0;
+	t0 = mytime ();
+	while (diff < usec_per_test)
+	{
+		StackReader (REGISTER_COUNT);
+		total_count += REGISTER_COUNT;
+
+		diff = mytime () - t0;
+	}
+
+	calculate_result (256, total_count, diff);
+	newline ();
+	flush ();
+
+#if defined(__x86_64__) || defined(__aarch64__)
+	print (L"Register-to-stack transfers (64-bit) ");
+#else
+	print (L"Register-to-stack transfers (32-bit) ");
+#endif
+	flush ();
+
+	//--------------------------------------
+	diff = 0;
+	total_count = 0;
+	t0 = mytime ();
+	while (diff < usec_per_test)
+	{
+		StackWriter (REGISTER_COUNT);
+		total_count += REGISTER_COUNT;
+
+		diff = mytime () - t0;
+	}
+
+	calculate_result (256, total_count, diff);
+	newline ();
+	flush ();
+}
+
+//----------------------------------------------------------------------------
+// Name:	library_test
+// Purpose:	Performs C library tests (memset, memcpy).
+//----------------------------------------------------------------------------
+void
+library_test ()
+{
+	char *a1, *a2;
+	unsigned long t, t0;
+	int i;
+
+
+#if defined(__WIN32__) && (defined(__arm__) || defined(__aarch64__))
+	#define NT_SIZE (1024*1024)
+	#define NT_SIZE2 (50)
+#elif !defined(__WIN32__) && (defined(__arm__) || defined(__aarch64__))
+#if defined(DRAM_SIZE_SMALL)
+	#define NT_SIZE (16*1024*1024)
+#else
+	#define NT_SIZE (32*1024*1024)
+#endif
+	#define NT_SIZE2 (50)
+#else
+	#define NT_SIZE (64*1024*1024)
+	#define NT_SIZE2 (100)
+#endif
+
+	a1 = malloc (NT_SIZE);
+	if (!a1)
+		error ("Out of memory");
+
+	a2 = malloc (NT_SIZE);
+	if (!a2)
+		error ("Out of memory");
+
+	//--------------------------------------
+	t0 = mytime ();
+	for (i=0; i<NT_SIZE2; i++) {
+		memset (a1, i, NT_SIZE);
+	}
+	t = mytime ();
+
+	print (L"Library: memset ");
+	calculate_result (NT_SIZE, NT_SIZE2, t-t0);
+	newline ();
+
+	flush ();
+
+	//--------------------------------------
+	t0 = mytime ();
+	for (i=0; i<NT_SIZE2; i++) {
+		memcpy (a2, a1, NT_SIZE);
+	}
+	t = mytime ();
+
+	print (L"Library: memcpy ");
+	calculate_result (NT_SIZE, NT_SIZE2, t-t0);
+	newline ();
+
+	flush ();
+
+	free (a1);
+	free (a2);
+}
+
+//----------------------------------------------------------------------------
+// Name:	network_test_core
+// Purpose:	Performs the network test, talking to and receiving data
+//		back from a transponder node.
+// Note:	Port number specified using server:# notation.
+// Returns:	-1 on error, else the network duration in microseconds.
+//----------------------------------------------------------------------------
+long
+network_test_core (const char *net_path, char *chunk,
+			unsigned long chunk_size,
+			unsigned long count)
+{
+	char hostname [PATH_MAX];
+	char *s;
+	int port = NETWORK_DEFAULT_PORTNUM ;
+	strcpy (hostname, net_path);
+	if ((s = strchr (hostname, ':'))) {
+		*s++ = 0;
+		port = atoi (s);
+	}
+
+	struct hostent* host = gethostbyname (hostname);
+	if (!host)
+		return -1;
+
+	char *host_ip = inet_ntoa (*(struct in_addr *)*host->h_addr_list);
+	int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+
+	struct sockaddr_in addr;
+	addr.sin_family = AF_INET;
+	addr.sin_addr.s_addr = inet_addr(host_ip);
+	addr.sin_port = htons(port);
+
+	if (connect (sock, (struct sockaddr*) &addr, sizeof (struct sockaddr)))
+	{
+		// perror ("connect");
+		close (sock);
+		return -1;
+	}
+
+	//------------------------------------
+	// Send all of our data.
+	//
+	unsigned long t0 = mytime ();
+	int i;
+	for (i = 0; i < count; i++)
+		send (sock, chunk, chunk_size, 0);
+
+#if 0
+	//------------------------------------
+	// Set nonblocking mode.
+	//
+	int opt = 1;
+	ioctl (sock, FIONBIO, &opt);
+#endif
+
+	//------------------------------------
+	// Read the response.
+	//
+	char *buffer = malloc (chunk_size);
+	if (!buffer) {
+		close (sock);
+		// perror ("malloc");
+		return -1;
+	}
+	int amount = recv (sock, buffer, chunk_size, 0);
+	if (amount <= 0) {
+		close (sock);
+		//perror ("recv");
+		return -1;
+	}
+
+	long t = mytime () - t0;
+	close (sock);
+	free (buffer);
+	return t;
+}
+
+//----------------------------------------------------------------------------
+// Name:	ip_to_str
+//----------------------------------------------------------------------------
+void
+ip_to_str (unsigned long addr, char *str)
+{
+	if (!str)
+		return;
+
+	unsigned short a = 0xff & addr;
+	unsigned short b = 0xff & (addr >> 8);
+	unsigned short c = 0xff & (addr >> 16);
+	unsigned short d = 0xff & (addr >> 24);
+	sprintf (str, "%u.%u.%u.%u", a,b,c,d);
+}
+
+//----------------------------------------------------------------------------
+// Name:	network_transponder
+// Purpose:	Act as a transponder, receiving chunks of data and sending
+//		back an acknowledgement once the enture chunk is read.
+// Returns:	False if a problem occurs setting up the network socket.
+//----------------------------------------------------------------------------
+bool
+network_transponder ()
+{
+	struct sockaddr_in sin, from;
+
+	//------------------------------
+	// Get listening socket for port.
+	// Then listen on given port#.
+	//
+	sin.sin_family = AF_INET;
+	sin.sin_addr.s_addr = htonl(INADDR_ANY);
+	sin.sin_port = htons(NETWORK_DEFAULT_PORTNUM);
+	int listensock;
+	if ((listensock = socket (AF_INET, SOCK_STREAM, 0)) < 0)  {
+		perror ("socket");
+		return false;
+	}
+	if (bind (listensock, (struct sockaddr*) &sin, sizeof(sin)) < 0) {
+		perror ("bind");
+		close (listensock);
+		return false;
+	}
+	if (listen (listensock, 500) < 0) {
+		perror ("listen");
+		close (listensock);
+		return false;
+	}
+
+	bool done = false;
+	while (!done) {
+		//----------------------------------------
+		// Wait for a client to contact us.
+		//
+		socklen_t len = sizeof (struct sockaddr);
+		int sock = accept (listensock, (struct sockaddr*) &from, &len);
+		if (sock < 0) {
+			perror ("accept");
+			close (listensock);
+			return false;
+		}
+
+		if (len != sizeof (struct sockaddr_in)) {
+			close (sock);
+			close (listensock);
+			return false;
+		}
+
+#if 0
+		unsigned long ipaddr = from.sin_addr.s_addr;
+		char ipstring[30];
+		ip_to_str (ipaddr, ipstring);
+		fprintf (stderr, "Incoming connection from %s\n", ipstring);
+#endif
+
+		char chunk [NETWORK_CHUNK_SIZE+1];
+		long n_chunks = 0;
+		int amount_read = read (sock, chunk, NETWORK_CHUNK_SIZE);
+		chunk [amount_read] = 0;
+		if (1 != sscanf (chunk, "%ld", &n_chunks)) {
+			close (sock);
+			close (listensock);
+			return false;
+		}
+
+		//----------------------------------------
+		// If the leader sends us a chunk count of
+		// -99, this indicates that we should exit.
+		//
+		if (n_chunks == -99) {
+			close (sock);
+			close (listensock);
+			return true;
+		}
+
+//		printf ("Reading %lu chunks of %d bytes...\n", n_chunks, NETWORK_CHUNK_SIZE);
+
+		unsigned long long remaining = n_chunks;
+		remaining *= NETWORK_CHUNK_SIZE;
+
+//		printf ("remaining="); dump_hex64(remaining); puts("");
+
+		remaining -= amount_read;
+		while (remaining > 0) {
+			amount_read = read (sock, chunk, NETWORK_CHUNK_SIZE);
+			remaining -= amount_read;
+
+			if (amount_read < 0) {
+				perror ("read");
+				break;
+			} else
+			if (!amount_read)
+				break;
+		}
+
+		char *foo = "OK.\n\n";
+		write (sock, foo, 4);
+		close (sock);
+	}
+
+	return true;
+}
+
+//----------------------------------------------------------------------------
+// Name:	network_test
+//----------------------------------------------------------------------------
+bool
+network_test (char **destinations, int n_destinations)
+{
+	int i;
+
+	//----------------------------------------
+	// The memory chunk starts with a 12-byte
+	// length of the overall send size.
+	// The memory chunk will have a list of
+	// the destinations in it.
+	// In future, there will be a mechanism
+	// for testing bandwidth between all nodes,
+	// not just the leader & each of the
+	// transponders.
+	//
+	char chunk [NETWORK_CHUNK_SIZE];
+	memset (chunk, 0, NETWORK_CHUNK_SIZE);
+	sprintf (chunk, "000000000000\n%d\n", n_destinations);
+	for (i = 0; i < n_destinations; i++) {
+		char *s = destinations [i];
+		int chunk_len = strlen (chunk);
+		int len = strlen (s);
+		if (len + chunk_len < NETWORK_CHUNK_SIZE-1) {
+			//----------------------------------------
+			// "transp" indicates that the given node
+			// has not yet been a leader.
+			// In future, "done" will indicate it has.
+			//
+			sprintf (chunk + chunk_len, "%s %s\n", s, "transp");
+		}
+	}
+
+	//----------------------------------------
+	// For each destination, run the test.
+	//
+	for (i = 0; i < n_destinations; i++) {
+		int j = 0;
+		bool problem = false;
+
+		char *hostname = destinations[i];
+		printf ("Bandwidth sending to %s:\n", hostname);
+
+		//----------------------------------------
+		// Send from 8kB up to 32 MB of data.
+		//
+		while (!problem && j < 13) {
+			unsigned long chunk_count = 1 << j;
+			unsigned long long amt_to_send = chunk_count;
+			amt_to_send *= NETWORK_CHUNK_SIZE;
+
+			if (!amt_to_send) // unlikely
+				break;
+
+			//----------------------------------------
+			// Write the overall send size into the
+			// 1st line of the chunk so that the
+			// transponder knows how large the send
+			// is without guessing.
+			//
+			sprintf (chunk, "%11lu", chunk_count);
+			chunk[11] = ' ';
+
+			//--------------------
+			// Send the data.
+			//
+			long duration = network_test_core (hostname,
+				chunk, NETWORK_CHUNK_SIZE, chunk_count);
+			if (duration == -1) {
+				problem = true;
+				fprintf (stderr, "\nCan't connect to %s\n", hostname);
+			} else {
+				unsigned long amt_in_kb = amt_to_send / 1024;
+				unsigned long amt_in_mb = amt_to_send / 1048576;
+				if (!amt_in_mb) {
+					printf ("\tSent %lu kB...", amt_in_kb);
+				} else {
+					printf ("\tSent %lu MB...", amt_in_mb);
+				}
+
+				//------------------------------
+				// Calculate rate in MB/sec.
+				//
+				// Get total # bytes.
+				unsigned long long tmp = NETWORK_CHUNK_SIZE;
+				tmp *= chunk_count;
+
+				// Get total bytes per second.
+				tmp *= 1000000;
+				tmp /= duration;
+
+				// Bytes to megabytes.
+				tmp /= 1000;
+				tmp /= 10;
+				unsigned long whole = tmp / 100;
+				unsigned long frac = tmp % 100;
+				printf ("%lu.%02lu MB/second\n", whole, frac);
+			}
+			j++;
+		}
+
+		puts ("");
+	}
+
+	return true;
+}
+
+//----------------------------------------------------------------------------
+// Name:	usage
+//----------------------------------------------------------------------------
+void
+usage ()
+{
+	printf ("Usage for memory tests: bandwidth [--quick] [--thread N] [--chunk-size N]\n");
+	printf ("Usage for starting network tests: bandwidth --network <ipaddr1> [<ipaddr2...]\n");
+	printf ("Usage for receiving network tests: bandwidth --transponder\n");
+	exit (0);
+}
+
+//----------------------------------------------------------------------------
+// Name:	main
+//----------------------------------------------------------------------------
+int
+main (int argc, char **argv)
+{
+	int i, j, chunk_size;
+
+	--argc;
+	++argv;
+
+	strcpy (graph_title, TITLE);
+
+	bool network_mode = false;
+	bool network_leader = false; // false => transponder
+	int network_destinations_size = 0;
+	int n_network_destinations = 0;
+	char **network_destinations = NULL;
+
+	i = 0;
+	while (i < argc) {
+		char *s = argv [i++];
+		if (!strcmp ("--network", s)) {
+			network_mode = true;
+			network_leader = true;
+			network_destinations_size = 20;
+			network_destinations = (char**) malloc (network_destinations_size * sizeof (char*));
+		}
+		else
+		if (!strcmp ("--transponder", s)) {
+			network_mode = true;
+		}
+		else
+		if (!strcmp ("--slow", s)) {
+			usec_per_test=20000000;	// 20 seconds per test.
+		}
+		else
+		if (!strcmp ("--quick", s)) {
+			usec_per_test = 250000;	// 0.25 seconds per test.
+		}
+		else
+		if (!strcmp ("--nosse2", s)) {
+			use_sse2 = false;
+			use_sse4 = false;
+		}
+		else
+		if (!strcmp ("--nosse4", s)) {
+			use_sse4 = false;
+		}
+		else
+		if (!strcmp ("--help", s)) {
+			usage ();
+		}
+		else
+		if (!strcmp ("--title", s) && i != argc) {
+			sprintf (graph_title, "%s -- %s", TITLE, argv[i++]);
+		}
+		else
+		if (!strcmp ("--thread", s)) {
+			int n = 0;
+			thread_num = atoi(argv[i++]);
+			for (j = 0; j < 32; j++)
+				n += (thread_num >> j) & 0x1;
+			if (n > 1)
+				error("thread_num must be power of 2\n");
+		}
+		else
+		if (!strcmp ("--chunk-size", s)) {
+			chunk_size = strtoul(argv[i++], NULL, 0);
+			for (j = 0; j < sizeof(chunk_sizes) / sizeof(chunk_sizes[0]); j++) {
+				if (chunk_size <= chunk_sizes[j])
+					break;
+			}
+			chunk_index = j;
+		}
+		else {
+			if (!network_mode || !network_leader)
+				usage ();
+
+			if ('-' == *s)
+				usage ();
+
+			if (n_network_destinations >= network_destinations_size) {
+				network_destinations_size *= 2;
+				int newsize = sizeof(char*) * network_destinations_size;
+				network_destinations = realloc (network_destinations,
+					newsize);
+			}
+
+			network_destinations [n_network_destinations++] = strdup (s);
+		}
+	}
+
+	msg[0] = 0;
+
+#if !(defined(__WIN32__) && (defined(__arm__) || defined(__aarch64__)))
+	printf ("This is bandwidth version %s.\n", VERSION);
+	printf ("Copyright (C) 2005-2010 by Zack T Smith.\n\n");
+	printf ("This software is covered by the GNU Public License.\n");
+	printf ("It is provided AS-IS, use at your own risk.\n");
+	printf ("See the file COPYING for more information.\n\n");
+	fflush (stdout);
+#else
+	println (L"(C) 2010 by Zack Smith");
+	println (L"Under GNU Public License");
+	println (L"Use at your own risk.");
+#endif
+
+	//----------------------------------------
+	// If network mode selected, enter it now.
+	// Currently cannot combine memory tests
+	// & network tests.
+	//
+	if (network_mode) {
+		if (network_leader) {
+			network_test (network_destinations, n_network_destinations);
+		} else {
+			network_transponder ();
+		}
+
+		puts ("Done.");
+		return 0;
+	}
+
+#if !defined(__arm__) && !defined(__aarch64__)
+	if (!has_sse2 ()) {
+		puts ("Processor does not have SSE2.");
+		use_sse2 = false;
+		use_sse4 = false;
+	}
+
+#ifdef __x86_64__
+	if (use_sse2)
+		println (L"Using 128-bit and 64-bit data transfers.");
+	else
+		println (L"Using 64-bit data transfers.");
+#else
+	if (use_sse2)
+		println (L"Using 128-bit and 32-bit data transfers.");
+	else
+		println (L"Using 32-bit data transfers.");
+#endif
+
+#else
+
+#if defined(__aarch64__)
+	println (L"Using 64-bit transfers.");
+#else
+	println (L"Using 32-bit transfers.");
+#endif
+
+	use_sse2 = false;
+#endif
+
+	println (L"Notation: kB = 1024 B, MB = 1048576 B.");
+
+	flush ();
+
+	//------------------------------------------------------------
+	// Attempt to obtain information about the CPU.
+	//
+#ifdef __linux__
+	struct stat st;
+	if (!stat ("/proc/cpuinfo", &st)) {
+#define TMPFILE "/tmp/bandw_tmp"
+		unlink (TMPFILE);
+		if (-1 == system ("grep MHz /proc/cpuinfo | uniq | sed \"s/[\\t\\n: a-zA-Z]//g\" > "TMPFILE))
+			perror ("system");
+
+		FILE *f = fopen (TMPFILE, "r");
+		if (f) {
+			float cpu_speed = 0.0;
+
+			if (1 == fscanf (f, "%g", &cpu_speed)) {
+				puts ("");
+				printf ("CPU speed is %g MHz.\n", cpu_speed);
+			}
+			fclose (f);
+		}
+
+#if !defined(__arm__) && !defined(__aarch64__)
+		unlink (TMPFILE);
+		if (-1 == system ("grep -i sse4 /proc/cpuinfo > "TMPFILE))
+			perror ("system");
+
+		if (!stat (TMPFILE, &st)) {
+			if (st.st_size < 2) {
+				use_sse4 = false;
+				puts ("Processor lacks SSE4.");
+			}
+		}
+
+		if (!use_sse2) {
+			unlink (TMPFILE);
+			if (-1 == system ("grep -i sse2 /proc/cpuinfo > "TMPFILE))
+				perror ("system");
+
+			if (!stat (TMPFILE, &st)) {
+				if (st.st_size < 2) {
+					use_sse2 = false;
+					puts ("Processor lacks SSE2.");
+				}
+			}
+		}
+#endif
+	} else {
+		printf ("CPU information is not available (/proc/cpuinfo).\n");
+	}
+
+	cpu_num = sysconf(_SC_NPROCESSORS_CONF);
+	printf("System has %d processor(s)\n", cpu_num);
+
+	fflush (stdout);
+#endif
+
+	graph = BMP_new (graph_width, graph_height);
+	graph_init ();
+
+#if !defined(__arm__) && !defined(__aarch64__)
+	//------------------------------------------------------------
+	// SSE2 sequential reads.
+	//
+	if (use_sse2) {
+		graph_new_line ("Sequential 128-bit reads", RGB_RED);
+
+		newline ();
+
+		i = chunk_index;
+		while ((chunk_size = chunk_sizes [i++])) {
+			int amount = do_read (chunk_size, true, false);
+
+			graph_add_point (chunk_size, amount);
+		}
+	}
+
+	//------------------------------------------------------------
+	// SSE2 random reads.
+	//
+	if (use_sse2) {
+		graph_new_line ("Random 128-bit reads", RGB_MAROON);
+
+		newline ();
+		srand (time (NULL));
+
+		i = chunk_index;
+		while ((chunk_size = chunk_sizes [i++])) {
+			int amount = do_read (chunk_size, true, true);
+
+			graph_add_point (chunk_size, amount);
+		}
+	}
+
+	//------------------------------------------------------------
+	// SSE2 sequential writes that do not bypass the caches.
+	//
+	if (use_sse2) {
+		graph_new_line ("Sequential 128-bit cache writes", RGB_PURPLE);
+
+		newline ();
+
+		i = chunk_index;
+		while ((chunk_size = chunk_sizes [i++])) {
+			int amount = do_write (chunk_size, SSE2, false);
+
+			graph_add_point (chunk_size, amount);
+		}
+	}
+
+	//------------------------------------------------------------
+	// SSE2 random writes that do not bypass the caches.
+	//
+	if (use_sse2) {
+		graph_new_line ("Random 128-bit cache writes", RGB_NAVYBLUE);
+
+		newline ();
+		srand (time (NULL));
+
+		i = chunk_index;
+		while ((chunk_size = chunk_sizes [i++])) {
+			int amount = do_write (chunk_size, SSE2, true);
+
+			graph_add_point (chunk_size, amount);
+		}
+	}
+
+	//------------------------------------------------------------
+	// SSE2 sequential writes that do bypass the caches.
+	//
+	if (use_sse2) {
+		graph_new_line ("Sequential 128-bit bypassing writes", RGB_DARKORANGE);
+
+		newline ();
+
+		i = chunk_index;
+		while ((chunk_size = chunk_sizes [i++])) {
+			int amount = do_write (chunk_size, SSE2_BYPASS, false);
+
+			graph_add_point (chunk_size, amount);
+		}
+	}
+
+	//------------------------------------------------------------
+	// SSE2 random writes that bypass the caches.
+	//
+	if (use_sse2) {
+		graph_new_line ("Random 128-bit bypassing writes", RGB_LEMONYELLOW);
+
+		newline ();
+		srand (time (NULL));
+
+		i = chunk_index;
+		while ((chunk_size = chunk_sizes [i++])) {
+			int amount = do_write (chunk_size, SSE2_BYPASS, true);
+
+			graph_add_point (chunk_size, amount);
+		}
+	}
+#endif
+
+	//------------------------------------------------------------
+	// Sequential non-SSE2 reads.
+	//
+	newline ();
+#if defined(__x86_64__) || defined(__aarch64__)
+	graph_new_line ("Sequential 64-bit reads", RGB_BLUE);
+#else
+	graph_new_line ("Sequential 32-bit reads", RGB_BLUE);
+#endif
+
+	i = chunk_index;
+	while ((chunk_size = chunk_sizes [i++])) {
+		int amount = do_read (chunk_size, false, false);
+
+		graph_add_point (chunk_size, amount);
+	}
+
+	//------------------------------------------------------------
+	// Random non-SSE2 reads.
+	//
+	newline ();
+#if defined(__x86_64__) || defined(__aarch64__)
+	graph_new_line ("Random 64-bit reads", RGB_CYAN);
+#else
+	graph_new_line ("Random 32-bit reads", RGB_CYAN);
+#endif
+	srand (time (NULL));
+
+	i = chunk_index;
+	while ((chunk_size = chunk_sizes [i++])) {
+		int amount = do_read (chunk_size, false, true);
+
+		graph_add_point (chunk_size, amount);
+	}
+
+	//------------------------------------------------------------
+	// Sequential non-SSE2 writes.
+	//
+#if defined(__x86_64__) || defined(__aarch64__)
+	graph_new_line ("Sequential 64-bit writes", RGB_DARKGREEN);
+#else
+	graph_new_line ("Sequential 32-bit writes", RGB_DARKGREEN);
+#endif
+
+	newline ();
+
+	i = chunk_index;
+	while ((chunk_size = chunk_sizes [i++])) {
+		int amount = do_write (chunk_size, NO_SSE2, false);
+
+		graph_add_point (chunk_size, amount);
+	}
+
+	//------------------------------------------------------------
+	// Random non-SSE2 writes.
+	//
+#if defined(__x86_64__) || defined(__aarch64__)
+	graph_new_line ("Random 64-bit writes", RGB_GREEN);
+#else
+	graph_new_line ("Random 32-bit writes", RGB_GREEN);
+#endif
+
+	newline ();
+	srand (time (NULL));
+
+	i = chunk_index;
+	while ((chunk_size = chunk_sizes [i++])) {
+		int amount = do_write (chunk_size, NO_SSE2, true);
+
+		graph_add_point (chunk_size, amount);
+	}
+
+#if !defined(__arm__) && !defined(__aarch64__)
+	//------------------------------------------------------------
+	// SSE2 sequential copy.
+	//
+	if (use_sse2) {
+		graph_new_line ("Sequential 128-bit copy", 0x8f8844);
+
+		newline ();
+
+		i = 0;
+		while ((chunk_size = chunk_sizes [i++])) {
+			int amount = do_copy (chunk_size, SSE2);
+
+			graph_add_point (chunk_size, amount);
+		}
+	}
+#endif
+
+	//------------------------------------------------------------
+	// Register to register.
+	//
+	newline ();
+	register_test ();
+
+	//------------------------------------------------------------
+	// Stack to/from register.
+	//
+	newline ();
+	stack_test ();
+
+	//------------------------------------------------------------
+	// C library performance.
+	//
+	newline ();
+	library_test ();
+
+	//------------------------------------------------------------
+	// Framebuffer read & write.
+	//
+#if defined(__linux__) && defined(FBIOGET_FSCREENINFO)
+	newline ();
+	fb_readwrite (true);
+#endif
+
+#if defined(__WIN32__) && (defined(__arm__) || defined(__aarch64__))
+	MessageBoxW (0, msg, APPNAME, 0);
+
+	FILE *of = fopen ("bandwidth.log", "w");
+	if (of) {
+		dump (of);
+		fclose (of);
+	}
+#else
+	flush ();
+#endif
+
+	graph_make ();
+
+	BMP_write (graph, "bandwidth.bmp");
+	BMP_delete (graph);
+#if defined(__linux__) || defined(__CYGWIN__) || defined(__APPLE__)
+	puts ("\nWrote graph to bandwidth.bmp.");
+	puts ("");
+	puts ("Done.");
+#endif
+
+	return 0;
+}
diff --git a/benchmark/bandwidth/make.inc b/benchmark/bandwidth/make.inc
index ddf9d17..e8eccab 100644
--- a/benchmark/bandwidth/make.inc
+++ b/benchmark/bandwidth/make.inc
@@ -19,8 +19,37 @@ LOCAL_PATH	:= $(call my-dir)
 include $(CLEAR_VARS)
 
 LOCAL_TARGET	:= bandwidth-arm
-LOCAL_SRCS	:= $(LOCAL_PATH)/routinesARM.S $(LOCAL_PATH)/main.c $(LOCAL_PATH)/BMP.c
+ifeq ($(CPU_ARCH), arm64)
+LOCAL_SRCS	:= $(LOCAL_PATH)/routinesARM64.S
+else
+LOCAL_SRCS	:= $(LOCAL_PATH)/routinesARM.S
+endif
+LOCAL_SRCS	+= $(LOCAL_PATH)/main.c $(LOCAL_PATH)/BMP.c
+LOCAL_CFLAGS	:= -O3
+
+include $(BUILD_APP)
+
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(UNIT_TEST_PATH)/
+	@cp -dpRf $< $(UNIT_TEST_PATH)/
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+
+###
+include $(CLEAR_VARS)
+
+LOCAL_TARGET	:= bandwidth-arm-thread
+ifeq ($(CPU_ARCH), arm64)
+LOCAL_SRCS	:= $(LOCAL_PATH)/routinesARM64.S
+else
+LOCAL_SRCS	:= $(LOCAL_PATH)/routinesARM.S
+endif
+LOCAL_SRCS	+= $(LOCAL_PATH)/main_thread.c $(LOCAL_PATH)/BMP.c
 LOCAL_CFLAGS	:= -O3
+LOCAL_LDFLAGS	:= -lpthread
 
 include $(BUILD_APP)
 
diff --git a/benchmark/bandwidth/routinesARM64.S b/benchmark/bandwidth/routinesARM64.S
new file mode 100644
index 0000000..fa1f8b7
--- /dev/null
+++ b/benchmark/bandwidth/routinesARM64.S
@@ -0,0 +1,483 @@
+
+# ============================================================================
+#  bandwidth 0.23, a benchmark to estimate memory transfer bandwidth.
+#  ARM assembly module.
+#  Copyright (C) 2010 by Zack T Smith.
+#
+#  This program is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License as published by
+#  the Free Software Foundation; either version 2 of the License, or
+#  (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#  GNU General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with this program; if not, write to the Free Software
+#  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+#  The author may be reached at fbui@comcast.net.
+# =============================================================================
+
+#--------------
+# Version 0.7
+#--------------
+
+#include "config.h"
+
+.arch armv8-a
+
+#ifdef __thumb2__
+.syntax unified
+.code 16
+#endif
+
+.section code
+
+.text
+.align 2
+
+.global Writer
+.global RandomWriter
+
+.global Reader
+.global RandomReader
+
+.global	RegisterToRegister
+.global	StackReader
+.global	StackWriter
+
+#-----------------------------------------------------------------------------
+# Name: 	Writer
+# Purpose:	Performs sequential write into memory, as fast as possible.
+# Params:
+#	x0 = address
+#	x1 = length, multiple of 256
+#	x2 = loop
+# 	x3 = value to write
+#-----------------------------------------------------------------------------
+Writer:
+	stp	x29, x30, [sp, #-16]!
+
+	bic	x1, x1, #0x7f
+	mov	x4, x0
+	mov	x5, x1
+
+	mov	x6, x3
+
+# x4 = temp address
+# x5 = temp length
+
+.L0:
+	mov	x0, x4
+	mov	x1, x5
+
+.L1:
+	stp x3, x6, [x0]
+	stp x3, x6, [x0, #16]
+	stp x3, x6, [x0, #32]
+	stp x3, x6, [x0, #48]
+	stp x3, x6, [x0, #64]
+	stp x3, x6, [x0, #80]
+	stp x3, x6, [x0, #96]
+	stp x3, x6, [x0, #112]
+	stp x3, x6, [x0, #128]
+	stp x3, x6, [x0, #144]
+	stp x3, x6, [x0, #160]
+	stp x3, x6, [x0, #176]
+	stp x3, x6, [x0, #192]
+	stp x3, x6, [x0, #208]
+	stp x3, x6, [x0, #224]
+	stp x3, x6, [x0, #240]
+	add x0, x0, #256
+
+	sub	x1, x1, #256
+	cbnz	x1, .L1
+
+	sub	x2, x2, #1
+	cbnz	x2, .L0
+
+# return.
+	ldp x29, x30, [sp], #16
+	ret
+
+#-----------------------------------------------------------------------------
+# Name: 	Reader
+# Purpose:	Performs sequential reads from memory, as fast as possible.
+# Params:
+#	x0 = address
+#	x1 = length, multiple of 256
+#	x2 = loop
+#-----------------------------------------------------------------------------
+Reader:
+	stp	x29, x30, [sp, #-16]!
+	stp	x20, x21, [sp, #-16]!
+	stp	x18, x19, [sp, #-16]!
+	stp	x16, x17, [sp, #-16]!
+	stp	x14, x15, [sp, #-16]!
+	stp	x12, x13, [sp, #-16]!
+	stp	x10, x11, [sp, #-16]!
+	stp	x8, x9, [sp, #-16]!
+
+	bic	x1, x1, #0x7f
+	mov	x4, x0
+	mov	x5, x1
+
+# x4 = temp address
+# x5 = temp length
+
+.L2:
+	mov	x0, x4
+	mov	x1, x5
+
+.L3:
+	ldp x3, x6, [x0]
+	ldp x7, x8, [x0, #16]
+	ldp x9, x10, [x0, #32]
+	ldp x11, x12, [x0, #48]
+	ldp x13, x14, [x0, #64]
+	ldp x15, x16, [x0, #80]
+	ldp x17, x18, [x0, #96]
+	ldp x19, x20, [x0, #112]
+	ldp x21, x6, [x0, #128]
+	ldp x7, x8, [x0, #144]
+	ldp x9, x10, [x0, #160]
+	ldp x11, x12, [x0, #176]
+	ldp x13, x14, [x0, #192]
+	ldp x15, x16, [x0, #208]
+	ldp x17, x18, [x0, #224]
+	ldp x19, x20, [x0, #240]
+	add x0, x0, #256
+
+	sub	x1, x1, #256
+	cbnz	x1, .L3
+
+	sub	x2, x2, #1
+	cbnz	x2, .L2
+
+# return.
+	ldp x8, x9, [sp], #16
+	ldp x10, x11, [sp], #16
+	ldp x12, x13, [sp], #16
+	ldp x14, x15, [sp], #16
+	ldp x16, x17, [sp], #16
+	ldp x18, x19, [sp], #16
+	ldp x20, x21, [sp], #16
+	ldp x29, x30, [sp], #16
+	ret
+
+#-----------------------------------------------------------------------------
+# Name: 	RandomWriter
+# Purpose:	Performs random write into memory, as fast as possible.
+# Params:
+# 	x0 = pointer to array of chunk pointers
+# 	x1 = # of 256-byte chunks
+# 	x2 = # loops to do
+# 	x3 = value to write
+#-----------------------------------------------------------------------------
+RandomWriter:
+	stp	x29, x30, [sp, #-16]!
+
+# x4 = temp
+# x5 = temp
+
+.L4:
+	mov	x5, #0
+
+.L5:
+# Get pointer to chunk in memory. Note, 64-bit pointers.
+	ldr	x4, [x0, x5, LSL #3]
+
+# Does 32 transfers, 8 bytes each = 256 bytes total.
+
+	str	x3, [x4, #160]
+	str	x3, [x4, #232]
+	str	x3, [x4, #224]
+	str	x3, [x4, #96]
+	str	x3, [x4, #168]
+	str	x3, [x4, #80]
+	str	x3, [x4, #104]
+	str	x3, [x4, #248]
+	str	x3, [x4, #8]
+	str	x3, [x4, #136]
+	str	x3, [x4, #112]
+	str	x3, [x4, #200]
+	str	x3, [x4, #128]
+	str	x3, [x4, #152]
+	str	x3, [x4, #216]
+	str	x3, [x4]
+	str	x3, [x4, #88]
+	str	x3, [x4, #144]
+	str	x3, [x4, #208]
+	str	x3, [x4, #184]
+	str	x3, [x4, #48]
+	str	x3, [x4, #64]
+	str	x3, [x4, #240]
+	str	x3, [x4, #24]
+	str	x3, [x4, #72]
+	str	x3, [x4, #32]
+	str	x3, [x4, #56]
+	str	x3, [x4, #16]
+	str	x3, [x4, #40]
+	str	x3, [x4, #176]
+	str	x3, [x4, #120]
+	str	x3, [x4, #192]
+
+	add	x5, x5, #1
+	cmp	x5, x1
+	bne	.L5
+
+	sub	x2, x2, #1
+	cbnz	x2, .L4
+
+# return.
+	ldp x29, x30, [sp], #16
+	ret
+
+#-----------------------------------------------------------------------------
+# Name: 	RandomReader
+# Purpose:	Performs random reads from memory, as fast as possible.
+# Params:
+# 	x0 = pointer to array of chunk pointers
+# 	x1 = # of 256-byte chunks
+# 	x2 = # loops to do
+#-----------------------------------------------------------------------------
+RandomReader:
+	stp	x29, x30, [sp, #-16]!
+
+# x4 = temp
+# x5 = temp
+
+.L6:
+	mov	x5, #0
+
+.L7:
+# Get pointer to chunk in memory. Note, 64-bit pointers.
+	ldr	x4, [x0, x5, LSL #3]
+
+# Does 32 transfers, 8 bytes each = 256 bytes total.
+
+	ldr	x3, [x4, #160]
+	ldr	x3, [x4, #232]
+	ldr	x3, [x4, #224]
+	ldr	x3, [x4, #96]
+	ldr	x3, [x4, #168]
+	ldr	x3, [x4, #80]
+	ldr	x3, [x4, #104]
+	ldr	x3, [x4, #248]
+	ldr	x3, [x4, #8]
+	ldr	x3, [x4, #136]
+	ldr	x3, [x4, #112]
+	ldr	x3, [x4, #200]
+	ldr	x3, [x4, #128]
+	ldr	x3, [x4, #152]
+	ldr	x3, [x4, #216]
+	ldr	x3, [x4]
+	ldr	x3, [x4, #88]
+	ldr	x3, [x4, #144]
+	ldr	x3, [x4, #208]
+	ldr	x3, [x4, #184]
+	ldr	x3, [x4, #48]
+	ldr	x3, [x4, #64]
+	ldr	x3, [x4, #240]
+	ldr	x3, [x4, #24]
+	ldr	x3, [x4, #72]
+	ldr	x3, [x4, #32]
+	ldr	x3, [x4, #56]
+	ldr	x3, [x4, #16]
+	ldr	x3, [x4, #40]
+	ldr	x3, [x4, #176]
+	ldr	x3, [x4, #120]
+	ldr	x3, [x4, #192]
+
+	add	x5, x5, #1
+	cmp	x5, x1
+	bne	.L7
+
+	sub	x2, x2, #1
+	cbnz	x2, .L6
+
+# return.
+	ldp x29, x30, [sp], #16
+	ret
+
+#-----------------------------------------------------------------------------
+# Name: 	RegisterToRegister
+# Purpose:	Performs register-to-register transfers.
+# Params:
+#	x0 = count
+#-----------------------------------------------------------------------------
+RegisterToRegister:
+	stp	x29, x30, [sp, #-16]!
+
+# x1 = temp
+
+.L8:
+# Does 32 transfers, 8 bytes each = 256 bytes total.
+
+	mov	x1, x2
+	mov	x1, x3
+	mov	x1, x4
+	mov	x1, x5
+	mov	x1, x6
+	mov	x1, x7
+	mov	x1, x8
+	mov	x1, x9
+
+	mov	x2, x1
+	mov	x2, x3
+	mov	x2, x4
+	mov	x2, x5
+	mov	x2, x6
+	mov	x2, x7
+	mov	x2, x8
+	mov	x2, x9
+
+	mov	x1, x2
+	mov	x1, x3
+	mov	x1, x4
+	mov	x1, x5
+	mov	x1, x6
+	mov	x1, x7
+	mov	x1, x8
+	mov	x1, x9
+
+	mov	x1, x2
+	mov	x1, x3
+	mov	x1, x4
+	mov	x1, x5
+	mov	x1, x6
+	mov	x1, x7
+	mov	x1, x8
+	mov	x1, x9
+
+
+	sub	x0, x0, #1
+	cbnz	x0, .L8
+
+# return.
+	ldp x29, x30, [sp], #16
+	ret
+
+#-----------------------------------------------------------------------------
+# Name: 	StackReader
+# Purpose:	Performs stack-to-register transfers.
+# Params:
+#	x0 = count
+#-----------------------------------------------------------------------------
+StackReader:
+	stp	x29, x30, [sp, #-16]!
+
+# x1 = temp
+
+	sub	sp, sp, #64
+.L9:
+# Does 32 transfers, 8 bytes each = 256 bytes total.
+
+	ldr	x1, [sp]
+	ldr	x1, [sp, #8]
+	ldr	x1, [sp, #16]
+	ldr	x1, [sp, #24]
+	ldr	x1, [sp, #32]
+	ldr	x1, [sp, #40]
+	ldr	x1, [sp, #48]
+	ldr	x1, [sp, #56]
+
+	ldr	x1, [sp]
+	ldr	x1, [sp, #8]
+	ldr	x1, [sp, #16]
+	ldr	x1, [sp, #24]
+	ldr	x1, [sp, #32]
+	ldr	x1, [sp, #40]
+	ldr	x1, [sp, #48]
+	ldr	x1, [sp, #56]
+
+	ldr	x1, [sp]
+	ldr	x1, [sp, #8]
+	ldr	x1, [sp, #16]
+	ldr	x1, [sp, #24]
+	ldr	x1, [sp, #32]
+	ldr	x1, [sp, #40]
+	ldr	x1, [sp, #48]
+	ldr	x1, [sp, #56]
+
+	ldr	x1, [sp]
+	ldr	x1, [sp, #8]
+	ldr	x1, [sp, #16]
+	ldr	x1, [sp, #24]
+	ldr	x1, [sp, #32]
+	ldr	x1, [sp, #40]
+	ldr	x1, [sp, #48]
+	ldr	x1, [sp, #56]
+
+	sub	x0, x0, #1
+	cbnz	x0, .L9
+
+	add	sp, sp, #64
+
+# return.
+	ldp x29, x30, [sp], #16
+	ret
+
+#-----------------------------------------------------------------------------
+# Name: 	StackWriter
+# Purpose:	Performs register-to-stack transfers.
+# Params:
+#	x0 = count
+#-----------------------------------------------------------------------------
+StackWriter:
+	stp	x29, x30, [sp, #-16]!
+
+# x1 = temp
+
+	sub	sp, sp, #64
+.L10:
+# Does 32 transfers, 8 bytes each = 256 bytes total.
+
+	str	x1, [sp]
+	str	x1, [sp, #8]
+	str	x1, [sp, #16]
+	str	x1, [sp, #24]
+	str	x1, [sp, #32]
+	str	x1, [sp, #40]
+	str	x1, [sp, #48]
+	str	x1, [sp, #56]
+
+	str	x1, [sp]
+	str	x1, [sp, #8]
+	str	x1, [sp, #16]
+	str	x1, [sp, #24]
+	str	x1, [sp, #32]
+	str	x1, [sp, #40]
+	str	x1, [sp, #48]
+	str	x1, [sp, #56]
+
+	str	x1, [sp]
+	str	x1, [sp, #8]
+	str	x1, [sp, #16]
+	str	x1, [sp, #24]
+	str	x1, [sp, #32]
+	str	x1, [sp, #40]
+	str	x1, [sp, #48]
+	str	x1, [sp, #56]
+
+	str	x1, [sp]
+	str	x1, [sp, #8]
+	str	x1, [sp, #16]
+	str	x1, [sp, #24]
+	str	x1, [sp, #32]
+	str	x1, [sp, #40]
+	str	x1, [sp, #48]
+	str	x1, [sp, #56]
+
+	sub	x0, x0, #1
+	cbnz	x0, .L10
+
+	add	sp, sp, #64
+
+# return.
+	ldp x29, x30, [sp], #16
+	ret
+
diff --git a/benchmark/mem_test/make.inc b/benchmark/mem_test/make.inc
index 8edaf6f..5777762 100644
--- a/benchmark/mem_test/make.inc
+++ b/benchmark/mem_test/make.inc
@@ -22,6 +22,7 @@ LOCAL_TARGET	:= test_mem
 LOCAL_SRCS	:= $(LOCAL_PATH)/test_mem.c
 LOCAL_CFLAGS  := -I$(PREBUILD_3RD_PARTY_DIR)/openssl/include
 LOCAL_LDFLAGS := -L$(PREBUILD_3RD_PARTY_DIR)/openssl/usr/lib -lcrypto -ldl
+LOCAL_LDFLAGS += -L$(PREBUILD_3RD_PARTY_DIR)/zlib/usr/lib -lz
 
 include $(BUILD_APP)
 
diff --git a/benchmark/nbench/emfloat.c b/benchmark/nbench/emfloat.c
index 5e73890..2f940b3 100644
--- a/benchmark/nbench/emfloat.c
+++ b/benchmark/nbench/emfloat.c
@@ -646,104 +646,102 @@ case NORMAL_NORMAL:
                 z->sign = locx.sign;
                 z->exp= locx.exp;
         }
-        else
-                if (exponent_difference > 0)
-                {
-                        /*
-                        ** locx.exp > locy.exp
-                        */
-                        StickyShiftRightMant(&locy,
-                                 exponent_difference);
-                        z->type = locx.type;
-                        z->sign = locx.sign;
-                        z->exp = locx.exp;
-                }
-                else    /* if (exponent_difference < 0) */
-                {
-                        /*
-                        ** locx.exp < locy.exp
-                        */
-                        StickyShiftRightMant(&locx,
-                                -exponent_difference);
-                        z->type = locy.type;
-                        z->sign = locy.sign ^ operation;
-                        z->exp = locy.exp;
-                }
+        else if (exponent_difference > 0)
+        {
+                /*
+                ** locx.exp > locy.exp
+                */
+                StickyShiftRightMant(&locy,
+                         exponent_difference);
+                z->type = locx.type;
+                z->sign = locx.sign;
+                z->exp = locx.exp;
+        }
+        else    /* if (exponent_difference < 0) */
+        {
+                /*
+                ** locx.exp < locy.exp
+                */
+                StickyShiftRightMant(&locx,
+                        -exponent_difference);
+                z->type = locy.type;
+                z->sign = locy.sign ^ operation;
+                z->exp = locy.exp;
+        }
 
-                if (locx.sign ^ locy.sign ^ operation)
+        if (locx.sign ^ locy.sign ^ operation)
+        {
+                /*
+                ** Signs are different, subtract mantissas
+                */
+                borrow = 0;
+                for (i=(INTERNAL_FPF_PRECISION-1); i>=0; i--)
+                        Sub16Bits(&borrow,
+                                &z->mantissa[i],
+                                locx.mantissa[i],
+                                locy.mantissa[i]);
+
+                if (borrow)
                 {
-                        /*
-                        ** Signs are different, subtract mantissas
+                        /* The y->mantissa was larger than the
+                        ** x->mantissa leaving a negative
+                        ** result.  Change the result back to
+                        ** an unsigned number and flip the
+                        ** sign flag.
                         */
+                        z->sign = locy.sign ^ operation;
                         borrow = 0;
                         for (i=(INTERNAL_FPF_PRECISION-1); i>=0; i--)
+                        {
                                 Sub16Bits(&borrow,
                                         &z->mantissa[i],
-                                        locx.mantissa[i],
-                                        locy.mantissa[i]);
-
-                        if (borrow)
-                        {
-                                /* The y->mantissa was larger than the
-                                ** x->mantissa leaving a negative
-                                ** result.  Change the result back to
-                                ** an unsigned number and flip the
-                                ** sign flag.
-                                */
-                                z->sign = locy.sign ^ operation;
-                                borrow = 0;
-                                for (i=(INTERNAL_FPF_PRECISION-1); i>=0; i--)
-                                {
-                                        Sub16Bits(&borrow,
-                                                &z->mantissa[i],
-                                                0,
-                                                z->mantissa[i]);
-                                }
-                        }
-                        else
-                        {
-                                /* The assumption made above
-                                ** (i.e. x->mantissa >= y->mantissa)
-                                ** was correct.  Therefore, do nothing.
-                                ** z->sign = x->sign;
-                                */
+                                        0,
+                                        z->mantissa[i]);
                         }
-
-                        if (IsMantissaZero(z->mantissa))
-                        {
-                                z->type = IFPF_IS_ZERO;
-                                z->sign = 0; /* positive */
-                        }
-                        else
-                                if (locx.type == IFPF_IS_NORMAL ||
-                                         locy.type == IFPF_IS_NORMAL)
-                                {
-                                        normalize(z);
-                                }
                 }
                 else
                 {
-                        /* signs are the same, add mantissas */
-                        carry = 0;
-                        for (i=(INTERNAL_FPF_PRECISION-1); i>=0; i--)
-                        {
-                                Add16Bits(&carry,
-                                        &z->mantissa[i],
-                                        locx.mantissa[i],
-                                        locy.mantissa[i]);
-                        }
+                        /* The assumption made above
+                        ** (i.e. x->mantissa >= y->mantissa)
+                        ** was correct.  Therefore, do nothing.
+                        ** z->sign = x->sign;
+                        */
+                }
 
-                        if (carry)
-                        {
-                                z->exp++;
-                                carry=0;
-                                ShiftMantRight1(&carry,z->mantissa);
-                                z->mantissa[0] |= 0x8000;
+                if (IsMantissaZero(z->mantissa))
+                {
+                        z->type = IFPF_IS_ZERO;
+                        z->sign = 0; /* positive */
+                }
+                else if (locx.type == IFPF_IS_NORMAL ||
+                         locy.type == IFPF_IS_NORMAL)
+                {
+                        normalize(z);
+                }
+        }
+        else
+        {
+                /* signs are the same, add mantissas */
+                carry = 0;
+                for (i=(INTERNAL_FPF_PRECISION-1); i>=0; i--)
+                {
+                        Add16Bits(&carry,
+                                &z->mantissa[i],
+                                locx.mantissa[i],
+                                locy.mantissa[i]);
+                }
+
+                if (carry)
+                {
+                        z->exp++;
+                        carry=0;
+                        ShiftMantRight1(&carry,z->mantissa);
+                        z->mantissa[0] |= 0x8000;
+                        z->type = IFPF_IS_NORMAL;
+                }
+                else
+                        if (z->mantissa[0] & 0x8000)
                                 z->type = IFPF_IS_NORMAL;
-                        }
-                        else
-                                if (z->mantissa[0] & 0x8000)
-                                        z->type = IFPF_IS_NORMAL;
         }
         break;
 
diff --git a/benchmark/nbench/nbench1.c b/benchmark/nbench/nbench1.c
index 7923015..01c609a 100644
--- a/benchmark/nbench/nbench1.c
+++ b/benchmark/nbench/nbench1.c
@@ -3436,7 +3436,7 @@ int i;
 
 error = 0.0;
 sum = 0.0;
-for (i=0; i<numpats; i++)
+for (i=0; i<numpats && i<MAXPATS; i++)
 {
 	if (tot_out_error[i] > error) error = tot_out_error[i];
 	sum += avg_out_error[i];
@@ -3612,7 +3612,7 @@ worst_pass_error();     /* identify the worst error in this pass */
 printf("\n Iteration # %d",iteration_count);
 #endif
 */
-for (i=0; i<numpats; i++)
+for (i=0; i<numpats && i<MAXPATS; i++)
 {
 /*      printf("\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
 	  i+1,tot_out_error[i], avg_out_error[i]);
diff --git a/benchmark/sd_benchmark/make.inc b/benchmark/sd_benchmark/make.inc
new file mode 100644
index 0000000..b2e9590
--- /dev/null
+++ b/benchmark/sd_benchmark/make.inc
@@ -0,0 +1,36 @@
+##
+## unit_test/linux/benchmark/sd_benchmark/make.inc
+##
+## History:
+##    2016/01/19 - [Zhifeng Gong] Created file
+##
+## Copyright (C) 2011-2016, Ambarella, Inc.
+##
+## All rights reserved. No Part of this file may be reproduced, stored
+## in a retrieval system, or transmitted, in any form, or by any means,
+## electronic, mechanical, photocopying, recording, or otherwise,
+## without the prior consent of Ambarella, Inc.
+##
+ifeq ($(BUILD_AMBARELLA_UNIT_TESTS_SD_BENCHMARK), y)
+
+LOCAL_PATH	:= $(call my-dir)
+
+###
+include $(CLEAR_VARS)
+
+LOCAL_TARGET	:= sd_benchmark
+LOCAL_SRCS	:= $(LOCAL_PATH)/sd_benchmark.c
+LOCAL_CFLAGS	:=-O3 -Wall
+LOCAL_LDFLAGS	:= -lpthread
+
+include $(BUILD_APP)
+
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(UNIT_TEST_PATH)/
+	@cp -dpRf $< $(UNIT_TEST_PATH)/
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+endif
diff --git a/benchmark/sd_benchmark/sd_benchmark.c b/benchmark/sd_benchmark/sd_benchmark.c
new file mode 100644
index 0000000..6d08712
--- /dev/null
+++ b/benchmark/sd_benchmark/sd_benchmark.c
@@ -0,0 +1,1066 @@
+/*******************************************************************************
+ * sd_benchmark.c
+ *
+ * History:
+ *   Jan 19, 2016 - [zfgong] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents (Software) are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <signal.h>
+#include <string.h>
+#include <memory.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <getopt.h>
+#include <errno.h>
+#include <stdint.h>
+#include <sys/mman.h>
+#include <sys/time.h>
+#include <sys/stat.h>
+#include <pthread.h>
+
+#define	NO_ARG		0
+#define	HAS_ARG		1
+
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+#define CLASS2			(2)
+#define CLASS4			(4)
+#define CLASS6			(6)
+#define CLASS10			(10)
+
+//The empiric value is from QA test result,
+//SONY microSDHC I 16GB class 10 is 2.51MB/s
+#define TOLERANCE_RATIO		(0.25)
+
+#define VERSION 	"1.0.0"
+
+
+#define MAX_FD_NUM	(5)
+#define MAX_RETRY_CNT	(3)
+#define DFT_MOUNT_POINT	"/sdcard"
+static char mount_point[128];
+static int len_1MB = 1*1024*1024;
+static void *buf_1MB = NULL;
+
+static int mmcblk_id = 0;
+static int fixed_step_flag = 0;
+static float speed_inst = 0.0;
+static float speed_inst_min = 0.0;
+static float speed_inst_max = 0.0;
+
+static float speed_avg = 0.0;
+static float speed_avg_min = 0.0;
+static float speed_avg_max = 0.0;
+
+struct file_desc {
+	union {
+		int fd;
+		FILE *fp;
+	};
+};
+
+struct task_info_t {
+	struct file_desc *fd;
+	int total;
+	int wait;
+	char path[32];
+	pthread_cond_t cond;
+	pthread_mutex_t mutex;
+};
+
+struct hint_s {
+	const char *arg;
+	const char *str;
+};
+
+struct sdcard_desc {
+	char dev[32];
+	char desc[64];
+};
+
+struct sdcard_desc sdcard_info[] = {
+	{"name", ""},
+	{"cid", ""},
+	{"csd", ""},
+	{"scr", ""},
+	{"serial", ""},
+	{"manfid", ""},
+	{"oemid", ""},
+	{"date", ""},
+};
+
+typedef struct file_ops {
+	struct file_desc * (*open)(const char *path);
+	ssize_t (*write)(struct file_desc *fd, const void *buf, size_t count);
+	ssize_t (*read)(struct file_desc *fd, void *buf, size_t count);
+	off_t (*seek)(struct file_desc *fd, off_t offset, int whence);
+	int (*sync)(struct file_desc *fd);
+	void (*close)(struct file_desc *fd);
+} file_ops_t;
+
+
+static struct file_ops *file_handle = NULL;
+
+static int range_random(int min, int max)
+{
+	int val;
+	uint64_t tick;
+	struct timeval tv;
+	gettimeofday(&tv, NULL);
+	tick = (tv.tv_sec * 1000) + (tv.tv_usec / 1000);
+
+	srandom((unsigned int)tick);
+	if (min < max) {
+		val = random() % (max - min + 1) + min;
+	} else {
+		val = random() % (min - max + 1) + max;
+	}
+	return val;
+}
+
+static void get_sdcard_info()
+{
+	int i = 0;
+	int ret = 0;
+	int fd = 0;
+	char path[128];
+	char prefix[128];
+	snprintf(prefix, sizeof(prefix), "/sys/block/mmcblk%d/device", mmcblk_id);
+	printf("prefix = %s\n", prefix);
+	for (i = 0; i < ARRAY_SIZE(sdcard_info); i++) {
+		snprintf(path, sizeof(path), "%s/%s",
+				prefix, sdcard_info[i].dev);
+		fd = open(path, O_RDONLY, 0666);
+		if (fd == -1) {
+			printf("open %s failed:%d %s\n",
+					path, errno, strerror(errno));
+			break;
+		}
+		ret = read(fd, sdcard_info[i].desc,
+				sizeof(sdcard_info[i].desc));
+		if (ret == -1) {
+			printf("read failed:%d %s\n", errno, strerror(errno));
+			return;
+		}
+		close(fd);
+	}
+	printf("sdcard info:\n");
+	for (i = 0; i < ARRAY_SIZE(sdcard_info); i++) {
+		printf("%10s: %s", sdcard_info[i].dev, sdcard_info[i].desc);
+	}
+	printf("\n");
+}
+
+static float get_speed(struct timeval *pre, struct timeval *post, int bytes)
+{
+	float cost_sec = ((1000000 * (post->tv_sec - pre->tv_sec))
+			+ (post->tv_usec - pre->tv_usec)) / 1000000.0;
+	float mega_bytes = bytes / (1024 * 1024.0);
+	float speed = mega_bytes / cost_sec;
+	if (speed_inst_max == 0 || speed_inst_min == 0) {
+		speed_inst_min = speed;
+		speed_inst_max = speed;
+	} else {
+		if (speed_inst_max < speed) {
+			speed_inst_max = speed;
+		}
+		if (speed_inst_min > speed) {
+			speed_inst_min = speed;
+		}
+	}
+	return speed;
+}
+
+static void print_speed(struct timeval *pre, struct timeval *post,
+		int bytes, char *prefix)
+{
+	float cost_sec = ((1000000 * (post->tv_sec - pre->tv_sec))
+			+ (post->tv_usec - pre->tv_usec)) / 1000000.0;
+	float mega_bytes = bytes / (1024 * 1024.0);
+	speed_avg = mega_bytes / cost_sec;
+	if (speed_avg_max == 0 || speed_avg_min == 0) {
+		speed_avg_min = speed_avg;
+		speed_avg_max = speed_avg;
+	} else {
+		if (speed_avg_max < speed_avg) {
+			speed_avg_max = speed_avg;
+		}
+		if (speed_avg_min > speed_avg) {
+			speed_avg_min = speed_avg;
+		}
+	}
+	fprintf(stderr, "\r%8s\t %6.2fMB\t %6.2fs\t "
+			"%4.2fMB/s\t %4.2fMB/s\t %4.2fMB/s\t "
+			"%4.2fMB/s\t %4.2fMB/s\t %4.2fMB/s\t ",
+			prefix, mega_bytes, cost_sec,
+			speed_inst, speed_inst_min, speed_inst_max,
+			speed_avg, speed_avg_min, speed_avg_max);
+}
+
+static int invalidate_cache(int fd, off_t len)
+{
+	int ret = 0;
+	int page_size;
+	int offset = lseek(fd, 0, SEEK_CUR);
+	page_size = getpagesize();
+	offset = offset % page_size;
+	ret = posix_fadvise (fd, offset, len, POSIX_FADV_DONTNEED);
+	if (ret != 0) {
+		return -1;
+	}
+	return 0;
+}
+
+static struct file_desc *fio_open(const char *path)
+{
+	struct file_desc *file = (struct file_desc *)calloc(1,
+			sizeof(struct file_desc));
+	if (!file) {
+		printf("malloc failed:%d %s\n", errno, strerror(errno));
+		return NULL;
+	}
+	file->fp = fopen(path, "w");
+	if (!file->fp) {
+		printf("fopen %s failed:%d %s\n",
+				path, errno, strerror(errno));
+		free(file);
+		return NULL;
+	}
+	return file;
+}
+
+static ssize_t fio_read(struct file_desc *file, void *buf, size_t len)
+{
+	int n;
+	void *p = buf;
+	size_t left = len;
+	size_t step = 1024*1024;
+	int cnt = 0;
+	if (file == NULL || buf == NULL || len == 0) {
+		printf("%s paraments invalid!\n", __func__);
+		return -1;
+	}
+	FILE *fp = file->fp;
+	while (left > 0) {
+		if (left < step)
+			step = left;
+		n = fread(p, 1, step, fp);
+		if (n > 0) {
+			p += n;
+			left -= n;
+			continue;
+		} else {
+			if (0 == feof(fp)) {
+				break;
+			} else {
+				if (errno == EINTR || errno == EAGAIN) {
+					if (++cnt > MAX_RETRY_CNT)
+						break;
+					continue;
+				}
+			}
+		}
+	}
+	return (len - left);
+}
+
+static ssize_t fio_write(struct file_desc *file, const void *buf, size_t count)
+{
+	ssize_t ret = 0;
+	ssize_t written;
+	void *cursor = (void *)buf;
+	size_t step;
+	size_t remain = count;
+	int retry = 0;
+	struct timeval pre = {0, 0}, post = {0, 0};
+	FILE *fp = NULL;
+
+	do {
+		if (file == NULL || buf == NULL || count == 0) {
+			printf("%s paraments invalid, buf=%p, "
+#if __WORDSIZE == 64
+			       "count=%lu!\n",
+#else
+			       "count=%u!\n",
+#endif
+			       __func__, buf, count);
+			ret = -1;
+			break;
+		}
+		fp = file->fp;
+		gettimeofday(&pre, NULL);
+		while (remain > 0) {
+			if (fixed_step_flag) {
+				step = 1024 * 1024;
+			} else {
+				step = range_random(128*1024, 1024* 1024);
+			}
+			if (remain < step)
+				step = remain;
+			written = fwrite(cursor, 1, step, fp);
+			if (written > 0) {
+				cursor += written;
+				remain -= written;
+				gettimeofday(&post, NULL);
+				speed_inst = get_speed(&pre, &post,
+						count-remain);
+				if (fflush(fp) < 0) {
+					printf("fsync failed:%d %s\n",
+						errno, strerror(errno));
+
+				}
+				continue;
+			} else {
+				if (errno == EINTR || errno == EAGAIN) {
+					if (++retry > MAX_RETRY_CNT) {
+						printf("reach max retry\n");
+						break;
+					}
+					continue;
+				} else {
+					printf("write failed:%d %s\n",
+						errno, strerror(errno));
+					ret = -1;
+					break;
+				}
+			}
+		}
+		ret = count - remain;
+	} while (0);
+	return ret;
+}
+
+static off_t fio_seek(struct file_desc *file, off_t offset, int whence)
+{
+	if (file) {
+		return fseek(file->fp, offset, whence);
+	}
+	return -1;
+}
+
+static int fio_sync(struct file_desc *file)
+{
+	if (file) {
+		return fsync(file->fd);
+	}
+	return -1;
+}
+
+static void fio_close(struct file_desc *file)
+{
+	if (file) {
+		fclose(file->fp);
+		free(file);
+	}
+}
+
+static struct file_desc *io_open(const char *path)
+{
+	struct file_desc *file = (struct file_desc *)calloc(1,
+			sizeof(struct file_desc));
+	if (!file) {
+		printf("malloc failed:%d %s\n", errno, strerror(errno));
+		return NULL;
+	}
+	file->fd = open(path, O_CREAT | O_TRUNC | O_RDWR | O_SYNC, 0666);
+	if (file->fd == -1) {
+		printf("open %s failed:%d %s\n", path, errno, strerror(errno));
+		free(file);
+		return NULL;
+	}
+	return file;
+}
+
+static ssize_t io_read(struct file_desc *file, void *buf, size_t len)
+{
+	int n;
+	void *p = buf;
+	size_t left = len;
+	size_t step = 1024*1024;
+	int cnt = 0;
+	if (file == NULL || buf == NULL || len == 0) {
+		printf("%s paraments invalid!\n", __func__);
+		return -1;
+	}
+	int fd = file->fd;
+	while (left > 0) {
+		if (left < step)
+			step = left;
+		n = read(fd, p, step);
+		if (n > 0) {
+			p += n;
+			left -= n;
+			continue;
+		} else {
+			if (n == 0) {
+				break;
+			} else {
+				if (errno == EINTR || errno == EAGAIN) {
+					if (++cnt > MAX_RETRY_CNT)
+						break;
+					continue;
+				}
+			}
+		}
+	}
+	return (len - left);
+}
+
+static ssize_t io_write(struct file_desc *file, const void *buf, size_t count)
+{
+	ssize_t ret = 0;
+	ssize_t written;
+	void *cursor = (void *)buf;
+	size_t step;
+	size_t remain = count;
+	int retry = 0;
+	struct timeval pre = {0, 0}, post = {0, 0};
+	int fd = -1;
+
+	do {
+		if (file == NULL || buf == NULL || count == 0) {
+			printf("%s paraments invalid, fd=%d, buf=%p, "
+#if __WORDSIZE == 64
+				"count=%lu!\n",
+#else
+				"count=%u!\n",
+#endif
+			       __func__, fd, buf, count);
+			ret = -1;
+			break;
+		}
+		fd = file->fd;
+		ret = invalidate_cache(fd, count);
+		if (ret != 0) {
+			printf("invalidate_cache failed!\n");
+		}
+		gettimeofday(&pre, NULL);
+		while (remain > 0) {
+			if (fixed_step_flag) {
+				step = 1024 * 1024;
+			} else {
+				step = range_random(128*1024, 1024* 1024);
+			}
+			if (remain < step)
+				step = remain;
+			written = write(fd, cursor, step);
+			if (written > 0) {
+				cursor += written;
+				remain -= written;
+				gettimeofday(&post, NULL);
+				speed_inst = get_speed(&pre, &post,
+						count-remain);
+				if (fsync(fd) < 0) {
+					printf("fsync failed:%d %s\n",
+						errno, strerror(errno));
+
+				}
+				continue;
+			} else {
+				if (errno == EINTR || errno == EAGAIN) {
+					if (++retry > MAX_RETRY_CNT) {
+						printf("reach max retry\n");
+						break;
+					}
+					continue;
+				} else {
+					printf("write failed:%d %s\n",
+						errno, strerror(errno));
+					ret = -1;
+					break;
+				}
+			}
+		}
+		ret = count - remain;
+	} while (0);
+	return ret;
+}
+
+static off_t io_seek(struct file_desc *file, off_t offset, int whence)
+{
+	if (file) {
+		return lseek(file->fd, offset, whence);
+	}
+	return -1;
+}
+
+static int io_sync(struct file_desc *file)
+{
+	if (file) {
+		return fflush(file->fp);
+	}
+	return -1;
+}
+
+static void io_close(struct file_desc *file)
+{
+	if (file) {
+		close(file->fd);
+		free(file);
+	}
+}
+
+static struct file_ops fio_ops = {
+	.open  = fio_open,
+	.write = fio_write,
+	.read  = fio_read,
+	.seek  = fio_seek,
+	.sync  = fio_sync,
+	.close = fio_close,
+};
+
+static struct file_ops io_ops = {
+	.open  = io_open,
+	.write = io_write,
+	.read  = io_read,
+	.seek  = io_seek,
+	.sync  = io_sync,
+	.close = io_close,
+};
+
+static void *wait_task(void *arg)
+{
+	struct task_info_t *tp = (struct task_info_t *)arg;
+	pthread_mutex_lock(&tp->mutex);
+	pthread_cond_wait(&tp->cond, &tp->mutex);
+	pthread_mutex_unlock(&tp->mutex);
+	pthread_mutex_destroy(&tp->mutex);
+	pthread_cond_destroy(&tp->cond);
+	if (tp->fd) {
+		file_handle->close(tp->fd);
+		tp->fd = NULL;
+	}
+	return NULL;
+}
+
+static void *write_task(void *arg)
+{
+	struct task_info_t *tp = (struct task_info_t *)arg;
+	struct timeval pre = {0, 0}, post = {0, 0};
+	char prefix[32];
+
+	int i, ret = 0;
+	gettimeofday(&pre, NULL);
+	for (i = 0; i < tp->total/len_1MB; i++) {
+		ret = file_handle->write(tp->fd, buf_1MB, len_1MB);
+		if (ret < 0) {
+			printf("write fd[%d] failed!\n", i);
+			break;
+		}
+		gettimeofday(&post, NULL);
+		snprintf(prefix, sizeof(prefix), "%s", tp->path);
+		print_speed(&pre, &post, (i+1)*len_1MB, prefix);
+	}
+	pthread_mutex_lock(&tp->mutex);
+	pthread_cond_signal(&tp->cond);
+	pthread_mutex_unlock(&tp->mutex);
+
+	return NULL;
+}
+
+static int thread_write(int num, int total)
+{
+	pthread_t tid;
+	int i;
+	int ret = 0;
+	int wait = 0;
+	struct task_info_t *tp = NULL;
+	struct task_info_t *tlist = NULL;
+
+	if (num > MAX_FD_NUM) {
+		num = MAX_FD_NUM;
+	}
+	printf("thread_write num = %d, %d MB bytes:\n", num, total/len_1MB);
+	printf("%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\n",
+		"path", "written", "cost",
+		"*inst_speed", "inst_min", "inst_max",
+		"*avg_speed", "avg_min", "avg_max");
+	do {
+		tlist = (struct task_info_t *)calloc(num,
+				sizeof(struct task_info_t));
+		if (!tlist) {
+			printf("%s: malloc failed!\n", __func__);
+			ret = -1;
+			break;
+		}
+		for (i = 0; i < num; i++) {
+			tp = tlist+i;
+			snprintf(tp->path, sizeof(tp->path), "%s/%s%d",
+					mount_point, "tfile", i);
+			tp->fd = file_handle->open(tp->path);
+			if (!tp->fd) {
+				ret = -1;
+				continue;
+			}
+			tp->total = total;
+			pthread_mutex_init(&tp->mutex, NULL);
+			pthread_cond_init(&tp->cond, NULL);
+		}
+		for (i = 0; i < num; i++) {
+			tp = tlist+i;
+			if (!tp->fd) {
+				continue;
+			}
+			pthread_create(&tid, NULL, write_task, tp);
+			pthread_create(&tid, NULL, wait_task, tp);
+		}
+	} while (0);
+
+	if (tlist) {
+		while (1) {
+			for (i = 0; i < num; i++) {
+				tp = tlist+i;
+				if (tp->fd) {
+					tp->wait = 1;
+				} else {
+					tp->wait = 0;
+				}
+			}
+			for (i = 0, wait = 0; i < num; i++) {
+				tp = tlist+i;
+				wait += tp->wait;
+			}
+			if (!wait) {
+				break;
+			}
+			sleep(1);
+		}
+		free(tlist);
+	}
+	return ret;
+}
+
+static int infinite_write()
+{
+	int loop = 0;
+	int ret = 0;
+	int block, remain;
+	void *ptr;
+	char path[32];
+	struct timeval pre = {0, 0}, post = {0, 0};
+	struct file_desc *fd = NULL;
+	int total = 1*1024*1024*1024;
+	printf("infinite_write %d MB bytes:\n", total/len_1MB);
+	printf("%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\n",
+		"path", "written", "cost",
+		"*inst_speed", "inst_min", "inst_max",
+		"*avg_speed", "avg_min", "avg_max");
+	do {
+		snprintf(path, sizeof(path), "%s/%s", mount_point, "ifile");
+		fd = file_handle->open(path);
+		if (!fd) {
+			ret = -1;
+			break;
+		}
+		gettimeofday(&pre, NULL);
+		for (loop = 0; ; loop++) {
+			remain = total;
+			block = len_1MB;
+			ptr = buf_1MB;
+			while (remain > 0) {
+				if (remain < block) {
+					block = remain;
+				}
+				if (ptr - buf_1MB >= len_1MB) {
+					ptr = buf_1MB;
+				}
+				ret = file_handle->write(fd, ptr, block);
+				if (ret > 0) {
+					ptr += ret;
+					remain -= ret;
+					gettimeofday(&post, NULL);
+					print_speed(&pre, &post,
+						(total-remain)*(loop+1), path);
+				} else {
+					printf("write failed!\n");
+					break;
+				}
+			}
+			file_handle->seek(fd, 0, SEEK_SET);
+		}
+	} while (0);
+	if (fd) {
+		file_handle->close(fd);
+	}
+	return ret;
+}
+
+static int cross_write(int num, int total)
+{
+	int i, j;
+	int total_mb;
+	int ret = 0;
+	struct file_desc *fd[MAX_FD_NUM];
+	char path[MAX_FD_NUM][32];
+	char prefix[32];
+	struct timeval pre = {0, 0}, post = {0, 0};
+
+	printf("cross_write num = %d, %d MB bytes:\n", num, total/len_1MB);
+	printf("%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\n",
+		"path", "written", "cost",
+		"*inst_speed", "inst_min", "inst_max",
+		"*avg_speed", "avg_min", "avg_max");
+	if (num > MAX_FD_NUM) {
+		num = MAX_FD_NUM;
+	}
+	total_mb = total / len_1MB;
+	do {
+		for (i = 0; i < num; i++) {
+			snprintf(path[i], sizeof(path[i]), "%s/%s%d",
+					mount_point, "cfile", i);
+			fd[i] = file_handle->open(path[i]);
+			if (!fd[i]) {
+				ret = -1;
+				break;
+			}
+		}
+		gettimeofday(&pre, NULL);
+		for (j = 0; j < total_mb; j++) {
+			for (i = 0; i < num; i++) {
+				ret = file_handle->write(fd[i], buf_1MB,
+						len_1MB);
+				if (ret < 0) {
+					printf("write fd[%d] failed!\n", i);
+					break;
+				}
+				gettimeofday(&post, NULL);
+				snprintf(prefix, sizeof(prefix), "%s", path[i]);
+				print_speed(&pre, &post, ((j*num)+i+1)*len_1MB,
+						prefix);
+			}
+		}
+		printf("\n");
+	} while (0);
+
+	for (i = 0; i < num; i++) {
+		if (fd[i]) {
+			file_handle->close(fd[i]);
+		}
+	}
+	return ret;
+}
+
+static int single_write(int total)
+{
+	int ret = 0;
+	int block, remain;
+	void *ptr;
+	char path[32];
+	struct timeval pre = {0, 0}, post = {0, 0};
+	struct file_desc *fd = NULL;
+
+	printf("single_write %d MB bytes:\n", total/len_1MB);
+	printf("%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\n",
+		"path", "written", "cost",
+		"*inst_speed", "inst_min", "inst_max",
+		"*avg_speed", "avg_min", "avg_max");
+	do {
+		snprintf(path, sizeof(path), "%s/%s", mount_point, "sfile");
+		fd = file_handle->open(path);
+		if (!fd) {
+			ret = -1;
+			break;
+		}
+		remain = total;
+		block = len_1MB;
+		ptr = buf_1MB;
+		gettimeofday(&pre, NULL);
+		while (remain > 0) {
+			if (remain < block) {
+				block = remain;
+			}
+			if (ptr - buf_1MB >= len_1MB) {
+				ptr = buf_1MB;
+			}
+			ret = file_handle->write(fd, ptr, block);
+			if (ret > 0) {
+				ptr += ret;
+				remain -= ret;
+				gettimeofday(&post, NULL);
+				print_speed(&pre, &post, total-remain, path);
+			} else {
+				printf("write failed!\n");
+				break;
+			}
+		}
+		printf("\n");
+	} while (0);
+	if (fd) {
+		file_handle->close(fd);
+	}
+	return ret;
+}
+
+static int analysis(int target, float factor)
+{
+	int ratio = (int)(factor*100);
+	if (speed_avg < (float)(target * factor)) {
+		printf("average speed is %d%% slower than Class %d speed.\n",
+				ratio, target);
+		return -1;
+	}
+	printf("average speed reach %d%% Class %d speed.\n", ratio, target);
+	return 0;
+}
+
+static int init_buffer()
+{
+	int i = 0;
+	buf_1MB = calloc(1, len_1MB);
+	if (!buf_1MB) {
+		printf("calloc failed:%d %s\n", errno, strerror(errno));
+		return -1;
+	}
+	for (i = 0; i < len_1MB; i++) {
+		*((char *)buf_1MB + i) = i;
+	}
+	return 0;
+}
+
+static void deinit_buffer()
+{
+	if (buf_1MB) {
+		free(buf_1MB);
+		buf_1MB = NULL;
+	}
+	file_handle = NULL;
+}
+
+static void sig_handle()
+{
+	deinit_buffer();
+	exit(0);
+}
+
+static const char *short_options = "bB:c:C:Ff:im:p:r:s:t:vh";
+
+static const struct hint_s hint[] = {
+	{"",       "\t\t\t" "using buffer-io(fopen/fwrite),"
+		            " default non-buffer(open/write)"},
+	{"0~1",    "\t\t"   "slot id of mmcblk"},
+	{"1~1024", "\t"     "MB bytes to cross write in one thread"},
+	{"1~10",   "\t"     "cross file number"},
+	{"2,4,6,10","\t"    "specify the CLASS level"},
+	{"",       "\t\t"   "fixed step write 1MB"},
+	{"",       "\t\t"   "infinite write 1024MB"},
+	{"1~1024", "\t"     "MB bytes to multi thread write"},
+	{"",       "\t\t"   "mount point of /dev/mmcblkn"},
+	{"0.1~1.0","\t\t"   "tolerance ratio of class level"},
+	{"1~1024", "\t"     "MB bytes to single write"},
+	{"1~5",    "\t"     "multi thread number"},
+	{"",       "\t"     "version"},
+	{"help",   "\t\t"   "show usage\n" "e.g.\n"
+		"./sd_benchmark -s 10 (single file write 10 MB)\n"
+		"./sd_benchmark -i 10 (infinite file write 10 MB)\n"
+		"./sd_benchmark -c 10 -f 2 (cross write 10MB to 2 files)\n"
+		"./sd_benchmark -m 10 -t 3 (3 thread write 10MB to 3 files)\n"
+	},
+	{"", ""},
+};
+
+static struct option long_options[] = {
+	{"buffer-io",      NO_ARG,  0, 'b'},
+	{"mmcblk",         HAS_ARG, 0, 'B'},
+	{"cross-write",    HAS_ARG, 0, 'c'},
+	{"CLASS level",    HAS_ARG, 0, 'C'},
+	{"file-number",    HAS_ARG, 0, 'f'},
+	{"fixed-step",     NO_ARG,  0, 'F'},
+	{"infinite-write", NO_ARG,  0, 'i'},
+	{"thread-write",   HAS_ARG, 0, 'm'},
+	{"mount-point",    HAS_ARG, 0, 'p'},
+	{"tolerance-ratio",HAS_ARG, 0, 'r'},
+	{"single-write",   HAS_ARG, 0, 's'},
+	{"thread-number",  HAS_ARG, 0, 't'},
+	{"version",        NO_ARG,  0, 'v'},
+	{"help",           NO_ARG,  0, 'h'},
+	{"", NO_ARG, 0, 0},
+};
+
+void usage(int argc, char **argv)
+{
+	int i;
+	printf("%s usage:\n", argv[0]);
+	for (i = 0; i < sizeof(long_options)/sizeof(long_options[0])-1; i++) {
+		if (isalpha(long_options[i].val))
+			printf("-%c, ", long_options[i].val);
+		else
+			printf("   ");
+		printf("--%s", long_options[i].name);
+		if (hint[i].arg[0] != 0)
+			printf(" [%s]", hint[i].arg);
+		printf("\t%s\n", hint[i].str);
+	}
+	printf("\n");
+}
+
+int parse_param(int argc, char **argv)
+{
+	int buffer_io_flag = 0;
+	int infinite_write_flag = 0;
+	int single_write_flag = 0;
+	int thread_write_flag = 0;
+	int cross_write_flag = 0;
+	int class_check_flag = 0;
+	int class_lvl = CLASS10;
+	float tolerance = TOLERANCE_RATIO;
+	int file_num = 0;
+	int thread_num = 0;
+	int mega = 0;
+	int ch = 0;
+	int ret = 0;
+	int opt_index = 0;
+	snprintf(mount_point, sizeof(mount_point), "%s", DFT_MOUNT_POINT);
+	while ((ch = getopt_long(argc, argv, short_options,
+					long_options, &opt_index)) != -1) {
+		switch (ch) {
+		case 'b':
+			buffer_io_flag =1;
+			break;
+		case 'B':
+			mmcblk_id = strtoul(optarg, NULL, 10);
+			printf("mmcblk_id = %d\n", mmcblk_id);
+			break;
+		case 'c':
+			mega = strtoul(optarg, NULL, 10);
+			if (mega > 1024) {
+				printf("write data too large, max is 1024MB\n");
+				mega = 1024;
+			}
+			cross_write_flag = 1;
+			break;
+		case 'C':
+			class_lvl = strtoul(optarg, NULL, 10);
+			if (!(class_lvl == CLASS2 || class_lvl == CLASS4
+				|| class_lvl == CLASS6 || class_lvl == CLASS10)) {
+				printf("invalid CLASS level, must be 2|4|6|10,"
+						"default using CLASS2\n");
+				class_lvl = CLASS2;
+			}
+			class_check_flag = 1;
+			break;
+		case 'f':
+			file_num = strtoul(optarg, NULL, 10);
+			break;
+		case 'F':
+			fixed_step_flag = 1;
+			break;
+		case 'i':
+			infinite_write_flag = 1;
+			break;
+		case 'm':
+			mega = strtoul(optarg, NULL, 10);
+			if (mega > 1024) {
+				printf("write data too large, max is 1024MB\n");
+				mega = 1024;
+			}
+			thread_write_flag = 1;
+			break;
+		case 'p':
+			snprintf(mount_point, sizeof(mount_point), "%s", optarg);
+			printf("mount_point is %s\n", mount_point);
+			break;
+		case 'r':
+			tolerance = atof(optarg);
+			if (tolerance > 1 || tolerance < 0) {
+				printf("tolerance ratio must be (0, 1],"
+					"default is %0.2f\n", TOLERANCE_RATIO);
+				tolerance = TOLERANCE_RATIO;
+			}
+			break;
+		case 's':
+			mega = strtoul(optarg, NULL, 10);
+			if (mega > 1024) {
+				printf("write data too large, max is 1024MB\n");
+				mega = 1024;
+			}
+			single_write_flag = 1;
+			break;
+		case 't':
+			thread_num = strtoul(optarg, NULL, 10);
+			printf("thread number %d\n", thread_num);
+			break;
+		case 'v':
+			printf("version: %s\n", VERSION);
+			break;
+		default:
+			usage(argc, argv);
+			break;
+		}
+	}
+
+	if (infinite_write_flag || single_write_flag
+		|| cross_write_flag || thread_write_flag || class_check_flag) {
+		get_sdcard_info();
+	}
+	if (buffer_io_flag) {
+		file_handle = &fio_ops;
+	} else {
+		file_handle = &io_ops;
+	}
+	if (infinite_write_flag) {
+		infinite_write();
+	}
+	if (single_write_flag) {
+		single_write(mega*1024*1024);
+	}
+	if (cross_write_flag) {
+		cross_write(file_num, mega*1024*1024);
+	}
+	if (thread_write_flag) {
+		thread_write(thread_num, mega*1024*1024);
+	}
+	if (class_check_flag) {
+		ret = analysis(class_lvl, tolerance);
+		if (ret == -1) {
+			printf("FAILED.\n");
+		} else {
+			printf("PASSED.\n");
+		}
+	}
+	return 0;
+}
+
+int main(int argc, char **argv)
+{
+	signal(SIGINT, sig_handle);
+	signal(SIGQUIT, sig_handle);
+	signal(SIGTERM, sig_handle);
+
+	if (argc < 2) {
+		usage(argc, argv);
+		return -1;
+	}
+	init_buffer();
+	parse_param(argc, argv);
+	deinit_buffer();
+	return 0;
+}
diff --git a/evtest/evtest.c b/evtest/evtest.c
new file mode 100644
index 0000000..e9c3f49
--- /dev/null
+++ b/evtest/evtest.c
@@ -0,0 +1,1334 @@
+/*
+ *  Copyright (c) 1999-2000 Vojtech Pavlik
+ *  Copyright (c) 2009-2011 Red Hat, Inc
+ */
+
+/**
+ * @file
+ * Event device test program
+ *
+ * evtest prints the capabilities on the kernel devices in /dev/input/eventX
+ * and their events. Its primary purpose is for kernel or X driver
+ * debugging.
+ *
+ * See INSTALL for installation details or manually compile with
+ * gcc -o evtest evtest.c
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
+ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
+ */
+
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE /* for asprintf */
+#endif
+#include <stdio.h>
+#include <stdint.h>
+
+#if HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <linux/version.h>
+#include <linux/input.h>
+
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <dirent.h>
+#include <errno.h>
+#include <getopt.h>
+#include <ctype.h>
+#include <signal.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#define BITS_PER_LONG (sizeof(long) * 8)
+#define NBITS(x) ((((x)-1)/BITS_PER_LONG)+1)
+#define OFF(x)  ((x)%BITS_PER_LONG)
+#define BIT(x)  (1UL<<OFF(x))
+#define LONG(x) ((x)/BITS_PER_LONG)
+#define test_bit(bit, array)	((array[LONG(bit)] >> OFF(bit)) & 1)
+
+#define DEV_INPUT_EVENT "/dev/input"
+#define EVENT_DEV_NAME "event"
+
+#ifndef EV_SYN
+#define EV_SYN 0
+#endif
+#ifndef SYN_MAX
+#define SYN_MAX 3
+#define SYN_CNT (SYN_MAX + 1)
+#endif
+#ifndef SYN_MT_REPORT
+#define SYN_MT_REPORT 2
+#endif
+#ifndef SYN_DROPPED
+#define SYN_DROPPED 3
+#endif
+
+#define NAME_ELEMENT(element) [element] = #element
+
+enum evtest_mode {
+	MODE_CAPTURE,
+	MODE_QUERY,
+	MODE_VERSION,
+};
+
+static const struct query_mode {
+	const char *name;
+	int event_type;
+	int max;
+	int rq;
+} query_modes[] = {
+	{ "EV_KEY", EV_KEY, KEY_MAX, EVIOCGKEY(KEY_MAX) },
+	{ "EV_LED", EV_LED, LED_MAX, EVIOCGLED(LED_MAX) },
+	{ "EV_SND", EV_SND, SND_MAX, EVIOCGSND(SND_MAX) },
+	{ "EV_SW",  EV_SW, SW_MAX, EVIOCGSW(SW_MAX) },
+};
+
+static int grab_flag = 0;
+static volatile sig_atomic_t stop = 0;
+
+static void interrupt_handler(int sig)
+{
+	stop = 1;
+}
+
+/**
+ * Look up an entry in the query_modes table by its textual name.
+ *
+ * @param mode The name of the entry to be found.
+ *
+ * @return The requested query_mode, or NULL if it could not be found.
+ */
+static const struct query_mode *find_query_mode_by_name(const char *name)
+{
+	int i;
+	for (i = 0; i < sizeof(query_modes) / sizeof(*query_modes); i++) {
+		const struct query_mode *mode = &query_modes[i];
+		if (strcmp(mode->name, name) == 0)
+			return mode;
+	}
+	return NULL;
+}
+
+/**
+ * Look up an entry in the query_modes table by value.
+ *
+ * @param event_type The value of the entry to be found.
+ *
+ * @return The requested query_mode, or NULL if it could not be found.
+ */
+static const struct query_mode *find_query_mode_by_value(int event_type)
+{
+	int i;
+	for (i = 0; i < sizeof(query_modes) / sizeof(*query_modes); i++) {
+		const struct query_mode *mode = &query_modes[i];
+		if (mode->event_type == event_type)
+			return mode;
+	}
+	return NULL;
+}
+
+/**
+ * Find a query_mode based on a string identifier. The string can either
+ * be a numerical value (e.g. "5") or the name of the event type in question
+ * (e.g. "EV_SW").
+ *
+ * @param query_mode The mode to search for
+ *
+ * @return The requested code's numerical value, or negative on error.
+ */
+static const struct query_mode *find_query_mode(const char *query_mode)
+{
+	if (isdigit(query_mode[0])) {
+		unsigned long val;
+		errno = 0;
+		val = strtoul(query_mode, NULL, 0);
+		if (errno)
+			return NULL;
+		return find_query_mode_by_value(val);
+	} else {
+		return find_query_mode_by_name(query_mode);
+	}
+}
+
+static const char * const events[EV_MAX + 1] = {
+	[0 ... EV_MAX] = NULL,
+	NAME_ELEMENT(EV_SYN),			NAME_ELEMENT(EV_KEY),
+	NAME_ELEMENT(EV_REL),			NAME_ELEMENT(EV_ABS),
+	NAME_ELEMENT(EV_MSC),			NAME_ELEMENT(EV_LED),
+	NAME_ELEMENT(EV_SND),			NAME_ELEMENT(EV_REP),
+	NAME_ELEMENT(EV_FF),			NAME_ELEMENT(EV_PWR),
+	NAME_ELEMENT(EV_FF_STATUS),		NAME_ELEMENT(EV_SW),
+};
+
+static const int maxval[EV_MAX + 1] = {
+	[0 ... EV_MAX] = -1,
+	[EV_SYN] = SYN_MAX,
+	[EV_KEY] = KEY_MAX,
+	[EV_REL] = REL_MAX,
+	[EV_ABS] = ABS_MAX,
+	[EV_MSC] = MSC_MAX,
+	[EV_SW] = SW_MAX,
+	[EV_LED] = LED_MAX,
+	[EV_SND] = SND_MAX,
+	[EV_REP] = REP_MAX,
+	[EV_FF] = FF_MAX,
+	[EV_FF_STATUS] = FF_STATUS_MAX,
+};
+
+
+#ifdef INPUT_PROP_SEMI_MT
+static const char * const props[INPUT_PROP_MAX + 1] = {
+	[0 ... INPUT_PROP_MAX] = NULL,
+	NAME_ELEMENT(INPUT_PROP_POINTER),
+	NAME_ELEMENT(INPUT_PROP_DIRECT),
+	NAME_ELEMENT(INPUT_PROP_BUTTONPAD),
+	NAME_ELEMENT(INPUT_PROP_SEMI_MT),
+#ifdef INPUT_PROP_TOPBUTTONPAD
+	NAME_ELEMENT(INPUT_PROP_TOPBUTTONPAD),
+#endif
+#ifdef INPUT_PROP_POINTING_STICK
+	NAME_ELEMENT(INPUT_PROP_POINTING_STICK),
+#endif
+};
+#endif
+
+static const char * const keys[KEY_MAX + 1] = {
+	[0 ... KEY_MAX] = NULL,
+	NAME_ELEMENT(KEY_RESERVED),		NAME_ELEMENT(KEY_ESC),
+	NAME_ELEMENT(KEY_1),			NAME_ELEMENT(KEY_2),
+	NAME_ELEMENT(KEY_3),			NAME_ELEMENT(KEY_4),
+	NAME_ELEMENT(KEY_5),			NAME_ELEMENT(KEY_6),
+	NAME_ELEMENT(KEY_7),			NAME_ELEMENT(KEY_8),
+	NAME_ELEMENT(KEY_9),			NAME_ELEMENT(KEY_0),
+	NAME_ELEMENT(KEY_MINUS),		NAME_ELEMENT(KEY_EQUAL),
+	NAME_ELEMENT(KEY_BACKSPACE),		NAME_ELEMENT(KEY_TAB),
+	NAME_ELEMENT(KEY_Q),			NAME_ELEMENT(KEY_W),
+	NAME_ELEMENT(KEY_E),			NAME_ELEMENT(KEY_R),
+	NAME_ELEMENT(KEY_T),			NAME_ELEMENT(KEY_Y),
+	NAME_ELEMENT(KEY_U),			NAME_ELEMENT(KEY_I),
+	NAME_ELEMENT(KEY_O),			NAME_ELEMENT(KEY_P),
+	NAME_ELEMENT(KEY_LEFTBRACE),		NAME_ELEMENT(KEY_RIGHTBRACE),
+	NAME_ELEMENT(KEY_ENTER),		NAME_ELEMENT(KEY_LEFTCTRL),
+	NAME_ELEMENT(KEY_A),			NAME_ELEMENT(KEY_S),
+	NAME_ELEMENT(KEY_D),			NAME_ELEMENT(KEY_F),
+	NAME_ELEMENT(KEY_G),			NAME_ELEMENT(KEY_H),
+	NAME_ELEMENT(KEY_J),			NAME_ELEMENT(KEY_K),
+	NAME_ELEMENT(KEY_L),			NAME_ELEMENT(KEY_SEMICOLON),
+	NAME_ELEMENT(KEY_APOSTROPHE),		NAME_ELEMENT(KEY_GRAVE),
+	NAME_ELEMENT(KEY_LEFTSHIFT),		NAME_ELEMENT(KEY_BACKSLASH),
+	NAME_ELEMENT(KEY_Z),			NAME_ELEMENT(KEY_X),
+	NAME_ELEMENT(KEY_C),			NAME_ELEMENT(KEY_V),
+	NAME_ELEMENT(KEY_B),			NAME_ELEMENT(KEY_N),
+	NAME_ELEMENT(KEY_M),			NAME_ELEMENT(KEY_COMMA),
+	NAME_ELEMENT(KEY_DOT),			NAME_ELEMENT(KEY_SLASH),
+	NAME_ELEMENT(KEY_RIGHTSHIFT),		NAME_ELEMENT(KEY_KPASTERISK),
+	NAME_ELEMENT(KEY_LEFTALT),		NAME_ELEMENT(KEY_SPACE),
+	NAME_ELEMENT(KEY_CAPSLOCK),		NAME_ELEMENT(KEY_F1),
+	NAME_ELEMENT(KEY_F2),			NAME_ELEMENT(KEY_F3),
+	NAME_ELEMENT(KEY_F4),			NAME_ELEMENT(KEY_F5),
+	NAME_ELEMENT(KEY_F6),			NAME_ELEMENT(KEY_F7),
+	NAME_ELEMENT(KEY_F8),			NAME_ELEMENT(KEY_F9),
+	NAME_ELEMENT(KEY_F10),			NAME_ELEMENT(KEY_NUMLOCK),
+	NAME_ELEMENT(KEY_SCROLLLOCK),		NAME_ELEMENT(KEY_KP7),
+	NAME_ELEMENT(KEY_KP8),			NAME_ELEMENT(KEY_KP9),
+	NAME_ELEMENT(KEY_KPMINUS),		NAME_ELEMENT(KEY_KP4),
+	NAME_ELEMENT(KEY_KP5),			NAME_ELEMENT(KEY_KP6),
+	NAME_ELEMENT(KEY_KPPLUS),		NAME_ELEMENT(KEY_KP1),
+	NAME_ELEMENT(KEY_KP2),			NAME_ELEMENT(KEY_KP3),
+	NAME_ELEMENT(KEY_KP0),			NAME_ELEMENT(KEY_KPDOT),
+	NAME_ELEMENT(KEY_ZENKAKUHANKAKU), 	NAME_ELEMENT(KEY_102ND),
+	NAME_ELEMENT(KEY_F11),			NAME_ELEMENT(KEY_F12),
+	NAME_ELEMENT(KEY_RO),			NAME_ELEMENT(KEY_KATAKANA),
+	NAME_ELEMENT(KEY_HIRAGANA),		NAME_ELEMENT(KEY_HENKAN),
+	NAME_ELEMENT(KEY_KATAKANAHIRAGANA),	NAME_ELEMENT(KEY_MUHENKAN),
+	NAME_ELEMENT(KEY_KPJPCOMMA),		NAME_ELEMENT(KEY_KPENTER),
+	NAME_ELEMENT(KEY_RIGHTCTRL),		NAME_ELEMENT(KEY_KPSLASH),
+	NAME_ELEMENT(KEY_SYSRQ),		NAME_ELEMENT(KEY_RIGHTALT),
+	NAME_ELEMENT(KEY_LINEFEED),		NAME_ELEMENT(KEY_HOME),
+	NAME_ELEMENT(KEY_UP),			NAME_ELEMENT(KEY_PAGEUP),
+	NAME_ELEMENT(KEY_LEFT),			NAME_ELEMENT(KEY_RIGHT),
+	NAME_ELEMENT(KEY_END),			NAME_ELEMENT(KEY_DOWN),
+	NAME_ELEMENT(KEY_PAGEDOWN),		NAME_ELEMENT(KEY_INSERT),
+	NAME_ELEMENT(KEY_DELETE),		NAME_ELEMENT(KEY_MACRO),
+	NAME_ELEMENT(KEY_MUTE),			NAME_ELEMENT(KEY_VOLUMEDOWN),
+	NAME_ELEMENT(KEY_VOLUMEUP),		NAME_ELEMENT(KEY_POWER),
+	NAME_ELEMENT(KEY_KPEQUAL),		NAME_ELEMENT(KEY_KPPLUSMINUS),
+	NAME_ELEMENT(KEY_PAUSE),		NAME_ELEMENT(KEY_KPCOMMA),
+	NAME_ELEMENT(KEY_HANGUEL),		NAME_ELEMENT(KEY_HANJA),
+	NAME_ELEMENT(KEY_YEN),			NAME_ELEMENT(KEY_LEFTMETA),
+	NAME_ELEMENT(KEY_RIGHTMETA),		NAME_ELEMENT(KEY_COMPOSE),
+	NAME_ELEMENT(KEY_STOP),			NAME_ELEMENT(KEY_AGAIN),
+	NAME_ELEMENT(KEY_PROPS),		NAME_ELEMENT(KEY_UNDO),
+	NAME_ELEMENT(KEY_FRONT),		NAME_ELEMENT(KEY_COPY),
+	NAME_ELEMENT(KEY_OPEN),			NAME_ELEMENT(KEY_PASTE),
+	NAME_ELEMENT(KEY_FIND),			NAME_ELEMENT(KEY_CUT),
+	NAME_ELEMENT(KEY_HELP),			NAME_ELEMENT(KEY_MENU),
+	NAME_ELEMENT(KEY_CALC),			NAME_ELEMENT(KEY_SETUP),
+	NAME_ELEMENT(KEY_SLEEP),		NAME_ELEMENT(KEY_WAKEUP),
+	NAME_ELEMENT(KEY_FILE),			NAME_ELEMENT(KEY_SENDFILE),
+	NAME_ELEMENT(KEY_DELETEFILE),		NAME_ELEMENT(KEY_XFER),
+	NAME_ELEMENT(KEY_PROG1),		NAME_ELEMENT(KEY_PROG2),
+	NAME_ELEMENT(KEY_WWW),			NAME_ELEMENT(KEY_MSDOS),
+	NAME_ELEMENT(KEY_COFFEE),		NAME_ELEMENT(KEY_DIRECTION),
+	NAME_ELEMENT(KEY_CYCLEWINDOWS),		NAME_ELEMENT(KEY_MAIL),
+	NAME_ELEMENT(KEY_BOOKMARKS),		NAME_ELEMENT(KEY_COMPUTER),
+	NAME_ELEMENT(KEY_BACK),			NAME_ELEMENT(KEY_FORWARD),
+	NAME_ELEMENT(KEY_CLOSECD),		NAME_ELEMENT(KEY_EJECTCD),
+	NAME_ELEMENT(KEY_EJECTCLOSECD),		NAME_ELEMENT(KEY_NEXTSONG),
+	NAME_ELEMENT(KEY_PLAYPAUSE),		NAME_ELEMENT(KEY_PREVIOUSSONG),
+	NAME_ELEMENT(KEY_STOPCD),		NAME_ELEMENT(KEY_RECORD),
+	NAME_ELEMENT(KEY_REWIND),		NAME_ELEMENT(KEY_PHONE),
+	NAME_ELEMENT(KEY_ISO),			NAME_ELEMENT(KEY_CONFIG),
+	NAME_ELEMENT(KEY_HOMEPAGE),		NAME_ELEMENT(KEY_REFRESH),
+	NAME_ELEMENT(KEY_EXIT),			NAME_ELEMENT(KEY_MOVE),
+	NAME_ELEMENT(KEY_EDIT),			NAME_ELEMENT(KEY_SCROLLUP),
+	NAME_ELEMENT(KEY_SCROLLDOWN),		NAME_ELEMENT(KEY_KPLEFTPAREN),
+	NAME_ELEMENT(KEY_KPRIGHTPAREN), 	NAME_ELEMENT(KEY_F13),
+	NAME_ELEMENT(KEY_F14),			NAME_ELEMENT(KEY_F15),
+	NAME_ELEMENT(KEY_F16),			NAME_ELEMENT(KEY_F17),
+	NAME_ELEMENT(KEY_F18),			NAME_ELEMENT(KEY_F19),
+	NAME_ELEMENT(KEY_F20),			NAME_ELEMENT(KEY_F21),
+	NAME_ELEMENT(KEY_F22),			NAME_ELEMENT(KEY_F23),
+	NAME_ELEMENT(KEY_F24),			NAME_ELEMENT(KEY_PLAYCD),
+	NAME_ELEMENT(KEY_PAUSECD),		NAME_ELEMENT(KEY_PROG3),
+	NAME_ELEMENT(KEY_PROG4),		NAME_ELEMENT(KEY_SUSPEND),
+	NAME_ELEMENT(KEY_CLOSE),		NAME_ELEMENT(KEY_PLAY),
+	NAME_ELEMENT(KEY_FASTFORWARD),		NAME_ELEMENT(KEY_BASSBOOST),
+	NAME_ELEMENT(KEY_PRINT),		NAME_ELEMENT(KEY_HP),
+	NAME_ELEMENT(KEY_CAMERA),		NAME_ELEMENT(KEY_SOUND),
+	NAME_ELEMENT(KEY_QUESTION),		NAME_ELEMENT(KEY_EMAIL),
+	NAME_ELEMENT(KEY_CHAT),			NAME_ELEMENT(KEY_SEARCH),
+	NAME_ELEMENT(KEY_CONNECT),		NAME_ELEMENT(KEY_FINANCE),
+	NAME_ELEMENT(KEY_SPORT),		NAME_ELEMENT(KEY_SHOP),
+	NAME_ELEMENT(KEY_ALTERASE),		NAME_ELEMENT(KEY_CANCEL),
+	NAME_ELEMENT(KEY_BRIGHTNESSDOWN),	NAME_ELEMENT(KEY_BRIGHTNESSUP),
+	NAME_ELEMENT(KEY_MEDIA),		NAME_ELEMENT(KEY_UNKNOWN),
+	NAME_ELEMENT(KEY_OK),
+	NAME_ELEMENT(KEY_SELECT),		NAME_ELEMENT(KEY_GOTO),
+	NAME_ELEMENT(KEY_CLEAR),		NAME_ELEMENT(KEY_POWER2),
+	NAME_ELEMENT(KEY_OPTION),		NAME_ELEMENT(KEY_INFO),
+	NAME_ELEMENT(KEY_TIME),			NAME_ELEMENT(KEY_VENDOR),
+	NAME_ELEMENT(KEY_ARCHIVE),		NAME_ELEMENT(KEY_PROGRAM),
+	NAME_ELEMENT(KEY_CHANNEL),		NAME_ELEMENT(KEY_FAVORITES),
+	NAME_ELEMENT(KEY_EPG),			NAME_ELEMENT(KEY_PVR),
+	NAME_ELEMENT(KEY_MHP),			NAME_ELEMENT(KEY_LANGUAGE),
+	NAME_ELEMENT(KEY_TITLE),		NAME_ELEMENT(KEY_SUBTITLE),
+	NAME_ELEMENT(KEY_ANGLE),		NAME_ELEMENT(KEY_ZOOM),
+	NAME_ELEMENT(KEY_MODE),			NAME_ELEMENT(KEY_KEYBOARD),
+	NAME_ELEMENT(KEY_SCREEN),		NAME_ELEMENT(KEY_PC),
+	NAME_ELEMENT(KEY_TV),			NAME_ELEMENT(KEY_TV2),
+	NAME_ELEMENT(KEY_VCR),			NAME_ELEMENT(KEY_VCR2),
+	NAME_ELEMENT(KEY_SAT),			NAME_ELEMENT(KEY_SAT2),
+	NAME_ELEMENT(KEY_CD),			NAME_ELEMENT(KEY_TAPE),
+	NAME_ELEMENT(KEY_RADIO),		NAME_ELEMENT(KEY_TUNER),
+	NAME_ELEMENT(KEY_PLAYER),		NAME_ELEMENT(KEY_TEXT),
+	NAME_ELEMENT(KEY_DVD),			NAME_ELEMENT(KEY_AUX),
+	NAME_ELEMENT(KEY_MP3),			NAME_ELEMENT(KEY_AUDIO),
+	NAME_ELEMENT(KEY_VIDEO),		NAME_ELEMENT(KEY_DIRECTORY),
+	NAME_ELEMENT(KEY_LIST),			NAME_ELEMENT(KEY_MEMO),
+	NAME_ELEMENT(KEY_CALENDAR),		NAME_ELEMENT(KEY_RED),
+	NAME_ELEMENT(KEY_GREEN),		NAME_ELEMENT(KEY_YELLOW),
+	NAME_ELEMENT(KEY_BLUE),			NAME_ELEMENT(KEY_CHANNELUP),
+	NAME_ELEMENT(KEY_CHANNELDOWN),		NAME_ELEMENT(KEY_FIRST),
+	NAME_ELEMENT(KEY_LAST),			NAME_ELEMENT(KEY_AB),
+	NAME_ELEMENT(KEY_NEXT),			NAME_ELEMENT(KEY_RESTART),
+	NAME_ELEMENT(KEY_SLOW),			NAME_ELEMENT(KEY_SHUFFLE),
+	NAME_ELEMENT(KEY_BREAK),		NAME_ELEMENT(KEY_PREVIOUS),
+	NAME_ELEMENT(KEY_DIGITS),		NAME_ELEMENT(KEY_TEEN),
+	NAME_ELEMENT(KEY_TWEN),			NAME_ELEMENT(KEY_DEL_EOL),
+	NAME_ELEMENT(KEY_DEL_EOS),		NAME_ELEMENT(KEY_INS_LINE),
+	NAME_ELEMENT(KEY_DEL_LINE),
+	NAME_ELEMENT(KEY_VIDEOPHONE),		NAME_ELEMENT(KEY_GAMES),
+	NAME_ELEMENT(KEY_ZOOMIN),		NAME_ELEMENT(KEY_ZOOMOUT),
+	NAME_ELEMENT(KEY_ZOOMRESET),		NAME_ELEMENT(KEY_WORDPROCESSOR),
+	NAME_ELEMENT(KEY_EDITOR),		NAME_ELEMENT(KEY_SPREADSHEET),
+	NAME_ELEMENT(KEY_GRAPHICSEDITOR), 	NAME_ELEMENT(KEY_PRESENTATION),
+	NAME_ELEMENT(KEY_DATABASE),		NAME_ELEMENT(KEY_NEWS),
+	NAME_ELEMENT(KEY_VOICEMAIL),		NAME_ELEMENT(KEY_ADDRESSBOOK),
+	NAME_ELEMENT(KEY_MESSENGER),		NAME_ELEMENT(KEY_DISPLAYTOGGLE),
+#ifdef KEY_SPELLCHECK
+	NAME_ELEMENT(KEY_SPELLCHECK),
+#endif
+#ifdef KEY_LOGOFF
+	NAME_ELEMENT(KEY_LOGOFF),
+#endif
+#ifdef KEY_DOLLAR
+	NAME_ELEMENT(KEY_DOLLAR),
+#endif
+#ifdef KEY_EURO
+	NAME_ELEMENT(KEY_EURO),
+#endif
+#ifdef KEY_FRAMEBACK
+	NAME_ELEMENT(KEY_FRAMEBACK),
+#endif
+#ifdef KEY_FRAMEFORWARD
+	NAME_ELEMENT(KEY_FRAMEFORWARD),
+#endif
+#ifdef KEY_CONTEXT_MENU
+	NAME_ELEMENT(KEY_CONTEXT_MENU),
+#endif
+#ifdef KEY_MEDIA_REPEAT
+	NAME_ELEMENT(KEY_MEDIA_REPEAT),
+#endif
+#ifdef KEY_10CHANNELSUP
+	NAME_ELEMENT(KEY_10CHANNELSUP),
+#endif
+#ifdef KEY_10CHANNELSDOWN
+	NAME_ELEMENT(KEY_10CHANNELSDOWN),
+#endif
+#ifdef KEY_IMAGES
+	NAME_ELEMENT(KEY_IMAGES),
+#endif
+	NAME_ELEMENT(KEY_DEL_EOL),		NAME_ELEMENT(KEY_DEL_EOS),
+	NAME_ELEMENT(KEY_INS_LINE),	 	NAME_ELEMENT(KEY_DEL_LINE),
+	NAME_ELEMENT(KEY_FN),			NAME_ELEMENT(KEY_FN_ESC),
+	NAME_ELEMENT(KEY_FN_F1),		NAME_ELEMENT(KEY_FN_F2),
+	NAME_ELEMENT(KEY_FN_F3),		NAME_ELEMENT(KEY_FN_F4),
+	NAME_ELEMENT(KEY_FN_F5),		NAME_ELEMENT(KEY_FN_F6),
+	NAME_ELEMENT(KEY_FN_F7),		NAME_ELEMENT(KEY_FN_F8),
+	NAME_ELEMENT(KEY_FN_F9),		NAME_ELEMENT(KEY_FN_F10),
+	NAME_ELEMENT(KEY_FN_F11),		NAME_ELEMENT(KEY_FN_F12),
+	NAME_ELEMENT(KEY_FN_1),			NAME_ELEMENT(KEY_FN_2),
+	NAME_ELEMENT(KEY_FN_D),			NAME_ELEMENT(KEY_FN_E),
+	NAME_ELEMENT(KEY_FN_F),			NAME_ELEMENT(KEY_FN_S),
+	NAME_ELEMENT(KEY_FN_B),
+	NAME_ELEMENT(KEY_BRL_DOT1),		NAME_ELEMENT(KEY_BRL_DOT2),
+	NAME_ELEMENT(KEY_BRL_DOT3),		NAME_ELEMENT(KEY_BRL_DOT4),
+	NAME_ELEMENT(KEY_BRL_DOT5),		NAME_ELEMENT(KEY_BRL_DOT6),
+	NAME_ELEMENT(KEY_BRL_DOT7),		NAME_ELEMENT(KEY_BRL_DOT8),
+	NAME_ELEMENT(KEY_BRL_DOT9),		NAME_ELEMENT(KEY_BRL_DOT10),
+#ifdef KEY_NUMERIC_0
+	NAME_ELEMENT(KEY_NUMERIC_0),		NAME_ELEMENT(KEY_NUMERIC_1),
+	NAME_ELEMENT(KEY_NUMERIC_2),		NAME_ELEMENT(KEY_NUMERIC_3),
+	NAME_ELEMENT(KEY_NUMERIC_4),		NAME_ELEMENT(KEY_NUMERIC_5),
+	NAME_ELEMENT(KEY_NUMERIC_6),		NAME_ELEMENT(KEY_NUMERIC_7),
+	NAME_ELEMENT(KEY_NUMERIC_8),		NAME_ELEMENT(KEY_NUMERIC_9),
+	NAME_ELEMENT(KEY_NUMERIC_STAR),		NAME_ELEMENT(KEY_NUMERIC_POUND),
+#endif
+	NAME_ELEMENT(KEY_BATTERY),
+	NAME_ELEMENT(KEY_BLUETOOTH),		NAME_ELEMENT(KEY_BRIGHTNESS_CYCLE),
+	NAME_ELEMENT(KEY_BRIGHTNESS_ZERO),
+#ifdef KEY_DASHBOARD
+	NAME_ELEMENT(KEY_DASHBOARD),
+#endif
+	NAME_ELEMENT(KEY_DISPLAY_OFF),		NAME_ELEMENT(KEY_DOCUMENTS),
+	NAME_ELEMENT(KEY_FORWARDMAIL),		NAME_ELEMENT(KEY_NEW),
+	NAME_ELEMENT(KEY_KBDILLUMDOWN),		NAME_ELEMENT(KEY_KBDILLUMUP),
+	NAME_ELEMENT(KEY_KBDILLUMTOGGLE), 	NAME_ELEMENT(KEY_REDO),
+	NAME_ELEMENT(KEY_REPLY),		NAME_ELEMENT(KEY_SAVE),
+#ifdef KEY_SCALE
+	NAME_ELEMENT(KEY_SCALE),
+#endif
+	NAME_ELEMENT(KEY_SEND),
+	NAME_ELEMENT(KEY_SCREENLOCK),		NAME_ELEMENT(KEY_SWITCHVIDEOMODE),
+#ifdef KEY_UWB
+	NAME_ELEMENT(KEY_UWB),
+#endif
+#ifdef KEY_VIDEO_NEXT
+	NAME_ELEMENT(KEY_VIDEO_NEXT),
+#endif
+#ifdef KEY_VIDEO_PREV
+	NAME_ELEMENT(KEY_VIDEO_PREV),
+#endif
+#ifdef KEY_WIMAX
+	NAME_ELEMENT(KEY_WIMAX),
+#endif
+#ifdef KEY_WLAN
+	NAME_ELEMENT(KEY_WLAN),
+#endif
+#ifdef KEY_RFKILL
+	NAME_ELEMENT(KEY_RFKILL),
+#endif
+#ifdef KEY_MICMUTE
+	NAME_ELEMENT(KEY_MICMUTE),
+#endif
+#ifdef KEY_CAMERA_FOCUS
+	NAME_ELEMENT(KEY_CAMERA_FOCUS),
+#endif
+#ifdef KEY_WPS_BUTTON
+	NAME_ELEMENT(KEY_WPS_BUTTON),
+#endif
+#ifdef KEY_TOUCHPAD_TOGGLE
+	NAME_ELEMENT(KEY_TOUCHPAD_TOGGLE),
+	NAME_ELEMENT(KEY_TOUCHPAD_ON),
+	NAME_ELEMENT(KEY_TOUCHPAD_OFF),
+#endif
+#ifdef KEY_CAMERA_ZOOMIN
+	NAME_ELEMENT(KEY_CAMERA_ZOOMIN),	NAME_ELEMENT(KEY_CAMERA_ZOOMOUT),
+	NAME_ELEMENT(KEY_CAMERA_UP),		NAME_ELEMENT(KEY_CAMERA_DOWN),
+	NAME_ELEMENT(KEY_CAMERA_LEFT),		NAME_ELEMENT(KEY_CAMERA_RIGHT),
+#endif
+#ifdef KEY_ATTENDANT_ON
+	NAME_ELEMENT(KEY_ATTENDANT_ON),		NAME_ELEMENT(KEY_ATTENDANT_OFF),
+	NAME_ELEMENT(KEY_ATTENDANT_TOGGLE),	NAME_ELEMENT(KEY_LIGHTS_TOGGLE),
+#endif
+
+	NAME_ELEMENT(BTN_0),			NAME_ELEMENT(BTN_1),
+	NAME_ELEMENT(BTN_2),			NAME_ELEMENT(BTN_3),
+	NAME_ELEMENT(BTN_4),			NAME_ELEMENT(BTN_5),
+	NAME_ELEMENT(BTN_6),			NAME_ELEMENT(BTN_7),
+	NAME_ELEMENT(BTN_8),			NAME_ELEMENT(BTN_9),
+	NAME_ELEMENT(BTN_LEFT),			NAME_ELEMENT(BTN_RIGHT),
+	NAME_ELEMENT(BTN_MIDDLE),		NAME_ELEMENT(BTN_SIDE),
+	NAME_ELEMENT(BTN_EXTRA),		NAME_ELEMENT(BTN_FORWARD),
+	NAME_ELEMENT(BTN_BACK),			NAME_ELEMENT(BTN_TASK),
+	NAME_ELEMENT(BTN_TRIGGER),		NAME_ELEMENT(BTN_THUMB),
+	NAME_ELEMENT(BTN_THUMB2),		NAME_ELEMENT(BTN_TOP),
+	NAME_ELEMENT(BTN_TOP2),			NAME_ELEMENT(BTN_PINKIE),
+	NAME_ELEMENT(BTN_BASE),			NAME_ELEMENT(BTN_BASE2),
+	NAME_ELEMENT(BTN_BASE3),		NAME_ELEMENT(BTN_BASE4),
+	NAME_ELEMENT(BTN_BASE5),		NAME_ELEMENT(BTN_BASE6),
+	NAME_ELEMENT(BTN_DEAD),			NAME_ELEMENT(BTN_C),
+#ifdef BTN_SOUTH
+	NAME_ELEMENT(BTN_SOUTH),		NAME_ELEMENT(BTN_EAST),
+	NAME_ELEMENT(BTN_NORTH),		NAME_ELEMENT(BTN_WEST),
+#else
+	NAME_ELEMENT(BTN_A),			NAME_ELEMENT(BTN_B),
+	NAME_ELEMENT(BTN_X),			NAME_ELEMENT(BTN_Y),
+#endif
+	NAME_ELEMENT(BTN_Z),			NAME_ELEMENT(BTN_TL),
+	NAME_ELEMENT(BTN_TR),			NAME_ELEMENT(BTN_TL2),
+	NAME_ELEMENT(BTN_TR2),			NAME_ELEMENT(BTN_SELECT),
+	NAME_ELEMENT(BTN_START),		NAME_ELEMENT(BTN_MODE),
+	NAME_ELEMENT(BTN_THUMBL),		NAME_ELEMENT(BTN_THUMBR),
+	NAME_ELEMENT(BTN_TOOL_PEN),		NAME_ELEMENT(BTN_TOOL_RUBBER),
+	NAME_ELEMENT(BTN_TOOL_BRUSH),		NAME_ELEMENT(BTN_TOOL_PENCIL),
+	NAME_ELEMENT(BTN_TOOL_AIRBRUSH),	NAME_ELEMENT(BTN_TOOL_FINGER),
+	NAME_ELEMENT(BTN_TOOL_MOUSE),		NAME_ELEMENT(BTN_TOOL_LENS),
+	NAME_ELEMENT(BTN_TOUCH),		NAME_ELEMENT(BTN_STYLUS),
+	NAME_ELEMENT(BTN_STYLUS2),		NAME_ELEMENT(BTN_TOOL_DOUBLETAP),
+	NAME_ELEMENT(BTN_TOOL_TRIPLETAP),
+#ifdef BTN_TOOL_QUADTAP
+	NAME_ELEMENT(BTN_TOOL_QUADTAP),
+#endif
+	NAME_ELEMENT(BTN_GEAR_DOWN),
+	NAME_ELEMENT(BTN_GEAR_UP),
+
+#ifdef BTN_DPAD_UP
+	NAME_ELEMENT(BTN_DPAD_UP),		NAME_ELEMENT(BTN_DPAD_DOWN),
+	NAME_ELEMENT(BTN_DPAD_LEFT),		NAME_ELEMENT(BTN_DPAD_RIGHT),
+#endif
+#ifdef KEY_ALS_TOGGLE
+	NAME_ELEMENT(KEY_ALS_TOGGLE),
+#endif
+#ifdef KEY_BUTTONCONFIG
+	NAME_ELEMENT(KEY_BUTTONCONFIG),
+#endif
+#ifdef KEY_TASKMANAGER
+	NAME_ELEMENT(KEY_TASKMANAGER),
+#endif
+#ifdef KEY_JOURNAL
+	NAME_ELEMENT(KEY_JOURNAL),
+#endif
+#ifdef KEY_CONTROLPANEL
+	NAME_ELEMENT(KEY_CONTROLPANEL),
+#endif
+#ifdef KEY_APPSELECT
+	NAME_ELEMENT(KEY_APPSELECT),
+#endif
+#ifdef KEY_SCREENSAVER
+	NAME_ELEMENT(KEY_SCREENSAVER),
+#endif
+#ifdef KEY_VOICECOMMAND
+	NAME_ELEMENT(KEY_VOICECOMMAND),
+#endif
+#ifdef KEY_BRIGHTNESS_MIN
+	NAME_ELEMENT(KEY_BRIGHTNESS_MIN),
+#endif
+#ifdef KEY_BRIGHTNESS_MAX
+	NAME_ELEMENT(KEY_BRIGHTNESS_MAX),
+#endif
+#ifdef KEY_KBDINPUTASSIST_PREV
+	NAME_ELEMENT(KEY_KBDINPUTASSIST_PREV),
+#endif
+#ifdef KEY_KBDINPUTASSIST_NEXT
+	NAME_ELEMENT(KEY_KBDINPUTASSIST_NEXT),
+#endif
+#ifdef KEY_KBDINPUTASSIST_PREVGROUP
+	NAME_ELEMENT(KEY_KBDINPUTASSIST_PREVGROUP),
+#endif
+#ifdef KEY_KBDINPUTASSIST_NEXTGROUP
+	NAME_ELEMENT(KEY_KBDINPUTASSIST_NEXTGROUP),
+#endif
+#ifdef KEY_KBDINPUTASSIST_ACCEPT
+	NAME_ELEMENT(KEY_KBDINPUTASSIST_ACCEPT),
+#endif
+#ifdef KEY_KBDINPUTASSIST_CANCEL
+	NAME_ELEMENT(KEY_KBDINPUTASSIST_CANCEL),
+#endif
+#ifdef BTN_TRIGGER_HAPPY
+	NAME_ELEMENT(BTN_TRIGGER_HAPPY1),	NAME_ELEMENT(BTN_TRIGGER_HAPPY11),
+	NAME_ELEMENT(BTN_TRIGGER_HAPPY2),	NAME_ELEMENT(BTN_TRIGGER_HAPPY12),
+	NAME_ELEMENT(BTN_TRIGGER_HAPPY3),	NAME_ELEMENT(BTN_TRIGGER_HAPPY13),
+	NAME_ELEMENT(BTN_TRIGGER_HAPPY4),	NAME_ELEMENT(BTN_TRIGGER_HAPPY14),
+	NAME_ELEMENT(BTN_TRIGGER_HAPPY5),	NAME_ELEMENT(BTN_TRIGGER_HAPPY15),
+	NAME_ELEMENT(BTN_TRIGGER_HAPPY6),	NAME_ELEMENT(BTN_TRIGGER_HAPPY16),
+	NAME_ELEMENT(BTN_TRIGGER_HAPPY7),	NAME_ELEMENT(BTN_TRIGGER_HAPPY17),
+	NAME_ELEMENT(BTN_TRIGGER_HAPPY8),	NAME_ELEMENT(BTN_TRIGGER_HAPPY18),
+	NAME_ELEMENT(BTN_TRIGGER_HAPPY9),	NAME_ELEMENT(BTN_TRIGGER_HAPPY19),
+	NAME_ELEMENT(BTN_TRIGGER_HAPPY10),	NAME_ELEMENT(BTN_TRIGGER_HAPPY20),
+
+	NAME_ELEMENT(BTN_TRIGGER_HAPPY21),	NAME_ELEMENT(BTN_TRIGGER_HAPPY31),
+	NAME_ELEMENT(BTN_TRIGGER_HAPPY22),	NAME_ELEMENT(BTN_TRIGGER_HAPPY32),
+	NAME_ELEMENT(BTN_TRIGGER_HAPPY23),	NAME_ELEMENT(BTN_TRIGGER_HAPPY33),
+	NAME_ELEMENT(BTN_TRIGGER_HAPPY24),	NAME_ELEMENT(BTN_TRIGGER_HAPPY34),
+	NAME_ELEMENT(BTN_TRIGGER_HAPPY25),	NAME_ELEMENT(BTN_TRIGGER_HAPPY35),
+	NAME_ELEMENT(BTN_TRIGGER_HAPPY26),	NAME_ELEMENT(BTN_TRIGGER_HAPPY36),
+	NAME_ELEMENT(BTN_TRIGGER_HAPPY27),	NAME_ELEMENT(BTN_TRIGGER_HAPPY37),
+	NAME_ELEMENT(BTN_TRIGGER_HAPPY28),	NAME_ELEMENT(BTN_TRIGGER_HAPPY38),
+	NAME_ELEMENT(BTN_TRIGGER_HAPPY29),	NAME_ELEMENT(BTN_TRIGGER_HAPPY39),
+	NAME_ELEMENT(BTN_TRIGGER_HAPPY30),	NAME_ELEMENT(BTN_TRIGGER_HAPPY40),
+#endif
+#ifdef BTN_TOOL_QUINTTAP
+	NAME_ELEMENT(BTN_TOOL_QUINTTAP),
+#endif
+};
+
+static const char * const absval[6] = { "Value", "Min  ", "Max  ", "Fuzz ", "Flat ", "Resolution "};
+
+static const char * const relatives[REL_MAX + 1] = {
+	[0 ... REL_MAX] = NULL,
+	NAME_ELEMENT(REL_X),			NAME_ELEMENT(REL_Y),
+	NAME_ELEMENT(REL_Z),			NAME_ELEMENT(REL_RX),
+	NAME_ELEMENT(REL_RY),			NAME_ELEMENT(REL_RZ),
+	NAME_ELEMENT(REL_HWHEEL),
+	NAME_ELEMENT(REL_DIAL),			NAME_ELEMENT(REL_WHEEL),
+	NAME_ELEMENT(REL_MISC),
+};
+
+static const char * const absolutes[ABS_MAX + 1] = {
+	[0 ... ABS_MAX] = NULL,
+	NAME_ELEMENT(ABS_X),			NAME_ELEMENT(ABS_Y),
+	NAME_ELEMENT(ABS_Z),			NAME_ELEMENT(ABS_RX),
+	NAME_ELEMENT(ABS_RY),			NAME_ELEMENT(ABS_RZ),
+	NAME_ELEMENT(ABS_THROTTLE),		NAME_ELEMENT(ABS_RUDDER),
+	NAME_ELEMENT(ABS_WHEEL),		NAME_ELEMENT(ABS_GAS),
+	NAME_ELEMENT(ABS_BRAKE),		NAME_ELEMENT(ABS_HAT0X),
+	NAME_ELEMENT(ABS_HAT0Y),		NAME_ELEMENT(ABS_HAT1X),
+	NAME_ELEMENT(ABS_HAT1Y),		NAME_ELEMENT(ABS_HAT2X),
+	NAME_ELEMENT(ABS_HAT2Y),		NAME_ELEMENT(ABS_HAT3X),
+	NAME_ELEMENT(ABS_HAT3Y),		NAME_ELEMENT(ABS_PRESSURE),
+	NAME_ELEMENT(ABS_DISTANCE),		NAME_ELEMENT(ABS_TILT_X),
+	NAME_ELEMENT(ABS_TILT_Y),		NAME_ELEMENT(ABS_TOOL_WIDTH),
+	NAME_ELEMENT(ABS_VOLUME),		NAME_ELEMENT(ABS_MISC),
+#ifdef ABS_MT_BLOB_ID
+	NAME_ELEMENT(ABS_MT_TOUCH_MAJOR),
+	NAME_ELEMENT(ABS_MT_TOUCH_MINOR),
+	NAME_ELEMENT(ABS_MT_WIDTH_MAJOR),
+	NAME_ELEMENT(ABS_MT_WIDTH_MINOR),
+	NAME_ELEMENT(ABS_MT_ORIENTATION),
+	NAME_ELEMENT(ABS_MT_POSITION_X),
+	NAME_ELEMENT(ABS_MT_POSITION_Y),
+	NAME_ELEMENT(ABS_MT_TOOL_TYPE),
+	NAME_ELEMENT(ABS_MT_BLOB_ID),
+#endif
+#ifdef ABS_MT_TRACKING_ID
+	NAME_ELEMENT(ABS_MT_TRACKING_ID),
+#endif
+#ifdef ABS_MT_PRESSURE
+	NAME_ELEMENT(ABS_MT_PRESSURE),
+#endif
+#ifdef ABS_MT_SLOT
+	NAME_ELEMENT(ABS_MT_SLOT),
+#endif
+#ifdef ABS_MT_TOOL_X
+	NAME_ELEMENT(ABS_MT_TOOL_X),
+	NAME_ELEMENT(ABS_MT_TOOL_Y),
+	NAME_ELEMENT(ABS_MT_DISTANCE),
+#endif
+
+};
+
+static const char * const misc[MSC_MAX + 1] = {
+	[ 0 ... MSC_MAX] = NULL,
+	NAME_ELEMENT(MSC_SERIAL),		NAME_ELEMENT(MSC_PULSELED),
+	NAME_ELEMENT(MSC_GESTURE),		NAME_ELEMENT(MSC_RAW),
+	NAME_ELEMENT(MSC_SCAN),
+#ifdef MSC_TIMESTAMP
+	NAME_ELEMENT(MSC_TIMESTAMP),
+#endif
+};
+
+static const char * const leds[LED_MAX + 1] = {
+	[0 ... LED_MAX] = NULL,
+	NAME_ELEMENT(LED_NUML),			NAME_ELEMENT(LED_CAPSL),
+	NAME_ELEMENT(LED_SCROLLL),		NAME_ELEMENT(LED_COMPOSE),
+	NAME_ELEMENT(LED_KANA),			NAME_ELEMENT(LED_SLEEP),
+	NAME_ELEMENT(LED_SUSPEND),		NAME_ELEMENT(LED_MUTE),
+	NAME_ELEMENT(LED_MISC),
+#ifdef LED_MAIL
+	NAME_ELEMENT(LED_MAIL),
+#endif
+#ifdef LED_CHARGING
+	NAME_ELEMENT(LED_CHARGING),
+#endif
+};
+
+static const char * const repeats[REP_MAX + 1] = {
+	[0 ... REP_MAX] = NULL,
+	NAME_ELEMENT(REP_DELAY),		NAME_ELEMENT(REP_PERIOD)
+};
+
+static const char * const sounds[SND_MAX + 1] = {
+	[0 ... SND_MAX] = NULL,
+	NAME_ELEMENT(SND_CLICK),		NAME_ELEMENT(SND_BELL),
+	NAME_ELEMENT(SND_TONE)
+};
+
+static const char * const syns[SYN_MAX + 1] = {
+	[0 ... SYN_MAX] = NULL,
+	NAME_ELEMENT(SYN_REPORT),
+	NAME_ELEMENT(SYN_CONFIG),
+	NAME_ELEMENT(SYN_MT_REPORT),
+	NAME_ELEMENT(SYN_DROPPED)
+};
+
+static const char * const switches[SW_MAX + 1] = {
+	[0 ... SW_MAX] = NULL,
+	NAME_ELEMENT(SW_LID),
+	NAME_ELEMENT(SW_TABLET_MODE),
+	NAME_ELEMENT(SW_HEADPHONE_INSERT),
+#ifdef SW_RFKILL_ALL
+	NAME_ELEMENT(SW_RFKILL_ALL),
+#endif
+#ifdef SW_MICROPHONE_INSERT
+	NAME_ELEMENT(SW_MICROPHONE_INSERT),
+#endif
+#ifdef SW_DOCK
+	NAME_ELEMENT(SW_DOCK),
+#endif
+#ifdef SW_LINEOUT_INSERT
+	NAME_ELEMENT(SW_LINEOUT_INSERT),
+#endif
+#ifdef SW_JACK_PHYSICAL_INSERT
+	NAME_ELEMENT(SW_JACK_PHYSICAL_INSERT),
+#endif
+#ifdef SW_VIDEOOUT_INSERT
+	NAME_ELEMENT(SW_VIDEOOUT_INSERT),
+#endif
+#ifdef SW_CAMERA_LENS_COVER
+	NAME_ELEMENT(SW_CAMERA_LENS_COVER),
+	NAME_ELEMENT(SW_KEYPAD_SLIDE),
+	NAME_ELEMENT(SW_FRONT_PROXIMITY),
+#endif
+#ifdef SW_ROTATE_LOCK
+	NAME_ELEMENT(SW_ROTATE_LOCK),
+#endif
+#ifdef SW_LINEIN_INSERT
+	NAME_ELEMENT(SW_LINEIN_INSERT),
+#endif
+#ifdef SW_MUTE_DEVICE
+	NAME_ELEMENT(SW_MUTE_DEVICE),
+#endif
+};
+
+static const char * const force[FF_MAX + 1] = {
+	[0 ... FF_MAX] = NULL,
+	NAME_ELEMENT(FF_RUMBLE),		NAME_ELEMENT(FF_PERIODIC),
+	NAME_ELEMENT(FF_CONSTANT),		NAME_ELEMENT(FF_SPRING),
+	NAME_ELEMENT(FF_FRICTION),		NAME_ELEMENT(FF_DAMPER),
+	NAME_ELEMENT(FF_INERTIA),		NAME_ELEMENT(FF_RAMP),
+	NAME_ELEMENT(FF_SQUARE),		NAME_ELEMENT(FF_TRIANGLE),
+	NAME_ELEMENT(FF_SINE),			NAME_ELEMENT(FF_SAW_UP),
+	NAME_ELEMENT(FF_SAW_DOWN),		NAME_ELEMENT(FF_CUSTOM),
+	NAME_ELEMENT(FF_GAIN),			NAME_ELEMENT(FF_AUTOCENTER),
+};
+
+static const char * const forcestatus[FF_STATUS_MAX + 1] = {
+	[0 ... FF_STATUS_MAX] = NULL,
+	NAME_ELEMENT(FF_STATUS_STOPPED),	NAME_ELEMENT(FF_STATUS_PLAYING),
+};
+
+static const char * const * const names[EV_MAX + 1] = {
+	[0 ... EV_MAX] = NULL,
+	[EV_SYN] = syns,			[EV_KEY] = keys,
+	[EV_REL] = relatives,			[EV_ABS] = absolutes,
+	[EV_MSC] = misc,			[EV_LED] = leds,
+	[EV_SND] = sounds,			[EV_REP] = repeats,
+	[EV_SW] = switches,
+	[EV_FF] = force,			[EV_FF_STATUS] = forcestatus,
+};
+
+/**
+ * Convert a string to a specific key/snd/led/sw code. The string can either
+ * be the name of the key in question (e.g. "SW_DOCK") or the numerical
+ * value, either as decimal (e.g. "5") or as hex (e.g. "0x5").
+ *
+ * @param mode The mode being queried (key, snd, led, sw)
+ * @param kstr The string to parse and convert
+ *
+ * @return The requested code's numerical value, or negative on error.
+ */
+static int get_keycode(const struct query_mode *query_mode, const char *kstr)
+{
+	if (isdigit(kstr[0])) {
+		unsigned long val;
+		errno = 0;
+		val = strtoul(kstr, NULL, 0);
+		if (errno) {
+			fprintf(stderr, "Could not interpret value %s\n", kstr);
+			return -1;
+		}
+		return (int) val;
+	} else {
+		const char * const *keynames = names[query_mode->event_type];
+		int i;
+
+		for (i = 0; i < query_mode->max; i++) {
+			const char *name = keynames[i];
+			if (name && strcmp(name, kstr) == 0)
+				return i;
+		}
+
+		return -1;
+	}
+}
+
+/**
+ * Filter for the AutoDevProbe scandir on /dev/input.
+ *
+ * @param dir The current directory entry provided by scandir.
+ *
+ * @return Non-zero if the given directory entry starts with "event", or zero
+ * otherwise.
+ */
+static int is_event_device(const struct dirent *dir) {
+	return strncmp(EVENT_DEV_NAME, dir->d_name, 5) == 0;
+}
+
+/**
+ * Scans all /dev/input/event*, display them and ask the user which one to
+ * open.
+ *
+ * @return The event device file name of the device file selected. This
+ * string is allocated and must be freed by the caller.
+ */
+static char* scan_devices(void)
+{
+	struct dirent **namelist;
+	int i, ndev, devnum;
+	char *filename;
+	int max_device = 0;
+
+	ndev = scandir(DEV_INPUT_EVENT, &namelist, is_event_device, versionsort);
+	if (ndev <= 0)
+		return NULL;
+
+	fprintf(stderr, "Available devices:\n");
+
+	for (i = 0; i < ndev; i++)
+	{
+		char fname[64];
+		int fd = -1;
+		char name[256] = "???";
+
+		snprintf(fname, sizeof(fname),
+			 "%s/%s", DEV_INPUT_EVENT, namelist[i]->d_name);
+		fd = open(fname, O_RDONLY);
+		if (fd < 0)
+			continue;
+		ioctl(fd, EVIOCGNAME(sizeof(name)), name);
+
+		fprintf(stderr, "%s:	%s\n", fname, name);
+		close(fd);
+
+		sscanf(namelist[i]->d_name, "event%d", &devnum);
+		if (devnum > max_device)
+			max_device = devnum;
+
+		free(namelist[i]);
+	}
+
+	fprintf(stderr, "Select the device event number [0-%d]: ", max_device);
+	scanf("%d", &devnum);
+
+	if (devnum > max_device || devnum < 0)
+		return NULL;
+
+	asprintf(&filename, "%s/%s%d",
+		 DEV_INPUT_EVENT, EVENT_DEV_NAME,
+		 devnum);
+
+	return filename;
+}
+
+static int version(void)
+{
+#ifndef PACKAGE_VERSION
+#define PACKAGE_VERSION "<version undefined>"
+#endif
+	printf("%s %s\n", program_invocation_short_name, PACKAGE_VERSION);
+	return EXIT_SUCCESS;
+}
+
+
+/**
+ * Print usage information.
+ */
+static int usage(void)
+{
+	printf("USAGE:\n");
+	printf(" Capture mode:\n");
+	printf("   %s [--grab] /dev/input/eventX\n", program_invocation_short_name);
+	printf("     --grab  grab the device for exclusive access\n");
+	printf("\n");
+	printf(" Query mode: (check exit code)\n");
+	printf("   %s --query /dev/input/eventX <type> <value>\n",
+		program_invocation_short_name);
+
+	printf("\n");
+	printf("<type> is one of: EV_KEY, EV_SW, EV_LED, EV_SND\n");
+	printf("<value> can either be a numerical value, or the textual name of the\n");
+	printf("key/switch/LED/sound being queried (e.g. SW_DOCK).\n");
+
+	return EXIT_FAILURE;
+}
+
+/**
+ * Print additional information for absolute axes (min/max, current value,
+ * etc.).
+ *
+ * @param fd The file descriptor to the device.
+ * @param axis The axis identifier (e.g. ABS_X).
+ */
+static void print_absdata(int fd, int axis)
+{
+	int abs[6] = {0};
+	int k;
+
+	ioctl(fd, EVIOCGABS(axis), abs);
+	for (k = 0; k < 6; k++)
+		if ((k < 3) || abs[k])
+			printf("      %s %6d\n", absval[k], abs[k]);
+}
+
+static void print_repdata(int fd)
+{
+	int i;
+	unsigned int rep[2];
+
+	ioctl(fd, EVIOCGREP, rep);
+
+	for (i = 0; i <= REP_MAX; i++) {
+		printf("    Repeat code %d (%s)\n", i, names[EV_REP] ? (names[EV_REP][i] ? names[EV_REP][i] : "?") : "?");
+		printf("      Value %6d\n", rep[i]);
+	}
+
+}
+
+static inline const char* typename(unsigned int type)
+{
+	return (type <= EV_MAX && events[type]) ? events[type] : "?";
+}
+
+static inline const char* codename(unsigned int type, unsigned int code)
+{
+	return (type <= EV_MAX && code <= maxval[type] && names[type] && names[type][code]) ? names[type][code] : "?";
+}
+
+#ifdef INPUT_PROP_SEMI_MT
+static inline const char* propname(unsigned int prop)
+{
+	return (prop <= INPUT_PROP_MAX && props[prop]) ? props[prop] : "?";
+}
+#endif
+
+static int get_state(int fd, unsigned int type, unsigned long *array, size_t size)
+{
+	int rc;
+
+	switch(type) {
+	case EV_LED:
+		rc = ioctl(fd, EVIOCGLED(size), array);
+		break;
+	case EV_SND:
+		rc = ioctl(fd, EVIOCGSND(size), array);
+		break;
+	case EV_SW:
+		rc = ioctl(fd, EVIOCGSW(size), array);
+		break;
+	case EV_KEY:
+		/* intentionally not printing the value for EV_KEY, let the
+		 * repeat handle this */
+	default:
+		return 1;
+	}
+	if (rc == -1)
+		return 1;
+
+	return 0;
+}
+
+/**
+ * Print static device information (no events). This information includes
+ * version numbers, device name and all bits supported by this device.
+ *
+ * @param fd The file descriptor to the device.
+ * @return 0 on success or 1 otherwise.
+ */
+static int print_device_info(int fd)
+{
+	unsigned int type, code;
+	int version;
+	unsigned short id[4];
+	char name[256] = "Unknown";
+	unsigned long bit[EV_MAX][NBITS(KEY_MAX)];
+	unsigned long state[KEY_CNT] = {0};
+#ifdef INPUT_PROP_SEMI_MT
+	unsigned int prop;
+	unsigned long propbits[INPUT_PROP_MAX];
+#endif
+	int stateval;
+	int have_state;
+
+	if (ioctl(fd, EVIOCGVERSION, &version)) {
+		perror("evtest: can't get version");
+		return 1;
+	}
+
+	printf("Input driver version is %d.%d.%d\n",
+		version >> 16, (version >> 8) & 0xff, version & 0xff);
+
+	ioctl(fd, EVIOCGID, id);
+	printf("Input device ID: bus 0x%x vendor 0x%x product 0x%x version 0x%x\n",
+		id[ID_BUS], id[ID_VENDOR], id[ID_PRODUCT], id[ID_VERSION]);
+
+	ioctl(fd, EVIOCGNAME(sizeof(name)), name);
+	printf("Input device name: \"%s\"\n", name);
+
+	memset(bit, 0, sizeof(bit));
+	ioctl(fd, EVIOCGBIT(0, EV_MAX), bit[0]);
+	printf("Supported events:\n");
+
+	for (type = 0; type < EV_MAX; type++) {
+		if (test_bit(type, bit[0]) && type != EV_REP) {
+			have_state = (get_state(fd, type, state, sizeof(state)) == 0);
+
+			printf("  Event type %d (%s)\n", type, typename(type));
+			if (type == EV_SYN) continue;
+			ioctl(fd, EVIOCGBIT(type, KEY_MAX), bit[type]);
+			for (code = 0; code < KEY_MAX; code++)
+				if (test_bit(code, bit[type])) {
+					if (have_state) {
+						stateval = test_bit(code, state);
+						printf("    Event code %d (%s) state %d\n",
+						       code, codename(type, code), stateval);
+					} else {
+						printf("    Event code %d (%s)\n", code, codename(type, code));
+					}
+					if (type == EV_ABS)
+						print_absdata(fd, code);
+				}
+		}
+	}
+
+	if (test_bit(EV_REP, bit[0])) {
+		printf("Key repeat handling:\n");
+		printf("  Repeat type %d (%s)\n", EV_REP, events[EV_REP] ?  events[EV_REP] : "?");
+		print_repdata(fd);
+	}
+#ifdef INPUT_PROP_SEMI_MT
+	memset(propbits, 0, sizeof(propbits));
+	ioctl(fd, EVIOCGPROP(sizeof(propbits)), propbits);
+	printf("Properties:\n");
+	for (prop = 0; prop < INPUT_PROP_MAX; prop++) {
+		if (test_bit(prop, propbits))
+			printf("  Property type %d (%s)\n", prop, propname(prop));
+	}
+#endif
+
+	return 0;
+}
+
+/**
+ * Print device events as they come in.
+ *
+ * @param fd The file descriptor to the device.
+ * @return 0 on success or 1 otherwise.
+ */
+static int print_events(int fd)
+{
+	struct input_event ev[64];
+	int i, rd;
+	fd_set rdfs;
+
+	FD_ZERO(&rdfs);
+	FD_SET(fd, &rdfs);
+
+	while (!stop) {
+		select(fd + 1, &rdfs, NULL, NULL, NULL);
+		if (stop)
+			break;
+		rd = read(fd, ev, sizeof(ev));
+
+		if (rd < (int) sizeof(struct input_event)) {
+			printf("expected %d bytes, got %d\n", (int) sizeof(struct input_event), rd);
+			perror("\nevtest: error reading");
+			return 1;
+		}
+
+		for (i = 0; i < rd / sizeof(struct input_event); i++) {
+			unsigned int type, code;
+
+			type = ev[i].type;
+			code = ev[i].code;
+
+			printf("Event: time %ld.%06ld, ", ev[i].time.tv_sec, ev[i].time.tv_usec);
+
+			if (type == EV_SYN) {
+				if (code == SYN_MT_REPORT)
+					printf("++++++++++++++ %s ++++++++++++\n", codename(type, code));
+				else if (code == SYN_DROPPED)
+					printf(">>>>>>>>>>>>>> %s <<<<<<<<<<<<\n", codename(type, code));
+				else
+					printf("-------------- %s ------------\n", codename(type, code));
+			} else {
+				printf("type %d (%s), code %d (%s), ",
+					type, typename(type),
+					code, codename(type, code));
+				if (type == EV_MSC && (code == MSC_RAW || code == MSC_SCAN))
+					printf("value %02x\n", ev[i].value);
+				else
+					printf("value %d\n", ev[i].value);
+			}
+		}
+
+	}
+
+	ioctl(fd, EVIOCGRAB, (void*)0);
+	return EXIT_SUCCESS;
+}
+
+/**
+ * Grab and immediately ungrab the device.
+ *
+ * @param fd The file descriptor to the device.
+ * @return 0 if the grab was successful, or 1 otherwise.
+ */
+static int test_grab(int fd, int grab_flag)
+{
+	int rc;
+
+	rc = ioctl(fd, EVIOCGRAB, (void*)1);
+
+	if (rc == 0 && !grab_flag)
+		ioctl(fd, EVIOCGRAB, (void*)0);
+
+	return rc;
+}
+
+/**
+ * Enter capture mode. The requested event device will be monitored, and any
+ * captured events will be decoded and printed on the console.
+ *
+ * @param device The device to monitor, or NULL if the user should be prompted.
+ * @return 0 on success, non-zero on error.
+ */
+static int do_capture(const char *device, int grab_flag)
+{
+	int fd;
+	char *filename = NULL;
+
+	if (!device) {
+		fprintf(stderr, "No device specified, trying to scan all of %s/%s*\n",
+			DEV_INPUT_EVENT, EVENT_DEV_NAME);
+
+		if (getuid() != 0)
+			fprintf(stderr, "Not running as root, no devices may be available.\n");
+
+		filename = scan_devices();
+		if (!filename)
+			return usage();
+	} else
+		filename = strdup(device);
+
+	if (!filename)
+		return EXIT_FAILURE;
+
+	if ((fd = open(filename, O_RDONLY)) < 0) {
+		perror("evtest");
+		if (errno == EACCES && getuid() != 0)
+			fprintf(stderr, "You do not have access to %s. Try "
+					"running as root instead.\n",
+					filename);
+		goto error;
+	}
+
+	if (!isatty(fileno(stdout)))
+		setbuf(stdout, NULL);
+
+	if (print_device_info(fd))
+		goto error;
+
+	printf("Testing ... (interrupt to exit)\n");
+
+	if (test_grab(fd, grab_flag))
+	{
+		printf("***********************************************\n");
+		printf("  This device is grabbed by another process.\n");
+		printf("  No events are available to evtest while the\n"
+		       "  other grab is active.\n");
+		printf("  In most cases, this is caused by an X driver,\n"
+		       "  try VT-switching and re-run evtest again.\n");
+		printf("  Run the following command to see processes with\n"
+		       "  an open fd on this device\n"
+		       " \"fuser -v %s\"\n", filename);
+		printf("***********************************************\n");
+	}
+
+	signal(SIGINT, interrupt_handler);
+	signal(SIGTERM, interrupt_handler);
+
+	free(filename);
+
+	return print_events(fd);
+
+error:
+	free(filename);
+	return EXIT_FAILURE;
+}
+
+/**
+ * Perform a one-shot state query on a specific device. The query can be of
+ * any known mode, on any valid keycode.
+ *
+ * @param device Path to the evdev device node that should be queried.
+ * @param query_mode The event type that is being queried (e.g. key, switch)
+ * @param keycode The code of the key/switch/sound/LED to be queried
+ * @return 0 if the state bit is unset, 10 if the state bit is set, 1 on error.
+ */
+static int query_device(const char *device, const struct query_mode *query_mode, int keycode)
+{
+	int fd;
+	int r;
+	unsigned long state[NBITS(query_mode->max)];
+
+	fd = open(device, O_RDONLY);
+	if (fd < 0) {
+		perror("open");
+		return EXIT_FAILURE;
+	}
+	memset(state, 0, sizeof(state));
+	r = ioctl(fd, query_mode->rq, state);
+	close(fd);
+
+	if (r == -1) {
+		perror("ioctl");
+		return EXIT_FAILURE;
+	}
+
+	if (test_bit(keycode, state))
+		return 10; /* different from EXIT_FAILURE */
+	else
+		return 0;
+}
+
+/**
+ * Enter query mode. The requested event device will be queried for the state
+ * of a particular switch/key/sound/LED.
+ *
+ * @param device The device to query.
+ * @param mode The mode (event type) that is to be queried (snd, sw, key, led)
+ * @param keycode The key code to query the state of.
+ * @return 0 if the state bit is unset, 10 if the state bit is set.
+ */
+static int do_query(const char *device, const char *event_type, const char *keyname)
+{
+	const struct query_mode *query_mode;
+	int keycode;
+
+	if (!device) {
+		fprintf(stderr, "Device argument is required for query.\n");
+		return usage();
+	}
+
+	query_mode = find_query_mode(event_type);
+	if (!query_mode) {
+		fprintf(stderr, "Unrecognised event type: %s\n", event_type);
+		return usage();
+	}
+
+	keycode = get_keycode(query_mode, keyname);
+	if (keycode < 0) {
+		fprintf(stderr, "Unrecognised key name: %s\n", keyname);
+		return usage();
+	} else if (keycode > query_mode->max) {
+		fprintf(stderr, "Key %d is out of bounds.\n", keycode);
+		return EXIT_FAILURE;
+	}
+
+	return query_device(device, query_mode, keycode);
+}
+
+static const struct option long_options[] = {
+	{ "grab", no_argument, &grab_flag, 1 },
+	{ "query", no_argument, NULL, MODE_QUERY },
+	{ "version", no_argument, NULL, MODE_VERSION },
+	{ 0, },
+};
+
+int main (int argc, char **argv)
+{
+	const char *device = NULL;
+	const char *keyname;
+	const char *event_type;
+	enum evtest_mode mode = MODE_CAPTURE;
+
+	while (1) {
+		int option_index = 0;
+		int c = getopt_long(argc, argv, "", long_options, &option_index);
+		if (c == -1)
+			break;
+		switch (c) {
+		case 0:
+			break;
+		case MODE_QUERY:
+			mode = c;
+			break;
+		case MODE_VERSION:
+			return version();
+		default:
+			return usage();
+		}
+	}
+
+	if (optind < argc)
+		device = argv[optind++];
+
+	if (mode == MODE_CAPTURE)
+		return do_capture(device, grab_flag);
+
+	if ((argc - optind) < 2) {
+		fprintf(stderr, "Query mode requires device, type and key parameters\n");
+		return usage();
+	}
+
+	event_type = argv[optind++];
+	keyname = argv[optind++];
+	return do_query(device, event_type, keyname);
+}
+
+/* vim: set noexpandtab tabstop=8 shiftwidth=8: */
diff --git a/evtest/make.inc b/evtest/make.inc
new file mode 100644
index 0000000..9132dea
--- /dev/null
+++ b/evtest/make.inc
@@ -0,0 +1,38 @@
+##
+## unit_test/linux/iio/make.inc
+##
+## History:
+##    2016/06/23 - [Cao Rongrong] Created file
+##
+## Copyright (C) 2011-2015, Ambarella, Inc.
+##
+## All rights reserved. No Part of this file may be reproduced, stored
+## in a retrieval system, or transmitted, in any form, or by any means,
+## electronic, mechanical, photocopying, recording, or otherwise,
+## without the prior consent of Ambarella, Inc.
+##
+
+ifeq ($(BUILD_AMBARELLA_UNIT_TESTS_EVTEST), y)
+
+LOCAL_PATH	:= $(call my-dir)
+
+
+###
+include $(CLEAR_VARS)
+
+LOCAL_TARGET	:= evtest
+LOCAL_SRCS	:= $(LOCAL_PATH)/evtest.c
+
+include $(BUILD_APP)
+
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(UNIT_TEST_PATH)/
+	@cp -dpRf $< $(UNIT_TEST_PATH)/
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+
+endif
+
diff --git a/evtest/readme.txt b/evtest/readme.txt
new file mode 100644
index 0000000..0e9cea0
--- /dev/null
+++ b/evtest/readme.txt
@@ -0,0 +1,12 @@
+https://cgit.freedesktop.org/evtest/
+
+$LINUX/Documentation/arm/ambarella/ir.txt
+
+For IR-keys, you have to select the decoder first. E.g.
+1) modprobe ir-ambarella
+2) cat /sys/class/rc/rc0/protocols
+3) echo nec > /sys/class/rc/rc0/protocols
+4) evtest
+
+Note: if you want to see the "Repeat" Key, you have to setup the key map first.
+
diff --git a/ide/test_ide.c b/ide/test_ide.c
index 60bf4bc..8ce5c00 100644
--- a/ide/test_ide.c
+++ b/ide/test_ide.c
@@ -1,86 +1,86 @@
-/*
- * test_ide.c
- *
- * History:
- *	2008/11/05 - [Cao Rongrong] created file
- *
- * Copyright (C) 2007-2008, Ambarella, Inc.
- *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
- *
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <time.h>
-
-#define LOOP_EXT	1000
-#define LOOP_INN	25
-#define SLEEP_TIME	10000
-
-void usage(void)
-{
-	printf("\nThis program is used to test IDE disk.\n"
-		"You should mount IDE disk to /tmp/ide first.\n"
-		"mkdir /tmp/ide; mount -t vfat /dev/hda1 /tmp/ide\n");
-}
-
-int main(int argc,char *argv[])
-{
-	int i, j;
-	FILE *fd;
-	char *buf = malloc(4096);
-	time_t tm_begin, tm_end;
-	float spd;
-
-	if(argc > 1){
-		usage();
-		return 1;
-	}
-
-	for(i = 0; i < 4096; i++){
-		*(buf+i) = i;
-	}
-
-	fd = fopen("/tmp/ide/tmp_file", "w+");
-	if(fd == NULL) {
-		fprintf(stderr, "Can't create or write file!\n"
-			"You may mount IDE disk to /tmp/ide first!\n"
-			"mkdir /tmp/ide; mount -t vfat /dev/hda1 /tmp/ide\n");
-                exit(1);
-	}
-
-	time(&tm_begin);
-	fprintf(stderr, "%s", ctime(&tm_begin));
-
-	for(j = 0; j < LOOP_EXT; j++){
-		for(i = 0; i < LOOP_INN; i++){
-			fwrite(buf, 4096, 1, fd);
-		}
-		usleep(SLEEP_TIME);
-	}
-
-	fsync(fileno(fd));
-
-	time(&tm_end);
-	fprintf(stderr, "%s", ctime(&tm_end));
-
-	spd = (4096 * LOOP_EXT * LOOP_INN) /
-		(tm_end - tm_begin - LOOP_EXT * SLEEP_TIME / 1000000);
-	fprintf(stderr, "IDE transfer speed is %.2f MB/s\n", spd / 1000000);
-
-	if (fd > 0)
-		fclose(fd);
-	if (buf)
-		free(buf);
-	return 0;
-}
-
-
+/*
+ * test_ide.c
+ *
+ * History:
+ *	2008/11/05 - [Cao Rongrong] created file
+ *
+ * Copyright (C) 2007-2008, Ambarella, Inc.
+ *
+ * All rights reserved. No Part of this file may be reproduced, stored
+ * in a retrieval system, or transmitted, in any form, or by any means,
+ * electronic, mechanical, photocopying, recording, or otherwise,
+ * without the prior consent of Ambarella, Inc.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <time.h>
+
+#define LOOP_EXT	1000
+#define LOOP_INN	25
+#define SLEEP_TIME	10000
+
+void usage(void)
+{
+	printf("\nThis program is used to test IDE disk.\n"
+		"You should mount IDE disk to /tmp/ide first.\n"
+		"mkdir /tmp/ide; mount -t vfat /dev/hda1 /tmp/ide\n");
+}
+
+int main(int argc,char *argv[])
+{
+	int i, j;
+	FILE *fd;
+	char *buf = malloc(4096);
+	time_t tm_begin, tm_end;
+	float spd;
+
+	if(argc > 1){
+		usage();
+		return 1;
+	}
+
+	for(i = 0; i < 4096; i++){
+		*(buf+i) = i;
+	}
+
+	fd = fopen("/tmp/ide/tmp_file", "w+");
+	if(fd == NULL) {
+		fprintf(stderr, "Can't create or write file!\n"
+			"You may mount IDE disk to /tmp/ide first!\n"
+			"mkdir /tmp/ide; mount -t vfat /dev/hda1 /tmp/ide\n");
+                exit(1);
+	}
+
+	time(&tm_begin);
+	fprintf(stderr, "%s", ctime(&tm_begin));
+
+	for(j = 0; j < LOOP_EXT; j++){
+		for(i = 0; i < LOOP_INN; i++){
+			fwrite(buf, 4096, 1, fd);
+		}
+		usleep(SLEEP_TIME);
+	}
+
+	fsync(fileno(fd));
+
+	time(&tm_end);
+	fprintf(stderr, "%s", ctime(&tm_end));
+
+	spd = (4096 * LOOP_EXT * LOOP_INN) /
+		(tm_end - tm_begin - LOOP_EXT * SLEEP_TIME / 1000000);
+	fprintf(stderr, "IDE transfer speed is %.2f MB/s\n", spd / 1000000);
+
+	if (fd > 0)
+		fclose(fd);
+	if (buf)
+		free(buf);
+	return 0;
+}
+
+
diff --git a/iio/events.h b/iio/events.h
new file mode 100644
index 0000000..edfcaf0
--- /dev/null
+++ b/iio/events.h
@@ -0,0 +1,42 @@
+/* The industrial I/O - event passing to userspace
+ *
+ * Copyright (c) 2008-2011 Jonathan Cameron
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+#ifndef _IIO_EVENTS_H_
+#define _IIO_EVENTS_H_
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+/**
+ * struct iio_event_data - The actual event being pushed to userspace
+ * @id:		event identifier
+ * @timestamp:	best estimate of time of event occurrence (often from
+ *		the interrupt handler)
+ */
+struct iio_event_data {
+	__u64	id;
+	__s64	timestamp;
+};
+
+#define IIO_GET_EVENT_FD_IOCTL _IOR('i', 0x90, int)
+
+#define IIO_EVENT_CODE_EXTRACT_TYPE(mask) ((mask >> 56) & 0xFF)
+
+#define IIO_EVENT_CODE_EXTRACT_DIR(mask) ((mask >> 48) & 0x7F)
+
+#define IIO_EVENT_CODE_EXTRACT_CHAN_TYPE(mask) ((mask >> 32) & 0xFF)
+
+/* Event code number extraction depends on which type of event we have.
+ * Perhaps review this function in the future*/
+#define IIO_EVENT_CODE_EXTRACT_CHAN(mask) ((__s16)(mask & 0xFFFF))
+#define IIO_EVENT_CODE_EXTRACT_CHAN2(mask) ((__s16)(((mask) >> 16) & 0xFFFF))
+
+#define IIO_EVENT_CODE_EXTRACT_MODIFIER(mask) ((mask >> 40) & 0xFF)
+#define IIO_EVENT_CODE_EXTRACT_DIFF(mask) (((mask) >> 55) & 0x1)
+
+#endif /* _IIO_EVENTS_H_ */
diff --git a/iio/iio_event_monitor.c b/iio/iio_event_monitor.c
new file mode 100644
index 0000000..849f63f
--- /dev/null
+++ b/iio/iio_event_monitor.c
@@ -0,0 +1,350 @@
+/* Industrialio event test code.
+ *
+ * Copyright (c) 2011-2012 Lars-Peter Clausen <lars@metafoo.de>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is primarily intended as an example application.
+ * Reads the current buffer setup from sysfs and starts a short capture
+ * from the specified device, pretty printing the result after appropriate
+ * conversion.
+ *
+ * Usage:
+ *	iio_event_monitor <device_name>
+ */
+
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <errno.h>
+#include <string.h>
+#include <poll.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include "iio_utils.h"
+#include "events.h"
+#include "types.h"
+
+static const char * const iio_chan_type_name_spec[] = {
+	[IIO_VOLTAGE] = "voltage",
+	[IIO_CURRENT] = "current",
+	[IIO_POWER] = "power",
+	[IIO_ACCEL] = "accel",
+	[IIO_ANGL_VEL] = "anglvel",
+	[IIO_MAGN] = "magn",
+	[IIO_LIGHT] = "illuminance",
+	[IIO_INTENSITY] = "intensity",
+	[IIO_PROXIMITY] = "proximity",
+	[IIO_TEMP] = "temp",
+	[IIO_INCLI] = "incli",
+	[IIO_ROT] = "rot",
+	[IIO_ANGL] = "angl",
+	[IIO_TIMESTAMP] = "timestamp",
+	[IIO_CAPACITANCE] = "capacitance",
+	[IIO_ALTVOLTAGE] = "altvoltage",
+	[IIO_CCT] = "cct",
+	[IIO_PRESSURE] = "pressure",
+	[IIO_HUMIDITYRELATIVE] = "humidityrelative",
+	[IIO_ACTIVITY] = "activity",
+	[IIO_STEPS] = "steps",
+	[IIO_ENERGY] = "energy",
+	[IIO_DISTANCE] = "distance",
+	[IIO_VELOCITY] = "velocity",
+	[IIO_CONCENTRATION] = "concentration",
+	[IIO_RESISTANCE] = "resistance",
+	[IIO_PH] = "ph",
+	[IIO_UVINDEX] = "uvindex",
+};
+
+static const char * const iio_ev_type_text[] = {
+	[IIO_EV_TYPE_THRESH] = "thresh",
+	[IIO_EV_TYPE_MAG] = "mag",
+	[IIO_EV_TYPE_ROC] = "roc",
+	[IIO_EV_TYPE_THRESH_ADAPTIVE] = "thresh_adaptive",
+	[IIO_EV_TYPE_MAG_ADAPTIVE] = "mag_adaptive",
+	[IIO_EV_TYPE_CHANGE] = "change",
+};
+
+static const char * const iio_ev_dir_text[] = {
+	[IIO_EV_DIR_EITHER] = "either",
+	[IIO_EV_DIR_RISING] = "rising",
+	[IIO_EV_DIR_FALLING] = "falling"
+};
+
+static const char * const iio_modifier_names[] = {
+	[IIO_MOD_X] = "x",
+	[IIO_MOD_Y] = "y",
+	[IIO_MOD_Z] = "z",
+	[IIO_MOD_X_AND_Y] = "x&y",
+	[IIO_MOD_X_AND_Z] = "x&z",
+	[IIO_MOD_Y_AND_Z] = "y&z",
+	[IIO_MOD_X_AND_Y_AND_Z] = "x&y&z",
+	[IIO_MOD_X_OR_Y] = "x|y",
+	[IIO_MOD_X_OR_Z] = "x|z",
+	[IIO_MOD_Y_OR_Z] = "y|z",
+	[IIO_MOD_X_OR_Y_OR_Z] = "x|y|z",
+	[IIO_MOD_LIGHT_BOTH] = "both",
+	[IIO_MOD_LIGHT_IR] = "ir",
+	[IIO_MOD_ROOT_SUM_SQUARED_X_Y] = "sqrt(x^2+y^2)",
+	[IIO_MOD_SUM_SQUARED_X_Y_Z] = "x^2+y^2+z^2",
+	[IIO_MOD_LIGHT_CLEAR] = "clear",
+	[IIO_MOD_LIGHT_RED] = "red",
+	[IIO_MOD_LIGHT_GREEN] = "green",
+	[IIO_MOD_LIGHT_BLUE] = "blue",
+	[IIO_MOD_LIGHT_UV] = "uv",
+	[IIO_MOD_QUATERNION] = "quaternion",
+	[IIO_MOD_TEMP_AMBIENT] = "ambient",
+	[IIO_MOD_TEMP_OBJECT] = "object",
+	[IIO_MOD_NORTH_MAGN] = "from_north_magnetic",
+	[IIO_MOD_NORTH_TRUE] = "from_north_true",
+	[IIO_MOD_NORTH_MAGN_TILT_COMP] = "from_north_magnetic_tilt_comp",
+	[IIO_MOD_NORTH_TRUE_TILT_COMP] = "from_north_true_tilt_comp",
+	[IIO_MOD_RUNNING] = "running",
+	[IIO_MOD_JOGGING] = "jogging",
+	[IIO_MOD_WALKING] = "walking",
+	[IIO_MOD_STILL] = "still",
+	[IIO_MOD_ROOT_SUM_SQUARED_X_Y_Z] = "sqrt(x^2+y^2+z^2)",
+	[IIO_MOD_I] = "i",
+	[IIO_MOD_Q] = "q",
+	[IIO_MOD_CO2] = "co2",
+	[IIO_MOD_VOC] = "voc",
+};
+
+static bool event_is_known(struct iio_event_data *event)
+{
+	enum iio_chan_type type = IIO_EVENT_CODE_EXTRACT_CHAN_TYPE(event->id);
+	enum iio_modifier mod = IIO_EVENT_CODE_EXTRACT_MODIFIER(event->id);
+	enum iio_event_type ev_type = IIO_EVENT_CODE_EXTRACT_TYPE(event->id);
+	enum iio_event_direction dir = IIO_EVENT_CODE_EXTRACT_DIR(event->id);
+
+	switch (type) {
+	case IIO_VOLTAGE:
+	case IIO_CURRENT:
+	case IIO_POWER:
+	case IIO_ACCEL:
+	case IIO_ANGL_VEL:
+	case IIO_MAGN:
+	case IIO_LIGHT:
+	case IIO_INTENSITY:
+	case IIO_PROXIMITY:
+	case IIO_TEMP:
+	case IIO_INCLI:
+	case IIO_ROT:
+	case IIO_ANGL:
+	case IIO_TIMESTAMP:
+	case IIO_CAPACITANCE:
+	case IIO_ALTVOLTAGE:
+	case IIO_CCT:
+	case IIO_PRESSURE:
+	case IIO_HUMIDITYRELATIVE:
+	case IIO_ACTIVITY:
+	case IIO_STEPS:
+	case IIO_ENERGY:
+	case IIO_DISTANCE:
+	case IIO_VELOCITY:
+	case IIO_CONCENTRATION:
+	case IIO_RESISTANCE:
+	case IIO_PH:
+	case IIO_UVINDEX:
+		break;
+	default:
+		return false;
+	}
+
+	switch (mod) {
+	case IIO_NO_MOD:
+	case IIO_MOD_X:
+	case IIO_MOD_Y:
+	case IIO_MOD_Z:
+	case IIO_MOD_X_AND_Y:
+	case IIO_MOD_X_AND_Z:
+	case IIO_MOD_Y_AND_Z:
+	case IIO_MOD_X_AND_Y_AND_Z:
+	case IIO_MOD_X_OR_Y:
+	case IIO_MOD_X_OR_Z:
+	case IIO_MOD_Y_OR_Z:
+	case IIO_MOD_X_OR_Y_OR_Z:
+	case IIO_MOD_LIGHT_BOTH:
+	case IIO_MOD_LIGHT_IR:
+	case IIO_MOD_ROOT_SUM_SQUARED_X_Y:
+	case IIO_MOD_SUM_SQUARED_X_Y_Z:
+	case IIO_MOD_LIGHT_CLEAR:
+	case IIO_MOD_LIGHT_RED:
+	case IIO_MOD_LIGHT_GREEN:
+	case IIO_MOD_LIGHT_BLUE:
+	case IIO_MOD_LIGHT_UV:
+	case IIO_MOD_QUATERNION:
+	case IIO_MOD_TEMP_AMBIENT:
+	case IIO_MOD_TEMP_OBJECT:
+	case IIO_MOD_NORTH_MAGN:
+	case IIO_MOD_NORTH_TRUE:
+	case IIO_MOD_NORTH_MAGN_TILT_COMP:
+	case IIO_MOD_NORTH_TRUE_TILT_COMP:
+	case IIO_MOD_RUNNING:
+	case IIO_MOD_JOGGING:
+	case IIO_MOD_WALKING:
+	case IIO_MOD_STILL:
+	case IIO_MOD_ROOT_SUM_SQUARED_X_Y_Z:
+	case IIO_MOD_I:
+	case IIO_MOD_Q:
+	case IIO_MOD_CO2:
+	case IIO_MOD_VOC:
+		break;
+	default:
+		return false;
+	}
+
+	switch (ev_type) {
+	case IIO_EV_TYPE_THRESH:
+	case IIO_EV_TYPE_MAG:
+	case IIO_EV_TYPE_ROC:
+	case IIO_EV_TYPE_THRESH_ADAPTIVE:
+	case IIO_EV_TYPE_MAG_ADAPTIVE:
+	case IIO_EV_TYPE_CHANGE:
+		break;
+	default:
+		return false;
+	}
+
+	switch (dir) {
+	case IIO_EV_DIR_EITHER:
+	case IIO_EV_DIR_RISING:
+	case IIO_EV_DIR_FALLING:
+	case IIO_EV_DIR_NONE:
+		break;
+	default:
+		return false;
+	}
+
+	return true;
+}
+
+static void print_event(struct iio_event_data *event)
+{
+	enum iio_chan_type type = IIO_EVENT_CODE_EXTRACT_CHAN_TYPE(event->id);
+	enum iio_modifier mod = IIO_EVENT_CODE_EXTRACT_MODIFIER(event->id);
+	enum iio_event_type ev_type = IIO_EVENT_CODE_EXTRACT_TYPE(event->id);
+	enum iio_event_direction dir = IIO_EVENT_CODE_EXTRACT_DIR(event->id);
+	int chan = IIO_EVENT_CODE_EXTRACT_CHAN(event->id);
+	int chan2 = IIO_EVENT_CODE_EXTRACT_CHAN2(event->id);
+	bool diff = IIO_EVENT_CODE_EXTRACT_DIFF(event->id);
+
+	if (!event_is_known(event)) {
+		fprintf(stderr, "Unknown event: time: %lld, id: %llx\n",
+			event->timestamp, event->id);
+
+		return;
+	}
+
+	printf("Event: time: %lld, type: %s", event->timestamp,
+	       iio_chan_type_name_spec[type]);
+
+	if (mod != IIO_NO_MOD)
+		printf("(%s)", iio_modifier_names[mod]);
+
+	if (chan >= 0) {
+		printf(", channel: %d", chan);
+		if (diff && chan2 >= 0)
+			printf("-%d", chan2);
+	}
+
+	printf(", evtype: %s", iio_ev_type_text[ev_type]);
+
+	if (dir != IIO_EV_DIR_NONE)
+		printf(", direction: %s", iio_ev_dir_text[dir]);
+
+	printf("\n");
+}
+
+int main(int argc, char **argv)
+{
+	struct iio_event_data event;
+	const char *device_name;
+	char *chrdev_name;
+	int ret;
+	int dev_num;
+	int fd, event_fd;
+
+	if (argc <= 1) {
+		fprintf(stderr, "Usage: %s <device_name>\n", argv[0]);
+		return -1;
+	}
+
+	device_name = argv[1];
+
+	dev_num = find_type_by_name(device_name, "iio:device");
+	if (dev_num >= 0) {
+		printf("Found IIO device with name %s with device number %d\n",
+		       device_name, dev_num);
+		ret = asprintf(&chrdev_name, "/dev/iio:device%d", dev_num);
+		if (ret < 0)
+			return -ENOMEM;
+	} else {
+		/*
+		 * If we can't find an IIO device by name assume device_name is
+		 * an IIO chrdev
+		 */
+		chrdev_name = strdup(device_name);
+		if (!chrdev_name)
+			return -ENOMEM;
+	}
+
+	fd = open(chrdev_name, 0);
+	if (fd == -1) {
+		ret = -errno;
+		fprintf(stderr, "Failed to open %s\n", chrdev_name);
+		goto error_free_chrdev_name;
+	}
+
+	ret = ioctl(fd, IIO_GET_EVENT_FD_IOCTL, &event_fd);
+	if (ret == -1 || event_fd == -1) {
+		ret = -errno;
+		if (ret == -ENODEV)
+			fprintf(stderr,
+				"This device does not support events\n");
+		else
+			fprintf(stderr, "Failed to retrieve event fd\n");
+		if (close(fd) == -1)
+			perror("Failed to close character device file");
+
+		goto error_free_chrdev_name;
+	}
+
+	if (close(fd) == -1)  {
+		ret = -errno;
+		goto error_free_chrdev_name;
+	}
+
+	while (true) {
+		ret = read(event_fd, &event, sizeof(event));
+		if (ret == -1) {
+			if (errno == EAGAIN) {
+				fprintf(stderr, "nothing available\n");
+				continue;
+			} else {
+				ret = -errno;
+				perror("Failed to read event from device");
+				break;
+			}
+		}
+
+		if (ret != sizeof(event)) {
+			fprintf(stderr, "Reading event failed!\n");
+			ret = -EIO;
+			break;
+		}
+
+		print_event(&event);
+	}
+
+	if (close(event_fd) == -1)
+		perror("Failed to close event file");
+
+error_free_chrdev_name:
+	free(chrdev_name);
+
+	return ret;
+}
diff --git a/iio/iio_generic_buffer.c b/iio/iio_generic_buffer.c
new file mode 100644
index 0000000..01c4f67
--- /dev/null
+++ b/iio/iio_generic_buffer.c
@@ -0,0 +1,475 @@
+/* Industrialio buffer test code.
+ *
+ * Copyright (c) 2008 Jonathan Cameron
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is primarily intended as an example application.
+ * Reads the current buffer setup from sysfs and starts a short capture
+ * from the specified device, pretty printing the result after appropriate
+ * conversion.
+ *
+ * Command line parameters
+ * generic_buffer -n <device_name> -t <trigger_name>
+ * If trigger name is not specified the program assumes you want a dataready
+ * trigger associated with the device and goes looking for it.
+ *
+ */
+
+#include <unistd.h>
+#include <stdlib.h>
+#include <dirent.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <sys/dir.h>
+#include <linux/types.h>
+#include <string.h>
+#include <poll.h>
+#include <endian.h>
+#include <getopt.h>
+#include <inttypes.h>
+#include "iio_utils.h"
+
+/**
+ * size_from_channelarray() - calculate the storage size of a scan
+ * @channels:		the channel info array
+ * @num_channels:	number of channels
+ *
+ * Has the side effect of filling the channels[i].location values used
+ * in processing the buffer output.
+ **/
+int size_from_channelarray(struct iio_channel_info *channels, int num_channels)
+{
+	int bytes = 0;
+	int i = 0;
+
+	while (i < num_channels) {
+		if (bytes % channels[i].bytes == 0)
+			channels[i].location = bytes;
+		else
+			channels[i].location = bytes - bytes % channels[i].bytes
+					       + channels[i].bytes;
+
+		bytes = channels[i].location + channels[i].bytes;
+		i++;
+	}
+
+	return bytes;
+}
+
+void print1byte(uint8_t input, struct iio_channel_info *info)
+{
+	/*
+	 * Shift before conversion to avoid sign extension
+	 * of left aligned data
+	 */
+	input >>= info->shift;
+	input &= info->mask;
+	if (info->is_signed) {
+		int8_t val = (int8_t)(input << (8 - info->bits_used)) >>
+			     (8 - info->bits_used);
+		printf("%05f ", ((float)val + info->offset) * info->scale);
+	} else {
+		printf("%05f ", ((float)input + info->offset) * info->scale);
+	}
+}
+
+void print2byte(uint16_t input, struct iio_channel_info *info)
+{
+	/* First swap if incorrect endian */
+	if (info->be)
+		input = be16toh(input);
+	else
+		input = le16toh(input);
+
+	/*
+	 * Shift before conversion to avoid sign extension
+	 * of left aligned data
+	 */
+	input >>= info->shift;
+	input &= info->mask;
+	if (info->is_signed) {
+		int16_t val = (int16_t)(input << (16 - info->bits_used)) >>
+			      (16 - info->bits_used);
+		printf("%05f ", ((float)val + info->offset) * info->scale);
+	} else {
+		printf("%05f ", ((float)input + info->offset) * info->scale);
+	}
+}
+
+void print4byte(uint32_t input, struct iio_channel_info *info)
+{
+	/* First swap if incorrect endian */
+	if (info->be)
+		input = be32toh(input);
+	else
+		input = le32toh(input);
+
+	/*
+	 * Shift before conversion to avoid sign extension
+	 * of left aligned data
+	 */
+	input >>= info->shift;
+	input &= info->mask;
+	if (info->is_signed) {
+		int32_t val = (int32_t)(input << (32 - info->bits_used)) >>
+			      (32 - info->bits_used);
+		printf("%05f ", ((float)val + info->offset) * info->scale);
+	} else {
+		printf("%05f ", ((float)input + info->offset) * info->scale);
+	}
+}
+
+void print8byte(uint64_t input, struct iio_channel_info *info)
+{
+	/* First swap if incorrect endian */
+	if (info->be)
+		input = be64toh(input);
+	else
+		input = le64toh(input);
+
+	/*
+	 * Shift before conversion to avoid sign extension
+	 * of left aligned data
+	 */
+	input >>= info->shift;
+	input &= info->mask;
+	if (info->is_signed) {
+		int64_t val = (int64_t)(input << (64 - info->bits_used)) >>
+			      (64 - info->bits_used);
+		/* special case for timestamp */
+		if (info->scale == 1.0f && info->offset == 0.0f)
+			printf("%" PRId64 " ", val);
+		else
+			printf("%05f ",
+			       ((float)val + info->offset) * info->scale);
+	} else {
+		printf("%05f ", ((float)input + info->offset) * info->scale);
+	}
+}
+
+/**
+ * process_scan() - print out the values in SI units
+ * @data:		pointer to the start of the scan
+ * @channels:		information about the channels.
+ *			Note: size_from_channelarray must have been called first
+ *			      to fill the location offsets.
+ * @num_channels:	number of channels
+ **/
+void process_scan(char *data,
+		  struct iio_channel_info *channels,
+		  int num_channels)
+{
+	int k;
+
+	for (k = 0; k < num_channels; k++)
+		switch (channels[k].bytes) {
+			/* only a few cases implemented so far */
+		case 1:
+			print1byte(*(uint8_t *)(data + channels[k].location),
+				   &channels[k]);
+			break;
+		case 2:
+			print2byte(*(uint16_t *)(data + channels[k].location),
+				   &channels[k]);
+			break;
+		case 4:
+			print4byte(*(uint32_t *)(data + channels[k].location),
+				   &channels[k]);
+			break;
+		case 8:
+			print8byte(*(uint64_t *)(data + channels[k].location),
+				   &channels[k]);
+			break;
+		default:
+			break;
+		}
+	printf("\n");
+}
+
+void print_usage(void)
+{
+	fprintf(stderr, "Usage: generic_buffer [options]...\n"
+		"Capture, convert and output data from IIO device buffer\n"
+		"  -c <n>     Do n conversions\n"
+		"  -e         Disable wait for event (new data)\n"
+		"  -g         Use trigger-less mode\n"
+		"  -l <n>     Set buffer length to n samples\n"
+		"  -n <name>  Set device name (mandatory)\n"
+		"  -t <name>  Set trigger name\n"
+		"  -w <n>     Set delay between reads in us (event-less mode)\n");
+}
+
+int main(int argc, char **argv)
+{
+	unsigned long num_loops = 2;
+	unsigned long timedelay = 1000000;
+	unsigned long buf_len = 128;
+
+	int ret, c, i, j, toread;
+	int fp;
+
+	int num_channels;
+	char *trigger_name = NULL, *device_name = NULL;
+	char *dev_dir_name, *buf_dir_name;
+
+	int datardytrigger = 1;
+	char *data;
+	ssize_t read_size;
+	int dev_num, trig_num;
+	char *buffer_access;
+	int scan_size;
+	int noevents = 0;
+	int notrigger = 0;
+	char *dummy;
+
+	struct iio_channel_info *channels;
+
+	while ((c = getopt(argc, argv, "c:egl:n:t:w:")) != -1) {
+		switch (c) {
+		case 'c':
+			errno = 0;
+			num_loops = strtoul(optarg, &dummy, 10);
+			if (errno)
+				return -errno;
+
+			break;
+		case 'e':
+			noevents = 1;
+			break;
+		case 'g':
+			notrigger = 1;
+			break;
+		case 'l':
+			errno = 0;
+			buf_len = strtoul(optarg, &dummy, 10);
+			if (errno)
+				return -errno;
+
+			break;
+		case 'n':
+			device_name = optarg;
+			break;
+		case 't':
+			trigger_name = optarg;
+			datardytrigger = 0;
+			break;
+		case 'w':
+			errno = 0;
+			timedelay = strtoul(optarg, &dummy, 10);
+			if (errno)
+				return -errno;
+			break;
+		case '?':
+			print_usage();
+			return -1;
+		}
+	}
+
+	if (!device_name) {
+		fprintf(stderr, "Device name not set\n");
+		print_usage();
+		return -1;
+	}
+
+	/* Find the device requested */
+	dev_num = find_type_by_name(device_name, "iio:device");
+	if (dev_num < 0) {
+		fprintf(stderr, "Failed to find the %s\n", device_name);
+		return dev_num;
+	}
+
+	printf("iio device number being used is %d\n", dev_num);
+
+	ret = asprintf(&dev_dir_name, "%siio:device%d", iio_dir, dev_num);
+	if (ret < 0)
+		return -ENOMEM;
+
+	if (!notrigger) {
+		if (!trigger_name) {
+			/*
+			 * Build the trigger name. If it is device associated
+			 * its name is <device_name>_dev[n] where n matches
+			 * the device number found above.
+			 */
+			ret = asprintf(&trigger_name,
+				       "%s-dev%d", device_name, dev_num);
+			if (ret < 0) {
+				ret = -ENOMEM;
+				goto error_free_dev_dir_name;
+			}
+		}
+
+		/* Verify the trigger exists */
+		trig_num = find_type_by_name(trigger_name, "trigger");
+		if (trig_num < 0) {
+			fprintf(stderr, "Failed to find the trigger %s\n",
+				trigger_name);
+			ret = trig_num;
+			goto error_free_triggername;
+		}
+
+		printf("iio trigger number being used is %d\n", trig_num);
+	} else {
+		printf("trigger-less mode selected\n");
+	}
+
+	/*
+	 * Parse the files in scan_elements to identify what channels are
+	 * present
+	 */
+	ret = build_channel_array(dev_dir_name, &channels, &num_channels);
+	if (ret) {
+		fprintf(stderr, "Problem reading scan element information\n"
+			"diag %s\n", dev_dir_name);
+		goto error_free_triggername;
+	}
+	if (!num_channels) {
+		fprintf(stderr,
+			"No channels are enabled, we have nothing to scan.\n");
+		fprintf(stderr, "Enable channels manually in "
+			FORMAT_SCAN_ELEMENTS_DIR
+			"/*_en and try again.\n", dev_dir_name);
+		ret = -ENOENT;
+		goto error_free_triggername;
+	}
+
+	/*
+	 * Construct the directory name for the associated buffer.
+	 * As we know that the lis3l02dq has only one buffer this may
+	 * be built rather than found.
+	 */
+	ret = asprintf(&buf_dir_name,
+		       "%siio:device%d/buffer", iio_dir, dev_num);
+	if (ret < 0) {
+		ret = -ENOMEM;
+		goto error_free_channels;
+	}
+
+	if (!notrigger) {
+		printf("%s %s\n", dev_dir_name, trigger_name);
+		/*
+		 * Set the device trigger to be the data ready trigger found
+		 * above
+		 */
+		ret = write_sysfs_string_and_verify("trigger/current_trigger",
+						    dev_dir_name,
+						    trigger_name);
+		if (ret < 0) {
+			fprintf(stderr,
+				"Failed to write current_trigger file\n");
+			goto error_free_buf_dir_name;
+		}
+	}
+
+	/* Setup ring buffer parameters */
+	ret = write_sysfs_int("length", buf_dir_name, buf_len);
+	if (ret < 0)
+		goto error_free_buf_dir_name;
+
+	/* Enable the buffer */
+	ret = write_sysfs_int("enable", buf_dir_name, 1);
+	if (ret < 0) {
+		fprintf(stderr,
+			"Failed to enable buffer: %s\n", strerror(-ret));
+		goto error_free_buf_dir_name;
+	}
+
+	scan_size = size_from_channelarray(channels, num_channels);
+	data = malloc(scan_size * buf_len);
+	if (!data) {
+		ret = -ENOMEM;
+		goto error_free_buf_dir_name;
+	}
+
+	ret = asprintf(&buffer_access, "/dev/iio:device%d", dev_num);
+	if (ret < 0) {
+		ret = -ENOMEM;
+		goto error_free_data;
+	}
+
+	/* Attempt to open non blocking the access dev */
+	fp = open(buffer_access, O_RDONLY | O_NONBLOCK);
+	if (fp == -1) { /* TODO: If it isn't there make the node */
+		ret = -errno;
+		fprintf(stderr, "Failed to open %s\n", buffer_access);
+		goto error_free_buffer_access;
+	}
+
+	for (j = 0; j < num_loops; j++) {
+		if (!noevents) {
+			struct pollfd pfd = {
+				.fd = fp,
+				.events = POLLIN,
+			};
+
+			ret = poll(&pfd, 1, -1);
+			if (ret < 0) {
+				ret = -errno;
+				goto error_close_buffer_access;
+			} else if (ret == 0) {
+				continue;
+			}
+
+			toread = buf_len;
+		} else {
+			usleep(timedelay);
+			toread = 64;
+		}
+
+		read_size = read(fp, data, toread * scan_size);
+		if (read_size < 0) {
+			if (errno == EAGAIN) {
+				fprintf(stderr, "nothing available\n");
+				continue;
+			} else {
+				break;
+			}
+		}
+		for (i = 0; i < read_size / scan_size; i++)
+			process_scan(data + scan_size * i, channels,
+				     num_channels);
+	}
+
+	/* Stop the buffer */
+	ret = write_sysfs_int("enable", buf_dir_name, 0);
+	if (ret < 0)
+		goto error_close_buffer_access;
+
+	if (!notrigger)
+		/* Disconnect the trigger - just write a dummy name. */
+		ret = write_sysfs_string("trigger/current_trigger",
+					 dev_dir_name, "NULL");
+		if (ret < 0)
+			fprintf(stderr, "Failed to write to %s\n",
+				dev_dir_name);
+
+error_close_buffer_access:
+	if (close(fp) == -1)
+		perror("Failed to close buffer");
+
+error_free_buffer_access:
+	free(buffer_access);
+error_free_data:
+	free(data);
+error_free_buf_dir_name:
+	free(buf_dir_name);
+error_free_channels:
+	for (i = num_channels - 1; i >= 0; i--) {
+		free(channels[i].name);
+		free(channels[i].generic_name);
+	}
+	free(channels);
+error_free_triggername:
+	if (datardytrigger)
+		free(trigger_name);
+
+error_free_dev_dir_name:
+	free(dev_dir_name);
+
+	return ret;
+}
diff --git a/iio/iio_utils.c b/iio/iio_utils.c
new file mode 100644
index 0000000..5eb6793
--- /dev/null
+++ b/iio/iio_utils.c
@@ -0,0 +1,991 @@
+/* IIO - useful set of util functionality
+ *
+ * Copyright (c) 2008 Jonathan Cameron
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <dirent.h>
+#include <errno.h>
+#include <ctype.h>
+#include "iio_utils.h"
+
+const char *iio_dir = "/sys/bus/iio/devices/";
+
+static char * const iio_direction[] = {
+	"in",
+	"out",
+};
+
+/**
+ * iioutils_break_up_name() - extract generic name from full channel name
+ * @full_name: the full channel name
+ * @generic_name: the output generic channel name
+ *
+ * Returns 0 on success, or a negative error code if string extraction failed.
+ **/
+int iioutils_break_up_name(const char *full_name, char **generic_name)
+{
+	char *current;
+	char *w, *r;
+	char *working, *prefix = "";
+	int i, ret;
+
+	for (i = 0; i < ARRAY_SIZE(iio_direction); i++)
+		if (!strncmp(full_name, iio_direction[i],
+			     strlen(iio_direction[i]))) {
+			prefix = iio_direction[i];
+			break;
+		}
+
+	current = strdup(full_name + strlen(prefix) + 1);
+	if (!current)
+		return -ENOMEM;
+
+	working = strtok(current, "_\0");
+	if (!working) {
+		free(current);
+		return -EINVAL;
+	}
+
+	w = working;
+	r = working;
+
+	while (*r != '\0') {
+		if (!isdigit(*r)) {
+			*w = *r;
+			w++;
+		}
+
+		r++;
+	}
+	*w = '\0';
+	ret = asprintf(generic_name, "%s_%s", prefix, working);
+	free(current);
+
+	return (ret == -1) ? -ENOMEM : 0;
+}
+
+/**
+ * iioutils_get_type() - find and process _type attribute data
+ * @is_signed: output whether channel is signed
+ * @bytes: output how many bytes the channel storage occupies
+ * @bits_used: output number of valid bits of data
+ * @shift: output amount of bits to shift right data before applying bit mask
+ * @mask: output a bit mask for the raw data
+ * @be: output if data in big endian
+ * @device_dir: the IIO device directory
+ * @name: the channel name
+ * @generic_name: the channel type name
+ *
+ * Returns a value >= 0 on success, otherwise a negative error code.
+ **/
+int iioutils_get_type(unsigned *is_signed, unsigned *bytes, unsigned *bits_used,
+		      unsigned *shift, uint64_t *mask, unsigned *be,
+		      const char *device_dir, const char *name,
+		      const char *generic_name)
+{
+	FILE *sysfsfp;
+	int ret;
+	DIR *dp;
+	char *scan_el_dir, *builtname, *builtname_generic, *filename = 0;
+	char signchar, endianchar;
+	unsigned padint;
+	const struct dirent *ent;
+
+	ret = asprintf(&scan_el_dir, FORMAT_SCAN_ELEMENTS_DIR, device_dir);
+	if (ret < 0)
+		return -ENOMEM;
+
+	ret = asprintf(&builtname, FORMAT_TYPE_FILE, name);
+	if (ret < 0) {
+		ret = -ENOMEM;
+		goto error_free_scan_el_dir;
+	}
+	ret = asprintf(&builtname_generic, FORMAT_TYPE_FILE, generic_name);
+	if (ret < 0) {
+		ret = -ENOMEM;
+		goto error_free_builtname;
+	}
+
+	dp = opendir(scan_el_dir);
+	if (!dp) {
+		ret = -errno;
+		goto error_free_builtname_generic;
+	}
+
+	ret = -ENOENT;
+	while (ent = readdir(dp), ent)
+		/*
+		 * Do we allow devices to override a generic name with
+		 * a specific one?
+		 */
+		if ((strcmp(builtname, ent->d_name) == 0) ||
+		    (strcmp(builtname_generic, ent->d_name) == 0)) {
+			ret = asprintf(&filename,
+				       "%s/%s", scan_el_dir, ent->d_name);
+			if (ret < 0) {
+				ret = -ENOMEM;
+				goto error_closedir;
+			}
+
+			sysfsfp = fopen(filename, "r");
+			if (!sysfsfp) {
+				ret = -errno;
+				fprintf(stderr, "failed to open %s\n",
+					filename);
+				goto error_free_filename;
+			}
+
+			ret = fscanf(sysfsfp,
+				     "%ce:%c%u/%u>>%u",
+				     &endianchar,
+				     &signchar,
+				     bits_used,
+				     &padint, shift);
+			if (ret < 0) {
+				ret = -errno;
+				fprintf(stderr,
+					"failed to pass scan type description\n");
+				goto error_close_sysfsfp;
+			} else if (ret != 5) {
+				ret = -EIO;
+				fprintf(stderr,
+					"scan type description didn't match\n");
+				goto error_close_sysfsfp;
+			}
+
+			*be = (endianchar == 'b');
+			*bytes = padint / 8;
+			if (*bits_used == 64)
+				*mask = ~0;
+			else
+				*mask = (1ULL << *bits_used) - 1;
+
+			*is_signed = (signchar == 's');
+			if (fclose(sysfsfp)) {
+				ret = -errno;
+				fprintf(stderr, "Failed to close %s\n",
+					filename);
+				goto error_free_filename;
+			}
+
+			sysfsfp = 0;
+			free(filename);
+			filename = 0;
+		}
+
+error_close_sysfsfp:
+	if (sysfsfp)
+		if (fclose(sysfsfp))
+			perror("iioutils_get_type(): Failed to close file");
+
+error_free_filename:
+	if (filename)
+		free(filename);
+
+error_closedir:
+	if (closedir(dp) == -1)
+		perror("iioutils_get_type(): Failed to close directory");
+
+error_free_builtname_generic:
+	free(builtname_generic);
+error_free_builtname:
+	free(builtname);
+error_free_scan_el_dir:
+	free(scan_el_dir);
+
+	return ret;
+}
+
+/**
+ * iioutils_get_param_float() - read a float value from a channel parameter
+ * @output: output the float value
+ * @param_name: the parameter name to read
+ * @device_dir: the IIO device directory in sysfs
+ * @name: the channel name
+ * @generic_name: the channel type name
+ *
+ * Returns a value >= 0 on success, otherwise a negative error code.
+ **/
+int iioutils_get_param_float(float *output, const char *param_name,
+			     const char *device_dir, const char *name,
+			     const char *generic_name)
+{
+	FILE *sysfsfp;
+	int ret;
+	DIR *dp;
+	char *builtname, *builtname_generic;
+	char *filename = NULL;
+	const struct dirent *ent;
+
+	ret = asprintf(&builtname, "%s_%s", name, param_name);
+	if (ret < 0)
+		return -ENOMEM;
+
+	ret = asprintf(&builtname_generic,
+		       "%s_%s", generic_name, param_name);
+	if (ret < 0) {
+		ret = -ENOMEM;
+		goto error_free_builtname;
+	}
+
+	dp = opendir(device_dir);
+	if (!dp) {
+		ret = -errno;
+		goto error_free_builtname_generic;
+	}
+
+	ret = -ENOENT;
+	while (ent = readdir(dp), ent)
+		if ((strcmp(builtname, ent->d_name) == 0) ||
+		    (strcmp(builtname_generic, ent->d_name) == 0)) {
+			ret = asprintf(&filename,
+				       "%s/%s", device_dir, ent->d_name);
+			if (ret < 0) {
+				ret = -ENOMEM;
+				goto error_closedir;
+			}
+
+			sysfsfp = fopen(filename, "r");
+			if (!sysfsfp) {
+				ret = -errno;
+				goto error_free_filename;
+			}
+
+			errno = 0;
+			if (fscanf(sysfsfp, "%f", output) != 1)
+				ret = errno ? -errno : -ENODATA;
+
+			break;
+		}
+error_free_filename:
+	if (filename)
+		free(filename);
+
+error_closedir:
+	if (closedir(dp) == -1)
+		perror("iioutils_get_param_float(): Failed to close directory");
+
+error_free_builtname_generic:
+	free(builtname_generic);
+error_free_builtname:
+	free(builtname);
+
+	return ret;
+}
+
+/**
+ * bsort_channel_array_by_index() - sort the array in index order
+ * @ci_array: the iio_channel_info array to be sorted
+ * @cnt: the amount of array elements
+ **/
+
+void bsort_channel_array_by_index(struct iio_channel_info *ci_array, int cnt)
+{
+	struct iio_channel_info temp;
+	int x, y;
+
+	for (x = 0; x < cnt; x++)
+		for (y = 0; y < (cnt - 1); y++)
+			if (ci_array[y].index > ci_array[y + 1].index) {
+				temp = ci_array[y + 1];
+				ci_array[y + 1] = ci_array[y];
+				ci_array[y] = temp;
+			}
+}
+
+/**
+ * build_channel_array() - function to figure out what channels are present
+ * @device_dir: the IIO device directory in sysfs
+ * @ci_array: output the resulting array of iio_channel_info
+ * @counter: output the amount of array elements
+ *
+ * Returns 0 on success, otherwise a negative error code.
+ **/
+int build_channel_array(const char *device_dir,
+			struct iio_channel_info **ci_array, int *counter)
+{
+	DIR *dp;
+	FILE *sysfsfp;
+	int count = 0, i;
+	struct iio_channel_info *current;
+	int ret;
+	const struct dirent *ent;
+	char *scan_el_dir;
+	char *filename;
+
+	*counter = 0;
+	ret = asprintf(&scan_el_dir, FORMAT_SCAN_ELEMENTS_DIR, device_dir);
+	if (ret < 0)
+		return -ENOMEM;
+
+	dp = opendir(scan_el_dir);
+	if (!dp) {
+		ret = -errno;
+		goto error_free_name;
+	}
+
+	while (ent = readdir(dp), ent)
+		if (strcmp(ent->d_name + strlen(ent->d_name) - strlen("_en"),
+			   "_en") == 0) {
+			ret = asprintf(&filename,
+				       "%s/%s", scan_el_dir, ent->d_name);
+			if (ret < 0) {
+				ret = -ENOMEM;
+				goto error_close_dir;
+			}
+
+			sysfsfp = fopen(filename, "r");
+			if (!sysfsfp) {
+				ret = -errno;
+				free(filename);
+				goto error_close_dir;
+			}
+
+			errno = 0;
+			if (fscanf(sysfsfp, "%i", &ret) != 1) {
+				ret = errno ? -errno : -ENODATA;
+				if (fclose(sysfsfp))
+					perror("build_channel_array(): Failed to close file");
+
+				free(filename);
+				goto error_close_dir;
+			}
+			if (ret == 1)
+				(*counter)++;
+
+			if (fclose(sysfsfp)) {
+				ret = -errno;
+				free(filename);
+				goto error_close_dir;
+			}
+
+			free(filename);
+		}
+
+	*ci_array = malloc(sizeof(**ci_array) * (*counter));
+	if (!*ci_array) {
+		ret = -ENOMEM;
+		goto error_close_dir;
+	}
+
+	seekdir(dp, 0);
+	while (ent = readdir(dp), ent) {
+		if (strcmp(ent->d_name + strlen(ent->d_name) - strlen("_en"),
+			   "_en") == 0) {
+			int current_enabled = 0;
+
+			current = &(*ci_array)[count++];
+			ret = asprintf(&filename,
+				       "%s/%s", scan_el_dir, ent->d_name);
+			if (ret < 0) {
+				ret = -ENOMEM;
+				/* decrement count to avoid freeing name */
+				count--;
+				goto error_cleanup_array;
+			}
+
+			sysfsfp = fopen(filename, "r");
+			if (!sysfsfp) {
+				ret = -errno;
+				free(filename);
+				count--;
+				goto error_cleanup_array;
+			}
+
+			errno = 0;
+			if (fscanf(sysfsfp, "%i", &current_enabled) != 1) {
+				ret = errno ? -errno : -ENODATA;
+				free(filename);
+				count--;
+				goto error_cleanup_array;
+			}
+
+			if (fclose(sysfsfp)) {
+				ret = -errno;
+				free(filename);
+				count--;
+				goto error_cleanup_array;
+			}
+
+			if (!current_enabled) {
+				free(filename);
+				count--;
+				continue;
+			}
+
+			current->scale = 1.0;
+			current->offset = 0;
+			current->name = strndup(ent->d_name,
+						strlen(ent->d_name) -
+						strlen("_en"));
+			if (!current->name) {
+				free(filename);
+				ret = -ENOMEM;
+				count--;
+				goto error_cleanup_array;
+			}
+
+			/* Get the generic and specific name elements */
+			ret = iioutils_break_up_name(current->name,
+						     &current->generic_name);
+			if (ret) {
+				free(filename);
+				free(current->name);
+				count--;
+				goto error_cleanup_array;
+			}
+
+			ret = asprintf(&filename,
+				       "%s/%s_index",
+				       scan_el_dir,
+				       current->name);
+			if (ret < 0) {
+				free(filename);
+				ret = -ENOMEM;
+				goto error_cleanup_array;
+			}
+
+			sysfsfp = fopen(filename, "r");
+			if (!sysfsfp) {
+				ret = -errno;
+				fprintf(stderr, "failed to open %s\n",
+					filename);
+				free(filename);
+				goto error_cleanup_array;
+			}
+
+			errno = 0;
+			if (fscanf(sysfsfp, "%u", &current->index) != 1) {
+				ret = errno ? -errno : -ENODATA;
+				if (fclose(sysfsfp))
+					perror("build_channel_array(): Failed to close file");
+
+				free(filename);
+				goto error_cleanup_array;
+			}
+
+			if (fclose(sysfsfp)) {
+				ret = -errno;
+				free(filename);
+				goto error_cleanup_array;
+			}
+
+			free(filename);
+			/* Find the scale */
+			ret = iioutils_get_param_float(&current->scale,
+						       "scale",
+						       device_dir,
+						       current->name,
+						       current->generic_name);
+			if ((ret < 0) && (ret != -ENOENT))
+				goto error_cleanup_array;
+
+			ret = iioutils_get_param_float(&current->offset,
+						       "offset",
+						       device_dir,
+						       current->name,
+						       current->generic_name);
+			if ((ret < 0) && (ret != -ENOENT))
+				goto error_cleanup_array;
+
+			ret = iioutils_get_type(&current->is_signed,
+						&current->bytes,
+						&current->bits_used,
+						&current->shift,
+						&current->mask,
+						&current->be,
+						device_dir,
+						current->name,
+						current->generic_name);
+			if (ret < 0)
+				goto error_cleanup_array;
+		}
+	}
+
+	if (closedir(dp) == -1) {
+		ret = -errno;
+		goto error_cleanup_array;
+	}
+
+	free(scan_el_dir);
+	/* reorder so that the array is in index order */
+	bsort_channel_array_by_index(*ci_array, *counter);
+
+	return 0;
+
+error_cleanup_array:
+	for (i = count - 1;  i >= 0; i--) {
+		free((*ci_array)[i].name);
+		free((*ci_array)[i].generic_name);
+	}
+	free(*ci_array);
+	*ci_array = NULL;
+	*counter = 0;
+error_close_dir:
+	if (dp)
+		if (closedir(dp) == -1)
+			perror("build_channel_array(): Failed to close dir");
+
+error_free_name:
+	free(scan_el_dir);
+
+	return ret;
+}
+
+static int calc_digits(int num)
+{
+	int count = 0;
+
+	while (num != 0) {
+		num /= 10;
+		count++;
+	}
+
+	return count;
+}
+
+/**
+ * find_type_by_name() - function to match top level types by name
+ * @name: top level type instance name
+ * @type: the type of top level instance being searched
+ *
+ * Returns the device number of a matched IIO device on success, otherwise a
+ * negative error code.
+ * Typical types this is used for are device and trigger.
+ **/
+int find_type_by_name(const char *name, const char *type)
+{
+	const struct dirent *ent;
+	int number, numstrlen, ret;
+
+	FILE *namefp;
+	DIR *dp;
+	char thisname[IIO_MAX_NAME_LENGTH];
+	char *filename;
+
+	dp = opendir(iio_dir);
+	if (!dp) {
+		fprintf(stderr, "No industrialio devices available\n");
+		return -ENODEV;
+	}
+
+	while (ent = readdir(dp), ent) {
+		if (strcmp(ent->d_name, ".") != 0 &&
+		    strcmp(ent->d_name, "..") != 0 &&
+		    strlen(ent->d_name) > strlen(type) &&
+		    strncmp(ent->d_name, type, strlen(type)) == 0) {
+			errno = 0;
+			ret = sscanf(ent->d_name + strlen(type), "%d", &number);
+			if (ret < 0) {
+				ret = -errno;
+				fprintf(stderr,
+					"failed to read element number\n");
+				goto error_close_dir;
+			} else if (ret != 1) {
+				ret = -EIO;
+				fprintf(stderr,
+					"failed to match element number\n");
+				goto error_close_dir;
+			}
+
+			numstrlen = calc_digits(number);
+			/* verify the next character is not a colon */
+			if (strncmp(ent->d_name + strlen(type) + numstrlen,
+			    ":", 1) != 0) {
+				filename = malloc(strlen(iio_dir) + strlen(type)
+						  + numstrlen + 6);
+				if (!filename) {
+					ret = -ENOMEM;
+					goto error_close_dir;
+				}
+
+				ret = sprintf(filename, "%s%s%d/name", iio_dir,
+					      type, number);
+				if (ret < 0) {
+					free(filename);
+					goto error_close_dir;
+				}
+
+				namefp = fopen(filename, "r");
+				if (!namefp) {
+					free(filename);
+					continue;
+				}
+
+				free(filename);
+				errno = 0;
+				if (fscanf(namefp, "%s", thisname) != 1) {
+					ret = errno ? -errno : -ENODATA;
+					goto error_close_dir;
+				}
+
+				if (fclose(namefp)) {
+					ret = -errno;
+					goto error_close_dir;
+				}
+
+				if (strcmp(name, thisname) == 0) {
+					if (closedir(dp) == -1)
+						return -errno;
+
+					return number;
+				}
+			}
+		}
+	}
+	if (closedir(dp) == -1)
+		return -errno;
+
+	return -ENODEV;
+
+error_close_dir:
+	if (closedir(dp) == -1)
+		perror("find_type_by_name(): Failed to close directory");
+
+	return ret;
+}
+
+static int _write_sysfs_int(const char *filename, const char *basedir, int val,
+			    int verify)
+{
+	int ret = 0;
+	FILE *sysfsfp;
+	int test;
+	char *temp = malloc(strlen(basedir) + strlen(filename) + 2);
+
+	if (!temp)
+		return -ENOMEM;
+
+	ret = sprintf(temp, "%s/%s", basedir, filename);
+	if (ret < 0)
+		goto error_free;
+
+	sysfsfp = fopen(temp, "w");
+	if (!sysfsfp) {
+		ret = -errno;
+		fprintf(stderr, "failed to open %s\n", temp);
+		goto error_free;
+	}
+
+	ret = fprintf(sysfsfp, "%d", val);
+	if (ret < 0) {
+		if (fclose(sysfsfp))
+			perror("_write_sysfs_int(): Failed to close dir");
+
+		goto error_free;
+	}
+
+	if (fclose(sysfsfp)) {
+		ret = -errno;
+		goto error_free;
+	}
+
+	if (verify) {
+		sysfsfp = fopen(temp, "r");
+		if (!sysfsfp) {
+			ret = -errno;
+			fprintf(stderr, "failed to open %s\n", temp);
+			goto error_free;
+		}
+
+		if (fscanf(sysfsfp, "%d", &test) != 1) {
+			ret = errno ? -errno : -ENODATA;
+			if (fclose(sysfsfp))
+				perror("_write_sysfs_int(): Failed to close dir");
+
+			goto error_free;
+		}
+
+		if (fclose(sysfsfp)) {
+			ret = -errno;
+			goto error_free;
+		}
+
+		if (test != val) {
+			fprintf(stderr,
+				"Possible failure in int write %d to %s/%s\n",
+				val, basedir, filename);
+			ret = -1;
+		}
+	}
+
+error_free:
+	free(temp);
+	return ret;
+}
+
+/**
+ * write_sysfs_int() - write an integer value to a sysfs file
+ * @filename: name of the file to write to
+ * @basedir: the sysfs directory in which the file is to be found
+ * @val: integer value to write to file
+ *
+ * Returns a value >= 0 on success, otherwise a negative error code.
+ **/
+int write_sysfs_int(const char *filename, const char *basedir, int val)
+{
+	return _write_sysfs_int(filename, basedir, val, 0);
+}
+
+/**
+ * write_sysfs_int_and_verify() - write an integer value to a sysfs file
+ *				  and verify
+ * @filename: name of the file to write to
+ * @basedir: the sysfs directory in which the file is to be found
+ * @val: integer value to write to file
+ *
+ * Returns a value >= 0 on success, otherwise a negative error code.
+ **/
+int write_sysfs_int_and_verify(const char *filename, const char *basedir,
+			       int val)
+{
+	return _write_sysfs_int(filename, basedir, val, 1);
+}
+
+static int _write_sysfs_string(const char *filename, const char *basedir,
+			       const char *val, int verify)
+{
+	int ret = 0;
+	FILE  *sysfsfp;
+	char *temp = malloc(strlen(basedir) + strlen(filename) + 2);
+
+	if (!temp) {
+		fprintf(stderr, "Memory allocation failed\n");
+		return -ENOMEM;
+	}
+
+	ret = sprintf(temp, "%s/%s", basedir, filename);
+	if (ret < 0)
+		goto error_free;
+
+	sysfsfp = fopen(temp, "w");
+	if (!sysfsfp) {
+		ret = -errno;
+		fprintf(stderr, "Could not open %s\n", temp);
+		goto error_free;
+	}
+
+	ret = fprintf(sysfsfp, "%s", val);
+	if (ret < 0) {
+		if (fclose(sysfsfp))
+			perror("_write_sysfs_string(): Failed to close dir");
+
+		goto error_free;
+	}
+
+	if (fclose(sysfsfp)) {
+		ret = -errno;
+		goto error_free;
+	}
+
+	if (verify) {
+		sysfsfp = fopen(temp, "r");
+		if (!sysfsfp) {
+			ret = -errno;
+			fprintf(stderr, "Could not open file to verify\n");
+			goto error_free;
+		}
+
+		if (fscanf(sysfsfp, "%s", temp) != 1) {
+			ret = errno ? -errno : -ENODATA;
+			if (fclose(sysfsfp))
+				perror("_write_sysfs_string(): Failed to close dir");
+
+			goto error_free;
+		}
+
+		if (fclose(sysfsfp)) {
+			ret = -errno;
+			goto error_free;
+		}
+
+		if (strcmp(temp, val) != 0) {
+			fprintf(stderr,
+				"Possible failure in string write of %s "
+				"Should be %s written to %s/%s\n", temp, val,
+				basedir, filename);
+			ret = -1;
+		}
+	}
+
+error_free:
+	free(temp);
+
+	return ret;
+}
+
+/**
+ * write_sysfs_string_and_verify() - string write, readback and verify
+ * @filename: name of file to write to
+ * @basedir: the sysfs directory in which the file is to be found
+ * @val: the string to write
+ *
+ * Returns a value >= 0 on success, otherwise a negative error code.
+ **/
+int write_sysfs_string_and_verify(const char *filename, const char *basedir,
+				  const char *val)
+{
+	return _write_sysfs_string(filename, basedir, val, 1);
+}
+
+/**
+ * write_sysfs_string() - write string to a sysfs file
+ * @filename: name of file to write to
+ * @basedir: the sysfs directory in which the file is to be found
+ * @val: the string to write
+ *
+ * Returns a value >= 0 on success, otherwise a negative error code.
+ **/
+int write_sysfs_string(const char *filename, const char *basedir,
+		       const char *val)
+{
+	return _write_sysfs_string(filename, basedir, val, 0);
+}
+
+/**
+ * read_sysfs_posint() - read an integer value from file
+ * @filename: name of file to read from
+ * @basedir: the sysfs directory in which the file is to be found
+ *
+ * Returns the read integer value >= 0 on success, otherwise a negative error
+ * code.
+ **/
+int read_sysfs_posint(const char *filename, const char *basedir)
+{
+	int ret;
+	FILE  *sysfsfp;
+	char *temp = malloc(strlen(basedir) + strlen(filename) + 2);
+
+	if (!temp) {
+		fprintf(stderr, "Memory allocation failed");
+		return -ENOMEM;
+	}
+
+	ret = sprintf(temp, "%s/%s", basedir, filename);
+	if (ret < 0)
+		goto error_free;
+
+	sysfsfp = fopen(temp, "r");
+	if (!sysfsfp) {
+		ret = -errno;
+		goto error_free;
+	}
+
+	errno = 0;
+	if (fscanf(sysfsfp, "%d\n", &ret) != 1) {
+		ret = errno ? -errno : -ENODATA;
+		if (fclose(sysfsfp))
+			perror("read_sysfs_posint(): Failed to close dir");
+
+		goto error_free;
+	}
+
+	if (fclose(sysfsfp))
+		ret = -errno;
+
+error_free:
+	free(temp);
+
+	return ret;
+}
+
+/**
+ * read_sysfs_float() - read a float value from file
+ * @filename: name of file to read from
+ * @basedir: the sysfs directory in which the file is to be found
+ * @val: output the read float value
+ *
+ * Returns a value >= 0 on success, otherwise a negative error code.
+ **/
+int read_sysfs_float(const char *filename, const char *basedir, float *val)
+{
+	int ret = 0;
+	FILE  *sysfsfp;
+	char *temp = malloc(strlen(basedir) + strlen(filename) + 2);
+
+	if (!temp) {
+		fprintf(stderr, "Memory allocation failed");
+		return -ENOMEM;
+	}
+
+	ret = sprintf(temp, "%s/%s", basedir, filename);
+	if (ret < 0)
+		goto error_free;
+
+	sysfsfp = fopen(temp, "r");
+	if (!sysfsfp) {
+		ret = -errno;
+		goto error_free;
+	}
+
+	errno = 0;
+	if (fscanf(sysfsfp, "%f\n", val) != 1) {
+		ret = errno ? -errno : -ENODATA;
+		if (fclose(sysfsfp))
+			perror("read_sysfs_float(): Failed to close dir");
+
+		goto error_free;
+	}
+
+	if (fclose(sysfsfp))
+		ret = -errno;
+
+error_free:
+	free(temp);
+
+	return ret;
+}
+
+/**
+ * read_sysfs_string() - read a string from file
+ * @filename: name of file to read from
+ * @basedir: the sysfs directory in which the file is to be found
+ * @str: output the read string
+ *
+ * Returns a value >= 0 on success, otherwise a negative error code.
+ **/
+int read_sysfs_string(const char *filename, const char *basedir, char *str)
+{
+	int ret = 0;
+	FILE  *sysfsfp;
+	char *temp = malloc(strlen(basedir) + strlen(filename) + 2);
+
+	if (!temp) {
+		fprintf(stderr, "Memory allocation failed");
+		return -ENOMEM;
+	}
+
+	ret = sprintf(temp, "%s/%s", basedir, filename);
+	if (ret < 0)
+		goto error_free;
+
+	sysfsfp = fopen(temp, "r");
+	if (!sysfsfp) {
+		ret = -errno;
+		goto error_free;
+	}
+
+	errno = 0;
+	if (fscanf(sysfsfp, "%s\n", str) != 1) {
+		ret = errno ? -errno : -ENODATA;
+		if (fclose(sysfsfp))
+			perror("read_sysfs_string(): Failed to close dir");
+
+		goto error_free;
+	}
+
+	if (fclose(sysfsfp))
+		ret = -errno;
+
+error_free:
+	free(temp);
+
+	return ret;
+}
diff --git a/iio/iio_utils.h b/iio/iio_utils.h
new file mode 100644
index 0000000..e3503bf
--- /dev/null
+++ b/iio/iio_utils.h
@@ -0,0 +1,78 @@
+#ifndef _IIO_UTILS_H_
+#define _IIO_UTILS_H_
+
+/* IIO - useful set of util functionality
+ *
+ * Copyright (c) 2008 Jonathan Cameron
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#include <stdint.h>
+
+/* Made up value to limit allocation sizes */
+#define IIO_MAX_NAME_LENGTH 30
+
+#define FORMAT_SCAN_ELEMENTS_DIR "%s/scan_elements"
+#define FORMAT_TYPE_FILE "%s_type"
+
+#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))
+
+extern const char *iio_dir;
+
+/**
+ * struct iio_channel_info - information about a given channel
+ * @name: channel name
+ * @generic_name: general name for channel type
+ * @scale: scale factor to be applied for conversion to si units
+ * @offset: offset to be applied for conversion to si units
+ * @index: the channel index in the buffer output
+ * @bytes: number of bytes occupied in buffer output
+ * @bits_used: number of valid bits of data
+ * @shift: amount of bits to shift right data before applying bit mask
+ * @mask: a bit mask for the raw output
+ * @be: flag if data is big endian
+ * @is_signed: is the raw value stored signed
+ * @location: data offset for this channel inside the buffer (in bytes)
+ **/
+struct iio_channel_info {
+	char *name;
+	char *generic_name;
+	float scale;
+	float offset;
+	unsigned index;
+	unsigned bytes;
+	unsigned bits_used;
+	unsigned shift;
+	uint64_t mask;
+	unsigned be;
+	unsigned is_signed;
+	unsigned location;
+};
+
+int iioutils_break_up_name(const char *full_name, char **generic_name);
+int iioutils_get_type(unsigned *is_signed, unsigned *bytes, unsigned *bits_used,
+		      unsigned *shift, uint64_t *mask, unsigned *be,
+		      const char *device_dir, const char *name,
+		      const char *generic_name);
+int iioutils_get_param_float(float *output, const char *param_name,
+			     const char *device_dir, const char *name,
+			     const char *generic_name);
+void bsort_channel_array_by_index(struct iio_channel_info *ci_array, int cnt);
+int build_channel_array(const char *device_dir,
+			struct iio_channel_info **ci_array, int *counter);
+int find_type_by_name(const char *name, const char *type);
+int write_sysfs_int(const char *filename, const char *basedir, int val);
+int write_sysfs_int_and_verify(const char *filename, const char *basedir,
+			       int val);
+int write_sysfs_string_and_verify(const char *filename, const char *basedir,
+				  const char *val);
+int write_sysfs_string(const char *filename, const char *basedir,
+		       const char *val);
+int read_sysfs_posint(const char *filename, const char *basedir);
+int read_sysfs_float(const char *filename, const char *basedir, float *val);
+int read_sysfs_string(const char *filename, const char *basedir, char *str);
+
+#endif /* _IIO_UTILS_H_ */
diff --git a/iio/lsiio.c b/iio/lsiio.c
new file mode 100644
index 0000000..3d650e6
--- /dev/null
+++ b/iio/lsiio.c
@@ -0,0 +1,190 @@
+/*
+ * Industrial I/O utilities - lsiio.c
+ *
+ * Copyright (c) 2010 Manuel Stahl <manuel.stahl@iis.fraunhofer.de>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#include <string.h>
+#include <dirent.h>
+#include <stdio.h>
+#include <errno.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/dir.h>
+#include "iio_utils.h"
+
+static enum verbosity {
+	VERBLEVEL_DEFAULT,	/* 0 gives lspci behaviour */
+	VERBLEVEL_SENSORS,	/* 1 lists sensors */
+} verblevel = VERBLEVEL_DEFAULT;
+
+const char *type_device = "iio:device";
+const char *type_trigger = "trigger";
+
+static inline int check_prefix(const char *str, const char *prefix)
+{
+	return strlen(str) > strlen(prefix) &&
+	       strncmp(str, prefix, strlen(prefix)) == 0;
+}
+
+static inline int check_postfix(const char *str, const char *postfix)
+{
+	return strlen(str) > strlen(postfix) &&
+	       strcmp(str + strlen(str) - strlen(postfix), postfix) == 0;
+}
+
+static int dump_channels(const char *dev_dir_name)
+{
+	DIR *dp;
+	const struct dirent *ent;
+
+	dp = opendir(dev_dir_name);
+	if (!dp)
+		return -errno;
+
+	while (ent = readdir(dp), ent)
+		if (check_prefix(ent->d_name, "in_") &&
+		    check_postfix(ent->d_name, "_raw"))
+			printf("   %-10s\n", ent->d_name);
+
+	return (closedir(dp) == -1) ? -errno : 0;
+}
+
+static int dump_one_device(const char *dev_dir_name)
+{
+	char name[IIO_MAX_NAME_LENGTH];
+	int dev_idx;
+	int ret;
+
+	ret = sscanf(dev_dir_name + strlen(iio_dir) + strlen(type_device), "%i",
+		     &dev_idx);
+	if (ret != 1)
+		return -EINVAL;
+
+	ret = read_sysfs_string("name", dev_dir_name, name);
+	if (ret < 0)
+		return ret;
+
+	printf("Device %03d: %s\n", dev_idx, name);
+
+	if (verblevel >= VERBLEVEL_SENSORS)
+		return dump_channels(dev_dir_name);
+
+	return 0;
+}
+
+static int dump_one_trigger(const char *dev_dir_name)
+{
+	char name[IIO_MAX_NAME_LENGTH];
+	int dev_idx;
+	int ret;
+
+	ret = sscanf(dev_dir_name + strlen(iio_dir) + strlen(type_trigger),
+		     "%i", &dev_idx);
+	if (ret != 1)
+		return -EINVAL;
+
+	ret = read_sysfs_string("name", dev_dir_name, name);
+	if (ret < 0)
+		return ret;
+
+	printf("Trigger %03d: %s\n", dev_idx, name);
+
+	return 0;
+}
+
+static int dump_devices(void)
+{
+	const struct dirent *ent;
+	int ret;
+	DIR *dp;
+
+	dp = opendir(iio_dir);
+	if (!dp) {
+		fprintf(stderr, "No industrial I/O devices available\n");
+		return -ENODEV;
+	}
+
+	while (ent = readdir(dp), ent) {
+		if (check_prefix(ent->d_name, type_device)) {
+			char *dev_dir_name;
+
+			if (asprintf(&dev_dir_name, "%s%s", iio_dir,
+				     ent->d_name) < 0) {
+				ret = -ENOMEM;
+				goto error_close_dir;
+			}
+
+			ret = dump_one_device(dev_dir_name);
+			if (ret) {
+				free(dev_dir_name);
+				goto error_close_dir;
+			}
+
+			free(dev_dir_name);
+			if (verblevel >= VERBLEVEL_SENSORS)
+				printf("\n");
+		}
+	}
+	rewinddir(dp);
+	while (ent = readdir(dp), ent) {
+		if (check_prefix(ent->d_name, type_trigger)) {
+			char *dev_dir_name;
+
+			if (asprintf(&dev_dir_name, "%s%s", iio_dir,
+				     ent->d_name) < 0) {
+				ret = -ENOMEM;
+				goto error_close_dir;
+			}
+
+			ret = dump_one_trigger(dev_dir_name);
+			if (ret) {
+				free(dev_dir_name);
+				goto error_close_dir;
+			}
+
+			free(dev_dir_name);
+		}
+	}
+
+	return (closedir(dp) == -1) ? -errno : 0;
+
+error_close_dir:
+	if (closedir(dp) == -1)
+		perror("dump_devices(): Failed to close directory");
+
+	return ret;
+}
+
+int main(int argc, char **argv)
+{
+	int c, err = 0;
+
+	while ((c = getopt(argc, argv, "v")) != EOF) {
+		switch (c) {
+		case 'v':
+			verblevel++;
+			break;
+
+		case '?':
+		default:
+			err++;
+			break;
+		}
+	}
+	if (err || argc > optind) {
+		fprintf(stderr, "Usage: lsiio [options]...\n"
+			"List industrial I/O devices\n"
+			"  -v  Increase verbosity (may be given multiple times)\n");
+		exit(1);
+	}
+
+	return dump_devices();
+}
diff --git a/iio/make.inc b/iio/make.inc
new file mode 100644
index 0000000..ca68a59
--- /dev/null
+++ b/iio/make.inc
@@ -0,0 +1,74 @@
+##
+## unit_test/linux/iio/make.inc
+##
+## History:
+##    2016/06/23 - [Cao Rongrong] Created file
+##
+## Copyright (C) 2011-2015, Ambarella, Inc.
+##
+## All rights reserved. No Part of this file may be reproduced, stored
+## in a retrieval system, or transmitted, in any form, or by any means,
+## electronic, mechanical, photocopying, recording, or otherwise,
+## without the prior consent of Ambarella, Inc.
+##
+
+ifeq ($(BUILD_AMBARELLA_UNIT_TESTS_IIO), y)
+
+LOCAL_PATH	:= $(call my-dir)
+
+
+###
+include $(CLEAR_VARS)
+
+LOCAL_TARGET	:= iio_event_monitor
+LOCAL_SRCS	:= $(LOCAL_PATH)/iio_event_monitor.c $(LOCAL_PATH)/iio_utils.c
+
+include $(BUILD_APP)
+
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(UNIT_TEST_PATH)/
+	@cp -dpRf $< $(UNIT_TEST_PATH)/
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+
+
+###
+include $(CLEAR_VARS)
+
+LOCAL_TARGET	:= lsiio
+LOCAL_SRCS	:= $(LOCAL_PATH)/lsiio.c $(LOCAL_PATH)/iio_utils.c
+
+include $(BUILD_APP)
+
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(UNIT_TEST_PATH)/
+	@cp -dpRf $< $(UNIT_TEST_PATH)/
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+
+
+###
+include $(CLEAR_VARS)
+
+LOCAL_TARGET	:= iio_generic_buffer
+LOCAL_SRCS	:= $(LOCAL_PATH)/iio_generic_buffer.c $(LOCAL_PATH)/iio_utils.c
+
+include $(BUILD_APP)
+
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(UNIT_TEST_PATH)/
+	@cp -dpRf $< $(UNIT_TEST_PATH)/
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+
+endif
+
diff --git a/iio/readme.txt b/iio/readme.txt
new file mode 100644
index 0000000..64e2f56
--- /dev/null
+++ b/iio/readme.txt
@@ -0,0 +1,31 @@
+$LINUX/Documentation/arm/ambarella/adc.txt
+
+
+root@/#lsiio
+Device 000: e801d000.adc
+Trigger 000: e801d000.adc-dev0
+
+
+
+root@/#echo 1 > /sys/bus/iio/devices/iio\:device0/scan_elements/in_voltage1_en
+root@/#echo 1 > /sys/bus/iio/devices/iio\:device0/scan_elements/in_voltage3_en
+root@/#iio_generic_buffer -n e801d000.adc
+iio device number being used is 0
+iio trigger number being used is 0
+/sys/bus/iio/devices/iio:device0 e801d000.adc-dev0
+3299.194336 3299.194336
+3299.194336 3299.194336
+3299.194336 3299.194336
+3299.194336 3299.194336
+...
+
+
+
+root@/#iio_event_monitor e801d000.adc
+Found IIO device with name e801d000.adc with device number 0
+Event: time: 968888270446955, type: voltage, channel: 3, evtype: thresh, direction: either
+Event: time: 968888270454558, type: voltage, channel: 3, evtype: thresh, direction: either
+Event: time: 968888270460012, type: voltage, channel: 3, evtype: thresh, direction: either
+Event: time: 968888270495962, type: voltage, channel: 3, evtype: thresh, direction: either
+Event: time: 968888270506679, type: voltage, channel: 3, evtype: thresh, direction: either
+Event: time: 968888442227487, type: voltage, channel: 3, evtype: thresh, direction: either
diff --git a/iio/types.h b/iio/types.h
new file mode 100644
index 0000000..7bd95b5
--- /dev/null
+++ b/iio/types.h
@@ -0,0 +1,101 @@
+/* industrial I/O data types needed both in and out of kernel
+ *
+ * Copyright (c) 2008 Jonathan Cameron
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#ifndef _IIO_TYPES_H_
+#define _IIO_TYPES_H_
+
+enum iio_chan_type {
+	IIO_VOLTAGE,
+	IIO_CURRENT,
+	IIO_POWER,
+	IIO_ACCEL,
+	IIO_ANGL_VEL,
+	IIO_MAGN,
+	IIO_LIGHT,
+	IIO_INTENSITY,
+	IIO_PROXIMITY,
+	IIO_TEMP,
+	IIO_INCLI,
+	IIO_ROT,
+	IIO_ANGL,
+	IIO_TIMESTAMP,
+	IIO_CAPACITANCE,
+	IIO_ALTVOLTAGE,
+	IIO_CCT,
+	IIO_PRESSURE,
+	IIO_HUMIDITYRELATIVE,
+	IIO_ACTIVITY,
+	IIO_STEPS,
+	IIO_ENERGY,
+	IIO_DISTANCE,
+	IIO_VELOCITY,
+	IIO_CONCENTRATION,
+	IIO_RESISTANCE,
+	IIO_PH,
+	IIO_UVINDEX,
+};
+
+enum iio_modifier {
+	IIO_NO_MOD,
+	IIO_MOD_X,
+	IIO_MOD_Y,
+	IIO_MOD_Z,
+	IIO_MOD_X_AND_Y,
+	IIO_MOD_X_AND_Z,
+	IIO_MOD_Y_AND_Z,
+	IIO_MOD_X_AND_Y_AND_Z,
+	IIO_MOD_X_OR_Y,
+	IIO_MOD_X_OR_Z,
+	IIO_MOD_Y_OR_Z,
+	IIO_MOD_X_OR_Y_OR_Z,
+	IIO_MOD_LIGHT_BOTH,
+	IIO_MOD_LIGHT_IR,
+	IIO_MOD_ROOT_SUM_SQUARED_X_Y,
+	IIO_MOD_SUM_SQUARED_X_Y_Z,
+	IIO_MOD_LIGHT_CLEAR,
+	IIO_MOD_LIGHT_RED,
+	IIO_MOD_LIGHT_GREEN,
+	IIO_MOD_LIGHT_BLUE,
+	IIO_MOD_QUATERNION,
+	IIO_MOD_TEMP_AMBIENT,
+	IIO_MOD_TEMP_OBJECT,
+	IIO_MOD_NORTH_MAGN,
+	IIO_MOD_NORTH_TRUE,
+	IIO_MOD_NORTH_MAGN_TILT_COMP,
+	IIO_MOD_NORTH_TRUE_TILT_COMP,
+	IIO_MOD_RUNNING,
+	IIO_MOD_JOGGING,
+	IIO_MOD_WALKING,
+	IIO_MOD_STILL,
+	IIO_MOD_ROOT_SUM_SQUARED_X_Y_Z,
+	IIO_MOD_I,
+	IIO_MOD_Q,
+	IIO_MOD_CO2,
+	IIO_MOD_VOC,
+	IIO_MOD_LIGHT_UV,
+};
+
+enum iio_event_type {
+	IIO_EV_TYPE_THRESH,
+	IIO_EV_TYPE_MAG,
+	IIO_EV_TYPE_ROC,
+	IIO_EV_TYPE_THRESH_ADAPTIVE,
+	IIO_EV_TYPE_MAG_ADAPTIVE,
+	IIO_EV_TYPE_CHANGE,
+};
+
+enum iio_event_direction {
+	IIO_EV_DIR_EITHER,
+	IIO_EV_DIR_RISING,
+	IIO_EV_DIR_FALLING,
+	IIO_EV_DIR_NONE,
+};
+
+#endif /* _IIO_TYPES_H_ */
+
diff --git a/misc/cpu_full_load.c b/misc/cpu_full_load.c
index 67d8c55..c644af1 100644
--- a/misc/cpu_full_load.c
+++ b/misc/cpu_full_load.c
@@ -1,57 +1,57 @@
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-#include <pthread.h>
-
-
-void *sayhello1(void *arg)
-{
-	unsigned int n = 0;
-
-	while(1) {
-		if (n % 25000000 == 0)
-			printf("Hello (1): %u\n", n);
-
-		n++;
-	};
-}
-
-void *sayhello2(void *arg)
-{
-	unsigned int n = 0;
-
-	while(1) {
-		if (n % 25000000 == 0)
-			printf("Hello (2): %u\n", n);
-
-		n++;
-	};
-}
-
-int main(int argc,char *argv[])
-{
-         int error;
-	 pthread_t wf_fid, rf_fid;
-
-         if ((error = pthread_create(&wf_fid ,NULL, sayhello1, NULL))<0)
-         {
-                  perror("can't create pthread");
-                  return 1;
-         }
-
-	 sleep(1);
-
-	 if ((error = pthread_create(&rf_fid, NULL, sayhello2, NULL))<0)
-         {
-                  perror("can't create pthread");
-                  return 1;
-         }
-
-         while(1);
-
-         return 0;
-}
-
-
-
-
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <pthread.h>
+
+
+void *sayhello1(void *arg)
+{
+	unsigned int n = 0;
+
+	while(1) {
+		if (n % 25000000 == 0)
+			printf("Hello (1): %u\n", n);
+
+		n++;
+	};
+}
+
+void *sayhello2(void *arg)
+{
+	unsigned int n = 0;
+
+	while(1) {
+		if (n % 25000000 == 0)
+			printf("Hello (2): %u\n", n);
+
+		n++;
+	};
+}
+
+int main(int argc,char *argv[])
+{
+         int error;
+	 pthread_t wf_fid, rf_fid;
+
+         if ((error = pthread_create(&wf_fid ,NULL, sayhello1, NULL))<0)
+         {
+                  perror("can't create pthread");
+                  return 1;
+         }
+
+	 sleep(1);
+
+	 if ((error = pthread_create(&rf_fid, NULL, sayhello2, NULL))<0)
+         {
+                  perror("can't create pthread");
+                  return 1;
+         }
+
+         while(1);
+
+         return 0;
+}
+
+
+
+
diff --git a/misc/make.inc b/misc/make.inc
index 7c7c4b9..a05ef13 100644
--- a/misc/make.inc
+++ b/misc/make.inc
@@ -110,6 +110,27 @@ $(call add-target-into-build, $(LOCAL_TARGET))
 ###
 include $(CLEAR_VARS)
 
+LOCAL_TARGET	:= simplest_init
+LOCAL_SRCS	:= $(LOCAL_PATH)/simplest_init.c
+ifneq ($(BUILD_AMBARELLA_APP_DEBUG_SANITIZE_ADDRESS), y)
+LOCAL_LDFLAGS	:= -static
+endif
+
+include $(BUILD_APP)
+
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(UNIT_TEST_PATH)/
+	@cp -dpRf $< $(UNIT_TEST_PATH)/
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+
+
+###
+include $(CLEAR_VARS)
+
 LOCAL_TARGET	:= test_spi
 LOCAL_SRCS	:= $(LOCAL_PATH)/test_spi.c
 
@@ -268,7 +289,22 @@ $(LOCAL_TARGET): $(LOCAL_MODULE)
 
 $(call add-target-into-build, $(LOCAL_TARGET))
 
+###
+include $(CLEAR_VARS)
+
+LOCAL_TARGET	:= test_fast_intergral
+LOCAL_SRCS	:= $(LOCAL_PATH)/test_fast_intergral.c
+
+include $(BUILD_APP)
 
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(UNIT_TEST_PATH)/
+	@cp -dpRf $< $(UNIT_TEST_PATH)/
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
 
 ifeq ($(BUILD_AMBARELLA_TEXTINSERT_PACKAGE), y)
 ###
diff --git a/misc/mmaptest3.c b/misc/mmaptest3.c
index 74fe311..50f692b 100644
--- a/misc/mmaptest3.c
+++ b/misc/mmaptest3.c
@@ -1,229 +1,229 @@
-/*!
- @addtogroup  mmaptest
- @{
- @file        mmaptest.c
- @brief       
-*/
-#include <stdio.h>
-#include <stdlib.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <sys/mman.h>
-#include <errno.h>
-#include <unistd.h>
-#include <string.h>
-
-
-typedef unsigned char u8;
-typedef unsigned short u16;
-typedef unsigned int u32;
-typedef unsigned long long u64;
-typedef signed char s8;
-typedef signed short s16;
-typedef signed int s32;
-typedef signed long long s64;
-#include <sys/ioctl.h>
-#include <linux/ioctl.h>
-#define SRCBUF_SIZE	(257)
-#define TARGET_BOARD
-
-
-#define MMAP_FILE_PATH	"/dev/mem"
-#define IAV_DRIVER_PATH	"/dev/iav"
-
-// physical address for mmap
-static const unsigned long g_mapaddress_outside = 0x0E000000;	// os
-static const unsigned long g_mapaddress_inside = 0x0C000000;	// os
-
-
-// size for mmap
-static const unsigned long g_mapsize = 3 * 1024 * 1024;
-
-static int createMmap( void** ppBuf, int* pFd, unsigned long );
-static int deleteMmap( void* pBufAdr, int fd);
-static size_t getMmapSize( size_t size );
-
-
-
-int main(int argc, char *argv[])
-{
-	void* pBuf, *pBuf2;
-	int fd, fd2;
-
-	// mmap for inside memory
-	if( 0 != createMmap( &pBuf, &fd, g_mapaddress_inside )) {
-		printf( "createMmap error\n");
-		return -1;
-	}
-	printf( "createMmap(inside) ok.\n");
-	
-		// mmap for outside memory
-	if( 0 != createMmap( &pBuf2, &fd2, g_mapaddress_outside )) {
-		printf( "createMmap error\n");
-		return -1;
-	}
-	printf( "createMmap(outside) ok.\n");
-
-
-	// copy from stack
-	char* testdata = (char*)malloc( 256 );
-	memset( testdata, 0xcc, 256 );
-
-	char testdata2[256];
-	memset( testdata2, 0xdd, 256 );
-
-	/************** test for heap ***********/
-
-	printf( "memcpy from heap to heap with alignment\n");
-
-	// memcpy from mmap area to heap with alignment --- ok.
-	memcpy( testdata, testdata2, 8 );
-
-	printf( "ok\n");
-
-	sleep( 1 );
-
-	printf( "memcpy from heap to heap without alignment \n");
-
-	// memcpy from mmap area to heap without alignment --- ok.
-	memcpy( testdata, testdata2 + 5, 8 );
-
-	printf( "ok\n");
-
-	sleep( 1 );
-
-
-	/************** test for mmap (inside os) ***********/
-
-	printf( "memcpy from mmap area(inside os) to heap with alignment\n");
-
-	// memcpy from mmap area to heap with alignment --- ok.
-	memcpy( testdata, pBuf, 8 );
-
-	printf( "ok\n");
-
-	sleep( 1 );
-
-	printf( "memcpy from mmap area(inside os) to heap without alignment \n");
-
-	// memcpy from mmap area to heap without alignment --- ok.
-	memcpy( testdata, pBuf + 5, 8 );
-
-	printf( "ok\n");
-
-	sleep( 1 );
-	
-	/************** test for mmap (outside os) ***********/
-
-	printf( "memcpy from mmap area(outside os) to heap with alignment\n");
-
-	// memcpy from mmap area to heap with alignment --- ok.
-	memcpy( testdata, pBuf2, 8 );
-
-	printf( "ok\n");
-
-	sleep( 1 );
-
-	printf( "memcpy from mmap area(outside os) to heap without alignment \n");
-
-	// memcpy from mmap area to heap without alignment --- hangup.
-	memcpy( testdata, pBuf2 + 5, 8 );
-
-	printf( "ok\n");
-
-	sleep( 1 );
-
-
-	
-	free( testdata );
-//	free( testdata2);
-
-	deleteMmap( pBuf, fd );
-	deleteMmap( pBuf2, fd );
-
-	return 0;
-}
-
-
-
-static int createMmap( void** ppBuf, int* pFd, unsigned long mapaddress )
-{
-	int fd;
-	long sizeBuf;
-	char buf[ 64 ];
-
-	if(( fd = open( MMAP_FILE_PATH, O_RDWR )) == -1 )
-	{
-		strerror_r( errno, buf, 64 );
-		printf( "open error (errno=%d, flag=%d): %s\n", errno, O_RDWR, buf );
-		return -1;
-	}
-
-	sizeBuf = getMmapSize( g_mapsize );
-
-	*ppBuf = mmap( NULL, sizeBuf, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED, fd, mapaddress );
-
-	if( *ppBuf == ( void *)-1 )
-	{
-		strerror_r( errno, buf, 64 );
-		printf( "%s: mmap: %s\n", __FUNCTION__, buf );
-		close( fd );
-		return -2;
-	}
-
-	printf( "mmap from 0x%lx to %p, size %ld\n", mapaddress, *ppBuf, sizeBuf );
-
-	*pFd = fd;
-
-
-	return 0;
-}
-
-
-static int deleteMmap( void* pBufAdr, int fd)
-{
-	long size;
-	int ret = 0;
-	char buf[ 64 ];
-
-	// null check
-	if( NULL == pBufAdr ) {
-		return -1;
-	}
-
-
-	size = getMmapSize( g_mapsize );
-
-	if( munmap( pBufAdr, size ) == -1 )
-	{
-		strerror_r( errno, buf, 64 );
-		printf( "%s: munmap buf: %s\n", __FUNCTION__, buf );
-		ret = -2;
-	}
-
-	if( close( fd ) == -1 )
-	{
-		strerror_r( errno, buf, 64 );
-		printf( "dev/exmem close: %s\n", buf );
-	}
-
-	printf( "munmap at %p.\n", pBufAdr );
-
-	return ret;
-}
-
-
-static size_t getMmapSize( size_t size )
-{
-	size_t pageSize;
-	int pageNum;
-
-	pageSize = sysconf( _SC_PAGESIZE );
-	pageNum = (size % pageSize == 0)?( size / pageSize ):( size / pageSize + 1);
-	return pageNum * pageSize;
-}
-
-
-/*! @} */
-
+/*!
+ @addtogroup  mmaptest
+ @{
+ @file        mmaptest.c
+ @brief       
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <errno.h>
+#include <unistd.h>
+#include <string.h>
+
+
+typedef unsigned char u8;
+typedef unsigned short u16;
+typedef unsigned int u32;
+typedef unsigned long long u64;
+typedef signed char s8;
+typedef signed short s16;
+typedef signed int s32;
+typedef signed long long s64;
+#include <sys/ioctl.h>
+#include <linux/ioctl.h>
+#define SRCBUF_SIZE	(257)
+#define TARGET_BOARD
+
+
+#define MMAP_FILE_PATH	"/dev/mem"
+#define IAV_DRIVER_PATH	"/dev/iav"
+
+// physical address for mmap
+static const unsigned long g_mapaddress_outside = 0x0E000000;	// os
+static const unsigned long g_mapaddress_inside = 0x0C000000;	// os
+
+
+// size for mmap
+static const unsigned long g_mapsize = 3 * 1024 * 1024;
+
+static int createMmap( void** ppBuf, int* pFd, unsigned long );
+static int deleteMmap( void* pBufAdr, int fd);
+static size_t getMmapSize( size_t size );
+
+
+
+int main(int argc, char *argv[])
+{
+	void* pBuf, *pBuf2;
+	int fd, fd2;
+
+	// mmap for inside memory
+	if( 0 != createMmap( &pBuf, &fd, g_mapaddress_inside )) {
+		printf( "createMmap error\n");
+		return -1;
+	}
+	printf( "createMmap(inside) ok.\n");
+	
+		// mmap for outside memory
+	if( 0 != createMmap( &pBuf2, &fd2, g_mapaddress_outside )) {
+		printf( "createMmap error\n");
+		return -1;
+	}
+	printf( "createMmap(outside) ok.\n");
+
+
+	// copy from stack
+	char* testdata = (char*)malloc( 256 );
+	memset( testdata, 0xcc, 256 );
+
+	char testdata2[256];
+	memset( testdata2, 0xdd, 256 );
+
+	/************** test for heap ***********/
+
+	printf( "memcpy from heap to heap with alignment\n");
+
+	// memcpy from mmap area to heap with alignment --- ok.
+	memcpy( testdata, testdata2, 8 );
+
+	printf( "ok\n");
+
+	sleep( 1 );
+
+	printf( "memcpy from heap to heap without alignment \n");
+
+	// memcpy from mmap area to heap without alignment --- ok.
+	memcpy( testdata, testdata2 + 5, 8 );
+
+	printf( "ok\n");
+
+	sleep( 1 );
+
+
+	/************** test for mmap (inside os) ***********/
+
+	printf( "memcpy from mmap area(inside os) to heap with alignment\n");
+
+	// memcpy from mmap area to heap with alignment --- ok.
+	memcpy( testdata, pBuf, 8 );
+
+	printf( "ok\n");
+
+	sleep( 1 );
+
+	printf( "memcpy from mmap area(inside os) to heap without alignment \n");
+
+	// memcpy from mmap area to heap without alignment --- ok.
+	memcpy( testdata, pBuf + 5, 8 );
+
+	printf( "ok\n");
+
+	sleep( 1 );
+	
+	/************** test for mmap (outside os) ***********/
+
+	printf( "memcpy from mmap area(outside os) to heap with alignment\n");
+
+	// memcpy from mmap area to heap with alignment --- ok.
+	memcpy( testdata, pBuf2, 8 );
+
+	printf( "ok\n");
+
+	sleep( 1 );
+
+	printf( "memcpy from mmap area(outside os) to heap without alignment \n");
+
+	// memcpy from mmap area to heap without alignment --- hangup.
+	memcpy( testdata, pBuf2 + 5, 8 );
+
+	printf( "ok\n");
+
+	sleep( 1 );
+
+
+	
+	free( testdata );
+//	free( testdata2);
+
+	deleteMmap( pBuf, fd );
+	deleteMmap( pBuf2, fd );
+
+	return 0;
+}
+
+
+
+static int createMmap( void** ppBuf, int* pFd, unsigned long mapaddress )
+{
+	int fd;
+	long sizeBuf;
+	char buf[ 64 ];
+
+	if(( fd = open( MMAP_FILE_PATH, O_RDWR )) == -1 )
+	{
+		strerror_r( errno, buf, 64 );
+		printf( "open error (errno=%d, flag=%d): %s\n", errno, O_RDWR, buf );
+		return -1;
+	}
+
+	sizeBuf = getMmapSize( g_mapsize );
+
+	*ppBuf = mmap( NULL, sizeBuf, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED, fd, mapaddress );
+
+	if( *ppBuf == ( void *)-1 )
+	{
+		strerror_r( errno, buf, 64 );
+		printf( "%s: mmap: %s\n", __FUNCTION__, buf );
+		close( fd );
+		return -2;
+	}
+
+	printf( "mmap from 0x%lx to %p, size %ld\n", mapaddress, *ppBuf, sizeBuf );
+
+	*pFd = fd;
+
+
+	return 0;
+}
+
+
+static int deleteMmap( void* pBufAdr, int fd)
+{
+	long size;
+	int ret = 0;
+	char buf[ 64 ];
+
+	// null check
+	if( NULL == pBufAdr ) {
+		return -1;
+	}
+
+
+	size = getMmapSize( g_mapsize );
+
+	if( munmap( pBufAdr, size ) == -1 )
+	{
+		strerror_r( errno, buf, 64 );
+		printf( "%s: munmap buf: %s\n", __FUNCTION__, buf );
+		ret = -2;
+	}
+
+	if( close( fd ) == -1 )
+	{
+		strerror_r( errno, buf, 64 );
+		printf( "dev/exmem close: %s\n", buf );
+	}
+
+	printf( "munmap at %p.\n", pBufAdr );
+
+	return ret;
+}
+
+
+static size_t getMmapSize( size_t size )
+{
+	size_t pageSize;
+	int pageNum;
+
+	pageSize = sysconf( _SC_PAGESIZE );
+	pageNum = (size % pageSize == 0)?( size / pageSize ):( size / pageSize + 1);
+	return pageNum * pageSize;
+}
+
+
+/*! @} */
+
diff --git a/misc/simplest_init.c b/misc/simplest_init.c
new file mode 100644
index 0000000..868e0f0
--- /dev/null
+++ b/misc/simplest_init.c
@@ -0,0 +1,78 @@
+/*
+ * test_uart.c
+ *
+ * History:
+ *	2010/12/08 - [Cao Rongrong ] Created file
+ *
+ * Copyright (C) 2007-2008, Ambarella, Inc.
+ *
+ * All rights reserved. No Part of this file may be reproduced, stored
+ * in a retrieval system, or transmitted, in any form, or by any means,
+ * electronic, mechanical, photocopying, recording, or otherwise,
+ * without the prior consent of Ambarella, Inc.
+ *
+ */
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <errno.h>
+#include <termios.h>
+
+static int uart_config(int fd)
+{
+	struct termios ti;
+
+	tcflush(fd, TCIOFLUSH);
+
+	if (tcgetattr(fd, &ti) < 0) {
+		perror("Can't get port settings");
+		return -1;
+	}
+
+	cfmakeraw(&ti);
+
+	ti.c_cflag |= CLOCAL;
+	ti.c_cflag &= ~CRTSCTS;
+
+	cfsetospeed(&ti, B115200);
+	cfsetispeed(&ti, B115200);
+
+	if (tcsetattr(fd, TCSANOW, &ti) < 0) {
+		perror("Can't set port settings");
+		return -1;
+	}
+
+	tcflush(fd, TCIOFLUSH);
+
+	return 0;
+}
+
+int main(int argc, char **argv)
+{
+	int rval, fd;
+	char buf[128];
+
+	fd = open("/dev/ttyS0", O_RDWR | O_NOCTTY | O_NONBLOCK);
+	if (fd < 0) {
+		perror("Can't open serial port!\n");
+		return -1;
+	}
+
+	uart_config(fd);
+
+	snprintf(buf, sizeof(buf), "\r\n!!!USER SPACE: Hello, Cruel World!!!\r\n\r\n");
+
+	rval = write(fd, buf, strlen(buf));
+	if (rval < 0) {
+		perror("Can't write serial port!\n");
+		return -1;
+	}
+
+	while (1);
+
+	return 0;
+}
+
diff --git a/misc/test_fb.c b/misc/test_fb.c
index a4b6596..bd2d3cd 100644
--- a/misc/test_fb.c
+++ b/misc/test_fb.c
@@ -36,11 +36,12 @@ static struct option long_options[] = {
 	{"rgb",	HAS_ARG,	0,	'c'},
 	{"height",	HAS_ARG,	0,	'h'},
 	{"width",		HAS_ARG,	0,	'w'},
+	{"id",		HAS_ARG,	0,	'b'},
 
 	{0, 0, 0, 0}
 };
 
-static const char *short_options = "c:h:w:";
+static const char *short_options = "c:h:w:b:";
 
 struct hint_s {
 	const char *arg;
@@ -51,6 +52,7 @@ static const struct hint_s hint[] = {
 	{"",			"\t\tset color(Format:R, G, B, alpha), max value is 255"},
 	{"",			"\t\tset frame buffer height"},
 	{"",			"\t\tset frame buffer width"},
+	{"",			"\t\tset frame buffer id"},
 };
 
 struct fb_cmap_user {
@@ -73,6 +75,8 @@ static int fb_width = 0;
 static int fb_width_flag = 0;
 static int fb_height = 0;
 static int fb_height_flag = 0;
+static int fb_id = 0;
+static int fb_id_flag = 0;
 
 #define MAX_COLOR_VALUE	255
 enum {
@@ -184,6 +188,16 @@ int init_param(int argc, char ** argv)
 			fb_width = atoi(optarg);
 			fb_width_flag = 1;
 			break;
+		case 'b':
+			fb_id = atoi(optarg);
+			if ((2 > fb_id) && (0 <= fb_id)) {
+				fb_id_flag = 1;
+			} else {
+				printf("frame buffer id should in range [0, 1]\n");
+				fb_id = 0;
+				fb_id_flag = 0;
+			}
+			break;
 
 		default:
 			printf("unknown option found: %c\n", ch);
@@ -213,15 +227,29 @@ int main(int argc, char **argv)
 		return 0;
 	}
 
-	fb = open("/dev/fb0", O_RDWR);
-	if (fb < 0) {
-		perror("Open fb error");
-		return -1;
-	}
-
 	if (init_param(argc, argv) < 0)
 		return -1;
 
+	if (!fb_id_flag) {
+		fb = open("/dev/fb0", O_RDWR);
+		if (fb < 0) {
+			printf("open /dev/fb0 fail\n");
+			perror("Open fb error");
+			return -1;
+		}
+		printf("open default /dev/fb0 done\n");
+	} else {
+		char fb_dev_string[32] = {0};
+		snprintf(fb_dev_string, sizeof(fb_dev_string), "/dev/fb%d", fb_id);
+		fb = open(fb_dev_string, O_RDWR);
+		if (fb < 0) {
+			printf("open /dev/fb%d fail\n", fb_id);
+			perror("Open fb error");
+			return -1;
+		}
+		printf("open %s done\n", fb_dev_string);
+	}
+
 	if(ioctl(fb, FBIOGET_VSCREENINFO, &var) >= 0
 		&& ioctl(fb, FBIOGET_FSCREENINFO, &fix) >= 0) {
 		buf = (unsigned char *)mmap(NULL, fix.smem_len, PROT_WRITE,  MAP_SHARED, fb, 0);
diff --git a/misc/test_fbtext.c b/misc/test_fbtext.c
index d6779b4..e0918f1 100644
--- a/misc/test_fbtext.c
+++ b/misc/test_fbtext.c
@@ -1,571 +1,571 @@
-/*
- * test_fbtext.c
- *
- * History:
- *	2009/10/13 - [Jian Tang] created file.
- *	2011/06/10 - [Qian Shen] modified file.
- *
- * Copyright (C) 2007-2011, Ambarella, Inc.
- *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
- *
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <fcntl.h>
-#include <ctype.h>
-#include <string.h>
-#include <unistd.h>
-#include <getopt.h>
-#include <signal.h>
-#include <time.h>
-#include <wchar.h>
-#include <linux/fb.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <sys/time.h>
-
-#include <basetypes.h>
-#include "text_insert.h"
-
-#ifndef LINE_SPACING
-#define LINE_SPACING(x)		((x) * 3 / 2)
-#endif
-
-#define FIXED_DIGIT_WIDTH	(2)
-
-typedef struct fb_clut_s {
-	u16 r;
-	u16 g;
-	u16 b;
-	u16 alpha;
-} fb_clut_t;
-
-struct fb_cmap_user {
-	u32 start; /* First entry	*/
-	u32 len; /* Number of entries */
-	u16 *r;
-	u16 *g;
-	u16 *b;
-	u16 *transparent;		/* transparency, can be NULL */
-};
-
-pixel_type_t pixel_type = {
-		.pixel_background = 0,
-		.pixel_outline = 1,
-		.pixel_font = 255,
-};
-
-static fb_clut_t default_clut_data[6] = { /* alpha 0 is full transparent */
-		{ .r = 255, .g = 0, .b = 0, .alpha = 255 }, /* red */
-		{ .r = 255, .g = 255, .b = 255, .alpha = 255 }, /* white */
-		{ .r = 0, .g = 0, .b = 255, .alpha = 255 }, /* blue */
-		{ .r = 0, .g = 255, .b = 0, .alpha = 255 }, /* green */
-		{ .r = 255, .g = 255, .b = 0, .alpha = 255 }, /* yellow */
-		{ .r = 255, .g = 0, .b = 255, .alpha = 255 },/* cyan */
-};
-
-struct fb_var_screeninfo var;
-struct fb_fix_screeninfo fix;
-
-static int fb;
-static font_attribute_t font;
-static wchar_t wstring[MAX_BYTE_SIZE];
-static int fb_color_id = 0;
-static int fb_x = 0;
-static int fb_y = 0;
-static int rect_width = 0;
-static int rect_height = 0;
-static int flag_string = 0;
-u8 *fb_mem = NULL;
-
-/* for time display */
-static int flag_time_display = 0;
-u8 *digit_buf = NULL;
-static int digit_width = 0;
-static int time_offset[32][2];
-char last_time[MAX_BYTE_SIZE];
-
-static u16 r_table[256];
-static u16 g_table[256];
-static u16 b_table[256];
-static u16 trans_table[256];
-
-wchar_t default_wtext[2][MAX_BYTE_SIZE] = {
-	L"AmbarellaA5sSDK",
-	L"(Chinese)",
-};
-
-wchar_t *digits = L"0123456789";
-char font_type[2][MAX_BYTE_SIZE] = {
-	"/usr/share/fonts/DroidSans.ttf",
-	"/usr/share/fonts/DroidSansFallbackFull.ttf",
-};
-
-
-#define	NO_ARG		0
-#define	HAS_ARG		1
-
-enum {
-	SPECIFY_BOLD,
-	SPECIFY_ITALIC,
-	SPECIFY_STRING,
-	TIME_DISPLAY,
-};
-
-static const char *short_options = "c:x:y:w:h:t:s:";
-static struct option long_options[] = {
-		{ "color", HAS_ARG, 0, 'c'},
-		{ "offset_x", HAS_ARG, 0, 'x'},
-		{ "offset_y", HAS_ARG, 0, 'y'},
-		{ "string", HAS_ARG, 0, SPECIFY_STRING},
-		{ "fonttype", HAS_ARG, 0, 't' },
-		{ "fontsize", HAS_ARG, 0, 's' },
-		{ "bold", HAS_ARG, 0, SPECIFY_BOLD },
-		{ "italic", HAS_ARG, 0, SPECIFY_ITALIC },
-		{ "rect_w", HAS_ARG, 0, 'w'},
-		{ "rect_h", HAS_ARG, 0, 'h'},
-		{ "time", NO_ARG, 0, TIME_DISPLAY },
-
-		{0, 0, 0, 0}
-};
-
-struct hint_s {
-	const char *arg;
-	const char *str;
-};
-
-static const struct hint_s hint[] = {
-	{ "0~6", "\tset color. 0 red, 1 white, 2 blue, 3 green, 4 yellow, 5 cyan"},
-	{ "", "\t\tset display horizontal offset"},
-	{ "", "\t\tset display vertical offset"},
-	{ "", "\t\ttext to be displayed" },
-	{ "0~1", "\tset font type, 0 DroidSans, 1 DroidSansFallbackFull" },
-	{ "", "\t\tset font size " },
-	{ "0~100", "\tn percentage bold of font size. Negative means thinner." },
-	{ "0~100", "\tn percentage italic of font size." },
-	{ "", "\t\tdraw a rectangle. Set width."},
-	{ "", "\t\tdraw a rectangle. Set height."},
-	{ "","\t\tdisplay current time." },
-};
-
-static void usage(void)
-{
-	int i;
-
-	printf("test_fbtext usage:\n");
-	for (i = 0; i < sizeof(long_options) / sizeof(long_options[0]) - 1; i++) {
-		if (isalpha(long_options[i].val))
-			printf("-%c ", long_options[i].val);
-		else
-			printf("   ");
-		printf("--%s", long_options[i].name);
-		if (hint[i].arg[0] != 0)
-			printf(" [%s]", hint[i].arg);
-		printf("\t%s\n", hint[i].str);
-	}
-	printf("\n");
-	printf("Example:\n"
-		"  To display text\n"
-		"    test_fbtext -x100 -y100 -c2 -t1 -s50 --string \"Hello World\"\n"
-		"  To draw rectangle\n"
-		"    test_fbtext -x200 -y50 -w128 -h128 -c4\n"
-		"  To display time\n"
-		"    test_fbtext -x450 -y50 -t1 -c1 -s20 --time\n");
-}
-
-static void get_time_string(char *str)
-{
-	time_t t;
-	struct tm *p;
-	time(&t);
-	p = gmtime(&t);
-	sprintf(str, "%04d-%02d-%02d %02d:%02d:%02d", (1900 + p->tm_year), (1
-	        + p->tm_mon), p->tm_mday, p->tm_hour, p->tm_min, p->tm_sec);
-}
-
-static int char_to_wchar(const char* orig_str, wchar_t *wtext)
-{
-	int str_length = strlen(orig_str);
-	if (str_length != mbstowcs(wtext, orig_str, str_length + 1))
-		return -1;
-
-	if (wcscat(wtext, L"") == NULL)
-		return -1;
-
-	return 0;
-}
-
-static int init_param(int argc, char ** argv)
-{
-	int ch, tmp, type = 0;
-	int option_index = 0;
-
-	opterr = 0;
-	while ((ch = getopt_long(argc, argv, short_options, long_options, &option_index)) != -1) {
-		switch (ch) {
-			case 'c':
-				fb_color_id = atoi(optarg);
-				break;
-			case 'x':
-				tmp = atoi(optarg);
-				fb_x = tmp > 0 ? tmp : 0;
-				break;
-			case 'y':
-				tmp = atoi(optarg);
-				fb_y = tmp > 0 ? tmp : 0;
-				break;
-			case 'w':
-				rect_width = atoi(optarg);
-				flag_string = 0;
-				break;
-			case 'h':
-				rect_height = atoi(optarg);
-				flag_string = 0;
-				break;
-			case SPECIFY_STRING:
-				if (!flag_time_display && char_to_wchar(optarg, &wstring[0]) < 0) {
-					memset(&wstring[0], 0, MAX_BYTE_SIZE);
-				}
-				flag_string = 1;
-				break;
-			case 't':
-				type = atoi(optarg);
-				strcpy(font.type, font_type[type]);
-				flag_string = 1;
-				break;
-			case 's':
-				font.size = atoi(optarg);
-				flag_string = 1;
-				break;
-				break;
-			case SPECIFY_BOLD:
-				font.hori_bold = font.vert_bold = atoi(optarg);
-				flag_string = 1;
-				break;
-			case SPECIFY_ITALIC:
-				font.italic = atoi(optarg);
-				flag_string = 1;
-				break;
-			case TIME_DISPLAY:
-				get_time_string(&last_time[0]);
-				char_to_wchar(&last_time[0], &wstring[0]);
-				flag_time_display = 1;
-				flag_string = 1;
-				break;
-			default:
-				printf("unknown option found: %c\n", ch);
-				return -1;
-		}
-	}
-
-	if (flag_string && !font.size) {
-		font.size = 32;
-		printf("Use default font size %d\n", font.size);
-	}
-	if (flag_string && (wcslen(&wstring[0]) == 0))
-		wcscpy(&wstring[0],  &default_wtext[type][0]);
-
-	return 0;
-}
-static int fb_put_cmap(int color)
-{
-	u16 i;
-	struct fb_cmap_user cmap;
-	cmap.start = 0;
-	cmap.len = 256;
-
-	for (i = 0; i < cmap.len - cmap.start; i++) {
-		r_table[i] = default_clut_data[color].r;
-		g_table[i] = default_clut_data[color].g;
-		b_table[i] = default_clut_data[color].b;
-		trans_table[i] = i;
-	}
-
-	cmap.r = r_table;
-	cmap.g = g_table;
-	cmap.b = b_table;
-	cmap.transparent = trans_table;
-	if (ioctl(fb, FBIOPUTCMAP, &cmap) < 0) {
-		printf("Unable to put cmap!\n");
-		return -1;
-	}
-	return 0;
-}
-
-static int fb_init(void)
-{
-	if (ioctl(fb, FBIOGET_VSCREENINFO, &var) >= 0) {
-		var.xres = var.xres_virtual;
-		var.yres = var.yres_virtual;
-		ioctl(fb, FBIOPUT_VSCREENINFO, &var);
-		printf("\tFB: %d x %d @ %dbpp\n", var.xres, var.yres, var.bits_per_pixel);
-	} else {
-		printf("\tUnable to get var and fix info!\n");
-		return -1;
-	}
-
-	if (ioctl(fb, FBIOGET_FSCREENINFO, &fix) >= 0)
-		fb_mem = (u8 *) mmap(NULL, fix.smem_len, PROT_WRITE, MAP_SHARED, fb, 0);
-	else {
-		printf("Unable to get screen_fix_info\n");
-		return -1;
-	}
-
-	fb_x = fb_x < var.xres ? fb_x : 0;
-	fb_y = fb_y < var.yres ? fb_y : 0;
-
-	return 0;
-}
-
-static int fb_rectangle_display(void)
-{
-	int i;
-	rect_width = (rect_width <= 0 || rect_width > var.xres - fb_x ?
-			var.xres - fb_x : rect_width);
-	rect_height = (rect_height <= 0 || rect_height > var.yres - fb_y ?
-			var.yres - fb_y : rect_height);
-	printf("\tRectangle [x %d, y %d, width %d, height %d]\n",
-	       fb_x, fb_y, rect_width, rect_height);
-	for (i = 0; i < rect_height; i++)
-		memset(fb_mem + (i + fb_y) * fix.line_length + fb_x,
-				pixel_type.pixel_font, rect_width);
-	ioctl(fb, FBIOPAN_DISPLAY, &var);
-	return 0;
-}
-
-static int fb_text_display(void)
-{
-	int i, remain_y, offset_x, offset_y;
-	u8 *line_addr = fb_mem + fb_y * fix.line_length;
-	u16 line_height = LINE_SPACING(font.size);
-	bitmap_info_t bmp = {0, 0};
-	wchar_t *p = &wstring[0];
-	font.disable_anti_alias = 1;
-
-	if (text2bitmap_lib_init(&pixel_type) < 0)
-		return -1;
-
-	if (text2bitmap_set_font_attribute(&font) < 0)
-		return -1;
-
-	memset(fb_mem, pixel_type.pixel_background, fix.smem_len);
-	offset_x = fb_x;
-	offset_y = fb_y;
-	for (i = 0; i < wcslen(&wstring[0]); i++) {
-		printf("%c", *p);
-		if (offset_x + font.size > var.xres) {
-			offset_y += line_height;
-			remain_y = var.yres - offset_y;
-			if (remain_y < LINE_SPACING(font.size))
-				return 0;
-			line_addr += fix.line_length * line_height;
-			offset_x = fb_x;
-		}
-		if (text2bitmap_convert_character(*p, line_addr, line_height,
-				fix.line_length, offset_x, &bmp) < 0)
-			return -1;
-		offset_x += bmp.width;
-		p++;
-	}
-	ioctl(fb, FBIOPAN_DISPLAY, &var);
-	printf("\n");
-	return 0;
-}
-
-static int fb_time_display()
-{
-	int i, remain_y, offset_x, offset_y;
-	u8 *line_addr = fb_mem + fb_y * fix.line_length;
-	u16 total_width = 10 * FIXED_DIGIT_WIDTH * font.size;
-	u16 line_height = LINE_SPACING(font.size);
-	bitmap_info_t bmp = { 0, 0 };
-	wchar_t digits[32] = L"0123456789";
-	wchar_t *p;
-	font.disable_anti_alias = 1;
-
-	digit_buf = (u8 *) malloc(total_width * line_height);
-	if (digit_buf == NULL) {
-		printf("malloc error!\n");
-		return -1;
-	}
-
-	if (text2bitmap_lib_init(&pixel_type) < 0)
-		return -1;
-
-	if (text2bitmap_set_font_attribute(&font) < 0)
-		return -1;
-
-	/* Store 10 digits' bitmap data in (u8 *)digit_buf for later reuse. */
-	p = &digits[0];
-	offset_x = 0;
-	memset(digit_buf, pixel_type.pixel_background, total_width * line_height);
-	for (i = 0; i < wcslen(&digits[0]); i++) {
-		if (text2bitmap_convert_character(*p, digit_buf, line_height,
-				total_width, offset_x, &bmp) < 0)
-			return -1;
-
-		offset_x += FIXED_DIGIT_WIDTH * font.size;
-		if (bmp.width > digit_width)
-			digit_width = bmp.width;
-		p++;
-	}
-
-	/* Write the time in the frame buffer */
-	memset(fb_mem, pixel_type.pixel_background, fix.smem_len);
-	offset_x = fb_x;
-	offset_y = fb_y;
-	p = &wstring[0];
-	for (i = 0; i < wcslen(&wstring[0]); i++) {
-		printf("%c", *p);
-		if (offset_x + font.size > var.xres) {
-			remain_y = var.yres - offset_y;
-			if (remain_y < LINE_SPACING(font.size)) {
-				time_offset[i][0] = -1;
-				printf("\n");
-				return 0;
-			}
-			offset_y += line_height;
-			line_addr += fix.line_length * line_height;
-			offset_x = fb_x;
-		}
-		time_offset[i][0] = offset_x;
-		time_offset[i][1] = offset_y;
-		if (text2bitmap_convert_character(*p, line_addr, line_height,
-				fix.line_length, offset_x, &bmp)
-		        < 0)
-			return -1;
-		if (isdigit(*p))
-			offset_x += digit_width;
-		else
-			offset_x += bmp.width;
-		p++;
-	}
-	ioctl(fb, FBIOPAN_DISPLAY, &var);
-
-	time_offset[i][0] = -1;
-	printf("\n");
-	return 0;
-}
-
-static void time_callback()
-{
-	int i, j;
-	char current_time[255], c;
-	u8 *src = NULL, *des = NULL;
-	int line_height = LINE_SPACING(font.size);
-
-	get_time_string(&current_time[0]);
-	if (!flag_time_display)
-		return;
-	i = 0;
-	while(current_time[i] != '\0') {
-		if (time_offset[i][0] == -1)
-			break;
-		if (current_time[i] == last_time[i]) {
-			i++;
-			continue;
-		}
-		/* Update the changed digits */
-		c = current_time[i] - '0';
-		src = digit_buf + c * FIXED_DIGIT_WIDTH * font.size;
-		des = fb_mem + time_offset[i][1] * fix.line_length + time_offset[i][0];
-		for (j = 0; j < line_height; j++)
-			memcpy(des + j * fix.line_length, src + j * FIXED_DIGIT_WIDTH
-				* font.size * 10, digit_width);
-		i++;
-	}
-	strcpy(last_time, current_time);
-	ioctl(fb, FBIOPAN_DISPLAY, &var);
-
-}
-
-static void fb_exit()
-{
-	if (flag_time_display) {
-		struct itimerval st_new = { { 0, 0 }, { 1, 0 } };
-		struct itimerval st_old;
-		setitimer(ITIMER_REAL, &st_new, &st_old);
-		if (digit_buf != NULL) {
-			free(digit_buf);
-			digit_buf = NULL;
-		}
-	}
-	if (flag_string)
-		text2bitmap_lib_deinit();
-
-	if (fb_mem != NULL) {
-		memset(fb_mem, 0, fix.smem_len);
-		ioctl(fb, FBIOBLANK, FB_BLANK_NORMAL);
-		ioctl(fb, FBIOPAN_DISPLAY, &var);
-		munmap(fb_mem, fb);
-		fb_mem = NULL;
-	}
-	close(fb);
-	exit(0);
-}
-
-int main(int argc, char **argv)
-{
-	signal(SIGINT, fb_exit);
-	signal(SIGQUIT, fb_exit);
-	signal(SIGTERM, fb_exit);
-
-	if (argc < 2) {
-		usage();
-		return 0;
-	}
-
-	fb = open("/dev/fb0", O_RDWR);
-	if (fb < 0) {
-		perror("Open fb error");
-		return -1;
-	}
-
-	if (init_param(argc, argv) < 0)
-		return -1;
-
-	printf("Set color map ...\n");
-	if (fb_put_cmap(fb_color_id) < 0)
-		return -1;
-
-	printf("Initialize frame buffer ...\n");
-	if (fb_init() < 0)
-		return -1;
-
-	if (!flag_time_display) {
-		if (flag_string) {
-			printf("Display text ...\n\t");
-			if (fb_text_display() < 0)
-				goto EXIT;
-		} else {
-			printf("Display rectangle ...\n");
-			fb_rectangle_display();
-		}
-	}
-
-	if (flag_time_display) {
-		struct itimerval st_new = { { 1, 0 }, { 1, 0 } };
-		struct itimerval st_old;
-		printf("Display time ...\n\t");
-		if (fb_time_display() < 0)
-			goto EXIT;
-
-		signal(SIGALRM, time_callback);
-		setitimer(ITIMER_REAL, &st_new, &st_old);
-	}
-
-	while (1)
-		sleep(10);
-
-EXIT:
-	fb_exit();
-	return 0;
-}
-
-
+/*
+ * test_fbtext.c
+ *
+ * History:
+ *	2009/10/13 - [Jian Tang] created file.
+ *	2011/06/10 - [Qian Shen] modified file.
+ *
+ * Copyright (C) 2007-2011, Ambarella, Inc.
+ *
+ * All rights reserved. No Part of this file may be reproduced, stored
+ * in a retrieval system, or transmitted, in any form, or by any means,
+ * electronic, mechanical, photocopying, recording, or otherwise,
+ * without the prior consent of Ambarella, Inc.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <string.h>
+#include <unistd.h>
+#include <getopt.h>
+#include <signal.h>
+#include <time.h>
+#include <wchar.h>
+#include <linux/fb.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+
+#include <basetypes.h>
+#include "text_insert.h"
+
+#ifndef LINE_SPACING
+#define LINE_SPACING(x)		((x) * 3 / 2)
+#endif
+
+#define FIXED_DIGIT_WIDTH	(2)
+
+typedef struct fb_clut_s {
+	u16 r;
+	u16 g;
+	u16 b;
+	u16 alpha;
+} fb_clut_t;
+
+struct fb_cmap_user {
+	u32 start; /* First entry	*/
+	u32 len; /* Number of entries */
+	u16 *r;
+	u16 *g;
+	u16 *b;
+	u16 *transparent;		/* transparency, can be NULL */
+};
+
+pixel_type_t pixel_type = {
+		.pixel_background = 0,
+		.pixel_outline = 1,
+		.pixel_font = 255,
+};
+
+static fb_clut_t default_clut_data[6] = { /* alpha 0 is full transparent */
+		{ .r = 255, .g = 0, .b = 0, .alpha = 255 }, /* red */
+		{ .r = 255, .g = 255, .b = 255, .alpha = 255 }, /* white */
+		{ .r = 0, .g = 0, .b = 255, .alpha = 255 }, /* blue */
+		{ .r = 0, .g = 255, .b = 0, .alpha = 255 }, /* green */
+		{ .r = 255, .g = 255, .b = 0, .alpha = 255 }, /* yellow */
+		{ .r = 255, .g = 0, .b = 255, .alpha = 255 },/* cyan */
+};
+
+struct fb_var_screeninfo var;
+struct fb_fix_screeninfo fix;
+
+static int fb;
+static font_attribute_t font;
+static wchar_t wstring[MAX_BYTE_SIZE];
+static int fb_color_id = 0;
+static int fb_x = 0;
+static int fb_y = 0;
+static int rect_width = 0;
+static int rect_height = 0;
+static int flag_string = 0;
+u8 *fb_mem = NULL;
+
+/* for time display */
+static int flag_time_display = 0;
+u8 *digit_buf = NULL;
+static int digit_width = 0;
+static int time_offset[32][2];
+char last_time[MAX_BYTE_SIZE];
+
+static u16 r_table[256];
+static u16 g_table[256];
+static u16 b_table[256];
+static u16 trans_table[256];
+
+wchar_t default_wtext[2][MAX_BYTE_SIZE] = {
+	L"AmbarellaA5sSDK",
+	L"(Chinese)",
+};
+
+wchar_t *digits = L"0123456789";
+char font_type[2][MAX_BYTE_SIZE] = {
+	"/usr/share/fonts/DroidSans.ttf",
+	"/usr/share/fonts/DroidSansFallbackFull.ttf",
+};
+
+
+#define	NO_ARG		0
+#define	HAS_ARG		1
+
+enum {
+	SPECIFY_BOLD,
+	SPECIFY_ITALIC,
+	SPECIFY_STRING,
+	TIME_DISPLAY,
+};
+
+static const char *short_options = "c:x:y:w:h:t:s:";
+static struct option long_options[] = {
+		{ "color", HAS_ARG, 0, 'c'},
+		{ "offset_x", HAS_ARG, 0, 'x'},
+		{ "offset_y", HAS_ARG, 0, 'y'},
+		{ "string", HAS_ARG, 0, SPECIFY_STRING},
+		{ "fonttype", HAS_ARG, 0, 't' },
+		{ "fontsize", HAS_ARG, 0, 's' },
+		{ "bold", HAS_ARG, 0, SPECIFY_BOLD },
+		{ "italic", HAS_ARG, 0, SPECIFY_ITALIC },
+		{ "rect_w", HAS_ARG, 0, 'w'},
+		{ "rect_h", HAS_ARG, 0, 'h'},
+		{ "time", NO_ARG, 0, TIME_DISPLAY },
+
+		{0, 0, 0, 0}
+};
+
+struct hint_s {
+	const char *arg;
+	const char *str;
+};
+
+static const struct hint_s hint[] = {
+	{ "0~6", "\tset color. 0 red, 1 white, 2 blue, 3 green, 4 yellow, 5 cyan"},
+	{ "", "\t\tset display horizontal offset"},
+	{ "", "\t\tset display vertical offset"},
+	{ "", "\t\ttext to be displayed" },
+	{ "0~1", "\tset font type, 0 DroidSans, 1 DroidSansFallbackFull" },
+	{ "", "\t\tset font size " },
+	{ "0~100", "\tn percentage bold of font size. Negative means thinner." },
+	{ "0~100", "\tn percentage italic of font size." },
+	{ "", "\t\tdraw a rectangle. Set width."},
+	{ "", "\t\tdraw a rectangle. Set height."},
+	{ "","\t\tdisplay current time." },
+};
+
+static void usage(void)
+{
+	int i;
+
+	printf("test_fbtext usage:\n");
+	for (i = 0; i < sizeof(long_options) / sizeof(long_options[0]) - 1; i++) {
+		if (isalpha(long_options[i].val))
+			printf("-%c ", long_options[i].val);
+		else
+			printf("   ");
+		printf("--%s", long_options[i].name);
+		if (hint[i].arg[0] != 0)
+			printf(" [%s]", hint[i].arg);
+		printf("\t%s\n", hint[i].str);
+	}
+	printf("\n");
+	printf("Example:\n"
+		"  To display text\n"
+		"    test_fbtext -x100 -y100 -c2 -t1 -s50 --string \"Hello World\"\n"
+		"  To draw rectangle\n"
+		"    test_fbtext -x200 -y50 -w128 -h128 -c4\n"
+		"  To display time\n"
+		"    test_fbtext -x450 -y50 -t1 -c1 -s20 --time\n");
+}
+
+static void get_time_string(char *str)
+{
+	time_t t;
+	struct tm *p;
+	time(&t);
+	p = gmtime(&t);
+	sprintf(str, "%04d-%02d-%02d %02d:%02d:%02d", (1900 + p->tm_year), (1
+	        + p->tm_mon), p->tm_mday, p->tm_hour, p->tm_min, p->tm_sec);
+}
+
+static int char_to_wchar(const char* orig_str, wchar_t *wtext)
+{
+	int str_length = strlen(orig_str);
+	if (str_length != mbstowcs(wtext, orig_str, str_length + 1))
+		return -1;
+
+	if (wcscat(wtext, L"") == NULL)
+		return -1;
+
+	return 0;
+}
+
+static int init_param(int argc, char ** argv)
+{
+	int ch, tmp, type = 0;
+	int option_index = 0;
+
+	opterr = 0;
+	while ((ch = getopt_long(argc, argv, short_options, long_options, &option_index)) != -1) {
+		switch (ch) {
+			case 'c':
+				fb_color_id = atoi(optarg);
+				break;
+			case 'x':
+				tmp = atoi(optarg);
+				fb_x = tmp > 0 ? tmp : 0;
+				break;
+			case 'y':
+				tmp = atoi(optarg);
+				fb_y = tmp > 0 ? tmp : 0;
+				break;
+			case 'w':
+				rect_width = atoi(optarg);
+				flag_string = 0;
+				break;
+			case 'h':
+				rect_height = atoi(optarg);
+				flag_string = 0;
+				break;
+			case SPECIFY_STRING:
+				if (!flag_time_display && char_to_wchar(optarg, &wstring[0]) < 0) {
+					memset(&wstring[0], 0, MAX_BYTE_SIZE);
+				}
+				flag_string = 1;
+				break;
+			case 't':
+				type = atoi(optarg);
+				strcpy(font.type, font_type[type]);
+				flag_string = 1;
+				break;
+			case 's':
+				font.size = atoi(optarg);
+				flag_string = 1;
+				break;
+				break;
+			case SPECIFY_BOLD:
+				font.hori_bold = font.vert_bold = atoi(optarg);
+				flag_string = 1;
+				break;
+			case SPECIFY_ITALIC:
+				font.italic = atoi(optarg);
+				flag_string = 1;
+				break;
+			case TIME_DISPLAY:
+				get_time_string(&last_time[0]);
+				char_to_wchar(&last_time[0], &wstring[0]);
+				flag_time_display = 1;
+				flag_string = 1;
+				break;
+			default:
+				printf("unknown option found: %c\n", ch);
+				return -1;
+		}
+	}
+
+	if (flag_string && !font.size) {
+		font.size = 32;
+		printf("Use default font size %d\n", font.size);
+	}
+	if (flag_string && (wcslen(&wstring[0]) == 0))
+		wcscpy(&wstring[0],  &default_wtext[type][0]);
+
+	return 0;
+}
+static int fb_put_cmap(int color)
+{
+	u16 i;
+	struct fb_cmap_user cmap;
+	cmap.start = 0;
+	cmap.len = 256;
+
+	for (i = 0; i < cmap.len - cmap.start; i++) {
+		r_table[i] = default_clut_data[color].r;
+		g_table[i] = default_clut_data[color].g;
+		b_table[i] = default_clut_data[color].b;
+		trans_table[i] = i;
+	}
+
+	cmap.r = r_table;
+	cmap.g = g_table;
+	cmap.b = b_table;
+	cmap.transparent = trans_table;
+	if (ioctl(fb, FBIOPUTCMAP, &cmap) < 0) {
+		printf("Unable to put cmap!\n");
+		return -1;
+	}
+	return 0;
+}
+
+static int fb_init(void)
+{
+	if (ioctl(fb, FBIOGET_VSCREENINFO, &var) >= 0) {
+		var.xres = var.xres_virtual;
+		var.yres = var.yres_virtual;
+		ioctl(fb, FBIOPUT_VSCREENINFO, &var);
+		printf("\tFB: %d x %d @ %dbpp\n", var.xres, var.yres, var.bits_per_pixel);
+	} else {
+		printf("\tUnable to get var and fix info!\n");
+		return -1;
+	}
+
+	if (ioctl(fb, FBIOGET_FSCREENINFO, &fix) >= 0)
+		fb_mem = (u8 *) mmap(NULL, fix.smem_len, PROT_WRITE, MAP_SHARED, fb, 0);
+	else {
+		printf("Unable to get screen_fix_info\n");
+		return -1;
+	}
+
+	fb_x = fb_x < var.xres ? fb_x : 0;
+	fb_y = fb_y < var.yres ? fb_y : 0;
+
+	return 0;
+}
+
+static int fb_rectangle_display(void)
+{
+	int i;
+	rect_width = (rect_width <= 0 || rect_width > var.xres - fb_x ?
+			var.xres - fb_x : rect_width);
+	rect_height = (rect_height <= 0 || rect_height > var.yres - fb_y ?
+			var.yres - fb_y : rect_height);
+	printf("\tRectangle [x %d, y %d, width %d, height %d]\n",
+	       fb_x, fb_y, rect_width, rect_height);
+	for (i = 0; i < rect_height; i++)
+		memset(fb_mem + (i + fb_y) * fix.line_length + fb_x,
+				pixel_type.pixel_font, rect_width);
+	ioctl(fb, FBIOPAN_DISPLAY, &var);
+	return 0;
+}
+
+static int fb_text_display(void)
+{
+	int i, remain_y, offset_x, offset_y;
+	u8 *line_addr = fb_mem + fb_y * fix.line_length;
+	u16 line_height = LINE_SPACING(font.size);
+	bitmap_info_t bmp = {0, 0};
+	wchar_t *p = &wstring[0];
+	font.disable_anti_alias = 1;
+
+	if (text2bitmap_lib_init(&pixel_type) < 0)
+		return -1;
+
+	if (text2bitmap_set_font_attribute(&font) < 0)
+		return -1;
+
+	memset(fb_mem, pixel_type.pixel_background, fix.smem_len);
+	offset_x = fb_x;
+	offset_y = fb_y;
+	for (i = 0; i < wcslen(&wstring[0]); i++) {
+		printf("%c", *p);
+		if (offset_x + font.size > var.xres) {
+			offset_y += line_height;
+			remain_y = var.yres - offset_y;
+			if (remain_y < LINE_SPACING(font.size))
+				return 0;
+			line_addr += fix.line_length * line_height;
+			offset_x = fb_x;
+		}
+		if (text2bitmap_convert_character(*p, line_addr, line_height,
+				fix.line_length, offset_x, &bmp) < 0)
+			return -1;
+		offset_x += bmp.width;
+		p++;
+	}
+	ioctl(fb, FBIOPAN_DISPLAY, &var);
+	printf("\n");
+	return 0;
+}
+
+static int fb_time_display()
+{
+	int i, remain_y, offset_x, offset_y;
+	u8 *line_addr = fb_mem + fb_y * fix.line_length;
+	u16 total_width = 10 * FIXED_DIGIT_WIDTH * font.size;
+	u16 line_height = LINE_SPACING(font.size);
+	bitmap_info_t bmp = { 0, 0 };
+	wchar_t digits[32] = L"0123456789";
+	wchar_t *p;
+	font.disable_anti_alias = 1;
+
+	digit_buf = (u8 *) malloc(total_width * line_height);
+	if (digit_buf == NULL) {
+		printf("malloc error!\n");
+		return -1;
+	}
+
+	if (text2bitmap_lib_init(&pixel_type) < 0)
+		return -1;
+
+	if (text2bitmap_set_font_attribute(&font) < 0)
+		return -1;
+
+	/* Store 10 digits' bitmap data in (u8 *)digit_buf for later reuse. */
+	p = &digits[0];
+	offset_x = 0;
+	memset(digit_buf, pixel_type.pixel_background, total_width * line_height);
+	for (i = 0; i < wcslen(&digits[0]); i++) {
+		if (text2bitmap_convert_character(*p, digit_buf, line_height,
+				total_width, offset_x, &bmp) < 0)
+			return -1;
+
+		offset_x += FIXED_DIGIT_WIDTH * font.size;
+		if (bmp.width > digit_width)
+			digit_width = bmp.width;
+		p++;
+	}
+
+	/* Write the time in the frame buffer */
+	memset(fb_mem, pixel_type.pixel_background, fix.smem_len);
+	offset_x = fb_x;
+	offset_y = fb_y;
+	p = &wstring[0];
+	for (i = 0; i < wcslen(&wstring[0]); i++) {
+		printf("%c", *p);
+		if (offset_x + font.size > var.xres) {
+			remain_y = var.yres - offset_y;
+			if (remain_y < LINE_SPACING(font.size)) {
+				time_offset[i][0] = -1;
+				printf("\n");
+				return 0;
+			}
+			offset_y += line_height;
+			line_addr += fix.line_length * line_height;
+			offset_x = fb_x;
+		}
+		time_offset[i][0] = offset_x;
+		time_offset[i][1] = offset_y;
+		if (text2bitmap_convert_character(*p, line_addr, line_height,
+				fix.line_length, offset_x, &bmp)
+		        < 0)
+			return -1;
+		if (isdigit(*p))
+			offset_x += digit_width;
+		else
+			offset_x += bmp.width;
+		p++;
+	}
+	ioctl(fb, FBIOPAN_DISPLAY, &var);
+
+	time_offset[i][0] = -1;
+	printf("\n");
+	return 0;
+}
+
+static void time_callback()
+{
+	int i, j;
+	char current_time[255], c;
+	u8 *src = NULL, *des = NULL;
+	int line_height = LINE_SPACING(font.size);
+
+	get_time_string(&current_time[0]);
+	if (!flag_time_display)
+		return;
+	i = 0;
+	while(current_time[i] != '\0') {
+		if (time_offset[i][0] == -1)
+			break;
+		if (current_time[i] == last_time[i]) {
+			i++;
+			continue;
+		}
+		/* Update the changed digits */
+		c = current_time[i] - '0';
+		src = digit_buf + c * FIXED_DIGIT_WIDTH * font.size;
+		des = fb_mem + time_offset[i][1] * fix.line_length + time_offset[i][0];
+		for (j = 0; j < line_height; j++)
+			memcpy(des + j * fix.line_length, src + j * FIXED_DIGIT_WIDTH
+				* font.size * 10, digit_width);
+		i++;
+	}
+	strcpy(last_time, current_time);
+	ioctl(fb, FBIOPAN_DISPLAY, &var);
+
+}
+
+static void fb_exit()
+{
+	if (flag_time_display) {
+		struct itimerval st_new = { { 0, 0 }, { 1, 0 } };
+		struct itimerval st_old;
+		setitimer(ITIMER_REAL, &st_new, &st_old);
+		if (digit_buf != NULL) {
+			free(digit_buf);
+			digit_buf = NULL;
+		}
+	}
+	if (flag_string)
+		text2bitmap_lib_deinit();
+
+	if (fb_mem != NULL) {
+		memset(fb_mem, 0, fix.smem_len);
+		ioctl(fb, FBIOBLANK, FB_BLANK_NORMAL);
+		ioctl(fb, FBIOPAN_DISPLAY, &var);
+		munmap(fb_mem, fb);
+		fb_mem = NULL;
+	}
+	close(fb);
+	exit(0);
+}
+
+int main(int argc, char **argv)
+{
+	signal(SIGINT, fb_exit);
+	signal(SIGQUIT, fb_exit);
+	signal(SIGTERM, fb_exit);
+
+	if (argc < 2) {
+		usage();
+		return 0;
+	}
+
+	fb = open("/dev/fb0", O_RDWR);
+	if (fb < 0) {
+		perror("Open fb error");
+		return -1;
+	}
+
+	if (init_param(argc, argv) < 0)
+		return -1;
+
+	printf("Set color map ...\n");
+	if (fb_put_cmap(fb_color_id) < 0)
+		return -1;
+
+	printf("Initialize frame buffer ...\n");
+	if (fb_init() < 0)
+		return -1;
+
+	if (!flag_time_display) {
+		if (flag_string) {
+			printf("Display text ...\n\t");
+			if (fb_text_display() < 0)
+				goto EXIT;
+		} else {
+			printf("Display rectangle ...\n");
+			fb_rectangle_display();
+		}
+	}
+
+	if (flag_time_display) {
+		struct itimerval st_new = { { 1, 0 }, { 1, 0 } };
+		struct itimerval st_old;
+		printf("Display time ...\n\t");
+		if (fb_time_display() < 0)
+			goto EXIT;
+
+		signal(SIGALRM, time_callback);
+		setitimer(ITIMER_REAL, &st_new, &st_old);
+	}
+
+	while (1)
+		sleep(10);
+
+EXIT:
+	fb_exit();
+	return 0;
+}
+
+
diff --git a/misc/test_uhc_stg.c b/misc/test_uhc_stg.c
index 773e442..eb82436 100644
--- a/misc/test_uhc_stg.c
+++ b/misc/test_uhc_stg.c
@@ -1,85 +1,85 @@
-/*
- * test_ide.c
- *
- * History:
- *	2011/06/21 - [Cao Rongrong] created file
- *
- * Copyright (C) 2007-2008, Ambarella, Inc.
- *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
- *
- */
-
-/* test_uhc_stg is used to test USB host controller which is
- * interfacing with a USB drive.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <time.h>
-
-#define BUFFER_SIZE	(5 * 1024 * 1024)
-#define	TEST_SIZE	(20 * BUFFER_SIZE)
-
-int main(int argc,char *argv[])
-{
-	char filename[128], buf[BUFFER_SIZE];
-	int fd, n, cnt = 1, size;
-	float spd;
-	time_t tm_begin, tm_end, tm_diff;
-
-	if (argc > 1)
-		strcpy(filename, argv[1]);
-	else
-		strcpy(filename, "/tmp/sda1/Ducks.Take.Off.1080p.QHD.CRF25.x264-CtrlHD.mkv");
-
-	fd = open(filename, O_RDONLY);
-	if(fd < 0) {
-		perror("open failed!\n");
-                exit(-1);
-	}
-
-	printf("start to read ...\n");
-
-	do {
-		size = 0;
-		time(&tm_begin);
-		do {
-			n = read(fd, buf, BUFFER_SIZE);
-			if (n < 0) {
-				perror("read failed");
-				exit(-1);
-			}
-			if (n == 0) {
-				printf("read again (%d) ...\n", cnt++);
-				lseek(fd, 0, SEEK_SET);
-				break;
-			}
-			size += n;
-		} while (size < TEST_SIZE);
-		time(&tm_end);
-		tm_diff = tm_end - tm_begin;
-		if (tm_diff <= 0)
-			printf("time elapsed: %ds, speed is NULL\n", (int)tm_diff);
-		else {
-			spd = TEST_SIZE / tm_diff;
-			printf("time elapsed: %ds, speed is %.2f MB/s 11\n", (int)tm_diff, spd / 1000000);
-		}
-
-		if(system ("echo 3 > /proc/sys/vm/drop_caches") < 0 )
-			perror("drop_caches");
-	} while(1);
-
-	close(fd);
-
-	return 0;
-}
-
-
+/*
+ * test_ide.c
+ *
+ * History:
+ *	2011/06/21 - [Cao Rongrong] created file
+ *
+ * Copyright (C) 2007-2008, Ambarella, Inc.
+ *
+ * All rights reserved. No Part of this file may be reproduced, stored
+ * in a retrieval system, or transmitted, in any form, or by any means,
+ * electronic, mechanical, photocopying, recording, or otherwise,
+ * without the prior consent of Ambarella, Inc.
+ *
+ */
+
+/* test_uhc_stg is used to test USB host controller which is
+ * interfacing with a USB drive.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <time.h>
+
+#define BUFFER_SIZE	(5 * 1024 * 1024)
+#define	TEST_SIZE	(20 * BUFFER_SIZE)
+
+int main(int argc,char *argv[])
+{
+	char filename[128], buf[BUFFER_SIZE];
+	int fd, n, cnt = 1, size;
+	float spd;
+	time_t tm_begin, tm_end, tm_diff;
+
+	if (argc > 1)
+		strcpy(filename, argv[1]);
+	else
+		strcpy(filename, "/tmp/sda1/Ducks.Take.Off.1080p.QHD.CRF25.x264-CtrlHD.mkv");
+
+	fd = open(filename, O_RDONLY);
+	if(fd < 0) {
+		perror("open failed!\n");
+                exit(-1);
+	}
+
+	printf("start to read ...\n");
+
+	do {
+		size = 0;
+		time(&tm_begin);
+		do {
+			n = read(fd, buf, BUFFER_SIZE);
+			if (n < 0) {
+				perror("read failed");
+				exit(-1);
+			}
+			if (n == 0) {
+				printf("read again (%d) ...\n", cnt++);
+				lseek(fd, 0, SEEK_SET);
+				break;
+			}
+			size += n;
+		} while (size < TEST_SIZE);
+		time(&tm_end);
+		tm_diff = tm_end - tm_begin;
+		if (tm_diff <= 0)
+			printf("time elapsed: %ds, speed is NULL\n", (int)tm_diff);
+		else {
+			spd = TEST_SIZE / tm_diff;
+			printf("time elapsed: %ds, speed is %.2f MB/s 11\n", (int)tm_diff, spd / 1000000);
+		}
+
+		if(system ("echo 3 > /proc/sys/vm/drop_caches") < 0 )
+			perror("drop_caches");
+	} while(1);
+
+	close(fd);
+
+	return 0;
+}
+
+
diff --git a/nand/test_nand.c b/nand/test_nand.c
index e8748e3..4769883 100644
--- a/nand/test_nand.c
+++ b/nand/test_nand.c
@@ -1,256 +1,256 @@
-/*
- * test_nand.c
- *
- * History:
- *	2008/7/10 - [Cao Rongrong] created file
- *
- * Copyright (C) 2007-2008, Ambarella, Inc.
- *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
- *
- */
-
-
-#include "test_nand.h"
-
-pthread_t wf_fid, rf_fid, df_fid;
-FILE *fd_null;
-int   fd_result;
-char goon_flag;
-
-void usage(void)
-{
-
-	printf("\nusage:\n");
-	printf("\tThis program just do the Fatigue Testing for Nand Driver.\n");
-	printf("\tFor functional test, please take MTD-tools.\n");
-	printf("\nThe result of test times will be written to /mnt/result.txt\n");
-	printf("\nPress 'CTRL + C' to quit\n\n");
-}
-
-int main(int argc,char *argv[])
-{
-         int error, i;
-         Fname fn[10];
-	 char file_name[10][30];
-
-	 goon_flag = 1;
-
-	 signal(SIGABRT, signal_handler);
-
-	 if(argc > 1){
-	 	usage();
-		return 1;
-	 }
-
-	 for(i = 0; i < 10; i++){
-	 	sprintf(file_name[i], "/home/default/%d", i);
-		pthread_mutex_init(&fn[i].op_mutex, NULL);
-	 	fn[i].op_file = file_name[i];
-		fn[i].rd_flag = 0;
-	 }
-
-         if ((error = pthread_create(&wf_fid ,NULL, writefile, fn))<0)
-         {
-                  perror("can't create pthread");
-                  return 1;
-         }
-
-	 if ((error = pthread_create(&rf_fid, NULL, readfile, fn))<0)
-         {
-                  perror("can't create pthread");
-                  return 1;
-         }
-
-	 if ((error = pthread_create(&df_fid, NULL, deletefile, fn))<0)
-         {
-                  perror("can't create pthread");
-                  return 1;
-         }
-
-         while(1);
-
-         return 0;
-}
-
-
-void *writefile(void *arg)
-{
-	Fname *fn = (Fname *)arg;
-        FILE *fd;
-	int i, j;
-
-	fprintf(stderr, "Enter writefile\n");
-
-	while(goon_flag) {
-
-		for(i = 0; i < 10 && goon_flag; i++){
-
-			pthread_mutex_lock(&fn[i].op_mutex);
-
-			fd = fopen(fn[i].op_file, "r");
-			if(fd != NULL) {
-				fclose(fd);
-				fd = NULL;
-				pthread_mutex_unlock(&fn[i].op_mutex);
-		                continue;
-			}
-
-			fd = fopen(fn[i].op_file, "w+");
-			if(fd == NULL) {
-				fprintf(stderr, "Can't write or create file %d\n", i);
-		                exit(1);
-			}
-
-			fprintf(stderr, "write file: %s\n", fn[i].op_file);
-			
-			fn[i].rd_flag = 0;
-			for(j = 0; j < 10000; j++){
-				fputc(j, fd);
-			}
-			
-			fclose(fd);
-			fd = NULL;
-			
-			pthread_mutex_unlock(&fn[i].op_mutex);
-		}
-	 }
-
-	 pthread_exit(NULL);
-
-         return NULL;
-}
-
-void *readfile(void *arg)
-{
-         Fname *fn = (Fname *)arg;
-         FILE *fd;
-	 int i, c;
-
-	 fprintf(stderr, "Enter readfile\n");
-
-	 fd_null = fopen("/dev/null", "w");
-	 if(fd_null == NULL) {
-	 	fprintf(stderr, "Can't open /dev/null\n");
-		exit(1);
-	 }
-
-	 while(goon_flag) {
-
-		for(i = 0; i < 10 && goon_flag; i++){
-			
-			pthread_mutex_lock(&fn[i].op_mutex);
-
-			fd = fopen(fn[i].op_file, "r");
-			if(fd == NULL) {
-				// file is not exist
-				pthread_mutex_unlock(&fn[i].op_mutex);
-				continue;
-			}
-
-			fprintf(stderr, "read file: %s\n", fn[i].op_file);
-
-	                while (!feof(fd)){
-				c = fgetc(fd);
-				fputc(c, fd_null);
-	                }
-
-			// have been read
-			fn[i].rd_flag = 1;
-
-			fclose(fd);
-			fd = NULL;
-
-			pthread_mutex_unlock(&fn[i].op_mutex);
-		}
-	 }
-
-	 pthread_exit(NULL);
-
-         return NULL;
-}
-
-void *deletefile(void *arg)
-{
-         Fname *fn = (Fname *)arg;
-	 FILE *fd;
-	 int i, err;
-	 char read_result[50];
- 	 unsigned long long times = 0;
-
-	 fprintf(stderr, "Enter deletefile\n");
-
-	 fd_result = open("/mnt/result.txt", O_WRONLY | O_CREAT, 0644);
-	 if(fd_result < 0) {
-		fprintf(stderr, "Can't create result file\n");
-		exit(1);
-	 }
-
-	 while(goon_flag) {
-
-		for(i = 0; i < 10 && goon_flag; i++){
-			
-			pthread_mutex_lock(&fn[i].op_mutex);
-
-			fd = fopen(fn[i].op_file, "r");
-			if(fd == NULL) {
-				// file is not exist
-				pthread_mutex_unlock(&fn[i].op_mutex);
-		                continue;
-			}
-			fclose(fd);
-			fd = NULL;
-
-			if(fn[i].rd_flag == 0) {
-				// file have not been read
-				pthread_mutex_unlock(&fn[i].op_mutex);
-				continue;
-			}
-
-			err = remove(fn[i].op_file);
-			if(err < 0) {
-				fprintf(stderr, "Can't delete file %d\n", i);
-				exit(1);
-			}
-
-			fn[i].rd_flag = 0;
-
-			fprintf(stderr, "delete file: %s\n", fn[i].op_file);
-			
-			// Written the result
-			times++;
-			sprintf(read_result, "Test times: %lld\r\n", times);
-			err = write(fd_result, read_result, strlen(read_result));
-			if(err != strlen(read_result))
-				fprintf(stderr, "write result error\n");
-
-			pthread_mutex_unlock(&fn[i].op_mutex);
-		}
-	 }
-
-	 pthread_exit(NULL);
-	 
-         return NULL;
-}
-
-
-void signal_handler(int sig)
-{
-	fprintf(stderr, "Aborted by signal...\n");	
-
-	goon_flag = 0;
-
-	pthread_join(wf_fid, NULL);
-	pthread_join(df_fid, NULL);
-	pthread_join(df_fid, NULL);
-
-	fclose(fd_null);
-	close(fd_result);
-
-	exit(1);
-}
-
-
+/*
+ * test_nand.c
+ *
+ * History:
+ *	2008/7/10 - [Cao Rongrong] created file
+ *
+ * Copyright (C) 2007-2008, Ambarella, Inc.
+ *
+ * All rights reserved. No Part of this file may be reproduced, stored
+ * in a retrieval system, or transmitted, in any form, or by any means,
+ * electronic, mechanical, photocopying, recording, or otherwise,
+ * without the prior consent of Ambarella, Inc.
+ *
+ */
+
+
+#include "test_nand.h"
+
+pthread_t wf_fid, rf_fid, df_fid;
+FILE *fd_null;
+int   fd_result;
+char goon_flag;
+
+void usage(void)
+{
+
+	printf("\nusage:\n");
+	printf("\tThis program just do the Fatigue Testing for Nand Driver.\n");
+	printf("\tFor functional test, please take MTD-tools.\n");
+	printf("\nThe result of test times will be written to /mnt/result.txt\n");
+	printf("\nPress 'CTRL + C' to quit\n\n");
+}
+
+int main(int argc,char *argv[])
+{
+         int error, i;
+         Fname fn[10];
+	 char file_name[10][30];
+
+	 goon_flag = 1;
+
+	 signal(SIGABRT, signal_handler);
+
+	 if(argc > 1){
+	 	usage();
+		return 1;
+	 }
+
+	 for(i = 0; i < 10; i++){
+	 	sprintf(file_name[i], "/home/default/%d", i);
+		pthread_mutex_init(&fn[i].op_mutex, NULL);
+	 	fn[i].op_file = file_name[i];
+		fn[i].rd_flag = 0;
+	 }
+
+         if ((error = pthread_create(&wf_fid ,NULL, writefile, fn))<0)
+         {
+                  perror("can't create pthread");
+                  return 1;
+         }
+
+	 if ((error = pthread_create(&rf_fid, NULL, readfile, fn))<0)
+         {
+                  perror("can't create pthread");
+                  return 1;
+         }
+
+	 if ((error = pthread_create(&df_fid, NULL, deletefile, fn))<0)
+         {
+                  perror("can't create pthread");
+                  return 1;
+         }
+
+         while(1);
+
+         return 0;
+}
+
+
+void *writefile(void *arg)
+{
+	Fname *fn = (Fname *)arg;
+        FILE *fd;
+	int i, j;
+
+	fprintf(stderr, "Enter writefile\n");
+
+	while(goon_flag) {
+
+		for(i = 0; i < 10 && goon_flag; i++){
+
+			pthread_mutex_lock(&fn[i].op_mutex);
+
+			fd = fopen(fn[i].op_file, "r");
+			if(fd != NULL) {
+				fclose(fd);
+				fd = NULL;
+				pthread_mutex_unlock(&fn[i].op_mutex);
+		                continue;
+			}
+
+			fd = fopen(fn[i].op_file, "w+");
+			if(fd == NULL) {
+				fprintf(stderr, "Can't write or create file %d\n", i);
+		                exit(1);
+			}
+
+			fprintf(stderr, "write file: %s\n", fn[i].op_file);
+			
+			fn[i].rd_flag = 0;
+			for(j = 0; j < 10000; j++){
+				fputc(j, fd);
+			}
+			
+			fclose(fd);
+			fd = NULL;
+			
+			pthread_mutex_unlock(&fn[i].op_mutex);
+		}
+	 }
+
+	 pthread_exit(NULL);
+
+         return NULL;
+}
+
+void *readfile(void *arg)
+{
+         Fname *fn = (Fname *)arg;
+         FILE *fd;
+	 int i, c;
+
+	 fprintf(stderr, "Enter readfile\n");
+
+	 fd_null = fopen("/dev/null", "w");
+	 if(fd_null == NULL) {
+	 	fprintf(stderr, "Can't open /dev/null\n");
+		exit(1);
+	 }
+
+	 while(goon_flag) {
+
+		for(i = 0; i < 10 && goon_flag; i++){
+			
+			pthread_mutex_lock(&fn[i].op_mutex);
+
+			fd = fopen(fn[i].op_file, "r");
+			if(fd == NULL) {
+				// file is not exist
+				pthread_mutex_unlock(&fn[i].op_mutex);
+				continue;
+			}
+
+			fprintf(stderr, "read file: %s\n", fn[i].op_file);
+
+	                while (!feof(fd)){
+				c = fgetc(fd);
+				fputc(c, fd_null);
+	                }
+
+			// have been read
+			fn[i].rd_flag = 1;
+
+			fclose(fd);
+			fd = NULL;
+
+			pthread_mutex_unlock(&fn[i].op_mutex);
+		}
+	 }
+
+	 pthread_exit(NULL);
+
+         return NULL;
+}
+
+void *deletefile(void *arg)
+{
+         Fname *fn = (Fname *)arg;
+	 FILE *fd;
+	 int i, err;
+	 char read_result[50];
+ 	 unsigned long long times = 0;
+
+	 fprintf(stderr, "Enter deletefile\n");
+
+	 fd_result = open("/mnt/result.txt", O_WRONLY | O_CREAT, 0644);
+	 if(fd_result < 0) {
+		fprintf(stderr, "Can't create result file\n");
+		exit(1);
+	 }
+
+	 while(goon_flag) {
+
+		for(i = 0; i < 10 && goon_flag; i++){
+			
+			pthread_mutex_lock(&fn[i].op_mutex);
+
+			fd = fopen(fn[i].op_file, "r");
+			if(fd == NULL) {
+				// file is not exist
+				pthread_mutex_unlock(&fn[i].op_mutex);
+		                continue;
+			}
+			fclose(fd);
+			fd = NULL;
+
+			if(fn[i].rd_flag == 0) {
+				// file have not been read
+				pthread_mutex_unlock(&fn[i].op_mutex);
+				continue;
+			}
+
+			err = remove(fn[i].op_file);
+			if(err < 0) {
+				fprintf(stderr, "Can't delete file %d\n", i);
+				exit(1);
+			}
+
+			fn[i].rd_flag = 0;
+
+			fprintf(stderr, "delete file: %s\n", fn[i].op_file);
+			
+			// Written the result
+			times++;
+			sprintf(read_result, "Test times: %lld\r\n", times);
+			err = write(fd_result, read_result, strlen(read_result));
+			if(err != strlen(read_result))
+				fprintf(stderr, "write result error\n");
+
+			pthread_mutex_unlock(&fn[i].op_mutex);
+		}
+	 }
+
+	 pthread_exit(NULL);
+	 
+         return NULL;
+}
+
+
+void signal_handler(int sig)
+{
+	fprintf(stderr, "Aborted by signal...\n");	
+
+	goon_flag = 0;
+
+	pthread_join(wf_fid, NULL);
+	pthread_join(df_fid, NULL);
+	pthread_join(df_fid, NULL);
+
+	fclose(fd_null);
+	close(fd_result);
+
+	exit(1);
+}
+
+
diff --git a/nand/test_nand.h b/nand/test_nand.h
index 9494134..74fba51 100644
--- a/nand/test_nand.h
+++ b/nand/test_nand.h
@@ -1,55 +1,55 @@
-/*
- * test_nand.h
- *
- * History:
- *	2008/7/10 - [Cao Rongrong] created file
- *
- * Copyright (C) 2007-2008, Ambarella, Inc.
- *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
- *
- */
-
-
-#ifndef   TEST_NAND_H
-#define   TEST_NAND_H
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <pthread.h>
-
-#include <sys/stat.h>
-#include <sys/times.h>
-#include <sys/socket.h>
-#include <sys/types.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <sys/signal.h>
-
-
-typedef struct 
-{
-         pthread_mutex_t op_mutex;
-         char *op_file;
-	 char rd_flag;
-	 
-}Fname;
-
-void *readfile(void *arg);
-
-void *writefile(void *arg);
-
-void *deletefile(void *arg);
-
-void signal_handler(int sig);
-
-
-#endif /* end   */
-
+/*
+ * test_nand.h
+ *
+ * History:
+ *	2008/7/10 - [Cao Rongrong] created file
+ *
+ * Copyright (C) 2007-2008, Ambarella, Inc.
+ *
+ * All rights reserved. No Part of this file may be reproduced, stored
+ * in a retrieval system, or transmitted, in any form, or by any means,
+ * electronic, mechanical, photocopying, recording, or otherwise,
+ * without the prior consent of Ambarella, Inc.
+ *
+ */
+
+
+#ifndef   TEST_NAND_H
+#define   TEST_NAND_H
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <pthread.h>
+
+#include <sys/stat.h>
+#include <sys/times.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <sys/signal.h>
+
+
+typedef struct 
+{
+         pthread_mutex_t op_mutex;
+         char *op_file;
+	 char rd_flag;
+	 
+}Fname;
+
+void *readfile(void *arg);
+
+void *writefile(void *arg);
+
+void *deletefile(void *arg);
+
+void signal_handler(int sig);
+
+
+#endif /* end   */
+
diff --git a/usb/test_usb_file.c b/usb/test_usb_file.c
index 4d23d11..9711592 100644
--- a/usb/test_usb_file.c
+++ b/usb/test_usb_file.c
@@ -1,423 +1,423 @@
-/*
- * test_usb_file.c
- *
- * History:
- *	2009/01/04 - [Cao Rongrong] created file
- *
- * Copyright (C) 2007-2008, Ambarella, Inc.
- *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
- *
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <errno.h>
-#include <sys/time.h>
-
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include "basetypes.h"
-
-#include "amba_usb.h"
-
-char *device = "/dev/amb_gadget";
-
-char *default_file_name = "/mnt/usb_up_file.dat";
-char file_to_write[256];// = "/mnt/file_usb.dat";
-//char *file_to_read = "/mnt/media/test_main.264";
-
-int fd_usb = 0;
-
-#define PORT_NUM 2000
-#define MAX_MEASURE_NUM	500 * 1024 * 1024
-
-static u32 rx_state;
-static int total_length = 0;
-
-char filename[256];
-struct amb_usb_buf *usb_buf = NULL;
-
-u32 pkt_size;
-
-void usage(void)
-{
-
-	printf("\nusage:\n");
-	printf("\tThis program is used to verify the feasibility of data"
-		" transfer with usb.\n");
-	printf("\tIt use a simple protocol to transfer data between host"
-		" and the platform.\n");
-	printf("\nPress 'CTRL + C' to quit\n\n");
-}
-
-int send_data(const char *buf, int length)
-{
-	int rval = 0;
-
-	rval = write(fd_usb, buf, length);
-	if(rval < 0)
-		perror("send_data error\n");
-	
-	return rval;
-}
-
-int send_file()
-{
-	int rval;
-	int fd = 0;
-	static unsigned long num = 0;
-
-	total_length = 0;
-
-	if(rx_state != MEASURE_SPEED_PHASE) {
-		fd = open(filename, O_RDONLY);
-		if (fd < 0) {
-			perror("open file to read");
-			return fd;
-		}
-	}
-
-	while(1){
-		if(rx_state == MEASURE_SPEED_PHASE){
-			/*for(i = 0; i < pkt_size - USB_HEAD_SIZE; i++)
-				usb_buf->buffer[i] = i;
-			*/
-
-			num += (pkt_size - USB_HEAD_SIZE);
-			if(num < MAX_MEASURE_NUM)
-				rval = pkt_size - USB_HEAD_SIZE;
-			else
-				rval = 0;
-		} else {
-			rval = read(fd, usb_buf->buffer, pkt_size - USB_HEAD_SIZE);
-			if (rval < 0)
-				break;
-		}
-
-		total_length += rval;
-
-		usb_buf->head.port_id = PORT_NUM;
-		usb_buf->head.size = rval;
-		rval = send_data((char *)usb_buf, pkt_size);
-		if(rval < 0)
-			break;
-
-		/* read the file end */
-		if(usb_buf->head.size == 0){
-			num = 0;
-			break;
-		}
-	}
-
-	if(rx_state != MEASURE_SPEED_PHASE) {
-		close(fd);
-	}
-	return rval;
-	
-}
-
-int recv_data(char *buf, int length)
-{
-	int rval = 0;
-	struct amb_usb_head *head;
-
-	rval = read(fd_usb, buf, length);
-	if(rval < 0){
-		perror("read usb error");
-		return rval;
-	}
-
-	head = (struct amb_usb_head *)buf;
-	if(head->port_id != PORT_NUM){
-		printf("port_id error: %d\n", head->port_id);
-		return -1;
-	}
-
-	return rval;
-}
-
-int recv_file()
-{
-	int rval = 0, fd = 0;
-
-	total_length = 0;
-
-	if(rx_state != MEASURE_SPEED_PHASE){
-		fd = open(file_to_write, O_CREAT | O_TRUNC | O_WRONLY, 0644);
-		if (fd < 0) {
-			perror("can't open file to write");
-			return fd;
-		}
-	}
-
-	while(1){
-		rval = recv_data((char *)usb_buf, pkt_size);
-		if (rval < 0){
-			printf("recv_data error\n");
-			break;
-		}
-
-		if(rx_state == MEASURE_SPEED_PHASE){
-			rval = usb_buf->head.size;
-		} else {
-			rval = write(fd, usb_buf->buffer, usb_buf->head.size);
-			if(rval < 0){
-				perror("write data");
-				break;
-			}
-		}
-
-		total_length += rval;
-		
-		if(rval == 0){
-			break;
-		}
-	}
-
-	if(rx_state != MEASURE_SPEED_PHASE)
-		close(fd);
-	return rval;
-}
-
-
-int get_command(struct amb_usb_cmd *cmd)
-{
-	int rval = 0;
-
-	rval = ioctl(fd_usb, AMB_DATA_STREAM_RD_CMD, cmd);
-	if (rval < 0) {
-		printf("read command error");
- 		return rval;
-	}
-
-	if (cmd->signature != AMB_COMMAND_TOKEN) {
-		printf("Wrong signature: %08x\n", cmd->signature);
-		return -EINVAL;
-	}
-
-	//printf("signature = 0x%x, command = 0x%x, parameter[0] = %d\n",
-	//	cmd->signature, cmd->command, cmd->parameter[0]);
-
-	return 0;
-}
-
-int set_response(int response)
-{
-	struct amb_usb_rsp rsp;
-
-	rsp.signature = AMB_STATUS_TOKEN;
-	rsp.response = response;
-
-	if (ioctl(fd_usb, AMB_DATA_STREAM_WR_RSP, &rsp) < 0) {
-		perror("ioctl error");
-		return -1;
-	}
-
-	return 0;
-}
-
-
-int main(int argc,char *argv[])
-{
-	int rval = 0;
-	char *file_tmp;
-	struct timeval tm_begin, tm_end;
-	int run_time;
-	
-	if( argc > 1 && (strcmp(argv[1], "-h") == 0 || strcmp(argv[1], "--help") == 0)){
-		usage();
-		return 1;
-	}
-
-	if(argc == 2)
-		file_tmp = argv[1];
-	else
-		file_tmp = default_file_name;
-
-	rx_state = COMMAND_PHASE;
-
-	fd_usb = open(device, O_RDWR);
-	if (fd_usb < 0) {
-		perror("can't open device");
-		exit(1);
-	}
-
-	rval = 0;
-	while(1){
-		switch(rx_state)
-		{
-		case COMMAND_PHASE:
-		{
-			struct amb_usb_cmd cmd;
-			u32 rsp;
-			
-			strcpy(filename, file_tmp);
-			
-			get_command(&cmd);
-			/* Process command */
-			switch (cmd.command)
-			{
-			case USB_CMD_SET_MODE:
-				rsp = AMB_RSP_SUCCESS;
-
-				if (cmd.parameter[0] == AMB_CMD_PARA_UP)
-					rx_state = SND_FILENAME_PHASE;
-				else if(cmd.parameter[0] == AMB_CMD_PARA_DOWN)
-					rx_state = RCV_FILENAME_PHASE;
-				else if(cmd.parameter[0] == AMB_CMD_PARA_MEASURE_SPD)
-					rx_state = MEASURE_SPEED_PHASE;					
-				else {
-					printf("parameter error: %d\n", cmd.parameter[0]);
-					rsp = AMB_RSP_FAILED;
-				}
-
-				pkt_size = cmd.parameter[1];
-				usb_buf = malloc(pkt_size);
-
-				/* response to the host */
-				set_response(rsp);					
-				break;
-
-			default:
-				printf ("Unknown command: %08x\n", cmd.command);
-				rval = -1;
-				break;
-			}
-
-			break;
-		}
-
-		case SND_FILENAME_PHASE:
-			usb_buf->head.port_id = PORT_NUM;
-			usb_buf->head.size = sizeof(filename);
-			strcpy(usb_buf->buffer, filename);
-			
-			rval = send_data((char *)usb_buf, pkt_size);
-			if(rval < 0)
-				break;
-			
-			rx_state = SND_DATA_PHASE;
-			break;
-			
-		case SND_DATA_PHASE:
-			gettimeofday(&tm_begin, NULL);
-			rval = send_file();
-			gettimeofday(&tm_end, NULL);
-			run_time = (tm_end.tv_sec - tm_begin.tv_sec) * 1000000 +
-				(tm_end.tv_usec - tm_begin.tv_usec);
-			printf("send done, total size = %d\n", total_length);
-			if(run_time > 0){
-				printf("USB transfer speed is %.2f MB/s\n\n", 
-					(float)total_length / run_time);
-			}
-			else {
-				printf("the file size is too small to calculate "
-					"transfer speed\n\n");
-			}
-			
-			if(usb_buf){
-				free(usb_buf);
-				usb_buf = NULL;
-			}
-			rx_state = COMMAND_PHASE;
-			break;
-
-		case RCV_FILENAME_PHASE:
-			rval = recv_data((char *)usb_buf, pkt_size);
-			if(rval < 0){
-				printf("recv filename error\n");
-				break;
-			}
-
-			sprintf(filename, "%s", usb_buf->buffer);
-			sprintf(file_to_write, "/mnt/%s", usb_buf->buffer);
-			rx_state = RCV_DATA_PHASE;
-			break;
-
-		case RCV_DATA_PHASE:
-			gettimeofday(&tm_begin, NULL);
-			rval = recv_file();
-			gettimeofday(&tm_end, NULL);
-			run_time = (tm_end.tv_sec - tm_begin.tv_sec) * 1000000 +
-				(tm_end.tv_usec - tm_begin.tv_usec);
-			printf("recv done, total size = %d\n", total_length);
-			if(run_time > 0){
-				printf("USB transfer speed is %.2f MB/s\n\n",
-					(float)total_length / run_time);
-			}
-			else {
-				printf("the file size is too small to calculate "
-					"transfer speed\n\n");
-			}
-			
-			if(usb_buf){
-				free(usb_buf);
-				usb_buf = NULL;
-			}
-			rx_state = COMMAND_PHASE;		
-			break;
-
-		case MEASURE_SPEED_PHASE:
-		{
-			char measure[256] = "measure data";
-			
-			/* download from PC */
-			gettimeofday(&tm_begin, NULL);
-			rval = recv_file();
-			gettimeofday(&tm_end, NULL);
-			printf("recv done, total size = %d\n", total_length);
-			run_time = (tm_end.tv_sec - tm_begin.tv_sec) * 1000000 +
-				(tm_end.tv_usec - tm_begin.tv_usec);
-			printf("USB download speed is %.2f MB/s\n\n",
-					(float)total_length / run_time);
-
-			/* upload to PC */
-			usb_buf->head.port_id = PORT_NUM;
-			usb_buf->head.size = sizeof(measure);
-			strcpy(usb_buf->buffer, measure);			
-			rval = send_data((char *)usb_buf, pkt_size);
-			if(rval < 0)
-				break;
-
-			gettimeofday(&tm_begin, NULL);
-			rval = send_file();
-			gettimeofday(&tm_end, NULL);
-			printf("send done, total size = %d\n", total_length);
-			run_time = (tm_end.tv_sec - tm_begin.tv_sec) * 1000000 +
-				(tm_end.tv_usec - tm_begin.tv_usec);
-			printf("USB upload speed is %.2f MB/s\n\n",
-					(float)total_length / run_time);
-
-			if(usb_buf){
-				free(usb_buf);
-				usb_buf = NULL;
-			}
-			rx_state = COMMAND_PHASE;
-			break;
-		}
-
-		default:
-			printf("rx_state (PHASE) error\n");
-			break;
-
-		}
-
-		if(rval < 0){
-			printf("some error happened\n");
-			break;
-		}
-	}
-
-	close(fd_usb);
-
-	
-	return 0;
-}
-
-
+/*
+ * test_usb_file.c
+ *
+ * History:
+ *	2009/01/04 - [Cao Rongrong] created file
+ *
+ * Copyright (C) 2007-2008, Ambarella, Inc.
+ *
+ * All rights reserved. No Part of this file may be reproduced, stored
+ * in a retrieval system, or transmitted, in any form, or by any means,
+ * electronic, mechanical, photocopying, recording, or otherwise,
+ * without the prior consent of Ambarella, Inc.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sys/time.h>
+
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include "basetypes.h"
+
+#include "amba_usb.h"
+
+char *device = "/dev/amb_gadget";
+
+char *default_file_name = "/mnt/usb_up_file.dat";
+char file_to_write[256];// = "/mnt/file_usb.dat";
+//char *file_to_read = "/mnt/media/test_main.264";
+
+int fd_usb = 0;
+
+#define PORT_NUM 2000
+#define MAX_MEASURE_NUM	500 * 1024 * 1024
+
+static u32 rx_state;
+static int total_length = 0;
+
+char filename[256];
+struct amb_usb_buf *usb_buf = NULL;
+
+u32 pkt_size;
+
+void usage(void)
+{
+
+	printf("\nusage:\n");
+	printf("\tThis program is used to verify the feasibility of data"
+		" transfer with usb.\n");
+	printf("\tIt use a simple protocol to transfer data between host"
+		" and the platform.\n");
+	printf("\nPress 'CTRL + C' to quit\n\n");
+}
+
+int send_data(const char *buf, int length)
+{
+	int rval = 0;
+
+	rval = write(fd_usb, buf, length);
+	if(rval < 0)
+		perror("send_data error\n");
+	
+	return rval;
+}
+
+int send_file()
+{
+	int rval;
+	int fd = 0;
+	static unsigned long num = 0;
+
+	total_length = 0;
+
+	if(rx_state != MEASURE_SPEED_PHASE) {
+		fd = open(filename, O_RDONLY);
+		if (fd < 0) {
+			perror("open file to read");
+			return fd;
+		}
+	}
+
+	while(1){
+		if(rx_state == MEASURE_SPEED_PHASE){
+			/*for(i = 0; i < pkt_size - USB_HEAD_SIZE; i++)
+				usb_buf->buffer[i] = i;
+			*/
+
+			num += (pkt_size - USB_HEAD_SIZE);
+			if(num < MAX_MEASURE_NUM)
+				rval = pkt_size - USB_HEAD_SIZE;
+			else
+				rval = 0;
+		} else {
+			rval = read(fd, usb_buf->buffer, pkt_size - USB_HEAD_SIZE);
+			if (rval < 0)
+				break;
+		}
+
+		total_length += rval;
+
+		usb_buf->head.port_id = PORT_NUM;
+		usb_buf->head.size = rval;
+		rval = send_data((char *)usb_buf, pkt_size);
+		if(rval < 0)
+			break;
+
+		/* read the file end */
+		if(usb_buf->head.size == 0){
+			num = 0;
+			break;
+		}
+	}
+
+	if(rx_state != MEASURE_SPEED_PHASE) {
+		close(fd);
+	}
+	return rval;
+	
+}
+
+int recv_data(char *buf, int length)
+{
+	int rval = 0;
+	struct amb_usb_head *head;
+
+	rval = read(fd_usb, buf, length);
+	if(rval < 0){
+		perror("read usb error");
+		return rval;
+	}
+
+	head = (struct amb_usb_head *)buf;
+	if(head->port_id != PORT_NUM){
+		printf("port_id error: %d\n", head->port_id);
+		return -1;
+	}
+
+	return rval;
+}
+
+int recv_file()
+{
+	int rval = 0, fd = 0;
+
+	total_length = 0;
+
+	if(rx_state != MEASURE_SPEED_PHASE){
+		fd = open(file_to_write, O_CREAT | O_TRUNC | O_WRONLY, 0644);
+		if (fd < 0) {
+			perror("can't open file to write");
+			return fd;
+		}
+	}
+
+	while(1){
+		rval = recv_data((char *)usb_buf, pkt_size);
+		if (rval < 0){
+			printf("recv_data error\n");
+			break;
+		}
+
+		if(rx_state == MEASURE_SPEED_PHASE){
+			rval = usb_buf->head.size;
+		} else {
+			rval = write(fd, usb_buf->buffer, usb_buf->head.size);
+			if(rval < 0){
+				perror("write data");
+				break;
+			}
+		}
+
+		total_length += rval;
+		
+		if(rval == 0){
+			break;
+		}
+	}
+
+	if(rx_state != MEASURE_SPEED_PHASE)
+		close(fd);
+	return rval;
+}
+
+
+int get_command(struct amb_usb_cmd *cmd)
+{
+	int rval = 0;
+
+	rval = ioctl(fd_usb, AMB_DATA_STREAM_RD_CMD, cmd);
+	if (rval < 0) {
+		printf("read command error");
+ 		return rval;
+	}
+
+	if (cmd->signature != AMB_COMMAND_TOKEN) {
+		printf("Wrong signature: %08x\n", cmd->signature);
+		return -EINVAL;
+	}
+
+	//printf("signature = 0x%x, command = 0x%x, parameter[0] = %d\n",
+	//	cmd->signature, cmd->command, cmd->parameter[0]);
+
+	return 0;
+}
+
+int set_response(int response)
+{
+	struct amb_usb_rsp rsp;
+
+	rsp.signature = AMB_STATUS_TOKEN;
+	rsp.response = response;
+
+	if (ioctl(fd_usb, AMB_DATA_STREAM_WR_RSP, &rsp) < 0) {
+		perror("ioctl error");
+		return -1;
+	}
+
+	return 0;
+}
+
+
+int main(int argc,char *argv[])
+{
+	int rval = 0;
+	char *file_tmp;
+	struct timeval tm_begin, tm_end;
+	int run_time;
+	
+	if( argc > 1 && (strcmp(argv[1], "-h") == 0 || strcmp(argv[1], "--help") == 0)){
+		usage();
+		return 1;
+	}
+
+	if(argc == 2)
+		file_tmp = argv[1];
+	else
+		file_tmp = default_file_name;
+
+	rx_state = COMMAND_PHASE;
+
+	fd_usb = open(device, O_RDWR);
+	if (fd_usb < 0) {
+		perror("can't open device");
+		exit(1);
+	}
+
+	rval = 0;
+	while(1){
+		switch(rx_state)
+		{
+		case COMMAND_PHASE:
+		{
+			struct amb_usb_cmd cmd;
+			u32 rsp;
+			
+			strcpy(filename, file_tmp);
+			
+			get_command(&cmd);
+			/* Process command */
+			switch (cmd.command)
+			{
+			case USB_CMD_SET_MODE:
+				rsp = AMB_RSP_SUCCESS;
+
+				if (cmd.parameter[0] == AMB_CMD_PARA_UP)
+					rx_state = SND_FILENAME_PHASE;
+				else if(cmd.parameter[0] == AMB_CMD_PARA_DOWN)
+					rx_state = RCV_FILENAME_PHASE;
+				else if(cmd.parameter[0] == AMB_CMD_PARA_MEASURE_SPD)
+					rx_state = MEASURE_SPEED_PHASE;					
+				else {
+					printf("parameter error: %d\n", cmd.parameter[0]);
+					rsp = AMB_RSP_FAILED;
+				}
+
+				pkt_size = cmd.parameter[1];
+				usb_buf = malloc(pkt_size);
+
+				/* response to the host */
+				set_response(rsp);					
+				break;
+
+			default:
+				printf ("Unknown command: %08x\n", cmd.command);
+				rval = -1;
+				break;
+			}
+
+			break;
+		}
+
+		case SND_FILENAME_PHASE:
+			usb_buf->head.port_id = PORT_NUM;
+			usb_buf->head.size = sizeof(filename);
+			strcpy(usb_buf->buffer, filename);
+			
+			rval = send_data((char *)usb_buf, pkt_size);
+			if(rval < 0)
+				break;
+			
+			rx_state = SND_DATA_PHASE;
+			break;
+			
+		case SND_DATA_PHASE:
+			gettimeofday(&tm_begin, NULL);
+			rval = send_file();
+			gettimeofday(&tm_end, NULL);
+			run_time = (tm_end.tv_sec - tm_begin.tv_sec) * 1000000 +
+				(tm_end.tv_usec - tm_begin.tv_usec);
+			printf("send done, total size = %d\n", total_length);
+			if(run_time > 0){
+				printf("USB transfer speed is %.2f MB/s\n\n", 
+					(float)total_length / run_time);
+			}
+			else {
+				printf("the file size is too small to calculate "
+					"transfer speed\n\n");
+			}
+			
+			if(usb_buf){
+				free(usb_buf);
+				usb_buf = NULL;
+			}
+			rx_state = COMMAND_PHASE;
+			break;
+
+		case RCV_FILENAME_PHASE:
+			rval = recv_data((char *)usb_buf, pkt_size);
+			if(rval < 0){
+				printf("recv filename error\n");
+				break;
+			}
+
+			sprintf(filename, "%s", usb_buf->buffer);
+			sprintf(file_to_write, "/mnt/%s", usb_buf->buffer);
+			rx_state = RCV_DATA_PHASE;
+			break;
+
+		case RCV_DATA_PHASE:
+			gettimeofday(&tm_begin, NULL);
+			rval = recv_file();
+			gettimeofday(&tm_end, NULL);
+			run_time = (tm_end.tv_sec - tm_begin.tv_sec) * 1000000 +
+				(tm_end.tv_usec - tm_begin.tv_usec);
+			printf("recv done, total size = %d\n", total_length);
+			if(run_time > 0){
+				printf("USB transfer speed is %.2f MB/s\n\n",
+					(float)total_length / run_time);
+			}
+			else {
+				printf("the file size is too small to calculate "
+					"transfer speed\n\n");
+			}
+			
+			if(usb_buf){
+				free(usb_buf);
+				usb_buf = NULL;
+			}
+			rx_state = COMMAND_PHASE;		
+			break;
+
+		case MEASURE_SPEED_PHASE:
+		{
+			char measure[256] = "measure data";
+			
+			/* download from PC */
+			gettimeofday(&tm_begin, NULL);
+			rval = recv_file();
+			gettimeofday(&tm_end, NULL);
+			printf("recv done, total size = %d\n", total_length);
+			run_time = (tm_end.tv_sec - tm_begin.tv_sec) * 1000000 +
+				(tm_end.tv_usec - tm_begin.tv_usec);
+			printf("USB download speed is %.2f MB/s\n\n",
+					(float)total_length / run_time);
+
+			/* upload to PC */
+			usb_buf->head.port_id = PORT_NUM;
+			usb_buf->head.size = sizeof(measure);
+			strcpy(usb_buf->buffer, measure);			
+			rval = send_data((char *)usb_buf, pkt_size);
+			if(rval < 0)
+				break;
+
+			gettimeofday(&tm_begin, NULL);
+			rval = send_file();
+			gettimeofday(&tm_end, NULL);
+			printf("send done, total size = %d\n", total_length);
+			run_time = (tm_end.tv_sec - tm_begin.tv_sec) * 1000000 +
+				(tm_end.tv_usec - tm_begin.tv_usec);
+			printf("USB upload speed is %.2f MB/s\n\n",
+					(float)total_length / run_time);
+
+			if(usb_buf){
+				free(usb_buf);
+				usb_buf = NULL;
+			}
+			rx_state = COMMAND_PHASE;
+			break;
+		}
+
+		default:
+			printf("rx_state (PHASE) error\n");
+			break;
+
+		}
+
+		if(rval < 0){
+			printf("some error happened\n");
+			break;
+		}
+	}
+
+	close(fd_usb);
+
+	
+	return 0;
+}
+
+
