diff --git a/AmbaConfig b/AmbaConfig
index ae124e9..ed5b64f 100644
--- a/AmbaConfig
+++ b/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2008/01/16 - [Anthony Ginger] Create
 ##
-## Copyright (C) 2004-2008, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 menuconfig BUILD_AMBARELLA_PRIVATE_MODULES
diff --git a/drivers/AmbaConfig b/drivers/AmbaConfig
index a7d714d..873409a 100644
--- a/drivers/AmbaConfig
+++ b/drivers/AmbaConfig
@@ -2,29 +2,548 @@
 ## kernel/private/drivers/AmbaConfig
 ##
 ## History:
-##    2008/01/16 - [Anthony Ginger] Create
-##
-## Copyright (C) 2004-2018, Ambarella, Inc.
-##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
-##
-
-source kernel/private/drivers/vin/AmbaConfig
-source kernel/private/drivers/lens/AmbaConfig
-source kernel/private/drivers/vout/AmbaConfig
-source kernel/private/drivers/msg/AmbaConfig
-source kernel/private/drivers/hw_timer/AmbaConfig
-source kernel/private/drivers/dsp/AmbaConfig
-source kernel/private/drivers/iav/AmbaConfig
-source kernel/private/drivers/imgproc/AmbaConfig
-source kernel/private/drivers/fdet/AmbaConfig
-source kernel/private/drivers/gyro/AmbaConfig
-source kernel/private/drivers/eis/AmbaConfig
-source kernel/private/drivers/debug/AmbaConfig
-source kernel/private/drivers/dsplog/AmbaConfig
-source kernel/private/drivers/crypto/AmbaConfig
-source kernel/private/drivers/cryptochip/AmbaConfig
+##    2017/01/06 - [Jian Tang] Create
+##
+## Copyright (c) 2017 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+menuconfig AMBARELLA_COMMON_MACROS
+	depends on BUILD_AMBARELLA_PRIVATE_MODULES
+	bool "Define Common Macros"
+	default y
+	help
+		Define Common Macros.
+
+if AMBARELLA_COMMON_MACROS
+
+config CONFIG_AMBARELLA_MAX_CHANNEL_NUM
+	int "Max VIN Channel Number"
+	depends on (CONFIG_ARCH_S3L || CONFIG_ARCH_S5L)
+	range  1   4
+	default 1
+	help
+		Set Max VIN Channel Number.
+
+config CONFIG_AMBA_MAX_CHAN_NUM
+	int "Max total channel num for all VINs"
+	depends on (CONFIG_ARCH_S5 || CONFIG_ARCH_CV1)
+	range  1   16
+	default 1
+	help
+		Set max total channel num for all VINs.
+
+endif
+
+config AMBARELLA_BUILD_IAV_SYMBOL
+	depends on BUILD_AMBARELLA_PRIVATE_MODULES
+	bool "Build IAV symbol"
+	default n
+	help
+		Build iav symbol for platform drivers.
+##
+## kernel/private/drivers/AmbaConfig
+##
+## Following content is generated automatically by
+##  create_private_mkcfg: DO NOT EDIT!!
+##
+
+
+##### crypto
+
+config BUILD_AMBARELLA_CRYPTO
+depends on BUILD_AMBARELLA_PRIVATE_MODULES
+	bool "Build Ambarella private crypto module"
+	default n
+	help
+		Build Ambarella private crypto module for Linux.
+
+
+
+##### cryptochip
+
+menuconfig BUILD_PRIVATE_DRIVER_FOR_CRYPTOCHIP
+depends on BUILD_AMBARELLA_PRIVATE_MODULES
+	bool "Build Ambarella Private Driver for Crypt Chip"
+	default n
+	help
+		Build Ambarella Private Driver Module for Crypt Chip.
+
+if BUILD_PRIVATE_DRIVER_FOR_CRYPTOCHIP
+
+config CONFIG_CRYPTOCHIP_ATSHA204
+	depends on BUILD_PRIVATE_DRIVER_FOR_CRYPTOCHIP
+	bool "Private Driver for Atmel ATSHA204"
+	default n
+	help
+		Private Driver for Atmel ATSHA204.
+
+config BUILD_PRIVATE_ATSHA204_DRIVER_FROM_SOURCE
+	depends on CONFIG_CRYPTOCHIP_ATSHA204
+	bool "Build Private Driver of Atmel ATSHA204 from source"
+	default n
+	help
+		Build Private Driver of Atmel ATSHA204 from source.
+
+endif
+
+
+##### debug
+
+config BUILD_AMBARELLA_DEBUG
+depends on BUILD_AMBARELLA_PRIVATE_MODULES
+	bool "Build Ambarella private debug module"
+	default n
+	help
+		Build Ambarella private debug module for Linux.
+
+
+
+##### dsp
+
+menuconfig BUILD_AMBARELLA_DSP
+	depends on BUILD_AMBARELLA_PRIVATE_MODULES
+	bool "Build Ambarella private DSP module"
+	default n
+	help
+		Build Ambarella private DSP module for Linux.
+
+if BUILD_AMBARELLA_DSP
+
+config CONFIG_PRINT_DSP_CMD
+	bool "Print all commands sent to DSP by printk"
+	default n
+	help
+		Print all commands sent to DSP by printk
+
+config CONFIG_PRINT_DSP_CMD_MORE
+	depends on CONFIG_PRINT_DSP_CMD
+	bool "Print dsp commands in detailed."
+	default n
+	help
+		Print dsp commands in detailed.
+
+config CONFIG_PRINT_DSP_CMD_RAW
+	depends on CONFIG_PRINT_DSP_CMD_MORE
+	bool "Print dsp commands in hex."
+	default n
+	help
+		Print dsp commands in hex.
+
+choice
+prompt "Choose DSP log start address"
+default CONFIG_DSP_LOG_START_0X80000
+help
+	Reset DSP log start address to 0x80000
+
+config CONFIG_DSP_LOG_START_0X80000
+	bool "Start from 0x80000"
+
+config CONFIG_DSP_LOG_START_IAVMEM
+	bool "Start from IAV mem end"
+
+endchoice
+
+endif
+
+
+
+##### dsplog
+
+menuconfig BUILD_AMBARELLA_DSP_LOG
+depends on BUILD_AMBARELLA_PRIVATE_MODULES
+	bool "Build Ambarella DSP Log Driver module"
+	default n
+	help
+		Build Ambarella DSP Log Driver (Independant to DSP Driver).
+
+config CONFIG_AMBARELLA_DSP_LOG_SIZE
+	depends on BUILD_AMBARELLA_DSP_LOG
+	hex "DSP log size"
+	range 0x20000   0x700000
+	default 0x20000
+	help
+		The DSP log buffer size must be in the range of 128KB to 7MB
+
+
+##### eis
+
+config BUILD_EIS
+depends on BUILD_AMBARELLA_PRIVATE_MODULES
+	bool "Build Ambarella private EIS modules"
+	default n
+	help
+		Build Ambarella private EIS modules for Linux.
+
+
+##### fdet
+
+config BUILD_AMBARELLA_FDET
+depends on BUILD_AMBARELLA_PRIVATE_MODULES && (CONFIG_ARCH_A7 || CONFIG_ARCH_S2)
+	bool "Build Ambarella private Fdet modules"
+	default n
+	help
+		Build Ambarella private face detection modules for Linux.
+
+
+##### gyro
+
+config BUILD_GYRO
+depends on BUILD_AMBARELLA_PRIVATE_MODULES
+	bool "Build Ambarella private gyro modules"
+	default n
+	help
+		Build Ambarella private gyro modules for Linux.
+
+
+##### hw_timer
+
+config BUILD_AMBARELLA_HW_TIMER
+depends on BUILD_AMBARELLA_PRIVATE_MODULES
+	bool "Build Ambarella private hw_timer module"
+	default n
+	depends on CONFIG_ARCH_S2L
+	help
+		Build Ambarella private hardware timer module for Linux.
+
+
+
+##### iav
+
+menuconfig BUILD_AMBARELLA_IAV
+	depends on BUILD_AMBARELLA_PRIVATE_MODULES
+	bool "Build Ambarella private IAV module"
+	default n
+	help
+		Build Ambarella private IAV module for Linux.
+
+if BUILD_AMBARELLA_IAV
+
+config CONFIG_AMBARELLA_IAV_DRAM_DECODE_ONLY
+	bool "IAV Memory Layout In Decode Only Mode"
+	default n
+	help
+		This option is used for decode only mode. In this mode, only DSP_BSB_SIZE is valid.
+		Others will all be set to 0.
+
+choice
+
+depends on (CONFIG_ARCH_S2L || CONFIG_ARCH_S3L)
+	prompt "VOUT Mode"
+	default CONFIG_AMBARELLA_IAV_DRAM_VOUT_NONE
+	help
+		Select VOUT Mode.
+		"None" is use default configuration.
+		"VOUT_ONLY" is used for vout only mode. In this mode, Only PM, USR, BPC and IMG will be used.
+		Others will all be set to 0. Also IDSP will be raised to 312MHz(on S2L) and more DSP SMEM will be
+		allocated to VOUT.
+		"VOUT_DISABLE" is used to disable VOUT for SMEM save with no VOUT case, only for s2l.
+
+config CONFIG_AMBARELLA_IAV_DRAM_VOUT_NONE
+	bool "NONE"
+
+config CONFIG_AMBARELLA_IAV_DRAM_VOUT_ONLY
+	bool "VOUT_ONLY"
+
+config CONFIG_AMBARELLA_IAV_DRAM_VOUT_DISABLE
+	depends on CONFIG_ARCH_S2L
+	bool "VOUT_DISABLE"
+
+endchoice
+
+menu "IAV memory options"
+
+config DSP_BSB_SIZE
+	hex "DSP Bit Stream Buffer Size"
+	depends on !(CONFIG_AMBARELLA_IAV_DRAM_VOUT_ONLY)
+	range  0x0100000   0x3200000
+	default 0x0600000
+	help
+		BSB DRAM Start = DSP DRAM Start = IDSP_RAM_START
+		DSP BSB SIZE must be in the range of 1MB to 50MB, default is 6 MB(0x0600000).
+		6 MB buffer has been set up to support 20 Mbps (8M + 4M + 4M + 4M) for the four streams.
+		If the system only needs to support one stream 1080p30, then 1 MB of buffer is sufficient.
+
+config DSP_IAVRSVD_SIZE
+	hex "DSP Reserved Buffer Size for IAV Drivers"
+	depends on !(CONFIG_AMBARELLA_IAV_DRAM_DECODE_ONLY)
+	range  0x0A00000  0x8000000
+	default 0x0A00000
+	help
+		DSP IAVRSVD DRAM Start = (DSP BSB DRAM Start + DSP_BSB_SIZE)
+		DSP IAVRSVD SIZE is the size of memory reserved for IAV drivers which included all below.
+		DSP IAVRSVD SIZE must be larger than DSP IMGRSVD SIZE.
+
+config IAV_MEM_USR_SIZE
+	hex "IAV Usr Buffer Size"
+	depends on !(CONFIG_AMBARELLA_IAV_DRAM_DECODE_ONLY)
+	default 0x0000000
+	help
+		If this function is not used, set it to 0x0;
+		Or else, default is 8M, it's for 1080p, 1920 * 1080 * 2 * 2  = 8 MB(0x0800000).
+		1920 * 1080 * 2: bytes per pixel
+		2: 2 cycle buffers
+
+config IAV_MEM_MV_SIZE
+	hex "IAV Motion Vector Buffer Size"
+	depends on !(CONFIG_AMBARELLA_IAV_DRAM_DECODE_ONLY) && !(CONFIG_AMBARELLA_IAV_DRAM_VOUT_ONLY)
+	default 0x0000000
+	help
+		This option is used to set MV buffer.
+		If this function is not used, set it to 0x0;
+		For a 6MP stream,  one frame MV data size is (3072 * 2048) / (16 *16) * 4 Bytes = 96 KB(0x0018000).
+		It is recommended to set MV buffer size from 1MB (0x0100000) to 4MB (0x0400000) for cycle saving
+
+config IAV_MEM_OVERLAY_SIZE
+	hex "IAV Overlay Buffer Size"
+	depends on !(CONFIG_AMBARELLA_IAV_DRAM_DECODE_ONLY) && !(CONFIG_AMBARELLA_IAV_DRAM_VOUT_ONLY)
+	range  0x0000000   0x0400000
+	default 0x0200000
+	help
+		If this function is not used, set it to 0x0;
+		IAV OVERLAY SIZE must be in the range of 0MB to 4MB, default is 2 MB(0x0200000).
+
+config CONFIG_AMBARELLA_IAV_ROI_IPB
+	bool "Support roi matrix for all I/P/B frames"
+	depends on (CONFIG_ARCH_S2L) && !(CONFIG_AMBARELLA_IAV_DRAM_DECODE_ONLY) && !(CONFIG_AMBARELLA_IAV_DRAM_VOUT_ONLY)
+	default n
+	help
+		choose this to reserve more roi memory for P/B frames.
+		If it is set, roi matrix numbers is 3, or else it is 1.
+
+config IAV_MEM_QPM_SIZE
+	hex "IAV QP MATRIX Buffer Size"
+	depends on (CONFIG_ARCH_S2L) && !(CONFIG_AMBARELLA_IAV_DRAM_DECODE_ONLY) && !(CONFIG_AMBARELLA_IAV_DRAM_VOUT_ONLY)
+	default 0x0018000
+	help
+		This option is used to set a single QP buffer.
+		If this function is not used, set it to 0x0;
+		Default for 6MP single QP size, (3072 * 2048) / (16 *16) * 4 Bytes = 96 KB(0x0018000).
+		So in fact, QP_MATRIX_TOTAL_SIZE =
+		96KB * 1(or 3) * 4(four streams) * (1 + 8) = 3456 KB(or 10368 KB).
+		96KB: IAV_MEM_QPM_SIZE
+		1(or 3): means QP MATRIX numbers, it is set by CONFIG_AMBARELLA_IAV_QP_OFFSET_IPB.
+		4: means four streams.
+		(1 + 8): means 8 buffers for cycle saving and another one buffer for the user.
+
+config CONFIG_AMBARELLA_IAV_DRAM_WARP_MEM
+	bool "Open warp memory for dewarp"
+	depends on !(CONFIG_AMBARELLA_IAV_DRAM_DECODE_ONLY) && !(CONFIG_AMBARELLA_IAV_DRAM_VOUT_ONLY)
+	default y
+	help
+		Choose this to allocate warp memory for dewarp, default WARP size is 364 KB.
+
+config IAV_MEM_PM_SIZE_S2L
+	hex "IAV Privacy Mask Buffer Size"
+	depends on (CONFIG_ARCH_S2L) && !(CONFIG_AMBARELLA_IAV_DRAM_DECODE_ONLY)
+	default 0x03C0000
+	help
+		It supports two types of privacy masks, BPC and MCTF.
+		If this function is not used, set it to 0x0;
+		Or else, default for BPC 6 MP, (3072 * 2048 / 8) * (1 + 4) = 3840 KB.
+		(3072 * 2048 / 8): PM single buffer as BPC is pixel level.
+		(1 + 4): 4 cycle buffers and another one buffer which is used for user Privacy Mask Partition.
+		And default for MCTF 6 MP, (3072 * 2048 / 16 /16 * 4 Bytes) * 8 = 768 KB.
+		(3072 * 2048 / 16 /16 * 4 Bytes): PM single size as MCTF is Macroblock (MB) level.
+		8: 8 cycle buffers
+		And they will share the same partition, so choose the max, default set is 3840 KB(0x03C0000).
+		If only need to use MCTF, set 768 KB(0x00C0000) is enough.
+
+config IAV_MEM_VCA_SIZE
+	hex "IAV Vca Buffer Size"
+	depends on (CONFIG_ARCH_S2L) && !(CONFIG_AMBARELLA_IAV_DRAM_DECODE_ONLY) && !(CONFIG_AMBARELLA_IAV_DRAM_VOUT_ONLY)
+	default 0x0000000
+	help
+		This Mem is used for VCA dump, set it as below rules.
+		If this function is not used, set it to 0x0;
+		Or else, default is 5M, it's for cif, 352 * (1 + 288 + 288 /2) * 32  = 4.65 MB.
+		352: Buffer_pitch which is ROUND_UP32(max_preview_width).
+		1 + 288 + 288 /2: Buffer_height which is (1 for PTS + max_preview_height for luma
+		+ max_preview_height / 2 for chroma).
+		32: The max number of frames which can dumped.
+
+endmenu
+
+config CONFIG_AMBARELLA_IAV_SESSION_ID_SUPPORT
+	bool "Support session id from ucode"
+	default n
+	help
+		choose this to enable session id support
+
+config CONFIG_AMBARELLA_IAV_GUARD_VSYNC_LOSS
+	bool "Guard Vsync loss detection in IAV driver"
+	depends on (CONFIG_ARCH_S2L || CONFIG_ARCH_S3L)
+	default n
+	help
+		IAV driver detect Vsync loss signal, and App recover from Vsync loss.
+
+endif
+
+
+
+##### imgproc
+
+menuconfig BUILD_AMBARELLA_IMGPROC_DRV
+	depends on BUILD_AMBARELLA_PRIVATE_MODULES
+	bool "Build Ambarella private IMGPROC module"
+	default n
+	help
+		Build Ambarella private image processing module for Linux.
+
+if BUILD_AMBARELLA_IMGPROC_DRV
+
+choice
+depends on CONFIG_ARCH_S2L
+	prompt "Choose proper memory size for IMGPROC"
+	default CONFIG_IMGPROC_MEM_SMALL
+	help
+		Select the proper memory size for IMGPROC
+
+config CONFIG_IMGPROC_MEM_SMALL
+	bool "Small"
+
+config CONFIG_IMGPROC_MEM_LARGE
+	bool "Large"
+
+endchoice
+
+endif
+
+
+
+##### lens
+
+menuconfig BUILD_AMBARELLA_LENS
+	depends on BUILD_AMBARELLA_PRIVATE_MODULES
+	bool "Build Ambarella Lens module"
+	default n
+	help
+		Build Ambarella Lens Module for Linux.
+
+if BUILD_AMBARELLA_LENS
+
+source kernel/private/drivers/lens/tamron_m13vp288ir/AmbaConfig
+
+source kernel/private/drivers/lens/evetar_mz128bp2810icr/AmbaConfig
+
+endif
+
+
+##### msg
+
+config BUILD_AMBARELLA_PRIVATE_DRV_MSG
+depends on BUILD_AMBARELLA_PRIVATE_MODULES
+	bool "Build Ambarella private drv msg module"
+	default n
+	help
+		Build Ambarella private drv msg (Independant to private driver).
+
+
+
+##### uvc_camera
+
+menuconfig BUILD_AMBARELLA_UVC_CAMERA
+	depends on BUILD_AMBARELLA_PRIVATE_MODULES
+	bool "Build Ambarella private UVC Camera"
+	default n
+	help
+		Build Ambarella UVC Camera for Linux.
+
+if BUILD_AMBARELLA_UVC_CAMERA
+
+config CONFIG_AMBARELLA_UVC_WITH_UAC
+	bool "UVC Camera with UAC"
+	default y
+	help
+		This option is depends on alsa , codec ...
+
+
+endif
+
+
+
+##### vin
+
+menuconfig BUILD_AMBARELLA_VIN
+	depends on BUILD_AMBARELLA_PRIVATE_MODULES
+	bool "Build Ambarella private Vin modules"
+	default n
+	help
+		Build Ambarella private video input modules for Linux.
+
+if BUILD_AMBARELLA_VIN
+
+source kernel/private/drivers/vin/sensors/AmbaConfig
+source kernel/private/drivers/vin/decoders/AmbaConfig
+
+config CONFIG_AMBARELLA_VIN_DEBUG
+	bool "Add debug info in vin driver"
+	default n
+	help
+		Add debug info in vin driver.
+
+config CONFIG_VIN_FPS_STAT
+	bool "Support VIN FPS Statistics"
+	default n
+	help
+		Support VIN FPS statistics
+
+endif
+
+
+
+##### vout
+
+menuconfig BUILD_AMBARELLA_VOUT
+	depends on BUILD_AMBARELLA_PRIVATE_MODULES
+	bool "Build Ambarella private VOUT modules"
+	default n
+	help
+		Build Ambarella private video output modules for Linux.
+
+if BUILD_AMBARELLA_VOUT
+
+source kernel/private/drivers/vout/dve/AmbaConfig
+source kernel/private/drivers/vout/digital/AmbaConfig
+source kernel/private/drivers/vout/hdmi/AmbaConfig
+source kernel/private/drivers/vout/it66121/AmbaConfig
+
+config CONFIG_AMBARELLA_VOUT_SW_PLL
+depends on (CONFIG_ARCH_A5S || CONFIG_ARCH_A7)
+	bool "Enable software pll for dual vout"
+	default n
+	help
+		Use software pll to avoid dsp collision
+
+config CONFIG_AMBARELLA_VOUT_DEBUG
+	bool "Add debug info in vout driver"
+	default n
+	help
+		Add debug info in vout driver.
+
+endif
+
+
+## The end of AmbaConfig file
 
diff --git a/drivers/Kbuild b/drivers/Kbuild
index ce7148a..cf616ee 100644
--- a/drivers/Kbuild
+++ b/drivers/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/04 - [Cao Rongrong] Create file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 obj-m := @MODULES@
diff --git a/drivers/crypto/AmbaConfig b/drivers/crypto/AmbaConfig
index e401d2f..45e7dcb 100644
--- a/drivers/crypto/AmbaConfig
+++ b/drivers/crypto/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2008/01/16 - [Anthony Ginger] Create
 ##
-## Copyright (C) 2004-2008, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 config BUILD_AMBARELLA_CRYPTO
diff --git a/drivers/crypto/Kbuild b/drivers/crypto/Kbuild
index 57d19e2..362d84b 100644
--- a/drivers/crypto/Kbuild
+++ b/drivers/crypto/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2009/07/09 - [Anthony Ginger] Create
 ##
-## Copyright (C) 2004-2008, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/crypto/amba_crypto.c b/drivers/crypto/amba_crypto.c
index 1f2fe23..c519d87 100644
--- a/drivers/crypto/amba_crypto.c
+++ b/drivers/crypto/amba_crypto.c
@@ -4,14 +4,33 @@
  * History:
  *	2011/05/03 - [Jian Tang]
  *
- * Copyright (C) 2004-2011, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
diff --git a/drivers/crypto/crypto_api.c b/drivers/crypto/crypto_api.c
index b9f958e..05686f7 100644
--- a/drivers/crypto/crypto_api.c
+++ b/drivers/crypto/crypto_api.c
@@ -3,16 +3,35 @@
  *
  * History:
  *	2011/05/05 - [Jian Tang] created file
- * Copyright (C) 2007-2011, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
 
+
 #include <crypto/hash.h>
 #include <linux/err.h>
 #include <linux/gfp.h>
diff --git a/drivers/crypto/crypto_api.h b/drivers/crypto/crypto_api.h
index ce74ecd..8f509cb 100644
--- a/drivers/crypto/crypto_api.h
+++ b/drivers/crypto/crypto_api.h
@@ -3,16 +3,35 @@
  *
  * History:
  *	2011/05/05 - [Jian Tang] created file
- * Copyright (C) 2007-2011, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
 
+
 #ifndef __CRYPTO_API_H__
 #define __CRYPTO_API_H__
 
diff --git a/drivers/crypto/make.inc b/drivers/crypto/make.inc
index db7a78a..aa9ca59 100644
--- a/drivers/crypto/make.inc
+++ b/drivers/crypto/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/01 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_CRYPTO), y)
diff --git a/drivers/cryptochip/AmbaConfig b/drivers/cryptochip/AmbaConfig
index 7229b24..670a7cf 100644
--- a/drivers/cryptochip/AmbaConfig
+++ b/drivers/cryptochip/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2015/06/10 - [Zhi He] Create
 ##
-## Copyright (C) 2015 - 2025, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 menuconfig BUILD_PRIVATE_DRIVER_FOR_CRYPTOCHIP
diff --git a/drivers/cryptochip/atmel_atsha204/Kbuild b/drivers/cryptochip/atmel_atsha204/Kbuild
index 2328749..1c8ba96 100644
--- a/drivers/cryptochip/atmel_atsha204/Kbuild
+++ b/drivers/cryptochip/atmel_atsha204/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2015/06/10 - [Zhi He] Create
 ##
-## Copyright (C) 2015-2025, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/cryptochip/make.inc b/drivers/cryptochip/make.inc
index bc83a74..e06b3f5 100644
--- a/drivers/cryptochip/make.inc
+++ b/drivers/cryptochip/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2015/06/10 - [Zhi He] Created file
 ##
-## Copyright (C) 2015 - 2025, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_CRYPTOCHIP_ATSHA204), y)
diff --git a/drivers/debug/AmbaConfig b/drivers/debug/AmbaConfig
index 34b90a0..7db92e0 100644
--- a/drivers/debug/AmbaConfig
+++ b/drivers/debug/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2008/01/16 - [Anthony Ginger] Create
 ##
-## Copyright (C) 2004-2008, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 config BUILD_AMBARELLA_DEBUG
diff --git a/drivers/debug/Kbuild b/drivers/debug/Kbuild
index 3a29c9f..3f1d8a0 100644
--- a/drivers/debug/Kbuild
+++ b/drivers/debug/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2009/07/09 - [Anthony Ginger] Create
 ##
-## Copyright (C) 2004-2008, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/debug/debug_core.c b/drivers/debug/debug_core.c
index 65ad5e0..26f7af3 100644
--- a/drivers/debug/debug_core.c
+++ b/drivers/debug/debug_core.c
@@ -4,15 +4,34 @@
  * History:
  *    2008/04/10 - [Anthony Ginger] Create
  *
- * Copyright (C) 2004-2008, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/cdev.h>
@@ -20,10 +39,10 @@
 #include <linux/fs.h>
 #include <linux/slab.h>
 #include <linux/uaccess.h>
-#include <plat/debug.h>
 #include <iav_devnum.h>
 #include <amba_debug.h>
-#include <plat/service.h>
+#include <plat/gpio.h>
+#include <plat/iav_helper.h>
 
 #define AMBA_DEBUG_NAME			"ambad"
 #define AMBA_DEBUG_DEV_NUM		1
@@ -48,11 +67,9 @@ static long amba_debug_ioctl(struct file *filp,
 
 	switch (cmd) {
 	case AMBA_DEBUG_IOC_GET_DEBUG_FLAG:
-		errorCode = put_user(ambarella_debug_level, (u32 __user *)args);
 		break;
 
 	case AMBA_DEBUG_IOC_SET_DEBUG_FLAG:
-		errorCode = get_user(ambarella_debug_level, (u32 __user *)args);
 		break;
 
 	case AMBA_DEBUG_IOC_VIN_SET_SRC_ID:
diff --git a/drivers/debug/make.inc b/drivers/debug/make.inc
index 672a3b9..071af43 100644
--- a/drivers/debug/make.inc
+++ b/drivers/debug/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/01 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_DEBUG), y)
diff --git a/drivers/dsp/AmbaConfig b/drivers/dsp/AmbaConfig
index d47a285..0ee1392 100644
--- a/drivers/dsp/AmbaConfig
+++ b/drivers/dsp/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2008/01/16 - [Jian Tang] Create
 ##
-## Copyright (C) 2012-2018, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 menuconfig BUILD_AMBARELLA_DSP
diff --git a/drivers/dsp/arch_s2l/Kbuild b/drivers/dsp/arch_s2l/Kbuild
index 4e2ac2e..cdf6cf5 100644
--- a/drivers/dsp/arch_s2l/Kbuild
+++ b/drivers/dsp/arch_s2l/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2009/07/09 - [Anthony Ginger] Create
 ##
-## Copyright (C) 2004-2008, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/dsp/arch_s2l/dsp.h b/drivers/dsp/arch_s2l/dsp.h
index 5adf7ae..4f4b7de 100644
--- a/drivers/dsp/arch_s2l/dsp.h
+++ b/drivers/dsp/arch_s2l/dsp.h
@@ -4,15 +4,34 @@
  * History:
  *	2010/06/21 - [Zhenwu Xue] created file
  *
- * Copyright (C) 2007-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #ifndef __DSP_H__
 #define __DSP_H__
 
@@ -30,6 +49,7 @@
 #define MAX_DEFAULT_CMD			31
 #define MAX_NUM_ENC_CMD		16
 #define DSP_CMD_LIST_NUM	4
+#define MAX_NUM_VOUT_CMD	12
 
 #define MAX_CMD_SIZE			(MAX_NUM_CMD * DSP_CMD_SIZE)
 #define MAX_DEFAULT_CMD_SIZE		(MAX_DEFAULT_CMD * DSP_CMD_SIZE)
@@ -42,7 +62,7 @@ struct dsp_cmd_array {
 	u8			update_cmd_seq_num;
 	u8			num_cmds;
 	u8			num_enc_cmds;
-	u8			reserved;
+	u8			num_vout_cmds;
 };
 
 struct dsp_cmd_port {
@@ -116,10 +136,10 @@ extern int ucode_dev_init(struct ambarella_dsp *dsp);
 extern void ucode_dev_exit(void);
 extern void dsp_print_cmd(void * cmd);
 extern int dsp_update_log(void);
-extern int dsp_set_op_mode(struct dsp_device *dsp_dev,
-		u32 op_mode, struct amb_dsp_cmd *dsp_cmd);
-extern int dsp_set_enc_sub_mode(struct dsp_device *dsp_dev,
-		u32 enc_mode, struct amb_dsp_cmd *first, u8 force);
+extern int dsp_set_op_mode(struct dsp_device *dsp_dev, u32 op_mode,
+	struct amb_dsp_cmd *dsp_cmd, u32 no_wait);
+extern int dsp_set_enc_sub_mode(struct dsp_device *dsp_dev, u32 enc_mode,
+	struct amb_dsp_cmd *first, u32 no_wait, u8 force);
 extern void dsp_release_cmd(struct dsp_device *dsp_dev, struct amb_dsp_cmd *first);
 extern struct amb_dsp_cmd *dsp_get_cmd(struct dsp_device *dsp_dev, u32 flag);
 extern struct amb_dsp_cmd *dsp_get_multi_cmds(struct dsp_device *dsp_dev,
@@ -128,11 +148,19 @@ extern void dsp_put_cmd(struct dsp_device *dsp_dev, struct amb_dsp_cmd *dsp_cmd,
 extern int dsp_get_chip_id(struct dsp_device *dsp_dev, u32 *id, u32 *chip);
 extern int dsp_wait_vcap(struct dsp_device *dsp_dev, u32 count);
 extern dsp_init_data_t *dsp_get_init_data(struct dsp_device *dsp_dev);
-extern int dsp_set_audit(struct dsp_device *dsp_dev, u32 id, u32 audit_addr);
-extern int dsp_get_audit(struct dsp_device *dsp_dev, u32 id, u32 audit_addr);
+extern int dsp_set_audit(struct dsp_device *dsp_dev, u32 id, unsigned long audit_addr);
+extern int dsp_get_audit(struct dsp_device *dsp_dev, u32 id, unsigned long audit_addr);
 extern int bopt_sync(void *arg0, void *arg1, void *arg2, void *arg3);
 extern int dsp_suspend(struct dsp_device *dsp_dev);
 extern int dsp_resume(struct dsp_device *dsp_dev);
+extern int dsp_freeze(struct dsp_device *dsp_dev);
+extern int dsp_thaw(struct dsp_device *dsp_dev);
+extern int dsp_set_clock_state(u32 clk_type, u32 enable);
+extern void dsp_reset_vin(void);
+
+#ifdef CONFIG_PM
+void dsp_halt(void);
+#endif
 
 #endif
 
diff --git a/drivers/dsp/arch_s2l/dsp_cmd.c b/drivers/dsp/arch_s2l/dsp_cmd.c
index 6b64206..66161d1 100644
--- a/drivers/dsp/arch_s2l/dsp_cmd.c
+++ b/drivers/dsp/arch_s2l/dsp_cmd.c
@@ -5,15 +5,34 @@
  *	2010/09/07 - [Zhenwu Xue] Ported from a5s
  *	2011/07/25 - [Louis Sun] ported from iOne for A7 IPCAM
  *
- * Copyright (C) 2007-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #include <linux/module.h>
 #include <linux/io.h>
 #include <linux/slab.h>
@@ -41,6 +60,29 @@
 #define DSP_CONFIG_SUB0_REG		(MEMD_BASE + DSP_CONFIG_SUB0_OFFSET)
 #define DSP_CONFIG_SUB1_REG		(MEMD_BASE + DSP_CONFIG_SUB1_OFFSET)
 
+#define DSP_CLK_STATE_REG	0xEC17008C
+#define DSP_CLK_STATE_ON	0x3FFF
+#define DSP_CLK_STATE_OFF	0x0540
+
+#define GET_DSP_CMD_CAT(cmd_code)		((cmd_code << 16) >> 28)
+
+#define IS_SAME_CMD_CODE(cmd_a, cmd_b)	((cmd_a)->dsp_cmd.cmd_code == (cmd_b)->dsp_cmd.cmd_code)
+
+static inline u32 __has_sub_cmds(struct amb_dsp_cmd *first)
+{
+	struct amb_dsp_cmd *sub_cmd;
+	u32 has_sub_cmds = 0;
+
+	list_for_each_entry(sub_cmd, &first->head, node) {
+		if (sub_cmd->dsp_cmd.cmd_code) {
+			++has_sub_cmds;
+			break;
+		}
+	}
+
+	return has_sub_cmds;
+}
+
 static inline struct amb_dsp_cmd *__alloc_cmd(struct ambarella_dsp *dsp)
 {
 	struct amb_dsp_cmd *cmd = NULL;
@@ -69,6 +111,111 @@ static inline struct amb_dsp_cmd *__alloc_cmd(struct ambarella_dsp *dsp)
 	return cmd;
 }
 
+static inline u32 __check_and_replace_repeat_cmd(struct ambarella_dsp * dsp,
+	struct amb_dsp_cmd *first, struct dsp_cmd_array *cmd_array)
+{
+	struct amb_dsp_cmd *cmd, *_cmd, *sub_cmd, *found_cmd = NULL;
+	LIST_HEAD(discard_cmd_list);
+	u32 need_check = 0, discard, first_cmd_discarded = 0;
+
+	if (first->keep_latest) {
+		need_check = 1;
+	} else {
+		list_for_each_entry(sub_cmd, &first->head, node) {
+			if (sub_cmd->keep_latest) {
+				need_check = 1;
+				break;
+			}
+		}
+	}
+
+	if (!need_check) {
+		return 0;
+	}
+
+	/* discard the same cmds which is older in cmd list */
+	if (!__has_sub_cmds(first)) {
+		list_for_each_entry_safe_reverse(cmd, _cmd, &cmd_array->cmd_list, node) {
+			if (!cmd->keep_latest) {
+				continue;
+			}
+
+			if (!__has_sub_cmds(cmd) && IS_SAME_CMD_CODE(cmd, first)) {
+				list_move_tail(&cmd->node, &discard_cmd_list);
+				break;
+			} else if (__has_sub_cmds(cmd)) {
+				found_cmd = NULL;
+				if (IS_SAME_CMD_CODE(cmd, first)) {
+					found_cmd = cmd;
+				} else {
+					list_for_each_entry(sub_cmd, &cmd->head, node) {
+						if ((sub_cmd->keep_latest) && IS_SAME_CMD_CODE(sub_cmd, first)) {
+							found_cmd = sub_cmd;
+							break;
+						}
+					}
+				}
+
+				if (found_cmd) {
+					memcpy(&found_cmd->dsp_cmd, &first->dsp_cmd, sizeof(DSP_CMD));
+					list_move_tail(&first->node, &discard_cmd_list);
+					first_cmd_discarded = 1;
+					break;
+				}
+			}
+		}
+	} else {
+		list_for_each_entry_safe_reverse(cmd, _cmd, &cmd_array->cmd_list, node) {
+			if (!cmd->keep_latest) {
+				continue;
+			}
+
+			if (!__has_sub_cmds(cmd)) {
+				discard = 0;
+				if (IS_SAME_CMD_CODE(cmd, first)) {
+					discard = 1;
+				} else {
+					list_for_each_entry(sub_cmd, &first->head, node) {
+						if ((sub_cmd->keep_latest) && IS_SAME_CMD_CODE(cmd, sub_cmd)) {
+							discard = 1;
+							break;
+						}
+					}
+				}
+
+				if (discard) {
+					list_move_tail(&cmd->node, &discard_cmd_list);
+				}
+			} else if (__has_sub_cmds(cmd)) {
+				/* FIXME: currently doesn't handle the case that both cmds have sub cmds */
+			}
+		}
+	}
+
+	list_for_each_entry_safe(cmd, _cmd, &discard_cmd_list, node) {
+		/* Currently the cmd to be discarded doesn't have sub cmds */
+		if (!__has_sub_cmds(cmd)) {
+			list_move(&cmd->node, &dsp->free_list);
+			cmd_array->num_cmds--;
+			if (cmd->cmd_type == DSP_CMD_TYPE_ENC) {
+				cmd_array->num_enc_cmds--;
+			}
+			if (GET_DSP_CMD_CAT(cmd->dsp_cmd.cmd_code) == CAT_VOUT) {
+				cmd_array->num_vout_cmds--;
+			}
+			iav_debug("discard following repeat cmd: 0x%x in the cmd list\n",
+				cmd->dsp_cmd.cmd_code);
+			dsp_print_cmd(&cmd->dsp_cmd);
+		} else {
+			iav_error("Why does the cmd: 0x%x to be discarded have sub cmds???\n",
+				cmd->dsp_cmd.cmd_code);
+			BUG_ON(1);
+		}
+	}
+
+	return first_cmd_discarded;
+}
+
 #if USE_INSTANT_CMD
 static inline void __put_cmd(struct ambarella_dsp * dsp,
 	struct dsp_cmd_port *port, struct amb_dsp_cmd *first,
@@ -129,26 +276,32 @@ static inline void __put_cmd(struct ambarella_dsp * dsp,
 	struct amb_dsp_cmd *cmd;
 	struct dsp_cmd_array *cmd_array;
 	u32 idx = (port->cmd_list_idx + delay) % DSP_CMD_LIST_NUM;
+	u32 first_cmd_discarded;
 
 	cmd_array = &port->cmd_array[idx];
-	switch (first->flag) {
-	case DSP_CMD_FLAG_HIGH_PRIOR:
-		/* Insert the cmd list in the beginning of prior list */
-		cmd = NULL;
-		list_for_each_entry(cmd, &cmd_array->cmd_list, node) {
-			if (cmd->flag != DSP_CMD_FLAG_HIGH_PRIOR)
-				break;
-		}
-		if (cmd) {
-			/* Insert "first" before "cmd" */
-			list_add_tail(&first->node, &cmd->node);
-		} else {
+
+	first_cmd_discarded = __check_and_replace_repeat_cmd(dsp, first, cmd_array);
+
+	if (!first_cmd_discarded) {
+		switch (first->flag) {
+		case DSP_CMD_FLAG_HIGH_PRIOR:
+			/* Insert the cmd list in the beginning of prior list */
+			cmd = NULL;
+			list_for_each_entry(cmd, &cmd_array->cmd_list, node) {
+				if (cmd->flag != DSP_CMD_FLAG_HIGH_PRIOR)
+					break;
+			}
+			if (cmd) {
+				/* Insert "first" before "cmd" */
+				list_add_tail(&first->node, &cmd->node);
+			} else {
+				list_add_tail(&first->node, &cmd_array->cmd_list);
+			}
+			break;
+		default:
 			list_add_tail(&first->node, &cmd_array->cmd_list);
+			break;
 		}
-		break;
-	default:
-		list_add_tail(&first->node, &cmd_array->cmd_list);
-		break;
 	}
 }
 #endif	// #if USE_INSTANT_CMD
@@ -191,37 +344,26 @@ static void __set_default_cmds(struct ambarella_dsp *dsp, struct amb_dsp_cmd *fi
 	}
 }
 
-static void __reset_idsp(struct ambarella_dsp *dsp)
+void dsp_reset_vin(void)
 {
-	iav_debug("dsp reset idsp \n");
-#if 0
-	dsp->idsp_reset_flag = 1;
-	amba_writel((get_ambarella_apb_virt() + 0x118000), 0x100);
-	if (!(amba_readl(get_ambarella_apb_virt() + 0x110068) & 0x0010)) {
-		amba_writel((get_ambarella_apb_virt() + 0x11801c), 0xFF);
-	}
-#endif
-	/* reset analog/digital mipi phy */
-	amba_writel(DBGBUS_BASE + 0x11801c, 0x30000);
-	mdelay(10);
-	amba_writel(DBGBUS_BASE + 0x11801c, 0x0);
-#if 1
-	/* Reset setion 1 */
-	amba_writel(DBGBUS_BASE + 0x11801c, 0x2);
-	mdelay(10);
-	amba_writel(DBGBUS_BASE + 0x11801c, 0x0);
-#else
-	/* Reset setion 8 for PIP */
-	amba_writel(DBGBUS_BASE + 0x11801c, 0x100);
-	mdelay(10);
+	iav_debug("dsp reset vin \n");
+
+	/* reset analog/digital mipi phy and section 1 */
+	amba_writel(DBGBUS_BASE + 0x11801c, 0x30002);
+	mdelay(5);
 	amba_writel(DBGBUS_BASE + 0x11801c, 0x0);
-#endif
 }
 
 static int __boot_dsp(struct ambarella_dsp *dsp, dsp_op_mode_t op_mode)
 {
+	u32 *init_data_addr;
+
 	if (op_mode == DSP_ENCODE_MODE)
-		__reset_idsp(dsp);
+		dsp_reset_vin();
+
+	init_data_addr = ioremap_nocache(UCODE_DSP_INIT_DATA_PTR, 4);
+	*init_data_addr = PHYS_TO_DSP(DSP_INIT_DATA_START);
+	iounmap(init_data_addr);
 
 	// set dsp code/memd address
 	amba_writel(DSP_DRAM_MAIN_REG, PHYS_TO_DSP(DSP_DRAM_CODE_START));
@@ -246,7 +388,7 @@ static int __enter_enc_timer_mode(struct ambarella_dsp *dsp)
 	dsp_cmd->cmd_code = H264_ENC_USE_TIMER;
 	dsp_cmd->timer_scaler = 0;
 
-	dsp_set_enc_sub_mode(&dsp->dsp_dev, TIMER_MODE, cmd, 0);
+	dsp_set_enc_sub_mode(&dsp->dsp_dev, TIMER_MODE, cmd, 0, 0);
 
 	return 0;
 }
@@ -321,6 +463,7 @@ void dsp_put_cmd(struct dsp_device *dsp_dev, struct amb_dsp_cmd *first,
 	u32 sub_num = 0;
 	u32 sub_enc_num = 0;
 	u32 idx;
+	u32 sub_vout_num = 0;
 
 	if (!first || delay >= DSP_CMD_LIST_NUM)
 		return;
@@ -331,6 +474,10 @@ void dsp_put_cmd(struct dsp_device *dsp_dev, struct amb_dsp_cmd *first,
 	if (first->cmd_type == DSP_CMD_TYPE_ENC) {
 		++sub_enc_num;
 	}
+	if (GET_DSP_CMD_CAT(first->dsp_cmd.cmd_code) == CAT_VOUT) {
+		sub_vout_num++;
+	}
+
 	list_for_each_entry(cmd, &first->head, node) {
 		if (cmd->dsp_cmd.cmd_code) {
 			dsp_print_cmd(&cmd->dsp_cmd);
@@ -339,6 +486,10 @@ void dsp_put_cmd(struct dsp_device *dsp_dev, struct amb_dsp_cmd *first,
 				++sub_enc_num;
 			}
 		}
+		if (GET_DSP_CMD_CAT(cmd->dsp_cmd.cmd_code) == CAT_VOUT) {
+			sub_vout_num++;
+		}
+
 	}
 
 	port = &dsp->gen_cmd_port;
@@ -350,6 +501,8 @@ void dsp_put_cmd(struct dsp_device *dsp_dev, struct amb_dsp_cmd *first,
 			iav_printk("===== DSP CMD Q is full. Wait for next INT!\n");
 		} else if (cmd_array->num_enc_cmds + sub_enc_num > MAX_NUM_ENC_CMD) {
 			iav_printk("===== DSP ENC CMD Q is full. Wait for next INT!\n");
+		} else if (cmd_array->num_vout_cmds + sub_vout_num > MAX_NUM_VOUT_CMD) {
+			iav_printk("===== DSP VOUT CMD Q is full. Wait for next INT!\n");
 		} else {
 			break;
 		}
@@ -362,6 +515,7 @@ void dsp_put_cmd(struct dsp_device *dsp_dev, struct amb_dsp_cmd *first,
 	//	cmd_array->num_cmds, sub_num, cmd_array->num_enc_cmds, sub_enc_num);
 	cmd_array->num_cmds += sub_num;
 	cmd_array->num_enc_cmds += sub_enc_num;
+	cmd_array->num_vout_cmds += sub_vout_num;
 	spin_unlock_irqrestore(&dsp->lock, flags);
 }
 
@@ -382,8 +536,8 @@ void dsp_release_cmd(struct dsp_device *dsp_dev, struct amb_dsp_cmd *first)
 	spin_unlock_irqrestore(&dsp->lock, flags);
 }
 
-int dsp_set_enc_sub_mode(struct dsp_device *dsp_dev,
-		u32 enc_mode, struct amb_dsp_cmd *first, u8 force)
+int dsp_set_enc_sub_mode(struct dsp_device *dsp_dev, u32 enc_mode,
+	struct amb_dsp_cmd *first, u32 no_wait, u8 force)
 {
 	int rval = 0;
 	struct ambarella_dsp *dsp = to_ambarella_dsp(dsp_dev);
@@ -396,19 +550,23 @@ int dsp_set_enc_sub_mode(struct dsp_device *dsp_dev,
 	dsp_put_cmd(dsp_dev, first, 0);
 
 	iav_debug("Entering DSP ENC sub mode [%d]\n", enc_mode);
-	rval = wait_event_interruptible_timeout(dsp->sub_wq,
-		(dsp->enc_mode == enc_mode), TWO_JIFFIES);
-	if (rval <= 0) {
-		iav_debug("[TIMEOUT] Enter sub mode event.\n");
+	if (no_wait == 0) {
+		rval = wait_event_interruptible_timeout(dsp->sub_wq,
+			(dsp->enc_mode == enc_mode), TWO_JIFFIES);
+		if (rval <= 0) {
+			iav_debug("[TIMEOUT] Enter sub mode event.\n");
+		} else {
+			iav_debug("[Done] Entered sub mode.\n");
+		}
 	} else {
-		iav_debug("[Done] Entered sub mode.\n");
+		iav_debug("Directly return, no wait for sub mode [%d]\n", enc_mode);
 	}
 
 	return 0;
 }
 
-int dsp_set_op_mode(struct dsp_device *dsp_dev,
-		u32 op_mode, struct amb_dsp_cmd *first)
+int dsp_set_op_mode(struct dsp_device *dsp_dev, u32 op_mode,
+	struct amb_dsp_cmd *first, u32 no_wait)
 {
 	int rval = 0;
 	struct ambarella_dsp *dsp = to_ambarella_dsp(dsp_dev);
@@ -429,19 +587,25 @@ int dsp_set_op_mode(struct dsp_device *dsp_dev,
 
 		__prepare_mode_switch(dsp, op_mode, first);
 		__reset_operation_cmd(dsp_dev);
+		// reset vin from encode mode to other modes
+		dsp_reset_vin();
 	} else if (dsp->op_mode == DSP_DECODE_MODE) {
 		__prepare_mode_switch(dsp, op_mode, first);
 		__reset_operation_cmd(dsp_dev);
 	}
 
 	iav_debug("Entering DSP mode [%d]...\n", op_mode);
-	rval = wait_event_interruptible_timeout(dsp->op_wq,
-		(dsp->op_mode == op_mode), TWO_JIFFIES);
-	if (rval <= 0) {
-		iav_debug("[TIMEOUT] Enter mode event.\n");
-		return (-1);
+	if (no_wait == 0) {
+		rval = wait_event_interruptible_timeout(dsp->op_wq,
+			(dsp->op_mode == op_mode), TWO_JIFFIES);
+		if (rval <= 0) {
+			iav_debug("[TIMEOUT] Enter mode event.\n");
+			return (-1);
+		} else {
+			iav_debug("[Done] Entered mode [%d].\n", op_mode);
+		}
 	} else {
-		iav_debug("[Done] Entered mode [%d].\n", op_mode);
+		iav_debug("Directly return, no wait for DSP mode [%d]\n", op_mode);
 	}
 
 	return 0;
@@ -449,13 +613,13 @@ int dsp_set_op_mode(struct dsp_device *dsp_dev,
 
 int dsp_get_chip_id(struct dsp_device *dsp_dev, u32 *id, u32 *chip)
 {
+	struct ambarella_dsp *dsp = to_ambarella_dsp(dsp_dev);
 	if (id != NULL) {
-		struct ambarella_dsp *dsp = to_ambarella_dsp(dsp_dev);
 		*id = *(dsp->chip_id);
 	}
 
 	if (chip != NULL) {
-		*chip = bopt_sync((void *)DSP_INIT_DATA_BASE, NULL, NULL, NULL);
+		*chip = bopt_sync((void *)DSP_INIT_DATA_START, NULL, NULL, NULL);
 	}
 
 	return 0;
@@ -489,7 +653,7 @@ dsp_init_data_t *dsp_get_init_data(struct dsp_device *dsp_dev)
 	return dsp->dsp_init_data;
 }
 
-int dsp_set_audit(struct dsp_device * dsp_dev, u32 id, u32 audit_addr)
+int dsp_set_audit(struct dsp_device * dsp_dev, u32 id, unsigned long audit_addr)
 {
 	struct ambarella_dsp *dsp = to_ambarella_dsp(dsp_dev);
 	struct dsp_audit_info *audit = (struct dsp_audit_info *)audit_addr;
@@ -505,7 +669,7 @@ int dsp_set_audit(struct dsp_device * dsp_dev, u32 id, u32 audit_addr)
 	return 0;
 }
 
-int dsp_get_audit(struct dsp_device * dsp_dev, u32 id, u32 audit_addr)
+int dsp_get_audit(struct dsp_device * dsp_dev, u32 id, unsigned long audit_addr)
 {
 	struct ambarella_dsp *dsp = to_ambarella_dsp(dsp_dev);
 	struct dsp_audit_info *audit = (struct dsp_audit_info *)audit_addr;
@@ -515,3 +679,48 @@ int dsp_get_audit(struct dsp_device * dsp_dev, u32 id, u32 audit_addr)
 	return 0;
 }
 
+int dsp_set_clock_state(u32 clk_type, u32 enable)
+{
+	if (clk_type == DSP_CLK_TYPE_IDSP) {
+		amba_writel(DSP_CLK_STATE_REG, (enable ? DSP_CLK_STATE_ON : DSP_CLK_STATE_OFF));
+	} else {
+		iav_warn("Only support idsp clock setting!\n");
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+void dsp_halt(void)
+{
+#define DSP_RESET_OFFSET (0x4)
+#define DSP_SYNC_START_OFFSET (0x101c00)
+#define DSP_SYNC_END_OFFSET (0x101c80)
+
+#define DSP_SYNC_START_REG (DBGBUS_BASE + DSP_SYNC_START_OFFSET)
+#define DSP_SYNC_END_REG (DBGBUS_BASE + DSP_SYNC_END_OFFSET)
+
+	u32 addr = 0;
+
+	/* Suspend all code orc threads */
+	amba_writel(CODE_BASE, 0xf0);
+	/* Suspend all md orc threads */
+	amba_writel(MEMD_BASE, 0xf0);
+
+	/* Assuming all the orc threads are now waiting to receive on some sync.
+	 * counter, debug port writes to all result in wakes to all sync */
+	for (addr = DSP_SYNC_START_REG; addr < DSP_SYNC_END_REG; addr += 0x4) {
+		amba_writel(addr, 0x108);
+	}
+	/* Now, reset sync counters */
+	for (addr = DSP_SYNC_START_REG; addr < DSP_SYNC_END_REG; addr += 0x4) {
+		amba_writel(addr, 0x0);
+	}
+
+	/* Reset code */
+	amba_writel((CODE_BASE + DSP_RESET_OFFSET), 0x1);
+	/* Reset me */
+	amba_writel((MEMD_BASE + DSP_RESET_OFFSET), 0x1);
+}
+#endif
+
diff --git a/drivers/dsp/arch_s2l/dsp_drv.c b/drivers/dsp/arch_s2l/dsp_drv.c
index a9416ef..cf41039 100644
--- a/drivers/dsp/arch_s2l/dsp_drv.c
+++ b/drivers/dsp/arch_s2l/dsp_drv.c
@@ -5,15 +5,34 @@
  *	2012/09/27 - [Cao Rongrong] Created
  *	2014/03/03 - [Jian Tang] Modified
  *
- * Copyright (C) 2012 -2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
@@ -22,6 +41,7 @@
 #include <linux/err.h>
 #include <plat/ambcache.h>
 #include <iav_ioctl.h>
+#include <iav_fastboot.h>
 #include "dsp.h"
 
 static struct ambpriv_device *ambpriv_dsp_device;
@@ -250,6 +270,7 @@ static void dsp_transfer_cmd(struct ambarella_dsp *dsp, struct dsp_cmd_port *por
 #if !USE_INSTANT_CMD
 	port->cmd_array[idx].num_cmds = 0;
 	port->cmd_array[idx].num_enc_cmds = 0;
+	port->cmd_array[idx].num_vout_cmds = 0;
 	port->cmd_list_idx = (idx + 1) % DSP_CMD_LIST_NUM;
 #endif
 }
@@ -410,14 +431,14 @@ static int dsp_irq_init(struct ambarella_dsp *dsp)
 	int rval;
 
 	rval = request_irq(CODE_VDSP_0_IRQ, vdsp_irq,
-			IRQF_TRIGGER_RISING | IRQF_DISABLED,
+			IRQF_TRIGGER_RISING,
 			"vdsp", dsp);
 	if (rval < 0) {
 		iav_error("request_irq failed (vdsp)\n");
 		return rval;
 	}
 	rval = request_irq(VENC_IRQ_NO, venc_irq,
-			IRQF_TRIGGER_RISING | IRQF_DISABLED,
+			IRQF_TRIGGER_RISING,
 			"venc", dsp);
 	if (rval < 0) {
 		iav_error("request_irq failed (venc)\n");
@@ -498,6 +519,7 @@ static int dsp_init_cmd_port(struct dsp_cmd_port *port, u32 probe_mode)
 		INIT_LIST_HEAD(&port->cmd_array[i].cmd_list);
 		port->cmd_array[i].num_cmds = 0;
 		port->cmd_array[i].num_enc_cmds = 0;
+		port->cmd_array[i].num_vout_cmds = 0;
 		port->cmd_array[i].update_cmd_seq_num = 1;
 	}
 
@@ -525,13 +547,17 @@ static int dsp_fill_init_data(struct ambarella_dsp *dsp)
 	init_data->result_queue_size = DSP_MSG_BUF_SIZE;
 
 	/* setup default cmd queue address */
-	init_data->default_config_ptr = (u32 *)PHYS_TO_DSP(dsp->default_cmd_phys);
-	init_data->default_config_size = dsp->total_default_cmd_size;
+	init_data->default_config_ptr = (u32 *)PHYS_TO_DSP(DSP_DEF_CMD_BUF_START);
+	init_data->default_config_size = DSP_DEF_CMD_BUF_SIZE;
+	if (dsp->probe_op_mode == DSP_UNKNOWN_MODE) {
+		memset(dsp->default_cmd_virt, 0, dsp->total_default_cmd_size);
+	}
 
 	/* setup dsp buffer */
 	init_data->DSP_buf_ptr = (u32 *)PHYS_TO_DSP(dsp->dsp_dev.buffer_start);
 	init_data->DSP_buf_size = dsp->dsp_dev.buffer_size;
 	init_data->dsp_log_buf_ptr = PHYS_TO_DSP(DSP_LOG_AREA_PHYS);
+	init_data->dsp_log_size = DSP_LOG_SIZE;
 
 	/* chip ID */
 	init_data->chip_id_ptr = (u32 *)PHYS_TO_DSP(DSP_CHIP_ID_START);
@@ -555,6 +581,14 @@ static int dsp_fill_init_data(struct ambarella_dsp *dsp)
 		init_data->cmdmsg_protocol_version = MPV_FIXED_BUFFER;
 	}
 
+#if defined(CONFIG_AMBARELLA_IAV_DRAM_VOUT_ONLY)
+	init_data->vout_profile = DEFAULT_VOUT0_4M_ROTATE_PROFILE;
+#elif defined(CONFIG_AMBARELLA_IAV_DRAM_VOUT_DISABLE)
+	init_data->vout_profile = DEFAULT_VOUT_DISABLE_PROFILE;
+#else
+	init_data->vout_profile = DEFAULT_VOUT_PROFILE;
+#endif
+
 	clean_d_cache(init_data, sizeof(dsp_init_data_t));
 
 	return 0;
@@ -564,44 +598,52 @@ int dsp_init_data(struct ambarella_dsp *dsp)
 {
 	int rval = 0;
 
-	dsp->dsp_init_data = (dsp_init_data_t *)DSP_INIT_DATA_BASE;
+	dsp->dsp_init_data = ioremap_nocache(DSP_INIT_DATA_START, sizeof(dsp_init_data_t));
+	if (!dsp->dsp_init_data) {
+		iav_error("Failed to call ioremap() for INIT DATA.\n");
+		rval = -ENOMEM;
+		goto dsp_init_data_err1;
+	}
+
 	/* dsp_init_data_pm is used to store dsp_init_data when system suspend */
 	dsp->dsp_init_data_pm = kzalloc(sizeof(dsp_init_data_t), GFP_KERNEL);
 	if (!dsp->dsp_init_data_pm) {
 		iav_error("Out of memory (%d)!\n", __LINE__);
 		rval = -ENOMEM;
-		goto dsp_init_data_err1;
+		goto dsp_init_data_err2;
 	}
 
 	/* prepare memory for default commands */
-	dsp->total_default_cmd_size = sizeof(DSP_HEADER_CMD) + MAX_DEFAULT_CMD_SIZE;
-	dsp->default_cmd_virt = dma_alloc_coherent(NULL,
-		dsp->total_default_cmd_size, &dsp->default_cmd_phys, GFP_KERNEL);
+	dsp->total_default_cmd_size = DSP_DEF_CMD_BUF_SIZE;
+	dsp->default_cmd_phys = DSP_DEF_CMD_BUF_START;
+	dsp->default_cmd_virt = ioremap_nocache(dsp->default_cmd_phys,
+		dsp->total_default_cmd_size);
 	if (!dsp->default_cmd_virt) {
-		iav_error("Out of memory (%d)!\n", __LINE__);
+		iav_error("Failed to call ioremap() for default_cmd.\n");
 		rval = -ENOMEM;
-		goto dsp_init_data_err2;
+		goto dsp_init_data_err3;
 	}
-	memset(dsp->default_cmd_virt, 0, dsp->total_default_cmd_size);
 
 	/* Fill initialized data for DSP */
 	rval = dsp_fill_init_data(dsp);
 	if (rval < 0) {
-		goto dsp_init_data_err3;
+		goto dsp_init_data_err4;
 	}
 
-	bopt_sync((void *)DSP_INIT_DATA_BASE, (void *)DSP_IDSP_BASE,
+	bopt_sync((void *)DSP_INIT_DATA_START, (void *)DSP_IDSP_BASE,
 		(void *)DSP_UCODE_START, NULL);
 
 	return 0;
 
-dsp_init_data_err3:
-	dma_free_coherent(NULL, dsp->total_default_cmd_size,
-		dsp->default_cmd_virt, dsp->default_cmd_phys);
+dsp_init_data_err4:
+	iounmap((void __iomem *)dsp->default_cmd_virt);
 	dsp->default_cmd_virt = NULL;
-dsp_init_data_err2:
+	dsp->default_cmd_phys = 0;
+dsp_init_data_err3:
 	kfree(dsp->dsp_init_data_pm);
 	dsp->dsp_init_data_pm = NULL;
+dsp_init_data_err2:
+	iounmap((void __iomem *)dsp->dsp_init_data);
 dsp_init_data_err1:
 	return rval;
 }
@@ -611,12 +653,12 @@ static void dsp_free_data(struct ambarella_dsp *dsp)
 	iounmap((void __iomem *)dsp->chip_id);
 	dsp->chip_id = NULL;
 	dsp->vdsp_info = NULL;
+	iounmap((void __iomem *)dsp->dsp_init_data);
 
 	kfree(dsp->dsp_init_data_pm);
 	dsp->dsp_init_data_pm = NULL;
 
-	dma_free_coherent(NULL, MAX_DEFAULT_CMD_SIZE,
-		dsp->default_cmd_virt, dsp->default_cmd_phys);
+	iounmap((void __iomem *)dsp->default_cmd_virt);
 	dsp->default_cmd_virt = NULL;
 }
 
@@ -634,20 +676,22 @@ static int dsp_audit_init(struct ambarella_dsp * dsp)
 
 static int dsp_drv_probe_status(struct ambarella_dsp *dsp)
 {
-	u32 *p_iav_state = NULL;
 	u32 iav_state = 0;
 	u32 dsp_op_mode = 0;
 	u32 dsp_enc_mode = 0;
+	struct iav_fb_hdr *fb_hdr = NULL;
 
-	if (DSP_FASTDATA_SIZE > 0) {
-		p_iav_state = ioremap_nocache(DSP_STATUS_STORE_START, sizeof(u32));
-		if (!p_iav_state) {
+	if (likely(DSP_FASTDATA_SIZE == 0)) {
+		iav_state = IAV_STATE_INIT;
+	} else {
+		fb_hdr = ioremap_nocache(DSP_FASTDATA_START, sizeof(struct iav_fb_hdr));
+		if (!fb_hdr) {
 			iav_error("Failed to call ioremap() for DSP STATUS.\n");
 			return -ENOMEM;
 		}
-		iav_state = *p_iav_state;
-	} else {
-		iav_state = IAV_STATE_INIT;
+		iav_state = fb_hdr->dsp_status;
+		iounmap((void __iomem *)fb_hdr);
+		fb_hdr = NULL;
 	}
 
 	switch (iav_state) {
@@ -670,10 +714,6 @@ static int dsp_drv_probe_status(struct ambarella_dsp *dsp)
 	dsp->probe_op_mode = dsp_op_mode;
 	dsp->enc_mode = dsp_enc_mode;
 
-	if (p_iav_state) {
-		iounmap((void __iomem *)p_iav_state);
-		p_iav_state = NULL;
-	}
 	iav_debug("DSP probe op mode [%u], enc mode [%u].\n", dsp_op_mode, dsp_enc_mode);
 
 	return 0;
@@ -706,6 +746,7 @@ static int dsp_drv_probe(struct ambpriv_device *ambdev)
 	dsp_dev->get_cmd = dsp_get_cmd;
 	dsp_dev->get_multi_cmds = dsp_get_multi_cmds;
 	dsp_dev->put_cmd = dsp_put_cmd;
+	dsp_dev->print_cmd = NULL;
 	dsp_dev->release_cmd = dsp_release_cmd;
 	dsp_dev->set_op_mode = dsp_set_op_mode;
 	dsp_dev->set_enc_sub_mode = dsp_set_enc_sub_mode;
@@ -717,7 +758,16 @@ static int dsp_drv_probe(struct ambpriv_device *ambdev)
 #ifdef CONFIG_PM
 	dsp_dev->suspend = dsp_suspend;
 	dsp_dev->resume = dsp_resume;
+	dsp_dev->freeze = dsp_freeze;
+	dsp_dev->thaw = dsp_thaw;
+#else
+	dsp_dev->suspend = NULL;
+	dsp_dev->resume = NULL;
+	dsp_dev->freeze = NULL;
+	dsp_dev->thaw = NULL;
 #endif
+	dsp_dev->set_clock_state = dsp_set_clock_state;
+	dsp_dev->reset_vin = dsp_reset_vin;
 
 	rval = dsp_drv_probe_status(dsp);
 	if (rval < 0)
@@ -791,11 +841,52 @@ static int dsp_drv_remove(struct ambpriv_device *ambdev)
 #ifdef CONFIG_PM
 int dsp_suspend(struct dsp_device *dsp_dev)
 {
+	int i = 0;
+	struct ambarella_dsp *dsp = NULL;
+	struct dsp_cmd_port *port = NULL;
+	DSP_HEADER_CMD *hdr_cmd = NULL;
+	struct amb_dsp_cmd *first, *_first;
+
+	/* Avoid DSP to touch memory in suspend */
+	dsp_halt();
+
+	dsp = ambpriv_get_drvdata(ambpriv_dsp_device);
+
+	/* The following code is not must have, it's better to re-init the dsp cmd/msg queue */
+	port = &dsp->gen_cmd_port;
+	memset((u8 *)port->cmd_queue, 0, port->total_cmd_size);
+	memset((u8 *)port->msg_queue, 0, port->total_msg_size);
+
+	/* Must clear prev_cmd_seq_num as well, otherwise DSP will be crashed */
+	dsp->dsp_init_data->prev_cmd_seq_num = 0;
+	port->current_msg = port->msg_queue;
+	port->prev_cmd_seq_num = 0;
+	port->cmd_list_idx = 0;
+
+	hdr_cmd = (DSP_HEADER_CMD *)port->cmd_queue;
+	hdr_cmd->cmd_seq_num = 0;
+	hdr_cmd->num_cmds = 0;
+
+	for (i = 0; i < DSP_CMD_LIST_NUM; ++i) {
+		if (port->cmd_array[i].num_cmds) {
+			list_for_each_entry_safe(first, _first, &port->cmd_array[i].cmd_list, node) {
+				list_move(&first->node, &dsp->free_list);
+				list_splice(&first->head, &dsp->free_list);
+			}
+
+			port->cmd_array[i].num_cmds = 0;
+			port->cmd_array[i].num_enc_cmds = 0;
+			port->cmd_array[i].num_vout_cmds = 0;
+			port->cmd_array[i].update_cmd_seq_num = 1;
+		}
+	}
+
 	return 0;
 }
+
 int dsp_resume(struct dsp_device *dsp_dev)
 {
-	struct ambarella_dsp *dsp;
+	struct ambarella_dsp *dsp = NULL;
 
 	dsp = ambpriv_get_drvdata(ambpriv_dsp_device);
 
@@ -807,6 +898,40 @@ int dsp_resume(struct dsp_device *dsp_dev)
 
 	return 0;
 }
+
+int dsp_freeze(struct dsp_device *dsp_dev)
+{
+	int i = 0;
+	struct ambarella_dsp *dsp = NULL;
+	struct dsp_cmd_port *port = NULL;
+	struct amb_dsp_cmd *first, *_first;
+
+	/* Avoid DSP to touch memory in suspend */
+	dsp_halt();
+
+	dsp = ambpriv_get_drvdata(ambpriv_dsp_device);
+	port = &dsp->gen_cmd_port;
+	for (i = 0; i < DSP_CMD_LIST_NUM; ++i) {
+		if (port->cmd_array[i].num_cmds) {
+			list_for_each_entry_safe(first, _first, &port->cmd_array[i].cmd_list, node) {
+				list_move(&first->node, &dsp->free_list);
+				list_splice(&first->head, &dsp->free_list);
+			}
+
+			port->cmd_array[i].num_cmds = 0;
+			port->cmd_array[i].num_enc_cmds = 0;
+			port->cmd_array[i].num_vout_cmds = 0;
+			port->cmd_array[i].update_cmd_seq_num = 1;
+		}
+	}
+
+	return 0;
+}
+
+int dsp_thaw(struct dsp_device *dsp_dev)
+{
+	return 0;
+}
 #endif
 
 static struct ambpriv_driver dsp_driver = {
diff --git a/drivers/dsp/arch_s2l/dsp_print_cmd.c b/drivers/dsp/arch_s2l/dsp_print_cmd.c
index 6e18860..b7b3978 100644
--- a/drivers/dsp/arch_s2l/dsp_print_cmd.c
+++ b/drivers/dsp/arch_s2l/dsp_print_cmd.c
@@ -4,15 +4,34 @@
  * History:
  *	2012/11/02 - [Cao Rongrong] Created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #include <config.h>
 #include "dsp.h"
 
@@ -108,6 +127,7 @@ void dsp_print_cmd(void *cmd)
 		dsp_put_cmd_dec(adv_iso_disabled);
 		dsp_put_cmd_dec(sub_mode_sel.multiple_stream);
 		dsp_put_cmd_dec(sub_mode_sel.power_mode);
+		dsp_put_cmd_dec(boot_mode);
 		dsp_put_cmd_dec(lcd_3d);
 		dsp_put_cmd_dec(iv_360);
 		dsp_put_cmd_dec(mode_flags);
@@ -119,6 +139,7 @@ void dsp_print_cmd(void *cmd)
 		dsp_put_cmd_dec(hdr_preblend_from_vin);
 		dsp_put_cmd_dec(hdr_num_exposures_minus_1);
 		dsp_put_cmd_dec(vout_swap);
+		dsp_put_cmd_dec(vin_overflow_protection);
 		break;
 	}
 	case SET_VIN_CAPTURE_WIN:
@@ -320,10 +341,18 @@ void dsp_print_cmd(void *cmd)
 		dsp_put_cmd_dec(stream_1_LT_enable);
 		dsp_put_cmd_dec(stream_2_LT_enable);
 		dsp_put_cmd_dec(stream_3_LT_enable);
+		dsp_put_cmd_dec(B_frame_enable_in_LT_gop);
+		dsp_put_cmd_dec(vca_preview_id);
+		dsp_put_cmd_dec(max_warp_region_input_height);
+		dsp_put_cmd_dec(vca_frame_num);
+		dsp_put_cmd_hex(vca_daddr_base);
+		dsp_put_cmd_hex(vca_daddr_size);
+		dsp_put_cmd_dec(enc_buf_extra_MB_row_at_top);
 		break;
 	}
 	case IPCAM_OSD_INSERT:
 	{
+#if 0
 		dsp_cast_cmd(ipcam_osd_insert_t);
 		dsp_put_cmd_id(IPCAM_OSD_INSERT);
 		dsp_put_cmd_hex(cmd_code);
@@ -332,7 +361,7 @@ void dsp_print_cmd(void *cmd)
 		dsp_put_cmd_dec(osd_num_regions);
 		dsp_put_cmd_dec(osd_enable_ex);
 		dsp_put_cmd_dec(osd_num_regions_ex);
-#if 0
+		dsp_put_cmd_dec(osd_insert_always);
 		dsp_put_cmd_hex(osd_clut_dram_address[0]);
 		dsp_put_cmd_hex(osd_buf_dram_address[0]);
 		dsp_put_cmd_dec(osd_buf_pitch[0]);
@@ -454,6 +483,7 @@ void dsp_print_cmd(void *cmd)
 		dsp_put_cmd_hex(default_img_uv_addr);
 		dsp_put_cmd_dec(default_img_pitch);
 		dsp_put_cmd_dec(default_img_repeat_field);
+		dsp_put_cmd_dec(interlaced);
 		break;
 	}
 	case VOUT_OSD_SETUP:
@@ -596,6 +626,10 @@ void dsp_print_cmd(void *cmd)
 		dsp_put_cmd_dec(rotate);
 		dsp_put_cmd_dec(chroma_format);
 		dsp_put_cmd_dec(custom_encoder_frame_rate);
+		dsp_put_cmd_hex(mvdump_daddr);
+		dsp_put_cmd_hex(mvdump_fifo_limit);
+		dsp_put_cmd_dec(mvdump_fifo_unit_sz);
+		dsp_put_cmd_dec(mvdump_dpitch);
 		break;
 	}
 	case JPEG_ENCODING_SETUP:
@@ -657,6 +691,7 @@ void dsp_print_cmd(void *cmd)
 		dsp_put_cmd_dec(log2_max_pic_order_cnt_lsb_minus4);
 		dsp_put_cmd_dec(sony_avc);
 		dsp_put_cmd_dec(gaps_in_frame_num_value_allowed_flag);
+		dsp_put_cmd_dec(custom_bitstream_restriction_cfg);
 		dsp_put_cmd_dec(height_mjpeg_h264_simultaneous);
 		dsp_put_cmd_dec(width_mjpeg_h264_simultaneous);
 		dsp_put_cmd_dec(vui_enable);
@@ -766,6 +801,8 @@ void dsp_print_cmd(void *cmd)
 		dsp_put_cmd_dec(scene_change_detect_on);
 		dsp_put_cmd_dec(flat_area_improvement_on);
 		dsp_put_cmd_dec(drop_frame);
+		dsp_put_cmd_dec(mvdump_enable);
+		dsp_put_cmd_dec(vin_state);
 		dsp_put_cmd_dec(pic_size_control);
 		dsp_put_cmd_hex(quant_matrix_addr);
 		dsp_put_cmd_dec(P_IntraBiasAdd);
@@ -782,6 +819,12 @@ void dsp_print_cmd(void *cmd)
 		dsp_put_cmd_dec(user2_direct_bias);
 		dsp_put_cmd_dec(user3_intra_bias);
 		dsp_put_cmd_dec(user3_direct_bias);
+		dsp_put_cmd_dec(force_pskip_num_plus1);
+		dsp_put_cmd_dec(set_I_size);
+		dsp_put_cmd_dec(q_qp_reduce);
+		dsp_put_cmd_dec(qp_min_on_Q);
+		dsp_put_cmd_dec(qp_max_on_Q);
+		dsp_put_cmd_dec(log_q_num_per_gop_plus_1);
 		break;
 	}
 	case IPCAM_ENC_SYNC_CMD:
@@ -812,6 +855,7 @@ void dsp_print_cmd(void *cmd)
 		dsp_put_cmd_dec(output_scan_format);
 		dsp_put_cmd_dec(deinterlace_mode);
 		dsp_put_cmd_dec(disabled);
+		dsp_put_cmd_dec(skip_interval);
 		dsp_put_cmd_dec(cap_width);
 		dsp_put_cmd_dec(cap_height);
 		dsp_put_cmd_dec(input_win_offset_x);
@@ -859,6 +903,7 @@ void dsp_print_cmd(void *cmd)
 		dsp_put_cmd_dec(yuv_fId);
 		dsp_put_cmd_dec(me1_fId);
 		dsp_put_cmd_dec(pts);
+		dsp_put_cmd_dec(next_is_last_frame);
 		break;
 	}
 	case RAW_ENCODE_VIDEO_SETUP:
diff --git a/drivers/dsp/arch_s2l/dsp_ucode.c b/drivers/dsp/arch_s2l/dsp_ucode.c
index 93cc4eb..35e355d 100644
--- a/drivers/dsp/arch_s2l/dsp_ucode.c
+++ b/drivers/dsp/arch_s2l/dsp_ucode.c
@@ -4,14 +4,33 @@
  * History:
  *	2012/10/25 - [Cao Rongrong] Created
  *
- * Copyright (C) 2012 -2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <linux/module.h>
 #include <linux/mm.h>
 #include <linux/device.h>
@@ -53,6 +72,7 @@ static const struct ucode_version_s *dsp_get_ucode_version(void)
 	#define	TIME_STRING_OFFSET		(36)
 	#define	VERSION_STRING_OFFSET	(32)
 	#define	IDSP_STRING_OFFSET		(40)
+	#define	UCODE_ARCH_OFFSET		(0)
 
 	static ucode_version_t ucode_version;
 	void __iomem *base = NULL;
@@ -83,6 +103,23 @@ static const struct ucode_version_s *dsp_get_ucode_version(void)
 	iounmap(base);
 	release_mem_region(start, 64);
 
+	start = DSP_BINARY_DATA_START;
+	if (!request_mem_region(start, 4, "ucode_arch")) {
+		pr_err("request_mem_region failed\n");
+		return NULL;
+	}
+
+	base = ioremap(start, 4);
+	if (base == NULL) {
+		pr_err("ioremap() failed\n");
+		return NULL;
+	}
+	tmp = *(u32*)(base + UCODE_ARCH_OFFSET);
+	ucode_version.chip_arch = tmp ? tmp : UCODE_ARCH_S2L;
+
+	iounmap(base);
+	release_mem_region(start, 4);
+
 	return &ucode_version;
 }
 
diff --git a/drivers/dsp/make.inc b/drivers/dsp/make.inc
index 40b9db7..86421b7 100644
--- a/drivers/dsp/make.inc
+++ b/drivers/dsp/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/04 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_DSP), y)
diff --git a/drivers/dsplog/AmbaConfig b/drivers/dsplog/AmbaConfig
index 1a53f7f..e504179 100644
--- a/drivers/dsplog/AmbaConfig
+++ b/drivers/dsplog/AmbaConfig
@@ -4,18 +4,42 @@
 ## History:
 ##    2013/09/30 - [Louis Sun] Create
 ##
-## Copyright (C) 2004-2018, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
-config BUILD_AMBARELLA_DSP_LOG
+menuconfig BUILD_AMBARELLA_DSP_LOG
 depends on BUILD_AMBARELLA_PRIVATE_MODULES
 	bool "Build Ambarella DSP Log Driver module"
 	default n
 	help
 		Build Ambarella DSP Log Driver (Independant to DSP Driver).
 
+config CONFIG_AMBARELLA_DSP_LOG_SIZE
+	depends on BUILD_AMBARELLA_DSP_LOG
+	hex "DSP log size"
+	range 0x20000   0x700000
+	default 0x20000
+	help
+		The DSP log buffer size must be in the range of 128KB to 7MB
\ No newline at end of file
diff --git a/drivers/dsplog/Kbuild b/drivers/dsplog/Kbuild
index abd5065..8039f1e 100644
--- a/drivers/dsplog/Kbuild
+++ b/drivers/dsplog/Kbuild
@@ -4,19 +4,36 @@
 ## History:
 ##    2013/09/30 - [Louis Sun] Create
 ##
-## Copyright (C) 2004-2018, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
 EXTRA_AFLAGS		+= $(AMBARELLA_DRV_AFLAGS)
 EXTRA_LDFLAGS		+= $(AMBARELLA_DRV_LDFLAGS)
 
-obj-m := dsplog.o 
+obj-m := dsplog.o
 dsplog-y := dsplog_drv.o dsplog_timer.o
-	
+
 
diff --git a/drivers/dsplog/dsplog_drv.c b/drivers/dsplog/dsplog_drv.c
index fec7541..5ad32b5 100644
--- a/drivers/dsplog/dsplog_drv.c
+++ b/drivers/dsplog/dsplog_drv.c
@@ -4,17 +4,32 @@
  * History:
  * 	2013/09/30 - [Louis Sun] create new dsplog driver
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
-//#include <amba_common.h>
-
-
 
 #include <config.h>
 
@@ -49,7 +64,7 @@
 #include <linux/mutex.h>
 #include <linux/completion.h>
 #include <linux/i2c.h>
-
+#include <iav_devnum.h>
 
 #include "iav_utils.h"
 
@@ -70,23 +85,20 @@ MODULE_LICENSE("Proprietary");
 
 amba_dsplog_controller_t    g_dsplog_controller;
 
-
 static int amba_dsplog_major = AMBA_DEV_MAJOR;
 static int amba_dsplog_minor = (AMBA_DEV_MINOR_PUBLIC_END + 9);
 static const char * amba_dsplog_name = "dsplog";
 static struct cdev amba_dsplog_cdev;
+int clean_dsplog_memory = 1; /* Set it into 0 in fastboot case */
+module_param(clean_dsplog_memory, int, 0644);
 
-
-
-
-static ssize_t amba_dsplog_read(struct file *filp, char __user *buffer, size_t count, loff_t *offp)
+static ssize_t amba_dsplog_read(struct file *filp,
+	char __user *buffer, size_t count, loff_t *offp)
 {
 	return dsplog_read(buffer, count);
 	return -1;
 }
 
-
-
 DEFINE_MUTEX(amba_dsplog_mutex);
 
 void dsplog_lock(void)
@@ -99,44 +111,46 @@ void dsplog_unlock(void)
 	mutex_unlock(&amba_dsplog_mutex);
 }
 
-
 static long amba_dsplog_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
 	int rval;
+
 	dsplog_lock();
-      switch (cmd) {
-              case AMBA_IOC_DSPLOG_START_CAPUTRE:
-                rval = dsplog_start_cap();
-                break;
-
-             case AMBA_IOC_DSPLOG_STOP_CAPTURE:
-                rval = dsplog_stop_cap();
-                break;
-
-            case AMBA_IOC_DSPLOG_SET_LOG_LEVEL:
-                rval = dsplog_set_level((int)arg);
-                break;
-
-            case AMBA_IOC_DSPLOG_GET_LOG_LEVEL:
-                rval = dsplog_get_level((int *) arg);
-                break;
-
-            case AMBA_IOC_DSPLOG_PARSE_LOG:
-                rval = dsplog_parse((int)arg);
-                break;
-
-		default:
-			rval = -ENOIOCTLCMD;
-			break;
+	switch (cmd) {
+	case AMBA_IOC_DSPLOG_START_CAPUTRE:
+		rval = dsplog_start_cap();
+		break;
+
+	case AMBA_IOC_DSPLOG_STOP_CAPTURE:
+		rval = dsplog_stop_cap();
+		break;
+
+	case AMBA_IOC_DSPLOG_SET_LOG_LEVEL:
+		rval = dsplog_set_level((int)arg);
+		break;
+
+	case AMBA_IOC_DSPLOG_GET_LOG_LEVEL:
+		rval = dsplog_get_level((int *)arg);
+		break;
+
+	case AMBA_IOC_DSPLOG_PARSE_LOG:
+		rval = dsplog_parse((int)arg);
+		break;
+
+	default:
+		rval = -ENOIOCTLCMD;
+		break;
 	}
-
 	dsplog_unlock();
+
 	return rval;
 }
 
 static int amba_dsplog_open(struct inode *inode, struct file *filp)
 {
-	amba_dsplog_context_t *context = kzalloc(sizeof(amba_dsplog_context_t), GFP_KERNEL);
+	amba_dsplog_context_t *context;
+
+	context = kzalloc(sizeof(amba_dsplog_context_t), GFP_KERNEL);
 	if (context == NULL) {
 		return -ENOMEM;
 	}
@@ -154,6 +168,22 @@ static int amba_dsplog_release(struct inode *inode, struct file *filp)
 	return 0;
 }
 
+#ifdef CONFIG_PM
+int amba_dsplog_suspend(void)
+{
+	dsplog_suspend();
+	return 0;
+}
+EXPORT_SYMBOL(amba_dsplog_suspend);
+
+int amba_dsplog_resume(void)
+{
+	dsplog_resume();
+	return 0;
+}
+EXPORT_SYMBOL(amba_dsplog_resume);
+#endif
+
 static struct file_operations amba_dsplog_fops = {
 	.owner = THIS_MODULE,
 	.unlocked_ioctl = amba_dsplog_ioctl,
diff --git a/drivers/dsplog/dsplog_priv.h b/drivers/dsplog/dsplog_priv.h
index ecdf0df..d0ea69d 100644
--- a/drivers/dsplog/dsplog_priv.h
+++ b/drivers/dsplog/dsplog_priv.h
@@ -1,3 +1,35 @@
+/*
+ * dsplog_priv.h
+ *
+ * History:
+ *      2012/12/25 - [Rongrong Cao] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #ifndef __DSP_LOG_PRIV_H__
 #define  __DSP_LOG_PRIV_H__
 
@@ -14,7 +46,7 @@ typedef struct amba_dsplog_context_s {
 	amba_dsplog_controller_t * controller;
 } amba_dsplog_context_t;
 
-
+extern int clean_dsplog_memory;
 int dsplog_init(void);
 int dsplog_deinit(amba_dsplog_controller_t * controller);
 int dsplog_start_cap(void);
@@ -24,6 +56,11 @@ int dsplog_get_level(int * level);
 int dsplog_parse(int arg);
 int dsplog_read(char  *buffer, size_t size);
 
+#ifdef CONFIG_PM
+int dsplog_suspend(void);
+int dsplog_resume(void);
+#endif
+
 void dsplog_lock(void);
 void dsplog_unlock(void);
 
diff --git a/drivers/dsplog/dsplog_timer.c b/drivers/dsplog/dsplog_timer.c
index 8309b97..d4bd793 100644
--- a/drivers/dsplog/dsplog_timer.c
+++ b/drivers/dsplog/dsplog_timer.c
@@ -4,14 +4,33 @@
  * History:
  *	2013/09/27 - [Louis Sun] created file
  *
- * Copyright (C) 2012-2018, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <config.h>
 
 #include <linux/version.h>
@@ -20,13 +39,8 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/io.h>
-#include <linux/ioport.h>
 #include <linux/irq.h>
 #include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/ambbus.h>
-#include <linux/delay.h>
-#include <linux/dma-mapping.h>
 #include <linux/ioctl.h>
 #include <linux/cdev.h>
 #include <linux/mm.h>
@@ -40,30 +54,8 @@
 #include <linux/wait.h>
 #include <linux/errno.h>
 #include <linux/slab.h>
-#include <linux/idr.h>
-#include <linux/seq_file.h>
 #include <linux/mutex.h>
 #include <linux/completion.h>
-#include <linux/i2c.h>
-#include <linux/firmware.h>
-#include <linux/string.h>
-#include <linux/fb.h>
-#include <linux/spi/spi.h>
-#include <linux/proc_fs.h>
-#include <linux/seq_file.h>
-#include <linux/clk.h>
-#include <asm/dma.h>
-#include <asm/uaccess.h>
-
-#include <linux/semaphore.h>
-#include <mach/hardware.h>
-#include <plat/fb.h>
-#include <plat/ambsyncproc.h>
-#include <plat/ambasyncproc.h>
-#include <plat/ambevent.h>
-#include <plat/debug.h>
-#include <plat/ambcache.h>
-#include <mach/init.h>
 
 #include "iav_utils.h"
 #include "dsplog_priv.h"
@@ -79,6 +71,13 @@ typedef struct idsp_printf_s {
 	u32 arg5;		/**< 5th var. arg */
 } idsp_printf_t;
 
+#define DSPLOG_ENTRY_SIZE       sizeof(idsp_printf_t)
+
+//increase DSP printk buffer size to 1MB to keep more data
+#define DSP_PRINTK_BUF_SIZE	(1 << 20)
+//when buffer data is beyond DUMP_THRESHOLD, it outputs
+#define DSP_PRINTK_BUF_DUMP_THRESHOLD_SIZE      (128 << 10)
+#define DSP_LOG_TIMER_PERIOD        (msecs_to_jiffies(10))
 
 //DSP log buffer is usually a Fixed size ( most case it's 128KB) buffer, with fixed physical address
 //used to do log data exchange between DSP and ARM.
@@ -86,11 +85,12 @@ static u8 *G_dsppf_base = NULL;
 static idsp_printf_t *G_dsppf_current = NULL;
 static u32 G_dsplog_buf_size = 0;
 static u32 G_last_seq_num = 0;
-#define DSPLOG_ENTRY_SIZE       sizeof(idsp_printf_t)
 
 static int G_dsplog_state = 0;   //0: not started  1: started
 static int G_dsplog_read_finish = 0;   //0: not finished 1: finished
 
+static u32 G_dsp_suspended = 0;
+static u32 G_seq_num_wrapped = 0; // 1: sequence number wrap around, 0: doesn't
 
 //Ring buffer (Cache) is used to store the DSP log data, to cache the DSP log to a bigger buffer,
 //in order to avoid data loss if user process is unable to read out the DSP log immediately
@@ -105,7 +105,7 @@ typedef struct dsp_log_ringbuf_s {
 	u8 * write_ptr;
 	int full;
 	struct completion fill_compl;
-	int   num_reader;
+	int num_reader;
 } dsp_log_ringbuf_t;
 
 static dsp_log_ringbuf_t G_ringbuf = {
@@ -117,17 +117,6 @@ static dsp_log_ringbuf_t G_ringbuf = {
 	.num_reader = 0,
 };
 
-
-//increase DSP printk buffer size to 1MB to keep more data
-#define DSP_PRINTK_BUF_SIZE	(1024 * 1024)
-//when buffer data is beyond DUMP_THRESHOLD, it outputs
-#define DSP_PRINTK_BUF_DUMP_THRESHOLD_SIZE      (128*1024)
-#define DSP_LOG_TIMER_PERIOD        10
-
-
-static int dsp_printk_timer(void *arg);
-
-
 /* User Kernel Timer to implement periodical dsp log copy,
  * The granularity for Kernel Timer for A5s is 10ms.
  */
@@ -146,29 +135,24 @@ static struct timer_control_s G_timer_control = {
 
 static void kernel_timer_callback(unsigned long data)
 {
-	//get the object pointer
 	TIMER_CALLBACK cb = G_timer_control.timer_callback;
 
-	//run user callback if installed
 	if (cb) {
 		//DRV_PRINT(KERN_DEBUG "user callback\n");
 		cb((void *)data);
 	}
 
-	//DRV_PRINT(KERN_DEBUG " dsplog timer \n");
-
 	//auto restart
-	mod_timer(&G_timer_control.timer, jiffies + DSP_LOG_TIMER_PERIOD *HZ/1000L);
+	mod_timer(&G_timer_control.timer, jiffies + DSP_LOG_TIMER_PERIOD);
 }
 
-
-int dsp_printk_init_timer(void *p_user_callback, unsigned long data)
+static int dsp_printk_init_timer(void *p_user_callback, unsigned long data)
 {
 	if (G_timer_control.timer_initialized) {
 		DRV_PRINT(KERN_DEBUG "timer already init, skip. \n");
 	} else {
 		G_timer_control.timer_callback = (TIMER_CALLBACK)p_user_callback ;
-		G_timer_control.timer.expires = jiffies + DSP_LOG_TIMER_PERIOD *HZ/1000L;
+		G_timer_control.timer.expires = jiffies + DSP_LOG_TIMER_PERIOD;
 		G_timer_control.timer.data = (unsigned long) data;
 		G_timer_control.timer.function = &kernel_timer_callback;
 		init_timer(&G_timer_control.timer);
@@ -178,22 +162,16 @@ int dsp_printk_init_timer(void *p_user_callback, unsigned long data)
 	return 0;
 }
 
-
-int dsp_printk_deinit_timer(void)
+static int dsp_printk_deinit_timer(void)
 {
-	 //cancel timer
 	if (G_timer_control.timer_initialized) {
 		del_timer_sync(&G_timer_control.timer);
-		//clean data
 		G_timer_control.timer_callback = NULL;
-		//deinit
 		G_timer_control.timer_initialized = 0;
 	}
 	return 0;
 }
 
-
-
 //buffer is user allocated mem buffer,  size is max read bytes.
 //return value of dsp_read_log is actual output.
 //actual output should be > 0 and <=  MIN ( ring buffer size,  max_size of user buffer)
@@ -203,53 +181,68 @@ int dsplog_read(char __user *buffer, size_t max_size)
 	u8 * cur_read_ptr;
 	int readout_size = 0;
 	int cur_log_size;
+	int retv = 0;
 
-	//check size, must be multiple of DSPLOG_ENTRY_SIZE, and size >  128KB
+	//check size, must be multiple of DSPLOG_ENTRY_SIZE, and size > 128KB
 	if ((max_size % DSPLOG_ENTRY_SIZE) || (max_size < DSP_PRINTK_BUF_SIZE)) {
-		DRV_PRINT(KERN_DEBUG "dsp_printk: please read dsp log with a buffer over %d size  and size is multiple of 32\n", DSP_PRINTK_BUF_SIZE);
+		DRV_PRINT(KERN_DEBUG"dsp_printk: please read dsp log with a buffer "
+			"over %d size  and size is multiple of 32\n", DSP_PRINTK_BUF_SIZE);
 		return -EINVAL;
 	}
-	//user buffer is big, can always flush simply to user space by one syscall "read"
 
 	if (G_dsplog_read_finish)  {
-		DRV_PRINT(KERN_DEBUG "dsp_printk: log has stopped and read finished , no more logs \n");
+		DRV_PRINT(KERN_DEBUG"dsp_printk: log has stopped and read "
+			"finished, no more logs.\n");
 		return 0;
 	}
 	G_ringbuf.num_reader++;
-	//unlock before waiting
+
 	dsplog_unlock();
 	wait_for_completion(&G_ringbuf.fill_compl);
 	dsplog_lock();
 
 	cur_write_ptr = G_ringbuf.write_ptr;
 	cur_read_ptr = G_ringbuf.read_ptr;
-
 	cur_log_size = cur_write_ptr - cur_read_ptr;
 	if (cur_log_size < 0) {
-		cur_log_size  += DSP_PRINTK_BUF_SIZE;
+		cur_log_size += DSP_PRINTK_BUF_SIZE;
 	}
 
-	//read out all
 	if (cur_write_ptr < cur_read_ptr) {
 		//copy 2 segments
-		memcpy(buffer,  cur_read_ptr,  G_ringbuf.end - cur_read_ptr);
-		readout_size += G_ringbuf.end - cur_read_ptr;
-		memcpy(buffer + readout_size,  G_ringbuf.start,   cur_write_ptr - G_ringbuf.start);
+		retv = copy_to_user(buffer, cur_read_ptr, G_ringbuf.end - cur_read_ptr);
+		if (retv) {
+			iav_error("dsplog_read: Failed to read out DSP log.\n");
+			return -EFAULT;
+		}
+		readout_size += (G_ringbuf.end - cur_read_ptr);
+		retv = copy_to_user(buffer + readout_size, G_ringbuf.start,
+			cur_write_ptr - G_ringbuf.start);
+		if (retv) {
+			iav_error("dsplog_read: Failed to read out DSP log.\n");
+			return -EFAULT;
+		}
 		readout_size += (cur_write_ptr - G_ringbuf.start);
 	} else if (cur_write_ptr >cur_read_ptr) {
 		//copy 1 segment
-		memcpy(buffer, cur_read_ptr, cur_write_ptr - cur_read_ptr);
+		retv = copy_to_user(buffer, cur_read_ptr, cur_write_ptr - cur_read_ptr);
+		if (retv) {
+			iav_error("dsplog_read: Failed to read out DSP log.\n");
+			return -EFAULT;
+		}
 		readout_size += (cur_write_ptr - cur_read_ptr);
 	}
-	//read out all, so change the read ptr position, note that G_ringbuf.write_ptr may still
-	//move ahead during readout, so here, we only set G_ringbuf.read_ptr to saved write ptr position
+	//read out all, so change the read ptr position, note that
+	//G_ringbuf.write_ptr may still move ahead during readout, so here, we
+	//only set G_ringbuf.read_ptr to saved write ptr position
 	G_ringbuf.read_ptr = cur_write_ptr;
 	G_ringbuf.full = 0;
 
 	if (cur_log_size < DSP_PRINTK_BUF_DUMP_THRESHOLD_SIZE) {
-		DRV_PRINT(KERN_DEBUG "dsp_printk: log may have stopped. \n");
-		if (G_dsplog_state == 0)
+		DRV_PRINT(KERN_DEBUG "dsp_printk: log may have stopped.\n");
+		if (G_dsplog_state == 0) {
 			G_dsplog_read_finish = 1;
+		}
 	}
 
 	if (G_dsplog_read_finish) {
@@ -262,7 +255,7 @@ int dsplog_read(char __user *buffer, size_t max_size)
 static int init_buffer(void)
 {
 	if ((G_ringbuf.start = kzalloc(DSP_PRINTK_BUF_SIZE, GFP_KERNEL)) == NULL) {
-		DRV_PRINT(KERN_DEBUG "init DSP printk buffer error, insufficient kernel mem\n");
+		DRV_PRINT(KERN_DEBUG"Init DSP printk buffer error, insufficient kernel mem\n");
 		return -ENOMEM;
 	}
 
@@ -288,20 +281,22 @@ static inline void dsp_log_add_to_ring_buffer(void)
 		}
 
 		//if ring buffer is full  (write ptr will NEVER catch read ptr)
-		if (unlikely(((G_ringbuf.write_ptr == G_ringbuf.end -DSPLOG_ENTRY_SIZE) &&
-			(G_ringbuf.read_ptr == G_ringbuf.start)) ||
+		if (unlikely(((G_ringbuf.write_ptr == G_ringbuf.end - DSPLOG_ENTRY_SIZE) &&
+				(G_ringbuf.read_ptr == G_ringbuf.start)) ||
 			(G_ringbuf.write_ptr + DSPLOG_ENTRY_SIZE == G_ringbuf.read_ptr))) {
-			DRV_PRINT(KERN_DEBUG"dsp_printk: SLOW start 0x%p, end0x%p,  write0x%p, read 0x%p\n",
-				G_ringbuf.start,  G_ringbuf.end,  G_ringbuf.write_ptr, G_ringbuf.read_ptr);
+			DRV_PRINT(KERN_DEBUG"dsp_printk: SLOW start 0x%p, end0x%p, "
+				"write0x%p, read 0x%p\n", G_ringbuf.start, G_ringbuf.end,
+				G_ringbuf.write_ptr, G_ringbuf.read_ptr);
 			G_ringbuf.full = 1;
 		}
 	}
 
 	if (G_ringbuf.num_reader) {
 		if (!G_ringbuf.full) {
-			cur_log_size = G_ringbuf.write_ptr  - G_ringbuf.read_ptr;
-			if (cur_log_size < 0)
+			cur_log_size = G_ringbuf.write_ptr - G_ringbuf.read_ptr;
+			if (cur_log_size < 0) {
 				cur_log_size += DSP_PRINTK_BUF_SIZE;
+			}
 			if (cur_log_size > DSP_PRINTK_BUF_DUMP_THRESHOLD_SIZE) {
 				G_ringbuf.num_reader--;
 				complete(&G_ringbuf.fill_compl);
@@ -313,90 +308,82 @@ static inline void dsp_log_add_to_ring_buffer(void)
 	}
 }
 
-
 static int dsp_printk_timer(void *arg)
 {
-	static int wrap=0;  //sequence number wrap around
-
-	while (1) {
-		//invalidate DSP debug buffer before reading.
-		invalidate_d_cache(G_dsppf_current, DSPLOG_ENTRY_SIZE);
-		if ((G_dsppf_current->seq_num < G_last_seq_num) && (G_last_seq_num != -1)) {
-			//DRV_PRINT(KERN_DEBUG "dsp_printk:  current seq num %d smaller than last %d \n",  G_dsppf_current->seq_num, G_last_seq_num);
+	// when dsp suspends, stop dumping dsp log
+	while (!G_dsp_suspended) {
+		if ((G_dsppf_current->seq_num < G_last_seq_num) &&
+			(G_last_seq_num != -1)) {
+			//DRV_PRINT(KERN_DEBUG"dsp_printk: current seq num %d smaller "
+			//	"than last %d.\n", G_dsppf_current->seq_num, G_last_seq_num);
 			break;
 		}
 		if (G_last_seq_num == -1) {
-			wrap=1;
+			G_seq_num_wrapped = 1;
 		}
 		G_last_seq_num = G_dsppf_current->seq_num;
-		if ((G_last_seq_num == 0) && (wrap!=1)) {
-			//DRV_PRINT(KERN_DEBUG "dsp_printk:  Zero sequence num\n");
+		if ((G_last_seq_num == 0) && (G_seq_num_wrapped == 0) &&
+			(G_dsppf_current->format_addr == 0)) {
+			//DRV_PRINT(KERN_DEBUG "dsp_printk: Zero sequence num\n");
 			break;
 		}
 		dsp_log_add_to_ring_buffer();
 		//advance read pointer and also handle wrap around
 		G_dsppf_current++;
-		if ((u8*)G_dsppf_current >= G_dsppf_base + G_dsplog_buf_size)
+		if ((u8*)G_dsppf_current >= G_dsppf_base + G_dsplog_buf_size) {
 			G_dsppf_current = (idsp_printf_t *)G_dsppf_base;
+		}
 	}
 
-	//ENQUEUE  the dsp buffer into print buffer
 	return 0;
 }
 
-
 //platform independant DSP printk init
 int dsplog_init()
 {
-        //call DSP driver's function to init the dsplog
-        dsp_init_logbuf(&G_dsppf_base, &G_dsplog_buf_size);
-        G_dsppf_current = (idsp_printf_t *)G_dsppf_base;
-        memset(G_dsppf_base, 0, G_dsplog_buf_size);
-        init_buffer();
-        DRV_PRINT(KERN_DEBUG "dsplog_printk: DSP log by Timer New\n");
-        return 0;
+	//call DSP driver's function to init the dsplog
+	dsp_init_logbuf(&G_dsppf_base, &G_dsplog_buf_size);
+	G_dsppf_current = (idsp_printf_t *)G_dsppf_base;
+	if (clean_dsplog_memory) {
+		memset(G_dsppf_base, 0, G_dsplog_buf_size);
+	}
+	 init_buffer();
+	DRV_PRINT(KERN_DEBUG "dsplog_printk: DSP log by Timer New\n");
+	return 0;
 }
 
-
 int dsplog_deinit(amba_dsplog_controller_t * controller)
 {
-	DRV_PRINT(KERN_DEBUG "dsplog:  deinit timer.\n");
+	DRV_PRINT(KERN_DEBUG "dsplog: deinit timer.\n");
 	dsp_printk_deinit_timer();
-	//remove buffer
-	DRV_PRINT(KERN_DEBUG "dsplog:  deinit ring buffer.\n");
 
+	DRV_PRINT(KERN_DEBUG "dsplog: deinit ring buffer.\n");
 	if (G_ringbuf.start) {
 		kfree(G_ringbuf.start);
 		G_ringbuf.start = NULL;
 	}
-
 	dsp_deinit_logbuf(G_dsppf_base, G_dsplog_buf_size);
 
 	return 0;
 }
 
-
 int dsplog_start_cap()
 {
 	G_ringbuf.read_ptr = G_ringbuf.write_ptr;
 	G_ringbuf.full = 0;
 	G_ringbuf.num_reader = 0;
-	//init and start timer
-	dsp_printk_init_timer(dsp_printk_timer,  0);   //make the timer to issue for each HZ
+	dsp_printk_init_timer(dsp_printk_timer, 0);   //make the timer to issue for each HZ
 	G_dsplog_state = 1; //started
 	G_dsplog_read_finish = 0;  //clear finish state
 	return 0;
 }
 
-
 int dsplog_stop_cap()
 {
-	//stop timer
 	dsp_printk_deinit_timer();
-	//flush data
 	DRV_PRINT(KERN_DEBUG "dsplog_stop_cap flushes ring buf \n");
 	G_ringbuf.num_reader--;
-	G_dsplog_state = 0; //stopped
+	G_dsplog_state = 0;
 	complete(&G_ringbuf.fill_compl);
 	return 0;
 }
@@ -417,4 +404,23 @@ int dsplog_parse(int arg)
 	return 0;
 }
 
+#ifdef CONFIG_PM
+int dsplog_suspend(void)
+{
+	G_dsp_suspended = 1;
+
+	// clear dsp log buffer
+	G_dsppf_current = (idsp_printf_t *)G_dsppf_base;
+	G_last_seq_num = 0;
+	G_seq_num_wrapped = 0;
+	memset(G_dsppf_base, 0, G_dsplog_buf_size);
+	return 0;
+}
+
+int dsplog_resume(void)
+{
+	G_dsp_suspended = 0;
+	return 0;
+}
+#endif
 
diff --git a/drivers/dsplog/make.inc b/drivers/dsplog/make.inc
index d445358..98bc8ef 100644
--- a/drivers/dsplog/make.inc
+++ b/drivers/dsplog/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2013/09/30 - [Louis Sun] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_DSP_LOG), y)
@@ -23,7 +40,7 @@ LOCAL_SRCS	+= $(wildcard $(LOCAL_PATH)/*.c) \
 			$(wildcard $(LOCAL_PATH)/*.h)
 LOCAL_SRCS	+= $(LOCAL_PATH)/Kbuild
 
-include $(BUILD_DRIVER) 
+include $(BUILD_DRIVER)
 
 endif
 
diff --git a/drivers/eis/AmbaConfig b/drivers/eis/AmbaConfig
index 781f619..90bc024 100644
--- a/drivers/eis/AmbaConfig
+++ b/drivers/eis/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/28 - [Zhenwu Xue] Create
 ##
-## Copyright (C) 2004-2012, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 config BUILD_EIS
diff --git a/drivers/eis/Kbuild b/drivers/eis/Kbuild
index 3f24388..ae081c5 100644
--- a/drivers/eis/Kbuild
+++ b/drivers/eis/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/12/26 - [Zhenwu Xue] Create
 ##
-## Copyright (C) 2004-2012, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/eis/eis_drv.c b/drivers/eis/eis_drv.c
index 1e07f84..ad6e73b 100644
--- a/drivers/eis/eis_drv.c
+++ b/drivers/eis/eis_drv.c
@@ -4,15 +4,34 @@
  * History:
  *    2012/12/26 - [Zhenwu Xue] Create
  *
- * Copyright (C) 2004-2012, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 /* ========================================================================== */
 #include <linux/interrupt.h>
 #include <iav_common.h>
diff --git a/drivers/eis/eis_priv.h b/drivers/eis/eis_priv.h
index 27e351a..8f583fa 100644
--- a/drivers/eis/eis_priv.h
+++ b/drivers/eis/eis_priv.h
@@ -4,15 +4,34 @@
  * History:
  *    2012/12/26 - [Zhenwu Xue] Create
  *
- * Copyright (C) 2004-2012, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #ifndef __EIS_PRIV_H__
 #define __EIS_PRIV_H__
 
diff --git a/drivers/eis/eis_queue.c b/drivers/eis/eis_queue.c
index 4edb988..f9ea090 100644
--- a/drivers/eis/eis_queue.c
+++ b/drivers/eis/eis_queue.c
@@ -5,15 +5,34 @@
  *    2013/01/05 - [Zhenwu Xue] Create
  *    2013/09/24 - [Louis Sun] Modify it to support file ops for user space
  *
- * Copyright (C) 2004-2018, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 /* ========================================================================== */
 //static struct timeval vcap_time;
 
diff --git a/drivers/eis/make.inc b/drivers/eis/make.inc
index d78e616..96e5d1c 100644
--- a/drivers/eis/make.inc
+++ b/drivers/eis/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/08/23 - [Bingliang Hu] Created file
 ##
-## Copyright (C) 2011-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 
diff --git a/drivers/fdet/AmbaConfig b/drivers/fdet/AmbaConfig
index e58d5a1..f0e2d97 100644
--- a/drivers/fdet/AmbaConfig
+++ b/drivers/fdet/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/28 - [Zhenwu Xue] Create
 ##
-## Copyright (C) 2004-2012, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 config BUILD_AMBARELLA_FDET
diff --git a/drivers/gyro/AmbaConfig b/drivers/gyro/AmbaConfig
index 10ef55a..96b6cae 100644
--- a/drivers/gyro/AmbaConfig
+++ b/drivers/gyro/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/28 - [Zhenwu Xue] Create
 ##
-## Copyright (C) 2004-2012, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 config BUILD_GYRO
diff --git a/drivers/gyro/Kbuild b/drivers/gyro/Kbuild
index f6445a5..e4398b3 100644
--- a/drivers/gyro/Kbuild
+++ b/drivers/gyro/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2009/07/09 - [Anthony Ginger] Create
 ##
-## Copyright (C) 2004-2008, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/gyro/gyro.c b/drivers/gyro/gyro.c
index a8a6a54..97b2914 100644
--- a/drivers/gyro/gyro.c
+++ b/drivers/gyro/gyro.c
@@ -8,14 +8,33 @@
  *    2012/12/26 - [Zhenwu Xue] Create
  *    2013/09/25 - [Louis Sun] Modify it to use tasklet to read SPI
  *
- * Copyright (C) 2004-2018, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <config.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
@@ -25,7 +44,7 @@
 #include <linux/gpio.h>
 #include <linux/of_gpio.h>
 #include <plat/spi.h>
-#include <plat/service.h>
+#include <plat/iav_helper.h>
 #include <amba_eis.h>
 #include "gyro.h"
 
diff --git a/drivers/gyro/gyro.h b/drivers/gyro/gyro.h
index dbbd4cd..34c8349 100644
--- a/drivers/gyro/gyro.h
+++ b/drivers/gyro/gyro.h
@@ -4,15 +4,34 @@
  * History:
  *    2012/12/26 - [Zhenwu Xue] Create
  *
- * Copyright (C) 2004-2012, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #ifndef __MPU6000_H__
 #define __MPU6000_H__
 
diff --git a/drivers/gyro/make.inc b/drivers/gyro/make.inc
index 2891627..7940488 100644
--- a/drivers/gyro/make.inc
+++ b/drivers/gyro/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/08/23 - [Bingliang Hu] Created file
 ##
-## Copyright (C) 2011-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 
diff --git a/drivers/hw_timer/AmbaConfig b/drivers/hw_timer/AmbaConfig
index 0548691..c0b0b39 100644
--- a/drivers/hw_timer/AmbaConfig
+++ b/drivers/hw_timer/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2008/01/16 - [Anthony Ginger] Create
 ##
-## Copyright (C) 2004-2008, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 config BUILD_AMBARELLA_HW_TIMER
diff --git a/drivers/hw_timer/arch_s2l/Kbuild b/drivers/hw_timer/arch_s2l/Kbuild
index 50c0230..bafcf74 100644
--- a/drivers/hw_timer/arch_s2l/Kbuild
+++ b/drivers/hw_timer/arch_s2l/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2009/07/09 - [Anthony Ginger] Create
 ##
-## Copyright (C) 2004-2008, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/hw_timer/arch_s2l/hw_timer.c b/drivers/hw_timer/arch_s2l/hw_timer.c
index 733b74c..cb2a300 100644
--- a/drivers/hw_timer/arch_s2l/hw_timer.c
+++ b/drivers/hw_timer/arch_s2l/hw_timer.c
@@ -4,15 +4,34 @@
  * History:
  *	2014/04/28 - [Zhaoyang Chen] created file
  *
- * Copyright (C) 2012-2013, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #include <config.h>
 
 #include <linux/version.h>
@@ -61,7 +80,6 @@
 #include <plat/ambsyncproc.h>
 #include <plat/ambasyncproc.h>
 #include <plat/ambevent.h>
-#include <plat/debug.h>
 #include <plat/ambcache.h>
 #include <mach/init.h>
 
@@ -88,10 +106,20 @@ static u32 hwtimer_enable_flag			= 0;
 static u64 hwtimer_overflow_count 		= 0;
 static u64 hwtimer_init_output_value 	= 0;
 static u32 hwtimer_init_overflow_value 	= 0;
+static u64 hwtimer_init_delta_seconds 	= 10;
 static u32 hwtimer_input_freq			= 0;
+static u32 hwtimer_input_gcd			= 0;
 static u32 hwtimer_curr_outfreq			= 0;
+static u32 hwtimer_output_gcd			= 0;
+
+static u32 hwtimer_curr_reg_tick		= 0xFFFFFFFF;
+
+static spinlock_t timer_lock;
+static struct timer_list sw_timer;
 
-static spinlock_t timer_isr_lock;
+static int fastboot = 0;
+module_param(fastboot, int, 0644);
+MODULE_PARM_DESC(fastboot, "Set hw timer init value according to fastboot audio");
 
 static int hwtimer_reset(void);
 
@@ -158,49 +186,38 @@ static inline int get_gcd(int a, int b)
 
 static int calc_output_ticks(u64 *out_tick)
 {
-	u64 total_ticks;
-	u64 overflow_ticks;
-	u64 overflow_count;
-	u64 overflow_count0;
-	u64 hwtimer_ticks;
-	unsigned long flags;
+	u64 total_ticks, overflow_ticks, hwtimer_ticks;
+	u64 overflow_count, hwtimer_init;
 	u32 curr_reg_value;
-	u32 curr_reg_value0;
-	int input_freq = hwtimer_input_freq;
-	int output_freq = hwtimer_curr_outfreq;
-
-	int gcd;
-
-	curr_reg_value0 = ambarella_hwtimer_read();
-	overflow_count0 = hwtimer_overflow_count;
+	u32 input_gcd, output_gcd;
+	unsigned long flags;
 
-	spin_lock_irqsave(&timer_isr_lock, flags);
+	spin_lock_irqsave(&timer_lock, flags);
+	hwtimer_init = hwtimer_init_output_value;
 	curr_reg_value = ambarella_hwtimer_read();
-	overflow_count = hwtimer_overflow_count;
-	spin_unlock_irqrestore(&timer_isr_lock, flags);
-
-	// update overflow count for register value rollback case
-	if ((curr_reg_value0 < curr_reg_value) &&
-		(overflow_count == overflow_count0)) {
-		overflow_count = overflow_count + 1;
+	if (curr_reg_value >= hwtimer_curr_reg_tick) {
+		overflow_count = hwtimer_overflow_count + 1;
+	} else {
+		overflow_count = hwtimer_overflow_count;
 	}
+	input_gcd = hwtimer_input_gcd;
+	output_gcd = hwtimer_output_gcd;
+	spin_unlock_irqrestore(&timer_lock, flags);
 
 	overflow_ticks = overflow_count * hwtimer_init_overflow_value;
 	hwtimer_ticks = hwtimer_init_overflow_value - curr_reg_value;
 	total_ticks = overflow_ticks + hwtimer_ticks;
 
 	// change frequency from apb clock to current output frequency
-	gcd = get_gcd(output_freq, (int)input_freq);
-	total_ticks = total_ticks * (output_freq / gcd) +
-		input_freq / (gcd * 2);
-	if (hwtimer_init_overflow_value) {
-		do_div(total_ticks, input_freq / gcd);
+	total_ticks = total_ticks * output_gcd + (input_gcd >> 1);
+	if (input_gcd) {
+		do_div(total_ticks, input_gcd);
 	} else {
 		printk("HWTimer: calculate output ticks failed! Can not divide zero!\n");
 		return -EINVAL;
 	}
 	// generate output ticks
-	*out_tick = total_ticks + hwtimer_init_output_value;
+	*out_tick = hwtimer_init + total_ticks;
 
 	return 0;
 }
@@ -209,25 +226,29 @@ static ssize_t hwtimer_write_proc(struct file *file, const char __user *buffer,
 		size_t count, loff_t *data)
 {
 	ssize_t retval = 0;
+	u64 value;
 	char buf[50];
+	unsigned long flags;
 
-	if (count >= 50) {
+	if (count >= 50 || count <= 1) {
 		printk("HWTimer: %s: count %d out of size!\n", __func__, (u32)count);
 		retval = -ENOSPC;
 		goto hwtimer_write_proc_exit;
 	}
-	if (count > 1) {
-		if (copy_from_user(buf, buffer, count)) {
-			printk("HWTimer: %s: copy_from_user fail!\n", __func__);
-			retval = -EFAULT;
-			goto hwtimer_write_proc_exit;
-		}
-		buf[count] = '\0';
-		hwtimer_init_output_value = simple_strtoull(buf, NULL, 10);
+
+	if (copy_from_user(buf, buffer, count)) {
+		printk("HWTimer: %s: copy_from_user fail!\n", __func__);
+		retval = -EFAULT;
+		goto hwtimer_write_proc_exit;
 	}
-	spin_lock_irq(&timer_isr_lock);
+	buf[count] = '\0';
+	value = simple_strtoull(buf, NULL, 10);
+
+	spin_lock_irqsave(&timer_lock, flags);
+	del_timer(&sw_timer);
+	hwtimer_init_output_value = value;
 	hwtimer_reset();
-	spin_unlock_irq(&timer_isr_lock);
+	spin_unlock_irqrestore(&timer_lock, flags);
 
 	retval = count;
 
@@ -336,21 +357,31 @@ static ssize_t hwtimer_outfreq_write_proc(struct file *file,
 {
 	ssize_t retval = 0;
 	char buf[50];
+	u32 gcd, input, output, out_freq;
+	unsigned long flags;
 
-	if (count >= 50) {
+	if (count >= 50 || count <= 1) {
 		printk("HWTimer: %s: count %d out of size!\n", __func__, (u32)count);
 		retval = -ENOSPC;
 		goto hwtimer_outfreq_write_proc_exit;
 	}
-	if (count > 1) {
-		if (copy_from_user(buf, buffer, count)) {
-			printk("HWTimer: %s: copy_from_user fail!\n", __func__);
-			retval = -EFAULT;
-			goto hwtimer_outfreq_write_proc_exit;
-		}
-		buf[count] = '\0';
-		hwtimer_curr_outfreq= simple_strtoull(buf, NULL, 10);
+
+	if (copy_from_user(buf, buffer, count)) {
+		printk("HWTimer: %s: copy_from_user fail!\n", __func__);
+		retval = -EFAULT;
+		goto hwtimer_outfreq_write_proc_exit;
 	}
+	buf[count] = '\0';
+	out_freq = (u32)simple_strtoull(buf, NULL, 10);
+	gcd = get_gcd(hwtimer_input_freq, out_freq);
+	input = hwtimer_input_freq / gcd;
+	output = out_freq / gcd;
+
+	spin_lock_irqsave(&timer_lock, flags);
+	hwtimer_curr_outfreq= out_freq;
+	hwtimer_input_gcd = input;
+	hwtimer_output_gcd = output;
+	spin_unlock_irqrestore(&timer_lock, flags);
 
 	retval = count;
 
@@ -381,13 +412,21 @@ static int hwtimer_create_outfreq_proc(void)
 	return err_code;
 }
 
-static irqreturn_t hwtimer_isr(int irq, void *dev_id)
+static void swtimer_routine(unsigned long data)
 {
-	spin_lock(&timer_isr_lock);
-	hwtimer_overflow_count++;
-	spin_unlock(&timer_isr_lock);
+	u32 curr_tick;
+	unsigned long flags;
 
-	return IRQ_HANDLED;
+	/* sw timer is scheduled per second */
+	spin_lock_irqsave(&timer_lock, flags);
+	mod_timer(&sw_timer, jiffies + HZ);
+
+	curr_tick = ambarella_hwtimer_read();
+	if (curr_tick >= hwtimer_curr_reg_tick) {
+		hwtimer_overflow_count++;
+	}
+	hwtimer_curr_reg_tick = curr_tick;
+	spin_unlock_irqrestore(&timer_lock, flags);
 }
 
 static void hwtimer_remove_proc(void)
@@ -400,21 +439,100 @@ static void hwtimer_remove_outfreq_proc(void)
 	remove_proc_entry(AMBARELLA_HWTIMER_OUTFREQ, get_ambarella_proc_dir());
 }
 
-int hwtimer_reset()
+static int hwtimer_pause(void)
+{
+	u64 suspend_ticks = 0;
+
+	get_hwtimer_output_ticks(&suspend_ticks);
+	hwtimer_init_output_value = suspend_ticks;
+
+	ambarella_hwtimer_disable();
+	del_timer(&sw_timer);
+	hwtimer_enable_flag = 0;
+
+	return 0;
+}
+
+static u64 hwtimer_get_fastboot_ticks(void)
+{
+	u32 gcd, input, output;
+	u32 input_freq = AMBARELLA_HWTIMER_INPUT_FREQ;
+	u32 output_freq = hwtimer_curr_outfreq;
+	u64 total_ticks = (u32)amba_readl(AMBARELLA_HWTIMER_STATUS_REG);
+
+	gcd = get_gcd(input_freq, output_freq);
+	input = input_freq / gcd;
+	output = output_freq / gcd;
+
+	total_ticks = ((u64)1 << 32) - total_ticks;
+	total_ticks = total_ticks * output + (input >> 1);
+	if (likely(input)) {
+		do_div(total_ticks, input);
+	} else {
+		printk("HWTimer: calculate output ticks failed! Can not divide zero!\n");
+	}
+
+	return total_ticks;
+}
+
+#ifdef CONFIG_PM
+int hwtimer_suspend(void)
+{
+	return hwtimer_pause();
+}
+
+EXPORT_SYMBOL(hwtimer_suspend);
+int hwtimer_resume(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&timer_lock, flags);
+	hwtimer_reset();
+	spin_unlock_irqrestore(&timer_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(hwtimer_resume);
+
+int hwtimer_freeze(void)
+{
+	return hwtimer_pause();
+}
+EXPORT_SYMBOL(hwtimer_freeze);
+
+int hwtimer_thaw(int fastboot_audio)
+{
+	if (fastboot_audio) {
+		// fast boot audio is enabled
+		hwtimer_init_output_value = hwtimer_init_delta_seconds *
+			hwtimer_curr_outfreq + hwtimer_get_fastboot_ticks();
+	}
+
+	return hwtimer_reset();
+}
+EXPORT_SYMBOL(hwtimer_thaw);
+#endif
+
+int hwtimer_reset(void)
 {
 	hwtimer_overflow_count = 0;
-	hwtimer_input_freq = AMBARELLA_HWTIMER_INPUT_FREQ;
-	hwtimer_init_overflow_value = hwtimer_input_freq * HWTIMER_OVERFLOW_SECONDS;
-	hwtimer_curr_outfreq = HWTIMER_DEFAULT_OUTPUT_FREQ;
 	hwtimer_enable_flag = 0;
 	ambarella_hwtimer_init();
 
+	init_timer(&sw_timer);
+	hwtimer_curr_reg_tick = 0xFFFFFFFF;
+	sw_timer.function = &swtimer_routine;
+	sw_timer.expires = jiffies + HZ;
+	add_timer(&sw_timer);
+
 	return 0;
 }
 
 static int __init hwtimer_init(void)
 {
-	int err_code = 0;
+	int gcd, err_code = 0;
+	unsigned long flags;
+
 	err_code = hwtimer_create_proc();
 	if (err_code) {
 		printk("HWTimer: create proc file for hw timer failed!\n");
@@ -426,25 +544,32 @@ static int __init hwtimer_init(void)
 		goto hwtimer_init_err_create_outfreq_proc;
 	}
 
-	hwtimer_overflow_count = 0;
-	err_code = request_irq(AMBARELLA_HWTIMER_IRQ, hwtimer_isr,
-					IRQF_TRIGGER_RISING, AMBARELLA_HWTIMER_NAME, NULL);
-	if (err_code) {
-		printk("HWTimer: request irq for hw timer failed!\n");
-		goto hwtimer_init_err_request_irq;
+	spin_lock_init(&timer_lock);
+	if (HWTIMER_OVERFLOW_SECONDS < 2) {
+		printk("HWTimer: overflow seconds should be >= 2!\n");
+		err_code = -1;
+		goto hwtimer_init_err_create_outfreq_proc;
 	}
 
 	hwtimer_input_freq = AMBARELLA_HWTIMER_INPUT_FREQ;
 	hwtimer_init_overflow_value = hwtimer_input_freq * HWTIMER_OVERFLOW_SECONDS;
 	hwtimer_curr_outfreq = HWTIMER_DEFAULT_OUTPUT_FREQ;
-	hwtimer_enable_flag = 0;
-	ambarella_hwtimer_init();
-	spin_lock_init(&timer_isr_lock);
+	gcd = get_gcd(hwtimer_input_freq, hwtimer_curr_outfreq);
+	hwtimer_input_gcd = hwtimer_input_freq / gcd;
+	hwtimer_output_gcd = hwtimer_curr_outfreq / gcd;
+	if (!fastboot) {
+		hwtimer_init_output_value = 0;
+	} else {
+		// To support fastboot audio case
+		hwtimer_init_output_value = hwtimer_init_delta_seconds *
+			hwtimer_curr_outfreq + hwtimer_get_fastboot_ticks();
+	}
 
-	goto hwtimer_init_err_na;
+	spin_lock_irqsave(&timer_lock, flags);
+	hwtimer_reset();
+	spin_unlock_irqrestore(&timer_lock, flags);
 
-hwtimer_init_err_request_irq:
-	free_irq(AMBARELLA_HWTIMER_IRQ, NULL);
+	goto hwtimer_init_err_na;
 
 hwtimer_init_err_create_outfreq_proc:
 	hwtimer_remove_outfreq_proc();
@@ -462,7 +587,7 @@ static void __exit hwtimer_exit(void)
 		ambarella_hwtimer_disable();
 		hwtimer_enable_flag = 0;
 	}
-	free_irq(AMBARELLA_HWTIMER_IRQ, NULL);
+	del_timer(&sw_timer);
 	hwtimer_remove_outfreq_proc();
 	hwtimer_remove_proc();
 }
diff --git a/drivers/hw_timer/make.inc b/drivers/hw_timer/make.inc
index f1ad878..cbd269e 100644
--- a/drivers/hw_timer/make.inc
+++ b/drivers/hw_timer/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/10/19 - [Zhaoyang Chen] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_HW_TIMER), y)
diff --git a/drivers/iav/AmbaConfig b/drivers/iav/AmbaConfig
index ea5068a..9461365 100644
--- a/drivers/iav/AmbaConfig
+++ b/drivers/iav/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/01/16 - [Jian Tang] Create
 ##
-## Copyright (C) 2014-2018, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 menuconfig BUILD_AMBARELLA_IAV
@@ -21,10 +38,43 @@ menuconfig BUILD_AMBARELLA_IAV
 
 if BUILD_AMBARELLA_IAV
 
+config CONFIG_AMBARELLA_IAV_DRAM_DECODE_ONLY
+	bool "IAV Memory Layout In Decode Only Mode"
+	default n
+	help
+		This option is used for decode only mode. In this mode, only DSP_BSB_SIZE is valid.
+		Others will all be set to 0.
+
+choice
+
+depends on (CONFIG_ARCH_S2L || CONFIG_ARCH_S3L)
+	prompt "VOUT Mode"
+	default CONFIG_AMBARELLA_IAV_DRAM_VOUT_NONE
+	help
+		Select VOUT Mode.
+		"None" is use default configuration.
+		"VOUT_ONLY" is used for vout only mode. In this mode, Only PM, USR, BPC and IMG will be used.
+		Others will all be set to 0. Also IDSP will be raised to 312MHz(on S2L) and more DSP SMEM will be
+		allocated to VOUT.
+		"VOUT_DISABLE" is used to disable VOUT for SMEM save with no VOUT case, only for s2l.
+
+config CONFIG_AMBARELLA_IAV_DRAM_VOUT_NONE
+	bool "NONE"
+
+config CONFIG_AMBARELLA_IAV_DRAM_VOUT_ONLY
+	bool "VOUT_ONLY"
+
+config CONFIG_AMBARELLA_IAV_DRAM_VOUT_DISABLE
+	depends on CONFIG_ARCH_S2L
+	bool "VOUT_DISABLE"
+
+endchoice
+
 menu "IAV memory options"
 
 config DSP_BSB_SIZE
 	hex "DSP Bit Stream Buffer Size"
+	depends on !(CONFIG_AMBARELLA_IAV_DRAM_VOUT_ONLY)
 	range  0x0100000   0x3200000
 	default 0x0600000
 	help
@@ -35,6 +85,7 @@ config DSP_BSB_SIZE
 
 config DSP_IAVRSVD_SIZE
 	hex "DSP Reserved Buffer Size for IAV Drivers"
+	depends on !(CONFIG_AMBARELLA_IAV_DRAM_DECODE_ONLY)
 	range  0x0A00000  0x8000000
 	default 0x0A00000
 	help
@@ -44,6 +95,7 @@ config DSP_IAVRSVD_SIZE
 
 config IAV_MEM_USR_SIZE
 	hex "IAV Usr Buffer Size"
+	depends on !(CONFIG_AMBARELLA_IAV_DRAM_DECODE_ONLY)
 	default 0x0000000
 	help
 		If this function is not used, set it to 0x0;
@@ -51,25 +103,36 @@ config IAV_MEM_USR_SIZE
 		1920 * 1080 * 2: bytes per pixel
 		2: 2 cycle buffers
 
+config IAV_MEM_MV_SIZE
+	hex "IAV Motion Vector Buffer Size"
+	depends on !(CONFIG_AMBARELLA_IAV_DRAM_DECODE_ONLY) && !(CONFIG_AMBARELLA_IAV_DRAM_VOUT_ONLY)
+	default 0x0000000
+	help
+		This option is used to set MV buffer.
+		If this function is not used, set it to 0x0;
+		For a 6MP stream,  one frame MV data size is (3072 * 2048) / (16 *16) * 4 Bytes = 96 KB(0x0018000).
+		It is recommended to set MV buffer size from 1MB (0x0100000) to 4MB (0x0400000) for cycle saving
+
 config IAV_MEM_OVERLAY_SIZE
 	hex "IAV Overlay Buffer Size"
+	depends on !(CONFIG_AMBARELLA_IAV_DRAM_DECODE_ONLY) && !(CONFIG_AMBARELLA_IAV_DRAM_VOUT_ONLY)
 	range  0x0000000   0x0400000
 	default 0x0200000
 	help
 		If this function is not used, set it to 0x0;
 		IAV OVERLAY SIZE must be in the range of 0MB to 4MB, default is 2 MB(0x0200000).
 
-
-config CONFIG_AMBARELLA_IAV_QP_OFFSET_IPB
-	bool "Support qp offset for all I/P/B frames"
-	depends on (CONFIG_ARCH_S2L)
+config CONFIG_AMBARELLA_IAV_ROI_IPB
+	bool "Support roi matrix for all I/P/B frames"
+	depends on (CONFIG_ARCH_S2L) && !(CONFIG_AMBARELLA_IAV_DRAM_DECODE_ONLY) && !(CONFIG_AMBARELLA_IAV_DRAM_VOUT_ONLY)
 	default n
 	help
-		choose this to reserve more qp memory for P/B frames.
-		If it is set, QP MATRIX numbers is 3, or else it is 1.
+		choose this to reserve more roi memory for P/B frames.
+		If it is set, roi matrix numbers is 3, or else it is 1.
 
 config IAV_MEM_QPM_SIZE
 	hex "IAV QP MATRIX Buffer Size"
+	depends on (CONFIG_ARCH_S2L) && !(CONFIG_AMBARELLA_IAV_DRAM_DECODE_ONLY) && !(CONFIG_AMBARELLA_IAV_DRAM_VOUT_ONLY)
 	default 0x0018000
 	help
 		This option is used to set a single QP buffer.
@@ -84,13 +147,14 @@ config IAV_MEM_QPM_SIZE
 
 config CONFIG_AMBARELLA_IAV_DRAM_WARP_MEM
 	bool "Open warp memory for dewarp"
+	depends on !(CONFIG_AMBARELLA_IAV_DRAM_DECODE_ONLY) && !(CONFIG_AMBARELLA_IAV_DRAM_VOUT_ONLY)
 	default y
 	help
 		Choose this to allocate warp memory for dewarp, default WARP size is 364 KB.
 
 config IAV_MEM_PM_SIZE_S2L
 	hex "IAV Privacy Mask Buffer Size"
-	depends on (CONFIG_ARCH_S2L)
+	depends on (CONFIG_ARCH_S2L) && !(CONFIG_AMBARELLA_IAV_DRAM_DECODE_ONLY)
 	default 0x03C0000
 	help
 		It supports two types of privacy masks, BPC and MCTF.
@@ -104,6 +168,19 @@ config IAV_MEM_PM_SIZE_S2L
 		And they will share the same partition, so choose the max, default set is 3840 KB(0x03C0000).
 		If only need to use MCTF, set 768 KB(0x00C0000) is enough.
 
+config IAV_MEM_VCA_SIZE
+	hex "IAV Vca Buffer Size"
+	depends on (CONFIG_ARCH_S2L) && !(CONFIG_AMBARELLA_IAV_DRAM_DECODE_ONLY) && !(CONFIG_AMBARELLA_IAV_DRAM_VOUT_ONLY)
+	default 0x0000000
+	help
+		This Mem is used for VCA dump, set it as below rules.
+		If this function is not used, set it to 0x0;
+		Or else, default is 5M, it's for cif, 352 * (1 + 288 + 288 /2) * 32  = 4.65 MB.
+		352: Buffer_pitch which is ROUND_UP32(max_preview_width).
+		1 + 288 + 288 /2: Buffer_height which is (1 for PTS + max_preview_height for luma
+		+ max_preview_height / 2 for chroma).
+		32: The max number of frames which can dumped.
+
 endmenu
 
 config CONFIG_AMBARELLA_IAV_SESSION_ID_SUPPORT
@@ -114,7 +191,7 @@ config CONFIG_AMBARELLA_IAV_SESSION_ID_SUPPORT
 
 config CONFIG_AMBARELLA_IAV_GUARD_VSYNC_LOSS
 	bool "Guard Vsync loss detection in IAV driver"
-	depends on (CONFIG_ARCH_S2L)
+	depends on (CONFIG_ARCH_S2L || CONFIG_ARCH_S3L)
 	default n
 	help
 		IAV driver detect Vsync loss signal, and App recover from Vsync loss.
diff --git a/drivers/iav/arch_s2l/Kbuild b/drivers/iav/arch_s2l/Kbuild
index 63a17ca..f0b81f0 100644
--- a/drivers/iav/arch_s2l/Kbuild
+++ b/drivers/iav/arch_s2l/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/01/09 - [Jian Tang] Create
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
@@ -17,6 +34,10 @@ EXTRA_AFLAGS		+= $(AMBARELLA_DRV_AFLAGS)
 EXTRA_LDFLAGS		+= $(AMBARELLA_DRV_LDFLAGS)
 
 obj-m := iav.o
-iav-y := iav_drv.o iav_vout.o iav_enc_api.o iav_enc_buf.o iav_enc_perf.o iav_enc_warp.o iav_enc_bufcap.o iav_enc_pm.o iav_enc_stream.o iav_enc_limit.o \
-	iav_dsp_cmd.o iav_vin.o iav_vin_pll.o iav_enc_utils.o iav_enc_pts.o iav_enc_test.o iav_netlink.o iav_dec_api.o iav_enc_mem.o iav_enc_efm.o
+iav-y := iav_dec_api.o iav_drv.o iav_dsp_cmd.o \
+	iav_enc_api.o iav_enc_buf.o iav_enc_bufcap.o iav_enc_custom.o \
+	iav_enc_efm.o iav_enc_limit.o iav_enc_mem.o iav_enc_perf.o \
+	iav_enc_pm.o iav_enc_pts.o iav_enc_stream.o iav_enc_test.o \
+	iav_enc_utils.o iav_enc_warp.o iav_netlink.o \
+	iav_vin.o iav_vin_pll.o iav_vout.o
 
diff --git a/drivers/iav/arch_s2l/iav.h b/drivers/iav/arch_s2l/iav.h
index f2bf48f..181b03f 100644
--- a/drivers/iav/arch_s2l/iav.h
+++ b/drivers/iav/arch_s2l/iav.h
@@ -4,14 +4,33 @@
  * History:
  *    2013/03/07 - [Cao Rongrong] Create
  *
- * Copyright (C) 2012 -2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #ifndef __IAV_H__
 #define __IAV_H__
 
@@ -36,7 +55,7 @@
 struct iav_nl_request
 {
 	u32 request_id;
-	u32 condition;
+	u32 responded;
 	wait_queue_head_t wq_request;
 };
 
@@ -73,6 +92,8 @@ struct iav_enc_limitation
 	/* the max/min size of main buffer */
 	struct iav_window max_main;
 	struct iav_window min_main;
+	/* the max input size of main buffer */
+	struct iav_window max_main_input;
 	/* the min size of encode window */
 	struct iav_window min_enc;
 	u32 max_enc_num : 8;
@@ -100,17 +121,20 @@ struct iav_enc_limitation
 	u32 me0_supported : 2;
 	u32 enc_from_mem_supported : 1;
 	u32 enc_raw_yuv_supported : 1;
-	u32 reserved : 9;
+	u32 long_ref_b_supported : 1;
+	u32 reserved : 8;
 };
 
 /* the limitation for each chip ID */
 struct iav_system_load
 {
 	#define	DESC_LENGTH		(32)
-	u32 system_load;
-	char desc[DESC_LENGTH];
+	u32	system_load;
+	u32	vin_pps;
+	char	desc[DESC_LENGTH];
 	u8	max_enc_num;
 	u8	reserved[3];
+	char	vin_pps_desc[DESC_LENGTH];
 };
 
 /* the limitation of each source buffer. */
@@ -132,8 +156,10 @@ struct iav_buffer {
 	struct iav_window max;
 	u32 ref_cnt;
 	int extra_dram_buf;
+	u32 dump_interval : 8;
+	u32 dump_duration : 16;
 	u32 unwarp : 1;
-	u32 reserved : 31;
+	u32 reserved : 7;
 };
 
 struct iav_h264_config {
@@ -151,10 +177,13 @@ struct iav_h264_config {
 	u32 cpb_cmp_idc :2;
 	u32 fast_rc_idc :4;
 	u32 zmv_threshold : 8;
-	u32 enc_improve : 1;
+	u32 flat_area_improve : 1;
 	u32 multi_ref_p : 1;
-	u32 reserved1 : 6;
-	u32 long_term_intvl : 8;
+	u32 statis : 1;
+	u32 pskip_repeat_enable : 1;
+	u32 drop_frame_repeat : 1;
+	u32 reserved1 : 3;
+	u32 fast_seek_intvl : 8;
 
 	u32 average_bitrate;
 	u32 vbr_setting : 8;
@@ -164,17 +193,20 @@ struct iav_h264_config {
 	u32 qp_max_on_P : 8;
 	u32 qp_min_on_B : 8;
 	u32 qp_max_on_B : 8;
+	u32 qp_min_on_Q : 8;
+	u32 qp_max_on_Q : 8;
 	u32 i_qp_reduce : 8;
 	u32 p_qp_reduce : 8;
+	u32 q_qp_reduce : 8;
+	u32 log_q_num_plus_1 : 8;
 	u32 adapt_qp : 8;
 	u32 skip_flag : 8;
-	u32 reserved2 : 8;
+	u32 repeat_pskip_num : 8;
 	u32 intrabias_p : 16;
 	u32 intrabias_b : 16;
 
 	s8 qp_delta[3][4];
 	u8 qp_roi_enable;
-	u8 qp_type;
 	u8 drop_frames;
 	u8 user1_intra_bias;
 	u8 user1_direct_bias;
@@ -182,7 +214,20 @@ struct iav_h264_config {
 	u8 user2_direct_bias;
 	u8 user3_intra_bias;
 	u8 user3_direct_bias;
-	u8 reserved3[3];
+	s8 deblocking_filter_alpha; 	/* set alpha for loop filter between -6 and 6 */
+	s8 deblocking_filter_beta; 		/* set beta for loop filter between -6 and 6 */
+	/* 0- disable deblocking filter
+	 * 1- enable deblocking filter, use alpha & beta values specified above
+	 * 2- use internally computed alpha and beta.
+	 */
+	u8 deblocking_filter_enable;
+	u8 abs_br_flag : 1;
+	u8 reserved : 7;
+	u16 frame_crop_left_offset;
+	u16 frame_crop_right_offset;
+	u16 frame_crop_top_offset;
+	u16 frame_crop_bottom_offset;
+	u32 max_I_size_KB;
 };
 
 struct iav_mjpeg_config {
@@ -235,6 +280,17 @@ struct iav_raw_data_info {
 	u32 pitch;
 };
 
+struct iav_qp_hist_info
+{
+	u32 data_dsp_addr_base;
+	u32 data_virt_addr_base;
+	u32 base_addr_set_flag;
+	u32 data_dsp_addr_end;
+	u32 data_dsp_addr_cur;
+	u32 seq_num;
+	u32 stream_num;
+};
+
 struct iav_srcbuf_data_info {
 	u32 y_data_addr;
 	u32 uv_data_addr;
@@ -275,6 +331,11 @@ struct iav_bufcap_info {
 	struct iav_me_data_info me0_info[IAV_SRCBUF_NUM][MAX_BUFCAP_DATA_NUM];
 	wait_queue_head_t me0_wq;
 	u32 me0_data_valid;
+
+	/* QP histogram statistics */
+	struct iav_qp_hist_info qp_hist;
+	wait_queue_head_t qp_hist_wq;
+	u32 qp_hist_data_valid;
 };
 
 struct iav_efm_buf_pool {
@@ -304,11 +365,6 @@ struct iav_efm_info {
 	wait_queue_head_t wq;
 };
 
-struct iav_statis_desc {
-	struct iav_statisdesc desc;
-	struct list_head node;
-};
-
 struct iav_mem_block {
 	unsigned long phys;
 	unsigned long virt;
@@ -350,6 +406,23 @@ struct iav_raw_encode {
 	wait_queue_head_t raw_wq;
 };
 
+struct iav_mv_dump {
+	u16 enable : 1;
+	u16 buf_num : 15;
+	u16 width;
+	u16 height;
+	u16 pitch;
+	u32 unit_size;
+};
+
+struct iav_cmd_sync {
+	u8 idx;
+	u8 qpm_idx;
+	u8 qpm_flag;
+	u8 reserved;
+	u32 apply_pts[IAV_STREAM_MAX_NUM_ALL];
+};
+
 struct iav_sync_frame_cnt {
 	u32 curr_h264_cnt;
 	u32 curr_mjpeg_cnt;
@@ -392,7 +465,9 @@ struct iav_system_config {
 	u32	enc_from_mem : 1;
 	u32	enc_raw_yuv : 1;
 	u32	eis_delay_count : 2;
-	u32	reserved3 : 15;
+	u32	long_ref_b_frame : 1;
+	u32	extra_top_row_buf_enable : 1;
+	u32	reserved3 : 13;
 };
 
 struct iav_hwtimer_pts_info
@@ -501,6 +576,15 @@ struct iav_decode_context {
 	struct iav_decoder_info decoder_config[DIAV_MAX_DECODER_NUMBER];
 
 	struct iav_decoder_current_status decoder_current_status[DIAV_MAX_DECODER_NUMBER];
+
+	u8 *p_default_image_base;
+	u32 default_image_buffer_size;
+	u32 default_image_width;
+	u32 default_image_height;
+	u32 default_image_stride;
+
+	u8 *p_default_image_y;
+	u8 *p_default_image_uv;
 };
 
 struct ambarella_iav {
@@ -508,13 +592,22 @@ struct ambarella_iav {
 	struct device_node *of_node;
 	struct dsp_device *dsp;
 	struct mutex iav_mutex;
+	struct mutex enc_mutex;
 	spinlock_t iav_lock;
 
-	u32 dsp_enc_state;	/* DSP encode state */
-	u32 state;			/* current IAV state */
+	u32 dsp_enc_state;		/* DSP encode state */
+	u32 state;				/* current IAV state */
 	u32 probe_state;		/* IAV state in module probe param */
-	u32 encode_mode;	/* current encode mode */
-	u32 cmd_read_delay;	/* cmd read latency in audio clock unit */
+	u32 encode_mode;		/* current encode mode */
+	u32 cmd_read_delay;		/* cmd read latency in audio clock unit */
+	u32 resume_flag : 1;		/* resume from suspend */
+	u32 fast_resume : 1;		/* fast resume from suspend */
+	u32 fast_thaw : 1;		/* fast thaw from suspend */
+	u32 reserved0 : 29;
+
+	u16 vcap_state;			/* VIN capture current state */
+	u16 vcap_next_state;	/* VIN capture state to be configured */
+	wait_queue_head_t vcap_state_wq;
 
 	struct iav_decode_context decode_context;
 
@@ -568,6 +661,7 @@ struct ambarella_iav {
 	u32 bsh_size;
 	BIT_STREAM_HDR *bsh;		/* current bit stream header */
 	wait_queue_head_t frame_wq;
+	wait_queue_head_t mv_wq;
 	struct list_head frame_queue;
 	struct list_head frame_free;
 	struct iav_frame_desc *frame_queue_virt;  /* frame queue header */
@@ -576,9 +670,9 @@ struct ambarella_iav {
 	u32 bsb_mmap_count;
 	default_enc_binary_data_t *dsp_enc_data_virt;
 	default_dec_binary_data_t *dsp_dec_data_virt;
-	u32 cmd_sync_idx;
-	u32 cmd_sync_qpm_idx;
-	u32 cmd_sync_qpm_flag;
+
+	/* cmd sync*/
+	struct iav_cmd_sync cmd_sync;
 
 	/* Encode from RAW (RGB/YUV)*/
 	struct iav_raw_encode raw_enc;
@@ -605,7 +699,8 @@ struct ambarella_iav {
 	u32 mixer_b_enable : 1;
 	u32 osd_from_mixer_a : 1;
 	u32 osd_from_mixer_b : 1;
-	u32 reserved1 : 27;
+	u32 vin_overflow_protection : 1;
+	u32 reserved1 : 26;
 
 	/* hash cmd */
 	struct mutex hash_mutex; // seperate mutex, not do impact to encoding
@@ -624,6 +719,9 @@ struct ambarella_iav {
 	/* Debug tool */
 	struct iav_debug_cfg *debug;
 	u32 dsp_used_dram;
+
+	/* dsplog setup */
+	struct iav_dsplog_setup dsplog_setup;
 };
 
 #define	get_next_cmd(cmd, first)			do {		\
@@ -670,6 +768,7 @@ extern struct iav_buffer_limitation G_buffer_limit[];
 extern struct iav_enc_limitation G_encode_limit[];
 extern struct iav_system_config G_system_config[];
 extern struct iav_system_load G_system_load[];
+extern struct ambpriv_device *iav_device;
 
 #endif
 
diff --git a/drivers/iav/arch_s2l/iav_dec_api.c b/drivers/iav/arch_s2l/iav_dec_api.c
index 660e2bf..2eea434 100644
--- a/drivers/iav/arch_s2l/iav_dec_api.c
+++ b/drivers/iav/arch_s2l/iav_dec_api.c
@@ -3,14 +3,33 @@
  *
  * History:
  *	2015/01/21 - [Zhi He] created file
- * Copyright (C) 2015 -2018, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <config.h>
 #include <plat/ambcache.h>
 #include <linux/random.h>
@@ -33,6 +52,9 @@
 #define	DIAV_DEC_MAX_CMD_IN_TICK	(12)
 #define	DCACHE_LINE_SIZE		(32)
 
+//1920x1088x2 = 4177920 = 0x3FC000
+//#define	DCONFIG_DEFAULT_IMAGE_FOR_VOUT
+
 #if 0
 #define DEC_DEBUG(format, args...) (void)0
 #define DEC_ERROR(format, args...) (void)0
@@ -47,7 +69,7 @@
 	} while (0)
 #endif
 
-static int __is_interlace_vout_mode(u32 mode)
+static u8 __is_interlace_vout_mode(u32 mode)
 {
 	switch (mode) {
 		case AMBA_VIDEO_MODE_480I:
@@ -66,9 +88,6 @@ static int __is_interlace_vout_mode(u32 mode)
 
 static int __check_enter_decode_mode_params(struct iav_decode_mode_config* mode_config)
 {
-	u32 i = 0;
-	struct iav_decoder_config* decoder_config = NULL;
-
 	if (!mode_config->num_decoder) {
 		DEC_ERROR("num_decoder %d is zero\n",
 			mode_config->num_decoder);
@@ -81,18 +100,10 @@ static int __check_enter_decode_mode_params(struct iav_decode_mode_config* mode_
 		return -EINVAL;
 	}
 
-	for (i = 0; i < mode_config->num_decoder; ++i) {
-		decoder_config = &mode_config->decoder_configs[i];
-		if (!decoder_config->max_frm_width || !decoder_config->max_frm_height) {
-			DEC_ERROR("not specify frame width %d or height %d\n",
-				decoder_config->max_frm_width, decoder_config->max_frm_height);
-			return -EINVAL;
-		}
-		if (!decoder_config->max_frm_num) {
-			DEC_ERROR("not specify max_frm_num %d\n",
-				decoder_config->max_frm_num);
-			return -EINVAL;
-		}
+	if (!mode_config->max_frm_width || !mode_config->max_frm_height) {
+		DEC_ERROR("not specify max frame width %d or height %d\n",
+			mode_config->max_frm_width, mode_config->max_frm_height);
+		return -EINVAL;
 	}
 
 	return 0;
@@ -198,20 +209,28 @@ static void handle_dec_msg(void *data, DSP_MSG *msg)
 
 	spin_lock(&iav->iav_lock);
 
-	decoder_status->current_bsb_read_offset = p_dsp_msg->h264_bits_fifo_next -
-		decoder_status->current_bsb_addr_dsp_base;
 	if (decoder_status->decode_state != p_dsp_msg->decode_state) {
 		DEC_DEBUG("[decode_state]: %d --> %d\n",
 			decoder_status->decode_state, p_dsp_msg->decode_state);
 		decoder_status->decode_state = p_dsp_msg->decode_state;
 	}
-	decoder_status->error_status = p_dsp_msg->error_status;
-	decoder_status->total_error_count = p_dsp_msg->total_error_count;
-	decoder_status->decoded_pic_number = p_dsp_msg->decoded_pic_number;
-	decoder_status->last_pts = p_dsp_msg->latest_pts;
-	decoder_status->yuv422_y_addr = p_dsp_msg->yuv422_y_addr;
-	decoder_status->yuv422_uv_addr = p_dsp_msg->yuv422_uv_addr;
-	decoder_status->accumulated_dec_cmd_number = 0;
+	if (decoder_status->decode_state) {
+		u32 error_status = p_dsp_msg->error_status & 0x7fffffff;
+		decoder_status->current_bsb_read_offset = p_dsp_msg->h264_bits_fifo_next -
+		decoder_status->current_bsb_addr_dsp_base;
+		if (ERR_NO_4BYTEHEADER != error_status) {
+			decoder_status->error_status = error_status;
+		} else {
+			decoder_status->error_status = 0;
+		}
+		decoder_status->total_error_count = p_dsp_msg->total_error_count;
+		decoder_status->decoded_pic_number = p_dsp_msg->decoded_pic_number;
+		decoder_status->last_pts = p_dsp_msg->latest_pts;
+		decoder_status->yuv422_y_addr = p_dsp_msg->yuv422_y_addr;
+		decoder_status->yuv422_uv_addr = p_dsp_msg->yuv422_uv_addr;
+		decoder_status->accumulated_dec_cmd_number = 0;
+	}
+
 	decoder_status->irq_count ++;
 	__dec_notify_waiters(decoder_status);
 
@@ -225,7 +244,7 @@ static inline int set_dsp_to_decode_mode(struct ambarella_iav *iav)
 	int ret = 0;
 	struct dsp_device *dsp = iav->dsp;
 
-	ret = dsp->set_op_mode(dsp, DSP_DECODE_MODE, NULL);
+	ret = dsp->set_op_mode(dsp, DSP_DECODE_MODE, NULL, 0);
 	if (!ret) {
 		iav->state = IAV_STATE_DECODING;
 	} else {
@@ -242,44 +261,39 @@ static int setup_h264_decoder(struct ambarella_iav *iav, u8 decoder_id)
 	struct amb_dsp_cmd *first, *cmd;
 	u8 i = 0;
 	struct iav_decode_vout_config *pvout_config = NULL;
-	int is_interlace = 0;
+	u8 is_interlace = 0;
+	struct iav_decoder_current_status *dec_status = &iav->decode_context.decoder_current_status[decoder_id];
 
 	if (1 != decoder->num_vout) {
 		DEC_ERROR("only support single vout\n");
 		decoder->num_vout = 1;
 	}
-
 	iav->decode_context.b_interlace_vout = __is_interlace_vout_mode(decoder->vout_configs[0].vout_mode);
-	first = dsp->get_multi_cmds(dsp, 3 + decoder->num_vout, DSP_CMD_FLAG_BLOCK);
-	if (!first) {
-		DEC_ERROR("no memory\n");
-		return -ENOMEM;
-	}
-
-	cmd = first;
-	cmd_system_info_setup(iav, cmd, 1);
-	get_next_cmd(cmd, first);
-	cmd_h264_decoder_setup(iav, cmd, decoder_id);
-	for (i = 0; i < decoder->num_vout; i ++) {
-		pvout_config = &decoder->vout_configs[i];
-		is_interlace = __is_interlace_vout_mode(pvout_config->vout_mode);
+
+	if (HDEC_OPM_IDLE == dec_status->decode_state) {
+		first = dsp->get_multi_cmds(dsp, 3 + decoder->num_vout, DSP_CMD_FLAG_BLOCK);
+		if (!first) {
+			DEC_ERROR("no memory\n");
+			return -ENOMEM;
+		}
+
+		cmd = first;
+		cmd_system_info_setup(iav, cmd, 1);
 		get_next_cmd(cmd, first);
-		if (!is_interlace) {
-			cmd_vout_video_setup(iav, cmd, pvout_config->vout_id, pvout_config->enable,
-				VOUT_SRC_DEC, pvout_config->flip, pvout_config->rotate,
-				pvout_config->target_win_offset_x, pvout_config->target_win_offset_y,
-				pvout_config->target_win_width, pvout_config->target_win_height);
-		} else {
-			cmd_vout_video_setup(iav, cmd, pvout_config->vout_id, pvout_config->enable,
-				VOUT_SRC_DEC, pvout_config->flip, pvout_config->rotate,
-				pvout_config->target_win_offset_x, pvout_config->target_win_offset_y,
-				pvout_config->target_win_width, pvout_config->target_win_height / 2);
+		cmd_h264_decoder_setup(iav, cmd, decoder_id);
+		for (i = 0; i < decoder->num_vout; i ++) {
+			pvout_config = &decoder->vout_configs[i];
+			is_interlace = __is_interlace_vout_mode(pvout_config->vout_mode);
+			get_next_cmd(cmd, first);
+			cmd_vout_video_setup(iav, cmd, pvout_config, VOUT_SRC_DEC, is_interlace);
 		}
-	}
-	get_next_cmd(cmd, first);
-	cmd_rescale_postp(iav, cmd, decoder_id, (decoder->width >> 1), (decoder->height >> 1));
+		get_next_cmd(cmd, first);
+		cmd_rescale_postp(iav, cmd, decoder_id, (decoder->width >> 1), (decoder->height >> 1));
 
-	dsp->put_cmd(dsp, first, 0);
+		dsp->put_cmd(dsp, first, 0);
+	} else {
+		cmd_rescale_postp(iav, NULL, decoder_id, (decoder->width >> 1), (decoder->height >> 1));
+	}
 
 	return 0;
 }
@@ -359,6 +373,14 @@ static void init_decoder_setting(struct iav_decoder_info* dec_config,
 	dec_status->is_started = 0;
 	dec_status->b_send_first_decode_cmd = 0;
 	dec_status->b_send_stop_cmd = 0;
+
+	dec_status->error_status = 0;
+	dec_status->total_error_count = 0;
+	dec_status->decoded_pic_number = 0;
+
+	dec_status->irq_count = 0;
+	dec_status->yuv422_y_addr = 0;
+	dec_status->yuv422_uv_addr = 0;
 }
 
 static void init_all_decoder_setting(struct ambarella_iav *iav)
@@ -385,6 +407,16 @@ static void init_decoder_status(struct iav_decoder_current_status *status)
 	status->speed = 0x100;
 	status->scan_mode = IAV_PB_SCAN_MODE_ALL_FRAMES;
 	status->direction= IAV_PB_DIRECTION_FW;
+
+	status->decode_state = 0;
+	status->error_status = 0;
+	status->total_error_count = 0;
+	status->decoded_pic_number = 0;
+
+	status->irq_count = 0;
+	status->yuv422_y_addr = 0;
+	status->yuv422_uv_addr = 0;
+
 }
 
 static int iav_enter_decode_mode(struct ambarella_iav *iav)
@@ -402,7 +434,18 @@ static int iav_enter_decode_mode(struct ambarella_iav *iav)
 			if (rval) {
 				break;
 			}
+#ifndef DCONFIG_DEFAULT_IMAGE_FOR_VOUT
 			iav_config_vout(VOUT_SRC_DEC);
+#else
+			if (iav->decode_context.p_default_image_y && iav->decode_context.p_default_image_uv) {
+                iav_config_vout_with_default_image(VOUT_SRC_DEFAULT_IMG,
+					VIRT_TO_DSP(iav->decode_context.p_default_image_y),
+					VIRT_TO_DSP(iav->decode_context.p_default_image_uv),
+					iav->decode_context.default_image_stride);
+			} else {
+				iav_config_vout(VOUT_SRC_DEC);
+			}
+#endif
 			DEC_DEBUG("[iav flow]: boot dsp to dec mode, iav state (%d)\n", iav->state);
 		} else if (IAV_STATE_IDLE != iav->state) {
 			DEC_ERROR("(%d) not in idle state, should goto idle first.\n", iav->state);
@@ -414,7 +457,18 @@ static int iav_enter_decode_mode(struct ambarella_iav *iav)
 			if (rval) {
 				break;
 			}
+#ifndef DCONFIG_DEFAULT_IMAGE_FOR_VOUT
 			iav_config_vout(VOUT_SRC_DEC);
+#else
+			if (iav->decode_context.p_default_image_y && iav->decode_context.p_default_image_uv) {
+                iav_config_vout_with_default_image(VOUT_SRC_DEFAULT_IMG,
+					VIRT_TO_DSP(iav->decode_context.p_default_image_y),
+					VIRT_TO_DSP(iav->decode_context.p_default_image_uv),
+					iav->decode_context.default_image_stride);
+			} else {
+				iav_config_vout(VOUT_SRC_DEC);
+			}
+#endif
 			DEC_DEBUG("[iav flow]: set dsp to decode mode done, iav state (%d)\n", iav->state);
 		}
 	} while (0);
@@ -440,18 +494,58 @@ static int iav_ioc_enter_decode_mode(struct ambarella_iav *iav, void __user * ar
 		return rval;
 	}
 	memcpy(&dec_context->mode_config, &mode_config, sizeof(mode_config));
+	DEC_DEBUG("num %d, support ff %d, drpoc %d, max video %dx%d, vout0 %dx%d, vout1 %dx%d\n",
+		dec_context->mode_config.num_decoder,
+		dec_context->mode_config.b_support_ff_fb_bw, dec_context->mode_config.debug_use_dproc,
+		dec_context->mode_config.max_frm_width, dec_context->mode_config.max_frm_height,
+		dec_context->mode_config.max_vout0_width, dec_context->mode_config.max_vout0_height,
+		dec_context->mode_config.max_vout1_width, dec_context->mode_config.max_vout1_height);
+
+#ifdef DCONFIG_DEFAULT_IMAGE_FOR_VOUT
+    if (!iav->decode_context.p_default_image_base) {
+        u32 memset_size = 0;
+
+        iav->decode_context.default_image_stride = iav->decode_context.default_image_width = 1920;
+        iav->decode_context.default_image_height = 1080;
+        iav->decode_context.default_image_buffer_size = (iav->decode_context.default_image_height * iav->decode_context.default_image_stride) * 2 + 32 * 2;
+
+        iav->decode_context.p_default_image_base = (u8 *) iav->mmap[IAV_BUFFER_VCA].virt;
+        printk("!iav->decode_context.p_default_image_base %ld\n", iav->decode_context.p_default_image_base);
+        if (iav->decode_context.p_default_image_base) {
+            iav->decode_context.p_default_image_y = (u8 *) (((u32) (iav->decode_context.p_default_image_base + 31)) & (~31));
+            iav->decode_context.p_default_image_uv = (u8 *) (((u32) (iav->decode_context.p_default_image_y + 31 + iav->decode_context.default_image_stride * iav->decode_context.default_image_height)) & (~31));
+
+            memset_size = (iav->decode_context.default_image_stride * iav->decode_context.default_image_height) / 4;
+            memset(iav->decode_context.p_default_image_y, 0x10, memset_size);
+            memset(iav->decode_context.p_default_image_y + memset_size, 0xb0, memset_size);
+            memset(iav->decode_context.p_default_image_y + memset_size + memset_size, 0x70, memset_size);
+            memset(iav->decode_context.p_default_image_y + memset_size + memset_size + memset_size, 0xf0, memset_size);
+
+            memset_size = (iav->decode_context.default_image_stride * iav->decode_context.default_image_height) / 4;
+            memset(iav->decode_context.p_default_image_uv, 0x33, memset_size);
+            memset(iav->decode_context.p_default_image_uv + memset_size, 0x55, memset_size);
+            memset(iav->decode_context.p_default_image_uv + memset_size + memset_size, 0xcc, memset_size);
+            memset(iav->decode_context.p_default_image_uv + memset_size + memset_size + memset_size, 0x77, memset_size);
+        } else {
+            printk("!null memory base\n");
+        }
+    }
+#endif
 
 	rval = iav_enter_decode_mode(iav);
 
 	return rval;
 }
 
+extern int iav_goto_timer_mode(struct ambarella_iav *iav);
 static int iav_ioc_leave_decode_mode(struct ambarella_iav *iav)
 {
 	DEC_DEBUG("[iav flow]: leave decode_mode, from state (%d)\n", iav->state);
-
-	iav_clean_decode_stuff(iav);
-
+	if (IAV_STATE_DECODING == iav->state) {
+		iav_clean_decode_stuff(iav);
+		iav_goto_timer_mode(iav);
+		DEC_DEBUG("[iav flow]: after goto idle (timer mode), state %d\n", iav->state);
+	}
 	return 0;
 }
 
@@ -481,6 +575,15 @@ static int iav_ioc_create_decoder(struct ambarella_iav *iav, void __user * arg)
 		return -EINVAL;
 	}
 
+	if ((decoder_info.width > dec_context->mode_config.max_frm_width)
+		|| (decoder_info.height > dec_context->mode_config.max_frm_height)) {
+		DEC_ERROR("exceed max video resolution %dx%d, max %dx%d.\n",
+			decoder_info.width, decoder_info.height,
+			dec_context->mode_config.max_frm_width, dec_context->mode_config.max_frm_height);
+		mutex_unlock(&iav->iav_mutex);
+		return -EINVAL;
+	}
+
 	if (dec_context->decoder_config[decoder_info.decoder_id].setup_done) {
 		DEC_ERROR("decoder_id %d is already setup.\n", decoder_info.decoder_id);
 		mutex_unlock(&iav->iav_mutex);
@@ -628,19 +731,32 @@ static int iav_ioc_decode_stop(struct ambarella_iav *iav, void __user * arg)
 		return -EPERM;
 	}
 
-	if (!dec_status->b_send_stop_cmd) {
-		/* always stop 1, stop 0 need re-setup decoder */
-		cmd_decode_stop(iav, stop.decoder_id, 1);
-		dec_status->b_send_stop_cmd = 1;
-		if (0 == stop.stop_flag) {
+	if (0 == dec_status->error_status) {
+		if (!dec_status->b_send_stop_cmd) {
+			/* always stop 1, stop 0 need re-setup decoder */
+			stop.stop_flag = 1;
+			cmd_decode_stop(iav, stop.decoder_id, stop.stop_flag);
+			dec_status->b_send_stop_cmd = 1;
+			if (0 == stop.stop_flag) {
+				DEC_DEBUG("[iav flow]: stop decode(id %d, flag 0), wait dec state to 0\n", stop.decoder_id);
+				wait_dec_state(iav, dec_status, HDEC_OPM_IDLE);
+			} else {
+				DEC_DEBUG("[iav flow]: stop decode(id %d, flag 1), wait dec state to 2\n", stop.decoder_id);
+				wait_dec_state(iav, dec_status, HDEC_OPM_VDEC_IDLE);
+			}
+		} else {
+			DEC_ERROR("already stopped.\n");
+		}
+	} else {
+		if (!dec_status->b_send_stop_cmd) {
+			/* stop 0, to clean errors */
+			cmd_decode_stop(iav, stop.decoder_id, 0);
+			dec_status->b_send_stop_cmd = 1;
 			DEC_DEBUG("[iav flow]: stop decode(id %d, flag 0), wait dec state to 0\n", stop.decoder_id);
 			wait_dec_state(iav, dec_status, HDEC_OPM_IDLE);
 		} else {
-			DEC_DEBUG("[iav flow]: stop decode(id %d, flag 1), wait dec state to 2\n", stop.decoder_id);
-			wait_dec_state(iav, dec_status, HDEC_OPM_VDEC_IDLE);
+			DEC_ERROR("already stopped.\n");
 		}
-	} else {
-		DEC_ERROR("already stopped.\n");
 	}
 
 	//DEC_DEBUG("before awake waiters(%d), %p.\n", dec_context->decoder_current_status[stop.decoder_id].num_waiters, &dec_context->decoder_current_status[stop.decoder_id]);
@@ -694,6 +810,12 @@ static int iav_ioc_decode_video(struct ambarella_iav *iav, void __user * arg)
 		return -EPERM;
 	}
 
+	if (0 != status->error_status) {
+		DEC_ERROR("decoder met error, status %d\n", status->error_status);
+		mutex_unlock(&iav->iav_mutex);
+		return -EPERM;
+	}
+
 	spin_lock(&iav->iav_lock);
 	status->current_bsb_write_offset = decode_video.end_ptr_offset;
 	spin_unlock(&iav->iav_lock);
@@ -713,7 +835,7 @@ static int iav_ioc_decode_video(struct ambarella_iav *iav, void __user * arg)
 		} else {
 			cmd_h264_decode(iav, NULL, decode_video.decoder_id,
 				decode_video.start_ptr_offset + status->current_bsb_addr_dsp_base,
-				status->current_bsb_size + status->current_bsb_addr_dsp_base,
+				status->current_bsb_size + status->current_bsb_addr_dsp_base - 1,
 				decode_video.num_frames, decode_video.first_frame_display);
 		}
 
@@ -760,7 +882,7 @@ static int iav_ioc_decode_video(struct ambarella_iav *iav, void __user * arg)
 			decode_video.num_frames);
 	} else {
 		cmd_h264_decode_fifo_update(iav, NULL, decode_video.decoder_id,
-			decode_video.start_ptr_offset + status->current_bsb_addr_dsp_base,
+			decode_video.start_ptr_offset + status->current_bsb_addr_dsp_base - 1,
 			status->current_bsb_size + status->current_bsb_addr_dsp_base,
 			decode_video.num_frames);
 	}
@@ -809,6 +931,12 @@ static int iav_ioc_wait_decode_bsb(struct ambarella_iav *iav, void __user * arg)
 
 	status = &iav->decode_context.decoder_current_status[bsb.decoder_id];
 
+	if (0 != status->error_status) {
+		DEC_ERROR("decoder met error, status 0x%08x, %d\n", status->error_status, status->error_status);
+		mutex_unlock(&iav->iav_mutex);
+		return -EPERM;
+	}
+
 	if ((bsb.room + DIAV_DEC_MIN_GAP_IN_BSB) >= status->current_bsb_size) {
 		DEC_ERROR("request size (%d) + DIAV_DEC_MIN_GAP_IN_BSB "
 			"exceed total bsb size (%d).\n", bsb.room, status->current_bsb_size);
@@ -892,6 +1020,12 @@ static int iav_ioc_decode_trick_play(struct ambarella_iav *iav, void __user * ar
 		return rval;
 	}
 
+	if (0 != dec_context->decoder_current_status[trickplay.decoder_id].error_status) {
+		DEC_ERROR("decoder met error, status %d\n", dec_context->decoder_current_status[trickplay.decoder_id].error_status);
+		mutex_unlock(&iav->iav_mutex);
+		return -EPERM;
+	}
+
 	if (!dec_context->decoder_current_status[trickplay.decoder_id].is_started) {
 		DEC_DEBUG("decode(%d) not started!\n", trickplay.decoder_id);
 		mutex_unlock(&iav->iav_mutex);
@@ -952,6 +1086,12 @@ static int iav_ioc_decode_speed(struct ambarella_iav *iav, void __user * arg)
 		return rval;
 	}
 
+	if (0 != dec_context->decoder_current_status[speed.decoder_id].error_status) {
+		DEC_ERROR("decoder met error, status %x\n", dec_context->decoder_current_status[speed.decoder_id].error_status);
+		mutex_unlock(&iav->iav_mutex);
+		return -EPERM;
+	}
+
 	if (!dec_context->decoder_current_status[speed.decoder_id].is_started) {
 		DEC_DEBUG("decode(%d) not started!\n", speed.decoder_id);
 		mutex_unlock(&iav->iav_mutex);
@@ -1000,9 +1140,14 @@ static int iav_ioc_query_decode_info(struct ambarella_iav *iav, void __user * ar
 		mutex_unlock(&iav->iav_mutex);
 		return rval;
 	}
-	mutex_unlock(&iav->iav_mutex);
 
 	status = &iav->decode_context.decoder_current_status[dec_status.decoder_id];
+	if (status->b_send_stop_cmd) {
+		DEC_DEBUG("decode(%d) already stopped!\n", dec_status.decoder_id);
+		mutex_unlock(&iav->iav_mutex);
+		return -EACCES;
+	}
+	mutex_unlock(&iav->iav_mutex);
 
 	spin_lock(&iav->iav_lock);
 	if (status->current_bsb_read_offset > status->current_bsb_write_offset) {
@@ -1070,9 +1215,14 @@ static int iav_ioc_query_decode_bsb(struct ambarella_iav *iav, void __user * arg
 		mutex_unlock(&iav->iav_mutex);
 		return rval;
 	}
-	mutex_unlock(&iav->iav_mutex);
 
 	status = &iav->decode_context.decoder_current_status[bsb.decoder_id];
+	if (status->b_send_stop_cmd) {
+		DEC_DEBUG("decode(%d) already stopped!\n", bsb.decoder_id);
+		mutex_unlock(&iav->iav_mutex);
+		return -EACCES;
+	}
+	mutex_unlock(&iav->iav_mutex);
 
 	spin_lock(&iav->iav_lock);
 	if (status->current_bsb_read_offset > status->current_bsb_write_offset) {
diff --git a/drivers/iav/arch_s2l/iav_dec_api.h b/drivers/iav/arch_s2l/iav_dec_api.h
index 7dbdcf7..7171b0b 100644
--- a/drivers/iav/arch_s2l/iav_dec_api.h
+++ b/drivers/iav/arch_s2l/iav_dec_api.h
@@ -4,15 +4,34 @@
  * History:
  *	2015/01/21 - [Zhi He] created file
  *
- * Copyright (C) 2015 -2018, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #ifndef __IAV_DEC_API_H__
 #define __IAV_DEC_API_H__
 
@@ -33,6 +52,50 @@ typedef enum {
 	HDEC_OPM_RAW_DECODE_2_IDLE, // not used yet - jrc 12/01/2005
 } HDEC_OPMODE;
 
+typedef enum {
+	ERR_NO_ERROR = 0,          //!< No error.
+	ERR_NO_4BYTEHEADER,        //!< Failed to search for the 4 byte sequence(0x00000001).
+	ERR_NALU_FORBIDDEN_ZERO,   //!< forbidden_zero_bit of NALU header is non-zero.
+	ERR_SPS_ID_OUTOFRANGE,     //!< seq_id over supported range, (2 by default, standard allows 0..31.
+	ERR_PPS_ID_OUTOFRANGE,     //!< pps_id over supported range, (2 by default, standard allows 0..255.
+	ERR_UNSUPPORTED_PROFILE,   //!< Only Main profile is supported.
+	ERR_UNSUPPORTED_POC_TYPE,  //!< Only type=0 is implemented by now.
+	ERR_LOG2MAXFRNUMOUTRANGE,  //!< Over 12, according to the Standard.
+	ERR_LOG2MAXPOCNTOUTRANGE,  //!< Over 12, according to the Standard.
+	ERR_PIC_WIDTHOUTRANGE,     //!< Picture is too wide.
+	ERR_PIC_HEIGHTOUTRANGE,    //!< Picture is too high.
+
+	ERR_PPS_SPS_ID_OUTRANGE,   //!< PPS.seq_id is out of range.
+	ERR_PPS_SPS_ID_NONEXISTS,  //!< PPS.seq_id does not exist.
+
+	ERR_SH_PPS_ID_OUTOFRANGE,  //!< SH.pps_id is out of range.
+	ERR_SH_PPS_ID_NONEXISTS,   //!< SH.pps_id does not exist.
+
+	ERR_CAVLC_NOTSUPPORTED,    //!< Not a CABAC stream (not supported).
+	ERR_MORETHANONESLICE,      //!< More than one slice per picture, not supported.
+	ERR_FIRSTMBADDRNONEZERO,   //!< First MB address of the slice is not zero.
+	ERR_INVALID_SLICETYPE,     //!< Slice type is not supported.
+	ERR_NOENOUGHFRMBUFS,       //!< There is no enough frame buffers as reqired by DPB.
+	ERR_FRMNO_IDRNONZERO,      //!< Current slice is IDR but frame num is not zero.
+	ERR_DIRECT_NONSPATIAL,     //!< Direct more is not spatial (temporal).
+	ERR_REFREORDER_INVALID,    //!< Invalid reordering_of_pic_idc (not 0 ~3)
+	ERR_REFREORDER_OVERLIMIT,  //!< Reorder reference picture over limit, see 7.4.3.1.
+	ERR_ERMARKER_OVERLIMIT,    //!< Ref picture markering number over limit, see 7.4.3.3
+	ERR_NUM_REFLIST0_TOOBIG,   //!<
+	ERR_NUM_REFLIST1_TOOBIG,   //!<
+	ERR_CABAC_INIT_IDC_NOZERO, //!< Only INIT_CABAC_IDC=0 is implemented.
+	ERR_DECMB,                 //!< Error occurs during decoding an individual MB
+	ERR_CMDINWROUNDSTATE,      //!< Command issued in wrong state, thus cannot be executed.
+	ERR_NOIDR,                 //!< Have not seen an IDR slice
+	ERR_BWD,                   //!< General BWD errors
+	ERR_POCTYPE_NONSUPPORTED,  //!< POC type not supported
+	ERR_LIST_TOO_SMALL,        //!< The number of entries of the list smaller than active_minus1 + 1
+	ERR_MMBUF,                 //!< Invalid Memory management or buffer operations
+	ERR_MISMATCHFIELDS,        //!< Field pairs not matched
+	ERR_PJPEG_TOO_BIG,         //!< PJPEG too big
+	ERR_UNKNOWN,               //!< Unknown error
+}HDEC_ERROR;
+
 void iav_clean_decode_stuff(struct ambarella_iav *iav);
 
 int iav_decode_ioctl(struct ambarella_iav *iav, unsigned int cmd, unsigned long arg);
diff --git a/drivers/iav/arch_s2l/iav_drv.c b/drivers/iav/arch_s2l/iav_drv.c
index 386bd01..e7abd0b 100644
--- a/drivers/iav/arch_s2l/iav_drv.c
+++ b/drivers/iav/arch_s2l/iav_drv.c
@@ -5,14 +5,33 @@
  *	2012/10/10 - [Cao Rongrong] created file
  *	2013/12/12 - [Jian Tang] modified file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <config.h>
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
@@ -27,12 +46,14 @@
 #include <plat/event.h>
 #include <plat/ambcache.h>
 #include <mach/hardware.h>
+#include <iav_fastboot.h>
 #include <iav_utils.h>
 #include <iav_ioctl.h>
 #include <iav_devnum.h>
 #include <vout_api.h>
 #include <dsp_api.h>
 #include <vin_api.h>
+#include <dsplog_api.h>
 #include "iav.h"
 #include "iav_vin.h"
 #include "iav_vout.h"
@@ -47,12 +68,13 @@
 #endif
 
 struct amba_iav_vout_info G_voutinfo[] = {{0, 0,}, {0, 0,}};
+static struct iav_imgproc_info G_img_info;
 
 static int iav_state_proc_show(struct seq_file *m, void *v)
 {
 	struct ambarella_iav *iav;
 	struct iav_state_info info;
-	int chip, rval = 0;
+	int chip;
 
 	iav = (struct ambarella_iav *)m->private;
 
@@ -73,27 +95,30 @@ static int iav_state_proc_show(struct seq_file *m, void *v)
 	case AMBA_CHIP_ID_S2L_55M:
 	case AMBA_CHIP_ID_S2L_99M:
 	case AMBA_CHIP_ID_S2L_TEST:
-		rval += seq_printf(m, "AMBARELLA_CHIP=S2LM\n");
+	case AMBA_CHIP_ID_S2L_33MEX:
+		seq_printf(m, "AMBARELLA_CHIP=S2LM\n");
 		break;
 	case AMBA_CHIP_ID_S2L_63:
 	case AMBA_CHIP_ID_S2L_66:
 	case AMBA_CHIP_ID_S2L_88:
 	case AMBA_CHIP_ID_S2L_99:
-		rval += seq_printf(m, "AMBARELLA_CHIP=S2L\n");
+	case AMBA_CHIP_ID_S2L_22:
+	case AMBA_CHIP_ID_S2L_33EX:
+		seq_printf(m, "AMBARELLA_CHIP=S2L\n");
 		break;
 	default:
-		rval += seq_printf(m, "AMBARELLA_CHIP=UNKNOWN\n");
+		seq_printf(m, "AMBARELLA_CHIP=UNKNOWN\n");
 		break;
 	}
-	rval += seq_printf(m, "dsp_op_mode: %d\n", info.dsp_op_mode);
-	rval += seq_printf(m, "dsp_encode_state: %d\n", info.dsp_encode_state);
-	rval += seq_printf(m, "dsp_encode_mode: %d\n", info.dsp_encode_mode);
-	rval += seq_printf(m, "dsp_decode_state: %d\n", info.dsp_decode_state);
-	rval += seq_printf(m, "decode_state: %d\n", info.decode_state);
-	rval += seq_printf(m, "encode timecode: %d\n", info.encode_timecode);
-	rval += seq_printf(m, "encode pts: %d\n", info.encode_pts);
+	seq_printf(m, "dsp_op_mode: %d\n", info.dsp_op_mode);
+	seq_printf(m, "dsp_encode_state: %d\n", info.dsp_encode_state);
+	seq_printf(m, "dsp_encode_mode: %d\n", info.dsp_encode_mode);
+	seq_printf(m, "dsp_decode_state: %d\n", info.dsp_decode_state);
+	seq_printf(m, "decode_state: %d\n", info.decode_state);
+	seq_printf(m, "encode timecode: %d\n", info.encode_timecode);
+	seq_printf(m, "encode pts: %d\n", info.encode_pts);
 
-	return rval;
+	return 0;
 }
 
 static int iav_state_proc_open(struct inode *inode, struct file *file)
@@ -127,35 +152,35 @@ static int iav_img_ioctl(struct ambarella_iav *iav, unsigned int cmd, unsigned l
 	int rval = 0, enc_mode;
 	struct iav_rect * vin;
 	struct iav_system_config *config;
-	struct iav_imgproc_info info;
+	struct iav_imgproc_info *info;
 
-	memset(&info, 0, sizeof(info));
+	info = &G_img_info;
 
 	get_vin_win(iav, &vin, 1);
 
 	mutex_lock(&iav->iav_mutex);
 	enc_mode = iav->encode_mode;
 	config = &iav->system_config[enc_mode];
-	info.iav_state = iav->state;
-	info.vin_num = 1;
-	info.hdr_expo_num = config->expo_num;
-	info.cap_width = vin->width;
-	info.cap_height = vin->height;
-	info.hdr_mode = get_hdr_type(iav);
-	info.img_size = iav->mmap[IAV_BUFFER_IMG].size;
-	info.img_virt = iav->mmap[IAV_BUFFER_IMG].virt;
-	info.img_phys = iav->mmap[IAV_BUFFER_IMG].phys;
-	info.img_config_offset = IAV_DRAM_IMG_OFFET;
+	info->iav_state = iav->state;
+	info->vin_num = 1;
+	info->hdr_expo_num = config->expo_num;
+	info->cap_width = vin->width;
+	info->cap_height = vin->height;
+	info->hdr_mode = get_hdr_type(iav);
+	info->img_size = iav->mmap[IAV_BUFFER_IMG].size;
+	info->img_virt = iav->mmap[IAV_BUFFER_IMG].virt;
+	info->img_phys = iav->mmap[IAV_BUFFER_IMG].phys;
+	info->img_config_offset = IAV_DRAM_IMG_OFFET;
 	if (!iav->dsp_partition_mapped) {
-		info.dsp_virt = iav->mmap[IAV_BUFFER_DSP].virt;
-		info.dsp_phys = iav->mmap[IAV_BUFFER_DSP].phys;
+		info->dsp_virt = iav->mmap[IAV_BUFFER_DSP].virt;
+		info->dsp_phys = iav->mmap[IAV_BUFFER_DSP].phys;
 	} else {
-		info.dsp_virt = iav->mmap_dsp[IAV_DSP_SUB_BUF_RAW].virt;
-		info.dsp_phys = iav->mmap_dsp[IAV_DSP_SUB_BUF_RAW].phys;
+		info->dsp_virt = iav->mmap_dsp[IAV_DSP_SUB_BUF_RAW].virt;
+		info->dsp_phys = iav->mmap_dsp[IAV_DSP_SUB_BUF_RAW].phys;
 	}
-	info.iav_mutex = &iav->iav_mutex;
+	info->iav_mutex = &iav->iav_mutex;
 
-	rval = amba_imgproc_cmd(&info, cmd, args);
+	rval = amba_imgproc_cmd(info, cmd, args);
 	mutex_unlock(&iav->iav_mutex);
 
 	return rval;
@@ -248,6 +273,16 @@ static void iav_destroy_dev(struct ambarella_iav *iav)
 	unregister_chrdev_region(iav->iav_cdev.dev, 1);
 }
 
+static inline int iav_drv_probe_thaw_method(struct ambarella_iav *iav)
+{
+	struct iav_fb_hdr *fb_hdr = (struct iav_fb_hdr *)
+		iav->mmap[IAV_BUFFER_FB_DATA].virt;
+
+	iav->fast_thaw = fb_hdr->fast_thaw;
+
+	return 0;
+}
+
 /* store dsp status in amboot, restore it after enter Linux IAV */
 static int iav_drv_probe_status(struct ambarella_iav *iav)
 {
@@ -284,10 +319,18 @@ static int iav_drv_probe_status(struct ambarella_iav *iav)
 /* store vin video format in amboot, restore it after enter Linux IAV */
 static int iav_drv_probe_vin_video_format(struct ambarella_iav *iav)
 {
-	iav->vin_probe_format = (struct vin_video_format *)
-		(iav->mmap[IAV_BUFFER_FB_DATA].virt + DSP_STATUS_STORE_SIZE);
+	struct iav_fb_hdr *fb_hdr = (struct iav_fb_hdr *)
+		iav->mmap[IAV_BUFFER_FB_DATA].virt;
 
-	if ((iav->vin_probe_format->video_mode != AMBA_VIDEO_MODE_INVALID) &&
+	if (fb_hdr->bin[IAV_FB_VIN_VIDEO_FORMAT].size == sizeof(struct vin_video_format)) {
+		iav->vin_probe_format = (struct vin_video_format *)
+			((u8 *)fb_hdr + fb_hdr->bin[IAV_FB_VIN_VIDEO_FORMAT].offset);
+	} else {
+		iav_error("Incorrect vin video format size [%d], should be [%d]\n",
+			fb_hdr->bin[IAV_FB_VIN_VIDEO_FORMAT].size, sizeof(struct vin_video_format));
+	}
+
+	if (iav->vin_probe_format && (iav->vin_probe_format->video_mode != AMBA_VIDEO_MODE_INVALID) &&
 		(iav->vin_probe_format->hdr_mode != AMBA_VIDEO_HDR_MODE_INVALID)) {
 		iav->vin_enabled = 1;
 	}
@@ -298,10 +341,40 @@ static int iav_drv_probe_vin_video_format(struct ambarella_iav *iav)
 /* store vin dsp config in amboot, restore it after enter Linux IAV */
 static int iav_drv_probe_vin_dsp_config (struct ambarella_iav *iav)
 {
-	memcpy(iav->vinc[0]->dsp_config,
-		(struct vin_dsp_config *)(iav->mmap[IAV_BUFFER_FB_DATA].virt +
-		DSP_STATUS_STORE_SIZE + DSP_VIN_VIDEO_FORMAT_STORE_SIZE),
-		sizeof(struct vin_dsp_config));
+	struct iav_fb_hdr *fb_hdr = (struct iav_fb_hdr *)
+		iav->mmap[IAV_BUFFER_FB_DATA].virt;
+
+	if (fb_hdr->bin[IAV_FB_VIN_DSP_CONFIG].size == sizeof(struct vin_dsp_config)) {
+		memcpy(iav->vinc[0]->dsp_config,
+			((u8 *)fb_hdr + fb_hdr->bin[IAV_FB_VIN_DSP_CONFIG].offset),
+			sizeof(struct vin_dsp_config));
+	} else {
+		iav_error("Incorrect vin dsp config size [%d], should be [%d]\n",
+			fb_hdr->bin[IAV_FB_VIN_DSP_CONFIG].size, sizeof(struct vin_dsp_config));
+	}
+
+	return 0;
+}
+
+static int iav_drv_probe_fb_data(struct ambarella_iav *iav)
+{
+	int rval = 0;
+
+	rval = iav_drv_probe_vin_dsp_config(iav);
+	if (rval < 0) {
+		iav_error("iav drv probe vin dsp config failed\n");
+		return -1;
+	}
+
+	rval = iav_restore_dsp_cmd(iav);
+	if (rval < 0) {
+		iav_error("iav restore dsp cmd failed\n");
+		return -1;
+	}
+
+	if (iav->probe_state == IAV_STATE_ENCODING) {
+		iav_sync_bsh_queue(iav);
+	}
 
 	return 0;
 }
@@ -337,10 +410,13 @@ static int iav_drv_probe(struct ambpriv_device *ambdev)
 	iav->mixer_b_enable = 1;
 	iav->osd_from_mixer_a = 1;
 	iav->osd_from_mixer_b = 0;
+	iav->vin_overflow_protection = 0;
 	iav->err_vsync_handling = 0;
 	iav->err_vsync_again = 0;
 	iav->err_vsync_lost = 0;
+	memset(&iav->dsplog_setup, 0, sizeof(struct iav_dsplog_setup));
 	mutex_init(&iav->iav_mutex);
+	mutex_init(&iav->enc_mutex);
 	spin_lock_init(&iav->iav_lock);
 
 	iav_init_source_buffer(iav);
@@ -359,7 +435,7 @@ static int iav_drv_probe(struct ambpriv_device *ambdev)
 
 	iav_init_debug(iav);
 
-	init_netlink(iav);
+	iav_init_netlink(iav);
 
 	rval = iav_create_dev(iav);
 	if (rval < 0)
@@ -392,15 +468,15 @@ static int iav_drv_probe(struct ambpriv_device *ambdev)
 		goto iav_init_err;
 
 	if (iav->probe_state != IAV_STATE_INIT) {
-		rval = iav_drv_probe_vin_dsp_config(iav);
-		if (rval < 0)
-			goto iav_init_err;
-
-		rval = iav_restore_dsp_cmd(iav);
+		rval = iav_drv_probe_fb_data(iav);
 		if (rval < 0)
 			goto iav_init_err;
 	}
 
+	rval = iav_init_isr(iav);
+	if (rval < 0)
+		goto iav_init_err;
+
 	return 0;
 
 iav_init_err:
@@ -416,6 +492,9 @@ iav_init_err:
 	if (iav->iav_cdev.owner) {
 		iav_destroy_dev(iav);
 	}
+	if (iav->nl_obj[NL_OBJ_VSYNC].iav) {
+		iav_deinit_netlink(iav);
+	}
 	if (iav->dsp_enc_data_virt) {
 		iav_encode_exit(iav);
 	}
@@ -439,6 +518,7 @@ static int iav_drv_remove(struct ambpriv_device *ambdev)
 	iav_vin_exit(iav);
 	remove_proc_entry("iav", get_ambarella_proc_dir());
 	iav_destroy_dev(iav);
+	iav_deinit_netlink(iav);
 	iav_encode_exit(iav);
 
 	iav_unmap_dsp_partitions(iav);
@@ -451,36 +531,141 @@ static int iav_drv_remove(struct ambpriv_device *ambdev)
 }
 
 
-static struct ambpriv_device *iav_device;
+struct ambpriv_device *iav_device;
 
 
 #ifdef CONFIG_PM
+static int iav_freeze_late(struct device *dev)
+{
+	struct ambarella_iav *iav = NULL;
+
+	iav = ambpriv_get_drvdata(iav_device);
+	if (iav->dsp->freeze) {
+		iav->dsp->freeze(iav->dsp);
+	}
+	return 0;
+}
+
+static int iav_freeze_noirq(struct device *dev)
+{
+	struct ambarella_iav *iav = NULL;
+	struct iav_sync_frame_cnt * sync = NULL;
+
+	iav = ambpriv_get_drvdata(iav_device);
+	if (iav->state == IAV_STATE_PREVIEW || iav->state == IAV_STATE_ENCODING) {
+		amba_imgproc_freeze();
+	}
+	list_splice_init(&iav->frame_queue, &iav->frame_free);
+	iav->bsh = iav->bsh_virt;
+	iav->bsb_free_bytes = iav->mmap[IAV_BUFFER_BSB].size;
+	sync = &iav->frame_cnt;
+	sync->free_frame_cnt = NUM_BS_DESC;
+	sync->total_frame_cnt = 0;
+	sync->total_h264_cnt = 0;
+	sync->total_mjpeg_cnt = 0;
+	sync->curr_h264_cnt = 0;
+	sync->curr_mjpeg_cnt = 0;
+	sync->sync_delta = 0;
+
+	/* HW timer freeze */
+	hwtimer_freeze();
+
+	return 0;
+}
+
+static int iav_thaw_noirq(struct device *dev)
+{
+	struct ambarella_iav *iav = NULL;
+	struct iav_stream *stream = NULL;
+	struct iav_nl_obj * nl_obj = NULL;
+	u32 i = 0;
+
+	if (iav_device == NULL) {
+		iav_error("iav_device should not be NULL!\n");
+		return -1;
+	}
+	iav = ambpriv_get_drvdata(iav_device);
+	/* HW timer thaw with fastboot audio enabled */
+	hwtimer_thaw(1);
+	if (iav->dsp->thaw) {
+		iav->dsp->thaw(iav->dsp);
+	}
+	if (iav_drv_probe_thaw_method(iav) < 0) {
+		iav_error("iav drv probe thaw status failed!\n");
+		return -1;
+	}
+	if (likely(iav->fast_thaw)) {
+		if (iav->state == IAV_STATE_ENCODING) {
+			for (i = 0; i < IAV_MAX_ENCODE_STREAMS_NUM; i++) {
+				stream = &iav->stream[i];
+				create_session_id(stream);
+			}
+			iav_sync_bsh_queue(iav);
+		}
+	} else {
+		/* Amboot change dsp state after freeze, then need re-prase dsp status in thaw */
+		if (iav_drv_probe_status(iav) < 0) {
+			iav_error("iav drv probe status failed\n");
+		}
+		iav_drv_probe_vin_video_format(iav);
+		if (iav_drv_probe_fb_data(iav) < 0) {
+			iav_error("iav drv probe fb data failed\n");
+		}
+	}
+	if (iav->state == IAV_STATE_PREVIEW || iav->state == IAV_STATE_ENCODING) {
+		amba_imgproc_thaw();
+	}
+
+	nl_obj = &iav->nl_obj[NL_OBJ_SYS];
+	if (nl_obj->nl_connected) {
+		nl_send_notice(nl_obj, NL_NOTICE_SYS_THAW_DONE);
+	}
+
+	return 0;
+}
+
 static int iav_suspend(struct device *dev)
 {
 	struct ambarella_iav *iav = NULL;
-	struct vin_device *vdev;
+	struct vin_device *vdev = NULL;
 
 	iav = ambpriv_get_drvdata(iav_device);
 	vdev = iav->vinc[0]->dev_active;
 
-	// Imgproc suspend
-	amba_imgproc_suspend();
-	// DSP suspend
-	iav->dsp->suspend(iav->dsp);
 	if (iav->state == IAV_STATE_PREVIEW || iav->state == IAV_STATE_ENCODING) {
+		// Imgproc suspend
+		amba_imgproc_suspend(iav->encode_mode);
+	}
+
+	if (iav->dsp->suspend) {
+		// DSP suspend
+		iav->dsp->suspend(iav->dsp);
+	}
+
+	// DSP log suspends after DSP suspends
+	amba_dsplog_suspend();
+
+	if (vdev) {
 		// VIN suspend
 		vin_pm_suspend(vdev);
+	}
+	if (iav->state == IAV_STATE_PREVIEW || iav->state == IAV_STATE_ENCODING) {
 		// Vout Suspend
 		amba_vout_pm(AMBA_EVENT_PRE_PM);
 	}
+
+	hwtimer_suspend();
+
 	return 0;
 }
 
 static int iav_resume(struct device *dev)
 {
 	struct ambarella_iav *iav = NULL;
-	struct vin_device *vdev;
+	struct vin_device *vdev = NULL;
 	u32 stream_map = 0;
+	int i = 0;
+	int max_enc_stream_num = 0;
 
 	if (iav_device == NULL) {
 		iav_error("iav_device should not be NULL!\n");
@@ -490,15 +675,31 @@ static int iav_resume(struct device *dev)
 	iav = ambpriv_get_drvdata(iav_device);
 	vdev = iav->vinc[0]->dev_active;
 
+	hwtimer_resume();
 	if (iav->state == IAV_STATE_PREVIEW || iav->state == IAV_STATE_ENCODING) {
 		// Vout resume
 		amba_vout_pm(AMBA_EVENT_POST_PM);
+	}
+	if (vdev) {
 		// VIN resume
 		vin_pm_resume(vdev);
 	}
-	// DSP resume
-	iav->dsp->resume(iav->dsp);
+
+	// DSP log resumes before DSP resumes
+	amba_dsplog_resume();
+	// set DSP debug level last sent before suspending
+	if (iav->dsplog_setup.args[1]) {
+		iav_set_dsplog_debug_level(iav, &iav->dsplog_setup);
+	}
+
+	if (iav->dsp->resume) {
+		// DSP resume
+		iav->dsp->resume(iav->dsp);
+	}
+
 	// IAV resume
+	iav->resume_flag = 1;
+	iav->fast_resume = 1;
 	if (iav->dsp_enc_state == DSP_ENCODE_MODE) {
 		switch (iav->state) {
 		case IAV_STATE_IDLE:
@@ -510,10 +711,14 @@ static int iav_resume(struct device *dev)
 			iav->state = IAV_STATE_INIT;
 			iav->dsp_enc_state = DSP_UNKNOWN_MODE;
 			iav_boot_dsp_action(iav);
-			iav_enable_preview(iav, 1);
+			iav_enable_preview(iav);
 			iav->state = IAV_STATE_PREVIEW;
-			amba_imgproc_resume(iav->encode_mode,
-				iav->system_config[iav->encode_mode].expo_num);
+			amba_imgproc_resume(iav->encode_mode, iav->fast_resume);
+			if (iav->pm.enable) {
+				iav_pm_resume(iav, 1);
+			}
+			// wait one vsync to let DSP process 3A cmds last sent
+			wait_vcap_count(iav, 1);
 			break;
 		case IAV_STATE_ENCODING:
 			iav->state = IAV_STATE_INIT;
@@ -521,20 +726,42 @@ static int iav_resume(struct device *dev)
 			stream_map = iav_get_stream_map(iav);
 			iav_clear_stream_state(iav);
 			iav_boot_dsp_action(iav);
-			iav_enable_preview(iav, 1);
+			iav_enable_preview(iav);
 			iav->state = IAV_STATE_PREVIEW;
-			amba_imgproc_resume(iav->encode_mode,
-				iav->system_config[iav->encode_mode].expo_num);
+			amba_imgproc_resume(iav->encode_mode, iav->fast_resume);
+			if (iav->pm.enable) {
+				iav_pm_resume(iav, 0);
+			}
+			max_enc_stream_num = iav->system_config[iav->encode_mode].max_stream_num;
+			for (i = 0; i < max_enc_stream_num; i++) {
+				if (iav->stream[i].osd.enable) {
+					iav_overlay_resume(iav, &iav->stream[i]);
+				}
+			}
 			iav_ioc_start_encode(iav, (void __user *)stream_map);
+			// wait one vsync to let DSP process 3A cmds last sent
+			wait_vcap_count(iav, 1);
 			break;
 		default:
 			break;
 		}
 	}
+	iav->resume_flag = 0;
+	iav->fast_resume = 0;
 
 	return 0;
 }
-static SIMPLE_DEV_PM_OPS(iav_pm_ops, iav_suspend, iav_resume);
+
+static const struct dev_pm_ops iav_pm_ops = {
+	/* DRAM Self Refresh */
+	.suspend = iav_suspend,
+	.resume = iav_resume,
+
+	/* Hibernation */
+	.freeze_late = iav_freeze_late,
+	.freeze_noirq = iav_freeze_noirq,
+	.thaw_noirq = iav_thaw_noirq,
+};
 #endif
 
 static struct ambpriv_driver iav_driver = {
diff --git a/drivers/iav/arch_s2l/iav_dsp_cmd.c b/drivers/iav/arch_s2l/iav_dsp_cmd.c
index 3a84e16..c5ad45a 100644
--- a/drivers/iav/arch_s2l/iav_dsp_cmd.c
+++ b/drivers/iav/arch_s2l/iav_dsp_cmd.c
@@ -4,15 +4,34 @@
  * History:
  *	2013/08/28 - [Cao Rongrong] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #include <plat/ambcache.h>
 #include <iav_utils.h>
 #include <iav_ioctl.h>
@@ -53,13 +72,15 @@ static inline void *get_cmd(struct dsp_device *dsp, struct amb_dsp_cmd *cmd)
 }
 
 static inline void put_cmd(struct dsp_device *dsp, struct amb_dsp_cmd *cmd,
-	void *dsp_cmd, int cmd_type, u32 cmd_delay)
+	void *dsp_cmd, int cmd_type, int cmd_keep_latest, u32 cmd_delay)
 {
 	if (likely(cmd)) {
 		cmd->cmd_type = cmd_type;
+		cmd->keep_latest = cmd_keep_latest;
 	} else {
 		cmd = container_of(dsp_cmd, struct amb_dsp_cmd, dsp_cmd);
 		cmd->cmd_type = cmd_type;
+		cmd->keep_latest = cmd_keep_latest;
 		dsp->put_cmd(dsp, cmd, cmd_delay);
 	}
 }
@@ -290,10 +311,19 @@ static inline int calc_frame_rate(struct ambarella_iav *iav,
 		custom_encoder_frame_rate = 3750;
 		break;
 	default:
-		custom_encoder_frame_rate = DIV_ROUND_CLOSEST(512000000,
-			(idsp_out_frame_rate / 1000));
+		/* If fps >= 10, only the round number is kept,
+		 * otherwise, the decimal part is also kept.
+		 */
+		if (idsp_out_frame_rate <= AMBA_VIDEO_FPS_10) {
+			custom_encoder_frame_rate = DIV_ROUND_CLOSEST(512000000,
+				idsp_out_frame_rate) * 1000;
+		} else {
+			custom_encoder_frame_rate = DIV_ROUND_CLOSEST(512000000,
+				(idsp_out_frame_rate / 1000));
+		}
 		break;
 	}
+
 	custom_encoder_frame_rate = custom_encoder_frame_rate *
 		multiplication_factor / division_factor;
 	*dsp_out_frame_rate = (0 |
@@ -402,21 +432,7 @@ static int get_gop_struct_from_quailty(struct iav_h264_config *h264_config, int
 	return 0;
 }
 
-static u32 get_dsp_encode_bitrate(struct iav_stream *stream)
-{
-	u32 ff_multi = stream->fps.fps_multi;
-	u32 ff_division = stream->fps.fps_div;
-	u32 full_bitrate = stream->h264_config.average_bitrate;
-	u32 bitrate = 0;
-
-	if (ff_division) {
-		bitrate =  full_bitrate * ff_multi / ff_division;
-	}
-
-	return bitrate;
-}
-
-inline void get_round_encode_format(struct iav_stream *stream,
+static inline void get_round_encode_format(struct iav_stream *stream,
 	u16* width, u16* height, s16* offset_y_shift)
 {
 	struct iav_stream_format *format = &stream->format;
@@ -486,6 +502,7 @@ static inline preview_type_t buffer_format_to_preview_type(u32 type, u16 width)
 		preview_type = OFF_PREVIEW_TYPE;
 		break;
 	case IAV_SRCBUF_TYPE_ENCODE:
+	case IAV_SRCBUF_TYPE_VCA:
 		preview_type = CAPTURE_PREVIEW_TYPE;
 		break;
 	case IAV_SRCBUF_TYPE_PREVIEW:
@@ -537,7 +554,7 @@ static u32 is_h264_frame_num_gap_allowed(struct iav_stream *stream)
 	case IAV_GOP_LT_REF_P:
 		// 2 ref without fast seek
 		if ((h264_cfg->multi_ref_p == 1) &&
-			(h264_cfg->long_term_intvl == 0 || h264_cfg->long_term_intvl == 63)) {
+			(h264_cfg->fast_seek_intvl == 0 || h264_cfg->fast_seek_intvl == 63)) {
 			allow_flag = 0;
 		} else {
 			allow_flag = 1;
@@ -551,23 +568,6 @@ static u32 is_h264_frame_num_gap_allowed(struct iav_stream *stream)
 	return allow_flag;
 }
 
-
-int cmd_chip_selection(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd)
-{
-	chip_select_t *dsp_cmd;
-
-	dsp_cmd = get_cmd(iav->dsp, cmd);
-	if (!dsp_cmd)
-		return -ENOMEM;
-
-	dsp_cmd->cmd_code = CHIP_SELECTION;
-	dsp_cmd->chip_type = 3;	// A5
-
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0);
-
-	return 0;
-}
-
 int cmd_vin_timer_mode(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd)
 {
 	vin_timer_mode_t *dsp_cmd;
@@ -579,7 +579,7 @@ int cmd_vin_timer_mode(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd)
 	dsp_cmd->cmd_code = H264_ENC_USE_TIMER;
 	dsp_cmd->timer_scaler = 0;
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0, 0);
 
 	return 0;
 }
@@ -599,7 +599,11 @@ int cmd_set_warp_control(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd)
 	if (!dsp_cmd)
 		return -ENOMEM;
 
-	iav->curr_warp_index = iav->next_warp_index + UWARP_NUM;
+	if (unlikely(iav->resume_flag)) {
+		iav->curr_warp_index = iav->next_warp_index;
+	} else {
+		iav->curr_warp_index = iav->next_warp_index + UWARP_NUM;
+	}
 
 	dsp_cmd->cmd_code = SET_WARP_CONTROL;
 
@@ -695,11 +699,13 @@ int cmd_set_warp_control(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd)
 	dsp_cmd->actual_right_bot_x = (crop_w << 16);
 	dsp_cmd->actual_right_bot_y = (crop_h << 16);
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0);
-
-	//update warp index
-	iav->next_warp_index = (iav->next_warp_index + 1) % IAV_PARTITION_TOGGLE_NUM;
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 1, 0);
 
+	if (likely(!iav->resume_flag)) {
+		//update warp index
+		iav->next_warp_index =
+			(iav->next_warp_index + 1) % IAV_PARTITION_TOGGLE_NUM;
+	}
 	return 0;
 }
 
@@ -722,7 +728,7 @@ int cmd_system_info_setup(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd,
 	if (unlikely(decode_flag)) {
 		dsp_cmd->audio_clk_freq = 12288000;
 		dsp_cmd->idsp_freq = 216000000;
-		put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_DEC, 0);
+		put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_DEC, 0, 0);
 	} else {
 		enc_mode = iav->encode_mode;
 		dsp_cmd->mode_flags = enc_mode;
@@ -750,6 +756,7 @@ int cmd_system_info_setup(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd,
 		dsp_cmd->voutA_osd_blend_enabled = iav->osd_from_mixer_a;
 		dsp_cmd->voutB_osd_blend_enabled = iav->osd_from_mixer_b;
 		dsp_cmd->audio_clk_freq = 0;
+		dsp_cmd->vin_overflow_protection = iav->vin_overflow_protection;
 		/* both RGB and YUV raw */
 		dsp_cmd->raw_encode_enabled = (config->enc_raw_rgb || config->enc_raw_yuv);
 
@@ -774,7 +781,7 @@ int cmd_system_info_setup(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd,
 
 		dsp_cmd->core_freq = (u32)clk_get_rate(clk_get(NULL, "gclk_core"));
 
-		put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0);
+		put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0, 0);
 	}
 
 	return 0;
@@ -811,7 +818,7 @@ int cmd_set_vin_global_config(struct ambarella_iav *iav,
 		break;
 	}
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0, 0);
 
 	return 0;
 }
@@ -830,7 +837,7 @@ int cmd_set_vin_master_config(struct ambarella_iav *iav,
 	memcpy(&dsp_cmd->master_sync_reg_word0,
 		iav->vinc[0]->master_config, sizeof(struct vin_master_config));
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0, 0);
 
 	return 0;
 }
@@ -853,7 +860,7 @@ int cmd_set_vin_config(struct ambarella_iav *iav,
 #else
 	dsp_cmd->cmd_code = SET_VIN_CONFIG;
 #endif
-	get_vin_win(iav, &vin_win, 1);
+	get_vin_win(iav, &vin_win, 0);
 	dsp_cmd->vin_width = vin_win->width;
 	dsp_cmd->vin_height = vin_win->height;
 	dsp_cmd->vin_config_dram_addr = VIRT_TO_DSP(iav->vinc[0]->dsp_config);
@@ -863,7 +870,7 @@ int cmd_set_vin_config(struct ambarella_iav *iav,
 
 	clean_d_cache(iav->vinc[0]->dsp_config, sizeof(struct vin_dsp_config));
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0, 0);
 
 	return 0;
 }
@@ -889,7 +896,7 @@ int cmd_raw_encode_video_setup(struct ambarella_iav *iav,
 	dsp_cmd->dpitch = iav->raw_enc.pitch;
 	dsp_cmd->num_frames = iav->raw_enc.raw_frame_num;
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0, 0);
 
 	return 0;
 }
@@ -981,8 +988,8 @@ int cmd_video_preproc(struct ambarella_iav *iav,
 		width = vout1_info->width;
 		height = vout1_info->height;
 	}
-	dsp_cmd->preview_w_B = vout1_info->width;
-	dsp_cmd->preview_h_B = vout1_info->height;
+	dsp_cmd->preview_w_B = width;
+	dsp_cmd->preview_h_B = height;
 	dsp_cmd->preview_format_B = amba_iav_format_to_format(vout1_info->format);
 	dsp_cmd->preview_frame_rate_B = amba_iav_fps_to_fps(vout1_info->fps);
 	dsp_cmd->preview_B_en = vout_swap ?
@@ -1015,7 +1022,7 @@ int cmd_video_preproc(struct ambarella_iav *iav,
 #else
 	dsp_cmd->cmdReadDly = 0;
 #endif
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0, 0);
 
 	return 0;
 }
@@ -1047,7 +1054,7 @@ int cmd_sensor_config(struct ambarella_iav *iav,
 	dsp_cmd->first_line_field_7 = 0;
 	dsp_cmd->sensor_readout_mode = 0;
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0, 0);
 
 	return 0;
 }
@@ -1056,7 +1063,7 @@ int cmd_video_system_setup(struct ambarella_iav *iav,
 		struct amb_dsp_cmd *cmd)
 {
 	ipcam_video_system_setup_t *dsp_cmd = NULL;
-	u16 max_w, max_h;
+	u16 max_w, max_h, i;
 	int enc_mode = iav->encode_mode;
 	struct amba_video_info *vout0_info = NULL, *vout1_info = NULL;
 	struct iav_buffer *buffer = NULL;
@@ -1118,6 +1125,7 @@ int cmd_video_system_setup(struct ambarella_iav *iav,
 		max_w = max_h = 0;
 		break;
 	case IAV_SRCBUF_TYPE_ENCODE:
+	case IAV_SRCBUF_TYPE_VCA:
 		max_win = &buffer->max;
 		calc_roundup_size(max_win->width, max_win->height,
 			IAV_STREAM_TYPE_H264, 0, &max_w, &max_h);
@@ -1136,6 +1144,7 @@ int cmd_video_system_setup(struct ambarella_iav *iav,
 		max_w = max_h = 0;
 		break;
 	case IAV_SRCBUF_TYPE_ENCODE:
+	case IAV_SRCBUF_TYPE_VCA:
 		max_win = &buffer->max;
 		calc_roundup_size(max_win->width, max_win->height,
 			IAV_STREAM_TYPE_H264, 0, &max_w, &max_h);
@@ -1163,6 +1172,7 @@ int cmd_video_system_setup(struct ambarella_iav *iav,
 		max_w = max_h = 0;
 		break;
 	case IAV_SRCBUF_TYPE_ENCODE:
+	case IAV_SRCBUF_TYPE_VCA:
 		max_win = &buffer->max;
 		calc_roundup_size(max_win->width, max_win->height,
 			IAV_STREAM_TYPE_H264, 0, &max_w, &max_h);
@@ -1234,6 +1244,18 @@ int cmd_video_system_setup(struct ambarella_iav *iav,
 	dsp_cmd->stream_2_LT_enable = iav->stream[2].long_ref_enable;
 	dsp_cmd->stream_3_LT_enable = iav->stream[3].long_ref_enable;
 
+	dsp_cmd->B_frame_enable_in_LT_gop = config->long_ref_b_frame;
+
+	for (i = IAV_SRCBUF_FIRST; i < IAV_SRCBUF_LAST; ++i) {
+		buffer = &iav->srcbuf[i];
+		if (buffer->type == IAV_SRCBUF_TYPE_VCA) {
+			dsp_cmd->vca_preview_id = iav->srcbuf[i].id_dsp;
+			dsp_cmd->vca_frame_num = iav->srcbuf[i].dump_duration;
+			dsp_cmd->vca_daddr_base = PHYS_TO_DSP(iav->mmap[IAV_BUFFER_VCA].phys);
+			dsp_cmd->vca_daddr_size = iav->mmap[IAV_BUFFER_VCA].size;
+		}
+	}
+
 	/* Add 16 lines more to avoid roundup issue in dewarp mode.
 		It's to fix the 16 lines alignment for each warp region.
 	*/
@@ -1249,7 +1271,9 @@ int cmd_video_system_setup(struct ambarella_iav *iav,
 		}
 	}
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0);
+	dsp_cmd->enc_buf_extra_MB_row_at_top = config->extra_top_row_buf_enable;
+
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0, 0);
 
 	return 0;
 }
@@ -1277,7 +1301,7 @@ int cmd_capture_buffer_default_setup(struct ambarella_iav *iav,
 	dsp_cmd->input_win_offset_x = 0;
 	dsp_cmd->input_win_offset_y = 0;
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0, 0);
 
 	return 0;
 }
@@ -1298,10 +1322,13 @@ int cmd_capture_buffer_setup(struct ambarella_iav *iav,
 	dsp_cmd->cmd_code = IPCAM_VIDEO_CAPTURE_PREVIEW_SIZE_SETUP;
 
 	dsp_cmd->preview_id = buffer->id_dsp;
-	if (buffer->win.width == 0 && buffer->win.height == 0) {
+	if (buffer->win.width == 0 || buffer->win.height == 0) {
 		dsp_cmd->disabled = 1;
-		dsp_cmd->cap_width = buffer->max.width;
-		dsp_cmd->cap_height = buffer->max.height;
+		/* avoid w / h upsampling for sub buffer when it is disabled. */
+		dsp_cmd->cap_width = (buffer->max.width > buffer->input.width) ?
+			buffer->input.width : buffer->max.width;
+		dsp_cmd->cap_height = (buffer->max.height > buffer->input.height) ?
+			buffer->input.height : buffer->max.height;
 	} else {
 		dsp_cmd->disabled = 0;
 		dsp_cmd->cap_width = buffer->win.width;
@@ -1313,8 +1340,11 @@ int cmd_capture_buffer_setup(struct ambarella_iav *iav,
 	dsp_cmd->input_win_height = buffer->input.height;
 	dsp_cmd->input_win_offset_x = buffer->input.x;
 	dsp_cmd->input_win_offset_y = buffer->input.y;
+	if (buffer->type == IAV_SRCBUF_TYPE_VCA) {
+		dsp_cmd->skip_interval = buffer->dump_interval - 1;
+	}
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0, 0);
 
 	return 0;
 }
@@ -1333,7 +1363,7 @@ int cmd_encode_size_setup(struct iav_stream *stream, struct amb_dsp_cmd *cmd)
 		return -ENOMEM;
 
 	dsp_cmd->cmd_code = GET_DSP_CMD_CODE(IPCAM_VIDEO_ENCODE_SIZE_SETUP,
-		stream->format.id);
+		stream->id_dsp);
 
 	if (stream->iav->encode_mode == DSP_MULTI_REGION_WARP_MODE) {
 		switch (format->buf_id) {
@@ -1360,7 +1390,7 @@ int cmd_encode_size_setup(struct iav_stream *stream, struct amb_dsp_cmd *cmd)
 	dsp_cmd->enc_x = format->enc_win.x;
 	dsp_cmd->enc_y = format->enc_win.y + offset_y;
 
-	put_cmd(stream->iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_ENC, 0);
+	put_cmd(stream->iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_ENC, 0, 0);
 
 	return 0;
 }
@@ -1373,6 +1403,8 @@ int cmd_h264_encode_setup(struct iav_stream *stream, struct amb_dsp_cmd *cmd)
 	struct iav_h264_config *h264_config;
 	struct iav_vin_format *vin_format;
 	struct iav_stream_format *stream_format;
+	struct iav_mv_dump mv_dump;
+	struct iav_window win;
 	u32 encoder_frame_rate;
 
 	dsp_cmd = get_cmd(stream->iav->dsp, cmd);
@@ -1384,7 +1416,7 @@ int cmd_h264_encode_setup(struct iav_stream *stream, struct amb_dsp_cmd *cmd)
 	vin_format = &iav->vinc[0]->vin_format;
 
 	dsp_cmd->cmd_code = GET_DSP_CMD_CODE(H264_ENCODING_SETUP,
-		stream->format.id);
+		stream->id_dsp);
 
 	dsp_cmd->mode = 1;
 	dsp_cmd->M = h264_config->M;
@@ -1427,9 +1459,23 @@ int cmd_h264_encode_setup(struct iav_stream *stream, struct amb_dsp_cmd *cmd)
 	dsp_cmd->fast_rc_idc = h264_config->fast_rc_idc;
 	dsp_cmd->cpb_user_size = h264_config->cpb_user_size;
 
-	dsp_cmd->fast_seek_interval = h264_config->long_term_intvl;
+	dsp_cmd->fast_seek_interval = h264_config->fast_seek_intvl;
 
-	put_cmd(stream->iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_ENC, 0);
+	if (iav->mmap[IAV_BUFFER_MV].size > 0) {
+		get_stream_win_MB(stream_format, &win);
+		mv_dump.width = win.width;
+		mv_dump.height = win.height;
+		mv_dump.pitch = ALIGN(mv_dump.width * sizeof(struct iav_mv), 32);
+		mv_dump.unit_size = mv_dump.pitch * mv_dump.height;
+		mv_dump.buf_num = iav->mmap[IAV_BUFFER_MV].size / mv_dump.unit_size;
+		dsp_cmd->mvdump_daddr = PHYS_TO_DSP(iav->mmap[IAV_BUFFER_MV].phys);
+		dsp_cmd->mvdump_dpitch = mv_dump.pitch;
+		dsp_cmd->mvdump_fifo_unit_sz = mv_dump.unit_size;
+		dsp_cmd->mvdump_fifo_limit = dsp_cmd->mvdump_daddr +
+			mv_dump.buf_num * mv_dump.unit_size - 1;
+	}
+
+	put_cmd(stream->iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_ENC, 0, 0);
 
 	return 0;
 }
@@ -1451,7 +1497,7 @@ int cmd_h264_encode_start(struct iav_stream *stream, struct amb_dsp_cmd *cmd)
 	if (!dsp_cmd)
 		return -ENOMEM;
 
-	dsp_cmd->cmd_code = GET_DSP_CMD_CODE(H264_ENCODE, stream->format.id);
+	dsp_cmd->cmd_code = GET_DSP_CMD_CODE(H264_ENCODE, stream->id_dsp);
 	dsp_cmd->start_encode_frame_no = 0xffffffff;
 	dsp_cmd->encode_duration = (stream->format.duration ?
 		stream->format.duration : ENCODE_DURATION_FOREVER);
@@ -1459,10 +1505,12 @@ int cmd_h264_encode_start(struct iav_stream *stream, struct amb_dsp_cmd *cmd)
 	dsp_cmd->enable_slow_shutter = 0;
 	dsp_cmd->res_rate_min = 40;
 
-	dsp_cmd->en_loop_filter = 2;
 	dsp_cmd->max_upsampling_rate = 1;
 	dsp_cmd->slow_shutter_upsampling_rate = 0;
 	dsp_cmd->au_type = h264_config->au_type;
+	dsp_cmd->alpha = h264_config->deblocking_filter_alpha;
+	dsp_cmd->beta = h264_config->deblocking_filter_beta;
+	dsp_cmd->en_loop_filter = h264_config->deblocking_filter_enable;
 	dsp_cmd->gaps_in_frame_num_value_allowed_flag =
 		is_h264_frame_num_gap_allowed(stream);
 
@@ -1477,6 +1525,19 @@ int cmd_h264_encode_start(struct iav_stream *stream, struct amb_dsp_cmd *cmd)
 		dsp_cmd->video_signal_type_present_flag = 1;
 		dsp_cmd->video_full_range_flag = 1;
 		dsp_cmd->video_format = 5;
+
+		dsp_cmd->custom_bitstream_restriction_cfg = 0;
+		dsp_cmd->bitstream_restriction_flag = 0;
+		/* bitstream restriction */
+		{
+			dsp_cmd->motion_vectors_over_pic_boundaries_flag = 0;
+			dsp_cmd->max_bytes_per_pic_denom = 0;
+			dsp_cmd->max_bits_per_mb_denom = 0;
+			dsp_cmd->log2_max_mv_length_horizontal = 0;
+			dsp_cmd->log2_max_mv_length_vertical = 0;
+			dsp_cmd->num_reorder_frames = 0;
+			dsp_cmd->max_dec_frame_buffering = 0;
+		}
 	}
 
 	/* color primaries */
@@ -1501,9 +1562,10 @@ int cmd_h264_encode_start(struct iav_stream *stream, struct amb_dsp_cmd *cmd)
 		round_factor = is_vcap_interlaced(stream->iav, 0) ?
 			(PIXEL_IN_MB << 1) : PIXEL_IN_MB;
 		dsp_cmd->frame_cropping_flag = 1;
-		dsp_cmd->frame_crop_left_offset = 0;
-		dsp_cmd->frame_crop_right_offset = 0;
-		dsp_cmd->frame_crop_top_offset = 0;
+		dsp_cmd->frame_crop_left_offset = stream->h264_config.frame_crop_left_offset >> 1;
+		dsp_cmd->frame_crop_right_offset = stream->h264_config.frame_crop_right_offset >> 1;
+		dsp_cmd->frame_crop_top_offset = stream->h264_config.frame_crop_top_offset >> 1;
+		dsp_cmd->frame_crop_bottom_offset = stream->h264_config.frame_crop_bottom_offset >> 1;
 		round_height = ALIGN(stream_height, round_factor);
 		margin = round_height - stream_height;
 		if (is_vcap_interlaced(stream->iav, 0))
@@ -1515,12 +1577,12 @@ int cmd_h264_encode_start(struct iav_stream *stream, struct amb_dsp_cmd *cmd)
 			/* Use minus height offset to compensate left cropping flag, so use
 			 * right cropping flag all the time.
 			 */
-			dsp_cmd->frame_crop_right_offset = margin;
+			dsp_cmd->frame_crop_right_offset += margin;
 		} else {
 			/* Use minus height offset to compensate top cropping flag, so
 			 * use bottom cropping flag all the time.
 			 */
-			dsp_cmd->frame_crop_bottom_offset = margin;
+			dsp_cmd->frame_crop_bottom_offset += margin;
 		}
 	}
 
@@ -1581,7 +1643,7 @@ int cmd_h264_encode_start(struct iav_stream *stream, struct amb_dsp_cmd *cmd)
 		}
 	}
 
-	put_cmd(stream->iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_ENC, 0);
+	put_cmd(stream->iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_ENC, 0, 0);
 
 	return 0;
 }
@@ -1594,11 +1656,11 @@ int cmd_encode_stop(struct iav_stream *stream, struct amb_dsp_cmd *cmd)
 	if (!dsp_cmd)
 		return -ENOMEM;
 
-	dsp_cmd->cmd_code = GET_DSP_CMD_CODE(ENCODING_STOP, stream->format.id);
+	dsp_cmd->cmd_code = GET_DSP_CMD_CODE(ENCODING_STOP, stream->id_dsp);
 	// Stop on next P or I picture after stop command has been received.
 	dsp_cmd->stop_method = H264_STOP_ON_NEXT_IP;
 
-	put_cmd(stream->iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_ENC, 0);
+	put_cmd(stream->iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_ENC, 0, 0);
 
 	return 0;
 }
@@ -1622,12 +1684,12 @@ int cmd_jpeg_encode_setup(struct iav_stream *stream, struct amb_dsp_cmd *cmd)
 		return -ENOMEM;
 
 	dsp_cmd->cmd_code = GET_DSP_CMD_CODE(JPEG_ENCODING_SETUP,
-		stream->format.id);
+		stream->id_dsp);
 
 	dsp_cmd->chroma_format = mjpeg_config->chroma_format;
 	dsp_cmd->is_mjpeg = 1;
 
-	init_stream_jpeg_dqt(iav, stream->format.id, mjpeg_config->quality);
+	init_stream_jpeg_dqt(iav, stream->id_dsp, mjpeg_config->quality);
 	offset = (u32)mjpeg_config->jpeg_quant_matrix -
 		iav->mmap[IAV_BUFFER_QUANT].virt;
 	dsp_cmd->quant_matrix_addr =
@@ -1648,7 +1710,7 @@ int cmd_jpeg_encode_setup(struct iav_stream *stream, struct amb_dsp_cmd *cmd)
 	dsp_cmd->vflip = stream_format->vflip;
 	dsp_cmd->rotate = stream_format->rotate_cw;
 
-	put_cmd(stream->iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_ENC, 0);
+	put_cmd(stream->iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_ENC, 0, 0);
 
 	return 0;
 }
@@ -1661,12 +1723,12 @@ int cmd_jpeg_encode_start(struct iav_stream *stream, struct amb_dsp_cmd *cmd)
 	if (!dsp_cmd)
 		return -ENOMEM;
 
-	dsp_cmd->cmd_code = GET_DSP_CMD_CODE(MJPEG_ENCODE, stream->format.id);
+	dsp_cmd->cmd_code = GET_DSP_CMD_CODE(MJPEG_ENCODE, stream->id_dsp);
 	dsp_cmd->start_encode_frame_no = -1;
 	dsp_cmd->encode_duration = (stream->format.duration ?
 		stream->format.duration : ENCODE_DURATION_FOREVER);
 
-	put_cmd(stream->iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_ENC, 0);
+	put_cmd(stream->iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_ENC, 0, 0);
 
 	return 0;
 }
@@ -1682,6 +1744,7 @@ int cmd_update_encode_params(struct iav_stream *stream,
 	struct iav_vin_format *vin_format;
 	u32 dsp_vin_fps, dsp_encoder_fps, i, offset;
 	u32 idsp_out_frame_rate = 0;
+	u8 ff_m = 1, ff_n = 1;
 
 	dsp_cmd = get_cmd(iav->dsp, cmd);
 	if (!dsp_cmd)
@@ -1692,7 +1755,7 @@ int cmd_update_encode_params(struct iav_stream *stream,
 	vin_format = &iav->vinc[0]->vin_format;
 
 	dsp_cmd->cmd_code = GET_DSP_CMD_CODE(
-		IPCAM_REAL_TIME_ENCODE_PARAM_SETUP, stream->format.id);
+		IPCAM_REAL_TIME_ENCODE_PARAM_SETUP, stream->id_dsp);
 
 	if (flags & REALTIME_PARAM_CBR_MODIFY_BIT) {
 		dsp_cmd->enable_flags |= REALTIME_PARAM_CBR_MODIFY_BIT;
@@ -1717,13 +1780,19 @@ int cmd_update_encode_params(struct iav_stream *stream,
 		dsp_cmd->qp_max_on_I = h264_config->qp_max_on_I;
 		dsp_cmd->qp_max_on_P = h264_config->qp_max_on_P;
 		dsp_cmd->qp_max_on_B = h264_config->qp_max_on_B;
+		dsp_cmd->qp_max_on_Q = h264_config->qp_max_on_Q;
 		dsp_cmd->qp_min_on_I = h264_config->qp_min_on_I;
 		dsp_cmd->qp_min_on_P = h264_config->qp_min_on_P;
 		dsp_cmd->qp_min_on_B = h264_config->qp_min_on_B;
+		dsp_cmd->qp_min_on_Q = h264_config->qp_min_on_Q;
 		dsp_cmd->aqp = h264_config->adapt_qp;
 		dsp_cmd->i_qp_reduce = h264_config->i_qp_reduce;
 		dsp_cmd->p_qp_reduce = h264_config->p_qp_reduce;
+		dsp_cmd->q_qp_reduce = h264_config->q_qp_reduce;
+		dsp_cmd->log_q_num_per_gop_plus_1 = h264_config->log_q_num_plus_1;
 		dsp_cmd->skip_flags = h264_config->skip_flag;
+		/* convert from KB to bits */
+		dsp_cmd->set_I_size = h264_config->max_I_size_KB << 13;
 	}
 	if (flags & REALTIME_PARAM_GOP_BIT) {
 		dsp_cmd->enable_flags |= REALTIME_PARAM_GOP_BIT;
@@ -1735,7 +1804,7 @@ int cmd_update_encode_params(struct iav_stream *stream,
 		dsp_cmd->enable_flags |= REALTIME_PARAM_CUSTOM_VIN_FPS_BIT;
 		if (calc_frame_rate(iav,
 			0, 0, 1, 1, &dsp_vin_fps, FRAME_RATE_SRC_VIN) < 0) {
-			iav_error("frame rate calculation for realtime encode param"
+			iav_error("frame rate calculation for realtime encode param "
 				"update failed, frame rate 0x%x.\n",
 				vin_format->frame_rate);
 			return -EINVAL;
@@ -1744,15 +1813,14 @@ int cmd_update_encode_params(struct iav_stream *stream,
 		if (iav_vin_get_idsp_frame_rate(iav, &idsp_out_frame_rate) < 0) {
 			return -EINVAL;
 		}
-		dsp_cmd->idsp_frame_rate_M = (u8)DIV_ROUND_CLOSEST(FPS_Q9_BASE,
-			idsp_out_frame_rate);
-		dsp_cmd->idsp_frame_rate_N = (u8)DIV_ROUND_CLOSEST(FPS_Q9_BASE,
-			iav->vinc[0]->vin_format.frame_rate);
-		if (check_idsp_upsample_factor(dsp_cmd->idsp_frame_rate_M,
-			dsp_cmd->idsp_frame_rate_N) < 0) {
+		ff_m = (u8)DIV_ROUND_CLOSEST(FPS_Q9_BASE, idsp_out_frame_rate);
+		ff_n = (u8)DIV_ROUND_CLOSEST(FPS_Q9_BASE, vin_format->frame_rate);
+		if (check_idsp_upsample_factor(ff_m, ff_n) < 0) {
 			iav_error("IDSP multiplication_factor can not be smaller than division_factor!\n");
 			return -EINVAL;
 		}
+		dsp_cmd->idsp_frame_rate_M = ff_m;
+		dsp_cmd->idsp_frame_rate_N = ff_n;
 	}
 	if (flags & REALTIME_PARAM_INTRA_MB_ROWS_BIT) {
 		dsp_cmd->enable_flags |= REALTIME_PARAM_INTRA_MB_ROWS_BIT;
@@ -1767,8 +1835,8 @@ int cmd_update_encode_params(struct iav_stream *stream,
 		if (h264_config->qp_roi_enable) {
 			dsp_cmd->roi_daddr = PHYS_TO_DSP(
 				iav->mmap[IAV_BUFFER_QPMATRIX].phys +
-				stream->format.id * STREAM_QP_MATRIX_SIZE);
-#ifdef CONFIG_AMBARELLA_IAV_QP_OFFSET_IPB
+				stream->id_dsp * STREAM_QP_MATRIX_SIZE);
+#ifdef CONFIG_AMBARELLA_IAV_ROI_IPB
 			dsp_cmd->roi_daddr_p = dsp_cmd->roi_daddr + SINGLE_QP_MATRIX_SIZE;
 			dsp_cmd->roi_daddr_b = dsp_cmd->roi_daddr_p + SINGLE_QP_MATRIX_SIZE;
 #else
@@ -1799,7 +1867,7 @@ int cmd_update_encode_params(struct iav_stream *stream,
 	}
 	if (flags & REALTIME_PARAM_QUANT_MATRIX_BIT) {
 		dsp_cmd->enable_flags |= REALTIME_PARAM_QUANT_MATRIX_BIT;
-		init_stream_jpeg_dqt(iav, stream->format.id,
+		init_stream_jpeg_dqt(iav, stream->id_dsp,
 			mjpeg_config->quality);
 		offset = (u32)mjpeg_config->jpeg_quant_matrix -
 			iav->mmap[IAV_BUFFER_QUANT].virt;
@@ -1829,7 +1897,7 @@ int cmd_update_encode_params(struct iav_stream *stream,
 	}
 	if (flags & REALTIME_PARAM_FLAT_AREA_BIT) {
 		dsp_cmd->enable_flags |= REALTIME_PARAM_FLAT_AREA_BIT;
-		dsp_cmd->flat_area_improvement_on = h264_config->enc_improve;
+		dsp_cmd->flat_area_improvement_on = h264_config->flat_area_improve;
 	}
 	if (flags & REALTIME_PARAM_FORCE_FAST_SEEK_BIT) {
 		dsp_cmd->enable_flags |= REALTIME_PARAM_FORCE_FAST_SEEK_BIT;
@@ -1837,67 +1905,80 @@ int cmd_update_encode_params(struct iav_stream *stream,
 	if (flags & REALTIME_PARAM_FRAME_DROP_BIT) {
 		dsp_cmd->enable_flags |= REALTIME_PARAM_FRAME_DROP_BIT;
 		dsp_cmd->drop_frame = h264_config->drop_frames;
+		dsp_cmd->drop_frame_repeat = h264_config->drop_frame_repeat;
+	}
+	if (flags & REALTIME_PARAM_MV_DUMP_BIT) {
+		dsp_cmd->enable_flags |= REALTIME_PARAM_MV_DUMP_BIT;
+		dsp_cmd->mvdump_enable = h264_config->statis;
+	}
+	if (flags & REALTIME_PARAM_LONG_REF_P_BIT) {
+		dsp_cmd->enable_flags |= REALTIME_PARAM_LONG_REF_P_BIT;
+	}
+	if (flags & REALTIME_PARAM_FORCE_PSKIP_BIT) {
+		dsp_cmd->enable_flags |= REALTIME_PARAM_FORCE_PSKIP_BIT;
+		if (h264_config->pskip_repeat_enable) {
+			dsp_cmd->force_pskip_num_plus1 = h264_config->repeat_pskip_num + 1;
+		} else {
+			dsp_cmd->force_pskip_num_plus1 = 0;
+		}
 	}
 
-	put_cmd(stream->iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_ENC, 0);
+	put_cmd(stream->iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_ENC, 0, 0);
 
 	return 0;
 }
 
 // 0x6004 command
-int cmd_update_idsp_factor(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd)
+int cmd_update_vcap_params(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd,
+	u32 flags)
 {
 	ipcam_real_time_encode_param_setup_t *dsp_cmd;
 	u32 dsp_vin_fps = 0;
 	u32 idsp_out_frame_rate = 0;
-	int rval = 0;
 
-	mutex_lock(&iav->iav_mutex);
+	// directly return when iav is not in Preview/Encode state
+	if (iav->state != IAV_STATE_PREVIEW && iav->state != IAV_STATE_ENCODING) {
+		return 0;
+	}
 
-	do {
-		if (iav->state != IAV_STATE_PREVIEW && iav->state != IAV_STATE_ENCODING) {
-			break;
-		}
+	dsp_cmd = get_cmd(iav->dsp, cmd);
+	if (!dsp_cmd) {
+		return -ENOMEM;
+	}
 
-		dsp_cmd = get_cmd(iav->dsp, cmd);
-		if (!dsp_cmd) {
-			rval = -ENOMEM;
-			break;
-		}
-		if (calc_frame_rate(iav,
-			0, 0, 1, 1, &dsp_vin_fps, FRAME_RATE_SRC_VIN) < 0) {
+	dsp_cmd->cmd_code = IPCAM_REAL_TIME_ENCODE_PARAM_SETUP;
+
+	if (flags & REALTIME_PARAM_VIN_CAP_STATE) {
+		dsp_cmd->enable_flags |= REALTIME_PARAM_VIN_CAP_STATE;
+		dsp_cmd->vin_state = iav->vcap_next_state;
+	}
+	if (flags & REALTIME_PARAM_CUSTOM_VIN_FPS_BIT) {
+		if (calc_frame_rate(iav, 0, 0, 1, 1, &dsp_vin_fps, FRAME_RATE_SRC_VIN)
+			< 0) {
 			iav_error("frame rate calculation for realtime encode param"
 				"update failed, frame rate 0x%x.\n", dsp_vin_fps);
-			rval = -EINVAL;
-			break;
+			return -EINVAL;
 		}
 		if (iav_vin_get_idsp_frame_rate(iav, &idsp_out_frame_rate) < 0) {
-			rval = -EINVAL;
-			break;
+			return -EINVAL;
+		}
+		if (check_idsp_upsample_factor(dsp_cmd->idsp_frame_rate_M,
+			dsp_cmd->idsp_frame_rate_N) < 0) {
+			iav_error("IDSP multiplication_factor can not be smaller"
+				" than division_factor!\n");
+			return -EINVAL;
 		}
-
-		dsp_cmd->cmd_code = IPCAM_REAL_TIME_ENCODE_PARAM_SETUP;
 		dsp_cmd->enable_flags |= REALTIME_PARAM_CUSTOM_VIN_FPS_BIT;
 		dsp_cmd->custom_vin_frame_rate = dsp_vin_fps;
 		dsp_cmd->idsp_frame_rate_M = (u8)DIV_ROUND_CLOSEST(FPS_Q9_BASE,
 			idsp_out_frame_rate);
 		dsp_cmd->idsp_frame_rate_N = (u8)DIV_ROUND_CLOSEST(FPS_Q9_BASE,
 			iav->vinc[0]->vin_format.frame_rate);
+	}
 
-		if (check_idsp_upsample_factor(dsp_cmd->idsp_frame_rate_M,
-			dsp_cmd->idsp_frame_rate_N) < 0) {
-			iav_error("IDSP multiplication_factor can not be smaller"
-				" than division_factor!\n");
-			rval = -EINVAL;
-			break;
-		}
-
-		put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_ENC, 0);
-	} while (0);
-
-	mutex_unlock(&iav->iav_mutex);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_ENC, 0, 0);
 
-	return rval;
+	return 0;
 }
 
 int update_sync_encode_params(struct iav_stream *stream,
@@ -1908,14 +1989,17 @@ int update_sync_encode_params(struct iav_stream *stream,
 	struct iav_h264_config *h264_config;
 	struct iav_mjpeg_config *mjpeg_config;
 	struct iav_vin_format *vin_format;
+	struct iav_cmd_sync *cmd_sync;
 	u32 dsp_vin_fps, dsp_encoder_fps, offset;
 	u8 *addr;
 	int i, qpm_idx;
 	u32 idsp_out_frame_rate = 0;
 
+	cmd_sync = &iav->cmd_sync;
+
 	addr = (u8 *)iav->mmap[IAV_BUFFER_CMD_SYNC].virt +
-		iav->cmd_sync_idx * CMD_SYNC_SIZE +
-		stream->format.id * DSP_ENC_CMD_SIZE;
+		cmd_sync->idx * CMD_SYNC_SIZE +
+		stream->id_dsp * DSP_ENC_CMD_SIZE;
 	dsp_cmd = (ipcam_real_time_encode_param_setup_t *)addr;
 
 	h264_config = &stream->h264_config;
@@ -1923,7 +2007,7 @@ int update_sync_encode_params(struct iav_stream *stream,
 	vin_format = &iav->vinc[0]->vin_format;
 
 	dsp_cmd->cmd_code = GET_DSP_CMD_CODE(
-		IPCAM_REAL_TIME_ENCODE_PARAM_SETUP, stream->format.id);
+		IPCAM_REAL_TIME_ENCODE_PARAM_SETUP, stream->id_dsp);
 
 	if (flags & REALTIME_PARAM_CBR_MODIFY_BIT) {
 		dsp_cmd->enable_flags |= REALTIME_PARAM_CBR_MODIFY_BIT;
@@ -1948,13 +2032,19 @@ int update_sync_encode_params(struct iav_stream *stream,
 		dsp_cmd->qp_max_on_I = h264_config->qp_max_on_I;
 		dsp_cmd->qp_max_on_P = h264_config->qp_max_on_P;
 		dsp_cmd->qp_max_on_B = h264_config->qp_max_on_B;
+		dsp_cmd->qp_max_on_Q = h264_config->qp_max_on_Q;
 		dsp_cmd->qp_min_on_I = h264_config->qp_min_on_I;
 		dsp_cmd->qp_min_on_P = h264_config->qp_min_on_P;
 		dsp_cmd->qp_min_on_B = h264_config->qp_min_on_B;
+		dsp_cmd->qp_min_on_Q = h264_config->qp_min_on_Q;
 		dsp_cmd->aqp = h264_config->adapt_qp;
 		dsp_cmd->i_qp_reduce = h264_config->i_qp_reduce;
 		dsp_cmd->p_qp_reduce = h264_config->p_qp_reduce;
+		dsp_cmd->q_qp_reduce = h264_config->q_qp_reduce;
+		dsp_cmd->log_q_num_per_gop_plus_1 = h264_config->log_q_num_plus_1;
 		dsp_cmd->skip_flags = h264_config->skip_flag;
+		/* convert from KB to bits */
+		dsp_cmd->set_I_size = h264_config->max_I_size_KB << 13;
 	}
 	if (flags & REALTIME_PARAM_GOP_BIT) {
 		dsp_cmd->enable_flags |= REALTIME_PARAM_GOP_BIT;
@@ -1997,17 +2087,17 @@ int update_sync_encode_params(struct iav_stream *stream,
 		dsp_cmd->enable_flags |= REALTIME_PARAM_QP_ROI_MATRIX_BIT;
 		if (h264_config->qp_roi_enable) {
 			/* use previous qp matrix if not updated */
-			if (!iav->cmd_sync_qpm_flag) {
-				qpm_idx = (iav->cmd_sync_qpm_idx + ENC_CMD_TOGGLED_NUM - 2) %
-					ENC_CMD_TOGGLED_NUM + 1;
+			if (!cmd_sync->qpm_flag) {
+				qpm_idx = (cmd_sync->qpm_idx + QP_MATRIX_TOGGLED_NUM - 2) %
+					QP_MATRIX_TOGGLED_NUM + 1;
 			} else {
-				qpm_idx = iav->cmd_sync_qpm_idx;
+				qpm_idx = cmd_sync->qpm_idx;
 			}
 			dsp_cmd->roi_daddr = PHYS_TO_DSP(
 				iav->mmap[IAV_BUFFER_QPMATRIX].phys +
 				qpm_idx * QP_MATRIX_SIZE +
-				stream->format.id * STREAM_QP_MATRIX_SIZE);
-#ifdef CONFIG_AMBARELLA_IAV_QP_OFFSET_IPB
+				stream->id_dsp * STREAM_QP_MATRIX_SIZE);
+#ifdef CONFIG_AMBARELLA_IAV_ROI_IPB
 			dsp_cmd->roi_daddr_p = dsp_cmd->roi_daddr + SINGLE_QP_MATRIX_SIZE;
 			dsp_cmd->roi_daddr_b = dsp_cmd->roi_daddr_p + SINGLE_QP_MATRIX_SIZE;
 #else
@@ -2037,7 +2127,7 @@ int update_sync_encode_params(struct iav_stream *stream,
 	}
 	if (flags & REALTIME_PARAM_QUANT_MATRIX_BIT) {
 		dsp_cmd->enable_flags |= REALTIME_PARAM_QUANT_MATRIX_BIT;
-		init_stream_jpeg_dqt(iav, stream->format.id,
+		init_stream_jpeg_dqt(iav, stream->id_dsp,
 			mjpeg_config->quality);
 		offset = (u32)mjpeg_config->jpeg_quant_matrix -
 			iav->mmap[IAV_BUFFER_QUANT].virt;
@@ -2067,7 +2157,7 @@ int update_sync_encode_params(struct iav_stream *stream,
 	}
 	if (flags & REALTIME_PARAM_FLAT_AREA_BIT) {
 		dsp_cmd->enable_flags |= REALTIME_PARAM_FLAT_AREA_BIT;
-		dsp_cmd->flat_area_improvement_on = h264_config->enc_improve;
+		dsp_cmd->flat_area_improvement_on = h264_config->flat_area_improve;
 	}
 	if (flags & REALTIME_PARAM_FORCE_FAST_SEEK_BIT) {
 		dsp_cmd->enable_flags |= REALTIME_PARAM_FORCE_FAST_SEEK_BIT;
@@ -2075,6 +2165,22 @@ int update_sync_encode_params(struct iav_stream *stream,
 	if (flags & REALTIME_PARAM_FRAME_DROP_BIT) {
 		dsp_cmd->enable_flags |= REALTIME_PARAM_FRAME_DROP_BIT;
 		dsp_cmd->drop_frame = h264_config->drop_frames;
+		dsp_cmd->drop_frame_repeat = h264_config->drop_frame_repeat;
+	}
+	if (flags & REALTIME_PARAM_MV_DUMP_BIT) {
+		dsp_cmd->enable_flags |= REALTIME_PARAM_MV_DUMP_BIT;
+		dsp_cmd->mvdump_enable = h264_config->statis;
+	}
+	if (flags & REALTIME_PARAM_LONG_REF_P_BIT) {
+		dsp_cmd->enable_flags |= REALTIME_PARAM_LONG_REF_P_BIT;
+	}
+	if (flags & REALTIME_PARAM_FORCE_PSKIP_BIT) {
+		dsp_cmd->enable_flags |= REALTIME_PARAM_FORCE_PSKIP_BIT;
+		if (h264_config->pskip_repeat_enable) {
+			dsp_cmd->force_pskip_num_plus1 = h264_config->repeat_pskip_num + 1;
+		} else {
+			dsp_cmd->force_pskip_num_plus1 = 0;
+		}
 	}
 
 	return 0;
@@ -2095,7 +2201,7 @@ int cmd_overlay_insert(struct iav_stream *stream, struct amb_dsp_cmd *cmd,
 	if (!dsp_cmd)
 		return -ENOMEM;
 
-	dsp_cmd->cmd_code = GET_DSP_CMD_CODE(IPCAM_OSD_INSERT, stream->format.id);
+	dsp_cmd->cmd_code = GET_DSP_CMD_CODE(IPCAM_OSD_INSERT, stream->id_dsp);
 
 	if (info->enable) {
 		if (stream->iav->osd_from_mixer_a)
@@ -2148,14 +2254,15 @@ int cmd_overlay_insert(struct iav_stream *stream, struct amb_dsp_cmd *cmd,
 			dsp_cmd->osd_num_regions_ex = active_areas -
 				MAX_NUM_OSD_AERA_NO_EXTENSION;
 		}
+		dsp_cmd->osd_insert_always = info->osd_insert_always;
 	}
 
-	put_cmd(stream->iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_ENC, 0);
+	put_cmd(stream->iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_ENC, 0, 0);
 
 	return 0;
 }
 
-int cmd_set_pm_mctf(struct ambarella_iav *iav,struct amb_dsp_cmd *cmd,
+int cmd_set_pm_mctf(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd,
 	u32 delay)
 {
 	ipcam_set_privacy_mask_t *dsp_cmd;
@@ -2172,7 +2279,7 @@ int cmd_set_pm_mctf(struct ambarella_iav *iav,struct amb_dsp_cmd *cmd,
 	dsp_cmd->U = iav->pm.u;
 	dsp_cmd->V = iav->pm.v;
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, delay);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0, delay);
 
 	return 0;
 }
@@ -2192,7 +2299,7 @@ int cmd_fastosd_insert(struct iav_stream *stream, struct amb_dsp_cmd *cmd,
 		return -ENOMEM;
 
 	dsp_cmd->cmd_code = GET_DSP_CMD_CODE(IPCAM_FAST_OSD_INSERT,
-		stream->format.id);
+		stream->id_dsp);
 
 	if (info->enable) {
 		dsp_cmd->fast_osd_enable = 1;
@@ -2249,7 +2356,7 @@ int cmd_fastosd_insert(struct iav_stream *stream, struct amb_dsp_cmd *cmd,
 
 	}
 
-	put_cmd(stream->iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_ENC, 0);
+	put_cmd(stream->iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_ENC, 0, 0);
 
 	return 0;
 }
@@ -2267,8 +2374,9 @@ int cmd_dsp_set_debug_level(struct ambarella_iav *iav,
 	dsp_cmd->module = module;
 	dsp_cmd->debug_level = debug_level;
 	dsp_cmd->coding_thread_printf_disable_mask = mask;
+	dsp_cmd->num_dsplog_delay_stop_plus1 = 0;
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0, 0);
 
 	return 0;
 }
@@ -2282,7 +2390,7 @@ int cmd_set_pm_bpc(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd)
 	if (!dsp_cmd)
 		return -ENOMEM;
 
-	get_pm_vin_win(iav, &vin_win);
+	get_vin_win(iav, &vin_win, 0);
 
 	dsp_cmd->cmd_code = FIXED_PATTERN_NOISE_CORRECTION;
 	dsp_cmd->fpn_pixel_mode = 3;
@@ -2293,7 +2401,7 @@ int cmd_set_pm_bpc(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd)
 	dsp_cmd->fpn_pixels_addr = PHYS_TO_DSP(iav->mmap[IAV_BUFFER_PM_BPC].phys +
 			PM_BPC_PARTITION_SIZE * (iav->curr_pm_index));
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0, 0);
 
 	return 0;
 }
@@ -2325,7 +2433,7 @@ int cmd_bpc_setup(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd,
 	dsp_cmd->dark_pixel_thresh_addr = PHYS_TO_DSP(iav->mmap[IAV_BUFFER_BPC].phys +
 		BPC_TABLE_SIZE);
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0, 0);
 
 	return 0;
 }
@@ -2354,7 +2462,7 @@ int cmd_static_bpc(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd,
 	dsp_cmd->column_gain_addr = 0;//VIRT_TO_DSP(column_offset);
 	dsp_cmd->bad_pixel_a5m_mode = 1;
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0, 0);
 
 	return 0;
 }
@@ -2536,19 +2644,16 @@ int cmd_set_warp_batch_cmds(struct ambarella_iav *iav, int active_num,
 		WARP_BATCH_CMDS_OFFSET + iav->next_warp_index *
 		WARP_TABLE_AREA_MAX_NUM * WARP_CMD_SIZE);
 
-	put_cmd(iav->dsp, cmd, warp_batch_cmd, DSP_CMD_TYPE_NORMAL, 0);
+	put_cmd(iav->dsp, cmd, warp_batch_cmd, DSP_CMD_TYPE_NORMAL, 0, 0);
 
 	return 0;
 }
 
-int cmd_apply_frame_sync_cmd(struct ambarella_iav *iav,
-	struct amb_dsp_cmd *cmd, struct iav_apply_frame_sync *apply)
+int cmd_apply_frame_sync_cmd(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd,
+	struct iav_apply_frame_sync *apply, u32 stream_map)
 {
 	enc_sync_cmd_t *dsp_cmd;
-	ipcam_real_time_encode_param_setup_t *cmd_data;
 	u8 *addr = NULL;
-	u16 enable_flag = 0;
-	int i;
 
 	dsp_cmd = get_cmd(iav->dsp, cmd);
 	if (!dsp_cmd)
@@ -2558,22 +2663,13 @@ int cmd_apply_frame_sync_cmd(struct ambarella_iav *iav,
 	dsp_cmd->target_pts = apply->dsp_pts;
 
 	addr = (u8 *)iav->mmap[IAV_BUFFER_CMD_SYNC].phys +
-		iav->cmd_sync_idx * CMD_SYNC_SIZE;
+		iav->cmd_sync.idx * CMD_SYNC_SIZE;
 	dsp_cmd->cmd_daddr = PHYS_TO_DSP(addr);
 
-	for (i = 0; i < IAV_MAX_ENCODE_STREAMS_NUM; ++i) {
-		addr = (u8 *)iav->mmap[IAV_BUFFER_CMD_SYNC].virt +
-			iav->cmd_sync_idx * CMD_SYNC_SIZE + i * DSP_ENC_CMD_SIZE;
-		cmd_data = (ipcam_real_time_encode_param_setup_t *)addr;
-		if (cmd_data->cmd_code) {
-			enable_flag |= (1 << i);
-		}
-	}
-
-	dsp_cmd->enable_flag = enable_flag;
-	dsp_cmd->force_update_flag = (enable_flag & apply->force_update);
+	dsp_cmd->enable_flag = stream_map;
+	dsp_cmd->force_update_flag = (stream_map & apply->force_update);
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_ENC, 0);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_ENC, 0, 0);
 
 	return 0;
 }
@@ -2592,7 +2688,7 @@ int cmd_get_frm_buf_pool_info(struct ambarella_iav *iav,
 	dsp_cmd->cmd_code = IPCAM_GET_FRAME_BUF_POOL_INFO;
 	dsp_cmd->frm_buf_pool_info_req_bit_flag = get_buffer_pool_map(buf_map);
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0, 0);
 
 	return 0;
 }
@@ -2616,7 +2712,7 @@ int cmd_efm_creat_frm_buf_pool(struct ambarella_iav *iav,
 	dsp_cmd->max_num_yuv = iav->efm.req_buf_num;
 	dsp_cmd->max_num_me1 = iav->efm.req_buf_num;
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0, 0);
 
 	return 0;
 }
@@ -2635,13 +2731,13 @@ int cmd_efm_req_frame_buf(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd)
 	dsp_cmd->fbp_type = (1 << EFM_BUF_POOL_TYPE_ME1) |
 		(1 << EFM_BUF_POOL_TYPE_YUV420);
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0, 0);
 
 	return 0;
 }
 
 // 0x6010 command
-int cmd_efm_handshake(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd)
+int cmd_efm_handshake(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd, u8 next_is_last_frame)
 {
 	ipcam_efm_handshake_cmd_t *dsp_cmd;
 	struct iav_efm_buf_pool *pool = &iav->efm.buf_pool;
@@ -2655,8 +2751,9 @@ int cmd_efm_handshake(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd)
 	dsp_cmd->yuv_fId = pool->yuv_fId[pool->hs_idx];
 	dsp_cmd->me1_fId = pool->me1_fId[pool->hs_idx];
 	dsp_cmd->pts = iav->efm.curr_pts;
+	dsp_cmd->next_is_last_frame = !!next_is_last_frame;
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0, 0);
 
 	return 0;
 }
@@ -2673,7 +2770,24 @@ int cmd_hash_verification(struct ambarella_iav *iav, u8* input)
 	dsp_cmd->cmd_code = HASH_VERIFICATION;
 	memcpy(dsp_cmd->hash_input, input, 8);
 
-	put_cmd(iav->dsp, NULL, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0);
+	put_cmd(iav->dsp, NULL, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0, 0);
+
+	return 0;
+}
+
+// 0x1011 command
+int cmd_hash_verification_long(struct ambarella_iav *iav, u8* input)
+{
+	hash_verification_ex_t *dsp_cmd;
+
+	dsp_cmd = get_cmd(iav->dsp, NULL);
+	if (!dsp_cmd)
+		return -ENOMEM;
+
+	dsp_cmd->cmd_code = HASH_VERIFICATION_EX;
+	memcpy(dsp_cmd->hash_input, input, sizeof(dsp_cmd->hash_input));
+
+	put_cmd(iav->dsp, NULL, dsp_cmd, DSP_CMD_TYPE_NORMAL, 0, 0);
 
 	return 0;
 }
@@ -2689,7 +2803,7 @@ int cmd_reset_operation(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd)
 
 	dsp_cmd->cmd_code = RESET_OPERATION;
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_DEC, 0);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_DEC, 0, 0);
 
 	return 0;
 }
@@ -2713,18 +2827,27 @@ int cmd_h264_decoder_setup(struct ambarella_iav *iav,
 	dsp_cmd->cabac_to_recon_delay = 0x6;
 	dsp_cmd->forced_max_fb_size = 0x0;
 
+	dsp_cmd->video_max_width = decoder->width;
+	dsp_cmd->video_max_height = decoder->height;
+
 	dsp_cmd->gop_n = 0xf;
 	dsp_cmd->gop_m = 0x1;
 	dsp_cmd->dpb_size = 0x6;
 	dsp_cmd->customer_mem_usage = 1;
 	dsp_cmd->trickplay_fw = 1;
-	dsp_cmd->trickplay_ff_IP = 1;
-	dsp_cmd->trickplay_ff_I = 1;
-	dsp_cmd->trickplay_bw = 1;
-	dsp_cmd->trickplay_fb_IP = 1;
-	dsp_cmd->trickplay_fb_I = 1;
+	if (iav->decode_context.mode_config.b_support_ff_fb_bw) {
+		dsp_cmd->trickplay_ff_IP = 1;
+		dsp_cmd->trickplay_ff_I = 1;
+		dsp_cmd->trickplay_bw = 1;
+		dsp_cmd->trickplay_fb_IP = 1;
+		dsp_cmd->trickplay_fb_I = 1;
+	}
 	dsp_cmd->trickplay_rsv = 0;
-	dsp_cmd->bit_rate = (12 << 20);
+	//if (!dec_config->max_bitrate) {
+		dsp_cmd->bit_rate = (10 << 20);
+	//} else {
+	//	dsp_cmd->bit_rate = dec_config->max_bitrate;
+	//}
 
 	//if (!iav->decode_context.b_interlace_vout) {
 	if (0 == decoder->vout_configs[0].vout_id) {
@@ -2736,7 +2859,7 @@ int cmd_h264_decoder_setup(struct ambarella_iav *iav,
 	}
 	//}
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_DEC, 0);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_DEC, 0, 0);
 
 	return 0;
 }
@@ -2754,14 +2877,13 @@ int cmd_decode_stop(struct ambarella_iav *iav, u8 decoder_id, u8 stop_flag)
 	dsp_cmd->cmd_code = DECODE_STOP;
 	dsp_cmd->stop_flag = stop_flag;
 
-	put_cmd(iav->dsp, NULL, dsp_cmd, DSP_CMD_TYPE_DEC, 0);
+	put_cmd(iav->dsp, NULL, dsp_cmd, DSP_CMD_TYPE_DEC, 0, 0);
 
 	return 0;
 }
 
 int cmd_vout_video_setup(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd,
-	u16 vout_id, u8 en, u8 src, u8 flip, u8 rotate,
-	u16 offset_x, u16 offset_y, u16 width, u16 height)
+	struct iav_decode_vout_config *p_vout_config, u8 src, u8 is_interlace)
 {
 	vout_video_setup_t *dsp_cmd;
 
@@ -2771,17 +2893,22 @@ int cmd_vout_video_setup(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd,
 
 	memset(dsp_cmd, 0x0, sizeof(vout_video_setup_t));
 	dsp_cmd->cmd_code = VOUT_VIDEO_SETUP;
-	dsp_cmd->vout_id = vout_id;
-	dsp_cmd->en = en;
+	dsp_cmd->vout_id = p_vout_config->vout_id;
+	dsp_cmd->en = p_vout_config->enable;
 	dsp_cmd->src = src;
-	dsp_cmd->flip = flip;
-	dsp_cmd->rotate = rotate;
-	dsp_cmd->win_offset_x = offset_x;
-	dsp_cmd->win_offset_y = offset_y;
-	dsp_cmd->win_width = width;
-	dsp_cmd->win_height = height;
+	dsp_cmd->flip = p_vout_config->flip;
+	dsp_cmd->rotate = p_vout_config->rotate;
+	dsp_cmd->win_offset_x = p_vout_config->target_win_offset_x;
+	dsp_cmd->win_offset_y = p_vout_config->target_win_offset_y;
+	dsp_cmd->win_width = p_vout_config->target_win_width;
+	if (!is_interlace) {
+		dsp_cmd->win_height = p_vout_config->target_win_height;
+	} else {
+		dsp_cmd->win_height = p_vout_config->target_win_height / 2;
+	}
+	dsp_cmd->interlaced = is_interlace;
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_DEC, 0);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_DEC, 0, 0);
 
 	return 0;
 }
@@ -2838,7 +2965,7 @@ int cmd_rescale_postp(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd,
 		}
 	}
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_DEC, 0);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_DEC, 0, 0);
 
 	return 0;
 }
@@ -2858,7 +2985,7 @@ int cmd_playback_speed(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd,
 	dsp_cmd->scan_mode = scan_mode;
 	dsp_cmd->direction = direction;
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_DEC, 0);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_DEC, 0, 0);
 
 	return 0;
 }
@@ -2880,7 +3007,7 @@ int cmd_h264_decode(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd,
 	dsp_cmd->num_pics = num_frames;
 	dsp_cmd->first_frame_display = first_frame_display;
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_DEC, 0);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_DEC, 0, 0);
 
 	return 0;
 }
@@ -2901,7 +3028,7 @@ int cmd_h264_decode_fifo_update(struct ambarella_iav *iav,
 	dsp_cmd->bits_fifo_end = bits_fifo_end;
 	dsp_cmd->num_pics = num_frames;
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_DEC, 0);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_DEC, 0, 0);
 
 	return 0;
 }
@@ -2919,7 +3046,7 @@ int cmd_h264_trick_play(struct ambarella_iav *iav,
 	dsp_cmd->cmd_code = H264_TRICKPLAY;
 	dsp_cmd->mode = mode;
 
-	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_DEC, 0);
+	put_cmd(iav->dsp, cmd, dsp_cmd, DSP_CMD_TYPE_DEC, 0, 0);
 
 	return 0;
 }
@@ -2927,20 +3054,54 @@ int cmd_h264_trick_play(struct ambarella_iav *iav,
 static int parse_cmd_system_info_setup(struct ambarella_iav *iav, DSP_CMD *cmd)
 {
 	system_setup_info_t *dsp_cmd = (system_setup_info_t *)cmd;
+	u32 chip_id;
+	u32 enc_mode = dsp_cmd->mode_flags;
+	struct iav_system_config *config = &iav->system_config[enc_mode];
 
-	iav->encode_mode = dsp_cmd->mode_flags;
-	iav->srcbuf[IAV_SRCBUF_PA].type = preview_type_to_buffer_format(dsp_cmd->preview_A_type);
-	iav->srcbuf[IAV_SRCBUF_PB].type = preview_type_to_buffer_format(dsp_cmd->preview_B_type);
+	iav->encode_mode = enc_mode;
+	iav->srcbuf[IAV_SRCBUF_PA].type =
+		preview_type_to_buffer_format(dsp_cmd->preview_A_type);
+	iav->srcbuf[IAV_SRCBUF_PB].type =
+		preview_type_to_buffer_format(dsp_cmd->preview_B_type);
 
 	iav->osd_from_mixer_a = dsp_cmd->voutA_osd_blend_enabled;
 	iav->osd_from_mixer_b = dsp_cmd->voutB_osd_blend_enabled;
-	iav->system_config[iav->encode_mode].enc_raw_rgb = dsp_cmd->raw_encode_enabled;
-	iav->system_config[iav->encode_mode].expo_num = dsp_cmd->hdr_num_exposures_minus_1 + 1;
-	iav->system_config[iav->encode_mode].vout_swap = dsp_cmd->vout_swap;
-	iav->system_config[iav->encode_mode].me0_scale = dsp_cmd->me0_scale_factor;
-	/* TODO: dsp_cmd->adv_iso_disabled */
+	config->enc_raw_rgb = dsp_cmd->raw_encode_enabled;
+	config->expo_num = dsp_cmd->hdr_num_exposures_minus_1 + 1;
+	config->vout_swap = dsp_cmd->vout_swap;
+	config->me0_scale = dsp_cmd->me0_scale_factor;
+	iav->vin_overflow_protection = dsp_cmd->vin_overflow_protection;
+
+	if (enc_mode == DSP_ADVANCED_ISO_MODE) {
+		iav->dsp->get_chip_id(iav->dsp, &chip_id, NULL);
+		switch (chip_id) {
+		case IAV_CHIP_ID_S2L_22M:
+		case IAV_CHIP_ID_S2L_33M:
+		case IAV_CHIP_ID_S2L_55M:
+		case IAV_CHIP_ID_S2L_99M:
+		case IAV_CHIP_ID_S2L_TEST:
+		case IAV_CHIP_ID_S2L_33MEX:
+			if (dsp_cmd->adv_iso_disabled == 0) {
+				config->debug_enable_map |= DEBUG_TYPE_ISO_TYPE;
+				config->debug_iso_type = ISO_TYPE_ADVANCED;
+			}
+			break;
+		case IAV_CHIP_ID_S2L_63:
+		case IAV_CHIP_ID_S2L_66:
+		case IAV_CHIP_ID_S2L_88:
+		case IAV_CHIP_ID_S2L_99:
+		case IAV_CHIP_ID_S2L_22:
+		case IAV_CHIP_ID_S2L_33EX:
+			if (dsp_cmd->adv_iso_disabled == 1) {
+				config->debug_enable_map |= DEBUG_TYPE_ISO_TYPE;
+				config->debug_iso_type = ISO_TYPE_MIDDLE;
+			}
+			break;
+		}
+	}
 
-	iav_debug ("cmd_code = 0x%08X, Encode mode [%u]\n", dsp_cmd->cmd_code, iav->encode_mode);
+	iav_debug ("cmd_code = 0x%08X, Encode mode [%u]\n",
+		dsp_cmd->cmd_code, iav->encode_mode);
 
 	return 0;
 }
@@ -2979,6 +3140,8 @@ static int parse_cmd_video_preproc(struct ambarella_iav *iav, DSP_CMD *cmd)
 {
 	video_preproc_t *dsp_cmd = (video_preproc_t *)cmd;
 	struct amba_video_info *vout0_info, *vout1_info;
+	u8 enc_mode = iav->encode_mode;
+	struct iav_system_config *config = &iav->system_config[enc_mode];
 
 	iav->vinc[0]->vin_format.input_format = dsp_cmd->input_format;
 	iav->vinc[0]->vin_format.sensor_id = dsp_cmd->sensor_id;
@@ -2988,14 +3151,14 @@ static int parse_cmd_video_preproc(struct ambarella_iav *iav, DSP_CMD *cmd)
 	iav->vinc[0]->vin_format.vin_win.width = dsp_cmd->vidcap_w;
 	iav->vinc[0]->vin_format.vin_win.height = dsp_cmd->vidcap_h; */
 
-	if (iav->encode_mode == DSP_MULTI_REGION_WARP_MODE) {
+	if (enc_mode == DSP_MULTI_REGION_WARP_MODE) {
 		iav->srcbuf[IAV_SRCBUF_PMN].win.width = dsp_cmd->main_w;
 		iav->srcbuf[IAV_SRCBUF_PMN].win.height= dsp_cmd->main_h;
 	} else {
 		iav->srcbuf[IAV_SRCBUF_MN].win.width = dsp_cmd->main_w;
 		iav->srcbuf[IAV_SRCBUF_MN].win.height = dsp_cmd->main_h;
 	}
-	if (iav->system_config[iav->encode_mode].vout_swap) {
+	if (config->vout_swap) {
 		vout0_info = &G_voutinfo[1].video_info;
 		vout1_info = &G_voutinfo[0].video_info;
 	} else {
@@ -3018,9 +3181,11 @@ static int parse_cmd_video_preproc(struct ambarella_iav *iav, DSP_CMD *cmd)
 		vout1_info->height = dsp_cmd->preview_h_B;
 	}
 
-	vout0_info->format = dsp_format_to_amba_iav_format(dsp_cmd->preview_format_A);
-	vout1_info->format = dsp_format_to_amba_iav_format(dsp_cmd->preview_format_B);
-	if (iav->system_config[iav->encode_mode].vout_swap) {
+	vout0_info->format =
+		dsp_format_to_amba_iav_format(dsp_cmd->preview_format_A);
+	vout1_info->format =
+		dsp_format_to_amba_iav_format(dsp_cmd->preview_format_B);
+	if (config->vout_swap) {
 		G_voutinfo[0].enabled = dsp_cmd->preview_B_en;
 		G_voutinfo[1].enabled = dsp_cmd->preview_A_en;
 	} else {
@@ -3031,6 +3196,8 @@ static int parse_cmd_video_preproc(struct ambarella_iav *iav, DSP_CMD *cmd)
 	/*TODO: dsp_cmd->Vert_WARP_enable
 			dsp_cmd->force_stitching
 			dsp_cmd->still_iso_config_daddr */
+	config->debug_stitched = dsp_cmd->force_stitching;
+	config->eis_delay_count = dsp_cmd->EIS_delay_count;
 
 	iav_debug ("cmd_code = 0x%08X\n", dsp_cmd->cmd_code);
 
@@ -3044,6 +3211,7 @@ static int parse_set_warp_control(struct ambarella_iav *iav, DSP_CMD *cmd)
 	u8 enc_mode = iav->encode_mode;
 	u8 expo_num = iav->system_config[enc_mode].expo_num;
 	set_warp_control_t *dsp_cmd = (set_warp_control_t *)cmd;
+	struct iav_warp_area *area = &iav->warp->area[0];
 
 	input_win.width = dsp_cmd->dummy_window_width;
 	input_win.height = dsp_cmd->dummy_window_height;
@@ -3067,23 +3235,29 @@ static int parse_set_warp_control(struct ambarella_iav *iav, DSP_CMD *cmd)
 	if (dsp_cmd->warp_control == WARP_CONTROL_ENABLE ||
 		dsp_cmd->vert_warp_enable == WARP_CONTROL_ENABLE) {
 		if (dsp_cmd->warp_control == WARP_CONTROL_ENABLE) {
-			iav->warp->area[0].h_map.enable = 1;
-			iav->warp->area[0].h_map.output_grid_col = dsp_cmd->grid_array_width;
-			iav->warp->area[0].h_map.output_grid_row = dsp_cmd->grid_array_height;
-			iav->warp->area[0].h_map.h_spacing = dsp_cmd->horz_grid_spacing_exponent;
-			iav->warp->area[0].h_map.v_spacing = dsp_cmd->vert_grid_spacing_exponent;
+			area->h_map.enable = 1;
+			area->h_map.output_grid_col = dsp_cmd->grid_array_width;
+			area->h_map.output_grid_row = dsp_cmd->grid_array_height;
+			area->h_map.h_spacing = dsp_cmd->horz_grid_spacing_exponent;
+			area->h_map.v_spacing = dsp_cmd->vert_grid_spacing_exponent;
 		}
 		if (dsp_cmd->vert_warp_enable == WARP_CONTROL_ENABLE) {
-			iav->warp->area[0].v_map.enable = 1;
-			iav->warp->area[0].v_map.output_grid_col = dsp_cmd->vert_warp_grid_array_width;
-			iav->warp->area[0].v_map.output_grid_row = dsp_cmd->vert_warp_grid_array_height;
-			iav->warp->area[0].v_map.h_spacing = dsp_cmd->vert_warp_horz_grid_spacing_exponent;
-			iav->warp->area[0].v_map.v_spacing = dsp_cmd->vert_warp_vert_grid_spacing_exponent;
-
-			iav->warp->area[0].me1_v_map.output_grid_col = dsp_cmd->ME1_vwarp_grid_array_width;
-			iav->warp->area[0].me1_v_map.output_grid_row = dsp_cmd->ME1_vwarp_grid_array_height;
-			iav->warp->area[0].me1_v_map.h_spacing = dsp_cmd->ME1_vwarp_horz_grid_spacing_exponent;
-			iav->warp->area[0].me1_v_map.v_spacing = dsp_cmd->ME1_vwarp_vert_grid_spacing_exponent;
+			area->v_map.enable = 1;
+			area->v_map.output_grid_col = dsp_cmd->vert_warp_grid_array_width;
+			area->v_map.output_grid_row = dsp_cmd->vert_warp_grid_array_height;
+			area->v_map.h_spacing =
+				dsp_cmd->vert_warp_horz_grid_spacing_exponent;
+			area->v_map.v_spacing =
+				dsp_cmd->vert_warp_vert_grid_spacing_exponent;
+
+			area->me1_v_map.output_grid_col =
+				dsp_cmd->ME1_vwarp_grid_array_width;
+			area->me1_v_map.output_grid_row =
+				dsp_cmd->ME1_vwarp_grid_array_height;
+			area->me1_v_map.h_spacing =
+				dsp_cmd->ME1_vwarp_horz_grid_spacing_exponent;
+			area->me1_v_map.v_spacing =
+				dsp_cmd->ME1_vwarp_vert_grid_spacing_exponent;
 		}
 		iav->warp->area[0].enable = 1;
 		iav->system_config[enc_mode].lens_warp = 1;
@@ -3091,10 +3265,10 @@ static int parse_set_warp_control(struct ambarella_iav *iav, DSP_CMD *cmd)
 
 	if (is_warp_mode(iav) || iav->system_config[enc_mode].lens_warp) {
 		if (iav->system_config[enc_mode].lens_warp) {
-			iav->warp->area[0].input.width = input_win.width;
-			iav->warp->area[0].input.height = input_win.height;
-			iav->warp->area[0].input.x = input_win.x;
-			iav->warp->area[0].input.y = input_win.y;
+			area->input.width = input_win.width;
+			area->input.height = input_win.height;
+			area->input.x = input_win.x;
+			area->input.y = input_win.y;
 
 			iav->main_buffer->input.width = iav->warp->area[0].input.width;
 			iav->main_buffer->input.height = iav->warp->area[0].input.height;
@@ -3107,15 +3281,21 @@ static int parse_set_warp_control(struct ambarella_iav *iav, DSP_CMD *cmd)
 			iav->srcbuf[IAV_SRCBUF_PMN].input.y = input_win.y;
 
 			if (iav->encode_mode == DSP_SINGLE_REGION_WARP_MODE) {
-				if ((dsp_cmd->actual_right_bot_x >> 16) >= iav->srcbuf[IAV_SRCBUF_MN].win.width &&
-					(dsp_cmd->actual_right_bot_y >> 16) >= iav->srcbuf[IAV_SRCBUF_MN].win.height) {
-					iav->srcbuf[IAV_SRCBUF_PMN].win.width = dsp_cmd->cfa_output_width;
-					iav->srcbuf[IAV_SRCBUF_PMN].win.height = dsp_cmd->cfa_output_height;
+				if ((dsp_cmd->actual_right_bot_x >> 16) >=
+					iav->srcbuf[IAV_SRCBUF_MN].win.width &&
+					(dsp_cmd->actual_right_bot_y >> 16) >=
+					iav->srcbuf[IAV_SRCBUF_MN].win.height) {
+					iav->srcbuf[IAV_SRCBUF_PMN].win.width =
+						dsp_cmd->cfa_output_width;
+					iav->srcbuf[IAV_SRCBUF_PMN].win.height =
+						dsp_cmd->cfa_output_height;
 				}
 			}
 
-			iav->main_buffer->input.width = iav->srcbuf[IAV_SRCBUF_PMN].win.width;
-			iav->main_buffer->input.height = iav->srcbuf[IAV_SRCBUF_PMN].win.height;
+			iav->main_buffer->input.width =
+				iav->srcbuf[IAV_SRCBUF_PMN].win.width;
+			iav->main_buffer->input.height =
+				iav->srcbuf[IAV_SRCBUF_PMN].win.height;
 			iav->main_buffer->input.x = 0;
 			iav->main_buffer->input.y = 0;
 		}
@@ -3132,31 +3312,48 @@ static int parse_set_warp_control(struct ambarella_iav *iav, DSP_CMD *cmd)
 
 static int parse_cmd_video_system_setup(struct ambarella_iav *iav, DSP_CMD *cmd)
 {
+	u32 buff_id;
+	int rval = 0;
 	ipcam_video_system_setup_t *dsp_cmd = (ipcam_video_system_setup_t *)cmd;
+	u8 enc_mode = iav->encode_mode;
+	struct iav_system_config *config = &iav->system_config[enc_mode];
 
 	if (iav->encode_mode == DSP_MULTI_REGION_WARP_MODE) {
-		iav->system_config[iav->encode_mode].max_warp_input_width = dsp_cmd->max_warp_region_input_width;
-		iav->system_config[iav->encode_mode].max_warp_input_height = dsp_cmd->max_warp_region_input_height;
-		iav->system_config[iav->encode_mode].max_warp_output_width = dsp_cmd->max_warp_region_output_width;
-		iav->system_config[iav->encode_mode].v_warped_main_max_width = dsp_cmd->v_warped_main_max_width;
-		iav->system_config[iav->encode_mode].v_warped_main_max_height = dsp_cmd->v_warped_main_max_height;
+		config->max_warp_input_width = dsp_cmd->max_warp_region_input_width;
+		config->max_warp_input_height = dsp_cmd->max_warp_region_input_height;
+		config->max_warp_output_width = dsp_cmd->max_warp_region_output_width;
+		config->v_warped_main_max_width = dsp_cmd->v_warped_main_max_width;
+		config->v_warped_main_max_height = dsp_cmd->v_warped_main_max_height;
 		iav->srcbuf[IAV_SRCBUF_MN].max.width = dsp_cmd->warped_main_max_width;
-		iav->srcbuf[IAV_SRCBUF_MN].max.height = get_rounddown_height(dsp_cmd->warped_main_max_height);
+		iav->srcbuf[IAV_SRCBUF_MN].max.height =
+			get_rounddown_height(dsp_cmd->warped_main_max_height);
 		iav->srcbuf[IAV_SRCBUF_PMN].win.width = dsp_cmd->main_max_width;
-		iav->srcbuf[IAV_SRCBUF_PMN].win.height =  get_rounddown_height(dsp_cmd->main_max_height);
+		iav->srcbuf[IAV_SRCBUF_PMN].win.height =
+			get_rounddown_height(dsp_cmd->main_max_height);
 	} else {
 		iav->srcbuf[IAV_SRCBUF_MN].max.width = dsp_cmd->main_max_width;
-		iav->srcbuf[IAV_SRCBUF_MN].max.height = get_rounddown_height(dsp_cmd->main_max_height);
+		iav->srcbuf[IAV_SRCBUF_MN].max.height =
+			get_rounddown_height(dsp_cmd->main_max_height);
 	}
-	iav->system_config[iav->encode_mode].max_padding_width = dsp_cmd->max_padding_width;
-	iav->system_config[iav->encode_mode].rotatable = dsp_cmd->enc_rotation_possible;
+	config->max_padding_width = dsp_cmd->max_padding_width;
+	config->rotatable = dsp_cmd->enc_rotation_possible;
 
 	iav->srcbuf[IAV_SRCBUF_PC].max.width = dsp_cmd->preview_C_max_width;
-	iav->srcbuf[IAV_SRCBUF_PC].max.height = get_rounddown_height(dsp_cmd->preview_C_max_height);
+	iav->srcbuf[IAV_SRCBUF_PC].max.height =
+		get_rounddown_height(dsp_cmd->preview_C_max_height);
 	iav->srcbuf[IAV_SRCBUF_PB].max.width = dsp_cmd->preview_B_max_width;
-	iav->srcbuf[IAV_SRCBUF_PB].max.height = get_rounddown_height(dsp_cmd->preview_B_max_height);
+	iav->srcbuf[IAV_SRCBUF_PB].max.height =
+		get_rounddown_height(dsp_cmd->preview_B_max_height);
 	iav->srcbuf[IAV_SRCBUF_PA].max.width = dsp_cmd->preview_A_max_width;
-	iav->srcbuf[IAV_SRCBUF_PA].max.height = get_rounddown_height(dsp_cmd->preview_A_max_height);
+	iav->srcbuf[IAV_SRCBUF_PA].max.height =
+		get_rounddown_height(dsp_cmd->preview_A_max_height);
+	for (buff_id = IAV_SUB_SRCBUF_FIRST;
+		buff_id < IAV_SUB_SRCBUF_LAST; buff_id ++) {
+		if (iav->srcbuf[buff_id].max.width == 0 ||
+			iav->srcbuf[buff_id].max.height == 0) {
+			iav->srcbuf[buff_id].type = IAV_SRCBUF_TYPE_OFF;
+		}
+	}
 
 	iav->stream[0].max_GOP_M = dsp_cmd->stream_0_max_GOP_M;
 	iav->stream[1].max_GOP_M = dsp_cmd->stream_1_max_GOP_M;
@@ -3164,52 +3361,72 @@ static int parse_cmd_video_system_setup(struct ambarella_iav *iav, DSP_CMD *cmd)
 	iav->stream[3].max_GOP_M = dsp_cmd->stream_3_max_GOP_M;
 
 	iav->stream[0].max.width = dsp_cmd->stream_0_max_width;
-	iav->stream[0].max.height = get_rounddown_height(dsp_cmd->stream_0_max_height);
+	iav->stream[0].max.height =
+		get_rounddown_height(dsp_cmd->stream_0_max_height);
 	iav->stream[1].max.width = dsp_cmd->stream_1_max_width;
-	iav->stream[1].max.height = get_rounddown_height(dsp_cmd->stream_1_max_height);
+	iav->stream[1].max.height =
+		get_rounddown_height(dsp_cmd->stream_1_max_height);
 	iav->stream[2].max.width = dsp_cmd->stream_2_max_width;
-	iav->stream[2].max.height = get_rounddown_height(dsp_cmd->stream_2_max_height);
+	iav->stream[2].max.height =
+		get_rounddown_height(dsp_cmd->stream_2_max_height);
 	iav->stream[3].max.width = dsp_cmd->stream_3_max_width;
-	iav->stream[3].max.height = get_rounddown_height(dsp_cmd->stream_3_max_height);
+	iav->stream[3].max.height =
+		get_rounddown_height(dsp_cmd->stream_3_max_height);
 
-	iav->system_config[iav->encode_mode].max_stream_num = dsp_cmd->max_num_streams;
-	iav->system_config[iav->encode_mode].raw_capture = dsp_cmd->raw_compression_disabled;
+	config->max_stream_num = dsp_cmd->max_num_streams;
+	config->raw_capture = dsp_cmd->raw_compression_disabled;
 
 	iav->srcbuf[IAV_SRCBUF_MN].extra_dram_buf = dsp_cmd->extra_buf_main;
 	iav->srcbuf[IAV_SRCBUF_PA].extra_dram_buf = dsp_cmd->extra_buf_preview_a;
 	iav->srcbuf[IAV_SRCBUF_PB].extra_dram_buf = dsp_cmd->extra_buf_preview_b;
 	iav->srcbuf[IAV_SRCBUF_PC].extra_dram_buf = dsp_cmd->extra_buf_preview_c;
-	iav->system_config[iav->encode_mode].enc_dummy_latency = dsp_cmd->enc_dummy_latency;
+	config->enc_dummy_latency = dsp_cmd->enc_dummy_latency;
 
 	iav->stream[0].long_ref_enable = dsp_cmd->stream_0_LT_enable;
 	iav->stream[1].long_ref_enable = dsp_cmd->stream_1_LT_enable;
 	iav->stream[2].long_ref_enable = dsp_cmd->stream_2_LT_enable;
 	iav->stream[3].long_ref_enable = dsp_cmd->stream_3_LT_enable;
+	config->long_ref_b_frame = dsp_cmd->B_frame_enable_in_LT_gop;
 	/* TODO: dsp_cmd->vwarp_blk_h */
 
+	rval = get_srcbuf_id(dsp_cmd->vca_preview_id, &buff_id);
+	if (((buff_id >= IAV_SRCBUF_FIRST) || (buff_id < IAV_SRCBUF_LAST)) &&
+			dsp_cmd->vca_frame_num && dsp_cmd->vca_daddr_base &&
+			dsp_cmd->vca_daddr_size) {
+		iav->srcbuf[buff_id].type = IAV_SRCBUF_TYPE_VCA;
+		iav->srcbuf[buff_id].dump_duration  = dsp_cmd->vca_frame_num;
+	}
+
 	iav_debug ("cmd_code = 0x%08X\n", dsp_cmd->cmd_code);
 
-	return 0;
+	return rval;
 }
 
 static int parse_cmd_capture_buffer_setup(struct ambarella_iav *iav, DSP_CMD *cmd)
 {
 	int rval = 0;
-	ipcam_capture_preview_size_setup_t *dsp_cmd = (ipcam_capture_preview_size_setup_t *)cmd;
-
+	ipcam_capture_preview_size_setup_t *dsp_cmd =
+		(ipcam_capture_preview_size_setup_t *)cmd;
 	enum iav_srcbuf_id buf_id = IAV_SRCBUF_FIRST;
+	struct iav_buffer *buffer = NULL;
+
 	rval = get_srcbuf_id(dsp_cmd->preview_id, &buf_id);
+	buffer = &iav->srcbuf[buf_id];
 	if (dsp_cmd->disabled) {
-		iav->srcbuf[buf_id].max.width = dsp_cmd->cap_width;
-		iav->srcbuf[buf_id].max.height = dsp_cmd->cap_height;
+		buffer->max.width = dsp_cmd->cap_width;
+		buffer->max.height = dsp_cmd->cap_height;
 	} else {
-		iav->srcbuf[buf_id].win.width = dsp_cmd->cap_width;
-		iav->srcbuf[buf_id].win.height = dsp_cmd->cap_height;
+		buffer->win.width = dsp_cmd->cap_width;
+		buffer->win.height = dsp_cmd->cap_height;
+	}
+	buffer->input.width = dsp_cmd->input_win_width;
+	buffer->input.height = dsp_cmd->input_win_height;
+	buffer->input.x = dsp_cmd->input_win_offset_x;
+	buffer->input.y = dsp_cmd->input_win_offset_y;
+
+	if (buffer->type == IAV_SRCBUF_TYPE_VCA) {
+		buffer->dump_interval = dsp_cmd->skip_interval + 1;
 	}
-	iav->srcbuf[buf_id].input.width = dsp_cmd->input_win_width;
-	iav->srcbuf[buf_id].input.height = dsp_cmd->input_win_height;
-	iav->srcbuf[buf_id].input.x = dsp_cmd->input_win_offset_x;
-	iav->srcbuf[buf_id].input.y = dsp_cmd->input_win_offset_y;
 
 	iav_debug ("cmd_code = 0x%08X, Buffer ID [%d]\n", dsp_cmd->cmd_code, buf_id);
 
@@ -3218,87 +3435,115 @@ static int parse_cmd_capture_buffer_setup(struct ambarella_iav *iav, DSP_CMD *cm
 
 static int parse_cmd_encode_size_setup(struct ambarella_iav *iav, DSP_CMD *cmd)
 {
-	int id = 0;
 	int rval = 0;
-	ipcam_video_encode_size_setup_t *dsp_cmd = (ipcam_video_encode_size_setup_t *)cmd;
-	id = GET_STRAME_ID_CODE(dsp_cmd->cmd_code);
+	ipcam_video_encode_size_setup_t *dsp_cmd =
+		(ipcam_video_encode_size_setup_t *)cmd;
+	int id = GET_STRAME_ID_CODE(dsp_cmd->cmd_code);
+	struct iav_stream *stream = &iav->stream[id];
+	struct iav_stream_format *format = &stream->format;
 
 	if (iav->encode_mode == DSP_MULTI_REGION_WARP_MODE) {
 		switch (dsp_cmd->capture_source) {
 		case DSP_CAPBUF_WARP:
-			iav->stream[id].format.buf_id = IAV_SRCBUF_MN;
+			format->buf_id = IAV_SRCBUF_MN;
 			break;
 		case DSP_CAPBUF_MN:
-			iav->stream[id].format.buf_id = IAV_SRCBUF_PMN;
+			format->buf_id = IAV_SRCBUF_PMN;
 			break;
 		default:
-			rval = get_srcbuf_id(dsp_cmd->capture_source, &iav->stream[id].format.buf_id);
+			rval = get_srcbuf_id(dsp_cmd->capture_source, &format->buf_id);
 			break;
 		}
 	} else {
-		 rval = get_srcbuf_id(dsp_cmd->capture_source, &iav->stream[id].format.buf_id);
+		 rval = get_srcbuf_id(dsp_cmd->capture_source, &format->buf_id);
 	}
 
-	iav->stream[id].format.enc_win.width = dsp_cmd->enc_width;
-	iav->stream[id].format.enc_win.height = get_rounddown_height(dsp_cmd->enc_height);
-	iav->stream[id].format.enc_win.x = dsp_cmd->enc_x;
-	iav->stream[id].format.enc_win.y = dsp_cmd->enc_y;
+	stream->srcbuf = &iav->srcbuf[format->buf_id];
+	format->enc_win.width = dsp_cmd->enc_width;
+	format->enc_win.height = dsp_cmd->enc_height;
+	format->enc_win.x = dsp_cmd->enc_x;
+	format->enc_win.y = dsp_cmd->enc_y;
 
-	iav_debug ("cmd_code = 0x%08X, Stream ID [%c]\n", dsp_cmd->cmd_code, 'A' + id);
+	iav_debug ("cmd_code = 0x%08X, Stream ID [%c]\n",
+		dsp_cmd->cmd_code, 'A' + id);
 
 	return rval;
 }
 
 static int parse_cmd_h264_encode_setup(struct ambarella_iav *iav, DSP_CMD *cmd)
 {
-	int id = 0;
+	s16 offset_y;
+	u32 tmp_width;
+	u32 tmp_height;
 	h264_encode_setup_t *dsp_cmd = (h264_encode_setup_t *)cmd;
-	id = GET_STRAME_ID_CODE(dsp_cmd->cmd_code);
-
-	iav->stream[id].h264_config.M = dsp_cmd->M;
-	iav->stream[id].h264_config.N = (dsp_cmd->N_msb << 8) | dsp_cmd->N;
-	get_gop_struct_from_quailty(&iav->stream[id].h264_config, dsp_cmd->quality);
-	iav->stream[id].h264_config.idr_interval = dsp_cmd->idr_interval;
-	iav->stream[id].h264_config.average_bitrate = dsp_cmd->average_bitrate;
-	iav->stream[id].h264_config.vbr_setting = dsp_cmd->vbr_setting;
-	iav->stream[id].format.hflip = dsp_cmd->hflip;
-	iav->stream[id].format.vflip = dsp_cmd->vflip;
-	iav->stream[id].format.rotate_cw = dsp_cmd->rotate;
-	iav->stream[id].h264_config.chroma_format = dsp_cmd->chroma_format;
-	iav->stream[id].fps.fps_div = dsp_cmd->frame_rate_division_factor;
-	iav->stream[id].fps.fps_multi = dsp_cmd->frame_rate_multiplication_factor;
-	iav->stream[id].h264_config.cpb_buf_idc = dsp_cmd->cpb_buf_idc;
-	iav->stream[id].h264_config.cpb_cmp_idc = dsp_cmd->cpb_cmp_idc;
-	iav->stream[id].h264_config.en_panic_rc = dsp_cmd->en_panic_rc;
-	iav->stream[id].h264_config.fast_rc_idc = dsp_cmd->fast_rc_idc;
-	iav->stream[id].h264_config.cpb_user_size = dsp_cmd->cpb_user_size;
-	/* TODO: dsp_cmd->fast_seek_interval */;
-
-	iav_debug ("cmd_code = 0x%08X, Stream ID [%c]\n", dsp_cmd->cmd_code, 'A' + id);
+	int id = GET_STRAME_ID_CODE(dsp_cmd->cmd_code);
+	struct iav_stream *stream = &iav->stream[id];
+	struct iav_stream_format *stream_format = &stream->format;
+	struct iav_h264_config *h264_config = &stream->h264_config;
+
+	h264_config->M = dsp_cmd->M;
+	h264_config->N = (dsp_cmd->N_msb << 8) | dsp_cmd->N;
+	get_gop_struct_from_quailty(h264_config, dsp_cmd->quality);
+	h264_config->idr_interval = dsp_cmd->idr_interval;
+	h264_config->average_bitrate = dsp_cmd->average_bitrate;
+	h264_config->vbr_setting = dsp_cmd->vbr_setting;
+	stream_format->hflip = dsp_cmd->hflip;
+	stream_format->vflip = dsp_cmd->vflip;
+	stream_format->rotate_cw = dsp_cmd->rotate;
+	tmp_width = stream_format->enc_win.width;
+	tmp_height = stream_format->enc_win.height;
+	if (dsp_cmd->rotate) {
+		stream->max.width =
+			get_rounddown_height(stream->max.width);
+		stream_format->enc_win.width = tmp_height;
+		stream_format->enc_win.height = get_rounddown_height(tmp_width);
+		offset_y = (stream_format->hflip ?
+			0 : (stream_format->enc_win.height - tmp_width));
+	} else {
+		stream_format->enc_win.height = get_rounddown_height(tmp_height);
+		offset_y = (stream_format->vflip?
+			(stream_format->enc_win.height - tmp_height) : 0);
+	}
+	stream_format->enc_win.y = stream_format->enc_win.y - offset_y;
+	h264_config->chroma_format = dsp_cmd->chroma_format;
+	stream->fps.fps_div = dsp_cmd->frame_rate_division_factor;
+	stream->fps.fps_multi = dsp_cmd->frame_rate_multiplication_factor;
+	h264_config->cpb_buf_idc = dsp_cmd->cpb_buf_idc;
+	h264_config->cpb_cmp_idc = dsp_cmd->cpb_cmp_idc;
+	h264_config->en_panic_rc = dsp_cmd->en_panic_rc;
+	h264_config->fast_rc_idc = dsp_cmd->fast_rc_idc;
+	h264_config->cpb_user_size = dsp_cmd->cpb_user_size;
+	h264_config->fast_seek_intvl = dsp_cmd->fast_seek_interval;
+
+	iav_debug ("cmd_code = 0x%08X, Stream ID [%c]\n",
+		dsp_cmd->cmd_code, 'A' + id);
 
 	return 0;
 }
 
 static int parse_cmd_h264_encode_start(struct ambarella_iav *iav, DSP_CMD *cmd)
 {
-	int id = 0;
 	int rval = 0;
 	h264_encode_t *dsp_cmd = (h264_encode_t *)cmd;
-	id = GET_STRAME_ID_CODE(dsp_cmd->cmd_code);
+	int id = GET_STRAME_ID_CODE(dsp_cmd->cmd_code);
+	int stream_height = 0, round_factor = 0, round_height = 0, margin = 0;
+	struct iav_stream *stream = &iav->stream[id];
+	struct iav_stream_format *format = &stream->format;
+	struct iav_h264_config *h264_config = &stream->h264_config;
 
 	if (dsp_cmd->encode_duration != ENCODE_DURATION_FOREVER) {
-		iav->stream[id].format.duration = dsp_cmd->encode_duration;
+		format->duration = dsp_cmd->encode_duration;
 	}
-	iav->stream[id].h264_config.au_type = dsp_cmd->au_type;
+	h264_config->au_type = dsp_cmd->au_type;
 	switch (dsp_cmd->profile) {
 	case 1:
-		iav->stream[id].h264_config.profile = H264_PROFILE_HIGH;
+		h264_config->profile = H264_PROFILE_HIGH;
 		break;
 	case 0:
-		iav->stream[id].h264_config.profile = H264_PROFILE_MAIN;
+		h264_config->profile = H264_PROFILE_MAIN;
 		break;
 	case 3:
-		iav->stream[id].h264_config.profile = H264_PROFILE_BASELINE;
+		h264_config->profile = H264_PROFILE_BASELINE;
 		break;
 	default:
 		rval = -1;
@@ -3306,53 +3551,74 @@ static int parse_cmd_h264_encode_start(struct ambarella_iav *iav, DSP_CMD *cmd)
 		break;
 	}
 
-	iav->stream[id].dsp_state = ENC_BUSY_STATE;
-	iav->stream[id].op = IAV_STREAM_OP_START;
-	iav->stream[id].format.type = IAV_STREAM_TYPE_H264;
-	inc_srcbuf_ref(iav->stream[id].srcbuf);
+	stream->dsp_state = ENC_BUSY_STATE;
+	stream->op = IAV_STREAM_OP_START;
+	format->type = IAV_STREAM_TYPE_H264;
+	h264_config->deblocking_filter_alpha = dsp_cmd->alpha;
+	h264_config->deblocking_filter_beta = dsp_cmd->beta;
+	h264_config->deblocking_filter_enable = dsp_cmd->en_loop_filter;
+	inc_srcbuf_ref(stream->srcbuf, id);
 
-	/*TODO: dsp_cmd->frame_crop_right_offset
-			dsp_cmd->frame_crop_bottom_offset
-			dsp_cmd->aspect_ratio_idc
+	/*TODO: dsp_cmd->aspect_ratio_idc
 			dsp_cmd->SAR_width
 			dsp_cmd->SAR_height */
+	stream_height = format->enc_win.height;
+	round_factor = ((is_vcap_interlaced(iav, 0)) ? (PIXEL_IN_MB << 1) : PIXEL_IN_MB);
+	round_height = ALIGN(stream_height, round_factor);
+	margin = round_height - stream_height;
+	margin = is_vcap_interlaced(iav, 0) ? (margin >> 2) : (margin >> 1);
+	if (format->rotate_cw) {
+		dsp_cmd->frame_crop_right_offset -= margin;
+	} else {
+		dsp_cmd->frame_crop_bottom_offset -= margin;
+	}
+	h264_config->frame_crop_left_offset =
+		dsp_cmd->frame_crop_left_offset << 1;
+	h264_config->frame_crop_right_offset =
+		dsp_cmd->frame_crop_right_offset << 1;
+	h264_config->frame_crop_top_offset =
+		dsp_cmd->frame_crop_top_offset << 1;
+	h264_config->frame_crop_bottom_offset =
+		dsp_cmd->frame_crop_bottom_offset << 1;
 
-	iav_debug ("cmd_code = 0x%08X, Stream ID [%c]\n", dsp_cmd->cmd_code, 'A' + id);
+	iav_debug ("cmd_code = 0x%08X, Stream ID [%c]\n",
+		dsp_cmd->cmd_code, 'A' + id);
 
 	return rval;
 }
 
 static int parse_cmd_jpeg_encode_setup(struct ambarella_iav *iav, DSP_CMD *cmd)
 {
-	int id = 0;
 	jpeg_encode_setup_t *dsp_cmd = (jpeg_encode_setup_t *)cmd;
-	id = GET_STRAME_ID_CODE(dsp_cmd->cmd_code);
+	int id = GET_STRAME_ID_CODE(dsp_cmd->cmd_code);
+	struct iav_stream *stream = &iav->stream[id];
 
-	iav->stream[id].mjpeg_config.chroma_format = dsp_cmd->chroma_format;
-	iav->stream[id].fps.fps_div = dsp_cmd->frame_rate_division_factor;
-	iav->stream[id].fps.fps_multi = dsp_cmd->frame_rate_multiplication_factor;
-	iav->stream[id].format.hflip = dsp_cmd->hflip;
-	iav->stream[id].format.vflip = dsp_cmd->vflip;
-	iav->stream[id].format.rotate_cw = dsp_cmd->rotate;
+	stream->mjpeg_config.chroma_format = dsp_cmd->chroma_format;
+	stream->fps.fps_div = dsp_cmd->frame_rate_division_factor;
+	stream->fps.fps_multi = dsp_cmd->frame_rate_multiplication_factor;
+	stream->format.hflip = dsp_cmd->hflip;
+	stream->format.vflip = dsp_cmd->vflip;
+	stream->format.rotate_cw = dsp_cmd->rotate;
 
-	iav_debug ("cmd_code = 0x%08X, Stream ID [%c]\n", dsp_cmd->cmd_code, 'A' + id);
+	iav_debug ("cmd_code = 0x%08X, Stream ID [%c]\n",
+		dsp_cmd->cmd_code, 'A' + id);
 
 	return 0;
 }
 
 static int parse_cmd_jpeg_encode_start(struct ambarella_iav *iav, DSP_CMD *cmd)
 {
-	int id = 0;
 	mjpeg_capture_t *dsp_cmd = (mjpeg_capture_t *)cmd;
-	id = GET_STRAME_ID_CODE(dsp_cmd->cmd_code);
+	int id = GET_STRAME_ID_CODE(dsp_cmd->cmd_code);
+	struct iav_stream *stream = &iav->stream[id];
 
 	if (dsp_cmd->encode_duration != ENCODE_DURATION_FOREVER) {
-		iav->stream[id].format.duration = dsp_cmd->encode_duration;
+		stream->format.duration = dsp_cmd->encode_duration;
 	}
-	iav->stream[id].dsp_state = ENC_BUSY_STATE;
-	iav->stream[id].op = IAV_STREAM_OP_START;
-	iav->stream[id].format.type = IAV_STREAM_TYPE_MJPEG;
-	inc_srcbuf_ref(iav->stream[id].srcbuf);
+	stream->dsp_state = ENC_BUSY_STATE;
+	stream->op = IAV_STREAM_OP_START;
+	stream->format.type = IAV_STREAM_TYPE_MJPEG;
+	inc_srcbuf_ref(stream->srcbuf, id);
 
 	iav_debug ("cmd_code = 0x%08X, Stream ID [%c]\n", dsp_cmd->cmd_code, 'A' + id);
 
@@ -3362,72 +3628,89 @@ static int parse_cmd_jpeg_encode_start(struct ambarella_iav *iav, DSP_CMD *cmd)
 static int parse_cmd_encode_param(struct ambarella_iav *iav, DSP_CMD *cmd)
 {
 	int i;
-	int id = 0;
-	ipcam_real_time_encode_param_setup_t *dsp_cmd = (ipcam_real_time_encode_param_setup_t *)cmd;
-	id = GET_STRAME_ID_CODE(dsp_cmd->cmd_code);
+	ipcam_real_time_encode_param_setup_t *dsp_cmd =
+		(ipcam_real_time_encode_param_setup_t *)cmd;
+	int id = GET_STRAME_ID_CODE(dsp_cmd->cmd_code);
+	struct iav_stream *stream = &iav->stream[id];
+	struct iav_stream_format *format = &stream->format;
+	struct iav_h264_config *h264_config = &stream->h264_config;
 
 	if (dsp_cmd->enable_flags & REALTIME_PARAM_QP_LIMIT_BIT) {
-		iav->stream[id].h264_config.qp_max_on_I = dsp_cmd->qp_max_on_I;
-		iav->stream[id].h264_config.qp_max_on_P = dsp_cmd->qp_max_on_P;
-		iav->stream[id].h264_config.qp_max_on_B = dsp_cmd->qp_max_on_B;
-		iav->stream[id].h264_config.qp_min_on_I = dsp_cmd->qp_min_on_I;
-		iav->stream[id].h264_config.qp_min_on_P = dsp_cmd->qp_min_on_P;
-		iav->stream[id].h264_config.qp_min_on_B = dsp_cmd->qp_min_on_B;
-		iav->stream[id].h264_config.adapt_qp = dsp_cmd->aqp;
-		iav->stream[id].h264_config.i_qp_reduce = dsp_cmd->i_qp_reduce;
-		iav->stream[id].h264_config.p_qp_reduce = dsp_cmd->p_qp_reduce;
-		iav->stream[id].h264_config.skip_flag = dsp_cmd->skip_flags;
+		h264_config->qp_max_on_I = dsp_cmd->qp_max_on_I;
+		h264_config->qp_max_on_P = dsp_cmd->qp_max_on_P;
+		h264_config->qp_max_on_B = dsp_cmd->qp_max_on_B;
+		h264_config->qp_max_on_Q = dsp_cmd->qp_max_on_Q;
+		h264_config->qp_min_on_I = dsp_cmd->qp_min_on_I;
+		h264_config->qp_min_on_P = dsp_cmd->qp_min_on_P;
+		h264_config->qp_min_on_B = dsp_cmd->qp_min_on_B;
+		h264_config->qp_min_on_Q = dsp_cmd->qp_min_on_Q;
+		h264_config->adapt_qp = dsp_cmd->aqp;
+		h264_config->i_qp_reduce = dsp_cmd->i_qp_reduce;
+		h264_config->p_qp_reduce = dsp_cmd->p_qp_reduce;
+		h264_config->q_qp_reduce = dsp_cmd->q_qp_reduce;
+		h264_config->log_q_num_plus_1 = dsp_cmd->log_q_num_per_gop_plus_1;
+		h264_config->skip_flag = dsp_cmd->skip_flags;
+		/* convert from bits to KB */
+		h264_config->max_I_size_KB = dsp_cmd->set_I_size >> 13;
 	}
 	if (dsp_cmd->enable_flags & REALTIME_PARAM_GOP_BIT) {
-		iav->stream[id].h264_config.idr_interval = dsp_cmd->idr_interval;
+		h264_config->N = (dsp_cmd->N_msb << 8) | dsp_cmd->N;
+		h264_config->idr_interval = dsp_cmd->idr_interval;
 	}
 	if (dsp_cmd->enable_flags & REALTIME_PARAM_QP_ROI_MATRIX_BIT) {
-		if ((dsp_cmd->roi_daddr) &&
-			(dsp_cmd->roi_daddr) &&
-			(dsp_cmd->roi_daddr)) {
-			iav->stream[id].h264_config.qp_roi_enable = 1;
+		if ((dsp_cmd->roi_daddr) && (dsp_cmd->roi_daddr_p)
+			&& (dsp_cmd->roi_daddr_b)) {
+			h264_config->qp_roi_enable = 1;
 		}
 		for (i = 0; i < NUM_PIC_TYPES; ++i) {
-			iav->stream[id].h264_config.qp_delta[i][0] = dsp_cmd->roi_delta[i][0];
-			iav->stream[id].h264_config.qp_delta[i][1] = dsp_cmd->roi_delta[i][1];
-			iav->stream[id].h264_config.qp_delta[i][2] = dsp_cmd->roi_delta[i][2];
-			iav->stream[id].h264_config.qp_delta[i][3] = dsp_cmd->roi_delta[i][3];
+			h264_config->qp_delta[i][0] = dsp_cmd->roi_delta[i][0];
+			h264_config->qp_delta[i][1] = dsp_cmd->roi_delta[i][1];
+			h264_config->qp_delta[i][2] = dsp_cmd->roi_delta[i][2];
+			h264_config->qp_delta[i][3] = dsp_cmd->roi_delta[i][3];
 		}
-		iav->stream[id].h264_config.user1_intra_bias = dsp_cmd->user1_intra_bias;
-		iav->stream[id].h264_config.user1_direct_bias = dsp_cmd->user1_direct_bias;
-		iav->stream[id].h264_config.user2_intra_bias = dsp_cmd->user2_intra_bias;
-		iav->stream[id].h264_config.user2_direct_bias = dsp_cmd->user2_direct_bias;
-		iav->stream[id].h264_config.user3_intra_bias = dsp_cmd->user3_intra_bias;
-		iav->stream[id].h264_config.user3_direct_bias = dsp_cmd->user3_direct_bias;
+		h264_config->user1_intra_bias = dsp_cmd->user1_intra_bias;
+		h264_config->user1_direct_bias = dsp_cmd->user1_direct_bias;
+		h264_config->user2_intra_bias = dsp_cmd->user2_intra_bias;
+		h264_config->user2_direct_bias = dsp_cmd->user2_direct_bias;
+		h264_config->user3_intra_bias = dsp_cmd->user3_intra_bias;
+		h264_config->user3_direct_bias = dsp_cmd->user3_direct_bias;
 	}
 	if (dsp_cmd->enable_flags & REALTIME_PARAM_MONOCHROME_BIT) {
-		if (iav->stream[id].format.type == IAV_STREAM_TYPE_H264) {
-			iav->stream[id].h264_config.chroma_format = dsp_cmd->is_monochrome;
+		if (format->type == IAV_STREAM_TYPE_H264) {
+			h264_config->chroma_format = dsp_cmd->is_monochrome;
 		} else {
 			if (dsp_cmd->is_monochrome) {
-				iav->stream[id].mjpeg_config.chroma_format = JPEG_CHROMA_MONO;
+				stream->mjpeg_config.chroma_format = JPEG_CHROMA_MONO;
 			}
 		}
 	}
 	if (dsp_cmd->enable_flags & REALTIME_PARAM_INTRA_BIAS_BIT) {
-		iav->stream[id].h264_config.intrabias_p = dsp_cmd->P_IntraBiasAdd;
-		iav->stream[id].h264_config.intrabias_b = dsp_cmd->B_IntraBiasAdd;
+		h264_config->intrabias_p = dsp_cmd->P_IntraBiasAdd;
+		h264_config->intrabias_b = dsp_cmd->B_IntraBiasAdd;
 	}
 	if (dsp_cmd->enable_flags & REALTIME_PARAM_ZMV_THRESHOLD_BIT) {
-		iav->stream[id].h264_config.zmv_threshold = dsp_cmd->zmv_threshold;
+		h264_config->zmv_threshold = dsp_cmd->zmv_threshold;
 	}
 	if (dsp_cmd->enable_flags & REALTIME_PARAM_FLAT_AREA_BIT) {
-		iav->stream[id].h264_config.enc_improve = dsp_cmd->flat_area_improvement_on;
+		h264_config->flat_area_improve =
+			dsp_cmd->flat_area_improvement_on;
 	}
 	if (dsp_cmd->enable_flags & REALTIME_PARAM_FRAME_DROP_BIT) {
-		iav->stream[id].h264_config.drop_frames = dsp_cmd->drop_frame;
+		h264_config->drop_frames = dsp_cmd->drop_frame;
+		h264_config->drop_frame_repeat = dsp_cmd->drop_frame_repeat;
+	}
+	if (dsp_cmd->enable_flags & REALTIME_PARAM_MV_DUMP_BIT) {
+		h264_config->statis = dsp_cmd->mvdump_enable;
+	}
+	if (dsp_cmd->enable_flags & REALTIME_PARAM_CUSTOM_FRAME_RATE_BIT) {
+		stream->fps.fps_div = dsp_cmd->frame_rate_division_factor;
+		stream->fps.fps_multi = dsp_cmd->frame_rate_multiplication_factor;
 	}
 	/* TODO: dsp_cmd->custom_encoder_frame_rate
-			 dsp_cmd->custom_vin_frame_rate
-			 dsp_cmd->idsp_frame_rate_M
-			 dsp_cmd->idsp_frame_rate_N */
+			 dsp_cmd->custom_vin_frame_rate */
 
-	iav_debug ("cmd_code = 0x%08X, Stream ID [%c]\n", dsp_cmd->cmd_code, 'A' + id);
+	iav_debug ("cmd_code = 0x%08X, Stream ID [%c]\n",
+		dsp_cmd->cmd_code, 'A' + id);
 
 	return 0;
 }
@@ -3444,8 +3727,8 @@ int parse_dsp_cmd_to_iav(struct ambarella_iav *iav)
 	dsp_init_data_t *dsp_init_data = NULL;
 
 	dsp_init_data = iav->dsp->get_dsp_init_data(iav->dsp);
-	cmd_data_phys = DSP_TO_PHYS(dsp_init_data->cmd_data_ptr);
-	cmd_data_virt = ioremap_nocache(cmd_data_phys, DSP_CMD_BUF_SIZE);
+	cmd_data_phys = DSP_TO_PHYS(dsp_init_data->default_config_ptr);
+	cmd_data_virt = ioremap_nocache(cmd_data_phys, DSP_DEF_CMD_BUF_SIZE);
 	if (!cmd_data_virt) {
 		iav_error("Failed to call ioremap() for dsp_cmd_data.\n");
 		return -ENOMEM;
diff --git a/drivers/iav/arch_s2l/iav_dsp_cmd.h b/drivers/iav/arch_s2l/iav_dsp_cmd.h
index 75eed54..175e580 100644
--- a/drivers/iav/arch_s2l/iav_dsp_cmd.h
+++ b/drivers/iav/arch_s2l/iav_dsp_cmd.h
@@ -5,42 +5,39 @@
  *	2013/04/24 - [Cao Rongrong] created file
  *	2013/12/12 - [Jian Tang] Modified file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #ifndef __IAV_DSP_CMD__
 #define __IAV_DSP_CMD__
 
 struct amb_dsp_cmd;
 
-enum {
-	REALTIME_PARAM_CBR_MODIFY_BIT = (1 << 0),
-	REALTIME_PARAM_CUSTOM_FRAME_RATE_BIT = (1 << 1),
-	REALTIME_PARAM_QP_LIMIT_BIT = (1 << 2),
-	REALTIME_PARAM_GOP_BIT = (1 << 3),
-	REALTIME_PARAM_CUSTOM_VIN_FPS_BIT = (1 << 4),
-	REALTIME_PARAM_INTRA_MB_ROWS_BIT = (1 << 5),
-	REALTIME_PARAM_PREVIEW_A_FRAME_RATE_BIT = (1 << 6),
-	REALTIME_PARAM_QP_ROI_MATRIX_BIT = (1 << 7),
-	REALTIME_PARAM_PANIC_MODE_BIT = (1 << 8),
-	REALTIME_PARAM_QUANT_MATRIX_BIT = (1 << 9),
-	REALTIME_PARAM_MONOCHROME_BIT = (1 << 10),
-	REALTIME_PARAM_INTRA_BIAS_BIT = (1 << 11),
-	REALTIME_PARAM_SCENE_DETECT_BIT = (1 << 12),
-	REALTIME_PARAM_FORCE_IDR_BIT = (1 << 13),
-	REALTIME_PARAM_ZMV_THRESHOLD_BIT = (1 << 14),
-	REALTIME_PARAM_FLAT_AREA_BIT = (1 << 15),
-	REALTIME_PARAM_FORCE_FAST_SEEK_BIT = (1 << 16),
-	REALTIME_PARAM_FRAME_DROP_BIT = (1 << 17),
-};
-
-int cmd_chip_selection(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd);
 int cmd_vin_timer_mode(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd);
 int cmd_set_vin_global_config(struct ambarella_iav *iav,
 		struct amb_dsp_cmd *cmd);
@@ -68,7 +65,8 @@ int cmd_update_encode_params(struct iav_stream *stream,
 // used for frame sync case
 int update_sync_encode_params(struct iav_stream *stream,
 		struct amb_dsp_cmd *cmd, u32 flags);
-int cmd_update_idsp_factor(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd);
+int cmd_update_vcap_params(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd,
+	u32 flags);
 
 int cmd_overlay_insert(struct iav_stream *stream, struct amb_dsp_cmd *cmd,
 		struct iav_overlay_insert *info);
@@ -84,24 +82,30 @@ int cmd_set_pm_mctf(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd, u32 dela
 int cmd_set_pm_bpc(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd);
 int cmd_bpc_setup(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd, struct iav_bpc_setup *bpc_setup);
 int cmd_static_bpc(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd, struct iav_bpc_fpn *bpc_fpn);
-int cmd_apply_frame_sync_cmd(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd, struct iav_apply_frame_sync * apply);
+int cmd_apply_frame_sync_cmd(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd, struct iav_apply_frame_sync * apply, u32 stream_map);
 
 int cmd_get_frm_buf_pool_info(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd, u32 buf_map);
 int cmd_efm_creat_frm_buf_pool(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd);
 int cmd_efm_req_frame_buf(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd);
-int cmd_efm_handshake(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd);
+int cmd_efm_handshake(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd, u8 next_is_last_frame);
 
 int cmd_hash_verification(struct ambarella_iav *iav, u8* input);
+int cmd_hash_verification_long(struct ambarella_iav *iav, u8* input);
 
 int cmd_reset_operation(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd);
 
 int cmd_h264_decoder_setup(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd, u8 decoder_id);
 int cmd_decode_stop(struct ambarella_iav *iav, u8 decoder_id, u8 stop_flag);
-int cmd_vout_video_setup(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd, u16 vout_id, u8 en, u8 src, u8 flip, u8 rotate, u16 offset_x, u16 offset_y, u16 width, u16 height);
-int cmd_rescale_postp(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd, u8 decoder_id, u16 center_x, u16 center_y);
-int cmd_playback_speed(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd, u8 decoder_id, u16 speed, u8 scan_mode, u8 direction);
-int cmd_h264_decode(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd, u8 decoder_id, u32 bits_fifo_start, u32 bits_fifo_end, u32 num_frames, u32 first_frame_display);
-int cmd_h264_decode_fifo_update(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd, u8 decoder_id, u32 bits_fifo_start, u32 bits_fifo_end, u32 num_frames);
+int cmd_vout_video_setup(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd,
+	struct iav_decode_vout_config *p_vout_config, u8 src, u8 is_interlace);
+int cmd_rescale_postp(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd,
+	u8 decoder_id, u16 center_x, u16 center_y);
+int cmd_playback_speed(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd,
+	u8 decoder_id, u16 speed, u8 scan_mode, u8 direction);
+int cmd_h264_decode(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd,
+	u8 decoder_id, u32 bits_fifo_start, u32 bits_fifo_end, u32 num_frames, u32 first_frame_display);
+int cmd_h264_decode_fifo_update(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd,
+	u8 decoder_id, u32 bits_fifo_start, u32 bits_fifo_end, u32 num_frames);
 int cmd_h264_trick_play(struct ambarella_iav *iav, struct amb_dsp_cmd *cmd, u8 decoder_id, u8 mode);
 
 /* used for Fastboot case */
diff --git a/drivers/iav/arch_s2l/iav_enc_api.c b/drivers/iav/arch_s2l/iav_enc_api.c
index 36a7e6f..fc17dfb 100644
--- a/drivers/iav/arch_s2l/iav_enc_api.c
+++ b/drivers/iav/arch_s2l/iav_enc_api.c
@@ -1,16 +1,35 @@
 /*
- * iav_enc.c
+ * iav_enc_api.c
  *
  * History:
  *	2012/04/13 - [Jian Tang] created file
- * Copyright (C) 2007-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <config.h>
 #include <plat/ambcache.h>
 #include <linux/random.h>
@@ -36,10 +55,10 @@ static struct iav_driver_version iav_driver_info =
 {
 	.arch = S2L,
 	.model = 1,
-	.major = 2,		/* SDK version 2.6.0 */
+	.major = 2,		/* SDK version 2.6.26 */
 	.minor = 6,
-	.patch = 0,
-	.mod_time = 0x20150922,
+	.patch = 26,
+	.mod_time = 0x20170825,
 	.description = "S2L Flexible Linux",
 	.api_version = API_REVISION_U32,
 	.idsp_version = IDSP_REVISION_U32,
@@ -112,6 +131,20 @@ static inline void irq_update_raw_enc_state(struct ambarella_iav *iav,
 	return ;
 }
 
+static inline void irq_update_vcap_state(struct ambarella_iav *iav,
+	encode_msg_t *enc_msg)
+{
+	if ((iav->vcap_state != iav->vcap_next_state) &&
+		(iav->vcap_next_state == enc_msg->vin_capture_state)) {
+		spin_lock(&iav->iav_lock);
+		iav->vcap_state = enc_msg->vin_capture_state;
+		wake_up_interruptible(&iav->vcap_state_wq);
+		spin_unlock(&iav->iav_lock);
+	}
+
+	return ;
+}
+
 static void handle_enc_msg(struct ambarella_iav *iav, DSP_MSG *msg)
 {
 	struct iav_stream *stream;
@@ -121,6 +154,7 @@ static void handle_enc_msg(struct ambarella_iav *iav, DSP_MSG *msg)
 	u32 fake_update_flag = 0;
 
 	irq_vsync_loss_detect(iav, enc_msg);
+	irq_update_vcap_state(iav, enc_msg);
 
 	for (i = 0; i < IAV_STREAM_MAX_NUM_ALL; ++i) {
 		stream = &iav->stream[i];
@@ -211,6 +245,23 @@ static void handle_hash_msg(struct ambarella_iav *iav, DSP_MSG *msg)
 	return ;
 }
 
+static void handle_hash_msg_ex(struct ambarella_iav *iav, DSP_MSG *msg)
+{
+	hash_verification_msg_ex_t *hash_msg = (hash_verification_msg_ex_t *)msg;
+
+	iav->hash_output[0] = hash_msg->hash_output[0];
+	iav->hash_output[1] = hash_msg->hash_output[1];
+	iav->hash_output[2] = hash_msg->hash_output[2];
+	iav->hash_output[3] = hash_msg->hash_output[3];
+
+	if (iav->wait_hash_msg) {
+		iav->hash_msg_cnt ++;
+		wake_up_interruptible(&iav->hash_wq);
+	}
+
+	return ;
+}
+
 static void handle_vcap_msg(void *data, DSP_MSG *msg)
 {
 	struct ambarella_iav *iav = data;
@@ -230,6 +281,9 @@ static void handle_vcap_msg(void *data, DSP_MSG *msg)
 	case DSP_STATUS_MSG_HASH_VERIFICATION:
 		handle_hash_msg(iav, msg);
 		break;
+	case DSP_STATUS_MSG_HASH_VERIFICATION_EX:
+		handle_hash_msg_ex(iav, msg);
+		break;
 	case DSP_STATUS_MSG_DECODE:
 	default:
 		iav_error("Invalid message status [%u] for encode mode.\n",
@@ -239,7 +293,7 @@ static void handle_vcap_msg(void *data, DSP_MSG *msg)
 }
 
 
-static int enter_preview_state(struct ambarella_iav *iav, u32 is_resume)
+static int enter_preview_state(struct ambarella_iav *iav)
 {
 	struct dsp_device *dsp = iav->dsp;
 	struct amb_dsp_cmd *first, *cmd;
@@ -253,16 +307,13 @@ static int enter_preview_state(struct ambarella_iav *iav, u32 is_resume)
 		return -ENOMEM;
 
 	/* VOUT configuration. It must run in the beginning. */
-	if (iav->dsp_enc_state != DSP_ENCODE_MODE || is_resume == 1) {
+	if (iav->dsp_enc_state != DSP_ENCODE_MODE || iav->resume_flag == 1) {
 		iav_config_vout(VOUT_SRC_ENC);
 	} else {
 		iav_change_vout_src(VOUT_SRC_ENC);
 	}
 
 	cmd = first;
-	cmd_chip_selection(iav, cmd);
-
-	get_next_cmd(cmd, first);
 	cmd_system_info_setup(iav, cmd, 0);
 
 	get_next_cmd(cmd, first);
@@ -294,7 +345,8 @@ static int enter_preview_state(struct ambarella_iav *iav, u32 is_resume)
 	}
 
 	for (i = IAV_SUB_SRCBUF_FIRST; i < IAV_SUB_SRCBUF_LAST; ++i) {
-		if ((iav->srcbuf[i].type == IAV_SRCBUF_TYPE_ENCODE) &&
+		if (((iav->srcbuf[i].type == IAV_SRCBUF_TYPE_ENCODE) ||
+			(iav->srcbuf[i].type == IAV_SRCBUF_TYPE_VCA)) &&
 			iav->srcbuf[i].max.width) {
 			get_next_cmd(cmd, first);
 			cmd_capture_buffer_default_setup(iav, cmd, i);
@@ -311,16 +363,17 @@ static int enter_preview_state(struct ambarella_iav *iav, u32 is_resume)
 
 	if (iav->dsp_enc_state != DSP_ENCODE_MODE) {
 		/* enter preview from bootup stage or other mode, like DECODE */
-		dsp->set_op_mode(dsp, DSP_ENCODE_MODE, first);
+		dsp->set_op_mode(dsp, DSP_ENCODE_MODE, first, iav->fast_resume);
 		iav->dsp_enc_state = DSP_ENCODE_MODE;
 	} else {
 		/* re-enter preview again */
-		dsp->set_enc_sub_mode(dsp, VIDEO_MODE, first, 0);
+		dsp->set_enc_sub_mode(dsp, VIDEO_MODE, first, iav->fast_resume, 0);
 	}
 
 	/* Config capture buffer resolution after entering preview for SMEM */
 	for (i = IAV_SUB_SRCBUF_FIRST; i < IAV_SUB_SRCBUF_LAST; ++i) {
-		if ((iav->srcbuf[i].type == IAV_SRCBUF_TYPE_ENCODE) &&
+		if (((iav->srcbuf[i].type == IAV_SRCBUF_TYPE_ENCODE) ||
+			(iav->srcbuf[i].type == IAV_SRCBUF_TYPE_VCA)) &&
 			iav->srcbuf[i].max.width) {
 			cmd_capture_buffer_setup(iav, NULL, i);
 		}
@@ -337,6 +390,7 @@ static void update_default_param_before_preview(struct ambarella_iav *iav,
 	struct iav_buffer * main_buffer, * buffer;
 	u32 encode_mode = iav->encode_mode;
 	struct iav_system_config *config = &iav->system_config[encode_mode];
+	struct iav_rect main_output;
 
 	/* default pre main input = vin */
 	buffer = &iav->srcbuf[IAV_SRCBUF_PMN];
@@ -374,16 +428,19 @@ static void update_default_param_before_preview(struct ambarella_iav *iav,
 		}
 	}
 
-	/* TODO: clear all dewarp params */
-	memset(iav->warp, 0, sizeof(struct iav_warp_main));
+	/* Clear all dewarp params */
+	if (likely(!iav->resume_flag)) {
+		memset(iav->warp, 0, sizeof(struct iav_warp_main));
+	}
 
 	/* Update warp aspect ratio */
 	switch (encode_mode) {
 	case DSP_ADVANCED_ISO_MODE:
 		if (config->lens_warp) {
-			update_warp_aspect_ratio(IAV_SRCBUF_MN, 0,
-				&iav->vinc[0]->vin_format.vin_win,
-				(struct iav_rect *)&iav->srcbuf[IAV_SRCBUF_MN].win);
+			memset(&main_output, 0, sizeof(main_output));
+			main_output.width = iav->srcbuf[IAV_SRCBUF_MN].win.width;
+			main_output.height = iav->srcbuf[IAV_SRCBUF_MN].win.height;
+			update_warp_aspect_ratio(IAV_SRCBUF_MN, 0, &main_buffer->input, &main_output);
 		}
 		break;
 	default:
@@ -398,6 +455,9 @@ static int iav_cross_check_vin(struct ambarella_iav *iav, struct iav_rect *vin)
 	struct iav_window * main_win = NULL;
 	struct iav_rect * input = NULL;
 	struct iav_enc_limitation * limit = NULL;
+	struct iav_system_config * config = NULL;
+	u8 hdr_mode = iav->vinc[0]->dev_active->cur_format->hdr_mode;
+	struct iav_vin_format *vin_format = &iav->vinc[0]->vin_format;
 
 	enc_mode = iav->encode_mode;
 	limit = &G_encode_limit[enc_mode];
@@ -410,12 +470,35 @@ static int iav_cross_check_vin(struct ambarella_iav *iav, struct iav_rect *vin)
 		return -1;
 	}
 
+
+	/* check vin hdr-mode when set expo_num in iav */
+	config = &iav->system_config[enc_mode];
+	if (config->expo_num > MIN_HDR_EXPOSURES) {
+		if ((config->expo_num - hdr_mode) != 1) {
+			iav_error("The hdr-mode is [%d], the hdr-expo is [%d].\n", hdr_mode,
+				config->expo_num);
+			return -1;
+		}
+	}
+
+	/* error if vin width are not aligned to 32 when raw_capture is disable */
+	if (!config->raw_capture && !config->enc_raw_yuv && (vin->width & 0x1F)) {
+		iav_error("vin width %d must be multiple of 32.\n", vin->width);
+		return -1;
+	}
+	/* error if vin width are not aligned to 16 when raw_capture is enable */
+	if (config->raw_capture && (vin->width & 0x0F)) {
+		iav_error("vin width %d must be multiple of 16.\n", vin->width);
+		return -1;
+	}
+
 	is_pre_main = (enc_mode == DSP_MULTI_REGION_WARP_MODE);
 	buf_id = is_pre_main ? IAV_SRCBUF_PMN : IAV_SRCBUF_MN;
 	main_win = &iav->srcbuf[buf_id].win;
 	input = &iav->srcbuf[buf_id].input;
 
-	if (!iav->system_config[enc_mode].enc_raw_yuv) {
+	if (!iav->system_config[enc_mode].enc_raw_yuv &&
+		vin_format->input_format != AMBA_VIN_INPUT_FORMAT_YUV_422_PROG) {
 		pm_unit = get_pm_unit(iav);
 		/* error if VIN width is not 32 pixels aligned while PM is BPP type */
 		if ((pm_unit == IAV_PM_UNIT_PIXEL) &&
@@ -424,6 +507,7 @@ static int iav_cross_check_vin(struct ambarella_iav *iav, struct iav_rect *vin)
 				"1bpp type in mode %d.\n", vin->width, enc_mode);
 			return -1;
 		}
+
 		/* error if pre-main / main > VIN */
 		if ((main_win->width > ALIGN(vin->width, PIXEL_IN_MB)) ||
 			(main_win->height > ALIGN(vin->height, PIXEL_IN_MB))) {
@@ -446,7 +530,7 @@ static int iav_cross_check_vin(struct ambarella_iav *iav, struct iav_rect *vin)
 		return -1;
 	}
 
-	if (check_main_buffer_input(is_pre_main, input, vin) < 0) {
+	if (check_main_buffer_input(iav, is_pre_main, input, vin) < 0) {
 		return -1;
 	}
 
@@ -491,6 +575,8 @@ static int cross_check_resource_in_mode(struct ambarella_iav *iav)
 {
 	u32 encode_mode = iav->encode_mode;
 	struct iav_system_config *config = &iav->system_config[encode_mode];
+	struct iav_stream *stream;
+	int i;
 
 	switch (encode_mode) {
 	case DSP_MULTI_REGION_WARP_MODE:
@@ -505,6 +591,23 @@ static int cross_check_resource_in_mode(struct ambarella_iav *iav)
 			return -1;
 		}
 		break;
+	case DSP_ADVANCED_ISO_MODE:
+		if ((config->lens_warp == 1) &&
+			((iav->srcbuf[IAV_SRCBUF_PB].type == IAV_SRCBUF_TYPE_PREVIEW) ||
+			(iav->srcbuf[IAV_SRCBUF_PA].type == IAV_SRCBUF_TYPE_PREVIEW))) {
+			for (i = 0; i < IAV_MAX_ENCODE_STREAMS_NUM; ++i) {
+				/* B frame and lens warp check */
+				stream = &iav->stream[i];
+				if (stream->max_GOP_M > 1) {
+					iav_error("Stream %c cannot set max gop M [%d] larger "
+						"than 1 to support B frame, when lens_warp & VOUT is enabled.\n",
+						'A' + i, stream->max_GOP_M );
+					return -1;
+				}
+			}
+		}
+
+		break;
 	default:
 		break;
 	}
@@ -572,6 +675,17 @@ static int iav_check_vout(struct ambarella_iav *iav)
 		return -1;
 	}
 
+	if (iav->pvoutinfo[0]->enabled && (iav->pvoutinfo[0]->active_mode.display_input ==
+		AMBA_VOUT_INPUT_FROM_MIXER) && iav->osd_from_mixer_a) {
+		iav_error("OSD from mixer A cannot be used when VOUT from Mixer A is used!\n");
+		return -1;
+	}
+	if (iav->pvoutinfo[1]->enabled && (iav->pvoutinfo[1]->active_mode.display_input ==
+		AMBA_VOUT_INPUT_FROM_MIXER) && iav->osd_from_mixer_b) {
+		iav_error("OSD from mixer B cannot be used when VOUT from Mixer B is used!\n");
+		return -1;
+	}
+
 #if 0	// Fixme: comment out the strictest check for VOUT and preview buffers
 	if (iav->pvoutinfo[0]->enabled &&
 		(iav->srcbuf[IAV_SRCBUF_PA].type != IAV_SRCBUF_TYPE_PREVIEW)) {
@@ -592,6 +706,46 @@ static int iav_check_vout(struct ambarella_iav *iav)
 	return 0;
 }
 
+static int check_vin_resource_limit(struct ambarella_iav *iav)
+{
+	u32 chip_id, chip_idx;
+	u32 vin_pps;
+	u32 vin_pps_limit;
+	int vin_fps;
+	u32 vin_width, vin_height;
+	struct iav_rect *vin_win;
+
+	iav_no_check();
+
+	get_vin_win(iav, &vin_win, 1);
+	vin_width = ALIGN(vin_win->width, PIXEL_IN_MB);
+	vin_height = ALIGN(vin_win->height, PIXEL_IN_MB);
+
+	if (iav->vinc[0]->vin_format.frame_rate == 0) {
+		iav_error("Divider of frame_rate can not be zero\n");
+		return -1;
+	}
+	vin_fps = DIV_CLOSEST(512000000, iav->vinc[0]->vin_format.frame_rate);
+
+	chip_id = get_chip_id(iav);
+	if (chip_id < IAV_CHIP_ID_S2LM_FIRST ||
+		chip_id >= IAV_CHIP_ID_S2L_LAST) {
+		iav_error("Invalid S2L chip ID [%d].\n", chip_id);
+		chip_id = IAV_CHIP_ID_S2L_99;
+	}
+
+	vin_pps = vin_width * vin_height * vin_fps;
+
+	chip_idx = chip_id - IAV_CHIP_ID_S2LM_FIRST;
+	vin_pps_limit = G_system_load[chip_idx].vin_pps;
+	if (vin_pps > vin_pps_limit) {
+		iav_warn("Total vin pps %d exceed except pps %d (%s).\n",
+			vin_pps, vin_pps_limit, G_system_load[chip_idx].vin_pps_desc);
+	}
+
+	return 0;
+}
+
 static int iav_check_before_enter_preview(struct ambarella_iav *iav, struct iav_rect *vin)
 {
 	iav_no_check();
@@ -612,6 +766,12 @@ static int iav_check_before_enter_preview(struct ambarella_iav *iav, struct iav_
 		return -1;
 	}
 
+	/* check total vin performance limit */
+	if (check_vin_resource_limit(iav) < 0) {
+		iav_error("Cannot start preview, system resource is not enough.\n");
+		return -1;
+	}
+
 	if (iav_check_sys_mem_usage(iav, (int)IAV_STATE_PREVIEW, 0) < 0) {
 		return -1;
 	}
@@ -629,7 +789,8 @@ static int update_default_param_after_preview(struct ambarella_iav *iav)
 	int rval = 0;
 
 	/* use iav mem info to fill dsp default binary address for encoding */
-	iav_reset_pm(iav);
+	if (!iav->resume_flag)
+		iav_reset_pm(iav);
 
 	/* DSP partitions physical address may be updated after preview*/
 	if (iav->dsp_map_updated || iav->dsp_partition_mapped) {
@@ -647,16 +808,24 @@ static int update_default_param_after_preview(struct ambarella_iav *iav)
 
 	iav->state = IAV_STATE_PREVIEW;
 
+	/* Resend IDSP upsampling config */
+	rval = cmd_update_vcap_params(iav, NULL, REALTIME_PARAM_CUSTOM_VIN_FPS_BIT);
+	if (rval < 0) {
+		iav_error("Failed to Update IDSP upsampling config!\n");
+		return rval;
+	}
+
 	return rval;
 }
 
 
-int iav_enable_preview(struct ambarella_iav *iav, u32 is_resume)
+int iav_enable_preview(struct ambarella_iav *iav)
 {
 	int rval = 0;
 	struct iav_rect *vin;
 	u8 enc_mode = iav->encode_mode;
 	u8 eis_delay_count = iav->system_config[enc_mode].eis_delay_count;
+	struct iav_nl_obj * nl_obj = &iav->nl_obj[NL_OBJ_IMAGE];
 
 	if (iav->state == IAV_STATE_PREVIEW)
 		return 0;
@@ -676,19 +845,16 @@ int iav_enable_preview(struct ambarella_iav *iav, u32 is_resume)
 			break;
 		}
 
-		if ((iav->nl_obj[NL_OBJ_IMAGE].nl_connected == 1) &&
-			(is_resume == 0)) {
-			rval = nl_send_request(&iav->nl_obj[NL_OBJ_IMAGE],
-				NL_REQ_IMG_PREPARE_AAA);
+		if ((nl_obj->nl_connected == 1) &&
+			(iav->resume_flag == 0)) {
+			rval = nl_send_request(nl_obj, NL_REQ_IMG_PREPARE_AAA);
 			if (rval < 0) {
-				iav->nl_obj[NL_OBJ_IMAGE].nl_connected = 0;
-				iav_error("iav netlink disconnected.\n");
 				rval = -EPERM;
 				break;
 			}
 		}
 
-		enter_preview_state(iav, is_resume);
+		enter_preview_state(iav);
 		if (unlikely(iav->err_vsync_again)) {
 			iav_error("Vsync loss in entering preview. Abort rest cmds.\n");
 			rval = -EAGAIN;
@@ -701,17 +867,10 @@ int iav_enable_preview(struct ambarella_iav *iav, u32 is_resume)
 			wait_vcap_count(iav, eis_delay_count);
 		}
 
-		if ((iav->nl_obj[NL_OBJ_IMAGE].nl_connected == 1) &&
+		if ((nl_obj->nl_connected == 1) &&
 			likely(!iav->err_vsync_again) &&
-			(is_resume == 0)) {
-			rval = nl_send_request(&iav->nl_obj[NL_OBJ_IMAGE],
-				NL_REQ_IMG_START_AAA);
-			if (rval < 0) {
-				iav->nl_obj[NL_OBJ_IMAGE].nl_connected = 0;
-				iav_error("iav netlink disconnected.\n");
-				rval = -EPERM;
-				break;
-			}
+			(iav->resume_flag == 0)) {
+			rval = nl_send_request(nl_obj, NL_REQ_IMG_START_AAA);
 		}
 	} while (0);
 	mutex_unlock(&iav->iav_mutex);
@@ -745,17 +904,12 @@ int iav_disable_preview(struct ambarella_iav *iav)
 	if (iav->nl_obj[NL_OBJ_IMAGE].nl_connected) {
 		rval = nl_send_request(&iav->nl_obj[NL_OBJ_IMAGE],
 			NL_REQ_IMG_STOP_AAA);
-		if (rval < 0) {
-			iav->nl_obj[NL_OBJ_IMAGE].nl_connected = 0;
-			iav_error("iav netlink disconnected.\n");
-			rval = 0;
-		}
 	}
 
 	iav->state = IAV_STATE_EXITING_PREVIEW;
 	cmd_vin_timer_mode(iav, cmd);
 	/* Wait for DSP to enter IDLE mode */
-	dsp->set_enc_sub_mode(dsp, TIMER_MODE, cmd, 0);
+	dsp->set_enc_sub_mode(dsp, TIMER_MODE, cmd, 0, 0);
 	iav->state = IAV_STATE_IDLE;
 	mutex_unlock(&iav->iav_mutex);
 
@@ -780,14 +934,14 @@ static inline int update_bsb_addr_in_dsp_init_data(struct ambarella_iav *iav)
 inline int iav_boot_dsp_action(struct ambarella_iav *iav)
 {
 	update_bsb_addr_in_dsp_init_data(iav);
-	iav->dsp->set_op_mode(iav->dsp, DSP_ENCODE_MODE, NULL);
+	iav->dsp->set_op_mode(iav->dsp, DSP_ENCODE_MODE, NULL, iav->resume_flag);
 	iav->dsp_enc_state = DSP_ENCODE_MODE;
 	iav->state = IAV_STATE_IDLE;
 
 	return 0;
 }
 
-static int iav_goto_timer_mode(struct ambarella_iav *iav)
+int iav_goto_timer_mode(struct ambarella_iav *iav)
 {
 	struct dsp_device *dsp = iav->dsp;
 	struct amb_dsp_cmd *cmd;
@@ -796,7 +950,7 @@ static int iav_goto_timer_mode(struct ambarella_iav *iav)
 	mutex_lock(&iav->iav_mutex);
 	// update bsb addr for encode mode
 	update_bsb_addr_in_dsp_init_data(iav);
-	rval = dsp->set_op_mode(dsp, DSP_ENCODE_MODE, NULL);
+	rval = dsp->set_op_mode(dsp, DSP_ENCODE_MODE, NULL, 0);
 	if (rval < 0) {
 		iav_error("set_op_mode(DSP_ENCODE_MODE) fail\n");
 		mutex_unlock(&iav->iav_mutex);
@@ -812,7 +966,7 @@ static int iav_goto_timer_mode(struct ambarella_iav *iav)
 		return -ENOMEM;
 	}
 	cmd_vin_timer_mode(iav, cmd);
-	dsp->set_enc_sub_mode(dsp, TIMER_MODE, cmd, 1);
+	dsp->set_enc_sub_mode(dsp, TIMER_MODE, cmd, 0, 1);
 
 	iav->state = IAV_STATE_IDLE;
 	mutex_unlock(&iav->iav_mutex);
@@ -868,6 +1022,100 @@ static int iav_goto_idle(struct ambarella_iav *iav)
 	return rval;
 }
 
+static int iav_ioc_set_vcap_state(struct ambarella_iav *iav, int state)
+{
+	int rval = 0;
+
+	if (iav->state != IAV_STATE_PREVIEW &&
+		iav->state != IAV_STATE_ENCODING) {
+		iav_error("Improper IAV state %d to set vin capture state, should be "
+			"in Preview/Encoding state!\n", iav->state);
+		return -EPERM;
+	} else if (iav->encode_mode != DSP_NORMAL_ISO_MODE &&
+		iav->encode_mode != DSP_BLEND_ISO_MODE &&
+		iav->encode_mode != DSP_ADVANCED_ISO_MODE &&
+		iav->encode_mode != DSP_HDR_LINE_INTERLEAVED_MODE) {
+		iav_error("Unsupported encode mode %d to set vin capture state, "
+			"should be mode [%d|%d|%d|%d]!\n", iav->encode_mode,
+			DSP_NORMAL_ISO_MODE, DSP_BLEND_ISO_MODE, DSP_ADVANCED_ISO_MODE,
+			DSP_HDR_LINE_INTERLEAVED_MODE);
+		return -EPERM;
+	} else if (state == iav->vcap_state) {
+		return 0;
+	}
+
+	// Reset VIN before resuming VIN capture
+	if (state == IAV_VCAP_STATE_ACTIVE) {
+		if (iav->dsp->reset_vin != NULL) {
+			iav->dsp->reset_vin();
+		} else {
+			iav_debug("Failed to reset VIN, when the function is NULL!\n");
+		}
+	}
+	iav->vcap_next_state = state;
+	cmd_update_vcap_params(iav, NULL, REALTIME_PARAM_VIN_CAP_STATE);
+	if(wait_event_interruptible_timeout(iav->vcap_state_wq,
+		(iav->vcap_next_state == iav->vcap_state), FIVE_JIFFIES) <= 0) {
+		iav_error("Wait vin capture state timeout!\n");
+		rval = -EFAULT;
+	}
+
+	return rval;
+}
+
+
+int iav_ioc_set_vcap_cfg(struct ambarella_iav *iav, void __user *arg)
+{
+	struct iav_vcap_cfg cfg;
+	int rval = 0;
+
+	if (copy_from_user(&cfg, arg, sizeof(cfg)))
+		return -EFAULT;
+
+	mutex_lock(&iav->iav_mutex);
+
+	switch (cfg.cid) {
+	case IAV_VCAP_CFG_STATE:
+		rval = iav_ioc_set_vcap_state(iav, cfg.arg.state);
+		break;
+	default:
+		iav_error("Unknown cid: %d!\n", cfg.cid);
+		rval = -EINVAL;
+		break;
+	}
+
+	mutex_unlock(&iav->iav_mutex);
+
+	return rval;
+}
+
+int iav_ioc_get_vcap_cfg(struct ambarella_iav *iav, void __user *args)
+{
+	struct iav_vcap_cfg cfg;
+
+	if (copy_from_user(&cfg, args, sizeof(cfg)))
+		return -EFAULT;
+
+	mutex_lock(&iav->iav_mutex);
+
+	switch (cfg.cid) {
+	case IAV_VCAP_CFG_STATE:
+		cfg.arg.state = iav->vcap_state;
+		break;
+	default:
+		mutex_unlock(&iav->iav_mutex);
+		iav_error("Unknown cid: %d!\n", cfg.cid);
+		return -EINVAL;
+	}
+
+	mutex_unlock(&iav->iav_mutex);
+
+	if (copy_to_user(args, &cfg, sizeof(cfg)))
+		return -EFAULT;
+
+	return 0;
+}
+
 static inline int iav_ioc_g_chip_id(struct ambarella_iav *iav, u32 __user *arg)
 {
 	struct dsp_device *dsp = iav->dsp;
@@ -916,12 +1164,13 @@ static inline int iav_ioc_g_drvdspinfo(struct ambarella_iav *iav, void __user *a
 		return -EPERM;
 	}
 
-	ret = wait_event_interruptible_timeout(iav->hash_wq, (pre_hash_cnt != iav->hash_msg_cnt), TWO_JIFFIES);
+	ret = wait_event_interruptible_timeout(iav->hash_wq,
+		(pre_hash_cnt != iav->hash_msg_cnt), TWO_JIFFIES);
 	iav->wait_hash_msg = 0;
 	if (0 > ret) {
 		iav_error("can not wait hash msg\n");
 		mutex_unlock(&iav->hash_mutex);
-		return -EPERM;
+		return -EINTR;
 	}
 
 	memcpy(iavdsp_info.dspout, iav->hash_output, 4);
@@ -934,6 +1183,72 @@ static inline int iav_ioc_g_drvdspinfo(struct ambarella_iav *iav, void __user *a
 	return 0;
 }
 
+static inline int iav_ioc_get_dsp_hash(struct ambarella_iav *iav, void __user *arg)
+{
+	struct iav_dsp_hash dsp_hash;
+	int ret = 0;
+	u32 pre_hash_cnt = 0;
+
+	if (copy_from_user(&dsp_hash, arg, sizeof(dsp_hash))) {
+		return -EFAULT;
+	}
+
+	mutex_lock(&iav->hash_mutex);
+	memset(iav->hash_output, 0x0, sizeof(iav->hash_output));
+
+	iav->wait_hash_msg = 1;
+	pre_hash_cnt = iav->hash_msg_cnt;
+
+	if (0 > cmd_hash_verification_long(iav, dsp_hash.input)) {
+		iav->wait_hash_msg = 0;
+		mutex_unlock(&iav->hash_mutex);
+		return -EPERM;
+	}
+
+	ret = wait_event_interruptible_timeout(iav->hash_wq,
+		(pre_hash_cnt != iav->hash_msg_cnt), TWO_JIFFIES);
+	iav->wait_hash_msg = 0;
+	if (0 > ret) {
+		iav_error("can not wait hash msg\n");
+		mutex_unlock(&iav->hash_mutex);
+		return -EINTR;
+	}
+
+	memcpy(dsp_hash.output, iav->hash_output, 4);
+	mutex_unlock(&iav->hash_mutex);
+
+	if (copy_to_user(arg, &dsp_hash, sizeof(dsp_hash))) {
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static int iav_ioc_s_dsp_clock_state(struct ambarella_iav *iav, void __user *arg)
+{
+	struct dsp_device *dsp = iav->dsp;
+	u32 state = 0;
+
+	state = (u32)arg;
+
+	if (iav->state != IAV_STATE_IDLE) {
+		iav_error("Only can set dsp clcok state in IDLE!\n");
+		return -EPERM;
+	}
+
+	switch (state) {
+	case DSP_CLOCK_NORMAL_STATE:
+	case DSP_CLOCK_OFF_STATE:
+		dsp->set_clock_state(DSP_CLK_TYPE_IDSP, !state);
+		break;
+	default:
+		iav_error("Invalid DSP clock state: %d!", state);
+		break;
+	}
+
+	return 0;
+}
+
 static inline int iav_ioc_wait_next_frame(struct ambarella_iav *iav)
 {
 	int rval = 0;
@@ -971,9 +1286,11 @@ static int iav_ioc_g_query_buf(struct ambarella_iav *iav, void __user *args)
 	switch (querybuf.buf) {
 	case IAV_BUFFER_BSB:
 	case IAV_BUFFER_USR:
+	case IAV_BUFFER_MV:
 	case IAV_BUFFER_OVERLAY:
 	case IAV_BUFFER_QUANT:
 	case IAV_BUFFER_IMG:
+	case IAV_BUFFER_VCA:
 	case IAV_BUFFER_DSP:
 		querybuf.offset = iav->mmap[querybuf.buf].phys;
 		querybuf.length = iav->mmap[querybuf.buf].size;
@@ -984,23 +1301,25 @@ static int iav_ioc_g_query_buf(struct ambarella_iav *iav, void __user *args)
 		break;
 	case IAV_BUFFER_WARP:
 		querybuf.offset = iav->mmap[querybuf.buf].phys;
-		querybuf.length = WARP_VECT_PART_SIZE;
+		querybuf.length = iav->mmap[querybuf.buf].size ? WARP_VECT_PART_SIZE : 0;
 		break;
 	case IAV_BUFFER_PM_BPC:
 		querybuf.offset = iav->mmap[querybuf.buf].phys;
-		querybuf.length = PM_BPC_PARTITION_SIZE;
+		querybuf.length = iav->mmap[querybuf.buf].size ? PM_BPC_PARTITION_SIZE : 0;
 		break;
 	case IAV_BUFFER_BPC:
-		querybuf.offset = iav->mmap[querybuf.buf].phys + PAGE_SIZE;
-		querybuf.length = PM_BPC_PARTITION_SIZE;
+		querybuf.offset =
+			iav->mmap[querybuf.buf].size ? (iav->mmap[querybuf.buf].phys + PAGE_SIZE) : 0;
+		querybuf.length =
+			iav->mmap[querybuf.buf].size ? PM_BPC_PARTITION_SIZE : 0;
 		break;
 	case IAV_BUFFER_CMD_SYNC:
 		querybuf.offset = iav->mmap[querybuf.buf].phys;
-		querybuf.length = CMD_SYNC_TOTAL_SIZE;
+		querybuf.length = iav->mmap[querybuf.buf].size ? CMD_SYNC_TOTAL_SIZE : 0;
 		break;
 	case IAV_BUFFER_PM_MCTF:
 		querybuf.offset = iav->mmap[querybuf.buf].phys;
-		querybuf.length = PM_MCTF_TOTAL_SIZE;
+		querybuf.length = iav->mmap[querybuf.buf].size ? PM_MCTF_TOTAL_SIZE : 0;
 		break;
 	case IAV_BUFFER_FB_DATA:
 		querybuf.offset = iav->mmap[querybuf.buf].phys;
@@ -1154,6 +1473,7 @@ static int check_sys_resource_general(struct iav_system_resource * resource)
 	if (resource->idsp_upsample_type < IDSP_UPSAMPLE_TYPE_OFF ||
 		resource->idsp_upsample_type >= IDSP_UPSAMPLE_TYPE_TOTAL_NUM){
 		iav_error("Invaid idsp upsample type [%d]\n", resource->idsp_upsample_type);
+		return -1;
 	}
 	if (resource->idsp_upsample_type > IDSP_UPSAMPLE_TYPE_OFF &&
 		!limit->idsp_upsample_supported) {
@@ -1365,22 +1685,22 @@ static int check_sys_resource_general(struct iav_system_resource * resource)
 					resource->stream_max_size[i].width,
 					MAX_WIDTH_FOR_TWO_REF);
 				return -1;
-			} else if (resource->rotate_enable) {
-				iav_error("Stream %c cannot set max gop M [%d] larger "
-					"than 1, when stream rotation is enabled.\n",
-					'A' + i, resource->stream_max_M[i]);
-				return -1;
-			} else if (resource->lens_warp_enable == 1 &&
-					resource->stream_long_ref_enable[i] == 0) {
-				iav_error("Stream %c cannot set max gop M [%d] larger "
-					"than 1 to support B frame, when lens_warp is enabled.\n",
-					'A' + i, resource->stream_max_M[i]);
-				return -1;
 			}
 		}
 		if (resource->stream_long_ref_enable[i] > 1) {
 			iav_error("Stream %c's long term reference enable [%d] should be "
-				"[0|1].\n", 'A' + i, resource->stream_long_ref_enable[0]);
+				"[0|1].\n", 'A' + i, resource->stream_long_ref_enable[i]);
+			return -1;
+		}
+	}
+	if (resource->long_ref_b_frame > 1) {
+		iav_error("Long term B frame [%d] should be [0|1].\n",
+			resource->long_ref_b_frame);
+		return -1;
+	} else {
+		if (resource->long_ref_b_frame && !limit->long_ref_b_supported) {
+			iav_error("Encode mode %d cannot support B frame for long term "
+				"reference case!\n", enc_mode);
 			return -1;
 		}
 	}
@@ -1394,12 +1714,12 @@ static int check_sys_resource_general(struct iav_system_resource * resource)
 	return 0;
 }
 
-static int check_sys_resource_buffer(struct iav_system_resource *resource)
+static int check_sys_resource_buffer(struct ambarella_iav *iav, struct iav_system_resource *resource)
 {
 	int buf_id;
 	u32 enc_mode = resource->encode_mode;
 	struct iav_enc_limitation * limit = &G_encode_limit[resource->encode_mode];
-	struct iav_window * max, * prop, * main_win;
+	struct iav_window * max, prop, * main_win;
 
 	/* error if main max > max limit */
 	buf_id = IAV_SRCBUF_MN;
@@ -1416,12 +1736,26 @@ static int check_sys_resource_buffer(struct iav_system_resource *resource)
 
 	for (buf_id = IAV_SRCBUF_FIRST; buf_id < IAV_SRCBUF_LAST; ++buf_id) {
 		max = &resource->buf_max_size[buf_id];
-		prop = &G_buffer_limit[buf_id].max_win;
+		prop = G_buffer_limit[buf_id].max_win;
+		if ((buf_id == IAV_SRCBUF_PA) || (buf_id == IAV_SRCBUF_PB)) {
+			/* Support 2560 width for PA&&PB when stitch is on */
+			if (resource->debug_enable_map & DEBUG_TYPE_STITCH) {
+				if (resource->debug_stitched == 1) {
+					prop.width = (buf_id == IAV_SRCBUF_PA) ?
+						PABUF_LIMIT_MAX_WIDTH_STITCH : PBBUF_LIMIT_MAX_WIDTH_STITCH;
+				}
+			} else {
+				if (is_stitched_vin(iav, enc_mode)) {
+					prop.width = (buf_id == IAV_SRCBUF_PA) ?
+						PABUF_LIMIT_MAX_WIDTH_STITCH : PBBUF_LIMIT_MAX_WIDTH_STITCH;
+				}
+			}
+		}
 		/* error if buffer max > buffer limit */
-		if ((max->width > prop->width) || (max->height > prop->height)) {
+		if ((max->width > prop.width) || (max->height > prop.height)) {
 			iav_error("Source buffer [%d] max %dx%d cannot be larger than "
 				"%dx%d.\n", buf_id, max->width, max->height,
-				prop->width, prop->height);
+				prop.width, prop.height);
 			return -1;
 		}
 		/* error if sub buffer max > main buffer max */
@@ -1483,7 +1817,7 @@ static int iav_check_sys_resource_limit(struct ambarella_iav *iav,
 		return -1;
 	} else if (check_sys_resource_general(resource) < 0) {
 		return -1;
-	} else if (check_sys_resource_buffer(resource) < 0) {
+	} else if (check_sys_resource_buffer(iav, resource) < 0) {
 		return -1;
 	} else if (check_sys_resource_enc_mode(resource) < 0) {
 		return -1;
@@ -1557,11 +1891,13 @@ static int update_system_resource(struct ambarella_iav *iav,
 		iav->stream[i].max_GOP_N = resource->stream_max_N[i];
 		iav->stream[i].long_ref_enable = resource->stream_long_ref_enable[i];
 	}
+	config->long_ref_b_frame = resource->long_ref_b_frame;
 	config->max_stream_num = resource->max_num_encode;
 	iav->mixer_a_enable = resource->mixer_a_enable;
 	iav->mixer_b_enable = resource->mixer_b_enable;
 	iav->osd_from_mixer_a = resource->osd_from_mixer_a;
 	iav->osd_from_mixer_b = resource->osd_from_mixer_b;
+	iav->vin_overflow_protection = resource->vin_overflow_protection;
 
 	spin_lock_irq(&iav->iav_lock);
 	if (resource->dsp_partition_map != iav->dsp_partition_mapped) {
@@ -1570,6 +1906,8 @@ static int update_system_resource(struct ambarella_iav *iav,
 	} else {
 		iav->dsp_map_updated = 0;
 	}
+
+	config->extra_top_row_buf_enable = resource->extra_top_row_buf_enable;
 	spin_unlock_irq(&iav->iav_lock);
 
 	mutex_unlock(&iav->iav_mutex);
@@ -1600,7 +1938,6 @@ static int iav_ioc_s_system_resource(struct ambarella_iav *iav, void __user *arg
 static int iav_ioc_g_system_resource(struct ambarella_iav *iav, void __user *arg)
 {
 	int i, enc_mode;
-	struct iav_rect *vin;
 	struct iav_system_resource param;
 	struct iav_system_config * config = NULL;
 
@@ -1611,8 +1948,6 @@ static int iav_ioc_g_system_resource(struct ambarella_iav *iav, void __user *arg
 		return -1;
 	}
 
-	get_vin_win(iav, &vin, 1);
-
 	mutex_lock(&iav->iav_mutex);
 
 	enc_mode = (param.encode_mode == DSP_CURRENT_MODE) ?
@@ -1635,21 +1970,25 @@ static int iav_ioc_g_system_resource(struct ambarella_iav *iav, void __user *arg
 	param.enc_raw_yuv = config->enc_raw_yuv;
 	param.eis_delay_count = enc_mode == DSP_ADVANCED_ISO_MODE ?
 		config->eis_delay_count : 0;
+	param.vin_overflow_protection = iav->vin_overflow_protection;
 	if (config->enc_raw_rgb || config->enc_raw_yuv) {
 		param.raw_size = iav->raw_enc.raw_size;
 	}
 	param.enc_from_mem = config->enc_from_mem;
 	param.efm_buf_num = iav->efm.req_buf_num;
 	param.efm_size = iav->efm.efm_size;
+	param.extra_top_row_buf_enable = config->extra_top_row_buf_enable;
 
 	for (i = IAV_SRCBUF_FIRST; i < IAV_SRCBUF_LAST; ++i) {
 		param.buf_max_size[i] = iav->srcbuf[i].max;
 		param.extra_dram_buf[i] = iav->srcbuf[i].extra_dram_buf;
 	}
 	param.max_num_cap_sources = 2;
-	if (iav->srcbuf[IAV_SRCBUF_PA].type == IAV_SRCBUF_TYPE_ENCODE)
+	if ((iav->srcbuf[IAV_SRCBUF_PA].type == IAV_SRCBUF_TYPE_ENCODE) ||
+		(iav->srcbuf[IAV_SRCBUF_PA].type == IAV_SRCBUF_TYPE_VCA))
 		++param.max_num_cap_sources;
-	if (iav->srcbuf[IAV_SRCBUF_PB].type == IAV_SRCBUF_TYPE_ENCODE)
+	if ((iav->srcbuf[IAV_SRCBUF_PB].type == IAV_SRCBUF_TYPE_ENCODE) ||
+		(iav->srcbuf[IAV_SRCBUF_PB].type == IAV_SRCBUF_TYPE_VCA))
 		++param.max_num_cap_sources;
 
 	for (i = 0; i < IAV_STREAM_MAX_NUM_IMPL; ++i) {
@@ -1671,6 +2010,7 @@ static int iav_ioc_g_system_resource(struct ambarella_iav *iav, void __user *arg
 	param.max_padding_width = (enc_mode == DSP_ADVANCED_ISO_MODE) ?
 		LDC_PADDING_WIDTH_MAX : 0;
 	param.enc_dummy_latency = config->enc_dummy_latency;
+	param.long_ref_b_frame = config->long_ref_b_frame;
 
 	/* Read only fields */
 	param.raw_pitch_in_bytes = config->raw_capture ?
@@ -1693,6 +2033,9 @@ static int iav_ioc_g_system_resource(struct ambarella_iav *iav, void __user *arg
 		param.debug_iso_type = param.iso_type;
 	}
 
+	/* ARCH info */
+	param.arch = S2L;
+
 	mutex_unlock(&iav->iav_mutex);
 
 	return copy_to_user(arg, &param, sizeof(param)) ? -EFAULT : 0;
@@ -1839,7 +2182,7 @@ static int iav_ioc_wait_raw_enc(struct ambarella_iav *iav, void __user *arg)
 	return 0;
 }
 
-static int iav_check_overlay_param(struct iav_stream *stream,
+int iav_check_overlay_param(struct iav_stream *stream,
 	struct iav_overlay_insert *info)
 {
 	int i, width, height;
@@ -1988,12 +2331,29 @@ static int iav_ioc_g_overlay_insert(struct ambarella_iav *iav,
 	for (i = 0; i < MAX_NUM_OVERLAY_AREA; ++i) {
 		info.area[i] = stream->osd.area[i];
 	}
+	info.osd_insert_always = stream->osd.osd_insert_always;
 
 	mutex_unlock(&stream->osd_mutex);
 
 	return copy_to_user(arg, &info, sizeof(info)) ? -EFAULT : 0;
 }
 
+int iav_overlay_resume(struct ambarella_iav *iav, struct iav_stream *stream)
+{
+	if (!is_enc_work_state(iav)) {
+		iav_error("IAV must be in PREVIEW or ENCODE for overlay.\n");
+		return -1;
+	}
+
+	mutex_lock(&stream->osd_mutex);
+
+	cmd_overlay_insert(stream, NULL, &stream->osd);
+
+	mutex_unlock(&stream->osd_mutex);
+
+	return 0;
+}
+
 static int iav_cfg_vproc_cawarp(struct ambarella_iav *iav,
 	struct iav_ca_warp *cawarp)
 {
@@ -2239,18 +2599,30 @@ static int iav_ioc_g_fastosd_insert(struct ambarella_iav *iav,
 	return copy_to_user(arg, &info, sizeof(info)) ? -EFAULT : 0;
 }
 
+int iav_set_dsplog_debug_level(struct ambarella_iav *iav,
+	struct iav_dsplog_setup *dsplog_setup)
+{
+	if (dsplog_setup->args[1] > 3) {
+		iav_debug("Set too high debug level, reduce to highest level [3].\n");
+		dsplog_setup->args[1] = 3;
+	}
+
+	cmd_dsp_set_debug_level(iav, NULL, dsplog_setup->args[0],
+		dsplog_setup->args[1], dsplog_setup->args[2]);
+	return 0;
+}
 
 static int iav_ioc_s_dsplog(struct ambarella_iav *iav, void __user *arg)
 {
-	u32 param;
-	u8 module, debug_level, mask;
+	u32 param = (u32)arg;
+	struct iav_dsplog_setup dsplog_setup;
 
-	param = (u32)arg;
-	module = (u8)param;
-	debug_level = (u8)(param >> 8);
-	mask = (u8)(param >> 16);
-
-	cmd_dsp_set_debug_level(iav, NULL, module, debug_level, mask);
+	memset(&dsplog_setup, 0, sizeof(struct iav_dsplog_setup));
+	dsplog_setup.args[0] = param & 0xFF; // module
+	dsplog_setup.args[1] = (param >> 8) & 0xFF; // debug level
+	dsplog_setup.args[2] = (param >> 16) & 0xFF; // mask
+	iav_set_dsplog_debug_level(iav, &dsplog_setup);
+	memcpy(&iav->dsplog_setup, &dsplog_setup, sizeof(struct iav_dsplog_setup));
 
 	return 0;
 }
@@ -2259,18 +2631,32 @@ static int iav_ioc_s_dsplog(struct ambarella_iav *iav, void __user *arg)
 static int iav_guard_task(void *arg)
 {
 	struct ambarella_iav *iav = (struct ambarella_iav *)arg;
+	struct iav_nl_obj * nl_obj = &iav->nl_obj[NL_OBJ_VSYNC];;
 
 	while (1) {
 		if (!iav->err_vsync_again) {
-			wait_event_interruptible(iav->err_wq, iav->err_vsync_lost);
+			if (!iav->err_vsync_handling) {
+				wait_event_interruptible(iav->err_wq, iav->err_vsync_lost);
+			}
 		}
-		mutex_lock(&iav->iav_mutex);
-		iav->err_vsync_handling = 1;
-		if (iav->nl_obj[NL_OBJ_VSYNC].nl_connected) {
-			nl_send_request(&iav->nl_obj[NL_OBJ_VSYNC], NL_REQ_VSYNC_RESTORE);
+		if (!iav->err_vsync_handling) {
+			mutex_lock(&iav->iav_mutex);
+			iav->err_vsync_handling = 1;
+			if (nl_obj->nl_connected) {
+				nl_send_request(nl_obj, NL_REQ_VSYNC_RESTORE);
+				if(is_nl_request_responded(&iav->nl_obj[NL_OBJ_VSYNC],
+					NL_REQ_VSYNC_RESTORE)) {
+					iav->err_vsync_handling = 0;
+				}
+			} else {
+				iav->err_vsync_handling = 0;
+			}
+			mutex_unlock(&iav->iav_mutex);
+		} else {
+			if(is_nl_request_responded(nl_obj, NL_REQ_VSYNC_RESTORE)) {
+				iav->err_vsync_handling = 0;
+			}
 		}
-		iav->err_vsync_handling = 0;
-		mutex_unlock(&iav->iav_mutex);
 	}
 
 	return 0;
@@ -2316,13 +2702,12 @@ void iav_encode_exit(struct ambarella_iav *iav)
 int iav_encode_init(struct ambarella_iav *iav)
 {
 	struct iav_frame_desc *frame_desc;
-	dsp_init_data_t *dsp_init_data;
-	u32 data_addr_phys;
-	int i, size;
+	int i;
 
 	INIT_LIST_HEAD(&iav->frame_queue);
 	INIT_LIST_HEAD(&iav->frame_free);
 	init_waitqueue_head(&iav->frame_wq);
+	init_waitqueue_head(&iav->mv_wq);
 
 	iav->system_config = &G_system_config[0];
 	iav->raw_enc.raw_size.width = MAX_WIDTH_IN_FULL_FPS;
@@ -2330,6 +2715,9 @@ int iav_encode_init(struct ambarella_iav *iav)
 	iav->raw_enc.cmd_send_flag = 0;
 	init_waitqueue_head(&iav->raw_enc.raw_wq);
 
+	iav->vcap_state = IAV_VCAP_STATE_ACTIVE;
+	init_waitqueue_head(&iav->vcap_state_wq);
+
 	/* Set up the frame descriptor list */
 	iav->frame_queue_virt = (struct iav_frame_desc *)
 		kzalloc(sizeof(struct iav_frame_desc) * NUM_BS_DESC, GFP_KERNEL);
@@ -2365,25 +2753,6 @@ int iav_encode_init(struct ambarella_iav *iav)
 			goto encode_init_exit;
 		}
 		iav->bsh = iav->bsh_virt;
-		if (iav->probe_state == IAV_STATE_ENCODING) {
-			iav_sync_bsh_queue(iav);
-		}
-	}
-
-	/* Set up encode interrupt handler */
-	iav->dsp->msg_callback[CAT_ENC] = irq_iav_queue_frame;
-	iav->dsp->msg_data[CAT_ENC] = iav;
-	iav->dsp->msg_callback[CAT_VCAP] = handle_vcap_msg;
-	iav->dsp->msg_data[CAT_VCAP] = iav;
-	iav->dsp_used_dram = 0;
-	// map dsp encode data table
-	dsp_init_data = iav->dsp->get_dsp_init_data(iav->dsp);
-	data_addr_phys = DSP_TO_PHYS(dsp_init_data->default_binary_data_ptr);
-	size = PAGE_ALIGN(sizeof(default_enc_binary_data_t));
-	iav->dsp_enc_data_virt = ioremap_nocache(data_addr_phys, size);
-	if (!iav->dsp_enc_data_virt) {
-		iav_error("Failed to call ioremap() for dsp_enc_data_virt.\n");
-		goto encode_init_exit;
 	}
 
 	init_waitqueue_head(&iav->dsp_map_wq);
@@ -2404,6 +2773,32 @@ encode_init_exit:
 	return -ENOMEM;
 }
 
+int iav_init_isr(struct ambarella_iav *iav)
+{
+	dsp_init_data_t *dsp_init_data;
+	u32 data_addr_phys;
+	int size;
+
+	/* Set up encode interrupt handler */
+	iav->dsp->msg_callback[CAT_ENC] = irq_iav_queue_frame;
+	iav->dsp->msg_data[CAT_ENC] = iav;
+	iav->dsp->msg_callback[CAT_VCAP] = handle_vcap_msg;
+	iav->dsp->msg_data[CAT_VCAP] = iav;
+	iav->dsp_used_dram = 0;
+	// map dsp encode data table
+	dsp_init_data = iav->dsp->get_dsp_init_data(iav->dsp);
+	data_addr_phys = DSP_TO_PHYS(dsp_init_data->default_binary_data_ptr);
+	size = PAGE_ALIGN(sizeof(default_enc_binary_data_t));
+	iav->dsp_enc_data_virt = ioremap_nocache(data_addr_phys, size);
+	if (!iav->dsp_enc_data_virt) {
+		iav_error("Failed to call ioremap() for dsp_enc_data_virt.\n");
+		iav_encode_exit(iav);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
 static int iav_check_gdma_copy(struct ambarella_iav *iav, struct iav_gdma_copy *param)
 {
 	iav_no_check();
@@ -2510,6 +2905,12 @@ int iav_encode_ioctl(struct ambarella_iav *iav, unsigned int cmd, unsigned long
 	case IAV_IOC_DRV_DSP_INFO:
 		rval = iav_ioc_g_drvdspinfo(iav, (void __user *)arg);
 		break;
+	case IAV_IOC_GET_DSP_HASH:
+		rval = iav_ioc_get_dsp_hash(iav, (void __user *)arg);
+		break;
+	case IAV_IOC_SET_DSP_CLOCK_STATE:
+		rval = iav_ioc_s_dsp_clock_state(iav, (void __user *)arg);
+		break;
 
 	/* state ioctl */
 	case IAV_IOC_WAIT_NEXT_FRAME:
@@ -2522,7 +2923,7 @@ int iav_encode_ioctl(struct ambarella_iav *iav, unsigned int cmd, unsigned long
 		rval = iav_goto_idle(iav);
 		break;
 	case IAV_IOC_ENABLE_PREVIEW:
-		rval = iav_enable_preview(iav, 0);
+		rval = iav_enable_preview(iav);
 		break;
 	case IAV_IOC_START_ENCODE:
 		rval = iav_ioc_start_encode(iav, (void __user *)arg);
@@ -2530,6 +2931,15 @@ int iav_encode_ioctl(struct ambarella_iav *iav, unsigned int cmd, unsigned long
 	case IAV_IOC_STOP_ENCODE:
 		rval = iav_ioc_stop_encode(iav, (void __user *)arg);
 		break;
+	case IAV_IOC_ABORT_ENCODE:
+		rval = iav_ioc_abort_encode(iav, (void __user *)arg);
+		break;
+	case IAV_IOC_SET_VCAP_CFG:
+		rval = iav_ioc_set_vcap_cfg(iav, (void __user *)arg);
+		break;
+	case IAV_IOC_GET_VCAP_CFG:
+		rval = iav_ioc_get_vcap_cfg(iav, (void __user *)arg);
+		break;
 
 	/* system ioctl */
 	case IAV_IOC_SET_SYSTEM_RESOURCE:
@@ -2714,6 +3124,11 @@ int iav_encode_ioctl(struct ambarella_iav *iav, unsigned int cmd, unsigned long
 		rval = iav_ioc_g_debug_cfg(iav, (void __user *)arg);
 		break;
 
+	/* Customized IAV IOCTL */
+	case IAV_IOC_CUSTOM_CMDS:
+		rval = iav_ioc_custom_cmds(iav, (void __user *)arg);
+		break;
+
 	default:
 		iav_error("Not supported cmd [%x].\n", cmd);
 		rval = -ENOIOCTLCMD;
diff --git a/drivers/iav/arch_s2l/iav_enc_api.h b/drivers/iav/arch_s2l/iav_enc_api.h
index e4633d8..4255188 100644
--- a/drivers/iav/arch_s2l/iav_enc_api.h
+++ b/drivers/iav/arch_s2l/iav_enc_api.h
@@ -4,29 +4,56 @@
  * History:
  *	2013/11/11 - [Jian Tang] created file
  *
- * Copyright (C) 2013-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
 
+
 #ifndef __IAV_ENC_API_H__
 #define __IAV_ENC_API_H__
 
+/* iav_enc_custom.c */
+int iav_ioc_custom_cmds(struct ambarella_iav *iav, void __user *arg);
+
 /* iav_enc_api.c */
 int iav_encode_init(struct ambarella_iav *iav);
+int iav_init_isr(struct ambarella_iav *iav);
 void iav_encode_exit(struct ambarella_iav *iav);
 int iav_encode_ioctl(struct ambarella_iav *iav, unsigned int cmd, unsigned long args);
 int iav_restore_dsp_cmd(struct ambarella_iav *iav);
 int iav_boot_dsp_action(struct ambarella_iav *iav);
-int iav_enable_preview(struct ambarella_iav *iav, u32 is_resume);
+int iav_enable_preview(struct ambarella_iav *iav);
+int iav_check_overlay_param(struct iav_stream *stream, struct iav_overlay_insert *info);
+int iav_overlay_resume(struct ambarella_iav *iav, struct iav_stream *stream);
+int iav_set_dsplog_debug_level(struct ambarella_iav *iav, struct iav_dsplog_setup *dsplog_setup);
 
 /* iav_enc_buf.c */
-int check_main_buffer_input(u32 is_pre_main, struct iav_rect * input, struct iav_rect * vin);
+int check_main_buffer_input(struct ambarella_iav *iav, u32 is_pre_main,
+	struct iav_rect * input, struct iav_rect * vin);
 int iav_cfg_vproc_dptz(struct ambarella_iav *iav, struct iav_digital_zoom *dptz);
 int iav_ioc_s_srcbuf_setup(struct ambarella_iav * iav, void __user * arg);
 int iav_ioc_g_srcbuf_setup(struct ambarella_iav * iav, void __user * arg);
@@ -45,6 +72,7 @@ int iav_query_yuvdesc(struct ambarella_iav *iav, struct iav_yuvbufdesc *yuvdesc)
 int iav_query_me1desc(struct ambarella_iav *iav, struct iav_mebufdesc *me1desc);
 int iav_query_me0desc(struct ambarella_iav *iav, struct iav_mebufdesc *me0desc);
 int iav_query_bufcapdesc(struct ambarella_iav *iav, struct iav_bufcapdesc *bufdesc);
+int iav_query_qphistdesc(struct ambarella_iav *iav, struct iav_qphistdesc *qphistdesc);
 
 /* iav_enc_perf.c */
 int iav_check_sys_mem_usage(struct ambarella_iav * iav, int iav_state, u32 stream_map);
@@ -64,6 +92,7 @@ void iav_reset_pm(struct ambarella_iav *iav);
 int iav_set_pm_bpc(struct ambarella_iav *iav, struct iav_privacy_mask *priv_mask);
 int iav_set_pm_mctf(struct ambarella_iav *iav,
 	struct iav_privacy_mask * priv_mask, u32 cmd_delay);
+int iav_pm_resume(struct ambarella_iav *iav, int wait);
 int iav_cfg_vproc_pm(struct ambarella_iav *iav, struct iav_privacy_mask *pm);
 int iav_ioc_g_pm_info(struct ambarella_iav *iav, void __user * arg);
 int iav_ioc_s_pm(struct ambarella_iav *iav, void __user * arg);
@@ -79,6 +108,7 @@ u64 get_hw_pts(struct ambarella_iav *iav, u32 audio_pts);
 /* iav_enc_stream.c */
 int iav_ioc_start_encode(struct ambarella_iav *iav, void __user *arg);
 int iav_ioc_stop_encode(struct ambarella_iav *iav, void __user *arg);
+int iav_ioc_abort_encode(struct ambarella_iav *iav, void __user *arg);
 int iav_ioc_g_query_desc(struct ambarella_iav *iav, void __user *arg);
 int iav_ioc_s_stream_format(struct ambarella_iav * iav, void __user * arg);
 int iav_ioc_g_stream_format(struct ambarella_iav * iav, void __user * arg);
@@ -107,6 +137,8 @@ int check_stream_config_limit(struct ambarella_iav *iav, u32 stream_id);
 void iav_sync_bsh_queue(void *data);
 u32 iav_get_stream_map(struct ambarella_iav *iav);
 void iav_clear_stream_state(struct ambarella_iav *iav);
+int iav_fetch_bsbinfo(unsigned long *iav_bsb_virt, u32 *iav_bsb_size);
+int iav_fetch_framedesc(struct iav_framedesc *framedesc);
 
 /* iav_enc_test.c */
 void iav_init_debug(struct ambarella_iav *iav);
@@ -125,14 +157,24 @@ int iav_create_efm_pool(struct ambarella_iav *iav);
 int iav_ioc_efm_get_pool_info(struct ambarella_iav * iav, void __user * arg);
 int iav_ioc_efm_request_frame(struct ambarella_iav * iav, void __user * arg);
 int iav_ioc_efm_handshake_frame(struct ambarella_iav * iav, void __user * arg);
+int iav_efm_feed_empty_frame(struct ambarella_iav * iav, struct iav_stream *stream);
 
 /* iav_netlink.c */
-int init_netlink(struct ambarella_iav *iav);
-int nl_send_request(struct iav_nl_obj *nl_obj, int cmd);
+int iav_init_netlink(struct ambarella_iav *iav);
+int iav_deinit_netlink(struct ambarella_iav * iav);
+int nl_send_request(struct iav_nl_obj *nl_obj, u32 cmd);
+int nl_send_notice(struct iav_nl_obj *nl_obj, u32 status);
+int is_nl_request_responded(struct iav_nl_obj *nl_obj, u32 cmd);
 
 /* hw_timer.c */
 int get_hwtimer_output_ticks(u64 *out_tick);
 int get_hwtimer_output_freq(u32 *out_tick);
+#ifdef CONFIG_PM
+int hwtimer_suspend(void);
+int hwtimer_resume(void);
+int hwtimer_freeze(void);
+int hwtimer_thaw(int fastboot_audio);
+#endif
 
 #endif	// __IAV_ENC_API_H__
 
diff --git a/drivers/iav/arch_s2l/iav_enc_buf.c b/drivers/iav/arch_s2l/iav_enc_buf.c
index 866ee84..5899f05 100644
--- a/drivers/iav/arch_s2l/iav_enc_buf.c
+++ b/drivers/iav/arch_s2l/iav_enc_buf.c
@@ -3,14 +3,33 @@
  *
  * History:
  *	2012/04/13 - [Jian Tang] created file
- * Copyright (C) 2007-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <config.h>
 #include <linux/random.h>
 #include <linux/slab.h>
@@ -65,7 +84,7 @@ static int check_src_buf_type(u32 buf_id, enum iav_srcbuf_type t)
 	switch (buf_id) {
 	case IAV_SRCBUF_MN:
 		if (t != IAV_SRCBUF_TYPE_ENCODE) {
-			iav_error("Source buffer [0] type cannot be OFF or PREVIEW.\n");
+			iav_error("Source buffer [0] type cannot be OFF, PREVIEW or VCA.\n");
 			return -1;
 		}
 		break;
@@ -135,9 +154,10 @@ static int check_main_buffer_size(struct ambarella_iav *iav,
 	return 0;
 }
 
-int check_main_buffer_input(u32 is_pre_main,
+int check_main_buffer_input(struct ambarella_iav *iav, u32 is_pre_main,
 	struct iav_rect * input, struct iav_rect * vin)
 {
+	struct iav_enc_limitation * limit = &G_encode_limit[iav->encode_mode];
 	char str[32];
 
 	/* default input window is VIN */
@@ -173,6 +193,15 @@ int check_main_buffer_input(u32 is_pre_main,
 		return -1;
 	}
 
+	if ((input->width > limit->max_main_input.width) ||
+		(input->height > limit->max_main_input.height)) {
+		iav_error("%s input window %dx%d cannot be "
+			"larger than %dx%d in mode %d. Pls crop it to a smaller size.\n",
+			str, input->width, input->height, limit->max_main_input.width,
+			limit->max_main_input.height, iav->encode_mode);
+		return -1;
+	}
+
 	// TODO: move pre-main input check to DZ type I
 
 	return 0;
@@ -204,9 +233,8 @@ static int check_sub_buf_size(struct ambarella_iav *iav,
 	char str[32];
 	struct iav_window *win;
 
+	sprintf(str, "Source buffer [%d]", id);
 	if (size->width && size->height) {
-		sprintf(str, "Source buffer [%d]", id);
-
 		/* error it's not aligned */
 		if ((size->width & 0xF) || (size->height & 0x7)) {
 			iav_error("%s width %d must be multiple of 16 and height %d must "
@@ -228,15 +256,15 @@ static int check_sub_buf_size(struct ambarella_iav *iav,
 				size->width, size->height, win->width, win->height);
 			return -1;
 		}
-		/* error if buffer is in use */
-		win = &iav->srcbuf[id].win;
-		if ((size->width != win->width) || (size->height != win->height)) {
-			if (iav->srcbuf[id].state == IAV_SRCBUF_STATE_BUSY) {
-				iav_error("%s cannot change size while it's used.\n", str);
-				return -1;
-			}
-		}
+	}
 
+	/* error if buffer is in use */
+	win = &iav->srcbuf[id].win;
+	if ((size->width != win->width) || (size->height != win->height)) {
+		if (iav->srcbuf[id].state == IAV_SRCBUF_STATE_BUSY) {
+			iav_error("%s cannot change size while it's used.\n", str);
+			return -1;
+		}
 	}
 
 	return 0;
@@ -298,9 +326,13 @@ static int check_sub_buf_zoom(struct ambarella_iav *iav, u32 id, u8 unwarp,
 				str, input->width, input->height);
 			return -1;
 		}
-		if (type == IAV_SRCBUF_TYPE_ENCODE) {
+
+		switch (type) {
+		case IAV_SRCBUF_TYPE_ENCODE:
+		case IAV_SRCBUF_TYPE_VCA:
 			output = *win;
-		} else {
+			break;
+		case IAV_SRCBUF_TYPE_PREVIEW:
 			if (id == IAV_SRCBUF_PB) {
 				if (vout_swap) {
 					vout1_info = &iav->pvoutinfo[0]->video_info;
@@ -321,6 +353,10 @@ static int check_sub_buf_zoom(struct ambarella_iav *iav, u32 id, u8 unwarp,
 				iav_error("Buffer [%d] cannot be set as PREV.\n", id);
 				return -1;
 			}
+			break;
+		default:
+			BUG();
+			break;
 		}
 		if (check_zoom_limit(id, input, &output, str) < 0) {
 			return -1;
@@ -337,6 +373,77 @@ static int check_sub_buf_zoom(struct ambarella_iav *iav, u32 id, u8 unwarp,
 	return 0;
 }
 
+static int check_vca_buf_param(struct ambarella_iav *iav, struct iav_srcbuf_setup *setup)
+{
+
+	int i;
+	u32 vca_buf_size, idsp_out_frame_rate;
+	u32 vca_buf_num = 0;
+	u16 vca_dump_duration, vca_dump_interval;
+	struct iav_window *win;
+	struct iav_window *size;
+
+	if (iav_vin_get_idsp_frame_rate(iav, &idsp_out_frame_rate) < 0) {
+		return -1;
+	}
+	idsp_out_frame_rate = DIV_CLOSEST(FPS_Q9_BASE, idsp_out_frame_rate);
+
+	for (i = IAV_SUB_SRCBUF_FIRST; i < IAV_SUB_SRCBUF_LAST; ++i) {
+		vca_dump_duration = setup->dump_duration[i];
+		vca_dump_interval = setup->dump_interval[i];
+		if (vca_dump_duration > MAX_NUM_VCA_DUMP_DURATION) {
+			iav_error("Dutation number [%d] not in range [0~%d] for buffer [%d].\n",
+				vca_dump_duration, MAX_NUM_VCA_DUMP_DURATION, i);
+			return -1;
+		}
+
+		if (vca_dump_interval > idsp_out_frame_rate) {
+			iav_error("Interval number [%d] not in range [0~%d] for buffer [%d].\n",
+				vca_dump_interval, idsp_out_frame_rate, i);
+			return -1;
+		}
+
+		if (setup->type[i] == IAV_SRCBUF_TYPE_VCA) {
+			++vca_buf_num;
+			if (vca_buf_num > 1) {
+				iav_error("Only one buffer can be set to VCA type.\n");
+				return -1;
+			}
+
+			win = &iav->srcbuf[i].max;
+			size = &setup->size[i];
+			if (((win->width != size->width) || (win->height != size->height)) &&
+				(size->width != 0 && size->height != 0)) {
+				iav_error("Max resolution shoule be equal with real resolution for VCA buffer.\n");
+				return -1;
+			}
+
+			if (vca_dump_duration == 0) {
+				iav_error("Dutation number [%d] cannot be 0 for VCA buffer.\n",
+					vca_dump_duration);
+				return -1;
+			}
+
+			if (vca_dump_interval == 0) {
+				iav_error("Interval number [%d] cannot be 0 for VCA buffer.\n",
+					vca_dump_interval);
+				return -1;
+			}
+
+			vca_buf_size = (ALIGN(win->width, PIXEL_IN_MB) *
+				(1 + win->height + (win->height >> 1)) * vca_dump_duration);
+			if (vca_buf_size > iav->mmap[IAV_BUFFER_VCA].size) {
+				iav_error("Vca Buffer size should be 0x%x, more than max 0x%x.\n",
+					vca_buf_size, iav->mmap[IAV_BUFFER_VCA].size);
+				return -1;
+			}
+		}
+	}
+
+	return 0;
+}
+
+
 static int iav_check_srcbuf_setup(struct ambarella_iav *iav,
 	struct iav_srcbuf_setup *setup)
 {
@@ -369,7 +476,7 @@ static int iav_check_srcbuf_setup(struct ambarella_iav *iav,
 		return -1;
 	} else if (check_main_buffer_size(iav, is_warp, main_zoom) < 0) {
 		return -1;
-	} else if (check_main_buffer_input(is_warp, main_input, vin) < 0) {
+	} else if (check_main_buffer_input(iav, is_warp, main_input, vin) < 0) {
 		return -1;
 	} else if (check_main_buffer_zoom(is_warp, main_input, main_zoom)) {
 		return -1;
@@ -390,6 +497,10 @@ static int iav_check_srcbuf_setup(struct ambarella_iav *iav,
 		}
 	}
 
+	if (check_vca_buf_param(iav, setup) < 0) {
+		return -1;
+	}
+
 	if (setup->type[IAV_SRCBUF_PMN] == IAV_SRCBUF_TYPE_ENCODE
 		&& iav->encode_mode != DSP_MULTI_REGION_WARP_MODE) {
 		iav_error("Premain buffer can only be set as encode fisheye mode!\n");
@@ -435,10 +546,15 @@ static int iav_check_dptz_I(struct ambarella_iav *iav,
 
 	iav_no_check();
 
+	if (iav->system_config[iav->encode_mode].lens_warp && iav->warp->area[0].enable) {
+		iav_error("Cannot run DPTZ I with lens warp enabled\n");
+		return -1;
+	}
+
 	get_vin_win(iav, &vin, 0);
 	main_win = &iav->srcbuf[IAV_SRCBUF_MN].win;
 
-	if (check_main_buffer_input(0, &dz->input, vin) < 0) {
+	if (check_main_buffer_input(iav, 0, &dz->input, vin) < 0) {
 		return -1;
 	} else if (check_main_buffer_zoom(0, &dz->input, main_win) < 0) {
 		return -1;
@@ -475,16 +591,16 @@ static int iav_check_dptz_II(struct ambarella_iav *iav,
 	}
 }
 
-inline void inc_srcbuf_ref(struct iav_buffer *srcbuf)
+inline void inc_srcbuf_ref(struct iav_buffer *srcbuf, u32 stream_id)
 {
-	++srcbuf->ref_cnt;
+	srcbuf->ref_cnt |= (1 << stream_id);
 	srcbuf->state = IAV_SRCBUF_STATE_BUSY;
 }
 
-inline void dec_srcbuf_ref(struct iav_buffer *srcbuf)
+inline void dec_srcbuf_ref(struct iav_buffer *srcbuf, u32 stream_id)
 {
 	if (srcbuf->ref_cnt) {
-		--srcbuf->ref_cnt;
+		srcbuf->ref_cnt &= ~(1 << stream_id);
 		if (srcbuf->ref_cnt == 0) {
 			srcbuf->state = IAV_SRCBUF_STATE_IDLE;
 		}
@@ -545,6 +661,8 @@ int iav_ioc_s_srcbuf_setup(struct ambarella_iav *iav, void __user *arg)
 			buf->input = setup.input[i];
 			buf->type = setup.type[i];
 //			buf->unwarp = setup.unwarp[i];
+			buf->dump_interval = setup.dump_interval[i];
+			buf->dump_duration = setup.dump_duration[i];
 		}
 	} while (0);
 	mutex_unlock(&iav->iav_mutex);
@@ -574,6 +692,8 @@ int iav_ioc_g_srcbuf_setup(struct ambarella_iav *iav, void __user *arg)
 				setup.size[i].height = 0;
 			}
 		}
+		setup.dump_interval[i] = buffer->dump_interval;
+		setup.dump_duration[i] = buffer->dump_duration;
 	}
 	i = IAV_SRCBUF_PMN;
 	buffer = &iav->srcbuf[i];
@@ -611,7 +731,8 @@ int iav_ioc_s_srcbuf_format(struct ambarella_iav *iav, void __user *arg)
 	buf_id = format.buf_id;
 	iav->srcbuf[buf_id].win = format.size;
 	iav->srcbuf[buf_id].input = format.input;
-	if (iav->srcbuf[buf_id].type == IAV_SRCBUF_TYPE_ENCODE) {
+	if ((iav->srcbuf[buf_id].type == IAV_SRCBUF_TYPE_ENCODE) ||
+		(iav->srcbuf[buf_id].type == IAV_SRCBUF_TYPE_VCA)) {
 		if (iav->encode_mode == DSP_MULTI_REGION_WARP_MODE) {
 			clear_default_warp_dptz(iav, 1 << buf_id);
 			/* Wait 3 frames to sync up the warp control and capture
diff --git a/drivers/iav/arch_s2l/iav_enc_bufcap.c b/drivers/iav/arch_s2l/iav_enc_bufcap.c
index 04957b9..9ca8eed 100644
--- a/drivers/iav/arch_s2l/iav_enc_bufcap.c
+++ b/drivers/iav/arch_s2l/iav_enc_bufcap.c
@@ -3,14 +3,33 @@
  *
  * History:
  *	2014/03/28 - [Zhaoyang Chen] created file
- * Copyright (C) 2007-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <config.h>
 #include <linux/random.h>
 #include <linux/slab.h>
@@ -36,6 +55,58 @@ static inline int is_invalid_dsp_addr(u32 addr)
 	return ((addr == 0x0) || (addr == 0xdeadbeef) || (addr == 0xc0000000));
 }
 
+static inline int is_invalid_qp_hist(struct ambarella_iav *iav)
+{
+	int i;
+	struct iav_stream *stream;
+
+	for (i = 0; i < IAV_MAX_ENCODE_STREAMS_NUM; ++i) {
+		stream = &iav->stream[i];
+		if (stream->format.type == IAV_STREAM_TYPE_H264
+				&& is_stream_in_encoding(stream)) {
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
+static int check_qp_hist_param(struct ambarella_iav *iav, struct iav_qp_histogram *hist)
+{
+	int i, mb_sum, stream_id;
+	u32 width, height;
+	struct iav_stream *stream;
+
+	/* check stream id */
+	stream_id = hist->id;
+	if (stream_id < 0 || stream_id >= IAV_MAX_ENCODE_STREAMS_NUM) {
+		iav_error("Invalid stream id [%d] for QP histogram.\n", stream_id);
+		return -1;
+	}
+	stream = &iav->stream[stream_id];
+
+	mb_sum = 0;
+	/* check QP value */
+	for (i = 0; i < IAV_QP_HIST_BIN_MAX_NUM; ++i) {
+		if (hist->qp[i] < H264_QP_MIN || hist->qp[i] > H264_QP_MAX) {
+			iav_error("Stream [%d] : Invalid QP value [%d] for bin [%d].\n",
+				stream_id, hist->qp[i], i);
+			return -1;
+		}
+		mb_sum += hist->mb[i];
+	}
+	/* check total MB num */
+	width = ALIGN(stream->format.enc_win.width, 16);
+	height = ALIGN(stream->format.enc_win.height, 16);
+	if ((mb_sum << 8) != (width * height)) {
+		iav_error("Stream [%d] : Invalid total MB number for resolution %dx%d.\n",
+			stream_id, width, height);
+		return -1;
+	}
+
+	return 0;
+}
+
 static void save_raw_data_info(struct ambarella_iav *iav, encode_msg_t *msg)
 {
 	struct iav_bufcap_info *buf_cap;
@@ -43,12 +114,12 @@ static void save_raw_data_info(struct ambarella_iav *iav, encode_msg_t *msg)
 	struct iav_rect *vin;
 
 	buf_cap = &iav->buf_cap;
-	vin = &iav->vinc[0]->vin_format.vin_win;
 
 	if (unlikely(is_invalid_dsp_addr(msg->raw_pic_addr))) {
 		return ;
 	}
 
+	get_vin_win(iav, &vin, 1);
 	raw_cap = &buf_cap->raw_info[buf_cap->write_index];
 	raw_cap->raw_addr = msg->raw_pic_addr;
 	raw_cap->raw_width = vin->width;
@@ -181,6 +252,31 @@ static void save_me0_data_info(struct ambarella_iav *iav, encode_msg_t *msg)
 	wake_up_interruptible_all(&buf_cap->me0_wq);
 }
 
+void save_qp_hist_info(struct ambarella_iav *iav, encode_msg_t *msg)
+{
+	struct iav_bufcap_info *buf_cap;
+	struct iav_qp_hist_info *qp_hist;
+	u32 seq_num;
+
+	buf_cap = &iav->buf_cap;
+	qp_hist = &buf_cap->qp_hist;
+	seq_num = buf_cap->seq_num;
+
+	qp_hist->stream_num = msg->raw_cap_cnt;
+	qp_hist->seq_num = seq_num;
+	if ((msg->qp_histo_addr < qp_hist->data_dsp_addr_base)
+			|| (msg->qp_histo_addr >= qp_hist->data_dsp_addr_end)) {
+		qp_hist->data_dsp_addr_base = msg->qp_histo_addr;
+		qp_hist->data_dsp_addr_end = msg->qp_histo_addr +
+			NUM_QP_HISTOGRAM_BUF * sizeof(struct iav_qp_histogram);
+		qp_hist->base_addr_set_flag = 1;
+	}
+	qp_hist->data_dsp_addr_cur = msg->qp_histo_addr;
+
+	buf_cap->qp_hist_data_valid = 1;
+	wake_up_interruptible(&buf_cap->qp_hist_wq);
+}
+
 static u32 get_dsp_sub_buf_idx(u32 buf_id, u32 is_yuv)
 {
 	u32 sub_buf_idx = 0;
@@ -418,6 +514,7 @@ void irq_update_bufcap(struct ambarella_iav *iav, encode_msg_t *msg)
 	save_srcbuf_data_info(iav, msg);
 	save_me1_data_info(iav, msg);
 	save_me0_data_info(iav, msg);
+	save_qp_hist_info(iav, msg);
 
 	++buf_cap->seq_num;
 
@@ -447,6 +544,14 @@ void iav_init_bufcap(struct ambarella_iav *iav)
 
 	buf_cap->me0_data_valid = 0;
 	init_waitqueue_head(&buf_cap->me0_wq);
+
+	buf_cap->qp_hist_data_valid = 0;
+	init_waitqueue_head(&buf_cap->qp_hist_wq);
+	buf_cap->qp_hist.base_addr_set_flag = 0;
+	buf_cap->qp_hist.data_dsp_addr_base = 0x0;
+	buf_cap->qp_hist.data_dsp_addr_cur = 0x0;
+	buf_cap->qp_hist.data_dsp_addr_end = 0x0;
+	buf_cap->qp_hist.data_virt_addr_base = 0x0;
 }
 
 int iav_query_rawdesc(struct ambarella_iav *iav,
@@ -458,7 +563,7 @@ int iav_query_rawdesc(struct ambarella_iav *iav,
 
 	if (iav->state == IAV_STATE_IDLE) {
 		iav_error("Invalid IAV state: %d!\n", iav->state);
-		return -EBADFD;
+		return -EPERM;
 	}
 
 	if (!iav->system_config[iav->encode_mode].raw_capture) {
@@ -486,8 +591,13 @@ int iav_query_rawdesc(struct ambarella_iav *iav,
 			break;
 		}
 
-		rawdesc->raw_addr_offset = DSP_TO_PHYS(raw_addr) -
-			iav->mmap[IAV_BUFFER_DSP].phys;
+		if (likely(!iav->dsp_partition_mapped)) {
+			rawdesc->raw_addr_offset = DSP_TO_PHYS(raw_addr) -
+					iav->mmap[IAV_BUFFER_DSP].phys;
+		} else {
+			rawdesc->raw_addr_offset = DSP_TO_PHYS(raw_addr) -
+					iav->mmap_dsp[IAV_DSP_SUB_BUF_RAW].phys;
+		}
 		rawdesc->width = buf_cap->raw_info[rd_idx].raw_width;
 		rawdesc->height = buf_cap->raw_info[rd_idx].raw_height;
 		rawdesc->pitch = buf_cap->raw_info[rd_idx].pitch;
@@ -516,7 +626,7 @@ int iav_query_yuvdesc(struct ambarella_iav *iav,
 
 	if (iav->state == IAV_STATE_IDLE) {
 		iav_error("Invalid IAV state: %d!\n", iav->state);
-		return -EBADFD;
+		return -EPERM;
 	}
 
 	buf_cap = &iav->buf_cap;
@@ -574,7 +684,7 @@ int iav_query_me1desc(struct ambarella_iav *iav,
 
 	if (iav->state == IAV_STATE_IDLE) {
 		iav_error("Invalid IAV state: %d!\n", iav->state);
-		return -EBADFD;
+		return -EPERM;
 	}
 
 	buf_cap = &iav->buf_cap;
@@ -630,7 +740,7 @@ int iav_query_me0desc(struct ambarella_iav *iav,
 
 	if (iav->state == IAV_STATE_IDLE) {
 		iav_error("Invalid IAV state: %d!\n", iav->state);
-		return -EBADFD;
+		return -EPERM;
 	}
 
 	buf_cap = &iav->buf_cap;
@@ -681,7 +791,7 @@ int iav_query_bufcapdesc(struct ambarella_iav *iav,
 
 	if (iav->state == IAV_STATE_IDLE) {
 		iav_error("Invalid IAV state: %d!\n", iav->state);
-		return -EBADFD;
+		return -EPERM;
 	}
 
 	buf_cap = &iav->buf_cap;
@@ -727,3 +837,91 @@ bufcapdesc_exit:
 	return rval;
 }
 
+int iav_query_qphistdesc(struct ambarella_iav *iav,
+	struct iav_qphistdesc *qphistdesc)
+{
+	int rval = 0;
+	u8 *start_addr, *buffer_base, *buffer_end;
+	u32 i, stream_num, seqnum;
+	void __iomem *base = NULL;
+	struct iav_bufcap_info *buf_cap;
+	struct iav_qp_hist_info *qp_hist;
+
+	buf_cap = &iav->buf_cap;
+	qp_hist = &buf_cap->qp_hist;
+
+	if (iav->state != IAV_STATE_ENCODING) {
+		qphistdesc->stream_num = 0;
+		return 0;
+	}
+	if (unlikely(is_invalid_qp_hist(iav))) {
+		qphistdesc->stream_num = 0;
+		return 0;
+	}
+
+	rval = wait_event_interruptible_timeout(buf_cap->qp_hist_wq,
+		(buf_cap->qp_hist_data_valid == 1), TWO_JIFFIES);
+	if (rval <= 0) {
+		iav_error("[TIMEOUT] Query QP HIST descriptor.\n");
+		return -EAGAIN;
+	} else {
+		rval = 0;
+	}
+
+	memset(qphistdesc, 0, sizeof(struct iav_qphistdesc));
+	mutex_lock(&iav->iav_mutex);
+	do {
+		stream_num = qp_hist->stream_num;
+		seqnum = qp_hist->seq_num;
+
+		iav_warn("Only can show accurate qp for QP delta case, "
+			"qp offset for MB level qp can't be supported. \n");
+
+		if (qp_hist->base_addr_set_flag == 1) {
+			if (qp_hist->data_virt_addr_base) {
+				base = (void __iomem *)qp_hist->data_virt_addr_base;
+				iounmap(base);
+				base = NULL;
+			}
+			base = ioremap_nocache(qp_hist->data_dsp_addr_base,
+				(qp_hist->data_dsp_addr_end - qp_hist->data_dsp_addr_base));
+			if (!base) {
+				iav_error("Failed to call ioremap() for IAV.\n");
+				return -ENOMEM;
+			}
+			qp_hist->data_virt_addr_base = (u32)base;
+			qp_hist->base_addr_set_flag = 0;
+		}
+		buffer_base = (u8 *)qp_hist->data_virt_addr_base;
+		buffer_end = (u8 *)(qp_hist->data_virt_addr_base +
+			(qp_hist->data_dsp_addr_end - qp_hist->data_dsp_addr_base));
+		start_addr = (u8 *)(qp_hist->data_virt_addr_base +
+			(qp_hist->data_dsp_addr_cur - qp_hist->data_dsp_addr_base));
+
+		/* now fill and check the data */
+		qphistdesc->stream_num = stream_num;
+		qphistdesc->seq_num = seqnum;
+		for (i = 0; i < stream_num; ++i) {
+			if (check_qp_hist_param(iav, (struct iav_qp_histogram *)start_addr) < 0) {
+				iav_error("Invalid QP histogram data!\n");
+				mutex_unlock(&iav->iav_mutex);
+				return -EINVAL;
+			}
+			memcpy(&qphistdesc->stream_qp_hist[i], start_addr,
+				sizeof(struct iav_qp_histogram));
+			start_addr += sizeof(struct iav_qp_histogram);
+			if (start_addr == buffer_end) {
+				start_addr = buffer_base;
+			}
+		}
+
+		/* clear data valid flag */
+		spin_lock_irq(&iav->iav_lock);
+		buf_cap->qp_hist_data_valid = 0;
+		spin_unlock_irq(&iav->iav_lock);
+	} while (0);
+	mutex_unlock(&iav->iav_mutex);
+
+	return rval;
+}
+
diff --git a/drivers/iav/arch_s2l/iav_enc_custom.c b/drivers/iav/arch_s2l/iav_enc_custom.c
new file mode 100644
index 0000000..6664f7e
--- /dev/null
+++ b/drivers/iav/arch_s2l/iav_enc_custom.c
@@ -0,0 +1,58 @@
+/*
+ * iav_enc_custom.c
+ *
+ * History:
+ *	2015/12/14 - [Jian Tang] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+
+#include <config.h>
+#include <linux/random.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/fs.h>
+#include <linux/clk.h>
+#include <iav_utils.h>
+#include <iav_ioctl.h>
+#include <dsp_api.h>
+#include <dsp_format.h>
+#include <vin_api.h>
+#include <vout_api.h>
+#include "iav.h"
+#include "iav_dsp_cmd.h"
+#include "iav_vin.h"
+#include "iav_vout.h"
+#include "iav_enc_api.h"
+#include "iav_enc_utils.h"
+
+int iav_ioc_custom_cmds(struct ambarella_iav * iav, void __user * arg)
+{
+	iav_debug("This is the IOCTL for customized commands.\n");
+	return 0;
+}
+
diff --git a/drivers/iav/arch_s2l/iav_enc_efm.c b/drivers/iav/arch_s2l/iav_enc_efm.c
index 2146cc6..69aba17 100644
--- a/drivers/iav/arch_s2l/iav_enc_efm.c
+++ b/drivers/iav/arch_s2l/iav_enc_efm.c
@@ -3,14 +3,33 @@
  *
  * History:
  *	2015/07/01 - [Zhaoyang Chen] created file
- * Copyright (C) 2015-2019, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <config.h>
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
@@ -115,9 +134,9 @@ void handle_efm_msg(struct ambarella_iav *iav, DSP_MSG *msg)
 		pool->req_idx = (pool->req_idx + 1) % efm->req_buf_num;
 		pool->req_msg_num++;
 		if (pool->req_num > 1 && pool->req_msg_num == pool->req_num) {
-			wake_up_interruptible(&efm->wq);
 			pool->req_num = 1;
 			efm->state = EFM_STATE_WORKING_OK;
+			wake_up_interruptible(&efm->wq);
 		}
 		break;
 	case DSP_STATUS_MSG_EFM_HANDSHAKE:
@@ -163,22 +182,12 @@ int iav_ioc_efm_get_pool_info(struct ambarella_iav * iav, void __user * arg)
 	return copy_to_user(arg, &info, sizeof(info)) ? -EFAULT : 0;
 }
 
-int iav_ioc_efm_request_frame(struct ambarella_iav * iav, void __user * arg)
+static int request_efm_frame(struct ambarella_iav *iav, struct iav_efm_request_frame *request)
 {
 	struct iav_efm_info *efm = &iav->efm;
 	struct iav_efm_buf_pool *pool = &efm->buf_pool;
-	struct iav_efm_request_frame request;
 	u32 idx, i;
 
-	if (copy_from_user(&request, arg, sizeof(request)))
-		return -EFAULT;
-
-	if(check_efm(iav) < 0) {
-		return -EINVAL;
-	}
-
-	mutex_lock(&iav->iav_mutex);
-
 	pool->req_msg_num = 0;
 	if (pool->req_num == IAV_EFM_INIT_REQ_NUM) {
 		// request frames from DSP for the first time
@@ -186,8 +195,7 @@ int iav_ioc_efm_request_frame(struct ambarella_iav * iav, void __user * arg)
 			cmd_efm_req_frame_buf(iav, NULL);
 		}
 		if (wait_efm_msg(iav, EFM_STATE_WORKING_OK) < 0) {
-			mutex_unlock(&iav->iav_mutex);
-			return -1;
+			return -EFAULT;
 		}
 	} else {
 		cmd_efm_req_frame_buf(iav, NULL);
@@ -195,61 +203,132 @@ int iav_ioc_efm_request_frame(struct ambarella_iav * iav, void __user * arg)
 	idx = pool->hs_idx;
 	if (!pool->requested[idx]) {
 		iav_error("Failed to request frame, idx: %d!\n", idx);
-		mutex_unlock(&iav->iav_mutex);
 		return -EAGAIN;
 	}
 	if (!iav->dsp_partition_mapped) {
-		request.yuv_luma_offset = DSP_TO_PHYS(pool->yuv_luma_addr[idx]) -
+		request->yuv_luma_offset = DSP_TO_PHYS(pool->yuv_luma_addr[idx]) -
 			iav->mmap[IAV_BUFFER_DSP].phys;
-		request.yuv_chroma_offset = DSP_TO_PHYS(pool->yuv_chroma_addr[idx]) -
+		request->yuv_chroma_offset = DSP_TO_PHYS(pool->yuv_chroma_addr[idx]) -
 			iav->mmap[IAV_BUFFER_DSP].phys;
-		request.me1_offset = DSP_TO_PHYS(pool->me1_addr[idx]) -
+		request->me1_offset = DSP_TO_PHYS(pool->me1_addr[idx]) -
 			iav->mmap[IAV_BUFFER_DSP].phys;
 	} else {
-		request.yuv_luma_offset = DSP_TO_PHYS(pool->yuv_luma_addr[idx]) -
+		request->yuv_luma_offset = DSP_TO_PHYS(pool->yuv_luma_addr[idx]) -
 			iav->mmap_dsp[IAV_DSP_SUB_BUF_EFM_YUV].phys;
-		request.yuv_chroma_offset = DSP_TO_PHYS(pool->yuv_chroma_addr[idx]) -
+		request->yuv_chroma_offset = DSP_TO_PHYS(pool->yuv_chroma_addr[idx]) -
 			iav->mmap[IAV_DSP_SUB_BUF_EFM_YUV].phys;
-		request.me1_offset = DSP_TO_PHYS(pool->me1_addr[idx]) -
+		request->me1_offset = DSP_TO_PHYS(pool->me1_addr[idx]) -
 			iav->mmap_dsp[IAV_DSP_SUB_BUF_EFM_ME1].phys;
 	}
-	request.frame_idx = idx;
+	request->frame_idx = idx;
+
+	return 0;
+}
+
+int iav_ioc_efm_request_frame(struct ambarella_iav * iav, void __user * arg)
+{
+	struct iav_efm_request_frame request;
+	int rval;
+
+	if (copy_from_user(&request, arg, sizeof(request)))
+		return -EFAULT;
+
+	if(check_efm(iav) < 0) {
+		return -EINVAL;
+	}
 
+	mutex_lock(&iav->iav_mutex);
+	rval = request_efm_frame(iav, &request);
 	mutex_unlock(&iav->iav_mutex);
+	if (rval) {
+		return rval;
+	}
 
 	return copy_to_user(arg, &request, sizeof(request)) ? -EFAULT : 0;
 }
 
-int iav_ioc_efm_handshake_frame(struct ambarella_iav * iav, void __user * arg)
+static int handshake_efm_frame(struct ambarella_iav *iav, struct iav_efm_handshake_frame *handshake)
 {
 	struct iav_efm_info *efm = &iav->efm;
 	struct iav_efm_buf_pool *pool = &efm->buf_pool;
-	struct iav_efm_handshake_frame handshake;
-	int ret = 0;
+	struct iav_stream *stream = NULL;
 
-	if (copy_from_user(&handshake, arg, sizeof(handshake)))
-		return -EFAULT;
+	u64 hwpts = 0;
+	int ret = 0, i;
 
 	if(check_efm(iav) < 0) {
 		return -EPERM;
 	}
 
-	if (handshake.frame_idx != pool->hs_idx) {
+	for (i = 0; i < IAV_MAX_ENCODE_STREAMS_NUM; ++i) {
+		stream = &iav->stream[i];
+		if (stream->format.buf_id == IAV_SRCBUF_EFM) {
+			break;
+		}
+	}
+	if (i == IAV_MAX_ENCODE_STREAMS_NUM) {
+		iav_error("no EFM stream found\n");
+		return -EINVAL;
+	}
+
+	if (handshake->frame_idx != pool->hs_idx) {
 		iav_error("Invalid frame idx for handshake, req: %u, curr: %u!\n",
-			pool->hs_idx, handshake.frame_idx);
+			pool->hs_idx, handshake->frame_idx);
 		return -EINVAL;
 	}
 
-	mutex_lock(&iav->iav_mutex);
+	if (is_stream_in_idle(stream) && handshake->is_last_frame) {
+		iav_error("Cannot handshake frame with is_last_frame = 1 in idle state\n");
+		return -EINVAL;
+	}
 
-	efm->curr_pts = handshake.frame_pts;
+	if (handshake->use_hw_pts) {
+		get_hwtimer_output_ticks(&hwpts);
+	} else {
+		hwpts = handshake->frame_pts;
+	}
+	efm->curr_pts = hwpts & 0xFFFFFFFF;
 
-	ret = cmd_efm_handshake(iav, NULL);
+	ret = cmd_efm_handshake(iav, NULL, handshake->is_last_frame);
 
 	pool->requested[pool->hs_idx] = 0;
 	pool->hs_idx = (pool->hs_idx + 1) % efm->req_buf_num;
 	efm->valid_num++;
 
+	/* wait EFM stream to switch from encoding to idle */
+	if (handshake->is_last_frame) {
+		/* NOTE: on s2l platform, we need to feed extra frames whose next_is_last_frame = 0
+		to make vdsp switch from encoding to idle after feeding the frame whose
+		next_is_last_frame = 1 */
+		iav_efm_feed_empty_frame(iav, stream);
+		if (is_stream_in_encoding(stream)) {
+			mutex_unlock(&iav->iav_mutex);
+			ret = wait_event_interruptible_timeout(stream->venc_wq,
+				is_stream_in_idle(stream), FIVE_JIFFIES);
+			mutex_lock(&iav->iav_mutex);
+			if (ret <= 0) {
+				iav_error("stream %c [EFM]: wait event timeout\n",
+					'A' + stream->format.id);
+				ret = -EFAULT;
+			} else {
+				ret = 0;
+			}
+		}
+	}
+
+	return ret;
+}
+
+int iav_ioc_efm_handshake_frame(struct ambarella_iav * iav, void __user * arg)
+{
+	struct iav_efm_handshake_frame handshake;
+	int ret = 0;
+
+	if (copy_from_user(&handshake, arg, sizeof(handshake)))
+		return -EFAULT;
+
+	mutex_lock(&iav->iav_mutex);
+	ret = handshake_efm_frame(iav, &handshake);
 	mutex_unlock(&iav->iav_mutex);
 
 	return ret;
@@ -298,3 +377,27 @@ int iav_create_efm_pool(struct ambarella_iav *iav)
 	return 0;
 }
 
+int iav_efm_feed_empty_frame(struct ambarella_iav * iav, struct iav_stream *stream)
+{
+	struct iav_efm_request_frame request;
+	struct iav_efm_handshake_frame handshake;
+	int i, feed_count = 2;
+	int ret = 0;
+
+	for (i = 0; i < feed_count; i++) {
+		ret = request_efm_frame(iav, &request);
+		if (ret) {
+			iav_error("Cannot request frame buffer\n");
+			return ret;
+		}
+		handshake.frame_idx = request.frame_idx;
+
+		wait_vcap_count(iav, 1);
+		handshake.use_hw_pts = 1;
+		handshake.is_last_frame = 0;
+		ret = handshake_efm_frame(iav, &handshake);
+	}
+
+	return ret;
+}
+
diff --git a/drivers/iav/arch_s2l/iav_enc_limit.c b/drivers/iav/arch_s2l/iav_enc_limit.c
index 742c25d..f795116 100644
--- a/drivers/iav/arch_s2l/iav_enc_limit.c
+++ b/drivers/iav/arch_s2l/iav_enc_limit.c
@@ -4,14 +4,33 @@
  * History:
  *	2013/02/25 - [Cao Rongrong] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <asm/uaccess.h>
 #include "iav.h"
 
@@ -59,48 +78,87 @@ struct iav_system_load G_system_load[IAV_CHIP_ID_S2L_NUM] =
 {
 	[IAV_CHIP_ID_S2L_22M - IAV_CHIP_ID_S2LM_FIRST] = {
 		.system_load = SYS_ENC_LOAD_S2L_22M,
+		.vin_pps = SYS_VIN_PPS_S2L_22M,
 		.desc = "720p60",
 		.max_enc_num = IAV_STREAM_MAX_NUM_ALL,
+		.vin_pps_desc = "3MP30",
 	},
 	[IAV_CHIP_ID_S2L_33M - IAV_CHIP_ID_S2LM_FIRST] = {
 		.system_load = SYS_ENC_LOAD_S2L_33M,
+		.vin_pps = SYS_VIN_PPS_S2L_33M,
 		.desc = "1080p31 + 480p30 + CIFp30",
 		.max_enc_num = IAV_STREAM_MAX_NUM_ALL,
+		.vin_pps_desc = "4MP30",
 	},
 	[IAV_CHIP_ID_S2L_55M - IAV_CHIP_ID_S2LM_FIRST] = {
 		.system_load = SYS_ENC_LOAD_S2L_55M,
+		.vin_pps = SYS_VIN_PPS_S2L_55M,
 		.desc = "3Mp30 + 480p30",
 		.max_enc_num = IAV_STREAM_MAX_NUM_ALL,
+		.vin_pps_desc = "6MP30",
 	},
 	[IAV_CHIP_ID_S2L_99M - IAV_CHIP_ID_S2LM_FIRST] = {
 		.system_load = SYS_ENC_LOAD_S2L_99M,
+		.vin_pps = SYS_VIN_PPS_S2L_99M,
 		.desc = "5Mp20 + 480p20",
 		.max_enc_num = IAV_STREAM_MAX_NUM_ALL,
+		.vin_pps_desc = "8MP30",
 	},
 	[IAV_CHIP_ID_S2L_63 - IAV_CHIP_ID_S2LM_FIRST] = {
 		.system_load = SYS_ENC_LOAD_S2L_63,
+		.vin_pps = SYS_VIN_PPS_S2L_63,
 		.desc = "3Mp30 + 480p30",
 		.max_enc_num = IAV_STREAM_MAX_NUM_ALL,
+		.vin_pps_desc = "8MP30",
 	},
 	[IAV_CHIP_ID_S2L_66 - IAV_CHIP_ID_S2LM_FIRST] = {
 		.system_load = SYS_ENC_LOAD_S2L_66,
+		.vin_pps = SYS_VIN_PPS_S2L_66,
 		.desc = "5Mp30 + 480p30",
 		.max_enc_num = IAV_STREAM_MAX_NUM_ALL,
+		.vin_pps_desc = "6MP60",
 	},
 	[IAV_CHIP_ID_S2L_88 - IAV_CHIP_ID_S2LM_FIRST] = {
 		.system_load = SYS_ENC_LOAD_S2L_88,
+		.vin_pps = SYS_VIN_PPS_S2L_88,
 		.desc = "5Mp30 + 480p30",
 		.max_enc_num = IAV_STREAM_MAX_NUM_ALL,
+		.vin_pps_desc = "6MP60",
 	},
 	[IAV_CHIP_ID_S2L_99 - IAV_CHIP_ID_S2LM_FIRST] = {
 		.system_load = SYS_ENC_LOAD_S2L_99,
+		.vin_pps = SYS_VIN_PPS_S2L_99,
 		.desc = "1080p110",
 		.max_enc_num = IAV_STREAM_MAX_NUM_ALL,
+		.vin_pps_desc = "6MP60",
 	},
 	[IAV_CHIP_ID_S2L_TEST - IAV_CHIP_ID_S2LM_FIRST] = {
 		.system_load = SYS_ENC_LOAD_S2L_TEST,
+		.vin_pps = SYS_VIN_PPS_S2L_TEST,
 		.desc = "5Mp20 + 480p20",
 		.max_enc_num = IAV_STREAM_MAX_NUM_ALL,
+		.vin_pps_desc = "8MP30",
+	},
+	[IAV_CHIP_ID_S2L_22 - IAV_CHIP_ID_S2LM_FIRST] = {
+		.system_load = SYS_ENC_LOAD_S2L_22,
+		.vin_pps = SYS_VIN_PPS_S2L_22,
+		.desc = "1080p25",
+		.max_enc_num = IAV_STREAM_MAX_NUM_ALL,
+		.vin_pps_desc = "6MP30",
+	},
+	[IAV_CHIP_ID_S2L_33MEX - IAV_CHIP_ID_S2LM_FIRST] = {
+		.system_load = SYS_ENC_LOAD_S2L_33M,
+		.vin_pps = SYS_VIN_PPS_S2L_33M,
+		.desc = "1080p31 + 480p30 + CIFp30",
+		.max_enc_num = IAV_STREAM_MAX_NUM_ALL,
+		.vin_pps_desc = "4MP30",
+	},
+	[IAV_CHIP_ID_S2L_33EX - IAV_CHIP_ID_S2LM_FIRST] = {
+		.system_load = SYS_ENC_LOAD_S2L_33M,
+		.vin_pps = SYS_VIN_PPS_S2L_33M,
+		.desc = "1080p31 + 480p30 + CIFp30",
+		.max_enc_num = IAV_STREAM_MAX_NUM_ALL,
+		.vin_pps_desc = "4MP30",
 	},
 };
 
@@ -109,6 +167,8 @@ struct iav_enc_limitation G_encode_limit[DSP_ENCODE_MODE_TOTAL_NUM] =
 	[DSP_NORMAL_ISO_MODE] = {
 		.max_main = {MAX_WIDTH_IN_HIGH_MP, MAX_HEIGHT_IN_HIGH_MP},
 		.min_main = {MIN_WIDTH_IN_HIGH_MP, MIN_HEIGHT_IN_HIGH_MP},
+		.max_main_input = {MAX_MAIN_BUF_INPUT_WIDTH_IN_HIGH_MP,
+			MAX_MAIN_BUF_INPUT_HEIGHT_IN_HIGH_MP},
 		.min_enc = {MIN_WIDTH_IN_STREAM_ROTATE, MIN_HEIGHT_IN_STREAM},
 		.max_enc_num = IAV_MAX_ENCODE_STREAMS_NUM,
 		.max_chroma_radius = CHROMA_RADIUS_32,
@@ -129,15 +189,18 @@ struct iav_enc_limitation G_encode_limit[DSP_ENCODE_MODE_TOTAL_NUM] =
 		.pm_mctf_supported = 1,
 		.wcr_supported = 0,
 		.idsp_upsample_supported = 1,
-		.me0_supported = ME0_SCALE_OFF,
+		.me0_supported = ME0_SCALE_16X,
 		.enc_raw_rgb_supported = 0,
 		.enc_raw_yuv_supported = 1,
 		.enc_from_mem_supported = 1,
+		.long_ref_b_supported = 1,
 	},
 
 	[DSP_MULTI_REGION_WARP_MODE] = {
 		.max_main = {MAX_WIDTH_IN_WARP, MAX_HEIGHT_IN_WARP},
 		.min_main = {MIN_WIDTH_IN_WARP, MIN_HEIGHT_IN_WARP},
+		.max_main_input = {MAX_MAIN_BUF_INPUT_WIDTH_IN_HIGH_MP,
+			MAX_MAIN_BUF_INPUT_HEIGHT_IN_HIGH_MP},
 		.min_enc = {MIN_WIDTH_IN_STREAM, MIN_HEIGHT_IN_STREAM},
 		.max_enc_num = IAV_MAX_ENCODE_STREAMS_NUM,
 		.max_chroma_radius = CHROMA_RADIUS_128,
@@ -162,11 +225,14 @@ struct iav_enc_limitation G_encode_limit[DSP_ENCODE_MODE_TOTAL_NUM] =
 		.enc_raw_rgb_supported = 0,
 		.enc_raw_yuv_supported = 0,
 		.enc_from_mem_supported = 0,
+		.long_ref_b_supported = 0,
 	},
 
 	[DSP_BLEND_ISO_MODE] = {
 		.max_main = {MAX_WIDTH_IN_HIGH_MP, MAX_HEIGHT_IN_HIGH_MP},
 		.min_main = {MIN_WIDTH_IN_HIGH_MP, MIN_HEIGHT_IN_HIGH_MP},
+		.max_main_input = {MAX_MAIN_BUF_INPUT_WIDTH_IN_HIGH_MP,
+			MAX_MAIN_BUF_INPUT_HEIGHT_IN_HIGH_MP},
 		.min_enc = {MIN_WIDTH_IN_STREAM_ROTATE, MIN_HEIGHT_IN_STREAM},
 		.max_enc_num = IAV_MAX_ENCODE_STREAMS_NUM,
 		.max_chroma_radius = CHROMA_RADIUS_128,
@@ -191,11 +257,14 @@ struct iav_enc_limitation G_encode_limit[DSP_ENCODE_MODE_TOTAL_NUM] =
 		.enc_raw_rgb_supported = 1,
 		.enc_raw_yuv_supported = 0,
 		.enc_from_mem_supported = 1,
+		.long_ref_b_supported = 0,
 	},
 
 	[DSP_SINGLE_REGION_WARP_MODE] = {
 		.max_main = {MAX_WIDTH_IN_FULL_FPS, MAX_HEIGHT_IN_FULL_FPS},
 		.min_main = {MIN_WIDTH_IN_FULL_FPS, MIN_HEIGHT_IN_FULL_FPS},
+		.max_main_input = {MAX_MAIN_BUF_INPUT_WIDTH_IN_HIGH_MP,
+			MAX_MAIN_BUF_INPUT_HEIGHT_IN_HIGH_MP},
 		.min_enc = {MIN_WIDTH_IN_STREAM_ROTATE, MIN_HEIGHT_IN_STREAM},
 		.max_enc_num = IAV_MAX_ENCODE_STREAMS_NUM,
 		.max_chroma_radius = CHROMA_RADIUS_32,
@@ -220,11 +289,14 @@ struct iav_enc_limitation G_encode_limit[DSP_ENCODE_MODE_TOTAL_NUM] =
 		.enc_raw_rgb_supported = 0,
 		.enc_raw_yuv_supported = 0,
 		.enc_from_mem_supported = 0,
+		.long_ref_b_supported = 0,
 	},
 
 	[DSP_ADVANCED_ISO_MODE] = {
 		.max_main = {MAX_WIDTH_IN_HIGH_MP, MAX_HEIGHT_IN_HIGH_MP},
 		.min_main = {MIN_WIDTH_IN_HIGH_MP, MIN_HEIGHT_IN_HIGH_MP},
+		.max_main_input = {MAX_MAIN_BUF_INPUT_WIDTH_IN_HIGH_MP,
+			MAX_MAIN_BUF_INPUT_HEIGHT_IN_HIGH_MP},
 		.min_enc = {MIN_WIDTH_IN_STREAM_ROTATE, MIN_HEIGHT_IN_STREAM},
 		.max_enc_num = IAV_MAX_ENCODE_STREAMS_NUM,
 		.max_chroma_radius = CHROMA_RADIUS_128,
@@ -249,11 +321,14 @@ struct iav_enc_limitation G_encode_limit[DSP_ENCODE_MODE_TOTAL_NUM] =
 		.enc_raw_rgb_supported = 1,
 		.enc_raw_yuv_supported = 0,
 		.enc_from_mem_supported = 1,
+		.long_ref_b_supported = 1,
 	},
 
 	[DSP_HDR_LINE_INTERLEAVED_MODE] = {
 		.max_main = {MAX_WIDTH_IN_HIGH_MP, MAX_HEIGHT_IN_HIGH_MP},
 		.min_main = {MIN_WIDTH_IN_HIGH_MP, MIN_HEIGHT_IN_HIGH_MP},
+		.max_main_input = {MAX_MAIN_BUF_INPUT_WIDTH_IN_HIGH_MP,
+			MAX_MAIN_BUF_INPUT_HEIGHT_IN_HIGH_MP},
 		.min_enc = {MIN_WIDTH_IN_STREAM_ROTATE, MIN_HEIGHT_IN_STREAM},
 		.max_enc_num = IAV_MAX_ENCODE_STREAMS_NUM,
 		.max_chroma_radius = CHROMA_RADIUS_32,
@@ -274,15 +349,18 @@ struct iav_enc_limitation G_encode_limit[DSP_ENCODE_MODE_TOTAL_NUM] =
 		.pm_mctf_supported = 1,
 		.wcr_supported = 0,
 		.idsp_upsample_supported = 1,
-		.me0_supported = ME0_SCALE_OFF,
+		.me0_supported = ME0_SCALE_16X,
 		.enc_raw_rgb_supported = 0,
 		.enc_raw_yuv_supported = 0,
 		.enc_from_mem_supported = 0,
+		.long_ref_b_supported = 0,
 	},
 
 	[DSP_HISO_VIDEO_MODE] = {
 		.max_main = {MAX_WIDTH_IN_FULL_FPS, MAX_HEIGHT_IN_FULL_FPS},
 		.min_main = {MIN_WIDTH_IN_FULL_FPS, MIN_HEIGHT_IN_FULL_FPS},
+		.max_main_input = {MAX_MAIN_BUF_INPUT_WIDTH_IN_HIGH_MP,
+			MAX_MAIN_BUF_INPUT_HEIGHT_IN_HIGH_MP},
 		.min_enc = {MIN_WIDTH_IN_STREAM, MIN_HEIGHT_IN_STREAM},
 		.max_enc_num = IAV_MAX_ENCODE_STREAMS_NUM,
 		.max_chroma_radius = CHROMA_RADIUS_32,
@@ -307,6 +385,7 @@ struct iav_enc_limitation G_encode_limit[DSP_ENCODE_MODE_TOTAL_NUM] =
 		.enc_raw_rgb_supported = 1,
 		.enc_raw_yuv_supported = 0,
 		.enc_from_mem_supported = 0,
+		.long_ref_b_supported = 0,
 	},
 };
 
@@ -329,6 +408,7 @@ struct iav_system_config G_system_config[DSP_ENCODE_MODE_TOTAL_NUM] =
 		.enc_raw_rgb = 0,
 		.enc_raw_yuv = 0,
 		.enc_from_mem = 0,
+		.long_ref_b_frame = 0,
 	},
 
 	[DSP_MULTI_REGION_WARP_MODE] = {
@@ -348,6 +428,7 @@ struct iav_system_config G_system_config[DSP_ENCODE_MODE_TOTAL_NUM] =
 		.enc_raw_rgb = 0,
 		.enc_raw_yuv = 0,
 		.enc_from_mem = 0,
+		.long_ref_b_frame = 0,
 	},
 
 	[DSP_BLEND_ISO_MODE] = {
@@ -367,6 +448,7 @@ struct iav_system_config G_system_config[DSP_ENCODE_MODE_TOTAL_NUM] =
 		.enc_raw_rgb = 0,
 		.enc_raw_yuv = 0,
 		.enc_from_mem = 0,
+		.long_ref_b_frame = 0,
 	},
 
 	[DSP_SINGLE_REGION_WARP_MODE] = {
@@ -380,13 +462,13 @@ struct iav_system_config G_system_config[DSP_ENCODE_MODE_TOTAL_NUM] =
 		.lens_warp = 0,
 		.vout_swap = 0,
 		.iso_type = ISO_TYPE_LOW,
-
 		.idsp_upsample_type = IDSP_UPSAMPLE_TYPE_OFF,
 		.me0_scale = ME0_SCALE_OFF,
 		.mctf_pm = 1,
 		.enc_raw_rgb = 0,
 		.enc_raw_yuv = 0,
 		.enc_from_mem = 0,
+		.long_ref_b_frame = 0,
 	},
 
 	[DSP_ADVANCED_ISO_MODE] = {
@@ -406,6 +488,7 @@ struct iav_system_config G_system_config[DSP_ENCODE_MODE_TOTAL_NUM] =
 		.enc_raw_rgb = 0,
 		.enc_raw_yuv = 0,
 		.enc_from_mem = 0,
+		.long_ref_b_frame = 0,
 	},
 
 	[DSP_HDR_LINE_INTERLEAVED_MODE] = {
@@ -425,6 +508,7 @@ struct iav_system_config G_system_config[DSP_ENCODE_MODE_TOTAL_NUM] =
 		.enc_raw_rgb = 0,
 		.enc_raw_yuv = 0,
 		.enc_from_mem = 0,
+		.long_ref_b_frame = 0,
 	},
 
 	[DSP_HISO_VIDEO_MODE] = {
@@ -444,6 +528,7 @@ struct iav_system_config G_system_config[DSP_ENCODE_MODE_TOTAL_NUM] =
 		.enc_raw_rgb = 0,
 		.enc_raw_yuv = 0,
 		.enc_from_mem = 0,
+		.long_ref_b_frame = 0,
 	},
 };
 
diff --git a/drivers/iav/arch_s2l/iav_enc_mem.c b/drivers/iav/arch_s2l/iav_enc_mem.c
index 40c55ab..9155803 100644
--- a/drivers/iav/arch_s2l/iav_enc_mem.c
+++ b/drivers/iav/arch_s2l/iav_enc_mem.c
@@ -3,14 +3,33 @@
  *
  * History:
  *	2015/03/13 - [Zhaoyang Chen] created file
- * Copyright (C) 2015-2019, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <config.h>
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
@@ -443,69 +462,83 @@ int iav_create_mmap_table(struct ambarella_iav *iav)
 	}
 	iav->mmap_base = (u32)base;
 
-	iav->mmap[IAV_BUFFER_BSB].phys = bsb_start;
-	iav->mmap[IAV_BUFFER_BSB].virt = (u32)base;
+	iav->mmap[IAV_BUFFER_BSB].phys = IAV_DRAM_BSB ? bsb_start : 0;
+	iav->mmap[IAV_BUFFER_BSB].virt = IAV_DRAM_BSB ? (u32)base : 0;
 	iav->mmap[IAV_BUFFER_BSB].size = IAV_DRAM_BSB;
 	iav->bsb_free_bytes = iav->mmap[IAV_BUFFER_BSB].size;
 	bsb_offset += iav->mmap[IAV_BUFFER_BSB].size;
 
-	iav->mmap[IAV_BUFFER_USR].phys = bsb_start + bsb_offset;
-	iav->mmap[IAV_BUFFER_USR].virt = (u32)(base + bsb_offset);
+	iav->mmap[IAV_BUFFER_USR].phys = IAV_DRAM_USR ? (bsb_start + bsb_offset) : 0;
+	iav->mmap[IAV_BUFFER_USR].virt = IAV_DRAM_USR ? (u32)(base + bsb_offset) : 0;
 	iav->mmap[IAV_BUFFER_USR].size = IAV_DRAM_USR;
 	bsb_offset += iav->mmap[IAV_BUFFER_USR].size;
 
-	iav->mmap[IAV_BUFFER_OVERLAY].phys = bsb_start + bsb_offset;
-	iav->mmap[IAV_BUFFER_OVERLAY].virt = (u32)(base + bsb_offset);
+	iav->mmap[IAV_BUFFER_MV].phys = IAV_DRAM_MV ? (bsb_start + bsb_offset) : 0;
+	iav->mmap[IAV_BUFFER_MV].virt = IAV_DRAM_MV ? (u32)(base + bsb_offset) : 0;
+	iav->mmap[IAV_BUFFER_MV].size = IAV_DRAM_MV;
+	bsb_offset += iav->mmap[IAV_BUFFER_MV].size;
+
+	iav->mmap[IAV_BUFFER_OVERLAY].phys = IAV_DRAM_OVERLAY ? (bsb_start + bsb_offset) : 0;
+	iav->mmap[IAV_BUFFER_OVERLAY].virt = IAV_DRAM_OVERLAY ? (u32)(base + bsb_offset) : 0;
 	iav->mmap[IAV_BUFFER_OVERLAY].size = IAV_DRAM_OVERLAY;
 	bsb_offset += iav->mmap[IAV_BUFFER_OVERLAY].size;
 
-	iav->mmap[IAV_BUFFER_QPMATRIX].phys = bsb_start + bsb_offset;
-	iav->mmap[IAV_BUFFER_QPMATRIX].virt = (u32)(base + bsb_offset);
+	iav->mmap[IAV_BUFFER_QPMATRIX].phys = IAV_DRAM_QPM ? (bsb_start + bsb_offset) : 0;
+	iav->mmap[IAV_BUFFER_QPMATRIX].virt = IAV_DRAM_QPM ? (u32)(base + bsb_offset) : 0;
 	iav->mmap[IAV_BUFFER_QPMATRIX].size = IAV_DRAM_QPM;
 	bsb_offset += iav->mmap[IAV_BUFFER_QPMATRIX].size;
 
-	iav->mmap[IAV_BUFFER_WARP].phys = bsb_start + bsb_offset;
-	iav->mmap[IAV_BUFFER_WARP].virt = (u32)(base + bsb_offset);
+	iav->mmap[IAV_BUFFER_WARP].phys = IAV_DRAM_WARP ? (bsb_start + bsb_offset) : 0;
+	iav->mmap[IAV_BUFFER_WARP].virt = IAV_DRAM_WARP ? (u32)(base + bsb_offset) : 0;
 	iav->mmap[IAV_BUFFER_WARP].size = IAV_DRAM_WARP;
 	bsb_offset += iav->mmap[IAV_BUFFER_WARP].size;
 
-	iav->mmap[IAV_BUFFER_QUANT].phys = bsb_start + bsb_offset;
-	iav->mmap[IAV_BUFFER_QUANT].virt = (u32)(base + bsb_offset);
+	iav->mmap[IAV_BUFFER_QUANT].phys = IAV_DRAM_QUANT ? (bsb_start + bsb_offset) : 0;
+	iav->mmap[IAV_BUFFER_QUANT].virt = IAV_DRAM_QUANT ? (u32)(base + bsb_offset) : 0;
 	iav->mmap[IAV_BUFFER_QUANT].size = IAV_DRAM_QUANT;
 	bsb_offset += iav->mmap[IAV_BUFFER_QUANT].size;
 
-	iav->mmap[IAV_BUFFER_IMG].phys = bsb_start + bsb_offset;
-	iav->mmap[IAV_BUFFER_IMG].virt = (u32)(base + bsb_offset);
+	iav->mmap[IAV_BUFFER_IMG].phys = IAV_DRAM_IMG ? (bsb_start + bsb_offset) : 0;
+	iav->mmap[IAV_BUFFER_IMG].virt = IAV_DRAM_IMG ? (u32)(base + bsb_offset) : 0;
 	iav->mmap[IAV_BUFFER_IMG].size = IAV_DRAM_IMG;
 	bsb_offset += iav->mmap[IAV_BUFFER_IMG].size;
 
 	/* BPC and MCTF share the same buffer */
-	iav->mmap[IAV_BUFFER_PM_BPC].phys = bsb_start + bsb_offset;
-	iav->mmap[IAV_BUFFER_PM_BPC].virt = (u32)(base + bsb_offset);
+	iav->mmap[IAV_BUFFER_PM_BPC].phys = IAV_DRAM_PM ? (bsb_start + bsb_offset) : 0;
+	iav->mmap[IAV_BUFFER_PM_BPC].virt = IAV_DRAM_PM ? (u32)(base + bsb_offset) : 0;
 	iav->mmap[IAV_BUFFER_PM_BPC].size = IAV_DRAM_PM;
-	iav->mmap[IAV_BUFFER_PM_MCTF].phys = bsb_start + bsb_offset;
-	iav->mmap[IAV_BUFFER_PM_MCTF].virt = (u32)(base + bsb_offset);
+	iav->mmap[IAV_BUFFER_PM_MCTF].phys = IAV_DRAM_PM ? (bsb_start + bsb_offset) : 0;
+	iav->mmap[IAV_BUFFER_PM_MCTF].virt = IAV_DRAM_PM ? (u32)(base + bsb_offset) : 0;
 	iav->mmap[IAV_BUFFER_PM_MCTF].size = IAV_DRAM_PM;
 	bsb_offset += IAV_DRAM_PM;
 
-	iav->mmap[IAV_BUFFER_BPC].phys = bsb_start + bsb_offset;
-	iav->mmap[IAV_BUFFER_BPC].virt = (u32)(base + bsb_offset);
+	iav->mmap[IAV_BUFFER_BPC].phys = IAV_DRAM_BPC ? (bsb_start + bsb_offset) : 0;
+	iav->mmap[IAV_BUFFER_BPC].virt = IAV_DRAM_BPC ? (u32)(base + bsb_offset) : 0;
 	iav->mmap[IAV_BUFFER_BPC].size = IAV_DRAM_BPC;
 	bsb_offset += iav->mmap[IAV_BUFFER_BPC].size;
 
-	iav->mmap[IAV_BUFFER_CMD_SYNC].phys = bsb_start + bsb_offset;
-	iav->mmap[IAV_BUFFER_CMD_SYNC].virt = (u32)(base + bsb_offset);
+	iav->mmap[IAV_BUFFER_CMD_SYNC].phys = IAV_DRAM_CMD_SYNC ? (bsb_start + bsb_offset) : 0;
+	iav->mmap[IAV_BUFFER_CMD_SYNC].virt = IAV_DRAM_CMD_SYNC ? (u32)(base + bsb_offset) : 0;
 	iav->mmap[IAV_BUFFER_CMD_SYNC].size = IAV_DRAM_CMD_SYNC;
 	bsb_offset += iav->mmap[IAV_BUFFER_CMD_SYNC].size;
 
+	iav->mmap[IAV_BUFFER_VCA].phys = IAV_DRAM_VCA ? (bsb_start + bsb_offset) : 0;
+	iav->mmap[IAV_BUFFER_VCA].virt = IAV_DRAM_VCA ? (u32)(base + bsb_offset) : 0;
+	iav->mmap[IAV_BUFFER_VCA].size = IAV_DRAM_VCA;
+	bsb_offset += iav->mmap[IAV_BUFFER_VCA].size;
+
 	BUG_ON(bsb_offset > IAV_DRAM_MAX);
 
-	iav->mmap[IAV_BUFFER_FB_DATA].phys = bsb_start + DSP_BSB_SIZE + DSP_IAVRSVD_SIZE;
-	iav->mmap[IAV_BUFFER_FB_DATA].virt = (u32)(base + DSP_BSB_SIZE + DSP_IAVRSVD_SIZE);
+	iav->mmap[IAV_BUFFER_FB_DATA].phys =
+		IAV_DRAM_FB_DATA ? (bsb_start + DSP_BSB_SIZE + DSP_IAVRSVD_SIZE) : 0;
+	iav->mmap[IAV_BUFFER_FB_DATA].virt =
+		IAV_DRAM_FB_DATA ? (u32)(base + DSP_BSB_SIZE + DSP_IAVRSVD_SIZE) : 0;
 	iav->mmap[IAV_BUFFER_FB_DATA].size = IAV_DRAM_FB_DATA;
 
-	iav->mmap[IAV_BUFFER_FB_AUDIO].phys = iav->mmap[IAV_BUFFER_FB_DATA].phys + DSP_FASTDATA_SIZE;
-	iav->mmap[IAV_BUFFER_FB_AUDIO].virt = iav->mmap[IAV_BUFFER_FB_DATA].virt + DSP_FASTDATA_SIZE;
+	iav->mmap[IAV_BUFFER_FB_AUDIO].phys =
+		IAV_DRAM_FB_AUDIO ? (iav->mmap[IAV_BUFFER_FB_DATA].phys + DSP_FASTDATA_SIZE) : 0;
+	iav->mmap[IAV_BUFFER_FB_AUDIO].virt =
+		IAV_DRAM_FB_AUDIO ? (iav->mmap[IAV_BUFFER_FB_DATA].virt + DSP_FASTDATA_SIZE)  : 0;
 	iav->mmap[IAV_BUFFER_FB_AUDIO].size = IAV_DRAM_FB_AUDIO;
 
 	return 0;
diff --git a/drivers/iav/arch_s2l/iav_enc_perf.c b/drivers/iav/arch_s2l/iav_enc_perf.c
index c693218..5f452f7 100644
--- a/drivers/iav/arch_s2l/iav_enc_perf.c
+++ b/drivers/iav/arch_s2l/iav_enc_perf.c
@@ -3,14 +3,33 @@
  *
  * History:
  *	2012/04/13 - [Jian Tang] created file
- * Copyright (C) 2007-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <config.h>
 #include <linux/random.h>
 #include <linux/slab.h>
@@ -55,7 +74,7 @@ static struct iav_system_freq G_system_freq[IAV_CHIP_ID_S2L_NUM] = {
 		.core_MHz = 144,
 		.dram_MHz = 456,
 	},
-#ifndef CONFIG_BOARD_VERSION_S2LMKIWI_S2LMHC
+#if (!defined(CONFIG_BOARD_VERSION_S2LMKIWI_S2LMHC) && !defined(CONFIG_BOARD_VERSION_S2LMIRONMAN_S2L55MHC))
 	[IAV_CHIP_ID_S2L_33M] = {
 		.cortex_MHz = 600,
 		.idsp_MHz = 216,
@@ -77,19 +96,31 @@ static struct iav_system_freq G_system_freq[IAV_CHIP_ID_S2L_NUM] = {
 #else
 	[IAV_CHIP_ID_S2L_33M] = {
 		.cortex_MHz = 600,
+#ifndef CONFIG_AMBARELLA_IAV_DRAM_VOUT_ONLY
 		.idsp_MHz = 240,
+#else
+		.idsp_MHz = 312,
+#endif
 		.core_MHz = 288,
 		.dram_MHz = 564,
 	},
 	[IAV_CHIP_ID_S2L_55M] = {
 		.cortex_MHz = 600,
+#ifndef CONFIG_AMBARELLA_IAV_DRAM_VOUT_ONLY
 		.idsp_MHz = 240,
+#else
+		.idsp_MHz = 312,
+#endif
 		.core_MHz = 288,
 		.dram_MHz = 564,
 	},
 	[IAV_CHIP_ID_S2L_99M] = {
 		.cortex_MHz = 600,
+#ifndef CONFIG_AMBARELLA_IAV_DRAM_VOUT_ONLY
 		.idsp_MHz = 240,
+#else
+		.idsp_MHz = 312,
+#endif
 		.core_MHz = 288,
 		.dram_MHz = 564,
 	},
@@ -98,7 +129,7 @@ static struct iav_system_freq G_system_freq[IAV_CHIP_ID_S2L_NUM] = {
 		.cortex_MHz = 816,
 		.idsp_MHz = 336,
 		.core_MHz = 312,
-		.dram_MHz = 600,
+		.dram_MHz = 588,
 	},
 	[IAV_CHIP_ID_S2L_66] = {
 		.cortex_MHz = 1008,
@@ -118,7 +149,7 @@ static struct iav_system_freq G_system_freq[IAV_CHIP_ID_S2L_NUM] = {
 		.core_MHz = 432,
 		.dram_MHz = 660,
 	},
-#ifndef CONFIG_BOARD_VERSION_S2LMKIWI_S2LMHC
+#if (!defined(CONFIG_BOARD_VERSION_S2LMKIWI_S2LMHC) && !defined(CONFIG_BOARD_VERSION_S2LMIRONMAN_S2L55MHC))
 	[IAV_CHIP_ID_S2L_TEST] = {
 		.cortex_MHz = 600,
 		.idsp_MHz = 216,
@@ -128,11 +159,33 @@ static struct iav_system_freq G_system_freq[IAV_CHIP_ID_S2L_NUM] = {
 #else
 	[IAV_CHIP_ID_S2L_TEST] = {
 		.cortex_MHz = 600,
+#ifndef CONFIG_AMBARELLA_IAV_DRAM_VOUT_ONLY
 		.idsp_MHz = 240,
+#else
+		.idsp_MHz = 312,
+#endif
 		.core_MHz = 288,
 		.dram_MHz = 564,
 	},
 #endif
+	[IAV_CHIP_ID_S2L_22] = {
+		.cortex_MHz = 816,
+		.idsp_MHz = 240,
+		.core_MHz = 288,
+		.dram_MHz = 588,
+	},
+	[IAV_CHIP_ID_S2L_33MEX] = {
+		.cortex_MHz = 600,
+		.idsp_MHz = 144,
+		.core_MHz = 144,
+		.dram_MHz = 456,
+	},
+	[IAV_CHIP_ID_S2L_33EX] = {
+		.cortex_MHz = 816,
+		.idsp_MHz = 144,
+		.core_MHz = 144,
+		.dram_MHz = 456,
+	},
 };
 
 struct iav_dram_coeff G_dram_buf_coeffs[DSP_ENCODE_MODE_TOTAL_NUM] = {
@@ -514,7 +567,7 @@ static struct iav_dram_buf_num G_sz_buf_num[DSP_ENCODE_MODE_TOTAL_NUM] = {
 	[DSP_NORMAL_ISO_MODE] = {
 		1, 0, 1, 0,
 		{5, 5},
-		{8, 9, 9, 9, 0},
+		{5, 9, 9, 9, 0},
 		{15, 16, 16, 16, 0},
 		{0, 0, 0, 0, 0},
 		{1, 1, 1, 1},
@@ -778,6 +831,7 @@ static u32 get_dsp_mem_buffer_bandwidth(struct ambarella_iav *iav)
 	struct amba_video_info * video = NULL;
 	u32 bandwidth = 0;
 	u32 pixel_ps, fps, vout[2];
+	struct iav_window vout_win;
 	int i;
 
 	/* Dual VOUT */
@@ -794,6 +848,11 @@ static u32 get_dsp_mem_buffer_bandwidth(struct ambarella_iav *iav)
 			fps = Q9_TO_FPS(video->fps, DEFAULT_VOUT_FPS);
 			pixel_ps = ALIGN(video->width, PIXEL_IN_MB) *
 				ALIGN(video->height, PIXEL_IN_MB) * fps;
+
+			/* If vout mode is an interlaced mode, bandwidth will reduce half. */
+			if (video->format == AMBA_VIDEO_FORMAT_INTERLACE) {
+				pixel_ps >>= 1;
+			}
 			bandwidth += pixel_ps * dram_coeffs->vout[i].multi /
 				dram_coeffs->vout[i].div;
 		}
@@ -809,18 +868,25 @@ static u32 get_dsp_mem_buffer_bandwidth(struct ambarella_iav *iav)
 
 	/* Sub source buffers */
 	for (i = IAV_SUB_SRCBUF_FIRST; i < IAV_SUB_SRCBUF_LAST; ++i) {
-		pixel_ps = ALIGN(iav->srcbuf[i].win.width, PIXEL_IN_MB) *
-			ALIGN(iav->srcbuf[i].win.height, PIXEL_IN_MB) * fps;
 		switch (iav->srcbuf[i].type) {
 		case IAV_SRCBUF_TYPE_ENCODE:
+		case IAV_SRCBUF_TYPE_VCA:
+			pixel_ps = ALIGN(iav->srcbuf[i].win.width, PIXEL_IN_MB) *
+				ALIGN(iav->srcbuf[i].win.height, PIXEL_IN_MB) * fps;
 			bandwidth += pixel_ps * dram_coeffs->buf_yuv[i].multi /
 				dram_coeffs->buf_yuv[i].div;
 			bandwidth += (pixel_ps >> 4) * dram_coeffs->buf_me1[i].multi /
 				dram_coeffs->buf_me1[i].div;
 			break;
 		case IAV_SRCBUF_TYPE_PREVIEW:
+			if (get_vout_win(i, &vout_win) < 0) {
+				vout_win.width = vout_win.height = 0;
+			}
+			pixel_ps = ALIGN(vout_win.width, PIXEL_IN_MB) *
+				ALIGN(vout_win.height, PIXEL_IN_MB) * fps;
 			bandwidth += (pixel_ps << 1);
 			break;
+		case IAV_SRCBUF_TYPE_OFF:
 		default:
 			break;
 		}
@@ -913,10 +979,11 @@ static int get_dsp_mem_buffer_size(struct ambarella_iav *iav)
 	u32 vin_width, vin_height;
 	u32 dummy_width, dummy_height;
 	u32 main_width, main_height;
-	u32 buf_width, buf_height;
+	u32 buf_width, buf_height, buf_pixels;
 	u32 expo_num;
 	u32 enc_mode = iav->encode_mode;
 	u32 raw_flag;
+	u32 extra_top_row_flag;
 	int i;
 	struct iav_rect *vin_win;
 	struct iav_dram_coeff *dram_coeffs = &G_dram_buf_coeffs[enc_mode];
@@ -924,8 +991,10 @@ static int get_dsp_mem_buffer_size(struct ambarella_iav *iav)
 	struct iav_system_config *sys_config = &iav->system_config[enc_mode];
 	struct iav_buffer *main_buf = &iav->srcbuf[IAV_SRCBUF_MN];
 	struct iav_buffer *curr_buf;
+	struct iav_window vout_win;
 
 	raw_flag = sys_config->raw_capture;
+	extra_top_row_flag = sys_config->extra_top_row_buf_enable;
 	get_vin_win(iav, &vin_win, 1);
 	vin_width = ALIGN(vin_win->width, PIXEL_IN_MB);
 	vin_height = ALIGN(vin_win->height, PIXEL_IN_MB);
@@ -996,37 +1065,59 @@ static int get_dsp_mem_buffer_size(struct ambarella_iav *iav)
 	/* source buffer size */
 	for (i = IAV_SRCBUF_FIRST; i < IAV_SRCBUF_LAST_PMN; ++i) {
 		curr_buf = &iav->srcbuf[i];
-		if (curr_buf->type != IAV_SRCBUF_TYPE_OFF) {
+		switch (curr_buf->type) {
+		case IAV_SRCBUF_TYPE_ENCODE:
+		case IAV_SRCBUF_TYPE_VCA:
 			buf_width = ALIGN(curr_buf->max.width, PIXEL_IN_MB);
 			buf_height = ALIGN(curr_buf->max.height, PIXEL_IN_MB);
-			if (curr_buf->type == IAV_SRCBUF_TYPE_ENCODE) {
-				size += buf_width * buf_height * (buf_num->buf_yuv[i] +
-						curr_buf->extra_dram_buf) *
-						dram_coeffs->buf_yuv[i].multi /
-						dram_coeffs->buf_yuv[i].div;
-				buf_width = buf_width / 4;
-				buf_height = buf_height / 4;
-				size += buf_width * buf_height * (buf_num->buf_me1[i] +
+			buf_pixels = buf_width * buf_height;
+			size += buf_pixels * (buf_num->buf_yuv[i] +
+				curr_buf->extra_dram_buf) *
+				dram_coeffs->buf_yuv[i].multi /
+				dram_coeffs->buf_yuv[i].div;
+			buf_pixels = (buf_pixels >> 4);
+			size += buf_pixels * (buf_num->buf_me1[i] +
+				curr_buf->extra_dram_buf) *
+				dram_coeffs->buf_me1[i].multi /
+				dram_coeffs->buf_me1[i].div;
+			/* me0 shares the same size as me1 */
+			if (sys_config->me0_scale != ME0_SCALE_OFF) {
+				size += buf_pixels * buf_num->buf_me0[i] *
+					dram_coeffs->buf_me0[i].multi /
+					dram_coeffs->buf_me0[i].div;
+			}
+			if (extra_top_row_flag) {
+				buf_pixels = buf_width * PIXEL_IN_MB;
+				size += buf_pixels * (buf_num->buf_yuv[i] +
+					curr_buf->extra_dram_buf) *
+					dram_coeffs->buf_yuv[i].multi /
+					dram_coeffs->buf_yuv[i].div;
+				buf_pixels = (buf_pixels >> 4);
+				size += buf_pixels * (buf_num->buf_me1[i] +
 					curr_buf->extra_dram_buf) *
 					dram_coeffs->buf_me1[i].multi /
 					dram_coeffs->buf_me1[i].div;
-				/* me0 shares the same size as me1 */
-				if (sys_config->me0_scale != ME0_SCALE_OFF) {
-					size += buf_width * buf_height * buf_num->buf_me0[i] *
-						dram_coeffs->buf_me0[i].multi /
-						dram_coeffs->buf_me0[i].div;
-				}
-			} else {
-				if (i == IAV_SRCBUF_PA) {
-					size += buf_width * buf_height * buf_num->vout[0] *
-						dram_coeffs->vout[0].multi /
-						dram_coeffs->vout[0].div;
-				} else if (i == IAV_SRCBUF_PB){
-					size += buf_width * buf_height * buf_num->vout[1] *
-						dram_coeffs->vout[1].multi /
-						dram_coeffs->vout[1].div;
-				}
 			}
+			break;
+		case IAV_SRCBUF_TYPE_PREVIEW:
+			if (get_vout_win(i, &vout_win) < 0) {
+				vout_win.width = vout_win.height = 0;
+			}
+			buf_pixels = ALIGN(vout_win.width, PIXEL_IN_MB) * ALIGN(vout_win.height, PIXEL_IN_MB);
+
+			if (i == IAV_SRCBUF_PA) {
+				size += buf_pixels * buf_num->vout[0] *
+					dram_coeffs->vout[0].multi /
+					dram_coeffs->vout[0].div;
+			} else if (i == IAV_SRCBUF_PB){
+				size += buf_pixels * buf_num->vout[1] *
+					dram_coeffs->vout[1].multi /
+					dram_coeffs->vout[1].div;
+			}
+			break;
+		case IAV_SRCBUF_TYPE_OFF:
+		default:
+			break;
 		}
 	}
 
diff --git a/drivers/iav/arch_s2l/iav_enc_pm.c b/drivers/iav/arch_s2l/iav_enc_pm.c
index f90e9f1..82ad30a 100644
--- a/drivers/iav/arch_s2l/iav_enc_pm.c
+++ b/drivers/iav/arch_s2l/iav_enc_pm.c
@@ -3,14 +3,33 @@
  *
  * History:
  *	2014/03/13 - [Zhikan Yang] created file
- * Copyright (C) 2007-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <config.h>
 #include <linux/random.h>
 #include <linux/slab.h>
@@ -28,6 +47,7 @@
 #include "iav_enc_api.h"
 #include "iav_enc_utils.h"
 
+static struct timer_list sw_timer;
 
 static inline u32 get_pm_mctf_pitch(u32 width)
 {
@@ -41,7 +61,8 @@ static inline u32 get_pm_mctf_pitch(u32 width)
 
 static inline u32 get_pm_mctf_height(u32 height)
 {
-	return ALIGN(height, PIXEL_IN_MB) / PIXEL_IN_MB;
+	/* For mode 2, height should be calculated in MB pair */
+	return ALIGN(height, PIXEL_IN_MB * 2) / PIXEL_IN_MB;
 }
 
 static inline u32 get_pm_bpc_pitch(u32 width)
@@ -54,10 +75,14 @@ static inline u32 get_pm_bpc_pitch(u32 width)
 static void iav_init_pm_bpc(struct ambarella_iav *iav)
 {
 	/* Clear BPC based PM and BPC memory for APP to use */
-	memset((u8 *)iav->mmap[IAV_BUFFER_PM_BPC].virt, 0,
-		PM_BPC_PARTITION_SIZE);
-	memset((u8 *)iav->mmap[IAV_BUFFER_BPC].virt, 0,
-		PAGE_SIZE + PM_BPC_PARTITION_SIZE);
+	if ((u8 *)iav->mmap[IAV_BUFFER_PM_BPC].virt != 0) {
+		memset((u8 *)iav->mmap[IAV_BUFFER_PM_BPC].virt, 0,
+			PM_BPC_PARTITION_SIZE);
+		if ((u8 *)iav->mmap[IAV_BUFFER_BPC].virt != 0) {
+			memset((u8 *)iav->mmap[IAV_BUFFER_BPC].virt, 0,
+				PAGE_SIZE + PM_BPC_PARTITION_SIZE);
+		}
+	}
 
 	iav->pm_bpc_enable = 0;
 	iav->bpc_enable = 0;
@@ -68,23 +93,29 @@ static void iav_init_pm_bpc(struct ambarella_iav *iav)
 static void iav_init_pm_mctf(struct ambarella_iav *iav)
 {
 	/* Clear MCTF based PM memory for APP to use */
-	memset((u8 *)iav->mmap[IAV_BUFFER_PM_MCTF].virt, 0,
-		PM_MCTF_TOTAL_SIZE);
+	if ((u8 *)iav->mmap[IAV_BUFFER_PM_MCTF].virt != 0) {
+		memset((u8 *)iav->mmap[IAV_BUFFER_PM_MCTF].virt, 0,
+			PM_MCTF_TOTAL_SIZE);
+	}
 }
 
 static void reset_pm_bpc(struct ambarella_iav *iav)
 {
-	/* Clear current Privacy mask */
-	memset((u8 *)(iav->mmap[IAV_BUFFER_PM_BPC].virt +
-		PM_BPC_PARTITION_SIZE * iav->curr_pm_index),
-		0, PM_BPC_PARTITION_SIZE);
-
-	/* Clear User PM Partition */
-	memset((u8 *)iav->mmap[IAV_BUFFER_PM_BPC].virt, 0, PM_BPC_PARTITION_SIZE);
-
-	/* Clear BPC Partition */
-	memset((u8 *)iav->mmap[IAV_BUFFER_BPC].virt, 0,
-		PAGE_SIZE + PM_BPC_PARTITION_SIZE);
+	if ((u8 *)iav->mmap[IAV_BUFFER_PM_BPC].virt != 0) {
+		/* Clear current Privacy mask */
+		memset((u8 *)(iav->mmap[IAV_BUFFER_PM_BPC].virt +
+			PM_BPC_PARTITION_SIZE * iav->curr_pm_index),
+			0, PM_BPC_PARTITION_SIZE);
+
+		/* Clear User PM Partition */
+		memset((u8 *)iav->mmap[IAV_BUFFER_PM_BPC].virt, 0, PM_BPC_PARTITION_SIZE);
+
+		if ((u8 *)iav->mmap[IAV_BUFFER_BPC].virt != 0) {
+			/* Clear BPC Partition */
+			memset((u8 *)iav->mmap[IAV_BUFFER_BPC].virt, 0,
+				PAGE_SIZE + PM_BPC_PARTITION_SIZE);
+		}
+	}
 
 	iav->pm_bpc_enable = 0;
 	iav->bpc_enable = 0;
@@ -93,7 +124,9 @@ static void reset_pm_bpc(struct ambarella_iav *iav)
 static void reset_pm_mctf(struct ambarella_iav *iav)
 {
 	/* Clear Privacy mask memory */
-	memset((u8 *)iav->mmap[IAV_BUFFER_PM_MCTF].virt, 0, PM_MCTF_TOTAL_SIZE);
+	if ((u8 *)iav->mmap[IAV_BUFFER_PM_MCTF].virt != 0) {
+		memset((u8 *)iav->mmap[IAV_BUFFER_PM_MCTF].virt, 0, PM_MCTF_TOTAL_SIZE);
+	}
 }
 
 void iav_init_pm(struct ambarella_iav *iav)
@@ -130,7 +163,7 @@ int iav_ioc_g_pm_info(struct ambarella_iav *iav, void __user * arg)
 	pm_info.domain = get_pm_domain(iav);
 
 	main_win = &iav->srcbuf[IAV_SRCBUF_MN].win;
-	get_pm_vin_win(iav, &vin_win);
+	get_vin_win(iav, &vin_win, 0);
 	switch (pm_info.unit) {
 	case IAV_PM_UNIT_PIXEL:
 		pm_info.buffer_pitch = get_pm_bpc_pitch(vin_win->width);
@@ -161,9 +194,7 @@ int iav_set_pm_bpc(struct ambarella_iav *iav,
 		return -1;
 	}
 
-	if (get_pm_vin_win(iav, &vin_win) < 0) {
-		return -EFAULT;
-	}
+	get_vin_win(iav, &vin_win, 0);
 
 	iav->pm_bpc_enable = 1;
 	width_in_u8 = ALIGN(vin_win->width, 32) / 8;
@@ -175,7 +206,7 @@ int iav_set_pm_bpc(struct ambarella_iav *iav,
 		PM_BPC_PARTITION_SIZE);
 
 	iav->pm.enable = priv_mask->enable;
-	if (priv_mask->y || priv_mask->u || priv_mask->v){
+	if (priv_mask->y || priv_mask->u || priv_mask->v) {
 		iav->pm.y = priv_mask->y;
 		iav->pm.u = priv_mask->u;
 		iav->pm.v = priv_mask->v;
@@ -213,26 +244,75 @@ int iav_set_pm_mctf(struct ambarella_iav *iav,
 	struct iav_privacy_mask *priv_mask, u32 cmd_delay)
 {
 	cmd_set_pm_mctf(iav, NULL, cmd_delay);
+
+	return 0;
+}
+
+static void swtimer_routine(unsigned long data)
+{
+	struct ambarella_iav *iav = (struct ambarella_iav *)data;
+
+	cmd_set_pm_mctf(iav, NULL, 0);
+}
+
+int iav_pm_resume(struct ambarella_iav *iav, int wait)
+{
+	u32 pm_unit;
+
+	if (!is_enc_work_state(iav)) {
+		iav_error("Privacy mask should be set in Preview/Encode state.\n");
+		return -1;
+	}
+
+	mutex_lock(&iav->iav_mutex);
+	pm_unit = get_pm_unit(iav);
+
+	if (pm_unit == IAV_PM_UNIT_PIXEL) {
+		if (iav->bpc_enable) {
+			cmd_bpc_setup(iav, NULL, NULL);
+		}
+		cmd_set_pm_bpc(iav, NULL);
+	} else {
+		if (iav->fast_resume && wait) {
+			init_timer(&sw_timer);
+			sw_timer.data = (unsigned long)iav;
+			sw_timer.function = &swtimer_routine;
+			/* trigger timer 50 ms later */
+			sw_timer.expires = jiffies + HZ / 20;
+			add_timer(&sw_timer);
+		} else {
+			cmd_set_pm_mctf(iav, NULL, 0);
+		}
+	}
+	mutex_unlock(&iav->iav_mutex);
+
 	return 0;
 }
 
-static int check_pm_mctf(struct ambarella_iav *iav,
+static int check_pm(struct ambarella_iav *iav,
 	struct iav_privacy_mask *pm)
 {
 	u32 buf_size, buf_pitch, buf_height;
+	u32 pm_unit;
 
 	iav_no_check();
 
-	if (pm->enable) {
+	pm_unit = get_pm_unit(iav);
+
+	if (!pm->enable) {
+		return 0;
+	}
+
+	if (pm_unit == IAV_PM_UNIT_MB) {
 		buf_pitch = get_pm_mctf_pitch(iav->srcbuf[IAV_SRCBUF_MN].win.width);
 		if (buf_pitch != pm->buf_pitch) {
-			iav_error("Incorrect buffer pitch %u, should be %d!\n",
+			iav_error("Incorrect buffer pitch %u for PM MCTF, should be %d!\n",
 				pm->buf_pitch, buf_pitch);
 			return -1;
 		}
 		buf_height = get_pm_mctf_height(iav->srcbuf[IAV_SRCBUF_MN].win.height);
 		if (buf_height != pm->buf_height) {
-			iav_error("Incorrect buffer height %u, should be %d!\n",
+			iav_error("Incorrect buffer height %u for PM MCTF, should be %d!\n",
 				pm->buf_height, buf_height);
 			return -1;
 		}
@@ -243,17 +323,7 @@ static int check_pm_mctf(struct ambarella_iav *iav,
 				PM_MCTF_TOTAL_SIZE);
 			return -1;
 		}
-	}
-
-	return 0;
-}
-
-static int check_pm_bpc(struct ambarella_iav *iav,
-	struct iav_privacy_mask *pm)
-{
-	iav_no_check();
-
-	if (pm->enable) {
+	} else {
 		if (pm->data_addr_offset > PM_BPC_PARTITION_SIZE) {
 			iav_error("PM BPC data offset 0x%x is out of range 0x%x!",
 				pm->data_addr_offset, PM_MCTF_TOTAL_SIZE);
@@ -271,16 +341,9 @@ int iav_cfg_vproc_pm(struct ambarella_iav *iav,
 
 	pm_unit = get_pm_unit(iav);
 
-	if (pm_unit == IAV_PM_UNIT_MB) {
-		if (check_pm_mctf(iav, pm) < 0) {
-			iav_error("Check MCTF Privacy Mask failed!\n");
-			return -EINVAL;
-		}
-	} else {
-		if (check_pm_bpc(iav, pm) < 0) {
-			iav_error("Check BPC Privacy Mask failed!\n");
-			return -EINVAL;
-		}
+	if (check_pm(iav, pm) < 0) {
+		iav_error("Check Privacy Mask failed!\n");
+		return -EINVAL;
 	}
 
 	iav->pm = *pm;
@@ -304,6 +367,12 @@ int iav_ioc_s_pm(struct ambarella_iav *iav, void __user * arg)
 	mutex_lock(&iav->iav_mutex);
 	pm_unit = get_pm_unit(iav);
 
+	if (check_pm(iav, &priv_mask) < 0) {
+		iav_error("Check Privacy Mask failed!\n");
+		return -EINVAL;
+	}
+
+	iav->pm = priv_mask;
 	if (pm_unit == IAV_PM_UNIT_PIXEL) {
 		rval = iav_set_pm_bpc(iav, &priv_mask);
 	} else {
@@ -383,9 +452,7 @@ int iav_ioc_s_static_bpc(struct ambarella_iav *iav, void __user * arg)
 		(void*)bpc_fpn.intercepts_and_slopes_addr, 1024))
 				return -EFAULT;
 
-	if (get_pm_vin_win(iav, &vin_win) < 0) {
-		return -EFAULT;
-	}
+	get_vin_win(iav, &vin_win, 0);
 
 	mutex_lock(&iav->iav_mutex);
 	iav->pm_bpc_enable = 1;
diff --git a/drivers/iav/arch_s2l/iav_enc_pts.c b/drivers/iav/arch_s2l/iav_enc_pts.c
index 33f3ccc..178da99 100644
--- a/drivers/iav/arch_s2l/iav_enc_pts.c
+++ b/drivers/iav/arch_s2l/iav_enc_pts.c
@@ -4,15 +4,34 @@
  * History:
  *	2014/04/28 - [Zhaoyang Chen] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #include <config.h>
 #include <linux/random.h>
 #include <linux/slab.h>
@@ -70,11 +89,12 @@ u64 get_hw_pts(struct ambarella_iav *iav, u32 audio_pts)
 		} else if (!leading && !prev_pts) {
 			iav_debug("HW PTS error: continuous 2 zero PTS!\n");
 		}
-	} else if (unlikely(audio_diff > (hw_pts_info->audio_freq << 1))) {
-		iav_debug("HW PTS error: too big gap [%u] between sync point [%u]"
-			" and pts [%u]!\n", audio_diff, hw_pts_info->audio_tick,
-			audio_pts);
 	} else {
+		if (unlikely(audio_diff > (hw_pts_info->audio_freq << 1))) {
+			iav_debug("HW PTS error: too big gap [%u] between sync point [%u]"
+				" and pts [%u]!\n", audio_diff, hw_pts_info->audio_tick,
+				audio_pts);
+		}
 		// got valid pts from dsp
 		leading = 0;
 		mono_pts = (u64)audio_diff * hw_pts_info->hwtimer_freq +
diff --git a/drivers/iav/arch_s2l/iav_enc_stream.c b/drivers/iav/arch_s2l/iav_enc_stream.c
index e813145..9b537dc 100644
--- a/drivers/iav/arch_s2l/iav_enc_stream.c
+++ b/drivers/iav/arch_s2l/iav_enc_stream.c
@@ -3,18 +3,38 @@
  *
  * History:
  *	2012/04/13 - [Jian Tang] created file
- * Copyright (C) 2007-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <config.h>
 #include <linux/random.h>
 #include <linux/slab.h>
 #include <linux/dma-mapping.h>
+#include <linux/ambpriv_device.h>
 #include <iav_utils.h>
 #include <iav_ioctl.h>
 #include <dsp_api.h>
@@ -30,14 +50,6 @@
 
 #define	ENCODE_BITS_INFO_GET_STREAM_ID(stream_id)	(((stream_id)>>6) & 0x3)
 
-static void create_session_id(struct iav_stream *stream)
-{
-	u32 random_data;
-
-	get_random_bytes(&random_data, sizeof(random_data));
-	stream->session_id = random_data;
-}
-
 inline int is_stream_in_starting(struct iav_stream *stream)
 {
 	return (stream->dsp_state == ENC_IDLE_STATE) &&
@@ -64,7 +76,7 @@ inline int is_stream_in_idle(struct iav_stream *stream)
 
 static inline int is_end_frame(BIT_STREAM_HDR *bsh)
 {
-	if (unlikely((bsh->frame_num == 0xFFFFFFFF) && (bsh->start_addr == 0xFFFFFFFF)))
+	if (unlikely((bsh->frmNo == 0xFFFFFFFF) && (bsh->start_addr == 0xFFFFFFFF)))
 		return 1;
 	else
 		return 0;
@@ -82,18 +94,18 @@ static inline int is_stream_format_changed(struct iav_stream_format *from,
 			(from->hflip != to->hflip) ||
 			(from->vflip != to->vflip) ||
 			(from->rotate_cw != to->rotate_cw) ||
-			(from->duration != to->duration) ||
-			(from->snapshot_enable != to->snapshot_enable));
+			(from->duration != to->duration));
 }
 
 static inline int is_invalid_frame(BIT_STREAM_HDR *bsh)
 {
-	return (bsh->pic_size == 0);
+	return (bsh->length == 0);
 }
 
 static inline void set_invalid_frame(BIT_STREAM_HDR *bsh)
 {
-	bsh->PTS = bsh->start_addr = bsh->pic_size = 0;
+	bsh->pts = INVALID_DSP_PTS_32;
+	bsh->start_addr = bsh->length = 0;
 }
 
 static inline int is_stream_offset_changed_only(struct iav_stream_format *from,
@@ -106,8 +118,7 @@ static inline int is_stream_offset_changed_only(struct iav_stream_format *from,
 			(from->hflip == to->hflip) &&
 			(from->vflip == to->vflip) &&
 			(from->rotate_cw == to->rotate_cw) &&
-			(from->duration == to->duration) &&
-			(from->snapshot_enable == to->snapshot_enable));
+			(from->duration == to->duration));
 }
 
 static inline int is_valid_frame_desc(struct iav_frame_desc *frame_desc)
@@ -150,6 +161,7 @@ static struct iav_frame_desc *iav_get_free_frame_desc(struct ambarella_iav *iav)
 			struct iav_frame_desc, node);
 		list_move_tail(&frame_desc->node, &iav->frame_free);
 		iav->bsb_free_bytes += ALIGN(frame_desc->desc.size, 32);
+		++iav->frame_cnt.free_frame_cnt;
 	}
 	if (!list_empty(&iav->frame_free)) {
 		frame_desc = list_first_entry(&iav->frame_free,
@@ -171,20 +183,33 @@ static void do_enqueue_frame_desc(struct ambarella_iav * iav, BIT_STREAM_HDR * b
 	struct iav_stream * stream, struct iav_frame_desc * frame_desc, int clean_pts)
 {
 	struct iav_frame_desc * old_frame;
+	int dsp_pts_diff = 0;
+	static int prev_clean_pts = -1;
 	u32 size;
 
-	frame_desc->desc.id = ENCODE_BITS_INFO_GET_STREAM_ID(bsh->stream_id);
+	frame_desc->desc.id = ENCODE_BITS_INFO_GET_STREAM_ID(bsh->streamID);
 	frame_desc->desc.session_id = stream->session_id;
 	frame_desc->desc.reso.width = stream->format.enc_win.width;
 	frame_desc->desc.reso.height = stream->format.enc_win.height;
-	frame_desc->desc.pic_type = bsh->pic_type;
+	frame_desc->desc.pic_type = bsh->frameTy;
 	frame_desc->desc.stream_type = stream->format.type;
 	frame_desc->desc.stream_end = !!is_end_frame(bsh);
-	frame_desc->desc.frame_num = bsh->frame_num;
+	frame_desc->desc.frame_num = bsh->frmNo;
 	if (stream->srcbuf->id != IAV_SRCBUF_EFM) {
 		if ((likely(!clean_pts)) && (likely(!is_end_frame(bsh)))) {
 			if (iav->pts_info.hwtimer_enabled == 1) {
 				frame_desc->desc.arm_pts = get_hw_pts(iav, bsh->hw_pts);
+				if (prev_clean_pts == 1) {
+					/* Update arm_pts for previous frames in fast boot case */
+					list_for_each_entry(old_frame, &iav->frame_queue, node) {
+						if (!old_frame->desc.arm_pts && old_frame->desc.size) {
+							dsp_pts_diff = (u32)old_frame->desc.dsp_pts -
+								bsh->pts;
+							old_frame->desc.arm_pts = frame_desc->desc.arm_pts +
+								dsp_pts_diff;
+						}
+					}
+				}
 			} else {
 				frame_desc->desc.arm_pts = get_monotonic_pts();
 			}
@@ -192,17 +217,25 @@ static void do_enqueue_frame_desc(struct ambarella_iav * iav, BIT_STREAM_HDR * b
 			frame_desc->desc.arm_pts = 0;
 		}
 	} else {
-		frame_desc->desc.arm_pts = bsh->PTS;
+		frame_desc->desc.arm_pts = bsh->hw_pts;
 	}
-	frame_desc->desc.dsp_pts = bsh->PTS;
+	get_hwtimer_output_ticks(&frame_desc->desc.enc_done_ts);
+	frame_desc->desc.dsp_pts = bsh->pts;
+	prev_clean_pts = clean_pts;
 	frame_desc->desc.data_addr_offset = DSP_TO_PHYS(bsh->start_addr) -
 		iav->mmap[IAV_BUFFER_BSB].phys;
-	frame_desc->desc.size = is_end_frame(bsh) ? 0 : bsh->pic_size;
+	frame_desc->desc.size = is_end_frame(bsh) ? 0 : bsh->length;
 	frame_desc->desc.jpeg_quality =
 		(frame_desc->desc.stream_type == IAV_STREAM_TYPE_MJPEG) ?
 		stream->mjpeg_config.quality : 0;
-	size = ALIGN(frame_desc->desc.size, 32);
+	if (bsh->mvdump_curr_daddr) {
+		frame_desc->desc.mv_data_offset = DSP_TO_PHYS(bsh->mvdump_curr_daddr) -
+			iav->mmap[IAV_BUFFER_MV].phys;
+	} else {
+		frame_desc->desc.mv_data_offset = 0xFFFFFFFF;
+	}
 
+	size = ALIGN(frame_desc->desc.size, 32);
 	/* If BSB is full, discard the oldest frame which is overwritten by DSP. */
 	while (!list_empty(&iav->frame_queue)) {
 		if (iav->bsb_free_bytes >= size)
@@ -235,7 +268,7 @@ static void iav_add_frame_desc(struct ambarella_iav *iav,
 	cnt = 0;
 	do {
 		bsh = iav->bsh;
-		stream_id = ENCODE_BITS_INFO_GET_STREAM_ID(bsh->stream_id);
+		stream_id = ENCODE_BITS_INFO_GET_STREAM_ID(bsh->streamID);
 		stream = &iav->stream[stream_id];
 
 		frame_desc = iav_get_free_frame_desc(iav);
@@ -270,15 +303,13 @@ static void iav_add_frame_desc(struct ambarella_iav *iav,
 		/* now this bits_info has been consumed totally, init it to 0 again */
 		set_invalid_frame(bsh);
 		iav->bsh++;
-		if ((u32)iav->bsh >= (u32)iav->bsh_virt + iav->bsh_size)
+		if ((u32)iav->bsh >= (u32)iav->bsh_virt + iav->bsh_size) {
 			iav->bsh = iav->bsh_virt;
-
-		/* Fixme: We need to find out if snapshot is overwriten later */
-		if (stream->format.snapshot_enable &&
-			stream->format.type == IAV_STREAM_TYPE_MJPEG) {
-			stream->snapshot = *frame_desc;
 		}
 
+		/* Always update snapshot */
+		stream->snapshot = *frame_desc;
+
 		spin_unlock(&iav->iav_lock);
 	} while (++cnt < MAX_RETRY);
 }
@@ -334,6 +365,7 @@ void irq_iav_queue_frame(void *data, DSP_MSG *msg)
 	iav_add_frame_desc(iav, 0);
 
 	wake_up_interruptible(&iav->frame_wq);
+	wake_up_interruptible(&iav->mv_wq);
 }
 
 /* This function is called by encode init stage only in fast boot mode. */
@@ -341,9 +373,16 @@ void iav_sync_bsh_queue(void *data)
 {
 	struct ambarella_iav *iav = data;
 
+	if (iav->bsh && iav->bsh->frmNo > 1) {
+		iav_error("The first frame num [%u] in bsh is bigger than 1, maybe overflow!\n",
+			iav->bsh->frmNo);
+		return;
+	}
+
 	while (iav->bsh && iav->bsh->start_addr) {
 		iav_add_frame_desc(iav, 1);
 	}
+	iav_debug("Sync bsh frame count %d\n", iav->frame_cnt.total_frame_cnt);
 }
 
 static inline void irq_sync_frame_count(struct ambarella_iav *iav)
@@ -403,16 +442,16 @@ int irq_update_stopping_stream_state(struct iav_stream * stream)
 
 	if (is_stream_in_stopping(stream)) {
 		wake_up = 1;
-		dec_srcbuf_ref(stream->srcbuf);
+		dec_srcbuf_ref(stream->srcbuf, stream->id_dsp);
 	} else if (is_stream_in_encoding(stream)) {
-		/* Encode duration is config as non-zero for stream */
-		if (stream->format.duration) {
+		/* Encode duration is config as non-zero for stream, or last frame's case in EFM */
+		if (stream->format.duration || (IAV_SRCBUF_EFM == stream->format.buf_id)) {
 			wake_up = 1;
 			stream->op = IAV_STREAM_OP_STOP;
-			dec_srcbuf_ref(stream->srcbuf);
+			dec_srcbuf_ref(stream->srcbuf, stream->id_dsp);
 		} else {
 			iav_error("Incorrect DSP encode IDLE state for stream %c.\n",
-				'A' + stream->format.id);
+				'A' + stream->id_dsp);
 		}
 	}
 
@@ -426,7 +465,7 @@ static struct iav_frame_desc *iav_find_frame_desc(struct ambarella_iav *iav,
 	int found = 0;
 
 	spin_lock_irq(&iav->iav_lock);
-	if (instant_fetch == IAV_FETCH_MJPEG_INSTANT_ENABLE) {
+	if (instant_fetch) {
 		frame_desc = &iav->stream[id].snapshot;
 		if (is_valid_frame_desc(frame_desc)) {
 			found = 1;
@@ -454,47 +493,49 @@ static struct iav_frame_desc *iav_find_frame_desc(struct ambarella_iav *iav,
 	return (found == 1)? frame_desc : NULL;
 }
 
+static int check_framedesc_param(struct ambarella_iav *iav,
+	struct iav_framedesc *framedesc)
+{
+	struct iav_stream *stream;
+	u32 enc_mode = iav->encode_mode;
+	u8 max_stream_num = iav->system_config[enc_mode].max_stream_num;
+	u8 instant_fetch = framedesc->instant_fetch;
+
+	if (framedesc->id != -1 && framedesc->id >= max_stream_num) {
+		iav_error("Invalid stream ID: %d!\n", framedesc->id);
+		return -1;
+	}
+
+	stream = &iav->stream[framedesc->id];
+	if (instant_fetch) {
+		if (framedesc->id == -1) {
+			iav_error("Invalid stream ID for instant fetch, should be [0,%d].\n",
+				IAV_STREAM_MAX_NUM_ALL - 1);
+			return -1;
+		} else if (stream->format.type != IAV_STREAM_TYPE_MJPEG) {
+			iav_error("Only support instant fetch for MJPEG stream!\n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
 static int iav_query_framedesc(struct ambarella_iav *iav,
 	struct iav_framedesc *framedesc)
 {
 	struct iav_frame_desc *frame_desc;
+	struct iav_stream *stream;
 	u32 stream_id;
 	long time_jiffies;
 	int rval = 0;
-	int enc_mode = iav->encode_mode;
-	int max_stream_num = iav->system_config[enc_mode].max_stream_num;
-	struct iav_stream_format *stream_format;
 	u8 instant_fetch = framedesc->instant_fetch;
 
-	stream_id = framedesc->id;
-	if (stream_id != -1 && stream_id >= max_stream_num) {
-		iav_error("Invalid stream ID: %d!\n", stream_id);
+	if (check_framedesc_param(iav, framedesc) < 0) {
 		return -EINVAL;
 	}
 
-	switch (instant_fetch) {
-	case IAV_FETCH_MJPEG_INSTANT_ENABLE:
-		if (stream_id == -1) {
-			iav_error("For the filo mode, stream id should not be -1.\n");
-			return -EINVAL;
-		}
-		stream_format = &iav->stream[stream_id].format;
-		if (stream_format->type != IAV_STREAM_TYPE_MJPEG) {
-			iav_error("The filo mode only supports MJPEG stream.\n");
-			return -EINVAL;
-		}
-
-		if (!stream_format->snapshot_enable) {
-			iav_error("Stream should enable snap shot for instant fetch!\n");
-			return -EINVAL;
-		}
-		break;
-	case IAV_FETCH_MJPEG_INSTANT_DISABLE:
-		break;
-	default :
-		iav_error("Invalid instant_fetch flag.\n");
-		return -EINVAL;
-	}
+	stream_id = framedesc->id;
 
 	if (framedesc->time_ms == -1) {
 		/* non blocking way */
@@ -518,6 +559,7 @@ static int iav_query_framedesc(struct ambarella_iav *iav,
 	*framedesc = frame_desc->desc;
 	stream_id = frame_desc->desc.id;
 
+	stream = &iav->stream[stream_id];
 	// Clean latest snapshot
 	if (instant_fetch) {
 		spin_lock_irq(&iav->iav_lock);
@@ -542,6 +584,128 @@ static int iav_query_framedesc(struct ambarella_iav *iav,
 	return rval;
 }
 
+static struct iav_frame_desc *iav_find_statis_desc(struct ambarella_iav *iav,
+	u32 stream_id)
+{
+	struct iav_frame_desc *frame_desc;
+
+	// use instant fetch for statis desc
+	frame_desc = iav_find_frame_desc(iav, stream_id, 1);
+	spin_lock_irq(&iav->iav_lock);
+	if ((frame_desc != NULL) &&
+		(frame_desc->desc.mv_data_offset != 0xFFFFFFFF)) {
+		spin_unlock_irq(&iav->iav_lock);
+		return frame_desc;
+	}
+	spin_unlock_irq(&iav->iav_lock);
+
+	return NULL;
+}
+
+static int iav_query_statisdesc(struct ambarella_iav *iav,
+	struct iav_statisdesc *statisdesc)
+{
+	struct iav_frame_desc *frame_desc;
+	struct iav_framedesc *desc;
+	struct iav_stream *stream;
+	struct iav_stream_format *stream_format = NULL;
+	u32 stream_id;
+	long time_jiffies;
+	int rval = 0;
+	int enc_mode = iav->encode_mode;
+	int max_stream_num = iav->system_config[enc_mode].max_stream_num;
+	struct iav_window win;
+
+	stream_id = statisdesc->id;
+	if (stream_id != -1 && stream_id >= max_stream_num) {
+		iav_error("Invalid stream ID: %d!\n", stream_id);
+		return -EINVAL;
+	}
+	stream = &iav->stream[stream_id];
+	stream_format = &stream->format;
+
+	if (statisdesc->time_ms == -1) {
+		/* non blocking way */
+		frame_desc = iav_find_statis_desc(iav, stream_id);
+	} else if (statisdesc->time_ms == 0) {
+		/* blocking way */
+		wait_event_interruptible(iav->mv_wq,
+			(frame_desc = iav_find_statis_desc(iav, stream_id)));
+	} else {
+		/* with timeout in ms*/
+		time_jiffies = msecs_to_jiffies(statisdesc->time_ms);
+		wait_event_interruptible_timeout(iav->mv_wq,
+			(frame_desc = iav_find_statis_desc(iav, stream_id)),
+			time_jiffies);
+	}
+
+	spin_lock_irq(&iav->iav_lock);
+	if (frame_desc == NULL) {
+		spin_unlock_irq(&iav->iav_lock);
+		return -EAGAIN;
+	}
+
+	desc = &frame_desc->desc;
+
+	statisdesc->data_addr_offset = desc->mv_data_offset;
+	get_stream_win_MB(stream_format, &win);
+	statisdesc->width = win.width;
+	statisdesc->height = win.height;
+	statisdesc->pitch = ALIGN(win.width * sizeof(struct iav_mv), 32);
+	statisdesc->arm_pts = desc->arm_pts;
+	statisdesc->dsp_pts = desc->dsp_pts;
+	statisdesc->frame_num = desc->frame_num;
+	statisdesc->session_id = desc->session_id;
+
+	set_frame_desc_invalid(&stream->snapshot);
+
+	spin_unlock_irq(&iav->iav_lock);
+
+	return rval;
+}
+
+/*
+ * EXPORT_SYMBOL Interface for UVC
+ */
+int iav_fetch_bsbinfo(unsigned long *iav_bsb_virt, u32 *iav_bsb_size)
+{
+	struct ambarella_iav *iav = NULL;
+
+	iav = ambpriv_get_drvdata(iav_device);
+	if (iav == NULL) {
+		iav_error("Get iav info failed\n");
+		return -EFAULT;
+	}
+
+	*iav_bsb_virt = iav->mmap[IAV_BUFFER_BSB].virt;
+	*iav_bsb_size = iav->mmap[IAV_BUFFER_BSB].size;
+
+	return 0;
+}
+EXPORT_SYMBOL(iav_fetch_bsbinfo);
+
+int iav_fetch_framedesc(struct iav_framedesc *framedesc)
+{
+	struct ambarella_iav *iav = NULL;
+	int ret = 0;
+
+	iav = ambpriv_get_drvdata(iav_device);
+	if (iav == NULL) {
+		iav_error("Get iav info failed\n");
+		return -EFAULT;
+	}
+
+	ret = iav_query_framedesc(iav, framedesc);
+	if (ret < 0) {
+		iav_error("Get frame descriptor failed\n");
+		return -EFAULT;
+	}
+	framedesc->data_addr_offset += iav->mmap[IAV_BUFFER_BSB].virt;
+
+	return ret;
+}
+EXPORT_SYMBOL(iav_fetch_framedesc);
+
 int iav_ioc_g_query_desc(struct ambarella_iav *iav, void __user *arg)
 {
 	struct iav_querydesc desc;
@@ -554,6 +718,9 @@ int iav_ioc_g_query_desc(struct ambarella_iav *iav, void __user *arg)
 	case IAV_DESC_FRAME:
 		rval = iav_query_framedesc(iav, &desc.arg.frame);
 		break;
+	case IAV_DESC_STATIS:
+		rval = iav_query_statisdesc(iav, &desc.arg.statis);
+		break;
 	case IAV_DESC_RAW:
 		rval = iav_query_rawdesc(iav, &desc.arg.raw);
 		break;
@@ -569,6 +736,9 @@ int iav_ioc_g_query_desc(struct ambarella_iav *iav, void __user *arg)
 	case IAV_DESC_BUFCAP:
 		rval = iav_query_bufcapdesc(iav, &desc.arg.bufcap);
 		break;
+	case IAV_DESC_QP_HIST:
+		rval = iav_query_qphistdesc(iav, &desc.arg.qphist);
+		break;
 	default:
 		rval = -EINVAL;
 		break;
@@ -613,16 +783,17 @@ static int check_encode_resource_limit(struct ambarella_iav *iav, u32 stream_map
 	u32 system_load_limit;
 	u32 max_mb;
 	int i, width, height;
-	int vin_fps, fps;
+	int idsp_fps, fps;
 	struct iav_stream *stream;
 
 	iav_no_check();
 
-	if (iav->vinc[0]->vin_format.frame_rate == 0) {
-		iav_error("Divider of frame_rate can not be zero\n");
+	iav_vin_get_idsp_frame_rate(iav, &idsp_fps);
+	if (idsp_fps == 0) {
+		iav_error("frame_rate of iDSP can not be zero\n");
 		return -1;
 	}
-	vin_fps = DIV_CLOSEST(512000000, iav->vinc[0]->vin_format.frame_rate);
+	idsp_fps = DIV_CLOSEST(FPS_Q9_BASE, idsp_fps);
 
 	chip_id = get_chip_id(iav);
 	if (chip_id < IAV_CHIP_ID_S2LM_FIRST ||
@@ -638,17 +809,17 @@ static int check_encode_resource_limit(struct ambarella_iav *iav, u32 stream_map
 				PIXEL_IN_MB) / PIXEL_IN_MB;
 			height = ALIGN(stream->format.enc_win.height,
 				PIXEL_IN_MB) / PIXEL_IN_MB;
-			fps = vin_fps * stream->fps.fps_multi / stream->fps.fps_div;
+			fps = idsp_fps * stream->fps.fps_multi / stream->fps.fps_div;
 			system_load += width * height * fps;
 
 			if (stream->format.type == IAV_STREAM_TYPE_H264) {
-				system_bitrate += stream->h264_config.average_bitrate;
+				system_bitrate += get_dsp_encode_bitrate(stream);
 			}
 		}
 	}
 
-	iav_debug("Check encode resource limit : VIN [%d], system load %u.\n",
-		vin_fps, system_load);
+	iav_debug("Check encode resource limit : iDSP [%d], system load %u.\n",
+		idsp_fps, system_load);
 
 	chip_idx = chip_id - IAV_CHIP_ID_S2LM_FIRST;
 	system_load_limit = G_system_load[chip_idx].system_load;
@@ -674,6 +845,7 @@ static int check_encode_resource_limit(struct ambarella_iav *iav, u32 stream_map
 	return 0;
 }
 
+
 static int check_encode_stream_state(struct ambarella_iav *iav, u32 stream_map)
 {
 	int i, encoding_counter, max_num;
@@ -759,6 +931,7 @@ static int check_stream_offset(struct ambarella_iav *iav, struct iav_stream_form
 {
 	struct iav_window *buf_win;
 	struct iav_rect *enc_win;
+	struct iav_window *main_win = &iav->srcbuf[IAV_SRCBUF_MN].win;
 
 	iav_no_check();
 
@@ -783,6 +956,12 @@ static int check_stream_offset(struct ambarella_iav *iav, struct iav_stream_form
 			buf_win->width, buf_win->height);
 		return -1;
 	}
+	if (enc_win->width > main_win->width || enc_win->height > main_win->height) {
+		iav_error("Stream %c encoding size %dx%d cannot be larger than main buffer "
+			"size %dx%d.\n", 'A' + format->id, enc_win->width, enc_win->height,
+			main_win->width, main_win->height);
+		return -1;
+	}
 
 	return 0;
 }
@@ -799,9 +978,9 @@ static int check_force_fast_seek(struct iav_stream *stream)
 		iav_error("Only support force fask seek frame when "
 			"gop = %d!\n", IAV_GOP_LT_REF_P);
 		return -1;
-	} else if (stream->h264_config.long_term_intvl == 0) {
+	} else if (stream->h264_config.fast_seek_intvl == 0) {
 		iav_error("Only support force fask seek frame when "
-			"long_term_intvl > 0!\n");
+			"fast_seek_intvl > 0!\n");
 		return -1;
 	}
 
@@ -903,13 +1082,7 @@ static int iav_check_h264_config(struct ambarella_iav *iav, int id,
 		iav_error("Invalid H264 gop structure: %d.\n", h264->gop_structure);
 		return -1;
 	}
-	if (h264->gop_structure == IAV_GOP_SVCT_2) {
-		if(stream->long_ref_enable != 0){
-			iav_error("Only support 2 level SVCT gop when "
-				"stream long ref enable = 0!\n");
-			return -1;
-		}
-	} else if (h264->gop_structure == IAV_GOP_SVCT_3) {
+	if (h264->gop_structure == IAV_GOP_SVCT_3) {
 		if(stream->long_ref_enable != 1){
 			iav_error("Only support 3 level SVCT gop when "
 				"stream long ref enable = 1!\n");
@@ -924,13 +1097,6 @@ static int iav_check_h264_config(struct ambarella_iav *iav, int id,
 		iav_error("H264 M %d should be no greater than max gop M %d!\n",
 			h264->M, stream->max_GOP_M);
 		return -1;
-	} else if (h264->M > 1) {
-		if (stream->long_ref_enable != 0) {
-			iav_error("H264 M %d should be set to 1 when stream long ref "
-				"enable = 1, which means no B frame in this case!\n",
-				h264->M);
-			return -1;
-		}
 	}
 	if (h264->chroma_format != H264_CHROMA_YUV420 &&
 		h264->chroma_format != H264_CHROMA_MONO) {
@@ -947,50 +1113,90 @@ static int iav_check_h264_config(struct ambarella_iav *iav, int id,
 			h264->profile, H264_PROFILE_FIRST, H264_PROFILE_LAST);
 		return -1;
 	}
-	if (h264->long_term_intvl >  LONG_TERM_INTVL_MAX ||
-		h264->long_term_intvl > h264->N) {
-		iav_error("Invalid H264 long term interval %d, should be smaller "
+	if (h264->fast_seek_intvl >  FAST_SEEK_INTVL_MAX ||
+		h264->fast_seek_intvl > h264->N) {
+		iav_error("Invalid H264 fast seek interval %d, should be smaller "
 			"than %d and N [%d].\n",
-			h264->long_term_intvl, LONG_TERM_INTVL_MAX, h264->N);
+			h264->fast_seek_intvl, FAST_SEEK_INTVL_MAX, h264->N);
 		return -1;
-	} else if (h264->long_term_intvl != 0) {
+	} else if (h264->fast_seek_intvl != 0) {
 		if(stream->long_ref_enable != 1){
-			iav_error("Only support long term interval when "
+			iav_error("Only support fast seek interval when "
 				"stream long ref enable = 1!\n");
 			return -1;
 		} else if (h264->gop_structure != IAV_GOP_LT_REF_P) {
-			iav_error("Only support long term interval when "
+			iav_error("Only support fast seek interval when "
 				"gop = %d!\n", IAV_GOP_LT_REF_P);
 			return -1;
 		} else if (h264->idr_interval != 1) {
-			iav_error("Only support long term interval when "
+			iav_error("Only support fast seek interval when "
 				"idr_interval = 1!\n");
 			return -1;
 		}
 	}
 	if (h264->multi_ref_p > 0) {
 		if(stream->long_ref_enable != 1){
-			iav_error("Only support multiple reference P frame when "
-				"stream long ref enable = 1!\n");
+			iav_error("Only support multi-ref P frame when stream long ref "
+				"enable = 1!\n");
 			return -1;
 		} else if (h264->gop_structure != IAV_GOP_LT_REF_P) {
-			iav_error("Only support multiple reference P frame when "
-				"gop = %d!\n", IAV_GOP_LT_REF_P);
+			iav_error("Only support multi-ref P frame when gop = %d!\n",
+				IAV_GOP_LT_REF_P);
 			return -1;
 		} else if (stream->max_GOP_M <= 1) {
-			iav_error("Only support multiple reference P frame when "
-				"stream max_GOP_M > 1!\n");
+			iav_error("Only support multi-ref P frame when stream "
+				"max_GOP_M > 1!\n");
 			return -1;
-
+		} else if (h264->M > 1) {
+			if (!iav->system_config[iav->encode_mode].long_ref_b_frame) {
+				iav_error("Only support multi-ref P frame with B frame when "
+					"long ref B frame is enabled!\n");
+				return -1;
+			} else if (h264->fast_seek_intvl % h264->M) {
+				iav_error("Only support multi-ref P frame with B frame when "
+					"fast seek interval is a multiple of M!\n");
+				return -1;
+			}
 		}
 	}
 
+	if (h264->deblocking_filter_alpha < IAV_DEBLOCKING_ALPHA_MIN ||
+		h264->deblocking_filter_alpha > IAV_DEBLOCKING_ALPHA_MAX) {
+		iav_error("deblocking filter alpha should be in range [%d, %d]!\n",
+			IAV_DEBLOCKING_ALPHA_MIN, IAV_DEBLOCKING_ALPHA_MAX);
+	}
+
+	if (h264->deblocking_filter_beta < IAV_DEBLOCKING_BETA_MIN ||
+		h264->deblocking_filter_beta > IAV_DEBLOCKING_BETA_MAX) {
+		iav_error("deblocking filter beta should be in range [%d, %d]!\n",
+			IAV_DEBLOCKING_BETA_MIN, IAV_DEBLOCKING_BETA_MAX);
+	}
+
+	if (h264->deblocking_filter_enable >= H264_DEBLOCKING_TYPE_NUM) {
+		iav_error("deblocking filter enable flag should be in range [0, %d]!\n",
+			H264_DEBLOCKING_TYPE_NUM);
+	}
+
 	stream = &iav->stream[id];
 	if (stream->format.type != IAV_STREAM_TYPE_H264) {
 		iav_error("Cannot change H264 config for MJPEG stream.\n");
 		return -1;
 	}
 
+	if ((h264->frame_crop_left_offset & 1) || (h264->frame_crop_right_offset & 1)
+		|| (h264->frame_crop_top_offset & 1) || (h264->frame_crop_bottom_offset & 1)) {
+		iav_error("Crop only support even offset.\n");
+		return -1;
+	}
+
+	if ((h264->frame_crop_left_offset + h264->frame_crop_right_offset) >
+			(stream->format.rotate_cw ? stream->format.enc_win.height : stream->format.enc_win.width)
+		|| (h264->frame_crop_top_offset + h264->frame_crop_bottom_offset) >
+			(stream->format.rotate_cw ? stream->format.enc_win.width : stream->format.enc_win.height)) {
+		iav_error("Crop can not bigger than stream resolution.\n");
+		return -1;
+	}
+
 	return 0;
 }
 
@@ -1082,6 +1288,11 @@ int check_stream_config_limit(struct ambarella_iav *iav, u32 stream_map)
 					return -1;
 				}
 			}
+			if (iav_check_overlay_param(stream, &stream->osd) < 0) {
+				iav_error("Incorrect overlay area for stream %c,"
+					" disable overlay first.\n", 'A' + i);
+				return -1;
+			}
 		}
 	}
 
@@ -1138,8 +1349,10 @@ static int iav_check_before_start_encode(struct ambarella_iav *iav, u32 stream_m
 	return 0;
 }
 
-static int check_stream_fps(struct iav_stream_fps *fps)
+static int check_stream_fps(struct ambarella_iav *iav, struct iav_stream_fps *fps)
 {
+	u32 idsp_out_frame_rate = 0;
+
 	if (fps->fps_div == 0) {
 		iav_error("Invalid fps_div: %d\n", fps->fps_div);
 		return -EINVAL;
@@ -1153,6 +1366,16 @@ static int check_stream_fps(struct iav_stream_fps *fps)
 		return -EINVAL;
 	}
 
+	if (iav_vin_get_idsp_frame_rate(iav, &idsp_out_frame_rate) < 0) {
+		return -EINVAL;
+	}
+	idsp_out_frame_rate = DIV_CLOSEST(FPS_Q9_BASE, idsp_out_frame_rate);
+	if ((idsp_out_frame_rate * fps->fps_multi) < fps->fps_div) {
+		iav_error("Encode frame rate: %u x (%u/%u) is less than 1 fps.\n",
+			idsp_out_frame_rate, fps->fps_multi, fps->fps_div);
+		return -EINVAL;
+	}
+
 	return 0;
 }
 
@@ -1160,8 +1383,10 @@ static int check_qp_matrix_param(struct iav_stream *stream,
 	struct iav_qpmatrix *h264_roi)
 {
 	u8 *start_addr = NULL;
-	int i, mb_width, mb_height, mb_pitch, total_size;
+	int i, j, mb_pitch, total_size;
 	struct iav_qproi_data *qp_data_addr;
+	struct iav_window win;
+	struct iav_stream_format *stream_format = NULL;
 
 	iav_no_check();
 
@@ -1170,28 +1395,49 @@ static int check_qp_matrix_param(struct iav_stream *stream,
 		return -1;
 	} else if (!h264_roi->qpm_no_check) {
 		start_addr = (u8 *)(stream->iav->mmap[IAV_BUFFER_QPMATRIX].virt) +
-			stream->format.id * STREAM_QP_MATRIX_SIZE;
-		mb_width = ALIGN(stream->format.enc_win.width, 16) / 16;
-		mb_height = ALIGN(stream->format.enc_win.height, 16) / 16;
-		mb_pitch = ALIGN(mb_width, 8);
-		total_size = mb_pitch * mb_height;
+			stream->id_dsp * STREAM_QP_MATRIX_SIZE;
+		stream_format = &stream->format;
+		get_stream_win_MB(stream_format, &win);
+		mb_pitch = ALIGN(win.width, 8);
+		total_size = mb_pitch * win.height;
+		// Always use I frame buffer no matter in IPB mode or not
 		qp_data_addr = (struct iav_qproi_data *)start_addr;
 		for (i = 0; i < total_size; ++i) {
 			if (qp_data_addr[i].qp_quality < QP_QUALITY_MIN ||
 				qp_data_addr[i].qp_quality > QP_QUALITY_MAX) {
 				iav_debug("Invalid QP quality value [%d] of element [%d] on "
 					"stream %c.\n", qp_data_addr[i].qp_quality, i,
-					'A' + stream->format.id);
+					'A' + stream->id_dsp);
 				return -1;
 			}
-			if (qp_data_addr[i].qp_offset < QP_OFFSET_MIN ||
-				qp_data_addr[i].qp_offset > QP_OFFSET_MAX) {
-				iav_debug("Invalid QP offset value [%d] of element [%d] on "
-					"stream %c.\n", qp_data_addr[i].qp_offset, i,
-					'A' + stream->format.id);
+		}
+
+		// Only P frame setting is valid
+		qp_data_addr = (struct iav_qproi_data *)(start_addr +
+			(STREAM_QP_MATRIX_NUM > 1 ? SINGLE_QP_MATRIX_SIZE : 0));
+		for (i = 0; i < total_size; ++i) {
+			if (qp_data_addr[i].zmv_threshold < ZMV_THRESHOLD_MIN ||
+				qp_data_addr[i].zmv_threshold > ZMV_THRESHOLD_MAX) {
+				iav_debug("Invalid zmv threshold value [%d] of element [%d] on "
+					"stream %c.\n", qp_data_addr[i].zmv_threshold, i,
+					'A' + stream->id_dsp);
 				return -1;
 			}
 		}
+
+		for (j = 0; j < STREAM_QP_MATRIX_NUM; ++j) {
+			qp_data_addr = (struct iav_qproi_data *)(start_addr + j * SINGLE_QP_MATRIX_SIZE);
+			for (i = 0; i < total_size; ++i) {
+				if (qp_data_addr[i].qp_offset < QP_OFFSET_MIN ||
+					qp_data_addr[i].qp_offset > QP_OFFSET_MAX) {
+					iav_debug("Invalid QP offset value [%d] of element [%d] for %c frame on "
+						"stream %c.\n", qp_data_addr[i].qp_offset, i,
+						((j == 0) ? 'I' : ((j == 1) ? 'P' : 'B')),
+						'A' + stream->id_dsp);
+					return -1;
+				}
+			}
+		}
 	}
 
 	return 0;
@@ -1236,11 +1482,17 @@ static inline int check_h264_bitrate(struct iav_bitrate *h264_rc)
 		|| h264_rc->qp_min_on_P > h264_rc->qp_max_on_P
 		|| h264_rc->qp_max_on_B > H264_QP_MAX
 		|| h264_rc->qp_min_on_B > h264_rc->qp_max_on_B
+		|| h264_rc->qp_max_on_Q > H264_QP_MAX
+		|| h264_rc->qp_min_on_Q > h264_rc->qp_max_on_Q
 		|| h264_rc->adapt_qp > H264_AQP_MAX
 		|| h264_rc->i_qp_reduce < H264_I_QP_REDUCE_MIN
 		|| h264_rc->i_qp_reduce > H264_I_QP_REDUCE_MAX
 		|| h264_rc->p_qp_reduce < H264_P_QP_REDUCE_MIN
-		|| h264_rc->p_qp_reduce > H264_P_QP_REDUCE_MAX) {
+		|| h264_rc->p_qp_reduce > H264_P_QP_REDUCE_MAX
+		|| h264_rc->q_qp_reduce < H264_Q_QP_REDUCE_MIN
+		|| h264_rc->q_qp_reduce > H264_Q_QP_REDUCE_MAX
+		|| h264_rc->log_q_num_plus_1 > H264_LOG_Q_NUM_PLUS_1_MAX
+		|| h264_rc->max_i_size_KB > H264_I_SIZE_KB_MAX) {
 		iav_error("Invalid QP limit, out of range!\n");
 		return -1;
 	}
@@ -1257,13 +1509,6 @@ static int check_qproi(struct iav_qpmatrix *h264_qproi, u8 enable_flag)
 		return -1;
 	}
 
-	if (h264_qproi->type != QPROI_TYPE_QP_QUALITY &&
-		h264_qproi->type != QPROI_TYPE_QP_OFFSET) {
-		iav_error("Invalid type [%d] of QP ROI for stream %c!\n",
-			h264_qproi->type, 'A' + h264_qproi->id);
-		return -1;
-	}
-
 	if (h264_qproi->size > STREAM_QP_MATRIX_SIZE) {
 		iav_error("QP ROI size %d cannot be larger than %d for stream %c!\n",
 			h264_qproi->size, STREAM_QP_MATRIX_SIZE, 'A' + h264_qproi->id);
@@ -1284,90 +1529,77 @@ int iav_ioc_start_encode(struct ambarella_iav *iav, void __user *arg)
 
 	stream_map = (u32)arg;
 
+	mutex_lock(&iav->enc_mutex);
 	mutex_lock(&iav->iav_mutex);
 
-	if (iav_check_start_encode_state(iav, stream_map) < 0) {
-		mutex_unlock(&iav->iav_mutex);
-		return -EINVAL;
-	}
-	iav_vin_update_stream_framerate(iav);
-	vcap_count = (iav->encode_mode == DSP_MULTI_REGION_WARP_MODE) ?
-		(WAIT_VSYNC_BEFORE_ENCODING + 1) : WAIT_VSYNC_BEFORE_ENCODING;
-	wait_vcap_count(iav, vcap_count);
-	iav_debug("Wait %d frames before encode for encode start delay.\n",
-		vcap_count);
+	do {
+		if (iav_check_start_encode_state(iav, stream_map) < 0) {
+			rval = -EINVAL;
+			break;
+		}
+		iav_vin_update_stream_framerate(iav);
+		if (likely(!iav->resume_flag)) {
+			vcap_count = (iav->encode_mode == DSP_MULTI_REGION_WARP_MODE) ?
+				(WAIT_VSYNC_BEFORE_ENCODING + 1) : WAIT_VSYNC_BEFORE_ENCODING;
+			wait_vcap_count(iav, vcap_count);
+			iav_debug("Wait %d frames before encode for encode start delay.\n",
+				vcap_count);
+		}
 
-	if (iav_check_before_start_encode(iav, stream_map) < 0) {
-		mutex_unlock(&iav->iav_mutex);
-		return -EINVAL;
-	}
+		if (iav_check_before_start_encode(iav, stream_map) < 0) {
+			rval = -EINVAL;
+			break;
+		}
 
-	/* Start a new travel from preview state. */
-	if (iav->state == IAV_STATE_PREVIEW) {
-		iav_reset_encode_obj(iav);
-		iav_debug("Init encoder when start encoding from preview state.\n");
-	}
+		/* Start a new travel from preview state. */
+		if (iav->state == IAV_STATE_PREVIEW) {
+			iav_reset_encode_obj(iav);
+			iav_debug("Init encoder when start encoding from preview state.\n");
+		}
 
-	/* Guarantee all encode start commans are issued in the same Vsync */
-	first = dsp->get_multi_cmds(dsp, IAV_MAX_ENCODE_STREAMS_NUM * 3,
-		DSP_CMD_FLAG_BLOCK);
-	if (!first) {
-		iav_error("Failed to get multiple commands for encode start!\n");
-		mutex_unlock(&iav->iav_mutex);
-		return -ENOMEM;
-	}
-	/* set up all streams */
-	for (i = 0, cmd = first; i < IAV_MAX_ENCODE_STREAMS_NUM; ++i) {
-		if (stream_map & (1 << i)) {
-			stream = &iav->stream[i];
-			create_session_id(stream);
-			cmd_encode_size_setup(stream, cmd);
-			get_next_cmd(cmd, first);
-			if (stream->format.type == IAV_STREAM_TYPE_H264) {
-				cmd_h264_encode_setup(stream, cmd);
-			} else {
-				cmd_jpeg_encode_setup(stream, cmd);
-			}
-			get_next_cmd(cmd, first);
-			stream->op = IAV_STREAM_OP_START;
+		/* Guarantee all encode start commans are issued in the same Vsync */
+		first = dsp->get_multi_cmds(dsp, IAV_MAX_ENCODE_STREAMS_NUM * 4,
+			DSP_CMD_FLAG_BLOCK);
+		if (!first) {
+			iav_error("Failed to get multiple commands for encode start!\n");
+			rval = -ENOMEM;
+			break;
 		}
-	}
-	/* start all streams */
-	for (i = 0; i < IAV_MAX_ENCODE_STREAMS_NUM; ++i) {
-		if (stream_map & (1 << i)) {
-			stream = &iav->stream[i];
-			if (stream->format.type == IAV_STREAM_TYPE_H264) {
-				cmd_h264_encode_start(stream, cmd);
-			} else {
-				cmd_jpeg_encode_start(stream, cmd);
+		/* set up all streams */
+		for (i = 0, cmd = first; i < IAV_MAX_ENCODE_STREAMS_NUM; ++i) {
+			if (stream_map & (1 << i)) {
+				stream = &iav->stream[i];
+				create_session_id(stream);
+				cmd_encode_size_setup(stream, cmd);
+				get_next_cmd(cmd, first);
+				if (stream->format.type == IAV_STREAM_TYPE_H264) {
+					cmd_h264_encode_setup(stream, cmd);
+				} else {
+					cmd_jpeg_encode_setup(stream, cmd);
+				}
+				get_next_cmd(cmd, first);
+				stream->op = IAV_STREAM_OP_START;
 			}
-			get_next_cmd(cmd, first);
-			spin_lock_irq(&iav->iav_lock);
-			inc_srcbuf_ref(stream->srcbuf);
-			spin_unlock_irq(&iav->iav_lock);
 		}
-	}
-	dsp->put_cmd(dsp, first, 0);
-
-	/* wait untill all streams start up */
-	for (i = 0; i < IAV_MAX_ENCODE_STREAMS_NUM; ++i) {
-		if (stream_map & (1 << i)) {
-			stream = &iav->stream[i];
-			if (is_stream_in_starting(stream)) {
-				mutex_unlock(&iav->iav_mutex);
-				rval = wait_event_interruptible_timeout(stream->venc_wq,
-					(stream->dsp_state == ENC_BUSY_STATE),
-					FIVE_JIFFIES);
-				mutex_lock(&iav->iav_mutex);
-				if (rval <= 0) {
-					iav_debug("stream %c: wait_event_interruptible_timeout\n",
-						'A' + i);
-					rval = -EAGAIN;
+		/* start all streams */
+		for (i = 0; i < IAV_MAX_ENCODE_STREAMS_NUM; ++i) {
+			if (stream_map & (1 << i)) {
+				stream = &iav->stream[i];
+				if (stream->format.type == IAV_STREAM_TYPE_H264) {
+					cmd_h264_encode_start(stream, cmd);
 				} else {
-					rval = 0;
+					cmd_jpeg_encode_start(stream, cmd);
 				}
+				get_next_cmd(cmd, first);
+				spin_lock_irq(&iav->iav_lock);
+				inc_srcbuf_ref(stream->srcbuf, i);
+				spin_unlock_irq(&iav->iav_lock);
 			}
-			if (is_stream_in_encoding(stream)) {
+		}
+		/* update parameters for all streams */
+		for (i = 0; i < IAV_MAX_ENCODE_STREAMS_NUM; ++i) {
+			if (stream_map & (1 << i)) {
+				stream = &iav->stream[i];
 				update_flags = 0;
 				if (stream->format.type == IAV_STREAM_TYPE_H264) {
 					update_flags = REALTIME_PARAM_CBR_MODIFY_BIT |
@@ -1379,13 +1611,38 @@ int iav_ioc_start_encode(struct ambarella_iav *iav, void __user *arg)
 						REALTIME_PARAM_CUSTOM_VIN_FPS_BIT;
 				}
 				if (update_flags) {
-					cmd_update_encode_params(stream, NULL, update_flags);
+					cmd_update_encode_params(stream, cmd, update_flags);
+					get_next_cmd(cmd, first);
 				}
 			}
 		}
-	}
+		dsp->put_cmd(dsp, first, 0);
+
+		/* wait untill all streams start up */
+		for (i = 0; i < IAV_MAX_ENCODE_STREAMS_NUM; ++i) {
+			if (stream_map & (1 << i)) {
+				stream = &iav->stream[i];
+				if (is_stream_in_starting(stream)) {
+					mutex_unlock(&iav->iav_mutex);
+					rval = wait_event_interruptible_timeout(stream->venc_wq,
+						(stream->dsp_state == ENC_BUSY_STATE),
+						FIVE_JIFFIES);
+					mutex_lock(&iav->iav_mutex);
+					if (rval <= 0) {
+						iav_debug("stream %c: wait_event_interruptible_timeout\n",
+							'A' + i);
+						rval = -EAGAIN;
+						break;
+					} else {
+						rval = 0;
+					}
+				}
+			}
+		}
+	} while (0);
 
 	mutex_unlock(&iav->iav_mutex);
+	mutex_unlock(&iav->enc_mutex);
 
 	return rval;
 }
@@ -1425,59 +1682,131 @@ int iav_ioc_stop_encode(struct ambarella_iav *iav, void __user *arg)
 	u32 stream_map = (u32)arg;
 	int i, rval = 0;
 
+	mutex_lock(&iav->enc_mutex);
 	mutex_lock(&iav->iav_mutex);
 
-	if ((rval = iav_check_stop_encode_state(iav, &stream_map)) < 0) {
-		mutex_unlock(&iav->iav_mutex);
-		return rval;
-	}
+	do {
+		if ((rval = iav_check_stop_encode_state(iav, &stream_map)) < 0) {
+			break;
+		}
 
-	first = dsp->get_multi_cmds(dsp,
-		IAV_MAX_ENCODE_STREAMS_NUM, DSP_CMD_FLAG_BLOCK);
-	if (!first) {
-		iav_error("Failed to get multiple commands for encode stop!\n");
-		mutex_unlock(&iav->iav_mutex);
-		return -ENOMEM;
-	}
-	/* stop multiple encoding streams at same VSYNC interrupt */
-	for (i = 0, cmd = first; i < IAV_MAX_ENCODE_STREAMS_NUM; ++i) {
-		stream = &iav->stream[i];
-		if ((stream_map & (1 << i)) && is_stream_in_encoding(stream)) {
-			cmd_encode_stop(stream, cmd);
-			get_next_cmd(cmd, first);
+		first = dsp->get_multi_cmds(dsp, IAV_MAX_ENCODE_STREAMS_NUM,
+			DSP_CMD_FLAG_BLOCK);
+		if (!first) {
+			iav_error("Failed to get multiple commands for encode stop!\n");
+			rval = -ENOMEM;
+			break;
+		}
+		/* stop multiple encoding streams at same VSYNC interrupt */
+		for (i = 0, cmd = first; i < IAV_MAX_ENCODE_STREAMS_NUM; ++i) {
+			stream = &iav->stream[i];
+			if ((stream_map & (1 << i)) && is_stream_in_encoding(stream)) {
+				cmd_encode_stop(stream, cmd);
+				get_next_cmd(cmd, first);
 
-			spin_lock_irq(&iav->iav_lock);
-			stream->op = IAV_STREAM_OP_STOP;
-			spin_unlock_irq(&iav->iav_lock);
-		} else {
-			stream_map &= ~(1 << i);
+				spin_lock_irq(&iav->iav_lock);
+				stream->op = IAV_STREAM_OP_STOP;
+				spin_unlock_irq(&iav->iav_lock);
+			} else {
+				stream_map &= ~(1 << i);
+			}
+		}
+		dsp->put_cmd(dsp, first, 0);
+
+		/* wait for all streams in FREE state to stop */
+		for (i = 0; i < IAV_MAX_ENCODE_STREAMS_NUM; ++i) {
+			if (stream_map & (1 << i)) {
+				stream = &iav->stream[i];
+				if (is_stream_in_stopping(stream)) {
+					mutex_unlock(&iav->iav_mutex);
+					rval = wait_event_interruptible_timeout(stream->venc_wq,
+						(stream->dsp_state == ENC_IDLE_STATE),
+						FIVE_JIFFIES);
+					mutex_lock(&iav->iav_mutex);
+					if (rval <= 0) {
+						if (stream->format.buf_id != IAV_SRCBUF_EFM) {
+							iav_debug("stream %c: wait_event_interruptible_timeout\n",
+								'A' + i);
+							rval = -EAGAIN;
+							break;
+						} else {
+							iav_warn("stream %c [EFM]: wait event timeout, need to abort encode\n",
+								'A' + i);
+							rval = 0;
+						}
+					} else {
+						rval = 0;
+					}
+				}
+			}
+		}
+	} while (0);
+
+	mutex_unlock(&iav->iav_mutex);
+	mutex_unlock(&iav->enc_mutex);
+
+	return rval;
+}
+
+int iav_ioc_abort_encode(struct ambarella_iav *iav, void __user *arg)
+{
+	u32 i;
+	struct iav_stream *stream;
+	u32 stream_map = (u32)arg;
+	int rval = 0;
+
+	for (i = 0; i < IAV_MAX_ENCODE_STREAMS_NUM; ++i) {
+		if (stream_map & (1 << i)) {
+			stream = &iav->stream[i];
+			if (is_stream_in_encoding(stream)) {
+				iav_warn("stream %c: is in encoding, stop first\n", 'A' + i);
+				return 0;
+			}
 		}
 	}
-	dsp->put_cmd(dsp, first, 0);
 
-	/* wait for all streams in FREE state to stop */
+	mutex_lock(&iav->enc_mutex);
+	mutex_lock(&iav->iav_mutex);
+
 	for (i = 0; i < IAV_MAX_ENCODE_STREAMS_NUM; ++i) {
 		if (stream_map & (1 << i)) {
 			stream = &iav->stream[i];
-			if (is_stream_in_stopping(stream)) {
-				mutex_unlock(&iav->iav_mutex);
-				rval = wait_event_interruptible_timeout(stream->venc_wq,
-					(stream->dsp_state == ENC_IDLE_STATE),
-					FIVE_JIFFIES);
-				mutex_lock(&iav->iav_mutex);
-				if (rval <= 0) {
-					iav_debug("stream %c: wait_event_interruptible_timeout\n",
-						'A' + i);
-					rval = -EAGAIN;
-				} else {
-					rval = 0;
+			if (stream->format.buf_id == IAV_SRCBUF_EFM) {
+				if (is_stream_in_stopping(stream)) {
+					/* feed an empty frame to let dsp exit encoding state */
+					if (iav_efm_feed_empty_frame(iav, stream)) {
+						iav_error("stream %c: fail to feed empty efm frame\n",
+							'A' + i);
+						rval = -EFAULT;
+						break;
+					}
+					mutex_unlock(&iav->iav_mutex);
+					rval = wait_event_interruptible_timeout(stream->venc_wq,
+						(stream->dsp_state == ENC_IDLE_STATE), FIVE_JIFFIES);
+					mutex_lock(&iav->iav_mutex);
+					if (rval <= 0) {
+						iav_debug("stream %c: wait event timeout\n",
+							'A' + i);
+						rval = -EFAULT;
+						break;
+					}
+				}
+			} else {
+				if ((is_stream_in_stopping(stream)) ||
+					(is_stream_in_starting(stream))) {
+					spin_lock_irq(&iav->iav_lock);
+					stream->dsp_state = ENC_IDLE_STATE;
+					stream->op = IAV_STREAM_OP_STOP;
+					stream->fake_dsp_state = ENC_IDLE_STATE;
+					stream->session_id = 0;
+					spin_unlock_irq(&iav->iav_lock);
 				}
 			}
-			//stream->session_id = 0;
 		}
 	}
 
 	mutex_unlock(&iav->iav_mutex);
+	mutex_unlock(&iav->enc_mutex);
 
 	return rval;
 }
@@ -1537,11 +1866,6 @@ static int iav_check_stream_format(u32 enc_mode,
 		return -1;
 	}
 
-	if (format->snapshot_enable && type != IAV_STREAM_TYPE_MJPEG) {
-		iav_error("snap shot is only supported by MJPEG stream!\n");
-		return -1;
-	}
-
 	return 0;
 }
 
@@ -1650,7 +1974,7 @@ static int iav_set_stream_fps(struct ambarella_iav *iav, u32 stream_id,
 		return -EINVAL;
 	}
 
-	if (check_stream_fps(fps) < 0) {
+	if (check_stream_fps(iav, fps) < 0) {
 		return -EINVAL;
 	}
 	stream->fps = *fps;
@@ -1676,10 +2000,12 @@ static int iav_set_stream_fps(struct ambarella_iav *iav, u32 stream_id,
 		// apply stream fps
 		update_flags = REALTIME_PARAM_CUSTOM_FRAME_RATE_BIT |
 			REALTIME_PARAM_CUSTOM_VIN_FPS_BIT;
-		if (stream->format.type == IAV_STREAM_TYPE_H264)
+		if (stream->format.type == IAV_STREAM_TYPE_H264) {
 			update_flags |= REALTIME_PARAM_CBR_MODIFY_BIT;
-		if (cmd_update_encode_params(stream, NULL, update_flags) < 0)
+		}
+		if (cmd_update_encode_params(stream, NULL, update_flags) < 0) {
 			return -EIO;
+		}
 	}
 
 	return 0;
@@ -1700,9 +2026,7 @@ static int iav_set_stream_offset(struct ambarella_iav *iav, u32 stream_id,
 	}
 
 	if (is_stream_in_encoding(stream)) {
-		// on the fly change stream offset is NOT supported.
-		iav_error("Currently change stream offset on the fly is NOT supported.\n");
-		return -EINVAL;
+		cmd_encode_size_setup(stream, NULL);
 	}
 
 	return 0;
@@ -1778,59 +2102,15 @@ static int iav_set_h264_bitrate(struct ambarella_iav *iav, u32 stream_id,
 	switch (h264_rc->vbr_setting) {
 	case IAV_BRC_CBR:
 		h264_cfg->vbr_setting = IAV_BRC_CBR;
-		h264_cfg->average_bitrate = h264_rc->average_bitrate;
-		h264_cfg->qp_min_on_I = h264_rc->qp_min_on_I;
-		h264_cfg->qp_max_on_I = h264_rc->qp_max_on_I;
-		h264_cfg->qp_min_on_P = h264_rc->qp_min_on_P;
-		h264_cfg->qp_max_on_P = h264_rc->qp_max_on_P;
-		h264_cfg->qp_min_on_B = h264_rc->qp_min_on_B;
-		h264_cfg->qp_max_on_B = h264_rc->qp_max_on_B;
-		h264_cfg->i_qp_reduce = h264_rc->i_qp_reduce;
-		h264_cfg->p_qp_reduce = h264_rc->p_qp_reduce;
-		h264_cfg->adapt_qp = h264_rc->adapt_qp;
-		h264_cfg->skip_flag = h264_rc->skip_flag;
 		break;
 	case IAV_BRC_PCBR:
 		h264_cfg->vbr_setting = IAV_BRC_PCBR;
-		h264_cfg->average_bitrate = h264_rc->average_bitrate;
-		h264_cfg->qp_min_on_I = h264_rc->qp_min_on_I;
-		h264_cfg->qp_max_on_I = h264_rc->qp_max_on_I;
-		h264_cfg->qp_min_on_P = h264_rc->qp_min_on_P;
-		h264_cfg->qp_max_on_P = h264_rc->qp_max_on_P;
-		h264_cfg->qp_min_on_B = h264_rc->qp_min_on_B;
-		h264_cfg->qp_max_on_B = h264_rc->qp_max_on_B;
-		h264_cfg->i_qp_reduce = h264_rc->i_qp_reduce;
-		h264_cfg->p_qp_reduce = h264_rc->p_qp_reduce;
-		h264_cfg->adapt_qp = h264_rc->adapt_qp;
-		h264_cfg->skip_flag = h264_rc->skip_flag;
 		break;
 	case IAV_BRC_SCBR:
 		h264_cfg->vbr_setting = IAV_BRC_SCBR;
-		h264_cfg->average_bitrate = h264_rc->average_bitrate;
-		h264_cfg->qp_min_on_I = h264_rc->qp_min_on_I;
-		h264_cfg->qp_max_on_I = h264_rc->qp_max_on_I;
-		h264_cfg->qp_min_on_P = h264_rc->qp_min_on_P;
-		h264_cfg->qp_max_on_P = h264_rc->qp_max_on_P;
-		h264_cfg->qp_min_on_B = h264_rc->qp_min_on_B;
-		h264_cfg->qp_max_on_B = h264_rc->qp_max_on_B;
-		h264_cfg->i_qp_reduce = h264_rc->i_qp_reduce;
-		h264_cfg->p_qp_reduce = h264_rc->p_qp_reduce;
-		h264_cfg->adapt_qp = h264_rc->adapt_qp;
-		h264_cfg->skip_flag = h264_rc->skip_flag;
 		break;
 	case IAV_BRC_VBR:
 		h264_cfg->vbr_setting = IAV_BRC_VBR;
-		h264_cfg->average_bitrate = h264_rc->average_bitrate;
-		h264_cfg->qp_min_on_I = h264_rc->qp_min_on_I;
-		h264_cfg->qp_max_on_I = h264_rc->qp_max_on_I;
-		h264_cfg->qp_min_on_P = h264_rc->qp_min_on_P;
-		h264_cfg->qp_max_on_P = h264_rc->qp_max_on_P;
-		h264_cfg->qp_min_on_B = h264_rc->qp_min_on_B;
-		h264_cfg->qp_max_on_B = h264_rc->qp_max_on_B;
-		h264_cfg->i_qp_reduce = h264_rc->i_qp_reduce;
-		h264_cfg->p_qp_reduce = h264_rc->p_qp_reduce;
-		h264_cfg->adapt_qp = h264_rc->adapt_qp;
-		h264_cfg->skip_flag = h264_rc->skip_flag;
 		break;
 	default:
 		iav_error("Unknown rate control mode!\n");
@@ -1838,6 +2118,23 @@ static int iav_set_h264_bitrate(struct ambarella_iav *iav, u32 stream_id,
 		break;
 	}
 
+	h264_cfg->average_bitrate = h264_rc->average_bitrate;
+	h264_cfg->qp_min_on_I = h264_rc->qp_min_on_I;
+	h264_cfg->qp_max_on_I = h264_rc->qp_max_on_I;
+	h264_cfg->qp_min_on_P = h264_rc->qp_min_on_P;
+	h264_cfg->qp_max_on_P = h264_rc->qp_max_on_P;
+	h264_cfg->qp_min_on_B = h264_rc->qp_min_on_B;
+	h264_cfg->qp_max_on_B = h264_rc->qp_max_on_B;
+	h264_cfg->qp_min_on_Q = h264_rc->qp_min_on_Q;
+	h264_cfg->qp_max_on_Q = h264_rc->qp_max_on_Q;
+	h264_cfg->i_qp_reduce = h264_rc->i_qp_reduce;
+	h264_cfg->p_qp_reduce = h264_rc->p_qp_reduce;
+	h264_cfg->q_qp_reduce = h264_rc->q_qp_reduce;
+	h264_cfg->log_q_num_plus_1 = h264_rc->log_q_num_plus_1;
+	h264_cfg->adapt_qp = h264_rc->adapt_qp;
+	h264_cfg->skip_flag = h264_rc->skip_flag;
+	h264_cfg->max_I_size_KB = h264_rc->max_i_size_KB;
+
 	if (is_stream_in_encoding(stream)) {
 		stream_map = 1 << stream_id;
 		// check encode resource limit
@@ -1868,6 +2165,7 @@ static int iav_set_h264_roi(struct ambarella_iav *iav, u32 stream_id,
 {
 	struct iav_stream *stream;
 	struct iav_h264_config *config;
+	struct iav_cmd_sync *cmd_sync;
 	u32 src_offset, dst_offset, size, buff_id;
 	int i;
 
@@ -1880,7 +2178,6 @@ static int iav_set_h264_roi(struct ambarella_iav *iav, u32 stream_id,
 	}
 
 	config->qp_roi_enable = h264_roi->enable;
-	config->qp_type = h264_roi->type;
 	for (i = 0; i < NUM_PIC_TYPES; ++i) {
 		config->qp_delta[i][0] = h264_roi->qp_delta[i][0];
 		config->qp_delta[i][1] = h264_roi->qp_delta[i][1];
@@ -1895,9 +2192,10 @@ static int iav_set_h264_roi(struct ambarella_iav *iav, u32 stream_id,
 			cmd_update_encode_params(stream, NULL,
 				REALTIME_PARAM_QP_ROI_MATRIX_BIT);
 		} else {
+			cmd_sync = &iav->cmd_sync;
 			if (!h264_roi->qpm_no_update) {
 				src_offset = stream_id * STREAM_QP_MATRIX_SIZE;
-				dst_offset = iav->cmd_sync_qpm_idx * QP_MATRIX_SIZE +
+				dst_offset = cmd_sync->qpm_idx * QP_MATRIX_SIZE +
 					stream_id * STREAM_QP_MATRIX_SIZE;
 				buff_id = IAV_BUFFER_QPMATRIX;
 				size = STREAM_QP_MATRIX_SIZE;
@@ -1905,7 +2203,7 @@ static int iav_set_h264_roi(struct ambarella_iav *iav, u32 stream_id,
 					size, KByte(1)) < 0) {
 					return -EFAULT;
 				}
-				iav->cmd_sync_qpm_flag = 1;
+				cmd_sync->qpm_flag = 1;
 			}
 			update_sync_encode_params(stream, NULL,
 				REALTIME_PARAM_QP_ROI_MATRIX_BIT);
@@ -1932,7 +2230,6 @@ static int iav_get_h264_roi(struct ambarella_iav * iav, u32 stream_id,
 
 	h264_roi->id = stream_id;
 	h264_roi->enable = h264_cfg->qp_roi_enable;
-	h264_roi->type = h264_cfg->qp_type;
 	for (i = 0; i < NUM_PIC_TYPES; ++i) {
 		h264_roi->qp_delta[i][0] = h264_cfg->qp_delta[i][0];
 		h264_roi->qp_delta[i][1] = h264_cfg->qp_delta[i][1];
@@ -1949,8 +2246,8 @@ static int iav_get_h264_roi(struct ambarella_iav * iav, u32 stream_id,
 	 */
 	if (cmd_delay && !h264_roi->qpm_no_update) {
 		/* get the qp matrix that is already applied */
-		qpm_idx = (iav->cmd_sync_qpm_idx + ENC_CMD_TOGGLED_NUM - 2) %
-			ENC_CMD_TOGGLED_NUM + 1;
+		qpm_idx = (iav->cmd_sync.qpm_idx + QP_MATRIX_TOGGLED_NUM - 2) %
+			QP_MATRIX_TOGGLED_NUM + 1;
 		src_offset  = qpm_idx * QP_MATRIX_SIZE +
 			stream_id * STREAM_QP_MATRIX_SIZE;
 		buff_id = IAV_BUFFER_QPMATRIX;
@@ -2007,15 +2304,18 @@ static int iav_set_h264_force_fast_seek(struct ambarella_iav *iav, u32 stream_id
 }
 
 static int iav_set_h264_frame_drop(struct ambarella_iav *iav, u32 stream_id,
-	u32 drop_frames, int cmd_delay)
+	struct iav_h264_frame_drop *h264_rame_drop, int cmd_delay)
 {
 	struct iav_stream *stream = &iav->stream[stream_id];
+	int drop_num = h264_rame_drop->drop_num;
+	int repeat_enable = h264_rame_drop->repeat_enable;
 
-	if (check_frame_drop(stream, drop_frames) < 0) {
+	if (check_frame_drop(stream, drop_num) < 0) {
 		return -EINVAL;
 	}
 
-	stream->h264_config.drop_frames = drop_frames;
+	stream->h264_config.drop_frames = drop_num;
+	stream->h264_config.drop_frame_repeat = repeat_enable;
 
 	if (is_stream_in_encoding(stream) &&
 		(stream->format.type == IAV_STREAM_TYPE_H264)) {
@@ -2059,12 +2359,12 @@ static int iav_set_h264_zmv_threshold(struct ambarella_iav *iav, u32 stream_id,
 	return 0;
 }
 
-static int iav_set_h264_enc_improve(struct ambarella_iav *iav, u32 stream_id,
-	int enc_improve, int cmd_delay)
+static int iav_set_h264_flat_area_improve(struct ambarella_iav *iav,
+	u32 stream_id, int flat_area_improve, int cmd_delay)
 {
 	struct iav_stream *stream = &iav->stream[stream_id];
 
-	stream->h264_config.enc_improve = enc_improve ? 1 : 0;
+	stream->h264_config.flat_area_improve = flat_area_improve ? 1 : 0;
 
 	if (is_stream_in_encoding(stream) &&
 		(stream->format.type == IAV_STREAM_TYPE_H264)) {
@@ -2080,6 +2380,101 @@ static int iav_set_h264_enc_improve(struct ambarella_iav *iav, u32 stream_id,
 	return 0;
 }
 
+static int iav_set_h264_statis(struct ambarella_iav *iav,
+	u32 stream_id, int statis, int cmd_delay)
+{
+	struct iav_stream *stream = &iav->stream[stream_id];
+
+	stream->h264_config.statis = statis ? 1 : 0;
+
+	if (is_stream_in_encoding(stream) &&
+		(stream->format.type == IAV_STREAM_TYPE_H264)) {
+		if (!cmd_delay) {
+			cmd_update_encode_params(stream, NULL,
+				REALTIME_PARAM_MV_DUMP_BIT);
+		} else {
+			update_sync_encode_params(stream, NULL,
+				REALTIME_PARAM_MV_DUMP_BIT);
+		}
+	}
+
+	return 0;
+}
+
+static int iav_set_h264_long_ref_p(struct ambarella_iav *iav,
+	u32 stream_id, int cmd_delay)
+{
+	struct iav_stream *stream = &iav->stream[stream_id];
+
+	if (stream->h264_config.gop_structure != IAV_GOP_LT_REF_P){
+		iav_error("Only support Long ref P when gop = %d!\n", IAV_GOP_LT_REF_P);
+		return -EINVAL;
+	}
+
+	if (is_stream_in_encoding(stream) &&
+		(stream->format.type == IAV_STREAM_TYPE_H264)) {
+		if (!cmd_delay) {
+			cmd_update_encode_params(stream, NULL,
+				REALTIME_PARAM_LONG_REF_P_BIT);
+		} else {
+			update_sync_encode_params(stream, NULL,
+				REALTIME_PARAM_LONG_REF_P_BIT);
+		}
+	}
+
+	return 0;
+}
+
+static int iav_set_h264_rc_strategy(struct ambarella_iav *iav,
+	u32 stream_id, struct iav_rc_strategy *h264_rc_strategy)
+{
+	struct iav_stream *stream = &iav->stream[stream_id];
+
+	if (!is_stream_in_idle(stream)) {
+		iav_error("Stream %c is not in idle when setting bitrate_autosync_disable.\n",
+			'A' + stream_id);
+		return -EINVAL;
+	}
+
+	if (stream->format.type == IAV_STREAM_TYPE_H264) {
+		stream->h264_config.abs_br_flag = (u8)h264_rc_strategy->abs_br_flag;
+	}
+
+	return 0;
+}
+
+static int iav_set_h264_force_pskip(struct ambarella_iav *iav, u32 stream_id,
+	struct iav_h264_pskip *h264_pskip, int cmd_delay)
+{
+	struct iav_stream *stream;
+	int rpt_enable, rpt_num;
+
+	stream = &iav->stream[stream_id];
+	rpt_enable = h264_pskip->repeat_enable;
+	rpt_num = h264_pskip->repeat_num;
+
+	if (rpt_enable && (rpt_num < 0 || rpt_num > MAX_PSKIP_REPEAT)) {
+		iav_error("Repeat pskip number should between [0~%d).\n", MAX_PSKIP_REPEAT);
+		return -EINVAL;
+	}
+
+	stream->h264_config.pskip_repeat_enable = rpt_enable;
+	stream->h264_config.repeat_pskip_num = rpt_enable ? rpt_num : 0;
+
+	if (is_stream_in_encoding(stream) &&
+		(stream->format.type == IAV_STREAM_TYPE_H264)) {
+		if (!cmd_delay) {
+			cmd_update_encode_params(stream, NULL,
+				REALTIME_PARAM_FORCE_PSKIP_BIT);
+		} else {
+			update_sync_encode_params(stream, NULL,
+				REALTIME_PARAM_FORCE_PSKIP_BIT);
+		}
+	}
+
+	return 0;
+}
+
 static int iav_set_h264_enc_param(struct ambarella_iav *iav, u32 stream_id,
 	struct iav_h264_enc_param *h264_enc, int cmd_delay)
 {
@@ -2198,9 +2593,9 @@ int iav_ioc_s_stream_cfg(struct ambarella_iav *iav, void __user *arg)
 		rval = iav_set_h264_zmv_threshold(iav, cfg.id,
 			cfg.arg.mv_threshold, 0);
 		break;
-	case IAV_H264_CFG_ENC_IMPROVE:
-		rval = iav_set_h264_enc_improve(iav, cfg.id,
-			cfg.arg.h264_enc_improve, 0);
+	case IAV_H264_CFG_FLAT_AREA_IMPROVE:
+		rval = iav_set_h264_flat_area_improve(iav, cfg.id,
+			cfg.arg.h264_flat_area_improve, 0);
 		break;
 	case IAV_H264_CFG_FORCE_FAST_SEEK:
 		rval = iav_set_h264_force_fast_seek(iav, cfg.id,
@@ -2208,17 +2603,30 @@ int iav_ioc_s_stream_cfg(struct ambarella_iav *iav, void __user *arg)
 		break;
 	case IAV_H264_CFG_FRAME_DROP:
 		rval = iav_set_h264_frame_drop(iav, cfg.id,
-			cfg.arg.h264_drop_frames, 0);
+			&cfg.arg.h264_frame_drop, 0);
 		break;
 	case IAV_H264_CFG_ENC_PARAM:
 		rval = iav_set_h264_enc_param(iav, cfg.id,
 			&cfg.arg.h264_enc, 0);
 		break;
+	case IAV_H264_CFG_STATIS:
+		rval = iav_set_h264_statis(iav, cfg.id,
+			cfg.arg.h264_statis, 0);
+		break;
 	case IAV_MJPEG_CFG_QUALITY:
 		rval = iav_set_mjpeg_quality(iav, cfg.id, cfg.arg.mjpeg_quality);
 		break;
+	case IAV_H264_CFG_LONG_REF_P:
+		rval = iav_set_h264_long_ref_p(iav, cfg.id, 0);
+		break;
+	case IAV_H264_CFG_RC_STRATEGY:
+		rval = iav_set_h264_rc_strategy(iav, cfg.id, &cfg.arg.h264_rc_strategy);
+		break;
+	case IAV_H264_CFG_FORCE_PSKIP:
+		rval = iav_set_h264_force_pskip(iav, cfg.id, &cfg.arg.h264_pskip, 0);
+		break;
 	default:
-		iav_error("Unknown cid: %d!\n", cfg.cid);
+		iav_error("Unknown cid: 0x%X!\n", cfg.cid);
 		rval = -EINVAL;
 		break;
 	}
@@ -2236,6 +2644,8 @@ int iav_ioc_g_stream_cfg(struct ambarella_iav *iav, void __user *args)
 	struct iav_h264_config *h264_cfg;
 	struct iav_h264_enc_param *h264_enc;
 	struct iav_qpmatrix *h264_roi;
+	struct iav_h264_pskip *h264_pskip;
+	struct iav_h264_frame_drop *h264_frame_drop;
 
 	if (copy_from_user(&cfg, args, sizeof(cfg)))
 		return -EFAULT;
@@ -2246,6 +2656,12 @@ int iav_ioc_g_stream_cfg(struct ambarella_iav *iav, void __user *args)
 	}
 
 	stream = &iav->stream[cfg.id];
+	h264_cfg = &stream->h264_config;
+	h264_enc = &cfg.arg.h264_enc;
+	h264_rc = &cfg.arg.h264_rc;
+	h264_roi = &cfg.arg.h264_roi;
+	h264_pskip = &cfg.arg.h264_pskip;
+	h264_frame_drop = &cfg.arg.h264_frame_drop;
 
 	mutex_lock(&iav->iav_mutex);
 
@@ -2274,9 +2690,6 @@ int iav_ioc_g_stream_cfg(struct ambarella_iav *iav, void __user *args)
 		break;
 
 	case IAV_H264_CFG_BITRATE:
-		h264_rc = &cfg.arg.h264_rc;
-		h264_cfg = &stream->h264_config;
-
 		h264_rc->id = cfg.id;
 		h264_rc->vbr_setting = h264_cfg->vbr_setting;
 		h264_rc->average_bitrate = h264_cfg->average_bitrate;
@@ -2286,29 +2699,30 @@ int iav_ioc_g_stream_cfg(struct ambarella_iav *iav, void __user *args)
 		h264_rc->qp_max_on_P = h264_cfg->qp_max_on_P;
 		h264_rc->qp_min_on_B = h264_cfg->qp_min_on_B;
 		h264_rc->qp_max_on_B = h264_cfg->qp_max_on_B;
+		h264_rc->qp_min_on_Q = h264_cfg->qp_min_on_Q;
+		h264_rc->qp_max_on_Q = h264_cfg->qp_max_on_Q;
 		h264_rc->i_qp_reduce = h264_cfg->i_qp_reduce;
 		h264_rc->p_qp_reduce = h264_cfg->p_qp_reduce;
+		h264_rc->q_qp_reduce = h264_cfg->q_qp_reduce;
+		h264_rc->log_q_num_plus_1 = h264_cfg->log_q_num_plus_1;
 		h264_rc->adapt_qp = h264_cfg->adapt_qp;
 		h264_rc->skip_flag = h264_cfg->skip_flag;
+		h264_rc->max_i_size_KB = h264_cfg->max_I_size_KB;
 		break;
 
 	case IAV_H264_CFG_ZMV_THRESHOLD:
 		cfg.arg.mv_threshold = stream->h264_config.zmv_threshold;
 		break;
 
-	case IAV_H264_CFG_ENC_IMPROVE:
-		cfg.arg.h264_enc_improve = stream->h264_config.enc_improve;
+	case IAV_H264_CFG_FLAT_AREA_IMPROVE:
+		cfg.arg.h264_flat_area_improve = stream->h264_config.flat_area_improve;
 		break;
 
 	case IAV_H264_CFG_QP_ROI:
-		h264_roi = &cfg.arg.h264_roi;
 		iav_get_h264_roi(iav, cfg.id, h264_roi, 0);
 		break;
 
 	case IAV_H264_CFG_ENC_PARAM:
-		h264_enc = &cfg.arg.h264_enc;
-		h264_cfg = &stream->h264_config;
-
 		h264_enc->id = cfg.id;
 		h264_enc->intrabias_p = h264_cfg->intrabias_p;
 		h264_enc->intrabias_b = h264_cfg->intrabias_b;
@@ -2320,13 +2734,31 @@ int iav_ioc_g_stream_cfg(struct ambarella_iav *iav, void __user *args)
 		h264_enc->user3_direct_bias = h264_cfg->user3_direct_bias;
 		break;
 
+	case IAV_H264_CFG_STATIS:
+		cfg.arg.h264_statis = stream->h264_config.statis;
+		break;
+
 	case IAV_MJPEG_CFG_QUALITY:
 		cfg.arg.mjpeg_quality = stream->mjpeg_config.quality;
 		break;
 
+	case IAV_H264_CFG_RC_STRATEGY:
+		cfg.arg.h264_rc_strategy.abs_br_flag = h264_cfg->abs_br_flag;
+		break;
+
+	case IAV_H264_CFG_FORCE_PSKIP:
+		h264_pskip->repeat_enable = h264_cfg->pskip_repeat_enable;
+		h264_pskip->repeat_num = h264_cfg->repeat_pskip_num;
+		break;
+
+	case IAV_H264_CFG_FRAME_DROP:
+		h264_frame_drop->drop_num = h264_cfg->drop_frames;
+		h264_frame_drop->repeat_enable = h264_cfg->drop_frame_repeat;
+		break;
+
 	default:
 		mutex_unlock(&iav->iav_mutex);
-		iav_error("Invalid cid: %d\n", cfg.cid);
+		iav_error("Invalid cid: 0x%X\n", cfg.cid);
 		return -EINVAL;
 	}
 
@@ -2364,7 +2796,7 @@ int iav_ioc_s_stream_fps_sync(struct ambarella_iav *iav, void __user *arg)
 				mutex_unlock(&iav->iav_mutex);
 				return -EINVAL;
 			}
-			if (check_stream_fps(&fps_sync.fps[i]) < 0) {
+			if (check_stream_fps(iav, &fps_sync.fps[i]) < 0) {
 				iav_error("Invalid stream fps for Stream %c.\n", 'A' + i);
 				mutex_unlock(&iav->iav_mutex);
 				return -EINVAL;
@@ -2406,8 +2838,9 @@ int iav_ioc_s_stream_fps_sync(struct ambarella_iav *iav, void __user *arg)
 			stream = &iav->stream[i];
 			update_flags = REALTIME_PARAM_CUSTOM_FRAME_RATE_BIT |
 				REALTIME_PARAM_CUSTOM_VIN_FPS_BIT;
-			if (stream->format.type == IAV_STREAM_TYPE_H264)
+			if (stream->format.type == IAV_STREAM_TYPE_H264) {
 				update_flags |= REALTIME_PARAM_CBR_MODIFY_BIT;
+			}
 			if (cmd_update_encode_params(stream, NULL, update_flags) < 0) {
 				mutex_unlock(&iav->iav_mutex);
 				return -EIO;
@@ -2449,8 +2882,8 @@ int iav_ioc_s_h264_cfg(struct ambarella_iav *iav, void __user *args)
 	updated.cpb_cmp_idc = h264.cpb_cmp_idc;
 	updated.fast_rc_idc = h264.fast_rc_idc;
 	updated.zmv_threshold = h264.mv_threshold;
-	updated.enc_improve = h264.enc_improve;
-	updated.long_term_intvl = h264.long_term_intvl;
+	updated.flat_area_improve = h264.flat_area_improve;
+	updated.fast_seek_intvl = h264.fast_seek_intvl;
 	updated.multi_ref_p = h264.multi_ref_p;
 	updated.intrabias_p = h264.intrabias_p;
 	updated.intrabias_b = h264.intrabias_b;
@@ -2460,6 +2893,13 @@ int iav_ioc_s_h264_cfg(struct ambarella_iav *iav, void __user *args)
 	updated.user2_direct_bias = h264.user2_direct_bias;
 	updated.user3_intra_bias = h264.user3_intra_bias;
 	updated.user3_direct_bias = h264.user3_direct_bias;
+	updated.deblocking_filter_alpha = h264.deblocking_filter_alpha;
+	updated.deblocking_filter_beta = h264.deblocking_filter_beta;
+	updated.deblocking_filter_enable = h264.deblocking_filter_enable;
+	updated.frame_crop_left_offset = h264.frame_crop_left_offset;
+	updated.frame_crop_right_offset = h264.frame_crop_right_offset;
+	updated.frame_crop_top_offset = h264.frame_crop_top_offset;
+	updated.frame_crop_bottom_offset = h264.frame_crop_bottom_offset;
 
 	if (iav_check_h264_config(iav, h264.id, &updated) < 0) {
 		mutex_unlock(&iav->iav_mutex);
@@ -2503,8 +2943,8 @@ int iav_ioc_g_h264_cfg(struct ambarella_iav *iav, void __user *args)
 	h264.fast_rc_idc = stream->h264_config.fast_rc_idc;
 	h264.cpb_user_size = stream->h264_config.cpb_user_size;
 	h264.mv_threshold = stream->h264_config.zmv_threshold;
-	h264.enc_improve = stream->h264_config.enc_improve;
-	h264.long_term_intvl = stream->h264_config.long_term_intvl;
+	h264.flat_area_improve = stream->h264_config.flat_area_improve;
+	h264.fast_seek_intvl = stream->h264_config.fast_seek_intvl;
 	h264.multi_ref_p = stream->h264_config.multi_ref_p;
 	h264.intrabias_p = stream->h264_config.intrabias_p;
 	h264.intrabias_b = stream->h264_config.intrabias_b;
@@ -2514,6 +2954,13 @@ int iav_ioc_g_h264_cfg(struct ambarella_iav *iav, void __user *args)
 	h264.user2_direct_bias = stream->h264_config.user2_direct_bias;
 	h264.user3_intra_bias = stream->h264_config.user3_intra_bias;
 	h264.user3_direct_bias = stream->h264_config.user3_direct_bias;
+	h264.deblocking_filter_alpha = stream->h264_config.deblocking_filter_alpha;
+	h264.deblocking_filter_beta = stream->h264_config.deblocking_filter_beta;
+	h264.deblocking_filter_enable = stream->h264_config.deblocking_filter_enable;
+	h264.frame_crop_left_offset = stream->h264_config.frame_crop_left_offset;
+	h264.frame_crop_right_offset = stream->h264_config.frame_crop_right_offset;
+	h264.frame_crop_top_offset = stream->h264_config.frame_crop_top_offset;
+	h264.frame_crop_bottom_offset = stream->h264_config.frame_crop_bottom_offset;
 
 	get_pic_info_h264(iav, h264.id, &h264);
 
@@ -2645,12 +3092,18 @@ int iav_ioc_cfg_frame_sync(struct ambarella_iav * iav, void __user * arg)
 		break;
 	case IAV_H264_CFG_FRAME_DROP:
 		rval = iav_set_h264_frame_drop(iav,cfg.id,
-			cfg.arg.h264_drop_frames, 1);
+			&cfg.arg.h264_frame_drop, 1);
 		break;
 	case IAV_H264_CFG_ENC_PARAM:
 		rval = iav_set_h264_enc_param(iav,cfg.id,
 			&cfg.arg.h264_enc, 1);
 		break;
+	case IAV_H264_CFG_LONG_REF_P:
+		rval = iav_set_h264_long_ref_p(iav, cfg.id, 1);
+		break;
+	case IAV_H264_CFG_FORCE_PSKIP:
+		rval = iav_set_h264_force_pskip(iav, cfg.id, &cfg.arg.h264_pskip, 1);
+		break;
 	default:
 		iav_error("Unsupported frame sync cfg ID: %d!\n", cfg.cid);
 		rval = -EINVAL;
@@ -2709,10 +3162,15 @@ int iav_ioc_get_frame_sync(struct ambarella_iav * iav, void __user * arg)
 		h264_rc->qp_max_on_P = h264_cfg->qp_max_on_P;
 		h264_rc->qp_min_on_B = h264_cfg->qp_min_on_B;
 		h264_rc->qp_max_on_B = h264_cfg->qp_max_on_B;
+		h264_rc->qp_min_on_Q = h264_cfg->qp_min_on_Q;
+		h264_rc->qp_max_on_Q = h264_cfg->qp_max_on_Q;
 		h264_rc->i_qp_reduce = h264_cfg->i_qp_reduce;
 		h264_rc->p_qp_reduce = h264_cfg->p_qp_reduce;
+		h264_rc->q_qp_reduce = h264_cfg->q_qp_reduce;
+		h264_rc->log_q_num_plus_1 = h264_cfg->log_q_num_plus_1;
 		h264_rc->adapt_qp = h264_cfg->adapt_qp;
 		h264_rc->skip_flag = h264_cfg->skip_flag;
+		h264_rc->max_i_size_KB = h264_cfg->max_I_size_KB;
 		break;
 	case IAV_H264_CFG_ENC_PARAM:
 		h264_enc = &cfg.arg.h264_enc;
@@ -2744,25 +3202,63 @@ int iav_ioc_get_frame_sync(struct ambarella_iav * iav, void __user * arg)
 	return 0;
 }
 
+static int iav_check_apply_frame_sync(struct ambarella_iav * iav,
+	struct iav_apply_frame_sync *apply, u32* stream_map)
+{
+	struct iav_cmd_sync *cmd_sync;
+	ipcam_real_time_encode_param_setup_t *cmd_data;
+	u8 *addr = NULL;
+	int i;
+
+	cmd_sync = &iav->cmd_sync;
+	for (i = 0; i < IAV_MAX_ENCODE_STREAMS_NUM; ++i) {
+		addr = (u8 *)iav->mmap[IAV_BUFFER_CMD_SYNC].virt +
+			cmd_sync->idx * CMD_SYNC_SIZE + i * DSP_ENC_CMD_SIZE;
+		cmd_data = (ipcam_real_time_encode_param_setup_t *)addr;
+		if (cmd_data->cmd_code) {
+			// For each stream, remove frame sync commands with the same PTS
+			if (cmd_sync->apply_pts[i] != apply->dsp_pts) {
+				*stream_map |= (1 << i);
+				cmd_sync->apply_pts[i] = apply->dsp_pts;
+			} else {
+				iav_debug("Remove frame sync apply flag for stream %c, "
+					"PTS: %u!\n", 'A' + i, apply->dsp_pts);
+			}
+		}
+	}
+
+	if (*stream_map == 0)
+		return -1;
+
+	return 0;
+}
+
 int iav_ioc_apply_frame_sync(struct ambarella_iav * iav, void __user * arg)
 {
 	struct iav_apply_frame_sync apply;
+	struct iav_cmd_sync *cmd_sync;
+	u32 stream_map = 0;
 	u8 *addr = NULL;
 
 	if (copy_from_user(&apply, arg, sizeof(apply)))
 		return -EFAULT;
 
-	cmd_apply_frame_sync_cmd(iav, NULL, &apply);
-	// update for next frame sync cmd
-	iav->cmd_sync_idx = (iav->cmd_sync_idx + 1) % ENC_CMD_TOGGLED_NUM;
-	addr = (u8 *)iav->mmap[IAV_BUFFER_CMD_SYNC].virt +
-		iav->cmd_sync_idx * CMD_SYNC_SIZE;
-	memset(addr, 0, CMD_SYNC_SIZE);
-	if (iav->cmd_sync_qpm_flag) {
-		iav->cmd_sync_qpm_idx =
-			(iav->cmd_sync_qpm_idx % ENC_CMD_TOGGLED_NUM) + 1;
+	/* Check whether send apply cmd to dsp or not.
+	 * If check failed, apply previous frame sync params to next apply cmd.
+	 */
+	if (iav_check_apply_frame_sync(iav, &apply, &stream_map) == 0) {
+		cmd_sync = &iav->cmd_sync;
+		cmd_apply_frame_sync_cmd(iav, NULL, &apply, stream_map);
+		// update for next frame sync cmd
+		cmd_sync->idx = (cmd_sync->idx + 1) % ENC_CMD_TOGGLED_NUM;
+		addr = (u8 *)iav->mmap[IAV_BUFFER_CMD_SYNC].virt +
+			cmd_sync->idx * CMD_SYNC_SIZE;
+		memset(addr, 0, CMD_SYNC_SIZE);
+		if (cmd_sync->qpm_flag) {
+			cmd_sync->qpm_idx = (cmd_sync->qpm_idx % QP_MATRIX_TOGGLED_NUM) + 1;
+		}
+		cmd_sync->qpm_flag = 0;
 	}
-	iav->cmd_sync_qpm_flag = 0;
 
 	return 0;
 }
@@ -2804,6 +3300,7 @@ void iav_init_streams(struct ambarella_iav *iav)
 	struct iav_h264_config *h264_config;
 	struct iav_mjpeg_config *mjpeg_config;
 	struct iav_stream_format *format;
+	struct iav_cmd_sync *cmd_sync;
 	struct iav_window max_enc_win[] = {
 		{1920, 1080}, {1280, 720}, {720, 576}, {352, 288},
 		{352, 240}, {352, 240}, {352, 240}, {352, 240},
@@ -2815,7 +3312,7 @@ void iav_init_streams(struct ambarella_iav *iav)
 	for (i = 0; i < IAV_MAX_ENCODE_STREAMS_NUM; i++) {
 		stream = &iav->stream[i];
 		stream->iav = iav;
-		//stream->id_dsp = STRM_TP_ENC_0 + i;
+		stream->id_dsp = i;
 		stream->session_id = 0;
 		stream->fake_dsp_state = ENC_IDLE_STATE;
 		stream->dsp_state = ENC_IDLE_STATE;
@@ -2881,23 +3378,31 @@ void iav_init_streams(struct ambarella_iav *iav)
 			h264_config->average_bitrate = 4000000;
 		else
 			h264_config->average_bitrate = 2000000;
-		h264_config->qp_min_on_I = 1;
+		h264_config->qp_min_on_I = 14;
 		h264_config->qp_max_on_I = 51;
-		h264_config->qp_min_on_P = 1;
+		h264_config->qp_min_on_P = 17;
 		h264_config->qp_max_on_P = 51;
-		h264_config->qp_min_on_B = 1;
+		h264_config->qp_min_on_Q = 15;
+		h264_config->qp_max_on_Q = 51;
+		h264_config->qp_min_on_B = 21;
 		h264_config->qp_max_on_B = 51;
 		h264_config->adapt_qp = 2;
 		h264_config->i_qp_reduce = 6;
 		h264_config->p_qp_reduce = 3;
+		h264_config->q_qp_reduce = 6;
+		h264_config->log_q_num_plus_1 = 0;
 		h264_config->skip_flag = 0;
+		h264_config->max_I_size_KB = 0;
 		h264_config->chroma_format = H264_CHROMA_YUV420;
 		h264_config->au_type = 1;
 		h264_config->qp_roi_enable = 0;
 		h264_config->zmv_threshold = 0;
-		h264_config->enc_improve = 0;
+		h264_config->flat_area_improve = 0;
 		h264_config->multi_ref_p = 0;
-		h264_config->long_term_intvl = 0;
+		h264_config->fast_seek_intvl = 0;
+		h264_config->drop_frames = 0;
+		h264_config->drop_frame_repeat = 0;
+		h264_config->statis = 0;
 		h264_config->intrabias_p = MIN_INTRABIAS;
 		h264_config->intrabias_b = MIN_INTRABIAS;
 		h264_config->user1_intra_bias = MIN_USER_BIAS;
@@ -2906,6 +3411,9 @@ void iav_init_streams(struct ambarella_iav *iav)
 		h264_config->user2_direct_bias = MIN_USER_BIAS;
 		h264_config->user3_intra_bias = MIN_USER_BIAS;
 		h264_config->user3_direct_bias = MIN_USER_BIAS;
+		h264_config->deblocking_filter_enable = 1;
+		h264_config->deblocking_filter_alpha = 0;
+		h264_config->deblocking_filter_beta = 0;
 		memcpy(h264_config->qp_delta[0], qp_delta, sizeof(qp_delta));
 
 		mjpeg_config = &stream->mjpeg_config;
@@ -2918,15 +3426,22 @@ void iav_init_streams(struct ambarella_iav *iav)
 	}
 
 	// clear cmd sync area to 0
+	cmd_sync = &iav->cmd_sync;
 	memset((u8*)iav->mmap[IAV_BUFFER_CMD_SYNC].virt, 0,
 		iav->mmap[IAV_BUFFER_CMD_SYNC].size);
-	iav->cmd_sync_idx = 0;
+	cmd_sync->idx = 0;
 	// qp matrix idx 0 is reserved for app
-	iav->cmd_sync_qpm_idx = 1;
-	iav->cmd_sync_qpm_flag = 0;
+	cmd_sync->qpm_idx = 1;
+	cmd_sync->qpm_flag = 0;
 	// clear qp matrix area to 0
 	memset((u8*)iav->mmap[IAV_BUFFER_QPMATRIX].virt, 0,
 		iav->mmap[IAV_BUFFER_QPMATRIX].size);
+	for (i = 0; i < IAV_MAX_ENCODE_STREAMS_NUM; i++) {
+		cmd_sync->apply_pts[i] = INVALID_DSP_PTS_32;
+	}
+	// clear mv area to 0
+	memset((u8*)iav->mmap[IAV_BUFFER_MV].virt, 0,
+		iav->mmap[IAV_BUFFER_MV].size);
 
 	iav->stream_num = 0;
 	// init hw pts
diff --git a/drivers/iav/arch_s2l/iav_enc_test.c b/drivers/iav/arch_s2l/iav_enc_test.c
index 5e09ee4..fbdbb57 100644
--- a/drivers/iav/arch_s2l/iav_enc_test.c
+++ b/drivers/iav/arch_s2l/iav_enc_test.c
@@ -4,15 +4,34 @@
  * History:
  *	2014/06/28 - [Jian Tang] created file
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #include <config.h>
 #include <linux/random.h>
 #include <linux/slab.h>
diff --git a/drivers/iav/arch_s2l/iav_enc_utils.c b/drivers/iav/arch_s2l/iav_enc_utils.c
index 8587234..150c6e6 100644
--- a/drivers/iav/arch_s2l/iav_enc_utils.c
+++ b/drivers/iav/arch_s2l/iav_enc_utils.c
@@ -4,14 +4,33 @@
  * History:
  *  Mar 4, 2014 - [qianshen] created file
  *
- * Copyright (C) 2012-2016, Ambarella ShangHai Co,Ltd
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella
+ * Copyright (c) 2015 Ambarella, Inc.
  *
- ******************************************************************************/
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include <config.h>
 #include <linux/random.h>
 #include <linux/slab.h>
@@ -93,21 +112,6 @@ inline u32 get_pm_domain(struct ambarella_iav *iav)
 	return domain;
 }
 
-inline int get_pm_vin_win(struct ambarella_iav *iav, struct iav_rect **vin)
-{
-	if (iav->system_config[iav->encode_mode].expo_num >= MAX_HDR_2X) {
-		if (!iav->vinc[0]->vin_format.max_act_win.width ||
-			!iav->vinc[0]->vin_format.max_act_win.height) {
-			iav_error("Sensor should export max_act_win in HDR mode!\n");
-			return -1;
-		}
-		*vin = (struct iav_rect *)&iav->vinc[0]->vin_format.max_act_win;
-		return 0;
-	} else {
-		return get_vin_win(iav, vin, 0);
-	}
-}
-
 int get_iso_type(struct ambarella_iav *iav, u32 debug_enable_map)
 {
 	u32 chip_id;
@@ -125,6 +129,7 @@ int get_iso_type(struct ambarella_iav *iav, u32 debug_enable_map)
 			case IAV_CHIP_ID_S2L_55M:
 			case IAV_CHIP_ID_S2L_99M:
 			case IAV_CHIP_ID_S2L_TEST:
+			case IAV_CHIP_ID_S2L_33MEX:
 				/* Run Middle ISO for S2LM */
 				iso_type = ISO_TYPE_MIDDLE;
 				break;
@@ -132,6 +137,8 @@ int get_iso_type(struct ambarella_iav *iav, u32 debug_enable_map)
 			case IAV_CHIP_ID_S2L_66:
 			case IAV_CHIP_ID_S2L_88:
 			case IAV_CHIP_ID_S2L_99:
+			case IAV_CHIP_ID_S2L_22:
+			case IAV_CHIP_ID_S2L_33EX:
 				/* Run Advanced ISO for S2L */
 				iso_type = ISO_TYPE_ADVANCED;
 				break;
@@ -217,6 +224,19 @@ inline int get_vout_win(u32 buf_id, struct iav_window *vout)
 	return 0;
 }
 
+inline int get_stream_win_MB(struct iav_stream_format *stream_format, struct iav_window *win)
+{
+	if (stream_format->rotate_cw == 0) {
+		win->width = ALIGN(stream_format->enc_win.width, PIXEL_IN_MB) / PIXEL_IN_MB;
+		win->height = ALIGN(stream_format->enc_win.height, PIXEL_IN_MB) / PIXEL_IN_MB;
+	} else {
+		win->width = ALIGN(stream_format->enc_win.height, PIXEL_IN_MB) / PIXEL_IN_MB;
+		win->height = ALIGN(stream_format->enc_win.width, PIXEL_IN_MB) / PIXEL_IN_MB;
+	}
+
+	return 0;
+}
+
 /* Need to add "mutex_lock / mutex_unlock" in the upper layer before
  * calling this function. */
 inline int wait_vcap_count(struct ambarella_iav *iav, u32 count)
@@ -283,3 +303,26 @@ int iav_mem_copy(struct ambarella_iav *iav, u32 buff_id,
 	return rval;
 }
 
+u32 get_dsp_encode_bitrate(struct iav_stream *stream)
+{
+	u32 ff_multi = stream->fps.fps_multi;
+	u32 ff_division = stream->fps.fps_div;
+	u32 full_bitrate = stream->h264_config.average_bitrate;
+	u32 bitrate = 0;
+
+	if (ff_division) {
+		bitrate =  (stream->h264_config.abs_br_flag ?
+			full_bitrate : (full_bitrate * ff_multi / ff_division));
+	}
+
+	return bitrate;
+}
+
+void create_session_id(struct iav_stream *stream)
+{
+	u32 random_data;
+
+	get_random_bytes(&random_data, sizeof(random_data));
+	stream->session_id = random_data;
+}
+
diff --git a/drivers/iav/arch_s2l/iav_enc_utils.h b/drivers/iav/arch_s2l/iav_enc_utils.h
index 801f842..b332e32 100644
--- a/drivers/iav/arch_s2l/iav_enc_utils.h
+++ b/drivers/iav/arch_s2l/iav_enc_utils.h
@@ -4,15 +4,34 @@
  * History:
  *	2011/11/11 - [Jian Tang] created file
  *
- * Copyright (C) 2007-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #ifndef __IAV_ENCODE_H__
 #define __IAV_ENCODE_H__
 
@@ -35,8 +54,8 @@ int dma_pitch_memcpy(struct iav_gdma_param *params);
 
 
 /* iav_enc_buf.c */
-void inc_srcbuf_ref(struct iav_buffer *srcbuf);
-void dec_srcbuf_ref(struct iav_buffer *srcbuf);
+void inc_srcbuf_ref(struct iav_buffer *srcbuf, u32 stream_id);
+void dec_srcbuf_ref(struct iav_buffer *srcbuf, u32 stream_id);
 
 /* iav_enc_test.c */
 int is_iav_no_check(void);
@@ -55,15 +74,17 @@ int get_hdr_type(struct ambarella_iav *iav);
 int get_iso_type(struct ambarella_iav *iav, u32 debug_enable_map);
 u32 get_pm_unit(struct ambarella_iav *iav);
 u32 get_pm_domain(struct ambarella_iav *iav);
-int get_pm_vin_win(struct ambarella_iav *iav, struct iav_rect **vin);
 u32 get_chip_id(struct ambarella_iav *iav);
 int get_gcd(int a, int b);
 u64 get_monotonic_pts(void);
 int get_vin_win(struct ambarella_iav *iav, struct iav_rect **vin, u8 vin_win_flag);
 int get_vout_win(u32 buf_id, struct iav_window *vout);
+int get_stream_win_MB(struct iav_stream_format *stream_format, struct iav_window *win);
 int wait_vcap_count(struct ambarella_iav *iav, u32 count);
 int iav_mem_copy(struct ambarella_iav *iav, u32 buff_id, u32 src_offset,
 	u32 dst_offset, u32 size, u32 pitch);
+u32 get_dsp_encode_bitrate(struct iav_stream *stream);
+void create_session_id(struct iav_stream *stream);
 
 /* iav_enc_warp.c */
 int cfg_default_multi_warp(struct ambarella_iav *iav);
diff --git a/drivers/iav/arch_s2l/iav_enc_warp.c b/drivers/iav/arch_s2l/iav_enc_warp.c
index b8852cc..0ae0e78 100644
--- a/drivers/iav/arch_s2l/iav_enc_warp.c
+++ b/drivers/iav/arch_s2l/iav_enc_warp.c
@@ -3,14 +3,33 @@
  *
  * History:
  *	2012/04/13 - [Jian Tang] created file
- * Copyright (C) 2007-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <config.h>
 #include <linux/random.h>
 #include <linux/slab.h>
@@ -106,7 +125,37 @@ static int check_warp_main_state(struct ambarella_iav *iav)
 static int check_lens_warp_param(struct ambarella_iav *iav,
 	struct iav_warp_area *lens_warp)
 {
-	return 0;
+	struct iav_rect *vin;
+	int rval = 0;
+	get_vin_win(iav, &vin, 0);
+
+	if ((lens_warp->input.x + lens_warp->input.width > vin->width) ||
+		(lens_warp->input.y + lens_warp->input.height > vin->height)) {
+		iav_error("Input window exceeds VIN!\n");
+		rval = -1;
+	}
+	if ((lens_warp->input.x & 0x01) || (lens_warp->input.y & 0x03)) {
+		iav_error("LDC input x/y [%d/%d] must be "
+			"multiple of 2 and 4 for each.\n", lens_warp->input.x, lens_warp->input.y);
+		return -1;
+	}
+	if ((lens_warp->output.x & 0x01) || (lens_warp->output.y & 0x03)) {
+		iav_error("LDC output x/y [%d/%d] must be "
+			"multiple of 2 and 4 for each.\n", lens_warp->output.x, lens_warp->output.y);
+		return -1;
+	}
+	if ((lens_warp->input.width & 0x0F) || (lens_warp->input.height & 0x07)) {
+		iav_error("LDC input w/h [%d/%d] must be "
+			"multiple of 16 and 8 for each.\n", lens_warp->input.width, lens_warp->input.height);
+		return -1;
+	}
+	if ((lens_warp->output.width & 0x07) || (lens_warp->output.height & 0x07)) {
+		iav_error("LDC output w/h [%d/%d] must be "
+			"multiple of 8.\n", lens_warp->output.width, lens_warp->output.height);
+		return -1;
+	}
+
+	return rval;
 }
 
 static int cfg_lens_warp_param(struct ambarella_iav *iav,
@@ -739,6 +788,10 @@ int iav_ioc_g_warp_ctrl(struct ambarella_iav* iav, void __user *arg)
 
 	mutex_unlock(&iav->iav_mutex);
 
+	if (!rval) {
+		rval = copy_to_user(arg, &warp_ctrl, sizeof(warp_ctrl));
+	}
+
 	return rval;
 }
 
@@ -785,6 +838,7 @@ int iav_ioc_a_warp_ctrl(struct ambarella_iav* iav, void __user *arg)
 	u32 user_warp_virt, dsp_warp_virt;
 	u32 user_warp_phys, dsp_warp_phys;
 	struct iav_gdma_param gparam;
+	struct iav_rect *vin;
 
 	if (copy_from_user(&flags, arg, sizeof(flags)))
 		return -EFAULT;
@@ -831,8 +885,8 @@ int iav_ioc_a_warp_ctrl(struct ambarella_iav* iav, void __user *arg)
 				update_warp_aspect_ratio(IAV_SRCBUF_MN, 0,
 					&iav->warp->area[0].input, &iav->warp->area[0].output);
 			} else {
-				update_warp_aspect_ratio(IAV_SRCBUF_MN, 0,
-					&iav->vinc[0]->vin_format.vin_win,
+				get_vin_win(iav, &vin, 0);
+				update_warp_aspect_ratio(IAV_SRCBUF_MN, 0, vin,
 					(struct iav_rect *)&iav->srcbuf[IAV_SRCBUF_MN].win);
 			}
 
diff --git a/drivers/iav/arch_s2l/iav_netlink.c b/drivers/iav/arch_s2l/iav_netlink.c
index daa1303..1b05313 100644
--- a/drivers/iav/arch_s2l/iav_netlink.c
+++ b/drivers/iav/arch_s2l/iav_netlink.c
@@ -3,14 +3,34 @@
  *
  * History:
  *	2014/07/25 - [Zhaoyang Chen] created file
- * Copyright (C) 2007-2016, Ambarella, Inc.
+ *	2017/02/21 - [Jian Tang] Add "notice" MSG type.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <config.h>
 #include <linux/random.h>
 #include <linux/slab.h>
@@ -30,38 +50,73 @@
 #include "iav_enc_api.h"
 #include "iav_enc_utils.h"
 
+struct iav_nl_instance {
+	u32 port;
+	u16 req_first;
+	u16 req_last;
+	struct iav_nl_obj *obj;
+};
+
+static struct iav_nl_instance g_nl_inst[NL_OBJ_MAX_NUM] = {
+	[NL_OBJ_IMAGE] = {
+		.port = NL_PORT_IMAGE,
+		.req_first = NL_REQ_IMG_FIRST,
+		.req_last = NL_REQ_IMG_LAST,
+	},
+	[NL_OBJ_VSYNC] = {
+		.port = NL_PORT_VSYNC,
+		.req_first = NL_REQ_VSYNC_FIRST,
+		.req_last = NL_REQ_VSYNC_LAST,
+	},
+	[NL_OBJ_SYS] = {
+		.port = NL_PORT_SYS,
+		.req_first = NL_NOTICE_SYS_FIRST,
+		.req_last = NL_NOTICE_SYS_LAST,
+	},
+};
+
 static struct ambarella_iav *g_iav = NULL;
 
-/* Need to add "mutex_lock / mutex_unlock" in the upper layer before
- * calling this function and its upper function. */
-static int nl_send_msg(struct iav_nl_obj *nl_obj, struct nl_msg_data *msg)
+static int do_nl_msg_check(struct nl_msg_data *msg, u32 nl_user_pid)
 {
-#define RETRY_TIMES			(5)
-#define TIMEOUT_JIFFY		msecs_to_jiffies(1000)
-	struct sk_buff *skb = NULL;
-	struct nlmsghdr *nlhdr = NULL;
-	struct ambarella_iav *iav = nl_obj->iav;
-	struct iav_nl_request *nl_req = NULL;
-	void *data;
-	int retry = RETRY_TIMES;
-	int rval = 0;
-
-	if (msg->type == NL_MSG_TYPE_SESSION) {
+	switch (msg->type) {
+	case NL_MSG_TYPE_SESSION:
 		if (msg->dir != NL_MSG_DIR_STATUS) {
-			iav_error("NETLINK ERR: IAV can only send session status to app!\n");
+			iav_error("NETLINK ERR: IAV can only send session status to "
+				"app %d!\n", nl_user_pid);
 			return -1;
 		}
-	} else if (msg->type == NL_MSG_TYPE_REQUEST) {
+		break;
+	case NL_MSG_TYPE_REQUEST:
 		if (msg->dir != NL_MSG_DIR_CMD) {
-			iav_error("NETLINK ERR: IAV can only send request cmd to app!\n");
+			iav_error("NETLINK ERR: IAV can only send request cmd to "
+				"app %d!\n", nl_user_pid);
 			return -1;
 		}
-	} else {
-		iav_error("NETLINK ERR: Unrecognized IAV msg type to app!\n");
+		break;
+	case NL_MSG_TYPE_NOTICE:
+		if (msg->dir != NL_MSG_DIR_STATUS) {
+			iav_error("NETLINK ERR: IAV can only send notice status to "
+				"app %d!\n", nl_user_pid);
+			return -1;
+		}
+		break;
+	default:
+		iav_error("NETLINK ERR: Unrecognized IAV msg type %d to "
+			"app %d!\n", msg->type, nl_user_pid);
 		return -1;
+		break;
 	}
+	return 0;
+}
+
+static int do_nl_msg_unicast(struct iav_nl_obj *nl_obj, struct nl_msg_data *msg)
+{
+	void *data;
+	struct sk_buff *skb = NULL;
+	struct nlmsghdr *nlhdr = NULL;
 
-	skb = nlmsg_new(sizeof(*msg), GFP_KERNEL);
+	skb = nlmsg_new(sizeof(struct nl_msg_data), GFP_KERNEL);
 	if (!skb) {
 		iav_error("NETLINK ERR: Function nlmsg_new failed!\n");
 		return -1;
@@ -74,54 +129,98 @@ static int nl_send_msg(struct iav_nl_obj *nl_obj, struct nl_msg_data *msg)
 
 	netlink_unicast(nl_obj->nl_sock, skb, nl_obj->nl_user_pid, 0);
 
-	if (msg->type == NL_MSG_TYPE_REQUEST) {
+	return 0;
+}
+
+static int do_nl_msg_response(struct iav_nl_obj *nl_obj, struct nl_msg_data *msg)
+{
+#define RETRY_TIMES			(10)
+#define TIMEOUT_JIFFY		msecs_to_jiffies(1000)
+
+	struct ambarella_iav *iav = nl_obj->iav;
+	struct iav_nl_request *nl_req = NULL;
+	int retry = RETRY_TIMES;
+	int rval = 0;
+
+	switch (msg->type) {
+	case NL_MSG_TYPE_SESSION:
+		iav_debug("NETLINK DBG: Send session status %u to session cmd %u of "
+			"app %d.\n", msg->status, msg->cmd, nl_obj->nl_user_pid);
+		break;
+	case NL_MSG_TYPE_REQUEST:
 		nl_req = &nl_obj->nl_requests[msg->cmd];
 
 		mutex_unlock(&iav->iav_mutex);
-		iav_debug("NETLINK DBG: Send request cmd %d to app %d.\n",
+		iav_debug("NETLINK DBG: Send request cmd %u to app %d.\n",
 			msg->cmd, nl_obj->nl_user_pid);
 		// wait for the response of the command
 		while (retry > 0) {
 			rval = wait_event_interruptible_timeout(nl_req->wq_request,
-				nl_req->condition, TIMEOUT_JIFFY) ;
+				nl_req->responded, TIMEOUT_JIFFY) ;
 			if (rval > 0) {
 				break;
 			}
-			iav_debug("NETLINK DBG: receive ACK of request cmd %d from app %d error,"
-				" retry:%d\n", msg->cmd, nl_obj->nl_user_pid, retry);
+			iav_debug("NETLINK DBG: receive ACK of request cmd %u from app %d "
+				"error, retry:%d\n", msg->cmd, nl_obj->nl_user_pid, retry);
 			--retry;
 		}
 		mutex_lock(&iav->iav_mutex);
 
 		if (retry <= 0) {
-			iav_error("NETLINK ERR: send request cmd %d to app %d timeout\n",
+			iav_error("NETLINK ERR: send request cmd %u to app %d timeout\n",
 				msg->cmd, nl_obj->nl_user_pid);
 			return -1;
 		}
-	} else if (msg->type == NL_MSG_TYPE_SESSION) {
-		iav_debug("NETLINK DBG: Send session status %d to session cmd %d"
-			" of app %d.\n", msg->status, msg->cmd, nl_obj->nl_user_pid);
+		break;
+	case NL_MSG_TYPE_NOTICE:
+		iav_debug("NETLINK DBG: Send notice status %u to app %d.\n",
+			msg->status, nl_obj->nl_user_pid);
+		break;
+	default:
+		iav_error("NETLINK ERR: Unrecognized IAV MSG type %d to "
+			"app %d!\n", msg->type, nl_obj->nl_user_pid);
+		return -1;
+		break;
 	}
 
 	return 0;
 }
 
-int nl_send_request(struct iav_nl_obj *nl_obj, int cmd)
+/* Need to add "mutex_lock / mutex_unlock" in the upper layer before
+ * calling this function and its upper function. */
+static int nl_send_msg(struct iav_nl_obj *nl_obj, struct nl_msg_data *msg)
 {
-	int ret = 0;
-	struct nl_msg_data msg;
+	if (do_nl_msg_check(msg, nl_obj->nl_user_pid) < 0) {
+		iav_error("NETLINK ERR: Invalid MSG type and dir!\n");
+		return -1;
+	}
 
-	msg.port = nl_obj->nl_port;
-	msg.pid = 0;
-	msg.dir = NL_MSG_DIR_CMD;
-	msg.type = NL_MSG_TYPE_REQUEST;
-	msg.cmd = cmd;
-	msg.status = 0;
+	if (do_nl_msg_unicast(nl_obj, msg) < 0) {
+		iav_error("NETLINK ERR: Unicast MSG fail!\n");
+		return -1;
+	}
 
-	nl_obj->nl_requests[cmd].condition = 0;
-	ret = nl_send_msg(nl_obj, &msg);
+	if (do_nl_msg_response(nl_obj, msg) < 0) {
+		iav_error("NETLINK ERR: Process MSG response fail!\n");
+		return -1;
+	}
 
-	return ret;
+	return 0;
+}
+
+static struct iav_nl_obj *find_nl_obj(int port)
+{
+	struct iav_nl_obj *nl_obj;
+	int i;
+
+	for(i = 0; i < NL_OBJ_MAX_NUM; ++i) {
+		nl_obj = &g_iav->nl_obj[i];
+		if (nl_obj->nl_init && nl_obj->nl_port == port) {
+			return nl_obj;
+		}
+	}
+
+	return NULL;
 }
 
 static int nl_process_session_cmd(struct iav_nl_obj *nl_obj,
@@ -158,7 +257,7 @@ static int nl_process_session_cmd(struct iav_nl_obj *nl_obj,
 		nl_obj->nl_user_pid = -1;
 		break;
 	default:
-		iav_debug("Unknown session cmd from app %d!\n", msg->pid);
+		iav_debug("Unknown session cmd from app %u!\n", msg->pid);
 		ret = -1;
 		break;
 	}
@@ -166,21 +265,6 @@ static int nl_process_session_cmd(struct iav_nl_obj *nl_obj,
 	return ret;
 }
 
-static struct iav_nl_obj *find_nl_obj(int port)
-{
-	struct iav_nl_obj *nl_obj;
-	int i;
-
-	for(i = 0; i < NL_OBJ_MAX_NUM; ++i) {
-		nl_obj = &g_iav->nl_obj[i];
-		if (nl_obj->nl_init && nl_obj->nl_port == port) {
-			return nl_obj;
-		}
-	}
-
-	return NULL;
-}
-
 static int nl_process_request_status(struct iav_nl_obj *nl_obj,
 	struct nl_msg_data *msg)
 {
@@ -188,26 +272,26 @@ static int nl_process_request_status(struct iav_nl_obj *nl_obj,
 	int ret = 0;
 
 	if (msg->status == NL_CMD_STATUS_SUCCESS) {
-		iav_debug("NETLINK DBG: Request %d succeeded with netlink.\n",
-			msg->cmd);
+		iav_debug("NETLINK DBG: Request %u succeeded from app %u.\n",
+			msg->cmd, msg->pid);
 	} else if (msg->status == NL_CMD_STATUS_FAIL) {
-		iav_debug("NETLINK DBG: Request %d failed with netlink!\n",
-			msg->cmd);
+		iav_debug("NETLINK DBG: Request %u failed from app %u!\n",
+			msg->cmd, msg->pid);
 	} else {
-		iav_debug("NETLINK DBG: Incorrect status %d from netlink!\n",
-			msg->status);
+		iav_debug("NETLINK DBG: Incorrect status %u from app %u!\n",
+			msg->status, msg->pid);
 		ret = -1;
 	}
 
 	if (msg->cmd > nl_obj->nl_request_count) {
-		iav_debug("NETLINK DBG: Incorrect request cmd %d from netlink!\n",
-			msg->cmd);
+		iav_debug("NETLINK DBG: Incorrect request cmd %u from app %u!\n",
+			msg->cmd, msg->pid);
 		ret = -1;
 	}
 
 	if (!ret) {
 		nl_req = &nl_obj->nl_requests[msg->cmd];
-		nl_req->condition = 1;
+		nl_req->responded = 1;
 		wake_up_interruptible(&nl_req->wq_request);
 	}
 
@@ -239,7 +323,7 @@ static void nl_recv_msg_handler(struct sk_buff * skb)
 		if (NETLINK_CB(skb).portid == msg.pid) {
 			nl_obj = find_nl_obj(msg.port);
 			if (!nl_obj) {
-				iav_error("NETLINK ERR: Unknown msg, port %d, app %d!\n",
+				iav_error("NETLINK ERR: Unknown msg, port %u, app %u!\n",
 					msg.port, msg.pid);
 				continue;
 			}
@@ -256,22 +340,21 @@ static void nl_recv_msg_handler(struct sk_buff * skb)
 	}
 }
 
-static int init_nl_obj_image(struct ambarella_iav *iav)
+static int init_nl_obj(struct ambarella_iav *iav, struct iav_nl_instance *nl_inst)
 {
-	struct iav_nl_obj *nl_obj = &iav->nl_obj[NL_OBJ_IMAGE];
+	struct iav_nl_obj *nl_obj = nl_inst->obj;
 	struct netlink_kernel_cfg cfg;
-	int ret = 0;
-	int i;
+	int i, ret = 0;
 
 	nl_obj->iav = iav;
 	nl_obj->nl_connected = 0;
 	nl_obj->nl_init = 0;
-	nl_obj->nl_port = NL_PORT_IMAGE;
+	nl_obj->nl_port = nl_inst->port;
 	nl_obj->nl_user_pid = -1;
 	nl_obj->nl_session_count = NL_SESS_CMD_NUM;
-	nl_obj->nl_request_count = NL_REQ_IMG_NUM;
+	nl_obj->nl_request_count = nl_inst->req_last - nl_inst->req_first;
 
-	for (i = NL_REQ_IMG_FIRST; i < NL_REQ_IMG_LAST; ++i) {
+	for (i = nl_inst->req_first; i < nl_inst->req_last; ++i) {
 		nl_obj->nl_requests[i].request_id = i;
 		init_waitqueue_head(&nl_obj->nl_requests[i].wq_request);
 	}
@@ -286,43 +369,130 @@ static int init_nl_obj_image(struct ambarella_iav *iav)
 	return ret;
 }
 
+static int init_nl_obj_image(struct ambarella_iav *iav)
+{
+	int ret = 0;
+	struct iav_nl_instance *nl = &g_nl_inst[NL_OBJ_IMAGE];
+
+	nl->obj = &iav->nl_obj[NL_OBJ_IMAGE];
+	ret = init_nl_obj(iav, nl);
+
+	return ret;
+}
+
 static int init_nl_obj_vsync(struct ambarella_iav *iav)
 {
-	struct iav_nl_obj *nl_obj = &iav->nl_obj[NL_OBJ_VSYNC];
-	struct netlink_kernel_cfg cfg;
 	int ret = 0;
-	int i;
+	struct iav_nl_instance *nl = &g_nl_inst[NL_OBJ_VSYNC];
 
-	nl_obj->iav = iav;
-	nl_obj->nl_connected = 0;
-	nl_obj->nl_init = 0;
-	nl_obj->nl_port = NL_PORT_VSYNC;
-	nl_obj->nl_user_pid = -1;
-	nl_obj->nl_session_count = NL_SESS_CMD_NUM;
-	nl_obj->nl_request_count = NL_REQ_VSYNC_NUM;
+	nl->obj = &iav->nl_obj[NL_OBJ_VSYNC];
+	ret = init_nl_obj(iav, nl);
 
-	for (i = NL_REQ_VSYNC_FIRST; i < NL_REQ_VSYNC_LAST; ++i) {
-		nl_obj->nl_requests[i].request_id = i;
-		init_waitqueue_head(&nl_obj->nl_requests[i].wq_request);
-	}
+	return ret;
+}
 
-	cfg.groups = 0;
-	cfg.input = nl_recv_msg_handler;
-	nl_obj->nl_sock = netlink_kernel_create(&init_net,
-		nl_obj->nl_port, &cfg);
+static int init_nl_obj_sys(struct ambarella_iav *iav)
+{
+	int ret = 0;
+	struct iav_nl_instance *nl = &g_nl_inst[NL_OBJ_SYS];
 
-	nl_obj->nl_init = 1;
+	nl->obj = &iav->nl_obj[NL_OBJ_SYS];
+	ret = init_nl_obj(iav, nl);
 
 	return ret;
 }
 
-int init_netlink(struct ambarella_iav *iav)
+static void deinit_nl_obj(struct iav_nl_obj *nl_obj)
+{
+	if (nl_obj->nl_sock != NULL) {
+		netlink_kernel_release(nl_obj->nl_sock);
+		nl_obj->nl_sock = NULL;
+	}
+
+	return;
+}
+
+static int deinit_nl_obj_image(struct ambarella_iav *iav)
+{
+	deinit_nl_obj(&iav->nl_obj[NL_OBJ_IMAGE]);
+
+	return 0;
+}
+
+static int deinit_nl_obj_vsync(struct ambarella_iav *iav)
+{
+	deinit_nl_obj(&iav->nl_obj[NL_OBJ_VSYNC]);
+
+	return 0;
+}
+
+static int deinit_nl_obj_sys(struct ambarella_iav *iav)
+{
+	deinit_nl_obj(&iav->nl_obj[NL_OBJ_SYS]);
+
+	return 0;
+}
+
+int iav_init_netlink(struct ambarella_iav *iav)
 {
 	g_iav = iav;
 
 	init_nl_obj_image(iav);
 	init_nl_obj_vsync(iav);
+	init_nl_obj_sys(iav);
 
 	return 0;
 }
 
+int iav_deinit_netlink(struct ambarella_iav *iav)
+{
+	deinit_nl_obj_image(iav);
+	deinit_nl_obj_vsync(iav);
+	deinit_nl_obj_sys(iav);
+
+	g_iav = NULL;
+
+	return 0;
+}
+
+int nl_send_request(struct iav_nl_obj *nl_obj, u32 cmd)
+{
+	int ret = 0;
+	struct nl_msg_data msg;
+
+	msg.port = nl_obj->nl_port;
+	msg.pid = 0;
+	msg.dir = NL_MSG_DIR_CMD;
+	msg.type = NL_MSG_TYPE_REQUEST;
+	msg.cmd = cmd;
+	msg.status = 0;
+
+	nl_obj->nl_requests[cmd].responded = 0;
+	ret = nl_send_msg(nl_obj, &msg);
+
+	return ret;
+}
+
+int nl_send_notice(struct iav_nl_obj *nl_obj, u32 status)
+{
+	int ret = 0;
+	struct nl_msg_data msg;
+
+	msg.port = nl_obj->nl_port;
+	msg.pid = 0;
+	msg.dir = NL_MSG_DIR_STATUS;
+	msg.type = NL_MSG_TYPE_NOTICE;
+	msg.cmd = 0;
+	msg.status = status;
+
+	nl_obj->nl_requests[status].responded = 0;
+	ret = nl_send_msg(nl_obj, &msg);
+
+	return ret;
+}
+
+int is_nl_request_responded(struct iav_nl_obj *nl_obj, u32 cmd)
+{
+	return nl_obj->nl_requests[cmd].responded;
+}
+
diff --git a/drivers/iav/arch_s2l/iav_vin.c b/drivers/iav/arch_s2l/iav_vin.c
index e3618f8..39a9b9b 100644
--- a/drivers/iav/arch_s2l/iav_vin.c
+++ b/drivers/iav/arch_s2l/iav_vin.c
@@ -3,15 +3,34 @@
  *
  * Author: Cao Rongrong <rrcao@ambarella.com>
  *
- * Copyright (C) 2012 -2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #include <linux/mutex.h>
 #include <linux/interrupt.h>
 #include <linux/delay.h>
@@ -22,7 +41,7 @@
 #include <linux/seq_file.h>
 #include <linux/kthread.h>
 #include <plat/highres_timer.h>
-#include <plat/service.h>
+#include <plat/iav_helper.h>
 #include <iav_utils.h>
 #include <vin_api.h>
 #include "iav_vin.h"
@@ -132,7 +151,7 @@ static int vin_hw_poweron(struct vin_device *vdev)
 		if (vinc->pwr_gpio[i] >= 0) {
 			gpio_svc.svc_id = AMBSVC_GPIO_OUTPUT;
 			gpio_svc.gpio = vinc->pwr_gpio[i];
-			gpio_svc.value = !vinc->pwr_gpio_active[i];
+			gpio_svc.value = vinc->pwr_gpio_active[i];
 			ambarella_request_service(AMBARELLA_SERVICE_GPIO, &gpio_svc, NULL);
 		}
 	}
@@ -146,15 +165,6 @@ static int vin_hw_poweron(struct vin_device *vdev)
 
 	msleep(5);
 
-	for (i = 0; i < 3; i++) {
-		if (vinc->pwr_gpio[i] >= 0) {
-			gpio_svc.svc_id = AMBSVC_GPIO_OUTPUT;
-			gpio_svc.gpio = vinc->pwr_gpio[i];
-			gpio_svc.value = vinc->pwr_gpio_active[i];
-			ambarella_request_service(AMBARELLA_SERVICE_GPIO, &gpio_svc, NULL);
-		}
-	}
-
 	if (vinc->rst_gpio >= 0) {
 		gpio_svc.svc_id = AMBSVC_GPIO_OUTPUT;
 		gpio_svc.gpio = vinc->rst_gpio;
@@ -197,21 +207,7 @@ static int vin_hw_poweroff(struct vin_device *vdev)
 	return 0;
 }
 
-static int ambarella_vin_set_pll_reg(struct vin_device *vdev, int pll_idx)
-{
-	if (pll_idx >= vdev->num_plls) {
-		vin_error("invalid pll index (%d/%d)\n", vdev->num_plls, pll_idx);
-		return -EINVAL;
-	}
-
-	/* set device specific configuration if necessary */
-	if (vdev->ops->set_pll)
-		return vdev->ops->set_pll(vdev, pll_idx);
-
-	return 0;
-}
-
-static int ambarella_vin_set_clk(struct vin_device *vdev, int pll_idx)
+static int ambarella_vin_set_pll(struct vin_device *vdev, int pll_idx)
 {
 	struct vin_video_pll *pll;
 
@@ -230,12 +226,39 @@ static int ambarella_vin_set_clk(struct vin_device *vdev, int pll_idx)
 	/* wait 5ms for pll stable */
 	msleep(5);
 
-	ambarella_vin_set_pll_reg(vdev, pll_idx);
+	return 0;
+}
+
+static int ambarella_vin_set_pll_reg(struct vin_device *vdev, int pll_idx)
+{
+	if (pll_idx >= vdev->num_plls) {
+		vin_error("invalid pll index (%d/%d)\n", vdev->num_plls, pll_idx);
+		return -EINVAL;
+	}
+
+	/* set device specific configuration if necessary */
+	if (vdev->ops->set_pll)
+		return vdev->ops->set_pll(vdev, pll_idx);
 
 	return 0;
 }
 
-static int ambarella_vin_set_phy(u32 intf_id, u8 interface_type)
+static int ambarella_vin_set_clk(struct vin_device *vdev, int pll_idx)
+{
+	int rval;
+
+	rval = ambarella_vin_set_pll(vdev, pll_idx);
+	if (rval < 0)
+		return rval;
+
+	rval = ambarella_vin_set_pll_reg(vdev, pll_idx);
+	if (rval < 0)
+		return rval;
+
+	return 0;
+}
+
+static int ambarella_vin_set_phy(u32 intf_id, u8 interface_type, u8 mipi_bit_rate)
 {
 	if ((intf_id != VIN_PRIMARY) && (intf_id != VIN_PIP)) {
 		vin_error("unsupport interface id %d\n", intf_id);
@@ -269,8 +292,14 @@ static int ambarella_vin_set_phy(u32 intf_id, u8 interface_type)
 			amba_writel(RCT_REG(0x478), 0x14403);
 			msleep(5);
 			amba_writel(RCT_REG(0x478), 0x14402);
-			amba_writel(RCT_REG(0x47C), 0x12B4B22F);
-			amba_writel(RCT_REG(0x480), 0x201F | (1 << 9)); /* force mipi clk to be HS mode */
+
+			if (mipi_bit_rate == SENSOR_MIPI_BIT_RATE_H) {
+				amba_writel(RCT_REG(0x47C), 0x1FDD964A);
+				amba_writel(RCT_REG(0x480), 0x3C1F | (1 << 9)); /* force mipi clk to be HS mode */
+			} else {
+				amba_writel(RCT_REG(0x47C), 0x1FDD9326);
+				amba_writel(RCT_REG(0x480), 0x3C1F | (1 << 9)); /* force mipi clk to be HS mode */
+			}
 		} else {
 			amba_writel(RCT_REG(0x474), 0x0);
 			amba_writel(RCT_REG(0x478), 0x14409);
@@ -317,10 +346,9 @@ int ambarella_set_vin_config(struct vin_device *vdev, struct vin_device_config *
 {
 	struct ambarella_iav *iav;
 	struct vin_dsp_config *dsp_config;
-	struct vin_master_config *master_config;
 	struct vin_controller *vinc;
 	u8 sync_code_style, data_edge, lane_number;
-	u16 lane_mux[3]={0,0,0};
+	u16 lane_mux[3] = {0, 0, 0};
 	int i, lane_mask = 0;
 
 	/* find the corresponding vin controller */
@@ -358,6 +386,7 @@ int ambarella_set_vin_config(struct vin_device *vdev, struct vin_device_config *
 	vinc->vin_format.max_act_win.width = cfg->hdr_cfg.act_win.max_width;
 	vinc->vin_format.max_act_win.height = cfg->hdr_cfg.act_win.max_height;
 	vinc->vin_format.readout_mode = cfg->readout_mode;
+	vinc->vin_format.sync_mode = cfg->sync_mode;
 	iav->vin_enabled = 1;
 
 	/* update VIN config used by DSP cmd. */
@@ -395,9 +424,6 @@ int ambarella_set_vin_config(struct vin_device *vdev, struct vin_device_config *
 		break;
 	case SENSOR_MIPI:
 		lane_number = cfg->mipi_cfg.lane_number;
-		lane_mux[0] = cfg->mipi_cfg.lane_mux_0;
-		lane_mux[1] = cfg->mipi_cfg.lane_mux_1;
-		lane_mux[2] = cfg->mipi_cfg.lane_mux_2;
 		break;
 	}
 
@@ -527,7 +553,6 @@ int ambarella_set_vin_config(struct vin_device *vdev, struct vin_device_config *
 			dsp_config->r26.eov_pat = 0xAB00;
 			break;
 		case SENSOR_SYNC_STYLE_PANASONIC:
-			/* for mn34220pl 3x */
 			dsp_config->r14.sync_type = 1;
 			dsp_config->r15.sol_en = 1;
 			dsp_config->r15.eol_en = 1;
@@ -556,6 +581,20 @@ int ambarella_set_vin_config(struct vin_device *vdev, struct vin_device_config *
 			dsp_config->r25.sov_pat = 0x2B00;
 			dsp_config->r26.eov_pat = 0x3600;
 			break;
+		case SENSOR_SYNC_STYLE_SONY_DOL2:
+			dsp_config->r14.sync_type = 1;
+			dsp_config->r15.sol_en = 1;
+			dsp_config->r15.eol_en = 1;
+			dsp_config->r15.sov_en = 1;
+			dsp_config->r15.eov_en = 1;
+			dsp_config->r18.sync_detect_mask = 0x8000;
+			dsp_config->r19.sync_detect_pat = 0x8000;
+			dsp_config->r20.sync_compare_mask = 0x3F00;
+			dsp_config->r21.sol_pat = 0x0000;
+			dsp_config->r22.eol_pat = 0x1D00;
+			dsp_config->r25.sov_pat = 0x2B00;
+			dsp_config->r26.eov_pat = 0x3600;
+			break;
 		case SENSOR_SYNC_STYLE_INTERLACE:
 			dsp_config->r14.sync_type = 1;
 			dsp_config->r15.sol_en = 1;
@@ -625,36 +664,66 @@ int ambarella_set_vin_config(struct vin_device *vdev, struct vin_device_config *
 
 	if (cfg->interface_type == SENSOR_MIPI) {
 		dsp_config->r27.mipi_vc_mask = 0x3;
-		dsp_config->r27.mipi_dt_mask = 0x3f;
+		if (cfg->mipi_cfg.data_type == SENSOR_MIPI_DATA_TYPE_RAW) {
+			dsp_config->r27.mipi_dt_mask = 0x2f;
+		} else {
+			dsp_config->r27.mipi_dt_mask = 0x3f;
+		}
 		dsp_config->r28.mipi_ecc_enable = 1;
 	}
 
-	if (cfg->sync_mode == SENSOR_SYNC_MODE_SLAVE){
-		/* update master config */
-		master_config = vinc->master_config;
+	ambarella_vin_set_phy(vdev->intf_id, cfg->interface_type, cfg->mipi_cfg.bit_rate);
+
+	return 0;
+}
+EXPORT_SYMBOL(ambarella_set_vin_config);
 
-		master_config->r0.hsync_period_l = (u16)cfg->slave_cfg.hsync_period ;
-		master_config->r1.hsync_period_h = (u16)(cfg->slave_cfg.hsync_period >> 16);
-		master_config->r2.hsync_width = cfg->slave_cfg.hsync_width;
-		master_config->r3.hsync_offset = 0;
-		master_config->r4.vsync_period = cfg->slave_cfg.vsync_period;
-		master_config->r5.vsync_width = cfg->slave_cfg.vsync_width;
-		master_config->r6.vsync_offset = 0;
-		master_config->r7.hsync_polarity = 0;
-		master_config->r7.vsync_polarity = 0;
-		master_config->r7.no_vb_hsync = 0;
-		master_config->r7.intr_mode = 0;
-		master_config->r7.vsync_width_unit = 0;
-		master_config->r7.num_vsync = 1;
-		master_config->r7.continuous = 1;
-		master_config->r7.preempt = 0;
+int ambarella_set_vin_master_sync(struct vin_device *vdev, struct vin_master_sync *master_cfg, bool by_dbg_bus)
+{
+	struct vin_controller *vinc;
+
+	/* find the corresponding vin controller */
+	vinc = vin_get_controller(vdev);
+	if (!vinc) {
+		vin_error("can not find vin controller!\n");
+		return -ENODEV;
 	}
 
-	ambarella_vin_set_phy(vdev->intf_id, cfg->interface_type);
+	if (!master_cfg)
+		return 0;
+
+	/* update master config */
+	vinc->master_config->r0.hsync_period_l = master_cfg->hsync_period ;
+	vinc->master_config->r1.hsync_period_h = master_cfg->hsync_period >> 16;
+	vinc->master_config->r2.hsync_width = master_cfg->hsync_width;
+	vinc->master_config->r3.hsync_offset = 0;
+	vinc->master_config->r4.vsync_period = master_cfg->vsync_period;
+	vinc->master_config->r5.vsync_width = master_cfg->vsync_width;
+	vinc->master_config->r6.vsync_offset = 0;
+	vinc->master_config->r7.hsync_polarity = 0;
+	vinc->master_config->r7.vsync_polarity = 0;
+	vinc->master_config->r7.no_vb_hsync = 0;
+	vinc->master_config->r7.intr_mode = 0;
+	vinc->master_config->r7.vsync_width_unit = 0;
+	vinc->master_config->r7.num_vsync = 1;
+	vinc->master_config->r7.continuous = 1;
+	vinc->master_config->r7.preempt = 0;
+
+	if (by_dbg_bus) {
+		amba_writel(DBGBUS_BASE + 0x118000, 0x1000);
+		amba_writel(DBGBUS_BASE + 0x110400, vinc->master_config->r0.hsync_period_l);
+		amba_writel(DBGBUS_BASE + 0x110404, vinc->master_config->r1.hsync_period_h);
+		amba_writel(DBGBUS_BASE + 0x110408, vinc->master_config->r2.hsync_width);
+		amba_writel(DBGBUS_BASE + 0x11040C, vinc->master_config->r3.hsync_offset);
+		amba_writel(DBGBUS_BASE + 0x110410, vinc->master_config->r4.vsync_period);
+		amba_writel(DBGBUS_BASE + 0x110414, vinc->master_config->r5.vsync_width);
+		amba_writel(DBGBUS_BASE + 0x110418, vinc->master_config->r6.vsync_offset);
+		amba_writel(DBGBUS_BASE + 0x11041C, 0x2020);
+	}
 
 	return 0;
 }
-EXPORT_SYMBOL(ambarella_set_vin_config);
+EXPORT_SYMBOL(ambarella_set_vin_master_sync);
 
 struct vin_device *ambarella_vin_create_device(const char *name, u32 sensor_id, u32 priv_size)
 {
@@ -741,11 +810,9 @@ int ambarella_vin_register_device(struct vin_device *vdev, struct vin_ops *ops,
 		if (vinc->iav->vin_enabled == 0) {
 			vin_hw_poweron(vdev);
 			if (vdev->ops->init_device) {
-				/* setup default pll needed by device to work */
-				ambarella_vin_set_clk(vdev, 0);
+				/* setup default pll clock source needed by device to work */
+				ambarella_vin_set_pll(vdev, 0);
 				vdev->ops->init_device(vdev);
-				/* set pll registers again, because init_device will do sw reset */
-				ambarella_vin_set_pll_reg(vdev, 0);
 			}
 		} else {
 			/* FIXME: In fastboot case,  IAV in preview mode by amboot/iav already
@@ -754,6 +821,11 @@ int ambarella_vin_register_device(struct vin_device *vdev, struct vin_ops *ops,
 			 *  TODO: For IAV some init param load by "test_encode".
 			 *  Need do this in fastboot case.
 			*/
+			if (!vinc->iav->vin_probe_format) {
+				vin_error("vin_probe_format is NULL\n");
+				return -EINVAL;
+			}
+
 			if (vdev->dev_type == VINDEV_TYPE_SENSOR) {
 				for (i = 0; i < vdev->num_formats; i++) {
 					format = &vdev->formats[i];
@@ -991,7 +1063,11 @@ static int vin_set_shutter_time(struct vin_device *vdev, int shutter)
 	if (rval < 0)
 		return rval;
 
+	if (vdev->ops->set_hold_mode)
+		vdev->ops->set_hold_mode(vdev, 1);
 	rval = vdev->ops->set_shutter_row(vdev, shutter);
+	if (vdev->ops->set_hold_mode)
+		vdev->ops->set_hold_mode(vdev, 0);
 	if (rval < 0)
 		return rval;
 
@@ -1089,7 +1165,9 @@ static int vin_set_frame_rate(struct vin_device *vdev, int frame_rate)
 	vinc->vin_format.frame_rate = frame_rate;
 
 	/* Modify idsp frame rate factor */
-	cmd_update_idsp_factor(iav, NULL);
+	mutex_lock(&iav->iav_mutex);
+	cmd_update_vcap_params(iav, NULL, REALTIME_PARAM_CUSTOM_VIN_FPS_BIT);
+	mutex_unlock(&iav->iav_mutex);
 
 	rval = iav_vin_update_stream_framerate(iav);
 	if (rval < 0)
@@ -1119,11 +1197,6 @@ static int vin_dev_get_frame_rate(struct vin_device *vdev, unsigned long args)
 {
 	struct vindev_fps vsrc_fps;
 
-	if (!vdev->cur_format) {
-		vin_error("please set proper format first\n");
-		return -EPERM;
-	}
-
 	vsrc_fps.vsrc_id = vdev->vsrc_id;
 	vsrc_fps.fps = vdev->frame_rate;
 
@@ -1249,6 +1322,7 @@ static int vin_dev_set_mirror_mode(struct vin_device *vdev, unsigned long args)
 			return rval;
 	}
 
+	vdev->cur_format->mirror_pattern = mirror_mode.pattern;
 	if (mirror_mode.bayer_pattern != VINDEV_BAYER_PATTERN_AUTO) {
 		vdev->cur_format->bayer_pattern = mirror_mode.bayer_pattern;
 		vinc->vin_format.bayer_pattern = vdev->cur_format->bayer_pattern;
@@ -1267,6 +1341,7 @@ static int vin_dev_get_mirror_mode(struct vin_device *vdev, unsigned long args)
 	}
 
 	mirror_mode.vsrc_id = vdev->vsrc_id;
+	mirror_mode.pattern = vdev->cur_format->mirror_pattern;
 	mirror_mode.bayer_pattern = vdev->cur_format->bayer_pattern;
 
 	if (copy_to_user((void __user *)args, &mirror_mode, sizeof(mirror_mode)))
@@ -1563,7 +1638,8 @@ static int vin_dev_set_wdr_gp(struct vin_device *vdev, unsigned long args)
 	}
 
 	if (vdev->cur_format->hdr_mode == AMBA_VIDEO_LINEAR_MODE ||
-		vdev->cur_format->hdr_mode == AMBA_VIDEO_INT_HDR_MODE) {
+		(vdev->cur_format->hdr_mode == AMBA_VIDEO_INT_HDR_MODE &&
+		!vdev->cur_format->gp_ctrl_used)) {
 		vin_error("%s can only be applied for HDR modes\n", __func__);
 		return -EPERM;
 	}
@@ -1686,11 +1762,9 @@ static int vin_dev_set_video_mode(struct vin_device *vdev, unsigned long args)
 		vdev->reset_for_mode_switch){
 		vin_hw_poweron(vdev);
 		if (vdev->ops->init_device) {
-			/* setup default pll needed by device to work */
-			ambarella_vin_set_clk(vdev, 0);
+			/* setup default pll clock source needed by device to work */
+			ambarella_vin_set_pll(vdev, 0);
 			vdev->ops->init_device(vdev);
-			/* set pll registers again, because init_device will do sw reset */
-			ambarella_vin_set_pll_reg(vdev, 0);
 		}
 	}
 
@@ -1722,13 +1796,10 @@ static int vin_dev_set_video_mode(struct vin_device *vdev, unsigned long args)
 		return -EINVAL;
 	}
 
-	/* vin device needs clock to work, so setup it first  */
-	if (format->pll_idx >= vdev->num_plls) {
-		vin_error("invalid PLL index %d.\n", format->pll_idx);
-		return -EINVAL;
-	}
-
-	ambarella_vin_set_clk(vdev, format->pll_idx);
+	/* setup corresponding pll clock source and regs */
+	rval = ambarella_vin_set_clk(vdev, format->pll_idx);
+	if (rval < 0)
+		return rval;
 
 	vdev->cur_format = format;
 	vdev->pre_video_mode = mode.video_mode;
@@ -1747,7 +1818,7 @@ static int vin_dev_set_video_mode(struct vin_device *vdev, unsigned long args)
 			return rval;
 	}
 	if (format->default_agc) {
-		rval = vin_dev_set_agc_db(vdev, format->default_agc);
+		rval = vin_set_agc_db(vdev, format->default_agc);
 		if (rval < 0)
 			return rval;
 	}
@@ -1757,8 +1828,9 @@ static int vin_dev_set_video_mode(struct vin_device *vdev, unsigned long args)
 			return rval;
 	}
 
-	if (format->hdr_mode != AMBA_VIDEO_LINEAR_MODE &&
-		format->hdr_mode != AMBA_VIDEO_INT_HDR_MODE) {
+	if ((format->hdr_mode != AMBA_VIDEO_LINEAR_MODE && format->hdr_mode != AMBA_VIDEO_INT_HDR_MODE) ||
+		(format->hdr_mode == AMBA_VIDEO_INT_HDR_MODE &&
+		format->gp_ctrl_used)) {
 		/* initial wdr gp value for each mode switching */
 		memset(&vdev->wdr_gp.shutter_gp, 0, sizeof(struct vindev_wdr_gp_s));
 		memset(&vdev->wdr_gp.again_gp, 0xFFFFFFFF, sizeof(struct vindev_wdr_gp_s));
@@ -1807,6 +1879,10 @@ static int vin_dev_get_aaa_info(struct vin_device *vdev, unsigned long args)
 		return -EPERM;
 	}
 
+	memset(&vsrc_aaa_info, 0, sizeof(struct vindev_aaa_info));
+	if (vdev->ops->get_aaa_info) {
+		vdev->ops->get_aaa_info(vdev, &vsrc_aaa_info);
+	}
 	vsrc_aaa_info.vsrc_id = vdev->vsrc_id;
 	vsrc_aaa_info.sensor_id = vdev->sensor_id;
 	vsrc_aaa_info.bayer_pattern = vdev->cur_format->bayer_pattern;
@@ -1961,6 +2037,36 @@ static int vin_dev_get_dgain_ratio(struct vin_device *vdev, unsigned long args)
 	return 0;
 }
 
+static int vin_dev_aaa_compensation(struct vin_device *vdev, unsigned long args)
+{
+	struct vindev_wdr_gp_info compensation_info;
+	int rval;
+
+	if (!vdev->cur_format) {
+		vin_error("please set proper format first\n");
+		return -EPERM;
+	}
+
+	if (!vdev->ops->wdr_shutter2row)
+		return -EINVAL;
+
+	if (copy_from_user(&compensation_info, (void __user *)args, sizeof(compensation_info)))
+		return -EFAULT;
+
+	if (vdev->ops->aaa_compensation) {
+		rval = vdev->ops->aaa_compensation(vdev, &compensation_info);
+		if (rval < 0)
+			return rval;
+	}
+
+	compensation_info.vsrc_id = vdev->vsrc_id;
+
+	if (copy_to_user((void __user *)args, &compensation_info, sizeof(compensation_info)))
+		return -EFAULT;
+
+	return 0;
+}
+
 static int vin_dev_get_chip_status(struct vin_device *vdev, unsigned long args)
 {
 	struct vindev_chip_status chip_status;
@@ -1984,6 +2090,40 @@ static int vin_dev_get_chip_status(struct vin_device *vdev, unsigned long args)
 	return 0;
 }
 
+static int vin_dev_set_low_light_mode(struct vin_device *vdev, unsigned long args)
+{
+	struct vindev_low_light_info low_light_info;
+	int rval;
+
+	if (!vdev->cur_format) {
+		vin_error("please set proper format first\n");
+		return -EPERM;
+	}
+
+	if (copy_from_user(&low_light_info, (void __user *)args, sizeof(low_light_info)))
+		return -EFAULT;
+
+	if (vdev->ops->set_low_light_mode) {
+		rval = vdev->ops->set_low_light_mode(vdev, low_light_info.ll_mode);
+		if (rval < 0)
+			return rval;
+	}
+
+	return 0;
+}
+
+static int vin_dev_stop_stream(struct vin_device *vdev, unsigned long args)
+{
+	int rval;
+
+	if (vdev->ops->init_device)
+		rval = vdev->ops->init_device(vdev);
+	else
+		return -EPERM;
+
+	return rval;
+}
+
 static int vin_device_ioctl(struct vin_controller *vinc,
 		unsigned int cmd, unsigned long args)
 {
@@ -2093,7 +2233,15 @@ static int vin_device_ioctl(struct vin_controller *vinc,
 	case IAV_IOC_VIN_SET_WDR_GP:
 		rval = vin_dev_set_wdr_gp(vdev, args);
 		break;
-
+	case IAV_IOC_VIN_AAA_COMPENSATION:
+		rval = vin_dev_aaa_compensation(vdev, args);
+		break;
+	case IAV_IOC_VIN_SET_LOW_LIGHT_MODE:
+		rval = vin_dev_set_low_light_mode(vdev, args);
+		break;
+	case IAV_IOC_VIN_STOP_STREAM:
+		rval = vin_dev_stop_stream(vdev, args);
+		break;
 	default:
 		rval = -ENOIOCTLCMD;
 		vin_error("do not support cmd %d!\n", cmd);
@@ -2107,30 +2255,51 @@ static int vin_device_ioctl(struct vin_controller *vinc,
 
 int vin_pm_suspend(struct vin_device *vdev)
 {
-	/* suspend sensor */
-	if (vdev->ops->suspend) {
-		vdev->ops->suspend(vdev);
+	struct vin_controller *vinc = NULL;
+	vinc = vin_get_controller(vdev);
+
+	if (vinc->iav->vin_enabled) {
+		/* suspend sensor */
+		if (vdev->ops->suspend) {
+			vdev->ops->suspend(vdev);
+		}
 	}
 	vin_hw_poweroff(vdev);
-	/* stop clk_si */
-	rct_set_so_freq_hz(0);
 
 	return 0;
 }
 
 int vin_pm_resume(struct vin_device *vdev)
 {
+	struct vin_controller *vinc = NULL;
+	struct vindev_mirror mirror_mode;
+
 	vin_hw_poweron(vdev);
-	if (vdev->ops->init_device && vdev->ops->set_format) {
-		/* must clear cur_pll so that clk_si can be set again when vin resumes */
-		vdev->cur_pll = 0;
-		/* setup default pll needed by device to work */
-		ambarella_vin_set_clk(vdev, vdev->cur_format->pll_idx);
+	/* must clear cur_pll so that clk_si can be set again when vin resumes */
+	vdev->cur_pll = NULL;
+
+	vinc = vin_get_controller(vdev);
+	if (vinc->iav->vin_enabled && vdev->ops->init_device && vdev->ops->set_format) {
+		if (vdev->cur_format) {
+			/* setup pll clock source needed by device to work */
+			ambarella_vin_set_pll(vdev, vdev->cur_format->pll_idx);
+		}
 		vdev->ops->init_device(vdev);
-		/* set pll registers again, because init_device will do sw reset */
-		ambarella_vin_set_pll_reg(vdev, vdev->cur_format->pll_idx);
-		vdev->ops->set_format(vdev, vdev->cur_format);
-		/* resume sensor*/
+		if (vdev->cur_format) {
+			/* set sensor pll registers */
+			ambarella_vin_set_pll_reg(vdev, vdev->cur_format->pll_idx);
+			vdev->ops->set_format(vdev, vdev->cur_format);
+
+			if (vdev->frame_rate)
+				vdev->ops->set_frame_rate(vdev, vdev->frame_rate);
+			if (vdev->ops->set_mirror_mode) {
+				mirror_mode.vsrc_id = 0;
+				mirror_mode.pattern = vdev->cur_format->mirror_pattern;
+				mirror_mode.bayer_pattern = vdev->cur_format->bayer_pattern;
+				vdev->ops->set_mirror_mode(vdev, &mirror_mode);
+			}
+		}
+		/* resume sensor shutter and gain status */
 		if (vdev->ops->resume) {
 			vdev->ops->resume(vdev);
 		}
@@ -2307,7 +2476,7 @@ static struct vin_controller *vin_controller_init(struct ambarella_iav *iav,
 	}
 
 	if (vinc->iav->vin_enabled == 0)
-		ambarella_vin_set_phy(id, SENSOR_PARALLEL_LVCMOS);
+		ambarella_vin_set_phy(id, SENSOR_PARALLEL_LVCMOS, 0);
 
 	vin_info("%s: probed!\n", vinc->name);
 
diff --git a/drivers/iav/arch_s2l/iav_vin.h b/drivers/iav/arch_s2l/iav_vin.h
index 608c556..5f1deb1 100644
--- a/drivers/iav/arch_s2l/iav_vin.h
+++ b/drivers/iav/arch_s2l/iav_vin.h
@@ -4,15 +4,34 @@
  * History:
  *	2013/08/29- [Cao Rongrong] Created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #ifndef __IAV_VIN_H__
 #define __IAV_VIN_H__
 
@@ -361,6 +380,7 @@ struct iav_vin_format {
 	u32 bayer_pattern;
 	u32 input_format;
 	u32 readout_mode;
+	u32 sync_mode;
 };
 
 struct ambarella_vin_irq {
diff --git a/drivers/iav/arch_s2l/iav_vin_pll.c b/drivers/iav/arch_s2l/iav_vin_pll.c
index d951d27..89ac1c1 100644
--- a/drivers/iav/arch_s2l/iav_vin_pll.c
+++ b/drivers/iav/arch_s2l/iav_vin_pll.c
@@ -3,15 +3,34 @@
  *
  * Author: Anthony Ginger <hfjiang@ambarella.com>
  *
- * Copyright (C) 2004-2013, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #include <linux/io.h>
 #include <linux/clk.h>
 #include <plat/clk.h>
diff --git a/drivers/iav/arch_s2l/iav_vout.c b/drivers/iav/arch_s2l/iav_vout.c
index 68ee5b5..b98f1e1 100644
--- a/drivers/iav/arch_s2l/iav_vout.c
+++ b/drivers/iav/arch_s2l/iav_vout.c
@@ -5,15 +5,34 @@
  * History:
  *	2009/9/9 - [Oliver Li] created file
  *
- * Copyright (C) 2009, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #include <linux/delay.h>
 #include <iav_utils.h>
 #include <iav_ioctl.h>
@@ -194,7 +213,7 @@ static int iav_configure_sink(struct amba_video_sink_mode __user *pcfg)
 	rval = start_vout(source_id);
 
 	//Send cmds to dsp directly if needed
-	if (pcfg->direct_to_dsp) {
+	if (sink_cfg.direct_to_dsp) {
 		u32				flag = VOUT_FLAGS_ALL;
 
 		amba_vout_video_source_cmd(source_id,
@@ -770,6 +789,29 @@ void iav_config_vout(vout_src_t vout_src)
 	}
 }
 
+void iav_config_vout_with_default_image(u32 vout_src, u32 y, u32 uv, u16 pitch)
+{
+	u32 flag = VOUT_FLAGS_ALL, i;
+	vout_video_setup_t def_vout_data;
+
+	for (i = 0; i < 2; i++) {
+		amba_vout_video_source_cmd(i, AMBA_VIDEO_SOURCE_GET_VOUT_SETUP,
+			&def_vout_data);
+
+		def_vout_data.src = vout_src;
+
+		def_vout_data.default_img_y_addr = y;
+		def_vout_data.default_img_uv_addr = uv;
+		def_vout_data.default_img_pitch = pitch;
+		def_vout_data.default_img_repeat_field = 0;
+
+		amba_vout_video_source_cmd(i, AMBA_VIDEO_SOURCE_SET_VOUT_SETUP,
+			&def_vout_data);
+		amba_vout_video_source_cmd(i,
+			AMBA_VIDEO_SOURCE_UPDATE_VOUT_SETUP, &flag);
+	}
+}
+
 void iav_change_vout_src(vout_src_t vout_src)
 {
 	u32 flag = VOUT_UPDATE_VIDEO, i;
diff --git a/drivers/iav/arch_s2l/iav_vout.h b/drivers/iav/arch_s2l/iav_vout.h
index 0845ae1..f495484 100644
--- a/drivers/iav/arch_s2l/iav_vout.h
+++ b/drivers/iav/arch_s2l/iav_vout.h
@@ -4,15 +4,34 @@
  * History:
  *	2012/10/11- [Cao Rongrong] Created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #ifndef __IAV_VOUT_H__
 #define __IAV_VOUT_H__
 
@@ -28,6 +47,7 @@ struct amba_iav_vout_info {
 extern struct amba_iav_vout_info G_voutinfo[];
 
 void iav_config_vout(vout_src_t vout_src);
+void iav_config_vout_with_default_image(u32 vout_src, u32 y, u32 uv, u16 pitch);
 void iav_change_vout_src(vout_src_t vout_src);
 int iav_vout_ioctl(struct ambarella_iav *iav, unsigned int cmd, unsigned long arg);
 
diff --git a/drivers/iav/make.inc b/drivers/iav/make.inc
index 735f71f..5c5e9b8 100644
--- a/drivers/iav/make.inc
+++ b/drivers/iav/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/04 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_IAV), y)
diff --git a/drivers/imgproc/AmbaConfig b/drivers/imgproc/AmbaConfig
index d5acc63..9545d54 100644
--- a/drivers/imgproc/AmbaConfig
+++ b/drivers/imgproc/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2008/01/16 - [Anthony Ginger] Create
 ##
-## Copyright (C) 2004-2008, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 menuconfig BUILD_AMBARELLA_IMGPROC_DRV
diff --git a/drivers/imgproc/arch_s2l/Kbuild b/drivers/imgproc/arch_s2l/Kbuild
index 8f231b5..1a2133b 100644
--- a/drivers/imgproc/arch_s2l/Kbuild
+++ b/drivers/imgproc/arch_s2l/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2009/07/09 - [Anthony Ginger] Create
 ##
-## Copyright (C) 2004-2008, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/imgproc/arch_s2l/imgproc_drv.c b/drivers/imgproc/arch_s2l/imgproc_drv.c
index 760b32c..2ff0d7b 100644
--- a/drivers/imgproc/arch_s2l/imgproc_drv.c
+++ b/drivers/imgproc/arch_s2l/imgproc_drv.c
@@ -5,15 +5,34 @@
  *	2012/10/10 - [Cao Rongrong] created file
  *	2013/12/12 - [Jian Tang] modified file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #include <config.h>
 #include <linux/kernel.h>
 
@@ -46,6 +65,11 @@
 static struct imgproc_private_info G_img;
 
 static DSP_CMD G_img_cmds[IMG_CMD_NUM];
+static struct iav_imgproc_info *G_img_info_ptr = NULL;
+#ifdef CONFIG_PM
+static struct timer_list sw_timer;
+#endif
+
 
 static DECLARE_COMPLETION(g_raw2yuv_comp);
 
@@ -67,9 +91,15 @@ static void img_exit(void)
 	}
 
 	if (G_img.rd_virt) {
+#if defined(CONFIG_PANDORA_RTOS)
+		iounmap((void __iomem *)G_img.rd_virt);
+		G_img.rd_virt = NULL;
+#else
 		dma_free_writecombine(NULL, IMS_READ_TOTAL_SIZE,
 			G_img.rd_virt, G_img.rd_phys);
+#endif
 	}
+
 	memset(&G_img, 0, sizeof(G_img));
 }
 
@@ -79,6 +109,14 @@ static int img_init(void)
 
 	memset(&G_img, 0, sizeof(G_img));
 
+#if defined(CONFIG_PANDORA_RTOS)
+	G_img.rd_phys = PHYS_TO_DSP(DSP_AAA_STATS_START);
+	G_img.rd_virt = ioremap_nocache(DSP_AAA_STATS_START, IMS_READ_TOTAL_SIZE);
+	if (!G_img.rd_virt) {
+		iav_error("Failed to call ioremap() for AAA STATS.\n");
+		goto IMG_INIT_EXIT;
+	}
+#else
 	/* 3A statistics data is for read only. Using DMA write combine to map
 	 * as non-cached & write buffered memory. No need to call
 	 * "invalidate_d_cache" function. */
@@ -90,6 +128,7 @@ static int img_init(void)
 		goto IMG_INIT_EXIT;
 	}
 	G_img.rd_virt = base;
+#endif
 
 	/* 3A configuration data is for write only. Using kzalloc to allocate
 	 * cacheable memory. Need to call "clean_d_cache" before issue DSP cmd. */
@@ -144,6 +183,7 @@ static int img_init(void)
 	}
 
 	G_img.dsp_enc_mode = ENC_UNKNOWN_MODE;
+	G_img.hdr_buf_id = 0;
 	spin_lock_init(&G_img.lock);
 	init_waitqueue_head(&G_img.statis_wq);
 	init_waitqueue_head(&G_img.dsp_wq);
@@ -823,30 +863,31 @@ static int dsp_color_correction (struct iav_imgproc_info *context,
 		return -EFAULT;
 
 	dsp_cmd.cmd_code = COLOR_CORRECTION;
-	dsp_cmd.in_lookup_table_addr = VIRT_TO_DSP(G_img.addr[IMB_INPUT_LUT]);
-	dsp_cmd.matrix_addr = VIRT_TO_DSP(G_img.addr[IMB_MATRIX_DRAM]);
 
 	if (dsp_cmd.output_lookup_bypass == 1) {
 		dsp_cmd.out_lookup_table_addr = 0;
 	} else {
-		if (param->out_lookup_table_addr) {
+		if (dsp_cmd.out_lookup_table_addr) {
 			if (copy_from_user(G_img.addr[IMB_OUTPUT_LUT],
-				(void*)param->out_lookup_table_addr, IMS_OUTPUT_LUT))
+				(void*)dsp_cmd.out_lookup_table_addr, IMS_OUTPUT_LUT))
 				return -EFAULT;
 		}
 		dsp_cmd.out_lookup_table_addr = VIRT_TO_DSP(G_img.addr[IMB_OUTPUT_LUT]);
 	}
-	if (param->in_lookup_table_addr) {
+	if (dsp_cmd.in_lookup_table_addr) {
 		if (copy_from_user(G_img.addr[IMB_INPUT_LUT],
-			(void*)param->in_lookup_table_addr, IMS_INPUT_LUT))
+			(void*)dsp_cmd.in_lookup_table_addr, IMS_INPUT_LUT))
 			return -EFAULT;
 	}
-	if (param->matrix_addr) {
+	if (dsp_cmd.matrix_addr) {
 		if (copy_from_user(G_img.addr[IMB_MATRIX_DRAM],
-			(void*)param->matrix_addr, IMS_MATRIX_DRAM))
+			(void*)dsp_cmd.matrix_addr, IMS_MATRIX_DRAM))
 			return -EFAULT;
 	}
 
+	dsp_cmd.in_lookup_table_addr = VIRT_TO_DSP(G_img.addr[IMB_INPUT_LUT]);
+	dsp_cmd.matrix_addr = VIRT_TO_DSP(G_img.addr[IMB_MATRIX_DRAM]);
+
 	clean_d_cache(G_img.addr[IMB_INPUT_LUT], IMS_INPUT_LUT);
 	clean_d_cache(G_img.addr[IMB_MATRIX_DRAM], IMS_MATRIX_DRAM);
 	clean_d_cache(G_img.addr[IMB_OUTPUT_LUT], IMS_OUTPUT_LUT);
@@ -1321,6 +1362,10 @@ static int dsp_hdr_video_proc(struct iav_imgproc_info* context,
 	dsp_cmd.cmd_code = IPCAM_SET_HDR_PROC_CONTROL;
 
 	dsp_issue_img_cmd(&dsp_cmd, sizeof(dsp_cmd));
+	if (G_img.save_cmd) {
+		memcpy(&G_img_cmds[IMG_CMD_SET_HDR_PROC_CONTROL], &dsp_cmd,
+			sizeof(DSP_CMD));
+	}
 
 	return 0;
 }
@@ -1414,9 +1459,9 @@ static int img_dump_idsp(struct iav_imgproc_info* context,
 				dsp_cmd.dram_size = ((u32)*p_sec_size) + 64; //64 for header,
 				printk("sec_size %d %d\n", *p_sec_size, dsp_cmd.dram_size);
 			}
-			param->addr_long = dsp_cmd.dram_size;
+			mw_cmd.addr_long = dsp_cmd.dram_size;
 
-			if(copy_to_user(param->addr,dump_buffer,dsp_cmd.dram_size)){
+			if(copy_to_user(mw_cmd.addr,dump_buffer,dsp_cmd.dram_size)){
 				printk("cpy to usr err\n");
 				kfree(dump_buffer);
 				return -EFAULT;
@@ -1672,6 +1717,7 @@ int amba_imgproc_cmd(struct iav_imgproc_info *info, unsigned int cmd, unsigned l
 				"internal PTR number.\n", info->hdr_expo_num);
 		}
 		G_img.expo_num_minus_1 = info->hdr_expo_num - 1;
+		G_img_info_ptr = info;
 	}
 
 	return rval;
@@ -1680,40 +1726,41 @@ EXPORT_SYMBOL(amba_imgproc_cmd);
 
 //for raw2enc mode
 #ifdef CONFIG_PM
-int amba_imgproc_suspend(void)
+int amba_imgproc_suspend(int enc_mode)
 {
+	video_hiso_config_update_t *dsp_cmd = NULL;
+	u32 cfg_addr = 0;
+
+	dsp_cmd = (video_hiso_config_update_t*) &G_img_cmds[IMG_CMD_VIDEO_HISO_CONFIG_UPDATE];
+	if (G_img_info_ptr != NULL) {
+		switch (enc_mode) {
+		case DSP_ADVANCED_ISO_MODE:
+		case DSP_HDR_LINE_INTERLEAVED_MODE:
+		case DSP_BLEND_ISO_MODE:
+			cfg_addr = G_img_info_ptr->img_virt +
+				DSP_TO_PHYS(dsp_cmd->hiso_param_daddr) - G_img_info_ptr->img_phys;
+			memcpy((u8 *)G_img_info_ptr->img_virt + G_img_info_ptr->img_config_offset,
+				(void *)cfg_addr, LISO_CFG_DATA_SIZE);
+			break;
+		default:
+			iav_warn("Invalid enc mode %d in suspend.\n", enc_mode);
+			break;
+		}
+	}
+
 	return 0;
 }
 EXPORT_SYMBOL(amba_imgproc_suspend);
-int amba_imgproc_resume(int enc_mode, int expo_num)
+static void amba_send_img_cmds(int enc_mode)
 {
-	int i;
-	video_hiso_config_update_t *update_cmd;
-
-	/* Clear imgproc driver status */
-	G_img.cfa_next = 0;
-	G_img.rgb_next = 0;
-	G_img.hdr_next = 0;
-	for (i = 0; i < MAX_SLICE_FOR_FRAME; ++i) {
-		G_img.rgb_entry[i] = INVALID_AAA_DATA_ENTRY;
-		G_img.cfa_entry[i] = INVALID_AAA_DATA_ENTRY;
-	}
-	for (i = 0; i < MAX_HDR_SLICE_FOR_FRAME; ++i) {
-		G_img.hdr_entry[i] = INVALID_AAA_DATA_ENTRY;
-	}
-	G_img.statis_3a_cnt = 0;
-
-	G_img.raw_hist_addr = 0;
-	G_img.raw_pitch = 0;
-	G_img.dsp_pts = 0;
-	G_img.mono_pts = 0;
+	video_hiso_config_update_t *update_cmd = NULL;
 
 	/* Issue necessary IMG dsp commands*/
 	dsp_issue_img_cmd(&G_img_cmds[IMG_CMD_AAA_STATISTICS_SETUP],
 		sizeof(DSP_CMD));
 	dsp_issue_img_cmd(&G_img_cmds[IMG_CMD_AAA_HISTORGRAM_SETUP],
 		sizeof(DSP_CMD));
-	if (expo_num != 1) {
+	if (G_img.expo_num_minus_1 > 0) {
 		dsp_issue_cmd(&G_img_cmds[IMG_CMD_VIN_STATISTICS_SETUP],
 			sizeof(DSP_CMD));
 	}
@@ -1731,19 +1778,8 @@ int amba_imgproc_resume(int enc_mode, int expo_num)
 			sizeof(DSP_CMD));
 		break;
 	case DSP_ADVANCED_ISO_MODE:
-		update_cmd = (video_hiso_config_update_t*)
-			&G_img_cmds[IMG_CMD_VIDEO_HISO_CONFIG_UPDATE];
-		update_cmd->loadcfg_type.flag.hiso_config_aaa_update = 1;
-		dsp_issue_img_cmd(&G_img_cmds[IMG_CMD_VIDEO_HISO_CONFIG_UPDATE],
-			sizeof(DSP_CMD));
-		dsp_issue_img_cmd(&G_img_cmds[IMG_CMD_AAA_STATISTICS_SETUP1],
-			sizeof(DSP_CMD));
-		dsp_issue_img_cmd(&G_img_cmds[IMG_CMD_AAA_STATISTICS_SETUP2],
-			sizeof(DSP_CMD));
-		dsp_issue_img_cmd(&G_img_cmds[IMG_CMD_VIDEO_HISO_CONFIG_UPDATE],
-			sizeof(DSP_CMD));
-		break;
 	case DSP_HDR_LINE_INTERLEAVED_MODE:
+	case DSP_BLEND_ISO_MODE:
 		update_cmd = (video_hiso_config_update_t*)
 			&G_img_cmds[IMG_CMD_VIDEO_HISO_CONFIG_UPDATE];
 		update_cmd->loadcfg_type.flag.hiso_config_aaa_update = 1;
@@ -1751,14 +1787,93 @@ int amba_imgproc_resume(int enc_mode, int expo_num)
 			sizeof(DSP_CMD));
 		break;
 	case DSP_MULTI_REGION_WARP_MODE:
-	case DSP_BLEND_ISO_MODE:
 	default:
+		iav_warn("Invalid enc mode %d in resume.\n", enc_mode);
 		break;
 	}
 
+	if (G_img.expo_num_minus_1 > 0) {
+		dsp_issue_cmd(&G_img_cmds[IMG_CMD_SET_HDR_PROC_CONTROL],
+			sizeof(DSP_CMD));
+	}
+}
+
+static void swtimer_routine(unsigned long data)
+{
+	int enc_mode = (int)data;
+
+	amba_send_img_cmds(enc_mode);
+}
+
+int amba_imgproc_resume(int enc_mode, int fast_resume)
+{
+	int i;
+
+	/* Clear imgproc driver status */
+	G_img.cfa_next = 0;
+	G_img.rgb_next = 0;
+	G_img.hdr_next = 0;
+	for (i = 0; i < MAX_SLICE_FOR_FRAME; ++i) {
+		G_img.rgb_entry[i] = INVALID_AAA_DATA_ENTRY;
+		G_img.cfa_entry[i] = INVALID_AAA_DATA_ENTRY;
+	}
+	for (i = 0; i < MAX_HDR_SLICE_FOR_FRAME; ++i) {
+		G_img.hdr_entry[i] = INVALID_AAA_DATA_ENTRY;
+	}
+	G_img.statis_3a_cnt = 0;
+
+	G_img.raw_hist_addr = 0;
+	G_img.raw_pitch = 0;
+	G_img.dsp_pts = 0;
+	G_img.mono_pts = 0;
+
+	if (fast_resume) {
+		init_timer(&sw_timer);
+		sw_timer.data = enc_mode;
+		sw_timer.function = &swtimer_routine;
+		/* trigger timer 50 ms later */
+		sw_timer.expires = jiffies + HZ / 20;
+		add_timer(&sw_timer);
+	} else {
+		amba_send_img_cmds(enc_mode);
+	}
+
 	return 0;
 }
 EXPORT_SYMBOL(amba_imgproc_resume);
+
+int amba_imgproc_freeze(void)
+{
+	int i;
+
+	/* Clear imgproc driver status */
+	G_img.cfa_next = 0;
+	G_img.rgb_next = 0;
+	G_img.hdr_next = 0;
+	for (i = 0; i < MAX_SLICE_FOR_FRAME; ++i) {
+		G_img.rgb_entry[i] = INVALID_AAA_DATA_ENTRY;
+		G_img.cfa_entry[i] = INVALID_AAA_DATA_ENTRY;
+	}
+	for (i = 0; i < MAX_HDR_SLICE_FOR_FRAME; ++i) {
+		G_img.hdr_entry[i] = INVALID_AAA_DATA_ENTRY;
+	}
+	G_img.statis_3a_cnt = 0;
+
+	G_img.raw_hist_addr = 0;
+	G_img.raw_pitch = 0;
+	G_img.dsp_pts = 0;
+	G_img.mono_pts = 0;
+
+
+	return 0;
+}
+EXPORT_SYMBOL(amba_imgproc_freeze);
+
+int amba_imgproc_thaw(void)
+{
+	return 0;
+}
+EXPORT_SYMBOL(amba_imgproc_thaw);
 #endif
 
 static int img_count_proc_num(u32 addr)
diff --git a/drivers/imgproc/arch_s2l/imgproc_drv.h b/drivers/imgproc/arch_s2l/imgproc_drv.h
index 2c43a27..24d6187 100644
--- a/drivers/imgproc/arch_s2l/imgproc_drv.h
+++ b/drivers/imgproc/arch_s2l/imgproc_drv.h
@@ -5,14 +5,33 @@
  *	2008/04/02 - [Andrew Lu] created file
  *	2014/07/14 - [Jian Tang] modified file
  *
- * Copyright (C) 2008-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #ifndef _IMGPROC_DRV_H
 #define  _IMGPROC_DRV_H
 
@@ -152,11 +171,12 @@ typedef enum {
 	IMG_CMD_AAA_STATISTICS_SETUP2 = 3,
 	IMG_CMD_VIDEO_HISO_CONFIG_UPDATE = 4,
 	IMG_CMD_VIN_STATISTICS_SETUP = 5,
-	IMG_CMD_VIGNETTE_COMPENSATION = 6,
-	IMG_CMD_RGB_GAIN_ADJUSTMENT = 7,
-	IMG_CMD_DIGITAL_GAIN_SATURATION_LEVEL = 8,
-	IMG_CMD_LOCAL_EXPOSURE = 9,
-	IMG_CMD_BLACK_LEVEL_GLOBAL_OFFSET = 10,
+	IMG_CMD_SET_HDR_PROC_CONTROL = 6,
+	IMG_CMD_VIGNETTE_COMPENSATION = 7,
+	IMG_CMD_RGB_GAIN_ADJUSTMENT = 8,
+	IMG_CMD_DIGITAL_GAIN_SATURATION_LEVEL = 9,
+	IMG_CMD_LOCAL_EXPOSURE = 10,
+	IMG_CMD_BLACK_LEVEL_GLOBAL_OFFSET = 11,
 	IMG_CMD_NUM,
 } IMG_CMDS;
 
diff --git a/drivers/imgproc/arch_s2l/imgproc_pri.h b/drivers/imgproc/arch_s2l/imgproc_pri.h
index 6742441..c385479 100644
--- a/drivers/imgproc/arch_s2l/imgproc_pri.h
+++ b/drivers/imgproc/arch_s2l/imgproc_pri.h
@@ -1,3 +1,36 @@
+/*
+ * imgproc_pri.h
+ *
+ * History:
+ *      2008/04/02 - [Andrew Lu] created file
+ *      2014/07/14 - [Jian Tang] modified file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #ifndef __IMGPROC_PRI_H__
 #define __IMGPROC_PRI_H__
 
diff --git a/drivers/imgproc/make.inc b/drivers/imgproc/make.inc
index 3db7897..c646c09 100644
--- a/drivers/imgproc/make.inc
+++ b/drivers/imgproc/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/04 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_IMGPROC_DRV), y)
diff --git a/drivers/lens/AmbaConfig b/drivers/lens/AmbaConfig
index 1f34668..12d543c 100644
--- a/drivers/lens/AmbaConfig
+++ b/drivers/lens/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/10/10 - [Peter Jiao] Create
 ##
-## Copyright (C) 2014-2018, Ambarella, Inc.
+## Copyright (c) 2017 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 menuconfig BUILD_AMBARELLA_LENS
diff --git a/drivers/lens/Kbuild b/drivers/lens/Kbuild
index 63ae4e9..dc7e21c 100644
--- a/drivers/lens/Kbuild
+++ b/drivers/lens/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2009/07/09 - [Anthony Ginger] Create
 ##
-## Copyright (C) 2004-2008, Ambarella, Inc.
+## Copyright (c) 2017 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/lens/amba_lens.c b/drivers/lens/amba_lens.c
index d83ac60..22d2f25 100644
--- a/drivers/lens/amba_lens.c
+++ b/drivers/lens/amba_lens.c
@@ -4,15 +4,33 @@
  * History:
  *    2014/10/10 - [Peter Jiao]
  *
- * Copyright (C) 2004-2016, Ambarella, Inc.
+ * Copyright (c) 2017 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #include <config.h>
 
 #include <linux/version.h>
@@ -56,10 +74,21 @@
 #include <asm/dma.h>
 #include <asm/uaccess.h>
 #include <linux/semaphore.h>
+#include <iav_devnum.h>
+#include <plat/iav_helper.h>
+#include <plat/gpio.h>
 
 #include "amba_lens.h"
 
 
+static u32 amba_timer_input_freq = 0;
+static int amba_zoom_timer_irq = 0;
+static int amba_focus_timer_irq = 0;
+static int amba_iris_timer_irq = 0;
+
+static int amba_lens_gpio_num = 0;
+static int * amba_lens_gpio_id = NULL;
+
 static const char * amba_lens_name = "amb_lens";
 static int amba_lens_major = AMBA_DEV_MAJOR;
 static int amba_lens_minor = (AMBA_DEV_MINOR_PUBLIC_START + 18);
@@ -73,6 +102,41 @@ static struct amba_lens_operations impl_fops = {
 	.lens_dev_release = NULL
 };
 
+int amba_lens_exchange_resource(struct amba_lens_interrupts *lens_irq, struct amba_lens_gpios *lens_gpio)
+{
+	if(!lens_irq || !lens_gpio) {
+		printk(KERN_ERR "Invalid resource for %s\n", amba_lens_name);
+		return -1;
+	}
+
+	if(amba_lens_registered) {
+		printk(KERN_ERR "%s already has device, others can't get resource\n", amba_lens_name);
+		return -1;
+	}
+
+	if(lens_gpio->gpio_num) {
+		amba_lens_gpio_id = kmalloc(lens_gpio->gpio_num * sizeof(int), GFP_KERNEL);
+		if(!amba_lens_gpio_id) {
+			printk(KERN_ERR "Kmalloc gpio failed for %s\n", amba_lens_name);
+			return -1;
+		}
+		memcpy(amba_lens_gpio_id, lens_gpio->gpio_val, lens_gpio->gpio_num * sizeof(int));
+		amba_lens_gpio_num = lens_gpio->gpio_num;
+	}
+
+	if(lens_irq->timer_freq)
+		*lens_irq->timer_freq = amba_timer_input_freq;
+	if(lens_irq->zoom_timer)
+		*lens_irq->zoom_timer = amba_zoom_timer_irq;
+	if(lens_irq->focus_timer)
+		*lens_irq->focus_timer = amba_focus_timer_irq;
+	if(lens_irq->iris_timer)
+		*lens_irq->iris_timer = amba_iris_timer_irq;
+
+	return 0;
+}
+EXPORT_SYMBOL(amba_lens_exchange_resource);
+
 int amba_lens_register(struct amba_lens_operations *lens_fops)
 {
 	if((!lens_fops->lens_dev_name)||(!lens_fops->lens_dev_ioctl)||(!lens_fops->lens_dev_open)||(!lens_fops->lens_dev_release)) {
@@ -105,10 +169,41 @@ void amba_lens_logoff(void)
 	impl_fops.lens_dev_open = NULL;
 	impl_fops.lens_dev_release = NULL;
 
+	if(amba_lens_gpio_id) {
+		kfree(amba_lens_gpio_id);
+		amba_lens_gpio_id = NULL;
+	}
+	amba_lens_gpio_num = 0;
+
 	amba_lens_registered = 0;
 }
 EXPORT_SYMBOL(amba_lens_logoff);
 
+static int request_gpio(int gpio_id)
+{
+	struct ambsvc_gpio gpio_svc;
+
+	printk(KERN_DEBUG "Request GPIO %d\n", gpio_id);
+
+	gpio_svc.svc_id = AMBSVC_GPIO_REQUEST;
+	gpio_svc.gpio = GPIO(gpio_id);
+	if(ambarella_request_service(AMBARELLA_SERVICE_GPIO, &gpio_svc, NULL))
+		return -1;
+
+	return 0;
+}
+
+static void release_gpio(int gpio_id)
+{
+	struct ambsvc_gpio gpio_svc;
+
+    printk(KERN_DEBUG "Release GPIO %d\n", gpio_id);
+
+	gpio_svc.svc_id = AMBSVC_GPIO_FREE;
+	gpio_svc.gpio = GPIO(gpio_id);
+	ambarella_request_service(AMBARELLA_SERVICE_GPIO, &gpio_svc, NULL);
+}
+
 static long amba_lens_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
 	if(!impl_fops.lens_dev_ioctl) {
@@ -121,22 +216,49 @@ static long amba_lens_ioctl(struct file *filp, unsigned int cmd, unsigned long a
 
 static int amba_lens_open(struct inode *inode, struct file *filp)
 {
+	int index = 0;
+
+	for(index=0; index<amba_lens_gpio_num; index++) {
+		if(request_gpio(amba_lens_gpio_id[index])) {
+			printk(KERN_ERR "Request gpio[%d] failed for %s\n", amba_lens_gpio_id[index], amba_lens_name);
+			goto RELEASE_EXIT;
+		}
+	}
+
 	if(!impl_fops.lens_dev_open) {
 		printk(KERN_ERR "No registered device, failed %s open\n", amba_lens_name);
-		return -1;
+		goto RELEASE_EXIT;
 	}
 
-	return impl_fops.lens_dev_open(inode, filp);
+	if(impl_fops.lens_dev_open(inode, filp) < 0)
+		goto RELEASE_EXIT;
+
+	return 0;
+
+RELEASE_EXIT:
+	while(index > 0) {
+		release_gpio(amba_lens_gpio_id[index-1]);
+		index--;
+	}
+
+	return -1;
 }
 
 static int amba_lens_release(struct inode *inode, struct file *filp)
 {
+	int index, ret = 0;
+
 	if(!impl_fops.lens_dev_release) {
 		printk(KERN_ERR "No registered device, failed %s release\n", amba_lens_name);
-		return -1;
+		ret = -1;
 	}
+	else
+		ret = impl_fops.lens_dev_release(inode, filp);
 
-	return impl_fops.lens_dev_release(inode, filp);
+	for(index=0; index<amba_lens_gpio_num; index++)
+		release_gpio(amba_lens_gpio_id[index]);
+
+	return ret;
 }
 
 static struct file_operations amba_lens_fops = {
@@ -146,11 +268,35 @@ static struct file_operations amba_lens_fops = {
 	.release = amba_lens_release
 };
 
-static int __init amba_lens_init(void)
+static int ambarella_lens_probe(struct platform_device *pdev)
 {
 	dev_t dev_id;
 	int rval;
 
+	amba_timer_input_freq = clk_get_rate(clk_get(NULL, "gclk_apb"));
+	if(!amba_timer_input_freq) {
+		printk(KERN_ERR "failed to get timer input freq for %s.\n", amba_lens_name);
+		return -1;
+	}
+
+	amba_zoom_timer_irq = platform_get_irq(pdev, 0);
+	if(amba_zoom_timer_irq < 0) {
+		printk(KERN_ERR "failed to get zoom_timer_irq for %s.\n", amba_lens_name);
+		return amba_zoom_timer_irq;
+	}
+
+	amba_focus_timer_irq = platform_get_irq(pdev, 1);
+	if(amba_focus_timer_irq < 0) {
+		printk(KERN_ERR "failed to get focus_timer_irq for %s.\n", amba_lens_name);
+		return amba_focus_timer_irq;
+	}
+
+	amba_iris_timer_irq = platform_get_irq(pdev, 2);
+	if(amba_iris_timer_irq < 0) {
+		printk(KERN_ERR "failed to get iris_timer_irq for %s.\n", amba_lens_name);
+		return amba_iris_timer_irq;
+	}
+
 	amba_lens_logoff(); //clear off registered lens
 
 	if (amba_lens_major) {
@@ -162,7 +308,7 @@ static int __init amba_lens_init(void)
 	}
 
 	if (rval) {
-		printk(KERN_DEBUG "failed to get dev region for %s.\n", amba_lens_name);
+		printk(KERN_ERR "failed to get dev region for %s.\n", amba_lens_name);
 		return rval;
 	}
 
@@ -170,7 +316,7 @@ static int __init amba_lens_init(void)
 	amba_lens_cdev.owner = THIS_MODULE;
 	rval = cdev_add(&amba_lens_cdev, dev_id, 1);
 	if (rval) {
-		printk(KERN_DEBUG "cdev_add failed for %s, error = %d.\n", amba_lens_name, rval);
+		printk(KERN_ERR "cdev_add failed for %s, error = %d.\n", amba_lens_name, rval);
 		unregister_chrdev_region(dev_id, 1);
 		return rval;
 	}
@@ -180,7 +326,7 @@ static int __init amba_lens_init(void)
 	return 0;
 }
 
-static void __exit amba_lens_exit(void)
+static int ambarella_lens_remove(struct platform_device *pdev)
 {
 	dev_t dev_id;
 
@@ -188,13 +334,28 @@ static void __exit amba_lens_exit(void)
 
 	dev_id = MKDEV(amba_lens_major, amba_lens_minor);
 	unregister_chrdev_region(dev_id, 1);
+
+	return 0;
 }
 
-module_init(amba_lens_init);
-module_exit(amba_lens_exit);
+static const struct of_device_id ambarella_lens_of_match[] = {
+	{.compatible = "ambarella,lens", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ambarella_lens_of_match);
+
+static struct platform_driver amba_lens_driver = {
+	.probe		= ambarella_lens_probe,
+	.remove		= ambarella_lens_remove,
+	.driver = {
+		.name	= "ambarella-lens",
+		.of_match_table = ambarella_lens_of_match,
+	},
+};
+module_platform_driver(amba_lens_driver);
 
 MODULE_DESCRIPTION("Ambarella lens driver");
-MODULE_LICENSE("Proprietary");
+MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Peter Jiao <hgjiao@ambarella.com>");
 MODULE_ALIAS("lens-driver");
 
diff --git a/drivers/lens/amba_lens.h b/drivers/lens/amba_lens.h
index 301b9a7..7df9022 100644
--- a/drivers/lens/amba_lens.h
+++ b/drivers/lens/amba_lens.h
@@ -4,16 +4,35 @@
  * History:
  *	2014/10/10 - [Peter Jiao] created file
  *
- * Copyright (C) 2004-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2017 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
 
+
 #ifndef __AMBA_LENS_PRIV_H__
 #define __AMBA_LENS_PRIV_H__
 
@@ -25,6 +44,19 @@ struct amba_lens_operations {
 	int (*lens_dev_release) (struct inode *, struct file *);
 };
 
+struct amba_lens_interrupts {
+	unsigned int * timer_freq;
+	unsigned int * zoom_timer;
+	unsigned int * focus_timer;
+	unsigned int * iris_timer;
+};
+
+struct amba_lens_gpios {
+	int gpio_num;
+	int * gpio_val;
+};
+
+int amba_lens_exchange_resource(struct amba_lens_interrupts *lens_irq, struct amba_lens_gpios *lens_gpio);
 int amba_lens_register(struct amba_lens_operations *lens_fops);
 void amba_lens_logoff(void);
 
diff --git a/drivers/lens/evetar_mz128bp2810icr/AmbaConfig b/drivers/lens/evetar_mz128bp2810icr/AmbaConfig
index 0109d50..7845f1b 100644
--- a/drivers/lens/evetar_mz128bp2810icr/AmbaConfig
+++ b/drivers/lens/evetar_mz128bp2810icr/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/10/10 - [Peter Jiao] Create
 ##
-## Copyright (C) 2014-2018, Ambarella, Inc.
+## Copyright (c) 2017 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 config CONFIG_EVETAR_MZ128BP2810ICR
diff --git a/drivers/lens/evetar_mz128bp2810icr/Kbuild b/drivers/lens/evetar_mz128bp2810icr/Kbuild
index 4c5bb06..7f4f046 100644
--- a/drivers/lens/evetar_mz128bp2810icr/Kbuild
+++ b/drivers/lens/evetar_mz128bp2810icr/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2009/07/09 - [Anthony Ginger] Create
 ##
-## Copyright (C) 2004-2008, Ambarella, Inc.
+## Copyright (c) 2017 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/lens/evetar_mz128bp2810icr/make.inc b/drivers/lens/evetar_mz128bp2810icr/make.inc
index d6f479e..a6a82e3 100644
--- a/drivers/lens/evetar_mz128bp2810icr/make.inc
+++ b/drivers/lens/evetar_mz128bp2810icr/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/10/10 - [Peter Jiao] Created file
 ##
-## Copyright (C) 2014-2018, Ambarella, Inc.
+## Copyright (c) 2017 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_EVETAR_MZ128BP2810ICR), y)
diff --git a/drivers/lens/evetar_mz128bp2810icr/mz128bp2810icr.c b/drivers/lens/evetar_mz128bp2810icr/mz128bp2810icr.c
index 0cc1af9..a156841 100644
--- a/drivers/lens/evetar_mz128bp2810icr/mz128bp2810icr.c
+++ b/drivers/lens/evetar_mz128bp2810icr/mz128bp2810icr.c
@@ -8,15 +8,34 @@
  *	GPIO: (98)(103)(97)(104)(108)(100)(105)(99)(106)(107)(96)(101)(95)(102)(93)
  *	HW_Timer: timer1, timer2 and timer3.
  *
- * Copyright (C) 2004-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #include <config.h>
 
 #include <linux/version.h>
@@ -67,9 +86,8 @@
 #include <plat/ambsyncproc.h>
 #include <plat/ambasyncproc.h>
 #include <plat/ambevent.h>
-#include <plat/debug.h>
 #include <plat/ambcache.h>
-#include <plat/service.h>
+#include <plat/iav_helper.h>
 #include <mach/init.h>
 
 #include <amba_lens_interface.h>
@@ -77,6 +95,8 @@
 #include "mz128bp2810icr.h"
 
 
+#define MZ128BP2810ICR_GPIO_NUM	(15)
+
 #define F_CK (98)
 #define F_EN (104)
 #define F_RE (97)
@@ -164,14 +184,14 @@ static s16 focus_step_init = 0;
 static s16 piris_step_move = 0;
 static s16 piris_step_init = 0;
 
-static struct ambsvc_gpio gpio_svc;
 
 /* Note that it's only used for this module */
-static void amba_lens_gpio_direction(int pin, int input)
+static void amba_lens_gpio_direction(int gpio_id, int input)
 {
 	void __iomem *regbase;
 	u32 bank, offset, mask;
 
+	int pin = GPIO(gpio_id);
 	bank = PINID_TO_BANK(pin);
 	offset = PINID_TO_OFFSET(pin);
 	regbase = (void __iomem *)GPIO_BASE[bank];
@@ -201,35 +221,13 @@ static void amba_lens_gpio_set(int pin, int value)
 	amba_writel(regbase + GPIO_DATA_OFFSET, mask);
 }
 
-static int request_gpio(int gpio_id, int input)
-{
-	printk(KERN_DEBUG "Request GPIO %d\n", gpio_id);
-
-	gpio_svc.svc_id = AMBSVC_GPIO_REQUEST;
-	gpio_svc.gpio = GPIO(gpio_id);
-	if(ambarella_request_service(AMBARELLA_SERVICE_GPIO, &gpio_svc, NULL))
-		return -1;
-
-	amba_lens_gpio_direction(GPIO(gpio_id), input);
-
-	return 0;
-}
-
-static void release_gpio(int gpio_id)
-{
-        printk(KERN_DEBUG "Release GPIO %d\n", gpio_id);
-
-		gpio_svc.svc_id = AMBSVC_GPIO_FREE;
-		gpio_svc.gpio = GPIO(gpio_id);
-		ambarella_request_service(AMBARELLA_SERVICE_GPIO, &gpio_svc, NULL);
-}
-
 static void write_gpio(int gpio_id, int gpio_val)
 {
 	//printk(KERN_DEBUG "write GPIO %d, value =%d \n", gpio_id, gpio_val);
 #if 1
 	amba_lens_gpio_set(GPIO(gpio_id), gpio_val);
 #else
+	struct ambsvc_gpio gpio_svc;
 	gpio_svc.svc_id = AMBSVC_GPIO_OUTPUT;
 	gpio_svc.gpio = GPIO(gpio_id);
 	gpio_svc.value = gpio_val;
@@ -240,40 +238,38 @@ static void write_gpio(int gpio_id, int gpio_val)
 static int read_gpio(int gpio_id)
 {
 	int value = 0;
-
+#if 1
+	//add here
+#else
+	struct ambsvc_gpio gpio_svc;
 	gpio_svc.svc_id = AMBSVC_GPIO_INPUT;
 	gpio_svc.gpio = GPIO(gpio_id);
 	ambarella_request_service(AMBARELLA_SERVICE_GPIO, &gpio_svc, &value);
-
+#endif
   	//printk(KERN_DEBUG "read GPIO %d, value =%d \n", gpio_id,  value);
  	return value;
 }
 
 static int init_zfp_gpio(void)
 {
-	int ret = 0;
-
-	ret |= request_gpio(F_CK, 0);
-	ret |= request_gpio(F_EN, 0);
-	ret |= request_gpio(F_RE, 0);
-	ret |= request_gpio(F_CW, 0);
-	ret |= request_gpio(F_MO, 1);
-	ret |= request_gpio(Z_CK, 0);
-	ret |= request_gpio(Z_EN, 0);
-	ret |= request_gpio(Z_RE, 0);
-	ret |= request_gpio(Z_CW, 0);
-	ret |= request_gpio(Z_MO, 1);
-	ret |= request_gpio(P_CK, 0);
-	ret |= request_gpio(P_EN, 0);
-	ret |= request_gpio(P_RE, 0);
-	ret |= request_gpio(P_CW, 0);
-	ret |= request_gpio(IRCUT, 0);
-
-	if(ret<0)
-		goto ERROR_REQUEST_GPIO;
-
-	read_gpio(F_MO); //only init as input
-	read_gpio(Z_MO); //only init as input
+	amba_lens_gpio_direction(F_CK, 0);
+	amba_lens_gpio_direction(F_EN, 0);
+	amba_lens_gpio_direction(F_RE, 0);
+	amba_lens_gpio_direction(F_CW, 0);
+	amba_lens_gpio_direction(F_MO, 1);
+	amba_lens_gpio_direction(Z_CK, 0);
+	amba_lens_gpio_direction(Z_EN, 0);
+	amba_lens_gpio_direction(Z_RE, 0);
+	amba_lens_gpio_direction(Z_CW, 0);
+	amba_lens_gpio_direction(Z_MO, 1);
+	amba_lens_gpio_direction(P_CK, 0);
+	amba_lens_gpio_direction(P_EN, 0);
+	amba_lens_gpio_direction(P_RE, 0);
+	amba_lens_gpio_direction(P_CW, 0);
+	amba_lens_gpio_direction(IRCUT, 0);
+
+	read_gpio(F_MO);
+	read_gpio(Z_MO);
 	write_gpio(F_CK, 0);
 	write_gpio(F_EN, 0);
 	write_gpio(F_RE, 0);
@@ -289,25 +285,6 @@ static int init_zfp_gpio(void)
 	write_gpio(IRCUT, 0);
 
 	return 0;
-
-ERROR_REQUEST_GPIO:
-	release_gpio(F_CK);
-	release_gpio(F_EN);
-	release_gpio(F_RE);
-	release_gpio(F_CW);
-	release_gpio(F_MO);
-	release_gpio(Z_CK);
-	release_gpio(Z_EN);
-	release_gpio(Z_RE);
-	release_gpio(Z_CW);
-	release_gpio(Z_MO);
-	release_gpio(P_CK);
-	release_gpio(P_EN);
-	release_gpio(P_RE);
-	release_gpio(P_CW);
-	release_gpio(IRCUT);
-
-	return -1;
 }
 
 static void deinit_zfp_gpio(void)
@@ -325,22 +302,6 @@ static void deinit_zfp_gpio(void)
 	write_gpio(P_RE, 0);
 	write_gpio(P_CW, 0);
 	write_gpio(IRCUT, 0);
-
-	release_gpio(F_CK);
-	release_gpio(F_EN);
-	release_gpio(F_RE);
-	release_gpio(F_CW);
-	release_gpio(F_MO);
-	release_gpio(Z_CK);
-	release_gpio(Z_EN);
-	release_gpio(Z_RE);
-	release_gpio(Z_CW);
-	release_gpio(Z_MO);
-	release_gpio(P_CK);
-	release_gpio(P_EN);
-	release_gpio(P_RE);
-	release_gpio(P_CW);
-	release_gpio(IRCUT);
 }
 
 static void zoom_timer_disable(void)
@@ -669,9 +630,8 @@ static irqreturn_t piris_isr(int irq, void *dev_id)
 
 static int init_zfp_timer(void)
 {
-	timer_input_freq = clk_get_rate(clk_get(NULL, "gclk_apb"));
 	if(!timer_input_freq) {
-		printk(KERN_ERR "Get timer input clock failed!\n");
+		printk(KERN_ERR "Invalid timer input freq!\n");
 		return -1;
 	}
 
@@ -945,6 +905,12 @@ static int mz128bp2810icr_open(struct inode *inode, struct file *filp)
 			return -EBUSY;
 	}
 
+	if(init_zfp_gpio()<0)
+		return -1;
+
+	if(init_zfp_timer()<0)
+		return -1;
+
 	zoom_motor_reset();
 	focus_motor_reset();
 	piris_motor_reset();
@@ -964,6 +930,10 @@ static int mz128bp2810icr_release(struct inode *inode, struct file *filp)
 	focus_motor_release();
 	piris_motor_release();
 
+	deinit_zfp_timer();
+
+	deinit_zfp_gpio();
+
 	return 0;
 }
 
@@ -974,12 +944,24 @@ static struct amba_lens_operations dev_fops = {
 	.lens_dev_release = mz128bp2810icr_release
 };
 
+static struct amba_lens_interrupts dev_irq = {
+	.timer_freq = &timer_input_freq,
+	.zoom_timer = NULL,
+	.focus_timer = NULL,
+	.iris_timer = NULL
+};
+
+static int lens_gpio_id[MZ128BP2810ICR_GPIO_NUM] = {
+	F_CK, F_EN, F_RE, F_CW, F_MO, Z_CK, Z_EN, Z_RE, Z_CW, Z_MO, P_CK, P_EN, P_RE, P_CW, IRCUT};
+
+static struct amba_lens_gpios dev_gpio = {
+	.gpio_num = MZ128BP2810ICR_GPIO_NUM,
+	.gpio_val = lens_gpio_id
+};
+
 static int __init mz128bp2810icr_init(void)
 {
-	if(init_zfp_gpio()<0)
-		return -1;
-
-	if(init_zfp_timer()<0)
+	if(amba_lens_exchange_resource(&dev_irq, &dev_gpio)<0)
 		return -1;
 
 	if(amba_lens_register(&dev_fops)<0)
@@ -991,10 +973,6 @@ static int __init mz128bp2810icr_init(void)
 static void __exit mz128bp2810icr_exit(void)
 {
 	amba_lens_logoff();
-
-	deinit_zfp_timer();
-
-	deinit_zfp_gpio();
 }
 
 module_init(mz128bp2810icr_init);
diff --git a/drivers/lens/evetar_mz128bp2810icr/mz128bp2810icr.h b/drivers/lens/evetar_mz128bp2810icr/mz128bp2810icr.h
index e6d9799..eb35dc7 100644
--- a/drivers/lens/evetar_mz128bp2810icr/mz128bp2810icr.h
+++ b/drivers/lens/evetar_mz128bp2810icr/mz128bp2810icr.h
@@ -4,16 +4,35 @@
  * History:
  *	2014/10/10 - [Peter Jiao] created file
  *
- * Copyright (C) 2004-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
 
+
 #ifndef __MZ128BP2810ICR_LENS_PRIV_H__
 #define __MZ128BP2810ICR_LENS_PRIV_H__
 
diff --git a/drivers/lens/make.inc b/drivers/lens/make.inc
index 10ae3f8..856c9c8 100644
--- a/drivers/lens/make.inc
+++ b/drivers/lens/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/10/10 - [Peter Jiao] Created file
 ##
-## Copyright (C) 2014-2018, Ambarella, Inc.
+## Copyright (c) 2017 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_LENS), y)
diff --git a/drivers/lens/tamron_m13vp288ir/AmbaConfig b/drivers/lens/tamron_m13vp288ir/AmbaConfig
index f554a4c..fbb173a 100644
--- a/drivers/lens/tamron_m13vp288ir/AmbaConfig
+++ b/drivers/lens/tamron_m13vp288ir/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/10/10 - [Peter Jiao] Create
 ##
-## Copyright (C) 2014-2018, Ambarella, Inc.
+## Copyright (c) 2017 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 config CONFIG_TAMRON_M13VP288IR
diff --git a/drivers/lens/tamron_m13vp288ir/Kbuild b/drivers/lens/tamron_m13vp288ir/Kbuild
index e34adf9..766c073 100644
--- a/drivers/lens/tamron_m13vp288ir/Kbuild
+++ b/drivers/lens/tamron_m13vp288ir/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2009/07/09 - [Anthony Ginger] Create
 ##
-## Copyright (C) 2004-2008, Ambarella, Inc.
+## Copyright (c) 2017 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/lens/tamron_m13vp288ir/m13vp288ir_piris.c b/drivers/lens/tamron_m13vp288ir/m13vp288ir_piris.c
index 3af4b10..fe47b18 100644
--- a/drivers/lens/tamron_m13vp288ir/m13vp288ir_piris.c
+++ b/drivers/lens/tamron_m13vp288ir/m13vp288ir_piris.c
@@ -5,16 +5,35 @@
  *	2012/06/29 - [Louis Sun]
  *    2014/10/17 - [Peter Jiao] Mod for S2L on old S2 version
  *
- * Copyright (C) 2004-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
 
+
 #include <config.h>
 
 #include <linux/version.h>
@@ -63,7 +82,7 @@
 #include <plat/ambsyncproc.h>
 #include <plat/ambasyncproc.h>
 #include <plat/ambevent.h>
-#include <plat/debug.h>
+
 #include <plat/ambcache.h>
 #include <mach/init.h>
 
@@ -210,7 +229,7 @@ module_init(amba_p_iris_init);
 module_exit(amba_p_iris_exit);
 
 MODULE_DESCRIPTION("Ambarella P-Iris driver for Tamron m13vp288ir with LB1909M");
-MODULE_LICENSE("Proprietary");
+MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Louis Sun, <lysun@ambarella.com>");
 MODULE_ALIAS("p-iris-driver");
 
diff --git a/drivers/lens/tamron_m13vp288ir/m13vp288ir_piris_api.c b/drivers/lens/tamron_m13vp288ir/m13vp288ir_piris_api.c
index f108e64..20a4e36 100644
--- a/drivers/lens/tamron_m13vp288ir/m13vp288ir_piris_api.c
+++ b/drivers/lens/tamron_m13vp288ir/m13vp288ir_piris_api.c
@@ -5,16 +5,35 @@
  *	2012/06/29 - [Louis Sun]
  *	2014/06/11 - [Peter Jiao] Mod
  *
- * Copyright (C) 2004-2012, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
 
+
 #include <config.h>
 
 #include <linux/version.h>
@@ -63,7 +82,7 @@
 #include <plat/ambsyncproc.h>
 #include <plat/ambasyncproc.h>
 #include <plat/ambevent.h>
-#include <plat/debug.h>
+
 #include <plat/ambcache.h>
 #include <mach/init.h>
 
diff --git a/drivers/lens/tamron_m13vp288ir/m13vp288ir_piris_impl.c b/drivers/lens/tamron_m13vp288ir/m13vp288ir_piris_impl.c
index dacb512..c28e2cf 100644
--- a/drivers/lens/tamron_m13vp288ir/m13vp288ir_piris_impl.c
+++ b/drivers/lens/tamron_m13vp288ir/m13vp288ir_piris_impl.c
@@ -5,19 +5,35 @@
  *	2012/07/2 - [Louis Sun]
  *	2014/10/22 - [Peter Jiao] Mod for S2L on old S2 version
  *
- * Copyright (C) 2004-2012, Ambarella, Inc.
  *
- * This file is to implement iris control on selected GPIO based IRIS driver
- * so this implementation depends on different IRIS drive chip design
+ * Copyright (c) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
 
+
 #include <config.h>
 
 #include <linux/version.h>
@@ -66,10 +82,10 @@
 #include <plat/ambsyncproc.h>
 #include <plat/ambasyncproc.h>
 #include <plat/ambevent.h>
-#include <plat/debug.h>
+
 #include <plat/ambcache.h>
 #include <mach/init.h>
-#include <plat/service.h>
+#include <plat/iav_helper.h>
 
 #include <amba_lens_interface.h>
 #include "m13vp288ir_piris_priv.h"
diff --git a/drivers/lens/tamron_m13vp288ir/m13vp288ir_piris_priv.h b/drivers/lens/tamron_m13vp288ir/m13vp288ir_piris_priv.h
index a5a7c92..bc80c91 100644
--- a/drivers/lens/tamron_m13vp288ir/m13vp288ir_piris_priv.h
+++ b/drivers/lens/tamron_m13vp288ir/m13vp288ir_piris_priv.h
@@ -5,16 +5,35 @@
  *	2012/06/29 - [Louis Sun] created file
  *	2014/06/11 - [Peter Jiao] Mod
  *
- * Copyright (C) 2007-2012, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
 
+
 #ifndef __M13VP288IR_PIRIS_PRIV_H__
 #define __M13VP288IR_PIRIS_PRIV_H__
 
diff --git a/drivers/lens/tamron_m13vp288ir/m13vp288ir_piris_timer.c b/drivers/lens/tamron_m13vp288ir/m13vp288ir_piris_timer.c
index 0467fc4..350e786 100644
--- a/drivers/lens/tamron_m13vp288ir/m13vp288ir_piris_timer.c
+++ b/drivers/lens/tamron_m13vp288ir/m13vp288ir_piris_timer.c
@@ -5,16 +5,35 @@
  *	2012/07/2 - [Louis Sun]
  *	2014/06/11 - [Peter Jiao] Mod
  *
- * Copyright (C) 2004-2012, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
 
+
 #include <config.h>
 
 #include <linux/version.h>
@@ -63,7 +82,7 @@
 #include <plat/ambsyncproc.h>
 #include <plat/ambasyncproc.h>
 #include <plat/ambevent.h>
-#include <plat/debug.h>
+
 #include <plat/ambcache.h>
 #include <mach/init.h>
 
diff --git a/drivers/lens/tamron_m13vp288ir/make.inc b/drivers/lens/tamron_m13vp288ir/make.inc
index 01398f3..a374d73 100644
--- a/drivers/lens/tamron_m13vp288ir/make.inc
+++ b/drivers/lens/tamron_m13vp288ir/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/10/10 - [Peter Jiao] Created file
 ##
-## Copyright (C) 2014-2018, Ambarella, Inc.
+## Copyright (c) 2017 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_TAMRON_M13VP288IR), y)
diff --git a/drivers/make.inc b/drivers/make.inc
index 86396eb..d7d7f34 100644
--- a/drivers/make.inc
+++ b/drivers/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/04 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_PRIVATE_MODULES), y)
diff --git a/drivers/msg/AmbaConfig b/drivers/msg/AmbaConfig
index db4ca40..b3d8109 100644
--- a/drivers/msg/AmbaConfig
+++ b/drivers/msg/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/07/29 - [Lei Hong] Create
 ##
-## Copyright (C) 2004-2018, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 config BUILD_AMBARELLA_PRIVATE_DRV_MSG
diff --git a/drivers/msg/Kbuild b/drivers/msg/Kbuild
index 61dba4b..95cb310 100644
--- a/drivers/msg/Kbuild
+++ b/drivers/msg/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/07/29 - [Lei Hong] Create
 ##
-## Copyright (C) 2004-2018, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/msg/make.inc b/drivers/msg/make.inc
index ce7cce0..1adef20 100644
--- a/drivers/msg/make.inc
+++ b/drivers/msg/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/07/29 - [Lei Hong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_PRIVATE_DRV_MSG), y)
diff --git a/drivers/msg/msg_drv.c b/drivers/msg/msg_drv.c
index e48c68e..6723c66 100644
--- a/drivers/msg/msg_drv.c
+++ b/drivers/msg/msg_drv.c
@@ -4,15 +4,34 @@
  * History:
  *	2014/07/22 - [Jian Tang] created file
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #include <linux/types.h>
 #include <linux/errno.h>
 #include <linux/time.h>
@@ -21,6 +40,7 @@
 #include <linux/proc_fs.h>
 #include <linux/fs.h>
 #include <linux/syslog.h>
+#include <linux/module.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
diff --git a/drivers/msg/msg_print.c b/drivers/msg/msg_print.c
index eec5f09..d0c12f2 100644
--- a/drivers/msg/msg_print.c
+++ b/drivers/msg/msg_print.c
@@ -4,14 +4,33 @@
  * Histroy:
  *  July 23, 2014 - [Lei Hong] created file
  *
- * Copyright (C) 2008-2014, Ambarella ShangHai Co,Ltd
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella
+ * Copyright (c) 2015 Ambarella, Inc.
  *
- ******************************************************************************/
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/init.h>
@@ -26,6 +45,7 @@
 #include <linux/syslog.h>
 #include <asm/uaccess.h>
 #include <linux/sched.h>
+#include <linux/version.h>
 
 MODULE_AUTHOR("Lei Hong<lhong@ambarella.com>");
 MODULE_DESCRIPTION("Ambarella print private driver");
@@ -51,10 +71,11 @@ struct drv_log {
 extern u64 local_clock(void);
 
 /* printk's without a loglevel use this.. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
+#define DEFAULT_MESSAGE_LOGLEVEL CONFIG_MESSAGE_LOGLEVEL_DEFAULT
+#else
 #define DEFAULT_MESSAGE_LOGLEVEL CONFIG_DEFAULT_MESSAGE_LOGLEVEL
-
-
-/*DECLARE_WAIT_QUEUE_HEAD(log_wait);*/
+#endif
 
 /*
  * The drv_logbuf_lock protects drvmsg buffer, indices, counters. It is also
@@ -485,12 +506,12 @@ static int drv_syslog_print_all(char __user *buf, int size, bool clear)
 }
 
 #ifdef CONFIG_SECURITY_DMESG_RESTRICT
-int drv_dmesg_restrict = 1;
+static int drv_dmesg_restrict = 1;
 #else
-int drv_dmesg_restrict;
+static int drv_dmesg_restrict = 0;
 #endif
 
-static int syslog_action_restricted(int type)
+static int drv_syslog_action_restricted(int type)
 {
 	if (drv_dmesg_restrict)
 		return 1;
@@ -498,7 +519,7 @@ static int syslog_action_restricted(int type)
 	return type != SYSLOG_ACTION_READ_ALL && type != SYSLOG_ACTION_SIZE_BUFFER;
 }
 
-static int check_syslog_permissions(int type, bool from_file)
+static int check_drv_syslog_permissions(int type, bool from_file)
 {
 	/*
 	 * If this is from /proc/kmsg and we've already opened it, then we've
@@ -507,7 +528,7 @@ static int check_syslog_permissions(int type, bool from_file)
 	if (from_file && type != SYSLOG_ACTION_OPEN)
 		return 0;
 
-	if (syslog_action_restricted(type)) {
+	if (drv_syslog_action_restricted(type)) {
 		if (capable(CAP_SYSLOG))
 			return 0;
 		/* For historical reasons, accept CAP_SYS_ADMIN too, with a warning */
@@ -528,7 +549,7 @@ int do_drv_syslog(int type, char __user *buf, int len, bool from_file)
 	bool clear = false;
 	int error;
 
-	error = check_syslog_permissions(type, from_file);
+	error = check_drv_syslog_permissions(type, from_file);
 	if (error)
 		goto out;
 
diff --git a/drivers/uvc_camera/AmbaConfig b/drivers/uvc_camera/AmbaConfig
new file mode 100644
index 0000000..dbb647a
--- /dev/null
+++ b/drivers/uvc_camera/AmbaConfig
@@ -0,0 +1,32 @@
+##
+## kernel/private/drivers/uvc_camera/AmbaConfig
+##
+## History:
+##    2015/10/26 - [Jorney Tu] Create
+##
+## Copyright (C) 2014-2018, Ambarella, Inc.
+##
+## All rights reserved. No Part of this file may be reproduced, stored
+## in a retrieval system, or transmitted, in any form, or by any means,
+## electronic, mechanical, photocopying, recording, or otherwise,
+## without the prior consent of Ambarella, Inc.
+##
+
+menuconfig BUILD_AMBARELLA_UVC_CAMERA
+	depends on BUILD_AMBARELLA_PRIVATE_MODULES
+	bool "Build Ambarella private UVC Camera"
+	default n
+	help
+		Build Ambarella UVC Camera for Linux.
+
+if BUILD_AMBARELLA_UVC_CAMERA
+
+config CONFIG_AMBARELLA_UVC_WITH_UAC
+	bool "UVC Camera with UAC"
+	default y
+	help
+		This option is depends on alsa , codec ...
+
+
+endif
+
diff --git a/drivers/uvc_camera/Document/README b/drivers/uvc_camera/Document/README
new file mode 100644
index 0000000..fe069bd
--- /dev/null
+++ b/drivers/uvc_camera/Document/README
@@ -0,0 +1,88 @@
+	UVC & UAC driver for linux
+	------------------------------------
+
+	Original by: Jorney Tu, Oct 2015
+	Last update: 2015-10-26
+
+UVC
+	USB video class
+UAC
+	USB audio class
+
+Specification
+
+UVC
+---
+	Solution support:
+	X MJPG 1280 * 720 15ps (default)
+	Y YUV  640 * 360  30ps
+
+UAC
+---
+	Support:
+	Sample Rate     : 48000 (default)
+	Channle    		: MONO
+	Sample Size   	: 16bit
+
+OS support
+---
+	windown7
+	windownxp
+	Ubuntu14.04    ; #define  LINUX  1 in config.h
+
+Player
+---
+	VLC(*2.2.1 version recommended)
+
+FIXME
+---
+  libcomposite.ko is needed, please refer to linux kernel
+  /dev/snd/pcmC0D0c is needed
+  /dev/iav is needed
+
+Steps
+---
+	* insmod ko
+		modprobe libcomposite
+		modprobe uac
+		modprobe audio
+		modprobe uvc
+		modprobe webcam
+
+	* VLC Player
+		please refer to device.PNG and format.PNG
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/uvc_camera/defconfig.h b/drivers/uvc_camera/defconfig.h
new file mode 100644
index 0000000..4364329
--- /dev/null
+++ b/drivers/uvc_camera/defconfig.h
@@ -0,0 +1,63 @@
+/*
+ * kernel/private/drivers/uvc_camera/defconfig.h
+ *
+ * History:
+ *    2015/11/10 - qtu@ambarella.com
+ *
+ * Copyright (C) 2004-2020, Ambarella, Inc.
+ *
+ * All rights reserved. No Part of this file may be reproduced, stored
+ * in a retrieval system, or transmitted, in any form, or by any means,
+ * electronic, mechanical, photocopying, recording, or otherwise,
+ * without the prior consent of Ambarella, Inc.
+ *
+ */
+
+#ifndef __LINUX_UVA__
+#define __LINUX_UVA__
+
+#include <config.h>
+
+#ifdef CONFIG_AMBARELLA_UVC_WITH_UAC
+#define AUDIO_OPEN  1
+#else
+#define AUDIO_OPEN  0
+#endif
+
+int audio_bind(struct usb_composite_dev *cdev);
+int audio_unbind(struct usb_composite_dev *cdev);
+int audio_do_config(struct usb_configuration *c);
+int uvc_stream_on(void);
+int uvc_stream_off(void);
+
+#define UVC_DELAY (1000 * 8)
+
+/* AUDIO_DEBUG */
+#define     AUDIO_DEBUG_CAPTURE     0
+#define     AUDIO_DEBUG_PLAY        0
+
+#define     AUDIO_DEBUG_CAPTURE_FILE    "/mnt/audio_record.wav"
+#define     AUDIO_DEBUG_CAPTURE_SIZE     (4 * 1024 * 1024)
+
+#define     AUDIO_DEBUG_PLAY_FILE	     "/mnt/audio_play.wav"
+#define     AUDIO_DEBUG_PLAY_SIZE         (1 * 1024 * 1024)
+
+/* AUDIO_DEBUG END*/
+
+/* VIDEO_DEBUG */
+
+#define VIDEO_DEBUG           0
+#define VIDEO_DEBUG_FILE      "/mnt/sample.mjpg"
+
+/* VIDEO_DEBUG END*/
+
+/* FIXME: Host is LINUX OS */
+#define LINUX              0
+
+/* WINDOWNS solution */
+#define UAC_EX_SOLUTION    0
+
+/* fix video flicker */
+#define UVC_FLICKER_FIXED    1
+
+#endif
diff --git a/drivers/uvc_camera/make.inc b/drivers/uvc_camera/make.inc
new file mode 100644
index 0000000..4280c43
--- /dev/null
+++ b/drivers/uvc_camera/make.inc
@@ -0,0 +1,33 @@
+##
+## kernel/private/drivers/uvc_camera/make.inc
+##
+## History:
+##    2015/10/26 - [Jorney] Created file
+##
+## Copyright (C) 2012-2016, Ambarella, Inc.
+##
+## All rights reserved. No Part of this file may be reproduced, stored
+## in a retrieval system, or transmitted, in any form, or by any means,
+## electronic, mechanical, photocopying, recording, or otherwise,
+## without the prior consent of Ambarella, Inc.
+##
+
+ifeq ($(BUILD_AMBARELLA_UVC_CAMERA), y)
+
+LOCAL_PATH	:= $(call my-dir)
+
+###
+include $(CLEAR_VARS)
+
+LOCAL_SRCS	+=  $(wildcard $(LOCAL_PATH)/uvc/*.c) \
+		     	$(wildcard $(LOCAL_PATH)/uvc/*.h)
+
+
+LOCAL_SRCS	+= $(wildcard $(LOCAL_PATH)/*.h)
+
+LOCAL_SRCS	+= $(LOCAL_PATH)/uvc/Kbuild
+
+include $(BUILD_DRIVER)
+
+endif
+
diff --git a/drivers/uvc_camera/uvc/Kbuild b/drivers/uvc_camera/uvc/Kbuild
new file mode 100644
index 0000000..fafd8d5
--- /dev/null
+++ b/drivers/uvc_camera/uvc/Kbuild
@@ -0,0 +1,26 @@
+##
+## Kbuild
+##
+## History:
+##    2015/10/26 - [Jorney] Create
+##
+## Copyright (C) 2012-2016, Ambarella, Inc.
+##
+## All rights reserved. No Part of this file may be reproduced, stored
+## in a retrieval system, or transmitted, in any form, or by any means,
+## electronic, mechanical, photocopying, recording, or otherwise,
+## without the prior consent of Ambarella, Inc.
+##
+
+EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
+EXTRA_AFLAGS		+= $(AMBARELLA_DRV_AFLAGS)
+EXTRA_LDFLAGS		+= $(AMBARELLA_DRV_LDFLAGS)
+
+obj-m += uvc.o
+uvc-y := f_uvc.o uvc_stream.o
+obj-m += webcam.o
+
+obj-m +=uac.o
+uac-y += f_uac1.o uac_stream.o
+obj-m += audio.o
+
diff --git a/drivers/uvc_camera/uvc/audio.c b/drivers/uvc_camera/uvc/audio.c
new file mode 100644
index 0000000..7a32cf0
--- /dev/null
+++ b/drivers/uvc_camera/uvc/audio.c
@@ -0,0 +1,290 @@
+/*
+ * audio.c -- Audio gadget driver
+ *
+ * Copyright (C) 2008 Bryan Wu <cooloney@kernel.org>
+ * Copyright (C) 2008 Analog Devices, Inc
+ * Copyright (C) 2015 Jorney Tu <qtu@ambarella.com>
+ *
+ * Enter bugs at http://blackfin.uclinux.org/
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+/* #define VERBOSE_DEBUG */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/usb/composite.h>
+
+#include "gadget_chips.h"
+#define DRIVER_DESC		"Linux USB Audio Gadget"
+#define DRIVER_VERSION		"Feb 2, 2012"
+
+#ifndef CONFIG_GADGET_UAC1
+#define CONFIG_GADGET_UAC1
+#endif
+
+USB_GADGET_COMPOSITE_OPTIONS();
+
+#ifndef CONFIG_GADGET_UAC1
+#include "u_uac2.h"
+
+/* Playback(USB-IN) Default Stereo - Fl/Fr */
+static int p_chmask = UAC2_DEF_PCHMASK;
+module_param(p_chmask, uint, S_IRUGO);
+MODULE_PARM_DESC(p_chmask, "Playback Channel Mask");
+
+/* Playback Default 48 KHz */
+static int p_srate = UAC2_DEF_PSRATE;
+module_param(p_srate, uint, S_IRUGO);
+MODULE_PARM_DESC(p_srate, "Playback Sampling Rate");
+
+/* Playback Default 16bits/sample */
+static int p_ssize = UAC2_DEF_PSSIZE;
+module_param(p_ssize, uint, S_IRUGO);
+MODULE_PARM_DESC(p_ssize, "Playback Sample Size(bytes)");
+
+/* Capture(USB-OUT) Default Stereo - Fl/Fr */
+static int c_chmask = UAC2_DEF_CCHMASK;
+module_param(c_chmask, uint, S_IRUGO);
+MODULE_PARM_DESC(c_chmask, "Capture Channel Mask");
+
+/* Capture Default 64 KHz */
+static int c_srate = UAC2_DEF_CSRATE;
+module_param(c_srate, uint, S_IRUGO);
+MODULE_PARM_DESC(c_srate, "Capture Sampling Rate");
+
+/* Capture Default 16bits/sample */
+static int c_ssize = UAC2_DEF_CSSIZE;
+module_param(c_ssize, uint, S_IRUGO);
+MODULE_PARM_DESC(c_ssize, "Capture Sample Size(bytes)");
+#else
+#include "u_uac1.h"
+
+static char *fn_play = FILE_PCM_PLAYBACK;
+module_param(fn_play, charp, S_IRUGO);
+MODULE_PARM_DESC(fn_play, "Playback PCM device file name");
+
+static char *fn_cap = FILE_PCM_CAPTURE;
+module_param(fn_cap, charp, S_IRUGO);
+MODULE_PARM_DESC(fn_cap, "Capture PCM device file name");
+
+static char *fn_cntl = FILE_CONTROL;
+module_param(fn_cntl, charp, S_IRUGO);
+MODULE_PARM_DESC(fn_cntl, "Control device file name");
+
+static int req_buf_size = UAC1_OUT_EP_MAX_PACKET_SIZE;
+module_param(req_buf_size, int, S_IRUGO);
+MODULE_PARM_DESC(req_buf_size, "ISO OUT endpoint request buffer size");
+
+static int req_count = UAC1_REQ_COUNT;
+module_param(req_count, int, S_IRUGO);
+MODULE_PARM_DESC(req_count, "ISO OUT endpoint request count");
+
+static int audio_buf_size = UAC1_AUDIO_BUF_SIZE;
+module_param(audio_buf_size, int, S_IRUGO);
+MODULE_PARM_DESC(audio_buf_size, "Audio buffer size");
+#endif
+
+/* string IDs are assigned dynamically */
+
+static struct usb_string strings_dev[] = {
+	[USB_GADGET_MANUFACTURER_IDX].s = "",
+	[USB_GADGET_PRODUCT_IDX].s = DRIVER_DESC,
+	[USB_GADGET_SERIAL_IDX].s = "",
+	{  } /* end of list */
+};
+
+
+#ifndef CONFIG_GADGET_UAC1
+static struct usb_function_instance *fi_uac2;
+static struct usb_function *f_uac2;
+#else
+static struct usb_function_instance *fi_uac1;
+static struct usb_function *f_uac1;
+#endif
+
+/*-------------------------------------------------------------------------*/
+
+/* DO NOT REUSE THESE IDs with a protocol-incompatible driver!!  Ever!!
+ * Instead:  allocate your own, using normal USB-IF procedures.
+ */
+
+/* Thanks to Linux Foundation for donating this product ID. */
+#define AUDIO_VENDOR_NUM		0x1d6b	/* Linux Foundation */
+#define AUDIO_PRODUCT_NUM		0x0101	/* Linux-USB Audio Gadget */
+
+/*-------------------------------------------------------------------------*/
+
+static struct usb_device_descriptor device_desc = {
+	.bLength =		sizeof device_desc,
+	.bDescriptorType =	USB_DT_DEVICE,
+
+	.bcdUSB =		__constant_cpu_to_le16(0x200),
+
+#ifdef CONFIG_GADGET_UAC1
+	.bDeviceClass =		USB_CLASS_PER_INTERFACE,
+	.bDeviceSubClass =	0,
+	.bDeviceProtocol =	0,
+#else
+	.bDeviceClass =		USB_CLASS_MISC,
+	.bDeviceSubClass =	0x02,
+	.bDeviceProtocol =	0x01,
+#endif
+	/* .bMaxPacketSize0 = f(hardware) */
+
+	/* Vendor and product id defaults change according to what configs
+	 * we support.  (As does bNumConfigurations.)  These values can
+	 * also be overridden by module parameters.
+	 */
+	.idVendor =		__constant_cpu_to_le16(AUDIO_VENDOR_NUM),
+	.idProduct =		__constant_cpu_to_le16(AUDIO_PRODUCT_NUM),
+	/* .bcdDevice = f(hardware) */
+	/* .iManufacturer = DYNAMIC */
+	/* .iProduct = DYNAMIC */
+	/* NO SERIAL NUMBER */
+	.bNumConfigurations =	1,
+};
+
+static struct usb_otg_descriptor otg_descriptor = {
+	.bLength =		sizeof otg_descriptor,
+	.bDescriptorType =	USB_DT_OTG,
+
+	/* REVISIT SRP-only hardware is possible, although
+	 * it would not be called "OTG" ...
+	 */
+	.bmAttributes =		USB_OTG_SRP | USB_OTG_HNP,
+};
+
+static const struct usb_descriptor_header *otg_desc[] = {
+	(struct usb_descriptor_header *) &otg_descriptor,
+	NULL,
+};
+
+/*-------------------------------------------------------------------------*/
+
+int audio_do_config(struct usb_configuration *c)
+{
+	int status;
+
+	/* FIXME alloc iConfiguration string, set it in c->strings */
+
+	if (gadget_is_otg(c->cdev->gadget)) {
+		c->descriptors = otg_desc;
+		c->bmAttributes |= USB_CONFIG_ATT_WAKEUP;
+	}
+
+#ifdef CONFIG_GADGET_UAC1
+	f_uac1 = usb_get_function(fi_uac1);
+	if (IS_ERR(f_uac1)) {
+		status = PTR_ERR(f_uac1);
+		return status;
+	}
+
+	status = usb_add_function(c, f_uac1);
+	if (status < 0) {
+		usb_put_function(f_uac1);
+		return status;
+	}
+#else
+	f_uac2 = usb_get_function(fi_uac2);
+	if (IS_ERR(f_uac2)) {
+		status = PTR_ERR(f_uac2);
+		return status;
+	}
+
+	status = usb_add_function(c, f_uac2);
+	if (status < 0) {
+		usb_put_function(f_uac2);
+		return status;
+	}
+#endif
+
+	return 0;
+}
+EXPORT_SYMBOL(audio_do_config);
+
+
+/*-------------------------------------------------------------------------*/
+
+int audio_bind(struct usb_composite_dev *cdev)
+{
+#ifndef CONFIG_GADGET_UAC1
+	struct f_uac2_opts	*uac2_opts;
+#else
+	struct f_uac1_opts	*uac1_opts;
+#endif
+	int			status;
+
+
+#ifndef CONFIG_GADGET_UAC1
+	fi_uac2 = usb_get_function_instance("uac2");
+	if (IS_ERR(fi_uac2))
+		return PTR_ERR(fi_uac2);
+#else
+	fi_uac1 = usb_get_function_instance("uac1");
+	if (IS_ERR(fi_uac1))
+		return PTR_ERR(fi_uac1);
+#endif
+
+#ifndef CONFIG_GADGET_UAC1
+	uac2_opts = container_of(fi_uac2, struct f_uac2_opts, func_inst);
+	uac2_opts->p_chmask = p_chmask;
+	uac2_opts->p_srate = p_srate;
+	uac2_opts->p_ssize = p_ssize;
+	uac2_opts->c_chmask = c_chmask;
+	uac2_opts->c_srate = c_srate;
+	uac2_opts->c_ssize = c_ssize;
+#else
+	uac1_opts = container_of(fi_uac1, struct f_uac1_opts, func_inst);
+	uac1_opts->fn_play = fn_play;
+	uac1_opts->fn_cap = fn_cap;
+	uac1_opts->fn_cntl = fn_cntl;
+	uac1_opts->req_buf_size = req_buf_size;
+	uac1_opts->req_count = req_count;
+	uac1_opts->audio_buf_size = audio_buf_size;
+#endif
+
+	status = usb_string_ids_tab(cdev, strings_dev);
+	if (status < 0)
+		goto fail;
+	device_desc.iManufacturer = strings_dev[USB_GADGET_MANUFACTURER_IDX].id;
+	device_desc.iProduct = strings_dev[USB_GADGET_PRODUCT_IDX].id;
+
+	usb_composite_overwrite_options(cdev, &coverwrite);
+
+	INFO(cdev, "%s, version: %s\n", DRIVER_DESC, DRIVER_VERSION);
+	return 0;
+
+fail:
+#ifndef CONFIG_GADGET_UAC1
+	usb_put_function_instance(fi_uac2);
+#else
+	usb_put_function_instance(fi_uac1);
+#endif
+	return status;
+}
+
+int audio_unbind(struct usb_composite_dev *cdev)
+{
+
+#ifdef CONFIG_GADGET_UAC1
+	if (!IS_ERR_OR_NULL(f_uac1))
+		usb_put_function(f_uac1);
+	if (!IS_ERR_OR_NULL(fi_uac1))
+		usb_put_function_instance(fi_uac1);
+#else
+	if (!IS_ERR_OR_NULL(f_uac2))
+		usb_put_function(f_uac2);
+	if (!IS_ERR_OR_NULL(fi_uac2))
+		usb_put_function_instance(fi_uac2);
+#endif
+	return 0;
+}
+EXPORT_SYMBOL(audio_bind);
+EXPORT_SYMBOL(audio_unbind);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR("Bryan Wu <cooloney@kernel.org>");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/uvc_camera/uvc/f_uac1.c b/drivers/uvc_camera/uvc/f_uac1.c
new file mode 100644
index 0000000..3b0a6a3
--- /dev/null
+++ b/drivers/uvc_camera/uvc/f_uac1.c
@@ -0,0 +1,990 @@
+/*
+ * f_audio.c -- USB Audio class function driver
+  *
+ * Copyright (C) 2008 Bryan Wu <cooloney@kernel.org>
+ * Copyright (C) 2008 Analog Devices, Inc
+ * Copyright (c) 2015 Jorney Tu <qtu@ambarella.com>
+ *
+ * Enter bugs at http://blackfin.uclinux.org/
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/atomic.h>
+
+#include "u_uac1.h"
+
+static int generic_set_cmd(struct usb_audio_control *con, u8 cmd, int value);
+static int generic_get_cmd(struct usb_audio_control *con, u8 cmd);
+
+/*
+ * DESCRIPTORS ... most are static, but strings and full
+ * configuration descriptors are built on demand.
+ */
+
+/*
+ * We have two interfaces- AudioControl and AudioStreaming
+ * TODO: only supcard playback currently
+ */
+
+#define UAC_TERMINAL_MIC       	 	0x201
+#define INPUT_TERMINAL_ID	    	1
+#define FEATURE_UNIT_ID		    	2
+#define OUTPUT_TERMINAL_ID	    	3
+#define F_AUDIO_AC_INTERFACE		0
+#define F_AUDIO_AS_INTERFACE		1
+#define F_AUDIO_NUM_INTERFACES		2
+
+#define UAC_DT_AC_HEADER_LENGTH	    UAC_DT_AC_HEADER_SIZE(1)
+
+/* 1 input terminal, 1 output terminal and 1 feature unit */
+#define UAC_DT_TOTAL_LENGTH (UAC_DT_AC_HEADER_LENGTH + UAC_DT_INPUT_TERMINAL_SIZE \
+	                + UAC_DT_OUTPUT_TERMINAL_SIZE + UAC_DT_FEATURE_UNIT_SIZE(0))
+
+DECLARE_UAC_AC_HEADER_DESCRIPTOR(2);
+DECLARE_UAC_FEATURE_UNIT_DESCRIPTOR(0);
+DECLARE_UAC_FORMAT_TYPE_I_DISCRETE_DESC(1);
+
+static struct usb_interface_assoc_descriptor iad_desc = {
+	.bLength         = sizeof iad_desc,
+	.bDescriptorType = USB_DT_INTERFACE_ASSOCIATION,
+
+	.bFirstInterface = F_AUDIO_AC_INTERFACE,
+	.bInterfaceCount = F_AUDIO_NUM_INTERFACES,
+	.bFunctionClass  = USB_CLASS_AUDIO,
+	.bFunctionSubClass = 0x02,
+	.bFunctionProtocol = UAC_VERSION_1,
+};
+
+
+static struct usb_interface_descriptor ac_interface_desc = {
+	.bLength         =	USB_DT_INTERFACE_SIZE,
+	.bDescriptorType =	USB_DT_INTERFACE,
+	.bInterfaceNumber = F_AUDIO_AC_INTERFACE,
+	.bNumEndpoints    =	0,
+	.bInterfaceClass    =	USB_CLASS_AUDIO,
+	.bInterfaceSubClass =	USB_SUBCLASS_AUDIOCONTROL,
+	.bInterfaceProtocol =   0x00,
+};
+
+/* B.3.2  Class-Specific AC Interface Descriptor */
+static struct uac1_ac_header_descriptor_2 ac_header_desc = {
+	.bLength =		UAC_DT_AC_HEADER_LENGTH,
+	.bDescriptorType =	USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype =	UAC_HEADER,
+	.bcdADC =		__constant_cpu_to_le16(0x0100),
+	.wTotalLength =		__constant_cpu_to_le16(UAC_DT_TOTAL_LENGTH),
+	.bInCollection =	1,
+	.baInterfaceNr[0] = F_AUDIO_AS_INTERFACE, /*  AS  */
+};
+
+static struct uac_input_terminal_descriptor input_terminal_desc = {
+	.bLength =		UAC_DT_INPUT_TERMINAL_SIZE,
+	.bDescriptorType =	USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype =	UAC_INPUT_TERMINAL,
+	.bTerminalID =		INPUT_TERMINAL_ID,
+	.wTerminalType =	UAC_TERMINAL_MIC,
+	.bAssocTerminal =	0,
+	.wChannelConfig =	0x03, //
+	.iChannelNames  =   0x00,
+};
+
+static struct uac_feature_unit_descriptor_0 feature_unit_desc = {
+	.bLength		= UAC_DT_FEATURE_UNIT_SIZE(0),
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype	= UAC_FEATURE_UNIT,
+	.bUnitID		= FEATURE_UNIT_ID,
+	.bSourceID		= INPUT_TERMINAL_ID,
+	.bControlSize		= 2,
+	.bmaControls[0]		= (UAC_FU_MUTE | UAC_FU_VOLUME),
+};
+
+static struct usb_audio_control mute_control = {
+	.list = LIST_HEAD_INIT(mute_control.list),
+	.name = "Mute Control",
+	.type = UAC_FU_MUTE,
+	/* Todo: add real Mute control code */
+	.set = generic_set_cmd,
+	.get = generic_get_cmd,
+};
+
+static struct usb_audio_control volume_control = {
+	.list = LIST_HEAD_INIT(volume_control.list),
+	.name = "Volume Control",
+	.type = UAC_FU_VOLUME,
+	/* Todo: add real Volume control code */
+	.set = generic_set_cmd,
+	.get = generic_get_cmd,
+};
+
+static struct usb_audio_control_selector feature_unit = {
+	.list = LIST_HEAD_INIT(feature_unit.list),
+	.id = FEATURE_UNIT_ID,
+	.name = "Mute & Volume Control",
+	.type = UAC_FEATURE_UNIT,
+	.desc = (struct usb_descriptor_header *)&feature_unit_desc,
+};
+
+static struct uac1_output_terminal_descriptor output_terminal_desc = {
+	.bLength		= UAC_DT_OUTPUT_TERMINAL_SIZE,
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype	= UAC_OUTPUT_TERMINAL,
+	.bTerminalID		= OUTPUT_TERMINAL_ID,
+	.wTerminalType		= 0x0101,
+	.bAssocTerminal		= 0,
+	.bSourceID		= FEATURE_UNIT_ID,
+};
+
+/* B.4.1  Standard AS Interface Descriptor */
+static struct usb_interface_descriptor as_interface_alt_0_desc = {
+	.bLength =		USB_DT_INTERFACE_SIZE,
+	.bDescriptorType =	USB_DT_INTERFACE,
+	.bAlternateSetting =	0,
+	.bNumEndpoints =	0,
+	.bInterfaceClass =	USB_CLASS_AUDIO,
+	.bInterfaceSubClass =	USB_SUBCLASS_AUDIOSTREAMING,
+};
+
+static struct usb_interface_descriptor as_interface_alt_1_desc = {
+	.bLength =		USB_DT_INTERFACE_SIZE,
+	.bDescriptorType =	USB_DT_INTERFACE,
+	.bAlternateSetting =	1,
+	.bNumEndpoints =	1,
+	.bInterfaceClass =	USB_CLASS_AUDIO,
+	.bInterfaceSubClass =	USB_SUBCLASS_AUDIOSTREAMING,
+};
+
+/* B.4.2  Class-Specific AS Interface Descriptor */
+static struct uac1_as_header_descriptor as_header_desc = {
+	.bLength =		UAC_DT_AS_HEADER_SIZE,
+	.bDescriptorType =	USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype =	UAC_AS_GENERAL,
+	.bTerminalLink =	OUTPUT_TERMINAL_ID,  //
+	.bDelay =		1,
+	.wFormatTag =		UAC_FORMAT_TYPE_I_PCM,
+};
+
+static struct uac_format_type_i_discrete_descriptor_1 as_type_i_desc = {
+	.bLength =		UAC_FORMAT_TYPE_I_DISCRETE_DESC_SIZE(1),
+	.bDescriptorType =	USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype =	UAC_FORMAT_TYPE,
+	.bFormatType =		UAC_FORMAT_TYPE_I,
+	.bNrChannels = 1,  // One channel.
+	.bSubframeSize =	2,  // Two bytes per audio subframe.
+	.bBitResolution =	16, // 16 bits per sample.
+	.bSamFreqType =		1,  // One frequency supported
+};
+
+/* Standard ISO IN Endpoint Descriptor */
+static struct usb_endpoint_descriptor as_out_ep_desc  = {
+	.bLength =		USB_DT_ENDPOINT_AUDIO_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bEndpointAddress =	USB_DIR_IN,
+	.bmAttributes =		USB_ENDPOINT_SYNC_ASYNC
+				| USB_ENDPOINT_XFER_ISOC,
+	.wMaxPacketSize =	__constant_cpu_to_le16(UAC1_OUT_EP_MAX_PACKET_SIZE),
+#if UAC_EX_SOLUTION
+	.bInterval =		1,
+#else
+	.bInterval =		4,
+#endif
+};
+
+/* Class-specific AS ISO OUT Endpoint Descriptor */
+static struct uac_iso_endpoint_descriptor as_iso_out_desc = {
+	.bLength =		UAC_ISO_ENDPOINT_DESC_SIZE,
+	.bDescriptorType =	USB_DT_CS_ENDPOINT,
+	.bDescriptorSubtype =	UAC_EP_GENERAL,
+	.bmAttributes = 	1,
+	.bLockDelayUnits =	0x00,
+	.wLockDelay =	0x00,
+};
+
+static struct usb_descriptor_header *f_audio_desc[] = {
+    (struct usb_descriptor_header *)&iad_desc,
+	(struct usb_descriptor_header *)&ac_interface_desc,
+	(struct usb_descriptor_header *)&ac_header_desc,
+
+	(struct usb_descriptor_header *)&input_terminal_desc,
+	(struct usb_descriptor_header *)&output_terminal_desc,
+	(struct usb_descriptor_header *)&feature_unit_desc,
+
+	(struct usb_descriptor_header *)&as_interface_alt_0_desc,
+	(struct usb_descriptor_header *)&as_interface_alt_1_desc,
+	(struct usb_descriptor_header *)&as_header_desc,
+
+	(struct usb_descriptor_header *)&as_type_i_desc,
+
+	(struct usb_descriptor_header *)&as_out_ep_desc,
+	(struct usb_descriptor_header *)&as_iso_out_desc,
+	NULL,
+};
+
+enum {
+	STR_AC_IF,
+	STR_INPUT_TERMINAL,
+	STR_INPUT_TERMINAL_CH_NAMES,
+	STR_FEAT_DESC_0,
+	STR_OUTPUT_TERMINAL,
+	STR_AS_IF_ALT0,
+	STR_AS_IF_ALT1,
+};
+
+static struct usb_string strings_uac1[] = {
+	[STR_AC_IF].s = "AC Interface",
+	[STR_INPUT_TERMINAL].s = "Input terminal",
+	[STR_INPUT_TERMINAL_CH_NAMES].s = "Channels",
+	[STR_FEAT_DESC_0].s = "Volume control & mute",
+	[STR_OUTPUT_TERMINAL].s = "Output terminal",
+	[STR_AS_IF_ALT0].s = "AS Interface",
+	[STR_AS_IF_ALT1].s = "AS Interface",
+	{ },
+};
+
+static struct usb_gadget_strings str_uac1 = {
+	.language = 0x0409,	/* en-us */
+	.strings = strings_uac1,
+};
+
+static struct usb_gadget_strings *uac1_strings[] = {
+	&str_uac1,
+	NULL,
+};
+
+/*
+ * This function is an ALSA sound card following USB Audio Class Spec 1.0.
+ */
+
+/*-------------------------------------------------------------------------*/
+struct f_audio_buf {
+	u8 *buf;
+	int actual;
+	struct list_head list;
+};
+
+static void stream_clean_all(struct f_audio *audio)
+{
+	audio->frame[0].total_size = 0;
+	audio->frame[0].bused_size = 0;
+	audio->frame[0].nodata = 1;
+
+	audio->frame[1].total_size = 0;
+	audio->frame[1].bused_size = 0;
+	audio->frame[1].nodata = 1;
+}
+
+
+#if AUDIO_DEBUG_PLAY
+static int f_audio_fill_dbg(struct usb_request *req)
+{
+	static int offset = 0;
+	struct f_audio *audio = req->context;
+
+	req->length = UAC1_OUT_EP_MAX_PACKET_SIZE;
+
+	if(offset + req->length >= audio->debug_avail){
+		offset = 0;
+	}
+
+	memcpy(req->buf, audio->debug_frame + offset, req->length);
+
+	offset += req->length;
+	return 0;
+}
+#endif
+
+
+static void f_audio_fill(struct usb_request *req)
+{
+
+	struct f_audio *audio = req->context;
+	char *buffer = (char *)req->buf;
+	int len = UAC1_OUT_EP_MAX_PACKET_SIZE;
+
+	int current_used = audio->current_used;
+	int total_size = audio->frame[current_used].total_size;
+	int bused_size = audio->frame[current_used].bused_size;
+	char *mem = audio->frame[current_used].buf;
+
+	int unused = (current_used == 1) ? 0 : 1;
+
+	if(audio->frame[current_used].nodata){
+
+		if(!audio->frame[unused].total_size){
+			/* TODO: send NoData */
+			req->length = 0;
+			return;
+		} else {
+			/* TODO: if buffer B is prepared , switch buffer */
+
+			audio->current_used = unused;
+			current_used = audio->current_used;
+
+			total_size = audio->frame[current_used].total_size;
+			bused_size = audio->frame[current_used].bused_size;
+			mem = audio->frame[current_used].buf;
+		}
+	}
+
+	if(total_size <= 0){
+		printk("%s audio no frame \n",__func__);
+		return;
+	}
+
+	if(bused_size + len >= total_size){
+		req->length = total_size - bused_size;
+	}else{
+		req->length = len;
+	}
+
+	memcpy(buffer, mem + bused_size, req->length);
+
+	bused_size += req->length;
+	audio->frame[current_used].bused_size += req->length;
+
+	/* TODO:  buffer A is finished */
+	if (bused_size >= total_size){
+
+		audio->frame[current_used].total_size = 0;
+		audio->frame[current_used].bused_size = 0;
+		audio->frame[current_used].nodata = 1;
+	}
+	return;
+}
+
+static inline struct f_audio *func_to_audio(struct usb_function *f)
+{
+	return container_of(f, struct f_audio, card.func);
+}
+
+/*-------------------------------------------------------------------------*/
+
+static int f_audio_out_ep_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	struct f_audio *audio = req->context;
+	struct usb_composite_dev *cdev = audio->card.func.config->cdev;
+	int err;
+#if AUDIO_DEBUG_PLAY
+	f_audio_fill_dbg(req);
+#else
+	f_audio_fill(req);
+#endif
+	err = usb_ep_queue(ep, req, GFP_ATOMIC);
+	if (err)
+		ERROR(cdev, "%s queue req: %d\n", ep->name, err);
+
+	return 0;
+}
+
+static void f_audio_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	struct f_audio *audio = req->context;
+	int status = req->status;
+	u32 data = 0;
+	struct usb_ep *out_ep = audio->out_ep;
+
+	switch (status) {
+
+	case 0:				/* normal completion? */
+		if (ep == out_ep)
+			f_audio_out_ep_complete(ep, req);
+		else if (audio->set_con) {
+			memcpy(&data, req->buf, req->length);
+			audio->set_con->set(audio->set_con, audio->set_cmd,
+					le16_to_cpu(data));
+			audio->set_con = NULL;
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+static int audio_set_intf_req(struct usb_function *f,
+		const struct usb_ctrlrequest *ctrl)
+{
+	struct f_audio		*audio = func_to_audio(f);
+	struct usb_composite_dev *cdev = f->config->cdev;
+	struct usb_request	*req = cdev->req;
+	u8			id = ((le16_to_cpu(ctrl->wIndex) >> 8) & 0xFF);
+	u16			len = le16_to_cpu(ctrl->wLength);
+	u16			w_value = le16_to_cpu(ctrl->wValue);
+	u8			con_sel = (w_value >> 8) & 0xFF;
+	u8			cmd = (ctrl->bRequest & 0x0F);
+	struct usb_audio_control_selector *cs;
+	struct usb_audio_control *con;
+
+
+	DBG(cdev, "bRequest 0x%x, w_value 0x%04x, len %d, entity %d\n",
+			ctrl->bRequest, w_value, len, id);
+
+	list_for_each_entry(cs, &audio->cs, list) {
+		if (cs->id == id) {
+			list_for_each_entry(con, &cs->control, list) {
+				if (con->type == con_sel) {
+					audio->set_con = con;
+					break;
+				}
+			}
+			break;
+		}
+	}
+
+	audio->set_cmd = cmd;
+	req->context = audio;
+	req->complete = f_audio_complete;
+
+	return len;
+}
+
+static int audio_get_intf_req(struct usb_function *f,
+		const struct usb_ctrlrequest *ctrl)
+{
+	struct f_audio		*audio = func_to_audio(f);
+	struct usb_composite_dev *cdev = f->config->cdev;
+	struct usb_request	*req = cdev->req;
+	int			value = -EOPNOTSUPP;
+	u8			id = ((le16_to_cpu(ctrl->wIndex) >> 8) & 0xFF);
+	u16			len = le16_to_cpu(ctrl->wLength);
+	u16			w_value = le16_to_cpu(ctrl->wValue);
+	u8			con_sel = (w_value >> 8) & 0xFF;
+	u8			cmd = (ctrl->bRequest & 0x0F);
+	struct usb_audio_control_selector *cs;
+	struct usb_audio_control *con;
+
+
+	DBG(cdev, "bRequest 0x%x, w_value 0x%04x, len %d, entity %d\n",
+			ctrl->bRequest, w_value, len, id);
+
+	list_for_each_entry(cs, &audio->cs, list) {
+		if (cs->id == id) {
+			list_for_each_entry(con, &cs->control, list) {
+				if (con->type == con_sel && con->get) {
+					value = con->get(con, cmd);
+					break;
+				}
+			}
+			break;
+		}
+	}
+
+	req->context = audio;
+	req->complete = f_audio_complete;
+	len = min_t(size_t, sizeof(value), len);
+	memcpy(req->buf, &value, len);
+
+	return len;
+}
+
+static int audio_set_endpoint_req(struct usb_function *f,
+		const struct usb_ctrlrequest *ctrl)
+{
+	struct usb_composite_dev *cdev = f->config->cdev;
+	int			value = -EOPNOTSUPP;
+	u16			ep = le16_to_cpu(ctrl->wIndex);
+	u16			len = le16_to_cpu(ctrl->wLength);
+	u16			w_value = le16_to_cpu(ctrl->wValue);
+
+
+	DBG(cdev, "bRequest 0x%x, w_value 0x%04x, len %d, endpoint %d\n",
+			ctrl->bRequest, w_value, len, ep);
+
+	switch (ctrl->bRequest) {
+	case UAC_SET_CUR:
+		value = len;
+		break;
+
+	case UAC_SET_MIN:
+		break;
+
+	case UAC_SET_MAX:
+		break;
+
+	case UAC_SET_RES:
+		break;
+
+	case UAC_SET_MEM:
+		break;
+
+	default:
+		break;
+	}
+
+	return value;
+}
+
+static int audio_get_endpoint_req(struct usb_function *f,
+		const struct usb_ctrlrequest *ctrl)
+{
+	struct usb_composite_dev *cdev = f->config->cdev;
+	int value = -EOPNOTSUPP;
+	u8 ep = ((le16_to_cpu(ctrl->wIndex) >> 8) & 0xFF);
+	u16 len = le16_to_cpu(ctrl->wLength);
+	u16 w_value = le16_to_cpu(ctrl->wValue);
+
+	DBG(cdev, "bRequest 0x%x, w_value 0x%04x, len %d, endpoint %d\n",
+			ctrl->bRequest, w_value, len, ep);
+
+	switch (ctrl->bRequest) {
+	case UAC_GET_CUR:
+	case UAC_GET_MIN:
+	case UAC_GET_MAX:
+	case UAC_GET_RES:
+		value = len;
+		break;
+	case UAC_GET_MEM:
+		break;
+	default:
+		break;
+	}
+
+	return value;
+}
+
+static int
+f_audio_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)
+{
+	struct usb_composite_dev *cdev = f->config->cdev;
+	struct usb_request	*req = cdev->req;
+	int			value = -EOPNOTSUPP;
+	u16			w_index = le16_to_cpu(ctrl->wIndex);
+	u16			w_value = le16_to_cpu(ctrl->wValue);
+	u16			w_length = le16_to_cpu(ctrl->wLength);
+
+	/* composite driver infrastructure handles everything; interface
+	 * activation uses set_alt().
+	 */
+
+	switch (ctrl->bRequestType) {
+	case USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE:
+		value = audio_set_intf_req(f, ctrl);
+		break;
+
+	case USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE:
+		value = audio_get_intf_req(f, ctrl);
+		break;
+
+	case USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_ENDPOINT:
+		value = audio_set_endpoint_req(f, ctrl);
+		break;
+
+	case USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_ENDPOINT:
+		value = audio_get_endpoint_req(f, ctrl);
+		break;
+
+	default:
+		ERROR(cdev, "invalid control req%02x.%02x v%04x i%04x l%d\n",
+			ctrl->bRequestType, ctrl->bRequest,
+			w_value, w_index, w_length);
+	}
+
+	/* respond with data transfer or status phase? */
+	if (value >= 0) {
+		DBG(cdev, "audio req%02x.%02x v%04x i%04x l%d\n",
+			ctrl->bRequestType, ctrl->bRequest,
+			w_value, w_index, w_length);
+		req->zero = 0;
+		req->length = value;
+		value = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);
+		if (value < 0)
+			ERROR(cdev, "audio response on err %d\n", value);
+	}
+
+	/* device either stalls (value < 0) or reports success */
+	return value;
+}
+
+static void free_ep(struct usb_ep *ep)
+{
+	int i;
+	struct f_audio *audio = ep->driver_data;
+
+	if (!audio || !audio->ep_enabled)
+		return;
+
+	audio->ep_enabled = false;
+
+	for (i = 0; i < UAC1_REQ_COUNT; i++) {
+		if (audio->req[i]) {
+			usb_ep_dequeue(ep, audio->req[i]);
+			kfree(audio->req[i]->buf);
+			usb_ep_free_request(ep, audio->req[i]);
+			audio->req[i] = NULL;
+		}
+	}
+	printk("%s Disable\n", ep->name);
+	if (usb_ep_disable(ep))
+		printk("%s:%d Error!\n", __func__, __LINE__);
+}
+
+static int f_audio_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
+{
+	struct f_audio		*audio = func_to_audio(f);
+	struct usb_composite_dev *cdev = f->config->cdev;
+	struct usb_ep *out_ep = audio->out_ep;
+	struct usb_request *req;
+	struct f_uac1_opts *opts;
+	int req_buf_size, req_count, audio_buf_size;
+	int i = 0, err = 0;
+
+	INFO(cdev, "%s(%u, %u)\n", __func__,intf, alt);
+	DBG(cdev, "intf %d, alt %d\n", intf, alt);
+
+	opts = container_of(f->fi, struct f_uac1_opts, func_inst);
+	req_buf_size = opts->req_buf_size;
+	req_count = opts->req_count;
+	audio_buf_size = opts->audio_buf_size;
+
+	if (intf == 1) {
+		if (alt == 1) {
+			err = config_ep_by_speed(cdev->gadget, f, out_ep);
+			if (err)
+				return err;
+
+			usb_ep_enable(out_ep);
+			out_ep->driver_data = audio;
+
+
+			/*
+			 * allocate a bunch of read buffers
+			 * and queue them all at once.
+			 */
+			for (i = 0; i < req_count && err == 0; i++) {
+				req = usb_ep_alloc_request(out_ep, GFP_ATOMIC);
+				if (req) {
+					req->buf = kzalloc(req_buf_size,
+							GFP_ATOMIC);
+					if (req->buf) {
+						req->length = req_buf_size;
+						req->context = audio;
+						req->complete =
+							f_audio_complete;
+
+						audio->req[i] = req;
+#if AUDIO_DEBUG_PLAY
+						f_audio_fill_dbg(req);
+#else
+						f_audio_fill(req);
+#endif
+						err = usb_ep_queue(out_ep,
+							req, GFP_ATOMIC);
+						if (err)
+							ERROR(cdev,
+							"%s queue req: %d\n",
+							out_ep->name, err);
+					} else
+						err = -ENOMEM;
+				} else
+					err = -ENOMEM;
+			}
+
+			audio->ep_enabled = true;
+			stream_clean_all(audio);
+		} else {
+			free_ep(out_ep);
+		}
+	}
+
+	return err;
+}
+
+static void f_audio_disable(struct usb_function *f)
+{
+	return;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static void f_audio_build_desc(struct f_audio *audio)
+{
+	u8 *sam_freq;
+	int rate;
+
+	/* Set channel numbers */
+	input_terminal_desc.bNrChannels = 1;
+	as_type_i_desc.bNrChannels = 1;
+	rate = 48000;
+
+	/* Set sample rates */
+	sam_freq = as_type_i_desc.tSamFreq[0];
+	memcpy(sam_freq, &rate, 3);
+
+	/* Todo: Set Sample bits and other parameters */
+
+	return;
+}
+
+/* audio function driver setup/binding */
+static int
+f_audio_bind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct usb_composite_dev *cdev = c->cdev;
+	struct f_audio		*audio = func_to_audio(f);
+	struct usb_string	*us;
+	int			status;
+	struct usb_ep		*ep = NULL;
+	struct f_uac1_opts	*audio_opts;
+
+	audio_opts = container_of(f->fi, struct f_uac1_opts, func_inst);
+	audio->card.gadget = c->cdev->gadget;
+	/* set up ASLA audio devices */
+	us = usb_gstrings_attach(cdev, uac1_strings, ARRAY_SIZE(strings_uac1));
+	if (IS_ERR(us))
+		return PTR_ERR(us);
+
+	ac_interface_desc.iInterface = us[STR_AC_IF].id;
+	input_terminal_desc.iTerminal = us[STR_INPUT_TERMINAL].id;
+	input_terminal_desc.iChannelNames = us[STR_INPUT_TERMINAL_CH_NAMES].id;
+	feature_unit_desc.iFeature = us[STR_FEAT_DESC_0].id;
+	output_terminal_desc.iTerminal = us[STR_OUTPUT_TERMINAL].id;
+	as_interface_alt_0_desc.iInterface = us[STR_AS_IF_ALT0].id;
+	as_interface_alt_1_desc.iInterface = us[STR_AS_IF_ALT1].id;
+
+
+	f_audio_build_desc(audio);
+
+	/* allocate instance-specific interface IDs, and patch descriptors */
+	status = usb_interface_id(c, f);
+	if (status < 0)
+		goto fail;
+	ac_interface_desc.bInterfaceNumber = status;
+
+	status = usb_interface_id(c, f);
+	if (status < 0)
+		goto fail;
+	as_interface_alt_0_desc.bInterfaceNumber = status;
+	as_interface_alt_1_desc.bInterfaceNumber = status;
+
+	status = -ENODEV;
+
+	/* allocate instance-specific endpoints */
+	ep = usb_ep_autoconfig(cdev->gadget, &as_out_ep_desc);
+	if (!ep)
+		goto fail;
+	audio->out_ep = ep;
+	audio->out_ep->desc = &as_out_ep_desc;
+	ep->driver_data = cdev;	/* claim */
+
+	status = -ENOMEM;
+
+	/* copy descriptors, and track endpoint copies */
+	status = usb_assign_descriptors(f, f_audio_desc, f_audio_desc, NULL);
+	if (status)
+		goto fail;
+	return 0;
+
+fail:
+	if (ep)
+		ep->driver_data = NULL;
+	return status;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static int generic_set_cmd(struct usb_audio_control *con, u8 cmd, int value)
+{
+	con->data[cmd] = value;
+
+	return 0;
+}
+
+static int generic_get_cmd(struct usb_audio_control *con, u8 cmd)
+{
+	return con->data[cmd];
+}
+
+/* Todo: add more control selecotor dynamically */
+static int control_selector_init(struct f_audio *audio)
+{
+	INIT_LIST_HEAD(&audio->cs);
+	list_add(&feature_unit.list, &audio->cs);
+
+	INIT_LIST_HEAD(&feature_unit.control);
+	list_add(&mute_control.list, &feature_unit.control);
+	list_add(&volume_control.list, &feature_unit.control);
+
+	volume_control.data[UAC__CUR] = 0xffc0;
+	volume_control.data[UAC__MIN] = 0xe3a0;
+	volume_control.data[UAC__MAX] = 0xfff0;
+	volume_control.data[UAC__RES] = 0x0030;
+
+	return 0;
+}
+
+static inline struct f_uac1_opts *to_f_uac1_opts(struct config_item *item)
+{
+	return container_of(to_config_group(item), struct f_uac1_opts,
+			    func_inst.group);
+}
+
+CONFIGFS_ATTR_STRUCT(f_uac1_opts);
+CONFIGFS_ATTR_OPS(f_uac1_opts);
+
+static void f_uac1_attr_release(struct config_item *item)
+{
+	struct f_uac1_opts *opts = to_f_uac1_opts(item);
+
+	usb_put_function_instance(&opts->func_inst);
+}
+
+static struct configfs_item_operations f_uac1_item_ops = {
+	.release	= f_uac1_attr_release,
+	.show_attribute	= f_uac1_opts_attr_show,
+	.store_attribute = f_uac1_opts_attr_store,
+};
+
+#define UAC1_INT_ATTRIBUTE(name)					\
+static ssize_t f_uac1_opts_##name##_show(struct f_uac1_opts *opts,	\
+					 char *page)			\
+{									\
+	int result;							\
+									\
+	mutex_lock(&opts->lock);					\
+	result = sprintf(page, "%u\n", opts->name);			\
+	mutex_unlock(&opts->lock);					\
+									\
+	return result;							\
+}									\
+									\
+static ssize_t f_uac1_opts_##name##_store(struct f_uac1_opts *opts,	\
+					  const char *page, size_t len)	\
+{									\
+	int ret;							\
+	u32 num;							\
+									\
+	mutex_lock(&opts->lock);					\
+	if (opts->refcnt) {						\
+		ret = -EBUSY;						\
+		goto end;						\
+	}								\
+									\
+	ret = kstrtou32(page, 0, &num);					\
+	if (ret)							\
+		goto end;						\
+									\
+	opts->name = num;						\
+	ret = len;							\
+									\
+end:									\
+	mutex_unlock(&opts->lock);					\
+	return ret;							\
+}									\
+									\
+static struct f_uac1_opts_attribute f_uac1_opts_##name =		\
+	__CONFIGFS_ATTR(name, S_IRUGO | S_IWUSR,			\
+			f_uac1_opts_##name##_show,			\
+			f_uac1_opts_##name##_store)
+
+UAC1_INT_ATTRIBUTE(req_buf_size);
+UAC1_INT_ATTRIBUTE(req_count);
+
+static struct configfs_attribute *f_uac1_attrs[] = {
+	&f_uac1_opts_req_buf_size.attr,
+	&f_uac1_opts_req_count.attr,
+	NULL,
+};
+
+static struct config_item_type f_uac1_func_type = {
+	.ct_item_ops	= &f_uac1_item_ops,
+	.ct_attrs	= f_uac1_attrs,
+	.ct_owner	= THIS_MODULE,
+};
+
+static void f_audio_free_inst(struct usb_function_instance *f)
+{
+	struct f_uac1_opts *opts;
+
+	opts = container_of(f, struct f_uac1_opts, func_inst);
+	kfree(opts);
+}
+
+static struct usb_function_instance *f_audio_alloc_inst(void)
+{
+	struct f_uac1_opts *opts;
+
+	opts = kzalloc(sizeof(*opts), GFP_KERNEL);
+	if (!opts)
+		return ERR_PTR(-ENOMEM);
+
+	mutex_init(&opts->lock);
+	opts->func_inst.free_func_inst = f_audio_free_inst;
+
+	config_group_init_type_name(&opts->func_inst.group, "",
+				    &f_uac1_func_type);
+
+	opts->req_buf_size = UAC1_OUT_EP_MAX_PACKET_SIZE;
+	opts->req_count = UAC1_REQ_COUNT;
+	return &opts->func_inst;
+}
+
+static void f_audio_free(struct usb_function *f)
+{
+	struct f_audio *audio = func_to_audio(f);
+	struct f_uac1_opts *opts;
+
+	opts = container_of(f->fi, struct f_uac1_opts, func_inst);
+	kfree(audio);
+	mutex_lock(&opts->lock);
+	--opts->refcnt;
+	mutex_unlock(&opts->lock);
+}
+
+static void f_audio_unbind(struct usb_configuration *c, struct usb_function *f)
+{
+	usb_free_all_descriptors(f);
+}
+
+static struct usb_function *f_audio_alloc(struct usb_function_instance *fi)
+{
+	struct f_audio *audio;
+	struct f_uac1_opts *opts;
+	struct task_struct *t;
+
+	/* allocate and initialize one new instance */
+	audio = kzalloc(sizeof(*audio), GFP_KERNEL);
+	if (!audio)
+		return ERR_PTR(-ENOMEM);
+
+	audio->card.func.name = "g_audio";
+
+	opts = container_of(fi, struct f_uac1_opts, func_inst);
+	mutex_lock(&opts->lock);
+	++opts->refcnt;
+
+	audio->card.func.bind = f_audio_bind;
+	audio->card.func.unbind = f_audio_unbind;
+	audio->card.func.set_alt = f_audio_set_alt;
+	audio->card.func.setup = f_audio_setup;
+	audio->card.func.disable = f_audio_disable;
+	audio->card.func.free_func = f_audio_free;
+	audio->ep_enabled = false;
+
+	control_selector_init(audio);
+
+	if (gaudio_setup(&audio->card))
+		goto error;
+
+	audio->current_used = -1;
+
+	t = kthread_create(audio_kthread_get_frame, audio, "uac");
+	if (IS_ERR(t)) {
+		printk("%s: failed to create kernel_thread uac (%ld)!\n",
+				__func__, PTR_ERR(t));
+		goto error;
+	}
+	wake_up_process(t);
+
+
+	return &audio->card.func;
+error:
+	kfree(audio);
+	return NULL;
+}
+
+DECLARE_USB_FUNCTION_INIT(uac1, f_audio_alloc_inst, f_audio_alloc);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Bryan Wu");
diff --git a/drivers/uvc_camera/uvc/f_uvc.c b/drivers/uvc_camera/uvc/f_uvc.c
new file mode 100644
index 0000000..f128796
--- /dev/null
+++ b/drivers/uvc_camera/uvc/f_uvc.c
@@ -0,0 +1,1197 @@
+/*
+ *	uvc_gadget.c  --  USB Video Class Gadget driver
+ *
+ *	Copyright (C) 2009-2010
+ *	    Laurent Pinchart (laurent.pinchart@ideasonboard.com)
+ * Copyright (C) 2015
+ * 		Jorney Tu (qtu@ambarella.com)
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/string.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+#include <linux/usb/video.h>
+#include <linux/vmalloc.h>
+#include <linux/wait.h>
+
+
+#include "u_uvc.h"
+#include "uvc.h"
+#include "uvc_configfs.h"
+#include "uvc_stream.h"
+
+
+#include "uvc_gadget.c"
+
+
+unsigned int uvc_gadget_trace_param;
+
+/* --------------------------------------------------------------------------
+ * Function descriptors
+ */
+
+/* string IDs are assigned dynamically */
+
+#define UVC_STRING_CONTROL_IDX			0
+#define UVC_STRING_STREAMING_IDX		1
+
+static struct usb_string uvc_en_us_strings[] = {
+	[UVC_STRING_CONTROL_IDX].s = "UVC Camera",
+	[UVC_STRING_STREAMING_IDX].s = "Video Streaming",
+	{  }
+};
+
+static struct usb_gadget_strings uvc_stringtab = {
+	.language = 0x0409,	/* en-us */
+	.strings = uvc_en_us_strings,
+};
+
+static struct usb_gadget_strings *uvc_function_strings[] = {
+	&uvc_stringtab,
+	NULL,
+};
+
+#define UVC_INTF_VIDEO_CONTROL			2
+#define UVC_INTF_VIDEO_STREAMING		3
+
+#define UVC_STATUS_MAX_PACKET_SIZE		16	/* 16 bytes status */
+
+static struct usb_interface_assoc_descriptor uvc_iad = {
+	.bLength		= sizeof(uvc_iad),
+	.bDescriptorType	= USB_DT_INTERFACE_ASSOCIATION,
+	.bFirstInterface	= 0,
+	.bInterfaceCount	= 2,
+	.bFunctionClass		= USB_CLASS_VIDEO,
+	.bFunctionSubClass	= UVC_SC_VIDEO_INTERFACE_COLLECTION,
+	.bFunctionProtocol	= 0x00,
+	.iFunction		= 0,
+};
+
+static struct usb_interface_descriptor uvc_control_intf = {
+	.bLength		= USB_DT_INTERFACE_SIZE,
+	.bDescriptorType	= USB_DT_INTERFACE,
+	.bInterfaceNumber	= UVC_INTF_VIDEO_CONTROL,
+	.bAlternateSetting	= 0,
+	.bNumEndpoints		= 1,
+	.bInterfaceClass	= USB_CLASS_VIDEO,
+	.bInterfaceSubClass	= UVC_SC_VIDEOCONTROL,
+	.bInterfaceProtocol	= 0x00,
+	.iInterface		= 0,
+};
+
+static struct usb_endpoint_descriptor uvc_control_ep = {
+	.bLength		= USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType	= USB_DT_ENDPOINT,
+	.bEndpointAddress	= USB_DIR_IN,
+	.bmAttributes		= USB_ENDPOINT_XFER_INT,
+	.wMaxPacketSize		= cpu_to_le16(UVC_STATUS_MAX_PACKET_SIZE),
+	.bInterval		= 8,
+};
+
+static struct usb_ss_ep_comp_descriptor uvc_ss_control_comp = {
+	.bLength		= sizeof(uvc_ss_control_comp),
+	.bDescriptorType	= USB_DT_SS_ENDPOINT_COMP,
+	/* The following 3 values can be tweaked if necessary. */
+	.bMaxBurst		= 0,
+	.bmAttributes		= 0,
+	.wBytesPerInterval	= cpu_to_le16(UVC_STATUS_MAX_PACKET_SIZE),
+};
+
+static struct uvc_control_endpoint_descriptor uvc_control_cs_ep = {
+	.bLength		= UVC_DT_CONTROL_ENDPOINT_SIZE,
+	.bDescriptorType	= USB_DT_CS_ENDPOINT,
+	.bDescriptorSubType	= UVC_EP_INTERRUPT,
+	.wMaxTransferSize	= cpu_to_le16(UVC_STATUS_MAX_PACKET_SIZE),
+};
+
+static struct usb_interface_descriptor uvc_streaming_intf_alt0 = {
+	.bLength		= USB_DT_INTERFACE_SIZE,
+	.bDescriptorType	= USB_DT_INTERFACE,
+	.bInterfaceNumber	= UVC_INTF_VIDEO_STREAMING,
+	.bAlternateSetting	= 0,
+	.bNumEndpoints		= 0,
+	.bInterfaceClass	= USB_CLASS_VIDEO,
+	.bInterfaceSubClass	= UVC_SC_VIDEOSTREAMING,
+	.bInterfaceProtocol	= 0x00,
+	.iInterface		= 0,
+};
+
+static struct usb_interface_descriptor uvc_streaming_intf_alt1 = {
+	.bLength		= USB_DT_INTERFACE_SIZE,
+	.bDescriptorType	= USB_DT_INTERFACE,
+	.bInterfaceNumber	= UVC_INTF_VIDEO_STREAMING,
+	.bAlternateSetting	= 1,
+	.bNumEndpoints		= 1,
+	.bInterfaceClass	= USB_CLASS_VIDEO,
+	.bInterfaceSubClass	= UVC_SC_VIDEOSTREAMING,
+	.bInterfaceProtocol	= 0x00,
+	.iInterface		= 0,
+};
+
+static struct usb_endpoint_descriptor uvc_fs_streaming_ep = {
+	.bLength		= USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType	= USB_DT_ENDPOINT,
+	.bEndpointAddress	= USB_DIR_IN,
+	.bmAttributes		= USB_ENDPOINT_SYNC_ASYNC
+				| USB_ENDPOINT_XFER_ISOC,
+	/* The wMaxPacketSize and bInterval values will be initialized from
+	 * module parameters.
+	 */
+};
+
+static struct usb_endpoint_descriptor uvc_hs_streaming_ep = {
+	.bLength		= USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType	= USB_DT_ENDPOINT,
+	.bEndpointAddress	= USB_DIR_IN,
+	.bmAttributes		= USB_ENDPOINT_SYNC_ASYNC
+				| USB_ENDPOINT_XFER_ISOC,
+	/* The wMaxPacketSize and bInterval values will be initialized from
+	 * module parameters.
+	 */
+};
+
+static struct usb_endpoint_descriptor uvc_ss_streaming_ep = {
+	.bLength		= USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType	= USB_DT_ENDPOINT,
+
+	.bEndpointAddress	= USB_DIR_IN,
+	.bmAttributes		= USB_ENDPOINT_SYNC_ASYNC
+				| USB_ENDPOINT_XFER_ISOC,
+	/* The wMaxPacketSize and bInterval values will be initialized from
+	 * module parameters.
+	 */
+};
+
+static struct usb_ss_ep_comp_descriptor uvc_ss_streaming_comp = {
+	.bLength		= sizeof(uvc_ss_streaming_comp),
+	.bDescriptorType	= USB_DT_SS_ENDPOINT_COMP,
+	/* The bMaxBurst, bmAttributes and wBytesPerInterval values will be
+	 * initialized from module parameters.
+	 */
+};
+
+static const struct usb_descriptor_header * const uvc_fs_streaming[] = {
+	(struct usb_descriptor_header *) &uvc_streaming_intf_alt1,
+	(struct usb_descriptor_header *) &uvc_fs_streaming_ep,
+	NULL,
+};
+
+static const struct usb_descriptor_header * const uvc_hs_streaming[] = {
+	(struct usb_descriptor_header *) &uvc_streaming_intf_alt1,
+	(struct usb_descriptor_header *) &uvc_hs_streaming_ep,
+	NULL,
+};
+
+static const struct usb_descriptor_header * const uvc_ss_streaming[] = {
+	(struct usb_descriptor_header *) &uvc_streaming_intf_alt1,
+	(struct usb_descriptor_header *) &uvc_ss_streaming_ep,
+	(struct usb_descriptor_header *) &uvc_ss_streaming_comp,
+	NULL,
+};
+
+void uvc_set_trace_param(unsigned int trace)
+{
+	uvc_gadget_trace_param = trace;
+}
+EXPORT_SYMBOL(uvc_set_trace_param);
+
+/* --------------------------------------------------------------------------
+ * Control requests
+ */
+#ifdef FMT_MJPEG
+
+
+static void uvc_fill_req_mjpg(struct usb_request *req)
+{
+	struct uvc_device *uvc = req->context;
+	char *buffer = (char *)req->buf;
+	int len = uvc->MaxPacketSize - 2;
+
+	int current_used = uvc->current_used;
+	int total_size = uvc->frame[current_used].total_size;
+	int bused_size = uvc->frame[current_used].bused_size;
+	char *mem = uvc->frame[current_used].buf;
+
+	int unused = (current_used == 1) ? 0 : 1;
+
+	if(uvc->delay++ < UVC_DELAY){
+		req->length = 0;
+		return;
+	}
+
+	if(uvc->frame[current_used].nodata){
+
+		if(!uvc->frame[unused].total_size){
+			/* TODO: send NoData */
+			req->length = 0;
+			return;
+		} else {
+			/* TODO: if buffer B is prepared , switch buffer */
+			uvc->current_used = unused;
+			current_used = uvc->current_used;
+
+			total_size = uvc->frame[current_used].total_size;
+			bused_size = uvc->frame[current_used].bused_size;
+			mem = uvc->frame[current_used].buf;
+		}
+	}
+
+	if(total_size <= 0){
+		printk("%s no frame \n",__func__);
+		return;
+	}
+
+	if(!bused_size){
+		uvc->fid ^= 1;
+	}
+
+	buffer[0] = 2;
+	buffer[1] = 0x80 | uvc->fid;
+
+	if(bused_size + len >= total_size){
+		req->length = total_size - bused_size + 2;
+		buffer[1] |= (1 << 1);
+	}else{
+		req->length = uvc->MaxPacketSize;
+	}
+
+	memcpy(buffer + 2, mem + bused_size, req->length - 2);
+
+	bused_size += req->length - 2;
+	uvc->frame[current_used].bused_size += req->length - 2;
+
+	/* TODO:  buffer A is finished */
+	if (bused_size >= total_size){
+
+		uvc->frame[current_used].total_size = 0;
+		uvc->frame[current_used].bused_size = 0;
+		uvc->frame[current_used].nodata = 1;
+	}
+}
+
+#else
+static void uvc_fill_req_yuv(struct usb_request *req)
+{
+	static char i = 0;
+	static int cnt = 0;
+	struct uvc_device *uvc = req->context;
+	char *buffer = (char *)req->buf;
+	int len = uvc->MaxPacketSize - 2;
+
+
+	buffer[0] = 2;
+	buffer[1] = 0x80 | uvc->fid;
+
+
+	if(cnt + len>= FRAME_SIZE){
+		req->length = FRAME_SIZE - cnt + 2;
+	}else{
+		req->length = uvc->MaxPacketSize;
+	}
+
+	if(!cnt){
+		i++;
+		uvc->fid ^= 1;
+	}
+
+	memset(buffer + 2, i, req->length - 2);
+
+	cnt += req->length - 2;
+
+	if(cnt >= FRAME_SIZE)
+		cnt = 0;
+}
+#endif
+
+static void
+uvc_function_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	int ret;
+
+	struct uvc_device *uvc = req->context;
+
+	if(uvc->state != UVC_STATE_STREAMING)
+		return;
+
+#ifndef FMT_MJPEG
+	uvc_fill_req_yuv(req);
+#else
+	uvc_fill_req_mjpg(req);
+#endif
+
+	ret = usb_ep_queue(ep, req, GFP_ATOMIC);
+	if (ret < 0) {
+		printk(KERN_INFO "Failed to queue request (%d)\n", ret);
+	}
+}
+
+static void
+uvc_function_ep0_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	struct uvc_device *uvc = req->context;
+
+	if (uvc->event_setup_out) {
+		uvc->event_setup_out = 0;
+	}
+}
+
+
+static int
+uvc_video_free_requests(struct uvc_device *uvc)
+{
+	unsigned int i;
+
+	for (i = 0; i < UVC_NUM_REQUESTS; ++i) {
+		if (uvc->req[i]) {
+			usb_ep_free_request(uvc->ep, uvc->req[i]);
+			uvc->req[i] = NULL;
+		}
+
+		if (uvc->req_buffer[i]) {
+			kfree(uvc->req_buffer[i]);
+			uvc->req_buffer[i] = NULL;
+		}
+	}
+
+	INIT_LIST_HEAD(&uvc->req_free);
+	return 0;
+}
+
+static int uvc_video_malloc_requests(struct uvc_device *uvc)
+{
+	int i, req_size;
+
+	req_size = uvc->MaxPacketSize;
+
+	for (i = 0; i < UVC_NUM_REQUESTS; ++i) {
+		uvc->req_buffer[i] = kmalloc(req_size, GFP_KERNEL);
+		if (uvc->req_buffer[i] == NULL)
+			goto error;
+
+		uvc->req[i] = usb_ep_alloc_request(uvc->ep, GFP_KERNEL);
+		if (uvc->req[i] == NULL)
+			goto error;
+
+		uvc->req[i]->buf = uvc->req_buffer[i];
+		uvc->req[i]->length = 0;
+		uvc->req[i]->complete = uvc_function_complete;
+		uvc->req[i]->context = uvc;
+
+		list_add_tail(&uvc->req[i]->list, &uvc->req_free);
+	}
+	return 0;
+error:
+	uvc_video_free_requests(uvc);
+	return -ENOMEM;
+
+}
+
+static int
+uvc_send_response(struct uvc_device *uvc, struct usb_request *req)
+{
+	struct usb_composite_dev *cdev = uvc->func.config->cdev;
+
+	if (req->length < 0)
+		return usb_ep_set_halt(cdev->gadget->ep0);
+
+	req->length = min_t(unsigned int, uvc->event_length, req->length);
+	req->zero = req->length < uvc->event_length;
+
+	return usb_ep_queue(cdev->gadget->ep0, req, GFP_KERNEL);
+}
+
+static int
+uvc_function_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)
+{
+	struct uvc_device *uvc = to_uvc(f);
+	struct usb_request *req = uvc->control_req;
+
+
+	if ((ctrl->bRequestType & USB_TYPE_MASK) != USB_TYPE_CLASS) {
+		INFO(f->config->cdev, "invalid request type\n");
+		return -EINVAL;
+	}
+
+	/* Stall too big requests. */
+	if (le16_to_cpu(ctrl->wLength) > UVC_MAX_REQUEST_SIZE)
+		return -EINVAL;
+
+	/* Tell the complete callback to generate an event for the next request
+	 * that will be enqueued by UVCIOC_SEND_RESPONSE.
+	 */
+	uvc->event_setup_out = !(ctrl->bRequestType & USB_DIR_IN);
+	uvc->event_length = le16_to_cpu(ctrl->wLength);
+
+	uvc_events_process_setup(ctrl, req);
+
+	uvc_send_response(uvc, req);
+
+	return 0;
+}
+
+void uvc_function_setup_continue(struct uvc_device *uvc)
+{
+	struct usb_composite_dev *cdev = uvc->func.config->cdev;
+
+	usb_composite_setup_continue(cdev);
+}
+
+static int
+uvc_function_get_alt(struct usb_function *f, unsigned interface)
+{
+	struct uvc_device *uvc = to_uvc(f);
+
+	INFO(f->config->cdev, "uvc_function_get_alt(%u)\n", interface);
+
+	if (interface == uvc->control_intf)
+		return 0;
+	else if (interface != uvc->streaming_intf)
+		return -EINVAL;
+	else
+		return uvc->ep->driver_data ? 1 : 0;
+}
+
+static int uvc_enable_queue(struct uvc_device *uvc)
+{
+	struct usb_request *req;
+	int ret;
+	uvc->fid = 1;
+
+	uvc_video_malloc_requests(uvc);
+
+	udelay(100);
+
+	while(1){
+
+		if(list_empty(&uvc->req_free)){
+			return 0;
+		}
+
+		req = list_first_entry(&uvc->req_free, struct usb_request,
+					list);
+		list_del(&req->list);
+
+#ifndef FMT_MJPEG
+		uvc_fill_req_yuv(req);
+#else
+		uvc_fill_req_mjpg(req);
+#endif
+
+		ret = usb_ep_queue(uvc->ep, req, GFP_ATOMIC);
+		if (ret < 0) {
+			printk(KERN_INFO "Failed to queue request (%d)\n", ret);
+			break;
+		}
+	}
+	return 0;
+}
+
+static int uvc_enable_dqueue(struct uvc_device *uvc)
+{
+	int i;
+	for (i = 0; i < UVC_NUM_REQUESTS; ++i) {
+		if (uvc->req[i])
+			usb_ep_dequeue(uvc->ep, uvc->req[i]);
+	}
+
+	uvc_video_free_requests(uvc);
+	return 0;
+}
+
+static int
+uvc_function_set_alt(struct usb_function *f, unsigned interface, unsigned alt)
+{
+	struct uvc_device *uvc = to_uvc(f);
+	struct usb_composite_dev *cdev = f->config->cdev;
+	int ret;
+
+	INFO(cdev, "uvc_function_set_alt(%u, %u)\n", interface, alt);
+
+	if (interface == uvc->control_intf) {
+		if (alt)
+			return -EINVAL;
+
+		if (uvc->control_ep->driver_data) {
+			INFO(cdev, "reset UVC Control\n");
+			usb_ep_disable(uvc->control_ep);
+			uvc->control_ep->driver_data = NULL;
+		}
+
+		if (!uvc->control_ep->desc)
+			if (config_ep_by_speed(cdev->gadget, f, uvc->control_ep))
+				return -EINVAL;
+
+		usb_ep_enable(uvc->control_ep);
+		uvc->control_ep->driver_data = uvc;
+
+		if (uvc->state == UVC_STATE_DISCONNECTED) {
+
+			uvc->state = UVC_STATE_CONNECTED;
+		}
+
+		return 0;
+	}
+
+	if (interface != uvc->streaming_intf)
+		return -EINVAL;
+
+	/* TODO
+	if (usb_endpoint_xfer_bulk(&uvc->desc.vs_ep))
+		return alt ? -EINVAL : 0;
+	*/
+
+	switch (alt) {
+	case 0:
+
+		if (uvc->state != UVC_STATE_STREAMING)
+			return 0;
+
+		uvc->state = UVC_STATE_CONNECTED;
+		uvc_enable_dqueue(uvc);
+
+		if (uvc->ep) {
+			uvc->delay = 0;
+			printk("%s Disabled!\n", uvc->ep->name);
+			usb_ep_disable(uvc->ep);
+			uvc->ep->driver_data = NULL;
+		}
+
+
+		return 0;
+
+	case 1:
+		if (uvc->state != UVC_STATE_CONNECTED)
+			return 0;
+
+		if (!uvc->ep)
+			return -EINVAL;
+
+		if (uvc->ep->driver_data) {
+			INFO(cdev, "reset UVC\n");
+			usb_ep_disable(uvc->ep);
+			uvc->ep->driver_data = NULL;
+		}
+
+		ret = config_ep_by_speed(f->config->cdev->gadget,
+				&(uvc->func), uvc->ep);
+		if (ret)
+			return ret;
+		usb_ep_enable(uvc->ep);
+		uvc->ep->driver_data = uvc;
+		uvc->delay = 0;
+
+		printk("%s Enabled!\n", uvc->ep->name);
+
+		uvc_enable_queue(uvc);
+		uvc->state = UVC_STATE_STREAMING;
+
+		return USB_GADGET_DELAYED_STATUS;
+
+	default:
+		return -EINVAL;
+	}
+}
+
+static void
+uvc_function_disable(struct usb_function *f)
+{
+	struct uvc_device *uvc = to_uvc(f);
+
+	INFO(f->config->cdev, "uvc_function_disable\n");
+
+	uvc->state = UVC_STATE_DISCONNECTED;
+
+	if (uvc->ep->driver_data) {
+		usb_ep_disable(uvc->ep);
+		uvc->ep->driver_data = NULL;
+	}
+
+	if (uvc->control_ep->driver_data) {
+		usb_ep_disable(uvc->control_ep);
+		uvc->control_ep->driver_data = NULL;
+	}
+}
+
+/* --------------------------------------------------------------------------
+ * Connection / disconnection
+ */
+
+void
+uvc_function_connect(struct uvc_device *uvc)
+{
+	struct usb_composite_dev *cdev = uvc->func.config->cdev;
+	int ret;
+
+	if ((ret = usb_function_activate(&uvc->func)) < 0)
+		INFO(cdev, "UVC connect failed with %d\n", ret);
+}
+
+void
+uvc_function_disconnect(struct uvc_device *uvc)
+{
+	struct usb_composite_dev *cdev = uvc->func.config->cdev;
+	int ret;
+
+	if ((ret = usb_function_deactivate(&uvc->func)) < 0)
+		INFO(cdev, "UVC disconnect failed with %d\n", ret);
+}
+
+/* --------------------------------------------------------------------------
+ * USB probe and disconnect
+ */
+
+static int
+uvc_register_video(struct uvc_device *uvc)
+{
+	struct usb_composite_dev *cdev = uvc->func.config->cdev;
+
+	/* TODO reference counting. */
+	uvc->vdev.release = video_device_release_empty;
+	uvc->vdev.vfl_dir = VFL_DIR_TX;
+	uvc->vdev.lock = &uvc->video.mutex;
+	strlcpy(uvc->vdev.name, cdev->gadget->name, sizeof(uvc->vdev.name));
+
+	video_set_drvdata(&uvc->vdev, uvc);
+
+	return 0;
+
+}
+
+#define UVC_COPY_DESCRIPTOR(mem, dst, desc) \
+	do { \
+		memcpy(mem, desc, (desc)->bLength); \
+		*(dst)++ = mem; \
+		mem += (desc)->bLength; \
+	} while (0);
+
+#define UVC_COPY_DESCRIPTORS(mem, dst, src) \
+	do { \
+		const struct usb_descriptor_header * const *__src; \
+		for (__src = src; *__src; ++__src) { \
+			memcpy(mem, *__src, (*__src)->bLength); \
+			*dst++ = mem; \
+			mem += (*__src)->bLength; \
+		} \
+	} while (0)
+
+static struct usb_descriptor_header **
+uvc_copy_descriptors(struct uvc_device *uvc, enum usb_device_speed speed)
+{
+	struct uvc_input_header_descriptor *uvc_streaming_header;
+	struct uvc_header_descriptor *uvc_control_header;
+	const struct uvc_descriptor_header * const *uvc_control_desc;
+	const struct uvc_descriptor_header * const *uvc_streaming_cls;
+	const struct usb_descriptor_header * const *uvc_streaming_std;
+	const struct usb_descriptor_header * const *src;
+	struct usb_descriptor_header **dst;
+	struct usb_descriptor_header **hdr;
+	unsigned int control_size;
+	unsigned int streaming_size;
+	unsigned int n_desc;
+	unsigned int bytes;
+	void *mem;
+
+	switch (speed) {
+	case USB_SPEED_SUPER:
+		uvc_control_desc = uvc->desc.ss_control;
+		uvc_streaming_cls = uvc->desc.ss_streaming;
+		uvc_streaming_std = uvc_ss_streaming;
+		break;
+
+	case USB_SPEED_HIGH:
+		uvc_control_desc = uvc->desc.fs_control;
+		uvc_streaming_cls = uvc->desc.hs_streaming;
+		uvc_streaming_std = uvc_hs_streaming;
+		break;
+
+	case USB_SPEED_FULL:
+	default:
+		uvc_control_desc = uvc->desc.fs_control;
+		uvc_streaming_cls = uvc->desc.fs_streaming;
+		uvc_streaming_std = uvc_fs_streaming;
+		break;
+	}
+
+	if (!uvc_control_desc || !uvc_streaming_cls)
+		return ERR_PTR(-ENODEV);
+
+	/* Descriptors layout
+	 *
+	 * uvc_iad
+	 * uvc_control_intf
+	 * Class-specific UVC control descriptors
+	 * uvc_control_ep
+	 * uvc_control_cs_ep
+	 * uvc_ss_control_comp (for SS only)
+	 * uvc_streaming_intf_alt0
+	 * Class-specific UVC streaming descriptors
+	 * uvc_{fs|hs}_streaming
+	 */
+
+	/* Count descriptors and compute their size. */
+	control_size = 0;
+	streaming_size = 0;
+	bytes = uvc_iad.bLength + uvc_control_intf.bLength
+	      + uvc_control_ep.bLength + uvc_control_cs_ep.bLength
+	      + uvc_streaming_intf_alt0.bLength;
+
+	if (speed == USB_SPEED_SUPER) {
+		bytes += uvc_ss_control_comp.bLength;
+		n_desc = 6;
+	} else {
+		n_desc = 5;
+	}
+
+	for (src = (const struct usb_descriptor_header **)uvc_control_desc;
+	     *src; ++src) {
+		control_size += (*src)->bLength;
+		bytes += (*src)->bLength;
+		n_desc++;
+	}
+	for (src = (const struct usb_descriptor_header **)uvc_streaming_cls;
+	     *src; ++src) {
+		streaming_size += (*src)->bLength;
+		bytes += (*src)->bLength;
+		n_desc++;
+	}
+	for (src = uvc_streaming_std; *src; ++src) {
+		bytes += (*src)->bLength;
+		n_desc++;
+	}
+
+	mem = kmalloc((n_desc + 1) * sizeof(*src) + bytes, GFP_KERNEL);
+	if (mem == NULL)
+		return NULL;
+
+	hdr = mem;
+	dst = mem;
+	mem += (n_desc + 1) * sizeof(*src);
+
+	/* Copy the descriptors. */
+	UVC_COPY_DESCRIPTOR(mem, dst, &uvc_iad);
+	UVC_COPY_DESCRIPTOR(mem, dst, &uvc_control_intf);
+
+	uvc_control_header = mem;
+	UVC_COPY_DESCRIPTORS(mem, dst,
+		(const struct usb_descriptor_header **)uvc_control_desc);
+	uvc_control_header->wTotalLength = cpu_to_le16(control_size);
+	uvc_control_header->bInCollection = 1;
+	uvc_control_header->baInterfaceNr[0] = uvc->streaming_intf;
+
+	UVC_COPY_DESCRIPTOR(mem, dst, &uvc_control_ep);
+	if (speed == USB_SPEED_SUPER)
+		UVC_COPY_DESCRIPTOR(mem, dst, &uvc_ss_control_comp);
+
+	UVC_COPY_DESCRIPTOR(mem, dst, &uvc_control_cs_ep);
+	UVC_COPY_DESCRIPTOR(mem, dst, &uvc_streaming_intf_alt0);
+
+	uvc_streaming_header = mem;
+	UVC_COPY_DESCRIPTORS(mem, dst,
+		(const struct usb_descriptor_header**)uvc_streaming_cls);
+	uvc_streaming_header->wTotalLength = cpu_to_le16(streaming_size);
+	uvc_streaming_header->bEndpointAddress = uvc->ep->address;
+
+	UVC_COPY_DESCRIPTORS(mem, dst, uvc_streaming_std);
+
+	*dst = NULL;
+	return hdr;
+}
+
+static int uvc_init(struct uvc_device *uvc, int max_packet_size)
+{
+	int ret = 0;
+	struct task_struct *t;
+	INIT_LIST_HEAD(&uvc->req_free);
+
+
+	uvc->current_used = -1;
+
+	ret = video_open_iav(uvc);
+	if(ret)
+		goto error;
+
+	t = kthread_create(video_kthread_get_frame, uvc, "uvc");
+	if (IS_ERR(t)) {
+		printk("%s: failed to create kernel_thread uvc (%ld)!\n",
+				__func__, PTR_ERR(t));
+		goto error;
+	}
+	wake_up_process(t);
+
+	return 0;
+error:
+	return -ENOMEM;
+}
+
+static int
+uvc_function_bind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct usb_composite_dev *cdev = c->cdev;
+	struct uvc_device *uvc = to_uvc(f);
+	struct usb_string *us;
+	unsigned int max_packet_mult;
+	unsigned int max_packet_size;
+	struct usb_ep *ep;
+	struct f_uvc_opts *opts;
+	int ret = -EINVAL;
+
+	INFO(cdev, "uvc_function_bind\n");
+
+	opts = fi_to_f_uvc_opts(f->fi);
+	/* Sanity check the streaming endpoint module parameters.
+	 */
+	opts->streaming_interval = clamp(opts->streaming_interval, 1U, 16U);
+	opts->streaming_maxpacket = clamp(opts->streaming_maxpacket, 1U, 3072U);
+	opts->streaming_maxburst = min(opts->streaming_maxburst, 15U);
+
+	/* Fill in the FS/HS/SS Video Streaming specific descriptors from the
+	 * module parameters.
+	 *
+	 * NOTE: We assume that the user knows what they are doing and won't
+	 * give parameters that their UDC doesn't support.
+	 */
+
+	/* TODO: 960 maybe the best. so  */
+	opts->streaming_maxpacket = 960 - (96 * 2 - 32);
+	if (opts->streaming_maxpacket <= 1024) {
+		max_packet_mult = 1;
+		max_packet_size = opts->streaming_maxpacket;
+	} else if (opts->streaming_maxpacket <= 2048) {
+		max_packet_mult = 2;
+		max_packet_size = opts->streaming_maxpacket / 2;
+	} else {
+		max_packet_mult = 3;
+		max_packet_size = opts->streaming_maxpacket / 3;
+	}
+
+	uvc_fs_streaming_ep.wMaxPacketSize =
+		cpu_to_le16(min(opts->streaming_maxpacket, 1023U));
+	uvc_fs_streaming_ep.bInterval = opts->streaming_interval;
+
+	uvc_hs_streaming_ep.wMaxPacketSize =
+		cpu_to_le16(max_packet_size | ((max_packet_mult - 1) << 11));
+	uvc_hs_streaming_ep.bInterval = opts->streaming_interval;
+
+	uvc_ss_streaming_ep.wMaxPacketSize = cpu_to_le16(max_packet_size);
+	uvc_ss_streaming_ep.bInterval = opts->streaming_interval;
+	uvc_ss_streaming_comp.bmAttributes = max_packet_mult - 1;
+	uvc_ss_streaming_comp.bMaxBurst = opts->streaming_maxburst;
+	uvc_ss_streaming_comp.wBytesPerInterval =
+		cpu_to_le16(max_packet_size * max_packet_mult *
+			    opts->streaming_maxburst);
+
+	/* Allocate endpoints. */
+	ep = usb_ep_autoconfig(cdev->gadget, &uvc_control_ep);
+	if (!ep) {
+		INFO(cdev, "Unable to allocate control EP\n");
+		goto error;
+	}
+	uvc->control_ep = ep;
+	ep->driver_data = uvc;
+
+	if (gadget_is_superspeed(c->cdev->gadget))
+		ep = usb_ep_autoconfig_ss(cdev->gadget, &uvc_ss_streaming_ep,
+					  &uvc_ss_streaming_comp);
+	else if (gadget_is_dualspeed(cdev->gadget))
+		ep = usb_ep_autoconfig(cdev->gadget, &uvc_hs_streaming_ep);
+	else
+		ep = usb_ep_autoconfig(cdev->gadget, &uvc_fs_streaming_ep);
+
+	if (!ep) {
+		INFO(cdev, "Unable to allocate streaming EP\n");
+		goto error;
+	}
+	uvc->ep = ep;
+	ep->driver_data = uvc;
+
+	uvc_fs_streaming_ep.bEndpointAddress = uvc->ep->address;
+	uvc_hs_streaming_ep.bEndpointAddress = uvc->ep->address;
+	uvc_ss_streaming_ep.bEndpointAddress = uvc->ep->address;
+
+	us = usb_gstrings_attach(cdev, uvc_function_strings,
+				 ARRAY_SIZE(uvc_en_us_strings));
+	if (IS_ERR(us)) {
+		ret = PTR_ERR(us);
+		goto error;
+	}
+	uvc_iad.iFunction = us[UVC_STRING_CONTROL_IDX].id;
+	uvc_control_intf.iInterface = us[UVC_STRING_CONTROL_IDX].id;
+	ret = us[UVC_STRING_STREAMING_IDX].id;
+	uvc_streaming_intf_alt0.iInterface = ret;
+	uvc_streaming_intf_alt1.iInterface = ret;
+
+	/* Allocate interface IDs. */
+	if ((ret = usb_interface_id(c, f)) < 0)
+		goto error;
+	uvc_iad.bFirstInterface = ret;
+	uvc_control_intf.bInterfaceNumber = ret;
+	uvc->control_intf = ret;
+
+	if ((ret = usb_interface_id(c, f)) < 0)
+		goto error;
+	uvc_streaming_intf_alt0.bInterfaceNumber = ret;
+	uvc_streaming_intf_alt1.bInterfaceNumber = ret;
+	uvc->streaming_intf = ret;
+
+	/* Copy descriptors */
+	f->fs_descriptors = uvc_copy_descriptors(uvc, USB_SPEED_FULL);
+	if (IS_ERR(f->fs_descriptors)) {
+		ret = PTR_ERR(f->fs_descriptors);
+		f->fs_descriptors = NULL;
+		goto error;
+	}
+	if (gadget_is_dualspeed(cdev->gadget)) {
+		f->hs_descriptors = uvc_copy_descriptors(uvc, USB_SPEED_HIGH);
+		if (IS_ERR(f->hs_descriptors)) {
+			ret = PTR_ERR(f->hs_descriptors);
+			f->hs_descriptors = NULL;
+			goto error;
+		}
+	}
+	if (gadget_is_superspeed(c->cdev->gadget)) {
+		f->ss_descriptors = uvc_copy_descriptors(uvc, USB_SPEED_SUPER);
+		if (IS_ERR(f->ss_descriptors)) {
+			ret = PTR_ERR(f->ss_descriptors);
+			f->ss_descriptors = NULL;
+			goto error;
+		}
+	}
+
+	/* Preallocate control endpoint request. */
+	uvc->control_req = usb_ep_alloc_request(cdev->gadget->ep0, GFP_KERNEL);
+	uvc->control_buf = kmalloc(UVC_MAX_REQUEST_SIZE, GFP_KERNEL);
+	if (uvc->control_req == NULL || uvc->control_buf == NULL) {
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	uvc->control_req->buf = uvc->control_buf;
+	uvc->control_req->complete = uvc_function_ep0_complete;
+	uvc->control_req->context = uvc;
+
+	/* Avoid letting this gadget enumerate until the userspace server is
+	 * active.
+	 */
+	if ((ret = usb_function_deactivate(f)) < 0)
+		goto error;
+
+
+	uvc->MaxPacketSize = max_packet_size;
+	uvc_init(uvc, max_packet_size);
+
+	/* Register a V4L2 device. */
+	ret = uvc_register_video(uvc);
+	if (ret < 0) {
+		printk(KERN_INFO "Unable to register video device\n");
+		goto error;
+	}
+
+	return 0;
+
+error:
+
+	if (uvc->control_ep)
+		uvc->control_ep->driver_data = NULL;
+	if (uvc->ep)
+		uvc->ep->driver_data = NULL;
+
+	if (uvc->control_req)
+		usb_ep_free_request(cdev->gadget->ep0, uvc->control_req);
+	kfree(uvc->control_buf);
+
+	usb_free_all_descriptors(f);
+	return ret;
+}
+
+/* --------------------------------------------------------------------------
+ * USB gadget function
+ */
+
+static void uvc_free_inst(struct usb_function_instance *f)
+{
+	struct f_uvc_opts *opts = fi_to_f_uvc_opts(f);
+
+	mutex_destroy(&opts->lock);
+	kfree(opts);
+}
+
+static struct usb_function_instance *uvc_alloc_inst(void)
+{
+	struct f_uvc_opts *opts;
+	struct uvc_camera_terminal_descriptor *cd;
+	struct uvc_processing_unit_descriptor *pd;
+	struct uvc_output_terminal_descriptor *od;
+	struct uvc_color_matching_descriptor *md;
+	struct uvc_descriptor_header **ctl_cls;
+
+	opts = kzalloc(sizeof(*opts), GFP_KERNEL);
+	if (!opts)
+		return ERR_PTR(-ENOMEM);
+	opts->func_inst.free_func_inst = uvc_free_inst;
+	mutex_init(&opts->lock);
+
+	cd = &opts->uvc_camera_terminal;
+	cd->bLength			= UVC_DT_CAMERA_TERMINAL_SIZE(3);
+	cd->bDescriptorType		= USB_DT_CS_INTERFACE;
+	cd->bDescriptorSubType		= UVC_VC_INPUT_TERMINAL;
+	cd->bTerminalID			= 1;
+	cd->wTerminalType		= cpu_to_le16(0x0201);
+	cd->bAssocTerminal		= 0;
+	cd->iTerminal			= 0;
+	cd->wObjectiveFocalLengthMin	= cpu_to_le16(0);
+	cd->wObjectiveFocalLengthMax	= cpu_to_le16(0);
+	cd->wOcularFocalLength		= cpu_to_le16(0);
+	cd->bControlSize		= 3;
+	cd->bmControls[0]		= 2;
+	cd->bmControls[1]		= 0;
+	cd->bmControls[2]		= 0;
+
+	pd = &opts->uvc_processing;
+	pd->bLength			= UVC_DT_PROCESSING_UNIT_SIZE(2);
+	pd->bDescriptorType		= USB_DT_CS_INTERFACE;
+	pd->bDescriptorSubType		= UVC_VC_PROCESSING_UNIT;
+	pd->bUnitID			= 2;
+	pd->bSourceID			= 1;
+	pd->wMaxMultiplier		= cpu_to_le16(16*1024);
+	pd->bControlSize		= 2;
+	pd->bmControls[0]		= 1;
+	pd->bmControls[1]		= 0;
+	pd->iProcessing			= 0;
+
+	od = &opts->uvc_output_terminal;
+	od->bLength			= UVC_DT_OUTPUT_TERMINAL_SIZE;
+	od->bDescriptorType		= USB_DT_CS_INTERFACE;
+	od->bDescriptorSubType		= UVC_VC_OUTPUT_TERMINAL;
+	od->bTerminalID			= 3;
+	od->wTerminalType		= cpu_to_le16(0x0101);
+	od->bAssocTerminal		= 0;
+	od->bSourceID			= 2;
+	od->iTerminal			= 0;
+
+	md = &opts->uvc_color_matching;
+	md->bLength			= UVC_DT_COLOR_MATCHING_SIZE;
+	md->bDescriptorType		= USB_DT_CS_INTERFACE;
+	md->bDescriptorSubType		= UVC_VS_COLORFORMAT;
+	md->bColorPrimaries		= 1;
+	md->bTransferCharacteristics	= 1;
+	md->bMatrixCoefficients		= 4;
+
+	/* Prepare fs control class descriptors for configfs-based gadgets */
+	ctl_cls = opts->uvc_fs_control_cls;
+	ctl_cls[0] = NULL;	/* assigned elsewhere by configfs */
+	ctl_cls[1] = (struct uvc_descriptor_header *)cd;
+	ctl_cls[2] = (struct uvc_descriptor_header *)pd;
+	ctl_cls[3] = (struct uvc_descriptor_header *)od;
+	ctl_cls[4] = NULL;	/* NULL-terminate */
+	opts->fs_control =
+		(const struct uvc_descriptor_header * const *)ctl_cls;
+
+	/* Prepare hs control class descriptors for configfs-based gadgets */
+	ctl_cls = opts->uvc_ss_control_cls;
+	ctl_cls[0] = NULL;	/* assigned elsewhere by configfs */
+	ctl_cls[1] = (struct uvc_descriptor_header *)cd;
+	ctl_cls[2] = (struct uvc_descriptor_header *)pd;
+	ctl_cls[3] = (struct uvc_descriptor_header *)od;
+	ctl_cls[4] = NULL;	/* NULL-terminate */
+	opts->ss_control =
+		(const struct uvc_descriptor_header * const *)ctl_cls;
+
+	opts->streaming_interval = 1;
+	opts->streaming_maxpacket = 1024;
+
+	return &opts->func_inst;
+}
+
+static void uvc_free(struct usb_function *f)
+{
+	struct uvc_device *uvc = to_uvc(f);
+	struct f_uvc_opts *opts = container_of(f->fi, struct f_uvc_opts,
+					       func_inst);
+	--opts->refcnt;
+	kfree(uvc);
+}
+
+static void uvc_unbind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct usb_composite_dev *cdev = c->cdev;
+	struct uvc_device *uvc = to_uvc(f);
+
+	INFO(cdev, "%s\n", __func__);
+
+	video_unregister_device(&uvc->vdev);
+	uvc->control_ep->driver_data = NULL;
+	uvc->ep->driver_data = NULL;
+
+	usb_ep_free_request(cdev->gadget->ep0, uvc->control_req);
+	kfree(uvc->control_buf);
+
+	usb_free_all_descriptors(f);
+}
+
+static struct usb_function *uvc_alloc(struct usb_function_instance *fi)
+{
+	struct uvc_device *uvc;
+	struct f_uvc_opts *opts;
+	struct uvc_descriptor_header **strm_cls;
+
+	uvc = kzalloc(sizeof(*uvc), GFP_KERNEL);
+	if (uvc == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	mutex_init(&uvc->video.mutex);
+	uvc->state = UVC_STATE_DISCONNECTED;
+	opts = fi_to_f_uvc_opts(fi);
+
+	mutex_lock(&opts->lock);
+	if (opts->uvc_fs_streaming_cls) {
+		strm_cls = opts->uvc_fs_streaming_cls;
+		opts->fs_streaming =
+			(const struct uvc_descriptor_header * const *)strm_cls;
+	}
+	if (opts->uvc_hs_streaming_cls) {
+		strm_cls = opts->uvc_hs_streaming_cls;
+		opts->hs_streaming =
+			(const struct uvc_descriptor_header * const *)strm_cls;
+	}
+	if (opts->uvc_ss_streaming_cls) {
+		strm_cls = opts->uvc_ss_streaming_cls;
+		opts->ss_streaming =
+			(const struct uvc_descriptor_header * const *)strm_cls;
+	}
+
+	uvc->desc.fs_control = opts->fs_control;
+	uvc->desc.ss_control = opts->ss_control;
+	uvc->desc.fs_streaming = opts->fs_streaming;
+	uvc->desc.hs_streaming = opts->hs_streaming;
+	uvc->desc.ss_streaming = opts->ss_streaming;
+	++opts->refcnt;
+	mutex_unlock(&opts->lock);
+
+	/* Register the function. */
+	uvc->func.name = "uvc";
+	uvc->func.bind = uvc_function_bind;
+	uvc->func.unbind = uvc_unbind;
+	uvc->func.get_alt = uvc_function_get_alt;
+	uvc->func.set_alt = uvc_function_set_alt;
+	uvc->func.disable = uvc_function_disable;
+	uvc->func.setup = uvc_function_setup;
+	uvc->func.free_func = uvc_free;
+
+	return &uvc->func;
+}
+
+DECLARE_USB_FUNCTION_INIT(uvc, uvc_alloc_inst, uvc_alloc);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("JORNEY");
diff --git a/drivers/uvc_camera/uvc/f_uvc.h b/drivers/uvc_camera/uvc/f_uvc.h
new file mode 100644
index 0000000..d0a73bd
--- /dev/null
+++ b/drivers/uvc_camera/uvc/f_uvc.h
@@ -0,0 +1,28 @@
+/*
+ *	f_uvc.h  --  USB Video Class Gadget driver
+ *
+ *	Copyright (C) 2009-2010
+ *	    Laurent Pinchart (laurent.pinchart@ideasonboard.com)
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ */
+
+#ifndef _F_UVC_H_
+#define _F_UVC_H_
+
+#include <linux/usb/composite.h>
+#include <linux/usb/video.h>
+
+#include "uvc.h"
+
+void uvc_function_setup_continue(struct uvc_device *uvc);
+
+void uvc_function_connect(struct uvc_device *uvc);
+
+void uvc_function_disconnect(struct uvc_device *uvc);
+
+#endif /* _F_UVC_H_ */
+
diff --git a/drivers/uvc_camera/uvc/gadget_chips.h b/drivers/uvc_camera/uvc/gadget_chips.h
new file mode 100644
index 0000000..e39d2dd
--- /dev/null
+++ b/drivers/uvc_camera/uvc/gadget_chips.h
@@ -0,0 +1,56 @@
+/*
+ * USB device controllers have lots of quirks.  Use these macros in
+ * gadget drivers or other code that needs to deal with them, and which
+ * autoconfigures instead of using early binding to the hardware.
+ *
+ * This SHOULD eventually work like the ARM mach_is_*() stuff, driven by
+ * some config file that gets updated as new hardware is supported.
+ * (And avoiding all runtime comparisons in typical one-choice configs!)
+ *
+ * NOTE:  some of these controller drivers may not be available yet.
+ * Some are available on 2.4 kernels; several are available, but not
+ * yet pushed in the 2.6 mainline tree.
+ */
+
+#ifndef __GADGET_CHIPS_H
+#define __GADGET_CHIPS_H
+
+#include <linux/usb/gadget.h>
+
+/*
+ * NOTICE: the entries below are alphabetical and should be kept
+ * that way.
+ *
+ * Always be sure to add new entries to the correct position or
+ * accept the bashing later.
+ *
+ * If you have forgotten the alphabetical order let VIM/EMACS
+ * do that for you.
+ */
+#define gadget_is_at91(g)		(!strcmp("at91_udc", (g)->name))
+#define gadget_is_goku(g)		(!strcmp("goku_udc", (g)->name))
+#define gadget_is_musbhdrc(g)		(!strcmp("musb-hdrc", (g)->name))
+#define gadget_is_net2280(g)		(!strcmp("net2280", (g)->name))
+#define gadget_is_pxa(g)		(!strcmp("pxa25x_udc", (g)->name))
+#define gadget_is_pxa27x(g)		(!strcmp("pxa27x_udc", (g)->name))
+#define gadget_is_ambarella(g)	(!strcmp("ambarella_udc", (g)->name))
+
+/**
+ * gadget_supports_altsettings - return true if altsettings work
+ * @gadget: the gadget in question
+ */
+static inline bool gadget_supports_altsettings(struct usb_gadget *gadget)
+{
+	/* PXA 21x/25x/26x has no altsettings at all */
+	if (gadget_is_pxa(gadget))
+		return false;
+
+	/* PXA 27x and 3xx have *broken* altsetting support */
+	if (gadget_is_pxa27x(gadget))
+		return false;
+
+	/* Everything else is *presumably* fine ... */
+	return true;
+}
+
+#endif /* __GADGET_CHIPS_H */
diff --git a/drivers/uvc_camera/uvc/u_uac1.h b/drivers/uvc_camera/uvc/u_uac1.h
new file mode 100644
index 0000000..c7b89f6
--- /dev/null
+++ b/drivers/uvc_camera/uvc/u_uac1.h
@@ -0,0 +1,136 @@
+/*
+ * u_uac1.h -- interface to USB gadget "ALSA AUDIO" utilities
+ *
+ * Copyright (C) 2008 Bryan Wu <cooloney@kernel.org>
+ * Copyright (C) 2008 Analog Devices, Inc
+ *
+ * Enter bugs at http://blackfin.uclinux.org/
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#ifndef __U_AUDIO_H
+#define __U_AUDIO_H
+
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/usb/audio.h>
+#include <linux/usb/composite.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+
+#include "gadget_chips.h"
+#include "../defconfig.h"
+
+#define FILE_PCM_PLAYBACK	"/dev/snd/pcmC0D0p"
+#define FILE_PCM_CAPTURE	"/dev/snd/pcmC0D0c"
+#define FILE_CONTROL		"/dev/snd/controlC0"
+
+#if LINUX   /* host is linux OS */
+#define UAC1_OUT_EP_MAX_PACKET_SIZE	 (96)
+#define UAC1_REQ_COUNT				  2
+#elif UAC_EX_SOLUTION
+#define UAC1_OUT_EP_MAX_PACKET_SIZE	 (96 / 8)
+#define UAC1_REQ_COUNT				  2
+#else
+#define UAC1_OUT_EP_MAX_PACKET_SIZE	 (96 * 2)
+#define UAC1_REQ_COUNT				  1
+#endif
+
+#define UAC1_AUDIO_BUF_SIZE			  48000
+/* audio buffer size */
+#define FRAME_SIZE  				 (UAC1_OUT_EP_MAX_PACKET_SIZE * 10)
+
+/*
+ * This represents the USB side of an audio card device, managed by a USB
+ * function which provides control and stream interfaces.
+ */
+
+struct gaudio_snd_dev {
+	struct gaudio			*card;
+	struct file			*filp;
+	struct snd_pcm_substream	*substream;
+	int				access;
+	int				format;
+	int				channels;
+	int				rate;
+};
+
+struct gaudio {
+	struct usb_function		func;
+	struct usb_gadget		*gadget;
+
+	/* ALSA sound device interfaces */
+	struct gaudio_snd_dev		control;
+	struct gaudio_snd_dev		playback;
+	struct gaudio_snd_dev		capture;
+
+	/* TODO */
+};
+
+struct f_uac1_opts {
+	struct usb_function_instance	func_inst;
+	int				req_buf_size;
+	int				req_count;
+	int				audio_buf_size;
+	char				*fn_play;
+	char				*fn_cap;
+	char				*fn_cntl;
+	unsigned			bound:1;
+	unsigned			fn_play_alloc:1;
+	unsigned			fn_cap_alloc:1;
+	unsigned			fn_cntl_alloc:1;
+	struct mutex			lock;
+	int				refcnt;
+};
+/* --------------------------------------------------------------------- */
+
+struct frame_info
+{
+	char buf[FRAME_SIZE];
+	int total_size;
+	int bused_size;
+	int nodata;
+};
+
+struct f_audio {
+	struct gaudio			card;
+
+	/* endpoints handle full and/or high speeds */
+	struct usb_ep			*out_ep;
+
+	spinlock_t			lock;
+	struct f_audio_buf *copy_buf;
+	struct work_struct playback_work;
+	struct list_head play_queue;
+
+	/* Control Set command */
+	struct list_head cs;
+	u8 set_cmd;
+	struct usb_audio_control *set_con;
+
+	struct usb_request *req[UAC1_REQ_COUNT];
+	bool ep_enabled;
+	int current_used;
+	struct frame_info frame[2];
+
+#if  AUDIO_DEBUG_PLAY
+	struct file *play_file;
+	char debug_frame[AUDIO_DEBUG_PLAY_SIZE];
+	int debug_avail;
+#endif
+
+
+};
+
+int gaudio_setup(struct gaudio *card);
+void gaudio_cleanup(struct gaudio *the_card);
+
+int audio_kthread_get_frame(void *arg);
+
+
+#endif /* __U_AUDIO_H */
diff --git a/drivers/uvc_camera/uvc/u_uvc.h b/drivers/uvc_camera/uvc/u_uvc.h
new file mode 100644
index 0000000..4676b60
--- /dev/null
+++ b/drivers/uvc_camera/uvc/u_uvc.h
@@ -0,0 +1,89 @@
+/*
+ * u_uvc.h
+ *
+ * Utility definitions for the uvc function
+ *
+ * Copyright (c) 2013-2014 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ *
+ * Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef U_UVC_H
+#define U_UVC_H
+
+#include <linux/usb/composite.h>
+#include <linux/usb/video.h>
+
+#define fi_to_f_uvc_opts(f)	container_of(f, struct f_uvc_opts, func_inst)
+
+struct f_uvc_opts {
+	struct usb_function_instance			func_inst;
+	unsigned int					uvc_gadget_trace_param;
+	unsigned int					streaming_interval;
+	unsigned int					streaming_maxpacket;
+	unsigned int					streaming_maxburst;
+
+	/*
+	 * Control descriptors array pointers for full-/high-speed and
+	 * super-speed. They point by default to the uvc_fs_control_cls and
+	 * uvc_ss_control_cls arrays respectively. Legacy gadgets must
+	 * override them in their gadget bind callback.
+	 */
+	const struct uvc_descriptor_header * const	*fs_control;
+	const struct uvc_descriptor_header * const	*ss_control;
+
+	/*
+	 * Streaming descriptors array pointers for full-speed, high-speed and
+	 * super-speed. They will point to the uvc_[fhs]s_streaming_cls arrays
+	 * for configfs-based gadgets. Legacy gadgets must initialize them in
+	 * their gadget bind callback.
+	 */
+	const struct uvc_descriptor_header * const	*fs_streaming;
+	const struct uvc_descriptor_header * const	*hs_streaming;
+	const struct uvc_descriptor_header * const	*ss_streaming;
+
+	/* Default control descriptors for configfs-based gadgets. */
+	struct uvc_camera_terminal_descriptor		uvc_camera_terminal;
+	struct uvc_processing_unit_descriptor		uvc_processing;
+	struct uvc_output_terminal_descriptor		uvc_output_terminal;
+	struct uvc_color_matching_descriptor		uvc_color_matching;
+
+	/*
+	 * Control descriptors pointers arrays for full-/high-speed and
+	 * super-speed. The first element is a configurable control header
+	 * descriptor, the other elements point to the fixed default control
+	 * descriptors. Used by configfs only, must not be touched by legacy
+	 * gadgets.
+	 */
+	struct uvc_descriptor_header			*uvc_fs_control_cls[5];
+	struct uvc_descriptor_header			*uvc_ss_control_cls[5];
+
+	/*
+	 * Streaming descriptors for full-speed, high-speed and super-speed.
+	 * Used by configfs only, must not be touched by legacy gadgets. The
+	 * arrays are allocated at runtime as the number of descriptors isn't
+	 * known in advance.
+	 */
+	struct uvc_descriptor_header			**uvc_fs_streaming_cls;
+	struct uvc_descriptor_header			**uvc_hs_streaming_cls;
+	struct uvc_descriptor_header			**uvc_ss_streaming_cls;
+
+	/*
+	 * Read/write access to configfs attributes is handled by configfs.
+	 *
+	 * This lock protects the descriptors from concurrent access by
+	 * read/write and symlink creation/removal.
+	 */
+	struct mutex			lock;
+	int				refcnt;
+};
+
+void uvc_set_trace_param(unsigned int trace);
+
+#endif /* U_UVC_H */
+
diff --git a/drivers/uvc_camera/uvc/uac_stream.c b/drivers/uvc_camera/uvc/uac_stream.c
new file mode 100644
index 0000000..4a96891
--- /dev/null
+++ b/drivers/uvc_camera/uvc/uac_stream.c
@@ -0,0 +1,494 @@
+/*
+ * uac_stream.c - ALSA audio utilities for Gadget stack
+ *
+ * Copyright (C) 2015 Jorney <qtu@ambarella.com>
+ *
+ * Enter bugs at http://blackfin.uclinux.org/
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+#include <linux/random.h>
+#include <linux/syscalls.h>
+
+#include "u_uac1.h"
+
+/*
+ * This component encapsulates the ALSA devices for USB audio gadget
+ */
+
+static char *fn_play = FILE_PCM_PLAYBACK;
+static char *fn_cap  = FILE_PCM_CAPTURE;
+static char *fn_cntl = FILE_CONTROL;
+
+/*-------------------------------------------------------------------------*/
+#if AUDIO_DEBUG_PLAY
+int audio_get_frame(struct f_audio *audio)
+{
+	struct file *file = audio->play_file;
+	char *buf = audio->debug_frame;
+	int size, ret;
+	mm_segment_t fs;
+	loff_t pos;
+
+	size = vfs_llseek(file, 0 ,SEEK_END);
+
+	if(size > AUDIO_DEBUG_PLAY_SIZE)
+		size = AUDIO_DEBUG_PLAY_SIZE;
+
+	audio->debug_avail = size;
+
+	pos = 0;
+	fs  = get_fs();
+	set_fs(KERNEL_DS);
+	ret = vfs_read(file, buf, size, &pos);
+	set_fs(fs);
+	return 0;
+}
+
+int audio_close_play(struct f_audio *audio)
+{
+	if(audio->play_file > 0)
+		filp_close(audio->play_file, NULL);
+
+	return 0;
+}
+
+int audio_open_play(struct f_audio *audio)
+{
+	audio->play_file = filp_open(AUDIO_DEBUG_PLAY_FILE, O_RDWR, 0);
+	if(IS_ERR(audio->play_file)){
+		printk("%s unable open video device\n", __FUNCTION__);
+		return PTR_ERR(audio->play_file);
+	}
+	return 0;
+}
+
+static int audio_play_debug(struct f_audio *audio)
+{
+	if (audio_open_play(audio))
+		return 0;
+
+	audio_get_frame(audio);
+	audio_close_play(audio);
+
+	return 0;
+}
+
+
+#endif
+
+#if AUDIO_DEBUG_CAPTURE
+
+struct file *file = NULL;
+static int offset = 0;
+
+int audio_open_capture(void)
+{
+	file = filp_open(AUDIO_DEBUG_CAPTURE_FILE, O_RDWR, 0);
+	if(IS_ERR(file)){
+		printk("%s unable open video device\n", __FUNCTION__);
+		return PTR_ERR(file);
+	}
+	return 0;
+}
+
+int audio_close_capture(void)
+{
+	if(file > 0)
+		filp_close(file, NULL);
+	file = NULL;
+
+	return 0;
+}
+
+int audio_record(char *buf, int size, loff_t pos)
+{
+	mm_segment_t fs;
+	int ret;
+
+	fs  = get_fs();
+	set_fs(KERNEL_DS);
+
+	ret = vfs_write(file, buf, size, &pos);
+
+	set_fs(fs);
+
+	return 0;
+}
+
+#endif
+
+int stereo_to_mono(struct f_audio *audio, char *buf, int size)
+{
+	int unused ;
+
+	int *s = (int *)buf;
+	short int *d;
+	int i;
+
+
+	if(size != FRAME_SIZE * 2)
+		BUG();
+
+	unused = (audio->current_used == 0) ? 1 : 0;
+
+	if (audio->current_used == -1) {
+		audio->current_used = 0;
+
+		d = (short int *)audio->frame[0].buf;
+
+		for (i = 0; i < FRAME_SIZE / 2 ; i++)
+			d[i] = s[i];
+
+		audio->frame[0].total_size = size / 2;
+		audio->frame[0].bused_size = 0;
+		audio->frame[0].nodata = 0;
+
+		return 0;
+	}
+
+	d = (short int *)audio->frame[unused].buf;
+
+	for (i = 0; i < FRAME_SIZE / 2 ; i++)
+		d[i] = s[i];
+
+#if AUDIO_DEBUG_CAPTURE
+	if (offset < AUDIO_DEBUG_CAPTURE_SIZE){
+		audio_record((char *)d, size / 2, offset);
+		offset += size;
+	}
+#endif
+
+	audio->frame[unused].total_size = size / 2;
+	audio->frame[unused].bused_size = 0;
+	audio->frame[unused].nodata = 0;
+
+	return 0;
+
+}
+
+int audio_kthread_get_frame(void *arg)
+{
+	struct f_audio *audio = (struct f_audio *)arg;
+	struct gaudio *card = &audio->card;
+
+	struct gaudio_snd_dev	*snd = &card->capture;
+	struct snd_pcm_substream *substream = snd->substream;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	mm_segment_t old_fs;
+	ssize_t result;
+	snd_pcm_sframes_t frames;
+
+	char *buffer;
+	int count = FRAME_SIZE * 2;
+
+	int ret = 0;
+
+#if AUDIO_DEBUG_CAPTURE
+	if (audio_open_capture())
+		return 0;
+#endif
+
+#if AUDIO_DEBUG_PLAY
+	audio_play_debug(audio);
+#endif
+
+	buffer = kzalloc(FRAME_SIZE * 2, GFP_KERNEL);
+	if (!buffer)
+		return -ENOMEM;
+
+	while(1){
+
+#if AUDIO_DEBUG_CAPTURE
+		if (!audio->ep_enabled)
+			offset = 0;
+#endif
+
+		memset(buffer, 0, FRAME_SIZE * 2);
+retry:
+		if (runtime->status->state == SNDRV_PCM_STATE_XRUN ||
+				runtime->status->state == SNDRV_PCM_STATE_SUSPENDED) {
+			result = snd_pcm_kernel_ioctl(substream,
+					SNDRV_PCM_IOCTL_PREPARE, NULL);
+			if (result < 0) {
+				printk("Preparing sound card failed: %d\n",
+						(int)result);
+				ret = result;
+				goto out;
+			}
+		}
+
+		frames = bytes_to_frames(runtime, count);
+
+		old_fs = get_fs();
+		set_fs(KERNEL_DS);
+
+		result = snd_pcm_lib_read(snd->substream, buffer, frames);
+		if (result != frames) {
+			printk("Capture error: %d\n", (int)result);
+			set_fs(old_fs);
+			goto retry;
+		}
+
+		set_fs(old_fs);
+
+		/* FIXME: only support MONO */
+		stereo_to_mono(audio, buffer, count);
+	}
+
+out:
+
+#if AUDIO_DEBUG_CAPTURE
+	audio_close_capture();
+#endif
+	kfree(buffer);
+	return ret;
+
+}
+EXPORT_SYMBOL(audio_kthread_get_frame);
+
+/**
+ * Some ALSA internal helper functions
+ */
+static int snd_interval_refine_set(struct snd_interval *i, unsigned int val)
+{
+	struct snd_interval t;
+	t.empty = 0;
+	t.min = t.max = val;
+	t.openmin = t.openmax = 0;
+	t.integer = 1;
+	return snd_interval_refine(i, &t);
+}
+
+static int _snd_pcm_hw_param_set(struct snd_pcm_hw_params *params,
+				 snd_pcm_hw_param_t var, unsigned int val,
+				 int dir)
+{
+	int changed;
+	if (hw_is_mask(var)) {
+		struct snd_mask *m = hw_param_mask(params, var);
+		if (val == 0 && dir < 0) {
+			changed = -EINVAL;
+			snd_mask_none(m);
+		} else {
+			if (dir > 0)
+				val++;
+			else if (dir < 0)
+				val--;
+			changed = snd_mask_refine_set(
+					hw_param_mask(params, var), val);
+		}
+	} else if (hw_is_interval(var)) {
+		struct snd_interval *i = hw_param_interval(params, var);
+		if (val == 0 && dir < 0) {
+			changed = -EINVAL;
+			snd_interval_none(i);
+		} else if (dir == 0)
+			changed = snd_interval_refine_set(i, val);
+		else {
+			struct snd_interval t;
+			t.openmin = 1;
+			t.openmax = 1;
+			t.empty = 0;
+			t.integer = 0;
+			if (dir < 0) {
+				t.min = val - 1;
+				t.max = val;
+			} else {
+				t.min = val;
+				t.max = val+1;
+			}
+			changed = snd_interval_refine(i, &t);
+		}
+	} else
+		return -EINVAL;
+	if (changed) {
+		params->cmask |= 1 << var;
+		params->rmask |= 1 << var;
+	}
+	return changed;
+}
+/*-------------------------------------------------------------------------*/
+
+/**
+ * Set default hardware params
+ */
+static int playback_default_hw_params(struct gaudio_snd_dev *snd, int channels)
+{
+	struct snd_pcm_substream *substream = snd->substream;
+	struct snd_pcm_hw_params *params;
+	snd_pcm_sframes_t result;
+
+       /*
+	* SNDRV_PCM_ACCESS_RW_INTERLEAVED,
+	* SNDRV_PCM_FORMAT_S16_LE
+	* CHANNELS: 2
+	* RATE: 48000
+	*/
+	snd->access = SNDRV_PCM_ACCESS_RW_INTERLEAVED;
+	snd->format = SNDRV_PCM_FORMAT_S16_LE;
+	snd->channels = channels;
+	snd->rate = 48000;
+
+	params = kzalloc(sizeof(*params), GFP_KERNEL);
+	if (!params)
+		return -ENOMEM;
+
+	_snd_pcm_hw_params_any(params);
+	_snd_pcm_hw_param_set(params, SNDRV_PCM_HW_PARAM_ACCESS,
+			snd->access, 0);
+	_snd_pcm_hw_param_set(params, SNDRV_PCM_HW_PARAM_FORMAT,
+			snd->format, 0);
+	_snd_pcm_hw_param_set(params, SNDRV_PCM_HW_PARAM_CHANNELS,
+			snd->channels, 0);
+	_snd_pcm_hw_param_set(params, SNDRV_PCM_HW_PARAM_RATE,
+			snd->rate, 0);
+
+	snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DROP, NULL);
+	snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_HW_PARAMS, params);
+
+	result = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_PREPARE, NULL);
+	if (result < 0) {
+		printk("Preparing sound card failed: %d\n", (int)result);
+		kfree(params);
+		return result;
+	}
+
+	/* Store the hardware parameters */
+	snd->access = params_access(params);
+	snd->format = params_format(params);
+	snd->channels = params_channels(params);
+	snd->rate = params_rate(params);
+
+	kfree(params);
+
+	printk("Hardware params: access %x, format %x, channels %d, rate %d\n",
+		snd->access, snd->format, snd->channels, snd->rate);
+
+	return 0;
+}
+
+
+/**
+ * Open ALSA PCM and control device files
+ * Initial the PCM or control device
+ */
+static int gaudio_open_snd_dev(struct gaudio *card)
+{
+	struct snd_pcm_file *pcm_file;
+	struct gaudio_snd_dev *snd;
+
+	if (!card)
+		return -ENODEV;
+
+
+	/* Open control device */
+	snd = &card->control;
+	snd->filp = filp_open(fn_cntl, O_RDWR, 0);
+	if (IS_ERR(snd->filp)) {
+		int ret = PTR_ERR(snd->filp);
+		printk("unable to open sound control device file: %s\n",
+				fn_cntl);
+		snd->filp = NULL;
+		return ret;
+	}
+	snd->card = card;
+
+	/* Open PCM playback device and setup substream */
+	snd = &card->playback;
+	snd->filp = filp_open(fn_play, O_WRONLY, 0);
+	if (IS_ERR(snd->filp)) {
+		int ret = PTR_ERR(snd->filp);
+
+		printk( "No such PCM playback device: %s\n", fn_play);
+		snd->filp = NULL;
+		return ret;
+	}
+	pcm_file = snd->filp->private_data;
+	snd->substream = pcm_file->substream;
+	snd->card = card;
+
+	playback_default_hw_params(snd, 2);
+
+	/* Open PCM capture device and setup substream */
+	snd = &card->capture;
+	snd->filp = filp_open(fn_cap, O_RDONLY, 0);
+	if (IS_ERR(snd->filp)) {
+		printk("No such PCM capture device: %s\n", fn_cap);
+		snd->substream = NULL;
+		snd->card = NULL;
+		snd->filp = NULL;
+	} else {
+		int ret = 0;
+		pcm_file = snd->filp->private_data;
+		snd->substream = pcm_file->substream;
+		snd->card = card;
+
+		ret =playback_default_hw_params(snd, 2);
+		if(ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+/**
+ * Close ALSA PCM and control device files
+ */
+static int gaudio_close_snd_dev(struct gaudio *gau)
+{
+	struct gaudio_snd_dev	*snd;
+
+	/* Close control device */
+	snd = &gau->control;
+	if (snd->filp)
+		filp_close(snd->filp, NULL);
+
+	/* Close PCM playback device and setup substream */
+	snd = &gau->playback;
+	if (snd->filp)
+		filp_close(snd->filp, NULL);
+
+	/* Close PCM capture device and setup substream */
+	snd = &gau->capture;
+	if (snd->filp)
+		filp_close(snd->filp, NULL);
+
+	return 0;
+}
+
+/**
+ * gaudio_setup - setup ALSA interface and preparing for USB transfer
+ *
+ * This sets up PCM, mixer or MIDI ALSA devices fore USB gadget using.
+ *
+ * Returns negative errno, or zero on success
+ */
+int  gaudio_setup(struct gaudio *card)
+{
+	int	ret = 0;
+
+	ret = gaudio_open_snd_dev(card);
+	if (ret)
+		printk("we need at least one control device\n");
+
+	return ret;
+
+}
+
+/**
+ * gaudio_cleanup - remove ALSA device interface
+ *
+ * This is called to free all resources allocated by @gaudio_setup().
+ */
+void gaudio_cleanup(struct gaudio *card)
+{
+	gaudio_close_snd_dev(card);
+}
diff --git a/drivers/uvc_camera/uvc/uvc.h b/drivers/uvc_camera/uvc/uvc.h
new file mode 100644
index 0000000..98fefe1
--- /dev/null
+++ b/drivers/uvc_camera/uvc/uvc.h
@@ -0,0 +1,235 @@
+/*
+ *	uvc_gadget.h  --  USB Video Class Gadget driver
+ *
+ *	Copyright (C) 2009-2010
+ *	    Laurent Pinchart (laurent.pinchart@ideasonboard.com)
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ */
+
+#ifndef _UVC_GADGET_H_
+#define _UVC_GADGET_H_
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+#include <linux/usb/ch9.h>
+
+#define UVC_EVENT_FIRST			(V4L2_EVENT_PRIVATE_START + 0)
+#define UVC_EVENT_CONNECT		(V4L2_EVENT_PRIVATE_START + 0)
+#define UVC_EVENT_DISCONNECT		(V4L2_EVENT_PRIVATE_START + 1)
+#define UVC_EVENT_STREAMON		(V4L2_EVENT_PRIVATE_START + 2)
+#define UVC_EVENT_STREAMOFF		(V4L2_EVENT_PRIVATE_START + 3)
+#define UVC_EVENT_SETUP			(V4L2_EVENT_PRIVATE_START + 4)
+#define UVC_EVENT_DATA			(V4L2_EVENT_PRIVATE_START + 5)
+#define UVC_EVENT_LAST			(V4L2_EVENT_PRIVATE_START + 5)
+
+struct uvc_request_data
+{
+	__s32 length;
+	__u8 data[60];
+};
+
+struct uvc_event
+{
+	union {
+		enum usb_device_speed speed;
+		struct usb_ctrlrequest req;
+		struct uvc_request_data data;
+	};
+};
+
+#define UVCIOC_SEND_RESPONSE		_IOW('U', 1, struct uvc_request_data)
+
+#define UVC_INTF_CONTROL		0
+#define UVC_INTF_STREAMING		1
+
+/* ------------------------------------------------------------------------
+ * Debugging, printing and logging
+ */
+
+#ifdef __KERNEL__
+
+#include <linux/usb.h>	/* For usb_endpoint_* */
+#include <linux/usb/composite.h>
+#include <linux/usb/gadget.h>
+#include <linux/videodev2.h>
+#include <linux/version.h>
+#include <media/v4l2-fh.h>
+#include <media/v4l2-device.h>
+
+#include "uvc_queue.h"
+#include "../defconfig.h"
+
+#define UVC_TRACE_PROBE				(1 << 0)
+#define UVC_TRACE_DESCR				(1 << 1)
+#define UVC_TRACE_CONTROL			(1 << 2)
+#define UVC_TRACE_FORMAT			(1 << 3)
+#define UVC_TRACE_CAPTURE			(1 << 4)
+#define UVC_TRACE_CALLS				(1 << 5)
+#define UVC_TRACE_IOCTL				(1 << 6)
+#define UVC_TRACE_FRAME				(1 << 7)
+#define UVC_TRACE_SUSPEND			(1 << 8)
+#define UVC_TRACE_STATUS			(1 << 9)
+
+#define UVC_WARN_MINMAX				0
+#define UVC_WARN_PROBE_DEF			1
+
+extern unsigned int uvc_gadget_trace_param;
+
+#define uvc_trace(flag, msg...) \
+	do { \
+		if (uvc_gadget_trace_param & flag) \
+			printk(KERN_DEBUG "uvcvideo: " msg); \
+	} while (0)
+
+#define uvc_warn_once(dev, warn, msg...) \
+	do { \
+		if (!test_and_set_bit(warn, &dev->warnings)) \
+			printk(KERN_INFO "uvcvideo: " msg); \
+	} while (0)
+
+#define uvc_printk(level, msg...) \
+	printk(level "uvcvideo: " msg)
+
+/* ------------------------------------------------------------------------
+ * Driver specific constants
+ */
+
+#define UVC_NUM_REQUESTS			4
+#define UVC_MAX_REQUEST_SIZE			64
+#define UVC_MAX_EVENTS				4
+
+/* ------------------------------------------------------------------------
+ * Structures
+ */
+
+struct uvc_video
+{
+	struct usb_ep *ep;
+
+	/* Frame parameters */
+	u8 bpp;
+	u32 fcc;
+	unsigned int width;
+	unsigned int height;
+	unsigned int imagesize;
+	struct mutex mutex;	/* protects frame parameters */
+
+	/* Requests */
+	unsigned int req_size;
+	struct usb_request *req[UVC_NUM_REQUESTS];
+	__u8 *req_buffer[UVC_NUM_REQUESTS];
+	struct list_head req_free;
+	spinlock_t req_lock;
+
+	void (*encode) (struct usb_request *req, struct uvc_video *video,
+			struct uvc_buffer *buf);
+
+	/* Context data used by the completion handler */
+	__u32 payload_size;
+	__u32 max_payload_size;
+
+	struct uvc_video_queue queue;
+	unsigned int fid;
+};
+
+enum uvc_state
+{
+	UVC_STATE_DISCONNECTED,
+	UVC_STATE_CONNECTED,
+	UVC_STATE_STREAMING,
+};
+
+#define FMT_MJPEG
+
+#ifdef FMT_MJPEG
+#define FRAME_SIZE   1024 * 1024
+#else
+#define FRAME_SIZE    640 * 360 * 2
+#endif
+struct frame_info
+{
+#if UVC_FLICKER_FIXED
+	void *buf;
+#else
+	char buf[FRAME_SIZE];
+#endif
+	int total_size;
+	int bused_size;
+	int nodata;
+};
+
+struct uvc_device
+{
+	struct video_device vdev;
+	struct v4l2_device v4l2_dev;
+	enum uvc_state state;
+	struct usb_function func;
+	struct uvc_video video;
+
+	/* Descriptors */
+	struct {
+		const struct uvc_descriptor_header * const *fs_control;
+		const struct uvc_descriptor_header * const *ss_control;
+		const struct uvc_descriptor_header * const *fs_streaming;
+		const struct uvc_descriptor_header * const *hs_streaming;
+		const struct uvc_descriptor_header * const *ss_streaming;
+	} desc;
+
+	unsigned int control_intf;
+	struct usb_ep *control_ep;
+	struct usb_request *control_req;
+	void *control_buf;
+
+	unsigned int streaming_intf;
+
+	/* Events */
+	unsigned int event_length;
+	unsigned int event_setup_out : 1;
+#if 1
+	struct list_head req_free;
+	struct usb_request *req[UVC_NUM_REQUESTS];
+	char *req_buffer[UVC_NUM_REQUESTS];
+	struct usb_ep *ep;
+	unsigned int MaxPacketSize;
+	unsigned int fid;
+	struct file    *video_filp;
+	int current_used;
+	struct frame_info frame[2];
+	int streamon;
+	int malloced;
+	int delay;
+#endif
+};
+
+static inline struct uvc_device *to_uvc(struct usb_function *f)
+{
+	return container_of(f, struct uvc_device, func);
+}
+
+struct uvc_file_handle
+{
+	struct v4l2_fh vfh;
+	struct uvc_video *device;
+};
+
+#define to_uvc_file_handle(handle) \
+	container_of(handle, struct uvc_file_handle, vfh)
+
+/* ------------------------------------------------------------------------
+ * Functions
+ */
+
+extern void uvc_function_setup_continue(struct uvc_device *uvc);
+extern void uvc_endpoint_stream(struct uvc_device *dev);
+
+extern void uvc_function_connect(struct uvc_device *uvc);
+extern void uvc_function_disconnect(struct uvc_device *uvc);
+
+#endif /* __KERNEL__ */
+
+#endif /* _UVC_GADGET_H_ */
+
diff --git a/drivers/uvc_camera/uvc/uvc_configfs.h b/drivers/uvc_camera/uvc/uvc_configfs.h
new file mode 100644
index 0000000..085e67b
--- /dev/null
+++ b/drivers/uvc_camera/uvc/uvc_configfs.h
@@ -0,0 +1,22 @@
+/*
+ * uvc_configfs.h
+ *
+ * Configfs support for the uvc function.
+ *
+ * Copyright (c) 2014 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ *
+ * Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef UVC_CONFIGFS_H
+#define UVC_CONFIGFS_H
+
+struct f_uvc_opts;
+
+int uvcg_attach_configfs(struct f_uvc_opts *opts);
+
+#endif /* UVC_CONFIGFS_H */
diff --git a/drivers/uvc_camera/uvc/uvc_gadget.c b/drivers/uvc_camera/uvc/uvc_gadget.c
new file mode 100644
index 0000000..bc6f9f6
--- /dev/null
+++ b/drivers/uvc_camera/uvc/uvc_gadget.c
@@ -0,0 +1,163 @@
+
+/*
+ * uvc_gadget.c
+ *
+ * Copyright (c) 2015 Ambarella Co., Ltd.
+ * 		Jorney Tu <qtu@ambarella.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+static void
+uvc_fill_streaming_control(struct uvc_streaming_control *ctrl)// 1, 0
+{
+
+	memset(ctrl, 0, sizeof *ctrl);
+
+	ctrl->bmHint = 1;
+	ctrl->bFormatIndex = 0 + 1;
+	ctrl->bFrameIndex = 0 + 1;
+	ctrl->dwFrameInterval = 666666;
+	ctrl->dwMaxVideoFrameSize = 64 * 1024;
+	ctrl->dwMaxPayloadTransferSize = 512;	/* TODO this should be filled by the driver. */
+	ctrl->bmFramingInfo = 3;
+	ctrl->bPreferedVersion = 1;
+	ctrl->bMaxVersion = 1;
+}
+static void
+uvc_events_process_control( uint8_t req, uint8_t cs,
+		struct usb_request *resp)
+{
+	char *buf = (char *)resp->buf;
+#if 0
+	printk("control request (req %02x cs %02x)\n", req, cs);
+#endif
+	switch (req) {
+	case UVC_SET_CUR:
+		buf[0] = 0x00;
+		resp->length = 1;
+		break;
+
+	case UVC_GET_CUR:
+		buf[0] = 0x00;
+		buf[1] = 0x22;
+		resp->length = 2;
+		break;
+
+	case UVC_GET_MIN:
+	case UVC_GET_MAX:
+	case UVC_GET_DEF:
+		buf[0] = 0x00;
+		buf[1] = 0x22;
+		resp->length = 2;
+		break;
+
+	case UVC_GET_RES:
+		buf[0] = 0x00;
+		buf[1] = 0x22;
+		resp->length = 2;
+		break;
+
+	case UVC_GET_LEN:
+		buf[0] = 0x00;
+		buf[1] = 0x22;
+		resp->length = 2;
+		break;
+
+	case UVC_GET_INFO:
+		buf[0] = 0x03;
+		resp->length = 1;
+		break;
+	}
+}
+
+static void
+uvc_events_process_streaming( uint8_t req, uint8_t cs,
+			     struct usb_request *resp)
+{
+	struct uvc_streaming_control *ctrl;
+	char *buf = (char *)resp->buf;
+
+#if 0
+	printk("streaming request (req %02x cs %02x)\n", req, cs);
+#endif
+
+	if (cs != UVC_VS_PROBE_CONTROL && cs != UVC_VS_COMMIT_CONTROL)
+		return;
+
+	ctrl = (struct uvc_streaming_control *)resp->buf;
+	resp->length = sizeof *ctrl;
+
+	switch (req) {
+	case UVC_SET_CUR:
+		resp->length = 34;
+		break;
+
+	case UVC_GET_CUR:
+
+	case UVC_GET_MIN:
+	case UVC_GET_MAX:
+	case UVC_GET_DEF:
+		uvc_fill_streaming_control(ctrl);
+		break;
+
+	case UVC_GET_RES:
+		memset(ctrl, 0, sizeof *ctrl);
+		break;
+
+	case UVC_GET_LEN:
+		buf[0] = 0x00;
+		buf[1] = 0x22;
+		resp->length = 2;
+		break;
+
+	case UVC_GET_INFO:
+		buf[0] = 0x03;
+		resp->length = 1;
+		break;
+	}
+}
+
+
+static void
+uvc_events_process_class(const struct usb_ctrlrequest *ctrl,
+			 struct usb_request *resp)
+{
+
+	if ((ctrl->bRequestType & USB_RECIP_MASK) != USB_RECIP_INTERFACE)
+		return;
+
+	switch (ctrl->wIndex & 0xff) {
+	case UVC_INTF_CONTROL:
+		uvc_events_process_control(ctrl->bRequest, ctrl->wValue >> 8, resp);
+		break;
+
+#if AUDIO_OPEN
+	case 3:
+#else
+	case UVC_INTF_STREAMING:
+#endif
+		uvc_events_process_streaming(ctrl->bRequest, ctrl->wValue >> 8, resp);
+		break;
+
+	default:
+		break;
+	}
+}
+static void
+uvc_events_process_setup(const struct usb_ctrlrequest *ctrl, struct usb_request *req)
+{
+
+	switch (ctrl->bRequestType & USB_TYPE_MASK) {
+	case USB_TYPE_STANDARD:
+		break;
+
+	case USB_TYPE_CLASS:
+		uvc_events_process_class(ctrl, req);
+		break;
+
+	default:
+		break;
+	}
+}
diff --git a/drivers/uvc_camera/uvc/uvc_queue.h b/drivers/uvc_camera/uvc/uvc_queue.h
new file mode 100644
index 0000000..01ca9ea
--- /dev/null
+++ b/drivers/uvc_camera/uvc/uvc_queue.h
@@ -0,0 +1,96 @@
+#ifndef _UVC_QUEUE_H_
+#define _UVC_QUEUE_H_
+
+#ifdef __KERNEL__
+
+#include <linux/kernel.h>
+#include <linux/poll.h>
+#include <linux/videodev2.h>
+#include <media/videobuf2-core.h>
+
+/* Maximum frame size in bytes, for sanity checking. */
+#define UVC_MAX_FRAME_SIZE	(16*1024*1024)
+/* Maximum number of video buffers. */
+#define UVC_MAX_VIDEO_BUFFERS	32
+
+/* ------------------------------------------------------------------------
+ * Structures.
+ */
+
+enum uvc_buffer_state {
+	UVC_BUF_STATE_IDLE	= 0,
+	UVC_BUF_STATE_QUEUED	= 1,
+	UVC_BUF_STATE_ACTIVE	= 2,
+	UVC_BUF_STATE_DONE	= 3,
+	UVC_BUF_STATE_ERROR	= 4,
+};
+
+struct uvc_buffer {
+	struct vb2_buffer buf;
+	struct list_head queue;
+
+	enum uvc_buffer_state state;
+	void *mem;
+	unsigned int length;
+	unsigned int bytesused;
+};
+
+#define UVC_QUEUE_DISCONNECTED		(1 << 0)
+#define UVC_QUEUE_DROP_INCOMPLETE	(1 << 1)
+#define UVC_QUEUE_PAUSED		(1 << 2)
+
+struct uvc_video_queue {
+	struct vb2_queue queue;
+
+	unsigned int flags;
+	__u32 sequence;
+
+	unsigned int buf_used;
+
+	spinlock_t irqlock;	/* Protects flags and irqqueue */
+	struct list_head irqqueue;
+};
+
+static inline int uvc_queue_streaming(struct uvc_video_queue *queue)
+{
+	return vb2_is_streaming(&queue->queue);
+}
+
+int uvcg_queue_init(struct uvc_video_queue *queue, enum v4l2_buf_type type,
+		    struct mutex *lock);
+
+void uvcg_free_buffers(struct uvc_video_queue *queue);
+
+int uvcg_alloc_buffers(struct uvc_video_queue *queue,
+		       struct v4l2_requestbuffers *rb);
+
+int uvcg_query_buffer(struct uvc_video_queue *queue, struct v4l2_buffer *buf);
+
+int uvcg_queue_buffer(struct uvc_video_queue *queue, struct v4l2_buffer *buf);
+
+int uvcg_dequeue_buffer(struct uvc_video_queue *queue,
+			struct v4l2_buffer *buf, int nonblocking);
+
+unsigned int uvcg_queue_poll(struct uvc_video_queue *queue,
+			     struct file *file, poll_table *wait);
+
+int uvcg_queue_mmap(struct uvc_video_queue *queue, struct vm_area_struct *vma);
+
+#ifndef CONFIG_MMU
+unsigned long uvcg_queue_get_unmapped_area(struct uvc_video_queue *queue,
+					   unsigned long pgoff);
+#endif /* CONFIG_MMU */
+
+void uvcg_queue_cancel(struct uvc_video_queue *queue, int disconnect);
+
+int uvcg_queue_enable(struct uvc_video_queue *queue, int enable);
+
+struct uvc_buffer *uvcg_queue_next_buffer(struct uvc_video_queue *queue,
+					  struct uvc_buffer *buf);
+
+struct uvc_buffer *uvcg_queue_head(struct uvc_video_queue *queue);
+
+#endif /* __KERNEL__ */
+
+#endif /* _UVC_QUEUE_H_ */
+
diff --git a/drivers/uvc_camera/uvc/uvc_stream.c b/drivers/uvc_camera/uvc/uvc_stream.c
new file mode 100644
index 0000000..d39183b
--- /dev/null
+++ b/drivers/uvc_camera/uvc/uvc_stream.c
@@ -0,0 +1,178 @@
+/*
+ * uvc_stream.c
+ *
+ * Copyright (c) 2015 Ambarella Co., Ltd.
+ * 		Jorney Tu <qtu@ambarella.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include "u_uvc.h"
+#include "uvc.h"
+#include "uvc_configfs.h"
+#include "uvc_stream.h"
+
+
+#define  VIDEO_DEV	"/dev/iav"
+
+int video_open_iav(struct uvc_device *uvc)
+{
+#if VIDEO_DEBUG
+	uvc->video_filp = filp_open(VIDEO_DEBUG_FILE, O_RDWR, 0);
+#else
+	uvc->video_filp = filp_open(VIDEO_DEV, O_RDWR, 0);
+#endif
+	if(IS_ERR(uvc->video_filp)){
+		printk("%s unable open video device\n", __FUNCTION__);
+		return PTR_ERR(uvc->video_filp);
+	}
+	return 0;
+}
+int video_kthread_get_frame(void *arg)
+{
+	struct uvc_device *uvc = (struct uvc_device*)arg;
+	struct iav_framedesc frame_desc;
+	int ret = 0;
+	int len, extra_len;
+
+	unsigned long iav_buf_start = 0;
+	unsigned long iav_buf_end = 0;
+
+	unsigned long iav_virt = 0;
+	unsigned int iav_size = 0;
+
+	int unused ;
+
+	iav_fetch_bsbinfo(&iav_virt, &iav_size);
+
+	iav_buf_start = iav_virt;
+	iav_buf_end = iav_virt + iav_size;
+
+	while(1){
+
+		unused = (uvc->current_used == 0) ? 1 : 0;
+
+#if VIDEO_DEBUG
+		{
+			int size;
+			char *buf;
+			mm_segment_t fs;
+			loff_t pos;
+
+			size = vfs_llseek(file, 0 ,SEEK_END);
+
+			if(uvc->current_used  == -1){
+				uvc->current_used = 0;
+				buf = uvc->frame[0].buf;
+				uvc->frame[0].total_size = size;
+				uvc->frame[0].bused_size = 0;
+				uvc->frame[0].nodata = 0;
+			}else{
+				buf = uvc->frame[unused].buf;
+				uvc->frame[unused].total_size = size;
+				uvc->frame[unused].bused_size = 0;
+				uvc->frame[unused].nodata = 0;
+			}
+
+			pos = 0;
+			fs  = get_fs();
+			set_fs(KERNEL_DS);
+
+			ret = vfs_read(file, buf, size, &pos);
+
+			set_fs(fs);
+		}
+#else
+		memset(&frame_desc, 0, sizeof(frame_desc));
+		frame_desc.id = -1;
+
+		ret = iav_fetch_framedesc(&frame_desc);
+		if(ret < 0){
+			printk("%s get frame descriptor failed\n", __FUNCTION__);
+			return 0;
+		}
+
+		if (frame_desc.size > FRAME_SIZE)
+			BUG();
+
+		if (uvc->current_used == -1){
+
+			uvc->current_used = 0;
+
+			if (frame_desc.data_addr_offset + frame_desc.size <= iav_buf_end){
+#if UVC_FLICKER_FIXED
+				uvc->frame[0].buf = (void*)frame_desc.data_addr_offset;
+#else
+				memcpy(uvc->frame[0].buf, (void *)frame_desc.data_addr_offset, frame_desc.size );
+#endif
+				uvc->frame[0].total_size = frame_desc.size;
+				uvc->frame[0].bused_size = 0;
+				uvc->frame[0].nodata = 0;
+			}else{
+				len = iav_buf_end - frame_desc.data_addr_offset;
+#if UVC_FLICKER_FIXED
+				uvc->frame[0].buf = (void*)frame_desc.data_addr_offset;
+				uvc->frame[0].total_size = len;
+				uvc->frame[0].bused_size = 0;
+				uvc->frame[0].nodata = 0;
+#else
+				memcpy(uvc->frame[0].buf, (void *)frame_desc.data_addr_offset, len);
+
+				extra_len = frame_desc.size - len;
+				memcpy(uvc->frame[0].buf + len , (void *)iav_buf_start, extra_len);
+
+				uvc->frame[0].total_size = frame_desc.size;
+				uvc->frame[0].bused_size = 0;
+				uvc->frame[0].nodata = 0;
+#endif
+			}
+			continue;
+		}
+
+		if (frame_desc.data_addr_offset + frame_desc.size <= iav_buf_end){
+#if UVC_FLICKER_FIXED
+			uvc->frame[unused].buf = (void*)frame_desc.data_addr_offset;
+#else
+			memcpy(uvc->frame[unused].buf, (void *)frame_desc.data_addr_offset, frame_desc.size );
+#endif
+			uvc->frame[unused].total_size = frame_desc.size;
+			uvc->frame[unused].bused_size = 0;
+			uvc->frame[unused].nodata = 0;
+		}else{
+			len = iav_buf_end - frame_desc.data_addr_offset;
+#if UVC_FLICKER_FIXED
+			extra_len = 0;
+			uvc->frame[unused].buf = (void*)frame_desc.data_addr_offset;
+			uvc->frame[unused].total_size = len;    /* FIXME lost same frame data, but it's OK ?*/
+			uvc->frame[unused].bused_size = 0;
+			uvc->frame[unused].nodata = 0;
+#else
+			memcpy(uvc->frame[unused].buf, (void *)frame_desc.data_addr_offset, len);
+
+			extra_len = frame_desc.size - len;
+			memcpy(uvc->frame[unused].buf + len , (void *)iav_buf_start, len);
+
+			uvc->frame[unused].total_size = frame_desc.size;
+			uvc->frame[unused].bused_size = 0;
+			uvc->frame[unused].nodata = 0;
+#endif
+		}
+
+#endif
+
+		//msleep(1);
+	}
+
+	return 0;
+
+}
+int video_close_iav(struct uvc_device *uvc)
+{
+	if(uvc->video_filp)
+		filp_close(uvc->video_filp, NULL);
+
+	return 0;
+}
diff --git a/drivers/uvc_camera/uvc/uvc_stream.h b/drivers/uvc_camera/uvc/uvc_stream.h
new file mode 100644
index 0000000..401019c
--- /dev/null
+++ b/drivers/uvc_camera/uvc/uvc_stream.h
@@ -0,0 +1,14 @@
+#ifndef __UVC_STREAM__
+#define __UVC_STREAM__
+#include <iav_ioctl.h>
+
+
+extern int iav_fetch_bsbinfo(unsigned long *iav_bsb_virt, u32 *iav_bsb_size);
+
+extern int iav_fetch_framedesc(struct iav_framedesc *);
+
+int video_open_iav(struct uvc_device *uvc);
+int video_kthread_get_frame(void *arg);
+int video_close_iav(struct uvc_device *uvc);
+
+#endif
diff --git a/drivers/uvc_camera/uvc/uvc_v4l2.h b/drivers/uvc_camera/uvc/uvc_v4l2.h
new file mode 100644
index 0000000..2683b92
--- /dev/null
+++ b/drivers/uvc_camera/uvc/uvc_v4l2.h
@@ -0,0 +1,22 @@
+/*
+ *	uvc_v4l2.h  --  USB Video Class Gadget driver
+ *
+ * Copyright (C) 2009-2010
+ *		Laurent Pinchart (laurent.pinchart@ideasonboard.com)
+ *
+ * Copyright (c) 2013 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ *		Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __UVC_V4L2_H__
+#define __UVC_V4L2_H__
+
+extern const struct v4l2_ioctl_ops uvc_v4l2_ioctl_ops;
+extern struct v4l2_file_operations uvc_v4l2_fops;
+
+#endif /* __UVC_V4L2_H__ */
diff --git a/drivers/uvc_camera/uvc/uvc_video.h b/drivers/uvc_camera/uvc/uvc_video.h
new file mode 100644
index 0000000..ef00f06
--- /dev/null
+++ b/drivers/uvc_camera/uvc/uvc_video.h
@@ -0,0 +1,24 @@
+/*
+ *	uvc_video.h  --  USB Video Class Gadget driver
+ *
+ * Copyright (C) 2009-2010
+ *		Laurent Pinchart (laurent.pinchart@ideasonboard.com)
+ *
+ * Copyright (c) 2013 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ *		Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __UVC_VIDEO_H__
+#define __UVC_VIDEO_H__
+
+int uvcg_video_pump(struct uvc_video *video);
+
+int uvcg_video_enable(struct uvc_video *video, int enable);
+
+int uvcg_video_init(struct uvc_video *video);
+
+#endif /* __UVC_VIDEO_H__ */
diff --git a/drivers/uvc_camera/uvc/webcam.c b/drivers/uvc_camera/uvc/webcam.c
new file mode 100644
index 0000000..3a82cb0
--- /dev/null
+++ b/drivers/uvc_camera/uvc/webcam.c
@@ -0,0 +1,480 @@
+/*
+ *	webcam.c -- USB webcam gadget driver
+ *
+ *	Copyright (C) 2009-2010
+ *	    Laurent Pinchart (laurent.pinchart@ideasonboard.com)
+ *
+ * Copyright (c) 2015 Ambarella Co., Ltd.
+ * 		Jorney Tu <qtu@ambarella.com>
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/usb/video.h>
+
+#include "u_uvc.h"
+#include "../defconfig.h"
+
+USB_GADGET_COMPOSITE_OPTIONS();
+
+/*-------------------------------------------------------------------------*/
+
+/* module parameters specific to the Video streaming endpoint */
+static unsigned int streaming_interval = 1;
+module_param(streaming_interval, uint, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(streaming_interval, "1 - 16");
+
+static unsigned int streaming_maxpacket = 1024;
+module_param(streaming_maxpacket, uint, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(streaming_maxpacket, "1 - 1023 (FS), 1 - 3072 (hs/ss)");
+
+static unsigned int streaming_maxburst;
+module_param(streaming_maxburst, uint, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(streaming_maxburst, "0 - 15 (ss only)");
+
+static unsigned int trace;
+module_param(trace, uint, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(trace, "Trace level bitmask");
+/* --------------------------------------------------------------------------
+ * Device descriptor
+ */
+
+#define WEBCAM_VENDOR_ID		0x1d6b	/* Linux Foundation */
+#define WEBCAM_PRODUCT_ID		0x0102	/* Webcam A/V gadget */
+#define WEBCAM_DEVICE_BCD		0x0010	/* 0.10 */
+
+static char webcam_vendor_label[] = "Linux Foundation";
+static char webcam_product_label[] = "Webcam gadget";
+static char webcam_config_label[] = "Video";
+
+/* string IDs are assigned dynamically */
+
+#define STRING_DESCRIPTION_IDX		USB_GADGET_FIRST_AVAIL_IDX
+
+static struct usb_string webcam_strings[] = {
+	[USB_GADGET_MANUFACTURER_IDX].s = webcam_vendor_label,
+	[USB_GADGET_PRODUCT_IDX].s = webcam_product_label,
+	[USB_GADGET_SERIAL_IDX].s = "",
+	[STRING_DESCRIPTION_IDX].s = webcam_config_label,
+	{  }
+};
+
+static struct usb_gadget_strings webcam_stringtab = {
+	.language = 0x0409,	/* en-us */
+	.strings = webcam_strings,
+};
+
+static struct usb_gadget_strings *webcam_device_strings[] = {
+	&webcam_stringtab,
+	NULL,
+};
+
+static struct usb_function_instance *fi_uvc;
+static struct usb_function *f_uvc;
+
+static struct usb_device_descriptor webcam_device_descriptor = {
+	.bLength		= USB_DT_DEVICE_SIZE,
+	.bDescriptorType	= USB_DT_DEVICE,
+	.bcdUSB			= cpu_to_le16(0x0200),
+	.bDeviceClass		= USB_CLASS_MISC,
+	.bDeviceSubClass	= 0x02,
+	.bDeviceProtocol	= 0x01,
+	.bMaxPacketSize0	= 0, /* dynamic */
+	.idVendor		= cpu_to_le16(WEBCAM_VENDOR_ID),
+	.idProduct		= cpu_to_le16(WEBCAM_PRODUCT_ID),
+	.bcdDevice		= cpu_to_le16(WEBCAM_DEVICE_BCD),
+	.iManufacturer		= 0, /* dynamic */
+	.iProduct		= 0, /* dynamic */
+	.iSerialNumber		= 0, /* dynamic */
+	.bNumConfigurations	= 0, /* dynamic */
+};
+
+DECLARE_UVC_HEADER_DESCRIPTOR(1);
+
+static const struct UVC_HEADER_DESCRIPTOR(1) uvc_control_header = {
+	.bLength		= UVC_DT_HEADER_SIZE(1),
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubType	= UVC_VC_HEADER,
+	.bcdUVC			= cpu_to_le16(0x0100),
+	.wTotalLength		= 0, /* dynamic */
+	.dwClockFrequency	= cpu_to_le32(48000000),
+	.bInCollection		= 0, /* dynamic */
+	.baInterfaceNr[0]	= 0, /* dynamic */
+};
+
+static const struct uvc_camera_terminal_descriptor uvc_camera_terminal = {
+	.bLength		= UVC_DT_CAMERA_TERMINAL_SIZE(3),
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubType	= UVC_VC_INPUT_TERMINAL,
+	.bTerminalID		= 1,
+	.wTerminalType		= cpu_to_le16(0x0201),
+	.bAssocTerminal		= 0,
+	.iTerminal		= 0,
+	.wObjectiveFocalLengthMin	= cpu_to_le16(0),
+	.wObjectiveFocalLengthMax	= cpu_to_le16(0),
+	.wOcularFocalLength		= cpu_to_le16(0),
+	.bControlSize		= 3,
+	.bmControls[0]		= 2,
+	.bmControls[1]		= 0,
+	.bmControls[2]		= 0,
+};
+
+static const struct uvc_processing_unit_descriptor uvc_processing = {
+	.bLength		= UVC_DT_PROCESSING_UNIT_SIZE(2),
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubType	= UVC_VC_PROCESSING_UNIT,
+	.bUnitID		= 2,
+	.bSourceID		= 1,
+	.wMaxMultiplier		= cpu_to_le16(16*1024),
+	.bControlSize		= 2,
+	.bmControls[0]		= 1,
+	.bmControls[1]		= 0,
+	.iProcessing		= 0,
+};
+
+static const struct uvc_output_terminal_descriptor uvc_output_terminal = {
+	.bLength		= UVC_DT_OUTPUT_TERMINAL_SIZE,
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubType	= UVC_VC_OUTPUT_TERMINAL,
+	.bTerminalID		= 3,
+	.wTerminalType		= cpu_to_le16(0x0101),
+	.bAssocTerminal		= 0,
+	.bSourceID		= 2,
+	.iTerminal		= 0,
+};
+
+DECLARE_UVC_INPUT_HEADER_DESCRIPTOR(1, 2);
+
+static const struct UVC_INPUT_HEADER_DESCRIPTOR(1, 2) uvc_input_header = {
+	.bLength		= UVC_DT_INPUT_HEADER_SIZE(1, 2),
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubType	= UVC_VS_INPUT_HEADER,
+	.bNumFormats		= 2,
+	.wTotalLength		= 0, /* dynamic */
+	.bEndpointAddress	= 0, /* dynamic */
+	.bmInfo			= 0,
+	.bTerminalLink		= 3,
+	.bStillCaptureMethod	= 0,
+	.bTriggerSupport	= 0,
+	.bTriggerUsage		= 0,
+	.bControlSize		= 1,
+	.bmaControls[0][0]	= 0,
+	.bmaControls[1][0]	= 4,
+};
+
+static const struct uvc_format_uncompressed uvc_format_yuv = {
+	.bLength		= UVC_DT_FORMAT_UNCOMPRESSED_SIZE,
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubType	= UVC_VS_FORMAT_UNCOMPRESSED,
+	.bFormatIndex		= 1,
+	.bNumFrameDescriptors	= 2,
+	.guidFormat		=
+		{ 'Y',  'U',  'Y',  '2', 0x00, 0x00, 0x10, 0x00,
+		 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71},
+	.bBitsPerPixel		= 16,
+	.bDefaultFrameIndex	= 1,
+	.bAspectRatioX		= 0,
+	.bAspectRatioY		= 0,
+	.bmInterfaceFlags	= 0,
+	.bCopyProtect		= 0,
+};
+
+DECLARE_UVC_FRAME_UNCOMPRESSED(1);
+DECLARE_UVC_FRAME_UNCOMPRESSED(3);
+
+static const struct UVC_FRAME_UNCOMPRESSED(3) uvc_frame_yuv_360p = {
+	.bLength		= UVC_DT_FRAME_UNCOMPRESSED_SIZE(3),
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubType	= UVC_VS_FRAME_UNCOMPRESSED,
+	.bFrameIndex		= 1,
+	.bmCapabilities		= 0,
+	.wWidth			= cpu_to_le16(640),
+	.wHeight		= cpu_to_le16(360),
+	.dwMinBitRate		= cpu_to_le32(18432000),
+	.dwMaxBitRate		= cpu_to_le32(55296000),
+	.dwMaxVideoFrameBufferSize	= cpu_to_le32(460800),
+	.dwDefaultFrameInterval	= cpu_to_le32(666666),
+	.bFrameIntervalType	= 3,
+	.dwFrameInterval[0]	= cpu_to_le32(666666),
+	.dwFrameInterval[1]	= cpu_to_le32(1000000),
+	.dwFrameInterval[2]	= cpu_to_le32(5000000),
+};
+
+static const struct UVC_FRAME_UNCOMPRESSED(1) uvc_frame_yuv_720p = {
+	.bLength		= UVC_DT_FRAME_UNCOMPRESSED_SIZE(1),
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubType	= UVC_VS_FRAME_UNCOMPRESSED,
+	.bFrameIndex		= 2,
+	.bmCapabilities		= 0,
+	.wWidth			= cpu_to_le16(1280),
+	.wHeight		= cpu_to_le16(720),
+	.dwMinBitRate		= cpu_to_le32(29491200),
+	.dwMaxBitRate		= cpu_to_le32(29491200),
+	.dwMaxVideoFrameBufferSize	= cpu_to_le32(1843200),
+	.dwDefaultFrameInterval	= cpu_to_le32(5000000),
+	.bFrameIntervalType	= 1,
+	.dwFrameInterval[0]	= cpu_to_le32(5000000),
+};
+
+static const struct uvc_format_mjpeg uvc_format_mjpg = {
+	.bLength		= UVC_DT_FORMAT_MJPEG_SIZE,
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubType	= UVC_VS_FORMAT_MJPEG,
+	.bFormatIndex		= 2,
+	.bNumFrameDescriptors	= 2,
+	.bmFlags		= 0,
+	.bDefaultFrameIndex	= 1,
+	.bAspectRatioX		= 0,
+	.bAspectRatioY		= 0,
+	.bmInterfaceFlags	= 0,
+	.bCopyProtect		= 0,
+};
+
+DECLARE_UVC_FRAME_MJPEG(1);
+DECLARE_UVC_FRAME_MJPEG(3);
+
+static const struct UVC_FRAME_MJPEG(3) uvc_frame_mjpg_360p = {
+	.bLength		= UVC_DT_FRAME_MJPEG_SIZE(3),
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubType	= UVC_VS_FRAME_MJPEG,
+	.bFrameIndex		= 1,
+	.bmCapabilities		= 0,
+	.wWidth			= cpu_to_le16(640),
+	.wHeight		= cpu_to_le16(360),
+	.dwMinBitRate		= cpu_to_le32(18432000),
+	.dwMaxBitRate		= cpu_to_le32(55296000),
+	.dwMaxVideoFrameBufferSize	= cpu_to_le32(460800),
+	.dwDefaultFrameInterval	= cpu_to_le32(666666),
+	.bFrameIntervalType	= 3,
+	.dwFrameInterval[0]	= cpu_to_le32(666666),
+	.dwFrameInterval[1]	= cpu_to_le32(1000000),
+	.dwFrameInterval[2]	= cpu_to_le32(5000000),
+};
+
+static const struct UVC_FRAME_MJPEG(1) uvc_frame_mjpg_720p = {
+	.bLength		= UVC_DT_FRAME_MJPEG_SIZE(1),
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubType	= UVC_VS_FRAME_MJPEG,
+	.bFrameIndex		= 2,
+	.bmCapabilities		= 0,
+	.wWidth			= cpu_to_le16(1280),
+	.wHeight		= cpu_to_le16(720),
+	.dwMinBitRate		= cpu_to_le32(29491200),
+	.dwMaxBitRate		= cpu_to_le32(29491200),
+	.dwMaxVideoFrameBufferSize	= cpu_to_le32(1843200),
+	.dwDefaultFrameInterval	= cpu_to_le32(5000000),
+	.bFrameIntervalType	= 1,
+	.dwFrameInterval[0]	= cpu_to_le32(5000000),
+};
+
+static const struct uvc_color_matching_descriptor uvc_color_matching = {
+	.bLength		= UVC_DT_COLOR_MATCHING_SIZE,
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubType	= UVC_VS_COLORFORMAT,
+	.bColorPrimaries	= 1,
+	.bTransferCharacteristics	= 1,
+	.bMatrixCoefficients	= 4,
+};
+
+static const struct uvc_descriptor_header * const uvc_fs_control_cls[] = {
+	(const struct uvc_descriptor_header *) &uvc_control_header,
+	(const struct uvc_descriptor_header *) &uvc_camera_terminal,
+	(const struct uvc_descriptor_header *) &uvc_processing,
+	(const struct uvc_descriptor_header *) &uvc_output_terminal,
+	NULL,
+};
+
+static const struct uvc_descriptor_header * const uvc_ss_control_cls[] = {
+	(const struct uvc_descriptor_header *) &uvc_control_header,
+	(const struct uvc_descriptor_header *) &uvc_camera_terminal,
+	(const struct uvc_descriptor_header *) &uvc_processing,
+	(const struct uvc_descriptor_header *) &uvc_output_terminal,
+	NULL,
+};
+
+static const struct uvc_descriptor_header * const uvc_fs_streaming_cls[] = {
+	(const struct uvc_descriptor_header *) &uvc_input_header,
+	(const struct uvc_descriptor_header *) &uvc_format_yuv,
+	(const struct uvc_descriptor_header *) &uvc_frame_yuv_360p,
+	(const struct uvc_descriptor_header *) &uvc_frame_yuv_720p,
+	(const struct uvc_descriptor_header *) &uvc_format_mjpg,
+	(const struct uvc_descriptor_header *) &uvc_frame_mjpg_360p,
+	(const struct uvc_descriptor_header *) &uvc_frame_mjpg_720p,
+	(const struct uvc_descriptor_header *) &uvc_color_matching,
+	NULL,
+};
+
+static const struct uvc_descriptor_header * const uvc_hs_streaming_cls[] = {
+	(const struct uvc_descriptor_header *) &uvc_input_header,
+	(const struct uvc_descriptor_header *) &uvc_format_yuv,
+	(const struct uvc_descriptor_header *) &uvc_frame_yuv_360p,
+	(const struct uvc_descriptor_header *) &uvc_frame_yuv_720p,
+	(const struct uvc_descriptor_header *) &uvc_format_mjpg,
+	(const struct uvc_descriptor_header *) &uvc_frame_mjpg_360p,
+	(const struct uvc_descriptor_header *) &uvc_frame_mjpg_720p,
+	(const struct uvc_descriptor_header *) &uvc_color_matching,
+	NULL,
+};
+
+static const struct uvc_descriptor_header * const uvc_ss_streaming_cls[] = {
+	(const struct uvc_descriptor_header *) &uvc_input_header,
+	(const struct uvc_descriptor_header *) &uvc_format_yuv,
+	(const struct uvc_descriptor_header *) &uvc_frame_yuv_360p,
+	(const struct uvc_descriptor_header *) &uvc_frame_yuv_720p,
+	(const struct uvc_descriptor_header *) &uvc_format_mjpg,
+	(const struct uvc_descriptor_header *) &uvc_frame_mjpg_360p,
+	(const struct uvc_descriptor_header *) &uvc_frame_mjpg_720p,
+	(const struct uvc_descriptor_header *) &uvc_color_matching,
+	NULL,
+};
+
+/* --------------------------------------------------------------------------
+ * USB configuration
+ */
+
+static int
+webcam_config_bind(struct usb_configuration *c)
+{
+	int status = 0;
+
+#if AUDIO_OPEN
+	if(audio_do_config(c)){
+		printk("audio_do_config failed\n");
+	}
+#endif
+
+	f_uvc = usb_get_function(fi_uvc);
+	if (IS_ERR(f_uvc))
+		return PTR_ERR(f_uvc);
+
+	status = usb_add_function(c, f_uvc);
+	if (status < 0)
+		usb_put_function(f_uvc);
+
+
+	return status;
+}
+
+static struct usb_configuration webcam_config_driver = {
+	.label			= webcam_config_label,
+	.bConfigurationValue	= 1,
+	.iConfiguration		= 0, /* dynamic */
+	.bmAttributes		= USB_CONFIG_ATT_SELFPOWER,
+	.MaxPower		= CONFIG_USB_GADGET_VBUS_DRAW,
+};
+
+static int
+webcam_unbind(struct usb_composite_dev *cdev)
+{
+	if (!IS_ERR_OR_NULL(f_uvc))
+		usb_put_function(f_uvc);
+	if (!IS_ERR_OR_NULL(fi_uvc))
+		usb_put_function_instance(fi_uvc);
+
+#if AUDIO_OPEN
+	audio_unbind(cdev);
+#endif
+	return 0;
+}
+
+static int
+webcam_bind(struct usb_composite_dev *cdev)
+{
+	struct f_uvc_opts *uvc_opts;
+	int ret;
+
+#if AUDIO_OPEN
+	ret = audio_bind(cdev);
+	if(ret < 0){
+		printk("audio_bind failed !\n");
+		return ret;
+	}
+#endif
+
+	fi_uvc = usb_get_function_instance("uvc");
+	if (IS_ERR(fi_uvc))
+		return PTR_ERR(fi_uvc);
+
+	uvc_opts = container_of(fi_uvc, struct f_uvc_opts, func_inst);
+
+	uvc_opts->streaming_interval = streaming_interval;
+	uvc_opts->streaming_maxpacket = streaming_maxpacket;
+	uvc_opts->streaming_maxburst = streaming_maxburst;
+
+	uvc_opts->fs_control = uvc_fs_control_cls;
+	uvc_opts->ss_control = uvc_ss_control_cls;
+	uvc_opts->fs_streaming = uvc_fs_streaming_cls;
+	uvc_opts->hs_streaming = uvc_hs_streaming_cls;
+	uvc_opts->ss_streaming = uvc_ss_streaming_cls;
+
+	/* Allocate string descriptor numbers ... note that string contents
+	 * can be overridden by the composite_dev glue.
+	 */
+	ret = usb_string_ids_tab(cdev, webcam_strings);
+	if (ret < 0)
+		goto error;
+	webcam_device_descriptor.iManufacturer =
+		webcam_strings[USB_GADGET_MANUFACTURER_IDX].id;
+	webcam_device_descriptor.iProduct =
+		webcam_strings[USB_GADGET_PRODUCT_IDX].id;
+	webcam_config_driver.iConfiguration =
+		webcam_strings[STRING_DESCRIPTION_IDX].id;
+
+
+	/* Register our configuration. */
+	if ((ret = usb_add_config(cdev, &webcam_config_driver,
+					webcam_config_bind)) < 0)
+		goto error;
+
+	usb_composite_overwrite_options(cdev, &coverwrite);
+	INFO(cdev, "Webcam Video Gadget\n");
+	return 0;
+
+error:
+	usb_put_function_instance(fi_uvc);
+	return ret;
+}
+
+/* --------------------------------------------------------------------------
+ * Driver
+ */
+
+static struct usb_composite_driver webcam_driver = {
+	.name		= "g_webcam",
+	.dev		= &webcam_device_descriptor,
+	.strings	= webcam_device_strings,
+	.max_speed	= USB_SPEED_SUPER,
+	.bind		= webcam_bind,
+	.unbind		= webcam_unbind,
+};
+
+#if 0
+module_usb_composite_driver(webcam_driver);
+#endif
+
+static int __init
+webcam_init(void)
+{
+	return usb_composite_probe(&webcam_driver);
+}
+
+static void __exit
+webcam_cleanup(void)
+{
+	usb_composite_unregister(&webcam_driver);
+}
+
+module_init(webcam_init);
+module_exit(webcam_cleanup);
+
+MODULE_AUTHOR("Laurent Pinchart");
+MODULE_DESCRIPTION("Webcam Video Gadget");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.1.0");
+
diff --git a/drivers/vin/AmbaConfig b/drivers/vin/AmbaConfig
index 642abc4..7553a33 100644
--- a/drivers/vin/AmbaConfig
+++ b/drivers/vin/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2008/01/16 - [Anthony Ginger] Create
 ##
-## Copyright (C) 2004-2008, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 menuconfig BUILD_AMBARELLA_VIN
diff --git a/drivers/vin/decoders/AmbaConfig b/drivers/vin/decoders/AmbaConfig
index fe9e9fa..03ed58f 100644
--- a/drivers/vin/decoders/AmbaConfig
+++ b/drivers/vin/decoders/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2008/01/16 - [Anthony Ginger] Create
 ##
-## Copyright (C) 2004-2008, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 menu "Ambarella TV decoder Configuration"
diff --git a/drivers/vin/decoders/adv7441a/Kbuild b/drivers/vin/decoders/adv7441a/Kbuild
index c4b97bc..fc8d851 100644
--- a/drivers/vin/decoders/adv7441a/Kbuild
+++ b/drivers/vin/decoders/adv7441a/Kbuild
@@ -3,12 +3,29 @@
 ##
 ## Author: Anthony Ginger <hfjiang@ambarella.com>
 ##
-## Copyright (C) 2004-2010, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS) -I$(AMB_TOPDIR)/kernel/private/drivers/vin
diff --git a/drivers/vin/decoders/adv7441a/adv7441a.c b/drivers/vin/decoders/adv7441a/adv7441a.c
index 5b9c8ed..3c8c1fc 100644
--- a/drivers/vin/decoders/adv7441a/adv7441a.c
+++ b/drivers/vin/decoders/adv7441a/adv7441a.c
@@ -3,15 +3,34 @@
  *
  * Author: Anthony Ginger <hfjiang@ambarella.com>
  *
- * Copyright (C) 2004-2010, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
diff --git a/drivers/vin/decoders/adv7441a/adv7441a.h b/drivers/vin/decoders/adv7441a/adv7441a.h
index 3c97c6f..c8b0289 100644
--- a/drivers/vin/decoders/adv7441a/adv7441a.h
+++ b/drivers/vin/decoders/adv7441a/adv7441a.h
@@ -4,15 +4,34 @@
  * History:
  *    2009/07/23 - [Qiao Wang] Copy form adv7443
  *
- * Copyright (C) 2004-2009, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #ifndef __ADV7441A_PRI_H__
 #define __ADV7441A_PRI_H__
 
diff --git a/drivers/vin/decoders/adv7441a/adv7441a_table.c b/drivers/vin/decoders/adv7441a/adv7441a_table.c
index e423851..d4609ca 100644
--- a/drivers/vin/decoders/adv7441a/adv7441a_table.c
+++ b/drivers/vin/decoders/adv7441a/adv7441a_table.c
@@ -4,15 +4,34 @@
  * History:
  *    2011/01/12 - [Haowei Lo] Create
  *
- * Copyright (C) 2004-2011, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 static struct vin_video_pll adv7441a_plls[] = {
 	{0, 1485000000, 1485000000},
 };
diff --git a/drivers/vin/decoders/adv7441a/make.inc b/drivers/vin/decoders/adv7441a/make.inc
index 418053d..d0bd320 100644
--- a/drivers/vin/decoders/adv7441a/make.inc
+++ b/drivers/vin/decoders/adv7441a/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/04 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_YUV_ADV7441A), y)
diff --git a/drivers/vin/decoders/ambdd/Kbuild b/drivers/vin/decoders/ambdd/Kbuild
index 6b479c8..6fb0b76 100644
--- a/drivers/vin/decoders/ambdd/Kbuild
+++ b/drivers/vin/decoders/ambdd/Kbuild
@@ -3,12 +3,29 @@
 ##
 ## Author: Anthony Ginger <hfjiang@ambarella.com>
 ##
-## Copyright (C) 2004-2010, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS) -I$(AMB_TOPDIR)/kernel/private/drivers/vin
diff --git a/drivers/vin/decoders/ambdd/ambdd.c b/drivers/vin/decoders/ambdd/ambdd.c
index 074ede4..abb964e 100644
--- a/drivers/vin/decoders/ambdd/ambdd.c
+++ b/drivers/vin/decoders/ambdd/ambdd.c
@@ -3,15 +3,34 @@
  *
  * Author: Anthony Ginger <hfjiang@ambarella.com>
  *
- * Copyright (C) 2004-2010, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
diff --git a/drivers/vin/decoders/ambdd/make.inc b/drivers/vin/decoders/ambdd/make.inc
index f8cc1c7..aace2ad 100644
--- a/drivers/vin/decoders/ambdd/make.inc
+++ b/drivers/vin/decoders/ambdd/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/04 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_YUV_AMBDD), y)
diff --git a/drivers/vin/make.inc b/drivers/vin/make.inc
index cfca7c5..d782be0 100644
--- a/drivers/vin/make.inc
+++ b/drivers/vin/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/04 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_VIN), y)
diff --git a/drivers/vin/sensors/AmbaConfig b/drivers/vin/sensors/AmbaConfig
index b84f1b6..d84ee3d 100644
--- a/drivers/vin/sensors/AmbaConfig
+++ b/drivers/vin/sensors/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2008/01/16 - [Anthony Ginger] Create
 ##
-## Copyright (C) 2004-2008, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 
@@ -88,6 +105,30 @@ config CONFIG_SENSOR_OV2718_MIPI
 	help
 		Select Omnivision OV2718 2.1M CMOS sensor with MIPI output.
 
+config CONFIG_SENSOR_OV2732_MIPI
+	bool "Omnivision OV2732 2M CMOS sensor(MIPI)"
+	default n
+	help
+		Select Omnivision OV2732 2M CMOS sensor, with MIPI output.
+
+config CONFIG_SENSOR_OV2732_PARALLEL
+	bool "Omnivision OV2732 2M CMOS sensor(Parallel LVCMOS)"
+	default n
+	help
+		Select Omnivision OV2732 2M CMOS sensor, with parallel output.
+
+config CONFIG_SENSOR_OV2735_MIPI
+        bool "Omnivision OV2735 2M CMOS sensor(MIPI)"
+        default n
+        help
+                Select Omnivision OV2735 2M CMOS sensor, with MIPI output.
+
+config CONFIG_SENSOR_OV2735_PARALLEL
+        bool "Omnivision OV2735 2M CMOS sensor(Parallel LVCMOS)"
+        default n
+        help
+                Select Omnivision OV2735 2M CMOS sensor, with parallel output.
+
 config CONFIG_SENSOR_OV4689_MIPI
 	bool "Omnivision OV4689 4M CMOS sensor(MIPI)"
 	default n
@@ -203,6 +244,18 @@ config CONFIG_SENSOR_IMX123
 	help
 		Select Sony IMX123 3.2M CMOS sensor.
 
+config CONFIG_SENSOR_IMX307
+        bool "Sony IMX307 2.13M CMOS sensor(Serial LVDS)"
+        default n
+        help
+                Select Sony IMX307 2.13M CMOS sensor.
+
+config CONFIG_SENSOR_IMX377_MIPI
+        bool "Sony IMX377 12M CMOS sensor(MIPI)"
+        default n
+        help
+                Select Sony IMX377 12M CMOS sensor, with MIPI output.
+
 config CONFIG_SENSOR_IMX322
 	bool "Sony IMX322 2.12M CMOS sensor(Parallel LVCMOS)"
 	default n
@@ -234,12 +287,30 @@ config CONFIG_SENSOR_IMX290
 	help
 		Select Sony IMX290 2.13M CMOS sensor.
 
+config CONFIG_SENSOR_IMX290_MIPI
+	bool "Sony IMX290 2.13M CMOS sensor(MIPI)"
+	default n
+	help
+		Select Sony IMX290 2.13M CMOS sensor, with MIPI output
+
 config CONFIG_SENSOR_IMX291
 	bool "Sony IMX291 2.13M CMOS sensor(Serial LVDS)"
 	default n
 	help
 		Select Sony IMX291 2.13M CMOS sensor.
 
+config CONFIG_SENSOR_IMX291_MIPI
+	bool "Sony IMX291 2.13M CMOS sensor(MIPI)"
+	default n
+	help
+		Select Sony IMX291 2.13M CMOS sensor, with MIPI output.
+
+config CONFIG_SENSOR_IMX326
+	bool "Sony IMX326 6.64M CMOS sensor(Serial LVDS)"
+	default n
+	help
+		Select Sony IMX326 6.64M CMOS sensor.
+
 config CONFIG_SENSOR_MN34041PL
 	bool "Panasonic MN34041PL 2.1M CMOS sensor(Serial LVDS)"
 	default n
@@ -264,6 +335,12 @@ config CONFIG_SENSOR_MN34227PL
 	help
 		Select Panasonic MN34227PL 2.1M CMOS sensor, with subLVDS output.
 
+config CONFIG_SENSOR_MN34420PL
+	bool "Panasonic MN34420PL 2.4M CMOS sensor(Serial LVDS)"
+	default n
+	help
+		Select Panasonic MN34420PL 2.4M CMOS sensor, with subLVDS output.
+
 config CONFIG_SENSOR_FPGA
 	bool "FPGA pattern card for S2L atb(Serial LVDS)"
 	default n
diff --git a/drivers/vin/sensors/ambds/Kbuild b/drivers/vin/sensors/ambds/Kbuild
index c573a5c..bb09c39 100644
--- a/drivers/vin/sensors/ambds/Kbuild
+++ b/drivers/vin/sensors/ambds/Kbuild
@@ -4,15 +4,30 @@
 ## History:
 ##    2015/01/30 - [Long Zhao] Create
 ##
-## Copyright (C) 2004-2015, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
-## This file is produced by perl.
-##/
 
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/ambds/ambds.c b/drivers/vin/sensors/ambds/ambds.c
index 8296d79..ed4058c 100644
--- a/drivers/vin/sensors/ambds/ambds.c
+++ b/drivers/vin/sensors/ambds/ambds.c
@@ -4,14 +4,33 @@
  * History:
  *    2015/01/30 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2015, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
diff --git a/drivers/vin/sensors/ambds/ambds.h b/drivers/vin/sensors/ambds/ambds.h
index 7ca753b..debee41 100644
--- a/drivers/vin/sensors/ambds/ambds.h
+++ b/drivers/vin/sensors/ambds/ambds.h
@@ -4,15 +4,33 @@
  * History:
  *    2015/01/30 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2015, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #ifndef __AMBDS_PRI_H__
 #define __AMBDS_PRI_H__
 
diff --git a/drivers/vin/sensors/ambds/ambds_table.c b/drivers/vin/sensors/ambds/ambds_table.c
index ab01b9e..aa9a6e4 100644
--- a/drivers/vin/sensors/ambds/ambds_table.c
+++ b/drivers/vin/sensors/ambds/ambds_table.c
@@ -4,14 +4,33 @@
  * History:
  *    2015/01/30 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2015, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_video_pll ambds_plls[] = {
 	/* please set master clock here, amba soc will output this frequency from CLK_SI */
 	{0, 27000000, 72000000},
diff --git a/drivers/vin/sensors/ambds/make.inc b/drivers/vin/sensors/ambds/make.inc
index 522a86c..f3889bd 100644
--- a/drivers/vin/sensors/ambds/make.inc
+++ b/drivers/vin/sensors/ambds/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/04 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_AMBDS), y)
diff --git a/drivers/vin/sensors/micron_ar0130/Kbuild b/drivers/vin/sensors/micron_ar0130/Kbuild
index a517695..9ecd7d9 100644
--- a/drivers/vin/sensors/micron_ar0130/Kbuild
+++ b/drivers/vin/sensors/micron_ar0130/Kbuild
@@ -4,15 +4,30 @@
 ## History:
 ##     2012/05/23 - [Long Zhao] Create
 ##
-## Copyright (C) 2004-2013, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
-## This file is produced by perl.
-##/
 
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/micron_ar0130/ar0130.c b/drivers/vin/sensors/micron_ar0130/ar0130.c
index 403990e..79bd4d7 100644
--- a/drivers/vin/sensors/micron_ar0130/ar0130.c
+++ b/drivers/vin/sensors/micron_ar0130/ar0130.c
@@ -4,15 +4,33 @@
  * History:
  *    2012/05/23 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2013, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
diff --git a/drivers/vin/sensors/micron_ar0130/ar0130.h b/drivers/vin/sensors/micron_ar0130/ar0130.h
index 8a3b841..04d0d53 100644
--- a/drivers/vin/sensors/micron_ar0130/ar0130.h
+++ b/drivers/vin/sensors/micron_ar0130/ar0130.h
@@ -4,15 +4,33 @@
  * History:
  *    2012/05/23 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2013, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #ifndef __AR0130_PRI_H__
 #define __AR0130_PRI_H__
 
diff --git a/drivers/vin/sensors/micron_ar0130/ar0130_table.c b/drivers/vin/sensors/micron_ar0130/ar0130_table.c
index 55c38f0..861f303 100644
--- a/drivers/vin/sensors/micron_ar0130/ar0130_table.c
+++ b/drivers/vin/sensors/micron_ar0130/ar0130_table.c
@@ -4,14 +4,33 @@
  * History:
  *    2012/05/23 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2013, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_reg_16_16 ar0130_pll_regs[][4] = {
 	{
 		{AR0130_VT_PIX_CLK_DIV, 4},
diff --git a/drivers/vin/sensors/micron_ar0130/make.inc b/drivers/vin/sensors/micron_ar0130/make.inc
index 4682f8b..d08a5bf 100644
--- a/drivers/vin/sensors/micron_ar0130/make.inc
+++ b/drivers/vin/sensors/micron_ar0130/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/05/23 - [Long Zhao] Create
 ##
-## Copyright (C) 2012-2013, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_AR0130), y)
diff --git a/drivers/vin/sensors/micron_ar0141/Kbuild b/drivers/vin/sensors/micron_ar0141/Kbuild
index a8e564c..756156b 100644
--- a/drivers/vin/sensors/micron_ar0141/Kbuild
+++ b/drivers/vin/sensors/micron_ar0141/Kbuild
@@ -4,15 +4,30 @@
 ## History:
 ##     2014/11/18 - [Long Zhao] Create
 ##
-## Copyright (C) 2004-2014, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
-## This file is produced by perl.
-##/
 
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/micron_ar0141/ar0141.c b/drivers/vin/sensors/micron_ar0141/ar0141.c
index 63ff29b..15bebfe 100644
--- a/drivers/vin/sensors/micron_ar0141/ar0141.c
+++ b/drivers/vin/sensors/micron_ar0141/ar0141.c
@@ -4,15 +4,33 @@
  * History:
  *    2014/11/18 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
diff --git a/drivers/vin/sensors/micron_ar0141/ar0141.h b/drivers/vin/sensors/micron_ar0141/ar0141.h
index d963214..e789fef 100644
--- a/drivers/vin/sensors/micron_ar0141/ar0141.h
+++ b/drivers/vin/sensors/micron_ar0141/ar0141.h
@@ -4,15 +4,33 @@
  * History:
  *    2014/11/18 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #ifndef __AR0141_PRI_H__
 #define __AR0141_PRI_H__
 
diff --git a/drivers/vin/sensors/micron_ar0141/ar0141_table.c b/drivers/vin/sensors/micron_ar0141/ar0141_table.c
index bf985fd..425daff 100644
--- a/drivers/vin/sensors/micron_ar0141/ar0141_table.c
+++ b/drivers/vin/sensors/micron_ar0141/ar0141_table.c
@@ -4,14 +4,33 @@
  * History:
  *    2014/11/18 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_reg_16_16 ar0141_pll_regs[][6] = {
 	{
 		{0x302A, 0x0006}, /* VT_PIX_CLK_DIV  */
diff --git a/drivers/vin/sensors/micron_ar0141/make.inc b/drivers/vin/sensors/micron_ar0141/make.inc
index 108ce75..41f2f02 100644
--- a/drivers/vin/sensors/micron_ar0141/make.inc
+++ b/drivers/vin/sensors/micron_ar0141/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/11/18 - [Long Zhao] Create
 ##
-## Copyright (C) 2004-2014, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_AR0141), y)
diff --git a/drivers/vin/sensors/micron_ar0230/Kbuild b/drivers/vin/sensors/micron_ar0230/Kbuild
index f59eb59..0f0e59f 100644
--- a/drivers/vin/sensors/micron_ar0230/Kbuild
+++ b/drivers/vin/sensors/micron_ar0230/Kbuild
@@ -4,15 +4,30 @@
 ## History:
 ##     2014/11/18 - [Long Zhao] Create
 ##
-## Copyright (C) 2004-2014, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
-## This file is produced by perl.
-##/
 
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/micron_ar0230/ar0230.c b/drivers/vin/sensors/micron_ar0230/ar0230.c
index a61c4ab..008203e 100644
--- a/drivers/vin/sensors/micron_ar0230/ar0230.c
+++ b/drivers/vin/sensors/micron_ar0230/ar0230.c
@@ -4,15 +4,33 @@
  * History:
  *    2014/11/18 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
@@ -22,6 +40,7 @@
 #include <iav_utils.h>
 #include <vin_api.h>
 #include "ar0230.h"
+#include "ar0230_table.c"
 
 static int bus_addr = (0 << 16) | (0x20 >> 1);
 module_param(bus_addr, int, 0644);
@@ -38,9 +57,7 @@ struct ar0230_priv {
 	u32 line_length;
 };
 
-#include "ar0230_table.c"
-
-static int ar0230_write_reg( struct vin_device *vdev, u32 subaddr, u32 data)
+static int ar0230_write_reg(struct vin_device *vdev, u32 subaddr, u32 data)
 {
 	int rval;
 	struct ar0230_priv *ar0230;
@@ -73,7 +90,7 @@ static int ar0230_write_reg( struct vin_device *vdev, u32 subaddr, u32 data)
 	return 0;
 }
 
-static int ar0230_read_reg( struct vin_device *vdev, u32 subaddr, u32 *data)
+static int ar0230_read_reg(struct vin_device *vdev, u32 subaddr, u32 *data)
 {
 	int rval = 0;
 	struct ar0230_priv *ar0230;
@@ -99,7 +116,7 @@ static int ar0230_read_reg( struct vin_device *vdev, u32 subaddr, u32 *data)
 	msgs[1].len = 2;
 
 	rval = i2c_transfer(client->adapter, msgs, 2);
-	if (rval < 0){
+	if (rval < 0) {
 		vin_error("failed(%d): [0x%x]\n", rval, subaddr);
 		return rval;
 	}
@@ -113,7 +130,7 @@ static int ar0230_set_vin_mode(struct vin_device *vdev, struct vin_video_format
 {
 	struct vin_device_config ar0230_config;
 
-	memset(&ar0230_config, 0, sizeof (ar0230_config));
+	memset(&ar0230_config, 0, sizeof(ar0230_config));
 
 	ar0230_config.interface_type = SENSOR_SERIAL_LVDS;
 	ar0230_config.sync_mode = SENSOR_SYNC_MODE_MASTER;
@@ -181,7 +198,7 @@ static int ar0230_update_hv_info(struct vin_device *vdev)
 	struct ar0230_priv *pinfo = (struct ar0230_priv *)vdev->priv;
 
 	ar0230_read_reg(vdev, AR0230_LINE_LENGTH_PCK, &pinfo->line_length);
-	if(unlikely(!pinfo->line_length)) {
+	if (unlikely(!pinfo->line_length)) {
 		vin_error("line length is 0!\n");
 		return -EIO;
 	}
@@ -269,15 +286,15 @@ static int ar0230_set_shutter_row(struct vin_device *vdev, u32 row)
 	if (vdev->cur_format->hdr_mode == AMBA_VIDEO_INT_HDR_MODE) {
 		ar0230_read_reg(vdev, 0x3082, &t1t2_ratio);
 		t1t2_ratio = 1<<(((t1t2_ratio&0xC)>>2) + 2);
-		max_shutter_width = MIN( 70 * t1t2_ratio, pinfo->frame_length_lines -71);
+		max_shutter_width = MIN(70 * t1t2_ratio, pinfo->frame_length_lines - 71);
 
 		min_line = t1t2_ratio/2;
 		max_line = max_shutter_width;
 		num_line = clamp(num_line, min_line, max_line);
-	} else if (vdev->cur_format->hdr_mode == AMBA_VIDEO_LINEAR_MODE){
-		/* FIXME: shutter width: 1 ~ Frame format(V) */
+	} else if (vdev->cur_format->hdr_mode == AMBA_VIDEO_LINEAR_MODE) {
+		/* FIXME: shutter width: 1 ~ (Frame format(V) - 4) */
 		min_line = 1;
-		max_line = pinfo->frame_length_lines;
+		max_line = pinfo->frame_length_lines - 4;
 		num_line = clamp(num_line, min_line, max_line);
 	}
 
@@ -310,7 +327,8 @@ static int ar0230_set_wdr_shutter_row_group(struct vin_device *vdev,
 	shutter_short = shutter_long/t1t2_ratio;
 
 	/* shutter limitation check */
-	if(shutter_long + shutter_short + 2 > pinfo->frame_length_lines){
+	if ((shutter_long + shutter_short + 2 > pinfo->frame_length_lines) ||
+		(1080 + shutter_short + 2 > pinfo->frame_length_lines)) {
 		vin_error("shutter exceeds limitation! long:%d, short:%d, V:%d, ratio:%d\n",
 			shutter_long, shutter_short, pinfo->frame_length_lines, t1t2_ratio);
 		return -EPERM;
@@ -341,14 +359,14 @@ static int ar0230_get_wdr_shutter_row_group(struct vin_device *vdev,
 	return 0;
 }
 
-static int ar0230_shutter2row(struct vin_device *vdev, u32* shutter_time)
+static int ar0230_shutter2row(struct vin_device *vdev, u32 *shutter_time)
 {
 	u64 exposure_lines;
 	int rval = 0;
 	struct ar0230_priv *pinfo = (struct ar0230_priv *)vdev->priv;
 
 	/* for fast boot, it may call set shutter time directly, so we must read line length/frame line */
-	if(unlikely(!pinfo->line_length)) {
+	if (unlikely(!pinfo->line_length)) {
 		rval = ar0230_update_hv_info(vdev);
 		if (rval < 0)
 			return rval;
@@ -392,10 +410,10 @@ static int ar0230_convert_dgain_ratio(u16 old_dgain, u32 ratio, u16 *new_dgain)
 
 	tmp_dgain = (old_dgain * ratio)/1024;
 
-	if(tmp_dgain > 0x7FF){//dgain should be less than 15.992
+	if (tmp_dgain > 0x7FF) {/* dgain should be less than 15.992 */
 		tmp_dgain = 0x7FF;
-		vin_info("Waring: dgain value is too high!\n");
-	} else if ((ratio != 0)&&(tmp_dgain == 0)){//0<ratio<1/128, set to 1/128
+		vin_warn("dgain value is too high!\n");
+	} else if ((ratio != 0) && (tmp_dgain == 0)) {/* 0<ratio<1/128, set to 1/128 */
 		tmp_dgain = 1;
 	}
 	*new_dgain = tmp_dgain;
@@ -414,29 +432,29 @@ static int ar0230_set_dgain_ratio(struct vin_device *vdev, struct vindev_dgain_r
 	pinfo = (struct ar0230_priv *)vdev->priv;
 
 	/* r */
-	if(p_dgain_ratio->r_ratio == 0)
+	if (p_dgain_ratio->r_ratio == 0)
 		vin_warn("Warning:R dgain ratio is set to 0!\n");
 	ar0230_convert_dgain_ratio(pinfo->dgain_base, p_dgain_ratio->r_ratio, &new_dgain);
-	ar0230_write_reg(vdev, 0x305A, new_dgain);
+	ar0230_write_reg(vdev, AR0230_R_GAIN, new_dgain);
 	pinfo->dgain_r_ratio = p_dgain_ratio->r_ratio;
 
 	/* gr */
-	if(p_dgain_ratio->gr_ratio == 0)
+	if (p_dgain_ratio->gr_ratio == 0)
 		vin_warn("Warning:Gr dgain ratio is set to 0!\n");
 	ar0230_convert_dgain_ratio(pinfo->dgain_base, p_dgain_ratio->gr_ratio, &new_dgain);
-	ar0230_write_reg(vdev, 0x3056, new_dgain);
+	ar0230_write_reg(vdev, AR0230_GR_GAIN, new_dgain);
 
 	/* gb */
-	if(p_dgain_ratio->gb_ratio == 0)
+	if (p_dgain_ratio->gb_ratio == 0)
 		vin_warn("Warning:Gb dgain ratio is set to 0!\n");
 	ar0230_convert_dgain_ratio(pinfo->dgain_base, p_dgain_ratio->gb_ratio, &new_dgain);
-	ar0230_write_reg(vdev, 0x305C, new_dgain);
+	ar0230_write_reg(vdev, AR0230_GB_GAIN, new_dgain);
 
 	/* b */
-	if(p_dgain_ratio->b_ratio == 0)
+	if (p_dgain_ratio->b_ratio == 0)
 		vin_warn("Warning:B dgain ratio is set to 0!\n");
 	ar0230_convert_dgain_ratio(pinfo->dgain_base, p_dgain_ratio->b_ratio, &new_dgain);
-	ar0230_write_reg(vdev, 0x3058, new_dgain);
+	ar0230_write_reg(vdev, AR0230_B_GAIN, new_dgain);
 	pinfo->dgain_b_ratio = p_dgain_ratio->b_ratio;
 
 	return errCode;
@@ -445,25 +463,25 @@ static int ar0230_set_dgain_ratio(struct vin_device *vdev, struct vindev_dgain_r
 static int ar0230_get_dgain_ratio(struct vin_device *vdev, struct vindev_dgain_ratio *p_dgain_ratio)
 {
 	int errCode = 0;
-	u32 current_dgain=0, dgain_ratio;
+	u32 current_dgain = 0, dgain_ratio;
 
 	/* r */
-	ar0230_read_reg(vdev, 0x305A, &current_dgain);
+	ar0230_read_reg(vdev, AR0230_R_GAIN, &current_dgain);
 	dgain_ratio = current_dgain * (1024 / 128);
 	p_dgain_ratio->r_ratio = dgain_ratio;
 
 	/* gr */
-	ar0230_read_reg(vdev, 0x3056, &current_dgain);
+	ar0230_read_reg(vdev, AR0230_GR_GAIN, &current_dgain);
 	dgain_ratio = current_dgain * (1024 / 128);
 	p_dgain_ratio->gr_ratio = dgain_ratio;
 
 	/* gb */
-	ar0230_read_reg(vdev, 0x305C, &current_dgain);
+	ar0230_read_reg(vdev, AR0230_GB_GAIN, &current_dgain);
 	dgain_ratio = current_dgain * (1024 / 128);
 	p_dgain_ratio->gb_ratio = dgain_ratio;
 
 	/* b */
-	ar0230_read_reg(vdev, 0x3058, &current_dgain);
+	ar0230_read_reg(vdev, AR0230_B_GAIN, &current_dgain);
 	dgain_ratio = current_dgain * (1024 / 128);
 	p_dgain_ratio->b_ratio = dgain_ratio;
 
@@ -473,13 +491,6 @@ static int ar0230_get_dgain_ratio(struct vin_device *vdev, struct vindev_dgain_r
 static int ar0230_set_agc_index(struct vin_device *vdev, int agc_idx)
 {
 	int agc_max_index;
-
-#if 0
-	u8 md_q1[4] = {41,57,76,85};
-	u16 q1_idx;
-	u32 data_val;
-#endif
-
 	u16 new_dgain, again;
 	struct ar0230_priv *pinfo;
 
@@ -500,7 +511,7 @@ static int ar0230_set_agc_index(struct vin_device *vdev, int agc_idx)
 		ar0230_write_reg(vdev, 0x3206, 0x0B08);/* ADACD_NOISE_FLOOR1 */
 		ar0230_write_reg(vdev, 0x3208, 0x1E13);/* ADACD_NOISE_FLOOR2 */
 		ar0230_write_reg(vdev, 0x3202, 0x0080);/* ADACD_NOISE_MODEL1 */
-		if  (vdev->cur_format->hdr_mode != AMBA_VIDEO_LINEAR_MODE) {
+		if (vdev->cur_format->hdr_mode != AMBA_VIDEO_LINEAR_MODE) {
 			ar0230_write_reg(vdev, 0x3096, 0x0480);/* ROW_NOISE_ADJUST_TOP */
 			ar0230_write_reg(vdev, 0x3098, 0x0480);/* ROW_NOISE_ADJUST_BTM */
 		}
@@ -535,27 +546,19 @@ static int ar0230_set_agc_index(struct vin_device *vdev, int agc_idx)
 		ar0230_write_reg(vdev, AR0230_DCG_CTL,
 			AR0230_HDR_GAIN_TABLE[agc_idx][AR0230_GAIN_COL_DCG]);
 
-#if 0
-		q1_idx = (again&0x30)>>4;
-		ar0230_read_reg(vdev, 0x3198, &data_val);
-		data_val &= 0xff00;
-		data_val |= md_q1[q1_idx%4];
-		ar0230_write_reg(vdev, 0x3198, data_val);
-#endif
-
 		pinfo->dgain_base = AR0230_GAIN_TABLE[agc_idx][AR0230_GAIN_COL_DGAIN];
 
 		/* r dgain */
 		ar0230_convert_dgain_ratio(pinfo->dgain_base, pinfo->dgain_r_ratio, &new_dgain);
-		ar0230_write_reg(vdev, 0x305A, new_dgain);
+		ar0230_write_reg(vdev, AR0230_R_GAIN, new_dgain);
 
 		/* gr/gb dgain, ratio is fixed to 1 */
-		ar0230_write_reg(vdev, 0x3056, pinfo->dgain_base);
-		ar0230_write_reg(vdev, 0x305C, pinfo->dgain_base);
+		ar0230_write_reg(vdev, AR0230_GR_GAIN, pinfo->dgain_base);
+		ar0230_write_reg(vdev, AR0230_GB_GAIN, pinfo->dgain_base);
 
 		/* b dgain */
 		ar0230_convert_dgain_ratio(pinfo->dgain_base, pinfo->dgain_b_ratio, &new_dgain);
-		ar0230_write_reg(vdev, 0x3058, new_dgain);
+		ar0230_write_reg(vdev, AR0230_B_GAIN, new_dgain);
 	}
 
 	return 0;
@@ -604,7 +607,7 @@ static int ar0230_wdr_shutter2row(struct vin_device *vdev,
 }
 
 static int ar0230_set_mirror_mode(struct vin_device *vdev,
-		struct vindev_mirror *mirror_mode)
+	struct vindev_mirror *mirror_mode)
 {
 	u32 tmp_reg, readmode, bayer_pattern;
 
@@ -648,19 +651,61 @@ static int ar0230_set_mirror_mode(struct vin_device *vdev,
 	return 0;
 }
 
+static int ar0230_get_aaa_info(struct vin_device *vdev,
+	struct vindev_aaa_info *aaa_info)
+{
+	struct ar0230_priv *pinfo = (struct ar0230_priv *)vdev->priv;
+
+	aaa_info->sht0_max = pinfo->frame_length_lines - 4;
+	aaa_info->sht1_max = pinfo->frame_length_lines - vdev->cur_format->height - 2;
+	aaa_info->sht2_max = 0;
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int ar0230_suspend(struct vin_device *vdev)
+{
+	u32 i, tmp;
+
+	for (i = 0; i < ARRAY_SIZE(pm_regs); i++) {
+		ar0230_read_reg(vdev, pm_regs[i].addr, &tmp);
+		pm_regs[i].data = (u16)tmp;
+	}
+
+	return 0;
+}
+
+static int ar0230_resume(struct vin_device *vdev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(pm_regs); i++) {
+		ar0230_write_reg(vdev, pm_regs[i].addr, pm_regs[i].data);
+	}
+
+	return 0;
+}
+#endif
+
 static struct vin_ops ar0230_ops = {
 	.init_device		= ar0230_init_device,
 	.set_pll			= ar0230_set_pll,
 	.set_format		= ar0230_set_format,
 	.set_shutter_row	= ar0230_set_shutter_row,
-	.shutter2row 		= ar0230_shutter2row,
+	.shutter2row		= ar0230_shutter2row,
 	.set_frame_rate	= ar0230_set_fps,
-	.set_agc_index	= ar0230_set_agc_index,
+	.set_agc_index		= ar0230_set_agc_index,
 	.set_mirror_mode	= ar0230_set_mirror_mode,
 	.set_dgain_ratio	= ar0230_set_dgain_ratio,
 	.get_dgain_ratio	= ar0230_get_dgain_ratio,
+	.get_aaa_info		= ar0230_get_aaa_info,
 	.read_reg			= ar0230_read_reg,
 	.write_reg		= ar0230_write_reg,
+#ifdef CONFIG_PM
+	.suspend		= ar0230_suspend,
+	.resume			= ar0230_resume,
+#endif
 
 	/* for wdr sensor */
 	.set_wdr_again_idx_gp = ar0230_set_wdr_again_idx_group,
@@ -672,7 +717,6 @@ static struct vin_ops ar0230_ops = {
 	.wdr_shutter2row = ar0230_wdr_shutter2row,
 };
 
-/*	< include init.c here for aptina sensor, which is produce by perl >  */
 /* ========================================================================== */
 static int ar0230_probe(struct i2c_client *client,
 	const struct i2c_device_id *id)
diff --git a/drivers/vin/sensors/micron_ar0230/ar0230.h b/drivers/vin/sensors/micron_ar0230/ar0230.h
index a812ac5..d698bcc 100644
--- a/drivers/vin/sensors/micron_ar0230/ar0230.h
+++ b/drivers/vin/sensors/micron_ar0230/ar0230.h
@@ -4,18 +4,38 @@
  * History:
  *    2014/11/18 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #ifndef __AR0230_PRI_H__
 #define __AR0230_PRI_H__
 
+#define USE_4X_RATIO	0
+
 #define AR0230_RESET_REGISTER				0x301A
 #define AR0230_LINE_LENGTH_PCK			0x300C
 #define AR0230_FRAME_LENGTH_LINES			0x300A
@@ -28,6 +48,11 @@
 #define AR0230_PRE_PLL_CLK_DIV				0x302E
 #define AR0230_PLL_MULTIPLIER				0x3030
 
+#define AR0230_GR_GAIN					0x3056
+#define AR0230_B_GAIN						0x3058
+#define AR0230_R_GAIN						0x305A
+#define AR0230_GB_GAIN					0x305C
+
 #define AR0230_DGAIN						0x305E
 #define AR0230_AGAIN						0x3060
 #define AR0230_DCG_CTL						0x3100
diff --git a/drivers/vin/sensors/micron_ar0230/ar0230_table.c b/drivers/vin/sensors/micron_ar0230/ar0230_table.c
index 72c1508..d71678d 100644
--- a/drivers/vin/sensors/micron_ar0230/ar0230_table.c
+++ b/drivers/vin/sensors/micron_ar0230/ar0230_table.c
@@ -4,14 +4,33 @@
  * History:
  *    2014/11/18 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_reg_16_16 ar0230_pll_regs[][6] = {
 	{
 		{0x302A, 0x0006}, /* VT_PIX_CLK_DIV  */
@@ -94,7 +113,11 @@ static struct vin_video_format ar0230_formats[] = {
 		.def_start_x	= 0,
 		.def_start_y	= 0,
 		.def_width	= 1920,
-		.def_height	= 1153 * 2,/* (1080+max T2+2) * 2 */
+#if USE_4X_RATIO
+		.def_height	= (1080+188+2)*2,/* (1080+max_T2+2)*2 */
+#else
+		.def_height	= (1080+74+2)*2,/* (1080+max_T2+2)*2 */
+#endif
 		.act_start_x	= 0,
 		.act_start_y	= 0,
 		.act_width	= 1920,
@@ -369,7 +392,6 @@ static struct vin_reg_16_16 ar0230_linear_share_regs[] = {
 
 static struct vin_reg_16_16 ar0230_hdr_share_regs[] = {
 	/* HDR 1080p30fps */
-	{0x301A, 0x0059}, /* RESET_REGISTER */
 	{0x3088, 0x8000}, /* SEQ_CTRL_PORT */
 	{0x3086, 0x4558}, /* SEQ_DATA_PORT */
 	{0x3086, 0x729B}, /* SEQ_DATA_PORT */
@@ -744,31 +766,6 @@ static struct vin_reg_16_16 ar0230_hdr_share_regs[] = {
 };
 
 static struct vin_reg_16_16 ar0230_2x_hdr_share_regs[] = {
-	{0x2436, 0x000E},
-	{0x320C, 0x0180},
-	{0x320E, 0x0300},
-	{0x3210, 0x0500},
-	{0x3204, 0x0B6D},
-	{0x30FE, 0x0080},
-	{0x3ED8, 0x7B99},
-	{0x3EDC, 0x9BA8},
-	{0x3EDA, 0x9B9B},
-	{0x3092, 0x006F},
-	{0x3EEC, 0x1C04},
-	{0x30BA, 0x779C},
-	{0x3EF6, 0xA70F},
-	{0x3044, 0x0410},
-	{0x3ED0, 0xFF44},
-	{0x3ED4, 0x031F},
-	{0x30FE, 0x0080},
-	{0x3EE2, 0x8866},
-	{0x3EE4, 0x6623},
-	{0x3EE6, 0x2263},
-	{0x30E0, 0x4283},
-	{0x30F0, 0x1283},
-	{0x30B0, 0x0000}, /* DIGITAL_TEST, 0x0000 */
-	{0x31AC, 0x100C}, /* DATA_FORMAT_BITS */
-	{0x301A, 0x0059},
 	{0x3088, 0x8000},
 	{0x3086, 0x4558},
 	{0x3086, 0x729B},
@@ -1055,14 +1052,65 @@ static struct vin_reg_16_16 ar0230_2x_hdr_share_regs[] = {
 	{0x3086, 0x444B},
 	{0x3086, 0x2C2C},
 	{0x3086, 0x2C2C},
+
+	{0x3ED6, 0x34B3},
+	{0x2436, 0x000E},
+	{0x320C, 0x0180},
+	{0x320E, 0x0300},
+	{0x3210, 0x0500},
+	{0x3204, 0x0B6D},
+	{0x30FE, 0x0080},
+	{0x3ED8, 0x7B99},
+	{0x3EDC, 0x9BA8},
+	{0x3EDA, 0x9B9B},
+	{0x3092, 0x006F},
+	{0x3EEC, 0x1C04},
+	{0x30BA, 0x779C},
+	{0x3EF6, 0xA70F},
+	{0x3044, 0x0410},
+	{0x3ED0, 0xFF44},
+	{0x3ED4, 0x031F},
+	{0x30FE, 0x0080},
+	{0x3EE2, 0x8866},
+	{0x3EE4, 0x6623},
+	{0x3EE6, 0x2263},
+	{0x30E0, 0x4283},
+	{0x30F0, 0x1283},
+	{0x3176, 0xFF80},
+	{0x3178, 0xFF80},
+	{0x317A, 0xFF80},
+	{0x317C, 0xFF80},
+	{0x3FD8, 0x0045},
+	{0x301A, 0x0058},
+	{0x30B0, 0x0118}, /* DIGITAL_TEST */
+	{0x31AC, 0x100C}, /* DATA_FORMAT_BITS */
+
+	{0x3002, 0x0000}, /* y_addr_start */
+	{0x3004, 0x0000}, /* x_addr_start */
+	{0x3006, 0x0437}, /* y_addr_end, 1079 */
+	{0x3008, 0x0787}, /* x_addr_end, 1927 */
+	{0x300A, 1271  }, /* 0x0489(1161) FRAME_LENGTH_LINES */
+	{0x300C, 1948  }, /* 0x07F0(2032) LINE_LENGTH_PCK */
+	{0x3012, 655   }, /* 0x0416(1046)coarse_integration_time */
+	{0x30A2, 0x0001}, /* x_odd_inc */
+	{0x30A6, 0x0001}, /* y_odd_inc */
+	{0x30AE, 0x0001}, /* x_odd_inc_cb */
+	{0x30A8, 0x0001}, /* y_odd_inc_cb */
+
+	{0x3040, 0x0000}, /* read mode */
+#if USE_4X_RATIO
+	{0x3082, 0x0000}, /* HDR 4x; 0: 4x; 4: 8x; 8: 16x; C: 32x */
+#else
 	{0x3082, 0x0008}, /* HDR 16x; 0: 4x; 4: 8x; 8: 16x; C: 32x */
+#endif
+	{0x31E0, 0x0200},
 	{0x2420, 0x0000},
 	{0x2440, 0x0004},
 	{0x2442, 0x0080},
-	{0x301E, 0x0000},
+	{0x301E, 0x00A8}, /* DATA_PEDESTAL */
 	{0x2450, 0x0000},
 	{0x320A, 0x0080},
-	{0x31D0, 0x0000},
+	{0x31D0, 0x0000}, /* COMPANDING */
 	{0x2400, 0x0002},
 	{0x2410, 0x0005},
 	{0x2412, 0x002D},
@@ -1075,49 +1123,46 @@ static struct vin_reg_16_16 ar0230_2x_hdr_share_regs[] = {
 	{0x3206, 0x0B08},
 	{0x3208, 0x1E13},
 	{0x3202, 0x0080},
-	{0x3200, 0x02  },
+	{0x3200, 0x0002},
 	{0x3190, 0x0000},
 	{0x318A, 0x0E74},
 	{0x318C, 0xC000},
+	{0x318E, 0x0200}, /* HDR_MC_CTRL3 */
 	{0x3192, 0x0400},
 	{0x3198, 0x183C},
 	{0x3060, 0x000B},
-	{0x3096, 0x0480},
-	{0x3098, 0x0480},
-	{0x3206, 0x0B08},
-	{0x3208, 0x1E13},
-	{0x3202, 0x0080},
-	{0x3200, 0x02  },
+	{0x3096, 0x0480}, /* ROW_NOISE_ADJUST_TOP */
+	{0x3098, 0x0480}, /* ROW_NOISE_ADJUST_BTM */
+	{0x3206, 0x0B08}, /* ADACD_NOISE_FLOOR1 */
+	{0x3208, 0x1E13}, /* ADACD_NOISE_FLOOR2 */
+	{0x3202, 0x0080}, /* ADACD_NOISE_MODEL1 */
+	{0x3200, 0x0002}, /* ADACD_CONTROL */
 	{0x3100, 0x0000}, /* DCG off */
+	{0x30BA, 0x779C}, /* DIGITAL_CTRL */
+
+	{0x318E, 0x0200}, /* HDR_MC_CTRL3 */
+	{0x3064, 0x1982}, /* SMIA_TEST */
 	{0x31AE, 0x0304}, /* HiSpi 4 lane */
 	{0x31C6, 0x8002}, /* HiSpi Steraming-S, 0x0402:HiSpi protocol Packetized-SP; MSB output */
-	{0x306E, 0x9010}, /* datapath_select */
-	{0x301A, 0x0058},
-	{0x318C, 0x0000},
-	{0x3200, 0x0000}, /* ADACD_CONTROL */
-	{0x31D0, 0x0000}, /* COMPANDING */
-	{0x2400, 0x0003},
-	{0x301E, 0x00A8},
-	{0x2450, 0x0000},
-	{0x320A, 0x0080},
-
-	{0x3004, 0x0000}, /* x_addr_start */
-	{0x3008, 0x0787}, /* x_addr_end, 1927 */
-	{0x3002, 0x0000}, /* y_addr_start */
-	{0x3006, 0x0437}, /* y_addr_end, 1079 */
-	{0x30A2, 0x0001}, /* x_odd_inc */
-	{0x30A6, 0x0001}, /* y_odd_inc */
-	{0x3040, 0x0000}, /* read mode */
-	{0x300A, 1222  }, /* 1125 FRAME_LENGTH_LINES Venkatesh 1180 */
-	{0x300C, 2024  }, /* 2200 2032 LINE_LENGTH_PCK Venkatesh */
-	{0x3012, 655   }, /* coarse_integration_time */
-	{0x305E, 0x0085}, /* min sesnor digital gain 1.04x */
-	{0x301A, 0x0058}, /* RESET_REGISTER */
+	{0x306E, 0x9010}, /* 0x9210, datapath_select, SLVS mode of HiSPi */
 	{0x3064, 0x1802}, /* SMIA_TEST */
 	{0x318E, 0x1200}, /* HDR_MC_CTRL3 */
 	{0x301A, 0x005C}, /* RESET_REGISTER */
 };
 
+#ifdef CONFIG_PM
+static struct vin_reg_16_16 pm_regs[] = {
+	{AR0230_COARSE_INTEGRATION_TIME, 0x0000},
+	{AR0230_AGAIN, 0x0000},
+	{AR0230_DGAIN, 0x0000},
+	{AR0230_DCG_CTL, 0x0000},
+	{AR0230_GR_GAIN, 0x0000},
+	{AR0230_GB_GAIN, 0x0000},
+	{AR0230_R_GAIN, 0x0000},
+	{AR0230_B_GAIN, 0x0000},
+};
+#endif
+
 /** AR0230 global gain table row size */
 #define AR0230_GAIN_ROWS		475
 #define AR0230_GAIN_COLS 		3
diff --git a/drivers/vin/sensors/micron_ar0230/make.inc b/drivers/vin/sensors/micron_ar0230/make.inc
index b200962..1f84ef2 100644
--- a/drivers/vin/sensors/micron_ar0230/make.inc
+++ b/drivers/vin/sensors/micron_ar0230/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/11/18 - [Long Zhao] Create
 ##
-## Copyright (C) 2004-2014, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_AR0230), y)
diff --git a/drivers/vin/sensors/micron_ar0230_parallel/Kbuild b/drivers/vin/sensors/micron_ar0230_parallel/Kbuild
index 6367b5d..18472cc 100644
--- a/drivers/vin/sensors/micron_ar0230_parallel/Kbuild
+++ b/drivers/vin/sensors/micron_ar0230_parallel/Kbuild
@@ -4,15 +4,30 @@
 ## History:
 ##     2014/11/18 - [Long Zhao] Create
 ##
-## Copyright (C) 2004-2014, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
-## This file is produced by perl.
-##/
 
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/micron_ar0230_parallel/ar0230.c b/drivers/vin/sensors/micron_ar0230_parallel/ar0230.c
index d4badf9..e87bf44 100644
--- a/drivers/vin/sensors/micron_ar0230_parallel/ar0230.c
+++ b/drivers/vin/sensors/micron_ar0230_parallel/ar0230.c
@@ -4,15 +4,33 @@
  * History:
  *    2014/11/18 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
@@ -22,11 +40,16 @@
 #include <iav_utils.h>
 #include <vin_api.h>
 #include "ar0230.h"
+#include "ar0230_table.c"
 
 static int bus_addr = (0 << 16) | (0x20 >> 1);
 module_param(bus_addr, int, 0644);
 MODULE_PARM_DESC(bus_addr, " bus and addr: bit16~bit31: bus, bit0~bit15: addr");
 
+static int bayer_pattern = VINDEV_BAYER_PATTERN_AUTO;
+module_param(bayer_pattern, int, 0644);
+MODULE_PARM_DESC(bayer_pattern, "set bayer pattern: 0:RG, 1:BG, 2:GR, 3:GB, 255:default");
+
 struct ar0230_priv {
 	void *control_data;
 	u32	dgain_r_ratio;
@@ -36,9 +59,7 @@ struct ar0230_priv {
 	u32 line_length;
 };
 
-#include "ar0230_table.c"
-
-static int ar0230_write_reg( struct vin_device *vdev, u32 subaddr, u32 data)
+static int ar0230_write_reg(struct vin_device *vdev, u32 subaddr, u32 data)
 {
 	int rval;
 	struct ar0230_priv *ar0230;
@@ -56,7 +77,10 @@ static int ar0230_write_reg( struct vin_device *vdev, u32 subaddr, u32 data)
 
 	msgs[0].len = 4;
 	msgs[0].addr = client->addr;
-	msgs[0].flags = client->flags;
+	if (unlikely(subaddr == AR0230_RESET_REGISTER))
+		msgs[0].flags = client->flags | I2C_M_IGNORE_NAK;
+	else
+		msgs[0].flags = client->flags;
 	msgs[0].buf = pbuf;
 
 	rval = i2c_transfer(client->adapter, msgs, 1);
@@ -68,14 +92,14 @@ static int ar0230_write_reg( struct vin_device *vdev, u32 subaddr, u32 data)
 	return 0;
 }
 
-static int ar0230_read_reg( struct vin_device *vdev, u32 subaddr, u32 *data)
+static int ar0230_read_reg(struct vin_device *vdev, u32 subaddr, u32 *data)
 {
 	int rval = 0;
 	struct ar0230_priv *ar0230;
 	struct i2c_client *client;
 	struct i2c_msg msgs[2];
 	u8 pbuf0[2];
-	u8 pbuf[6];
+	u8 pbuf[2];
 
 	ar0230 = (struct ar0230_priv *)vdev->priv;
 	client = ar0230->control_data;
@@ -94,7 +118,7 @@ static int ar0230_read_reg( struct vin_device *vdev, u32 subaddr, u32 *data)
 	msgs[1].len = 2;
 
 	rval = i2c_transfer(client->adapter, msgs, 2);
-	if (rval < 0){
+	if (rval < 0) {
 		vin_error("failed(%d): [0x%x]\n", rval, subaddr);
 		return rval;
 	}
@@ -108,7 +132,7 @@ static int ar0230_set_vin_mode(struct vin_device *vdev, struct vin_video_format
 {
 	struct vin_device_config ar0230_config;
 
-	memset(&ar0230_config, 0, sizeof (ar0230_config));
+	memset(&ar0230_config, 0, sizeof(ar0230_config));
 
 	ar0230_config.interface_type = SENSOR_PARALLEL_LVCMOS;
 	ar0230_config.sync_mode = SENSOR_SYNC_MODE_MASTER;
@@ -140,9 +164,8 @@ static int ar0230_set_vin_mode(struct vin_device *vdev, struct vin_video_format
 static void ar0230_sw_reset(struct vin_device *vdev)
 {
 	ar0230_write_reg(vdev, AR0230_RESET_REGISTER, 0x0001);/* Register RESET_REGISTER */
-	msleep(10);
+	msleep(1);
 	ar0230_write_reg(vdev, AR0230_RESET_REGISTER, 0x10D8);/* Register RESET_REGISTER */
-	msleep(10);
 }
 
 static int ar0230_init_device(struct vin_device *vdev)
@@ -177,7 +200,7 @@ static int ar0230_update_hv_info(struct vin_device *vdev)
 	struct ar0230_priv *pinfo = (struct ar0230_priv *)vdev->priv;
 
 	ar0230_read_reg(vdev, AR0230_LINE_LENGTH_PCK, &pinfo->line_length);
-	if(unlikely(!pinfo->line_length)) {
+	if (unlikely(!pinfo->line_length)) {
 		vin_error("line length is 0!\n");
 		return -EIO;
 	}
@@ -215,7 +238,7 @@ static int ar0230_set_format(struct vin_device *vdev, struct vin_video_format *f
 		vdev->agc_db_max = 0x2C700000;	/* 44.4375dB */
 		vdev->agc_db_min = 0x00000000;	/* 0dB */
 		vdev->agc_db_step = 0x00180000;	/* 0.09375dB */
-	} else if (format->hdr_mode == AMBA_VIDEO_INT_HDR_MODE){
+	} else if (format->hdr_mode == AMBA_VIDEO_INT_HDR_MODE) {
 		regs = ar0230_hdr_share_regs;
 		regs_num = ARRAY_SIZE(ar0230_hdr_share_regs);
 		/* mapping from 0db */
@@ -264,15 +287,15 @@ static int ar0230_set_shutter_row(struct vin_device *vdev, u32 row)
 	if (vdev->cur_format->hdr_mode == AMBA_VIDEO_INT_HDR_MODE) {
 		ar0230_read_reg(vdev, 0x3082, &t1t2_ratio);
 		t1t2_ratio = 1<<(((t1t2_ratio&0xC)>>2) + 2);
-		max_shutter_width = MIN( 70 * t1t2_ratio, pinfo->frame_length_lines -71);
+		max_shutter_width = MIN(70 * t1t2_ratio, pinfo->frame_length_lines - 71);
 
 		min_line = t1t2_ratio/2;
 		max_line = max_shutter_width;
 		num_line = clamp(num_line, min_line, max_line);
-	} else if (vdev->cur_format->hdr_mode == AMBA_VIDEO_LINEAR_MODE){
-		/* FIXME: shutter width: 1 ~ Frame format(V) */
+	} else if (vdev->cur_format->hdr_mode == AMBA_VIDEO_LINEAR_MODE) {
+		/* FIXME: shutter width: 1 ~ (Frame format(V) - 4) */
 		min_line = 1;
-		max_line = pinfo->frame_length_lines;
+		max_line = pinfo->frame_length_lines - 4;
 		num_line = clamp(num_line, min_line, max_line);
 	}
 
@@ -288,14 +311,14 @@ static int ar0230_set_shutter_row(struct vin_device *vdev, u32 row)
 	return errCode;
 }
 
-static int ar0230_shutter2row(struct vin_device *vdev, u32* shutter_time)
+static int ar0230_shutter2row(struct vin_device *vdev, u32 *shutter_time)
 {
 	u64 exposure_lines;
 	int rval = 0;
 	struct ar0230_priv *pinfo = (struct ar0230_priv *)vdev->priv;
 
 	/* for fast boot, it may call set shutter time directly, so we must read line length/frame line */
-	if(unlikely(!pinfo->line_length)) {
+	if (unlikely(!pinfo->line_length)) {
 		rval = ar0230_update_hv_info(vdev);
 		if (rval < 0)
 			return rval;
@@ -339,10 +362,10 @@ static int ar0230_convert_dgain_ratio(u16 old_dgain, u32 ratio, u16 *new_dgain)
 
 	tmp_dgain = (old_dgain * ratio)/1024;
 
-	if(tmp_dgain > 0x7FF){//dgain should be less than 15.992
+	if (tmp_dgain > 0x7FF) {/* dgain should be less than 15.992 */
 		tmp_dgain = 0x7FF;
 		vin_info("Waring: dgain value is too high!\n");
-	} else if ((ratio != 0)&&(tmp_dgain == 0)){//0<ratio<1/128, set to 1/128
+	} else if ((ratio != 0) && (tmp_dgain == 0)) {/* 0<ratio<1/128, set to 1/128 */
 		tmp_dgain = 1;
 	}
 	*new_dgain = tmp_dgain;
@@ -361,26 +384,26 @@ static int ar0230_set_dgain_ratio(struct vin_device *vdev, struct vindev_dgain_r
 	pinfo = (struct ar0230_priv *)vdev->priv;
 
 	/* r */
-	if(p_dgain_ratio->r_ratio == 0)
+	if (p_dgain_ratio->r_ratio == 0)
 		vin_warn("Warning:R dgain ratio is set to 0!\n");
 	ar0230_convert_dgain_ratio(pinfo->dgain_base, p_dgain_ratio->r_ratio, &new_dgain);
 	ar0230_write_reg(vdev, 0x305A, new_dgain);
 	pinfo->dgain_r_ratio = p_dgain_ratio->r_ratio;
 
 	/* gr */
-	if(p_dgain_ratio->gr_ratio == 0)
+	if (p_dgain_ratio->gr_ratio == 0)
 		vin_warn("Warning:Gr dgain ratio is set to 0!\n");
 	ar0230_convert_dgain_ratio(pinfo->dgain_base, p_dgain_ratio->gr_ratio, &new_dgain);
 	ar0230_write_reg(vdev, 0x3056, new_dgain);
 
 	/* gb */
-	if(p_dgain_ratio->gb_ratio == 0)
+	if (p_dgain_ratio->gb_ratio == 0)
 		vin_warn("Warning:Gb dgain ratio is set to 0!\n");
 	ar0230_convert_dgain_ratio(pinfo->dgain_base, p_dgain_ratio->gb_ratio, &new_dgain);
 	ar0230_write_reg(vdev, 0x305C, new_dgain);
 
 	/* b */
-	if(p_dgain_ratio->b_ratio == 0)
+	if (p_dgain_ratio->b_ratio == 0)
 		vin_warn("Warning:B dgain ratio is set to 0!\n");
 	ar0230_convert_dgain_ratio(pinfo->dgain_base, p_dgain_ratio->b_ratio, &new_dgain);
 	ar0230_write_reg(vdev, 0x3058, new_dgain);
@@ -392,7 +415,7 @@ static int ar0230_set_dgain_ratio(struct vin_device *vdev, struct vindev_dgain_r
 static int ar0230_get_dgain_ratio(struct vin_device *vdev, struct vindev_dgain_ratio *p_dgain_ratio)
 {
 	int errCode = 0;
-	u32 current_dgain=0, dgain_ratio;
+	u32 current_dgain = 0, dgain_ratio;
 
 	/* r */
 	ar0230_read_reg(vdev, 0x305A, &current_dgain);
@@ -420,13 +443,6 @@ static int ar0230_get_dgain_ratio(struct vin_device *vdev, struct vindev_dgain_r
 static int ar0230_set_agc_index(struct vin_device *vdev, int agc_idx)
 {
 	int agc_max_index;
-
-#if 0
-	u8 md_q1[4] = {41,57,76,85};
-	u16 q1_idx;
-	u32 data_val;
-#endif
-
 	u16 new_dgain, again;
 	struct ar0230_priv *pinfo;
 
@@ -475,14 +491,6 @@ static int ar0230_set_agc_index(struct vin_device *vdev, int agc_idx)
 		ar0230_write_reg(vdev, AR0230_DCG_CTL,
 			AR0230_HDR_GAIN_TABLE[agc_idx][AR0230_GAIN_COL_DCG]);
 
-#if 0
-		q1_idx = (again&0x30)>>4;
-		ar0230_read_reg(vdev, 0x3198, &data_val);
-		data_val &= 0xff00;
-		data_val |= md_q1[q1_idx%4];
-		ar0230_write_reg(vdev, 0x3198, data_val);
-#endif
-
 		pinfo->dgain_base = AR0230_GAIN_TABLE[agc_idx][AR0230_GAIN_COL_DGAIN];
 
 		/* r dgain */
@@ -502,7 +510,7 @@ static int ar0230_set_agc_index(struct vin_device *vdev, int agc_idx)
 }
 
 static int ar0230_set_mirror_mode(struct vin_device *vdev,
-		struct vindev_mirror *mirror_mode)
+	struct vindev_mirror *mirror_mode)
 {
 	u32 tmp_reg, readmode, bayer_pattern;
 
@@ -550,10 +558,10 @@ static struct vin_ops ar0230_ops = {
 	.init_device		= ar0230_init_device,
 	.set_pll			= ar0230_set_pll,
 	.set_format		= ar0230_set_format,
-	.set_shutter_row 	= ar0230_set_shutter_row,
-	.shutter2row 		= ar0230_shutter2row,
+	.set_shutter_row	= ar0230_set_shutter_row,
+	.shutter2row		= ar0230_shutter2row,
 	.set_frame_rate	= ar0230_set_fps,
-	.set_agc_index	= ar0230_set_agc_index,
+	.set_agc_index		= ar0230_set_agc_index,
 	.set_mirror_mode	= ar0230_set_mirror_mode,
 	.set_dgain_ratio	= ar0230_set_dgain_ratio,
 	.get_dgain_ratio	= ar0230_get_dgain_ratio,
@@ -561,18 +569,17 @@ static struct vin_ops ar0230_ops = {
 	.write_reg		= ar0230_write_reg,
 };
 
-/*	< include init.c here for aptina sensor, which is produce by perl >  */
 /* ========================================================================== */
 static int ar0230_probe(struct i2c_client *client,
 	const struct i2c_device_id *id)
 {
-	int rval = 0;
+	int i, rval = 0;
 	struct vin_device *vdev;
 	struct ar0230_priv *ar0230;
 	u32 version;
 
 	vdev = ambarella_vin_create_device(client->name,
-			SENSOR_AR0230, sizeof(struct ar0230_priv));
+		SENSOR_AR0230, sizeof(struct ar0230_priv));
 	if (!vdev)
 		return -ENOMEM;
 
@@ -593,9 +600,19 @@ static int ar0230_probe(struct i2c_client *client,
 	ar0230 = (struct ar0230_priv *)vdev->priv;
 	ar0230->control_data = client;
 
+	if (bayer_pattern != VINDEV_BAYER_PATTERN_AUTO) {
+		if (bayer_pattern > VINDEV_BAYER_PATTERN_GB) {
+			vin_error("invalid bayer pattern:%d\n", bayer_pattern);
+			return -EINVAL;
+		} else {
+			for (i = 0; i < ARRAY_SIZE(ar0230_formats); i++)
+				ar0230_formats[i].default_bayer_pattern = bayer_pattern;
+		}
+	}
+
 	rval = ambarella_vin_register_device(vdev, &ar0230_ops,
-			ar0230_formats, ARRAY_SIZE(ar0230_formats),
-			ar0230_plls, ARRAY_SIZE(ar0230_plls));
+		ar0230_formats, ARRAY_SIZE(ar0230_formats),
+		ar0230_plls, ARRAY_SIZE(ar0230_plls));
 	if (rval < 0)
 		goto ar0230_probe_err;
 
diff --git a/drivers/vin/sensors/micron_ar0230_parallel/ar0230.h b/drivers/vin/sensors/micron_ar0230_parallel/ar0230.h
index a812ac5..7779262 100644
--- a/drivers/vin/sensors/micron_ar0230_parallel/ar0230.h
+++ b/drivers/vin/sensors/micron_ar0230_parallel/ar0230.h
@@ -4,15 +4,33 @@
  * History:
  *    2014/11/18 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #ifndef __AR0230_PRI_H__
 #define __AR0230_PRI_H__
 
diff --git a/drivers/vin/sensors/micron_ar0230_parallel/ar0230_table.c b/drivers/vin/sensors/micron_ar0230_parallel/ar0230_table.c
index c9ff1b8..cd57085 100644
--- a/drivers/vin/sensors/micron_ar0230_parallel/ar0230_table.c
+++ b/drivers/vin/sensors/micron_ar0230_parallel/ar0230_table.c
@@ -4,14 +4,33 @@
  * History:
  *    2014/11/18 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_reg_16_16 ar0230_pll_regs[][6] = {
 	{
 		{0x302A, 0x0008}, /* VT_PIX_CLK_DIV  */
@@ -332,7 +351,6 @@ static struct vin_reg_16_16 ar0230_linear_share_regs[] = {
 
 static struct vin_reg_16_16 ar0230_hdr_share_regs[] = {
 	/* HDR 1080p30fps */
-	{0x301A, 0x10D9}, /* RESET_REGISTER */
 	{0x3088, 0x8000}, /* SEQ_CTRL_PORT */
 	{0x3086, 0x4558}, /* SEQ_DATA_PORT */
 	{0x3086, 0x729B}, /* SEQ_DATA_PORT */
diff --git a/drivers/vin/sensors/micron_ar0230_parallel/make.inc b/drivers/vin/sensors/micron_ar0230_parallel/make.inc
index fa57315..8f5cd53 100644
--- a/drivers/vin/sensors/micron_ar0230_parallel/make.inc
+++ b/drivers/vin/sensors/micron_ar0230_parallel/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/11/18 - [Long Zhao] Create
 ##
-## Copyright (C) 2004-2014, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_AR0230P), y)
diff --git a/drivers/vin/sensors/micron_ar0331/Kbuild b/drivers/vin/sensors/micron_ar0331/Kbuild
index bad1c96..360df50 100644
--- a/drivers/vin/sensors/micron_ar0331/Kbuild
+++ b/drivers/vin/sensors/micron_ar0331/Kbuild
@@ -4,15 +4,30 @@
 ## History:
 ##     2015/02/06 - [Hao Zeng] Create
 ##
-## Copyright (C) 2004-2015, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
-## This file is produced by perl.
-##/
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
 EXTRA_AFLAGS		+= $(AMBARELLA_DRV_AFLAGS)
diff --git a/drivers/vin/sensors/micron_ar0331/ar0331.c b/drivers/vin/sensors/micron_ar0331/ar0331.c
index 178fb90..567510b 100644
--- a/drivers/vin/sensors/micron_ar0331/ar0331.c
+++ b/drivers/vin/sensors/micron_ar0331/ar0331.c
@@ -4,15 +4,33 @@
  * History:
  *    2015/02/06 - [Hao Zeng] Create
  *
- * Copyright (C) 2004-2015, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
diff --git a/drivers/vin/sensors/micron_ar0331/ar0331.h b/drivers/vin/sensors/micron_ar0331/ar0331.h
index ac12381..66c00c6 100644
--- a/drivers/vin/sensors/micron_ar0331/ar0331.h
+++ b/drivers/vin/sensors/micron_ar0331/ar0331.h
@@ -4,15 +4,33 @@
  * History:
  *    2015/02/06 - [Hao Zeng] Create
  *
- * Copyright (C) 2004-2015, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #ifndef __AR0331_PRI_H__
 #define __AR0331_PRI_H__
 
diff --git a/drivers/vin/sensors/micron_ar0331/ar0331_table.c b/drivers/vin/sensors/micron_ar0331/ar0331_table.c
index 9351b0c..d348573 100644
--- a/drivers/vin/sensors/micron_ar0331/ar0331_table.c
+++ b/drivers/vin/sensors/micron_ar0331/ar0331_table.c
@@ -4,14 +4,33 @@
  * History:
  *    2015/02/06 - [Hao Zeng] Create
  *
- * Copyright (C) 2004-2015, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_reg_16_16 ar0331_pll_regs[][6] = {
 	{
 		{0x302A, 0x0006}, /* VT_PIX_CLK_DIV  */
diff --git a/drivers/vin/sensors/micron_ar0331/make.inc b/drivers/vin/sensors/micron_ar0331/make.inc
index 35fbd73..26263f2 100644
--- a/drivers/vin/sensors/micron_ar0331/make.inc
+++ b/drivers/vin/sensors/micron_ar0331/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##     2015/02/06 - [Hao Zeng] Create
 ##
-## Copyright (C) 2004-2015, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_AR0331), y)
diff --git a/drivers/vin/sensors/micron_mt9t002/Kbuild b/drivers/vin/sensors/micron_mt9t002/Kbuild
index bc805d7..b5a9bdf 100644
--- a/drivers/vin/sensors/micron_mt9t002/Kbuild
+++ b/drivers/vin/sensors/micron_mt9t002/Kbuild
@@ -4,15 +4,30 @@
 ## History:
 ##    2011/01/12 - [Haowei Lo] Create
 ##
-## Copyright (C) 2004-2011, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
-## This file is produced by perl.
-##/
 
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/micron_mt9t002/make.inc b/drivers/vin/sensors/micron_mt9t002/make.inc
index 1b8a26a..90dbe46 100644
--- a/drivers/vin/sensors/micron_mt9t002/make.inc
+++ b/drivers/vin/sensors/micron_mt9t002/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/04 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_MT9T002), y)
diff --git a/drivers/vin/sensors/micron_mt9t002/mt9t002.c b/drivers/vin/sensors/micron_mt9t002/mt9t002.c
index 42ff9d3..902de1c 100644
--- a/drivers/vin/sensors/micron_mt9t002/mt9t002.c
+++ b/drivers/vin/sensors/micron_mt9t002/mt9t002.c
@@ -4,15 +4,33 @@
  * History:
  *    2011/01/12 - [Haowei Lo] Create
  *
- * Copyright (C) 2004-2011, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
@@ -453,25 +471,11 @@ static int mt9t002_set_mirror_mode(struct vin_device *vdev,
 static int mt9t002_get_eis_info(struct vin_device *vdev,
 		struct vindev_eisinfo *eis_info)
 {
-	struct mt9t002_priv *pinfo = (struct mt9t002_priv *)vdev->priv;
-	struct vin_video_format *format = vdev->cur_format;
-
-	eis_info->cap_start_x = format->def_start_x;
-	eis_info->cap_start_y = format->def_start_y;
-	eis_info->cap_cap_w = format->def_width;
-	eis_info->cap_cap_h = format->def_height;
-	eis_info->source_width = format->width;
-	eis_info->source_height = format->height;
-	eis_info->current_fps = vdev->frame_rate;
-	eis_info->main_fps = format->default_fps;
-	eis_info->current_shutter_time = vdev->shutter_time;
 	eis_info->sensor_cell_width = 220;// 2.2 um
 	eis_info->sensor_cell_height = 220;// 2.2 um
 	eis_info->column_bin = 1;
 	eis_info->row_bin = 1;
-
-	eis_info->vb_lines = pinfo->frame_length_lines - format->height;
-	eis_info->row_time = (u32)DIV64_CLOSEST((u64)format->line_time * 1000, 512);
+	eis_info->vb_time = vdev->cur_format->vb_time;
 
 	return 0;
 }
diff --git a/drivers/vin/sensors/micron_mt9t002/mt9t002.h b/drivers/vin/sensors/micron_mt9t002/mt9t002.h
index 4801194..e1e93a9 100644
--- a/drivers/vin/sensors/micron_mt9t002/mt9t002.h
+++ b/drivers/vin/sensors/micron_mt9t002/mt9t002.h
@@ -4,15 +4,33 @@
  * History:
  *    2011/01/12 - [Haowei Lo] Create
  *
- * Copyright (C) 2004-2011, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #ifndef __MT9T002_PRI_H__
 #define __MT9T002_PRI_H__
 
diff --git a/drivers/vin/sensors/micron_mt9t002/mt9t002_table.c b/drivers/vin/sensors/micron_mt9t002/mt9t002_table.c
index e7faa39..430c409 100644
--- a/drivers/vin/sensors/micron_mt9t002/mt9t002_table.c
+++ b/drivers/vin/sensors/micron_mt9t002/mt9t002_table.c
@@ -4,14 +4,33 @@
  * History:
  *    2011/01/12 - [Haowei Lo] Create
  *
- * Copyright (C) 2004-2011, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_reg_16_16 mt9t002_pll_regs[][7] = {
 	{
 		{0x302A, 0x0006}, {0x302C, 0x0001}, {0x302E, 0x0004},
diff --git a/drivers/vin/sensors/micron_mt9t002_mipi/Kbuild b/drivers/vin/sensors/micron_mt9t002_mipi/Kbuild
index 8a70657..9f7dfcb 100644
--- a/drivers/vin/sensors/micron_mt9t002_mipi/Kbuild
+++ b/drivers/vin/sensors/micron_mt9t002_mipi/Kbuild
@@ -4,15 +4,30 @@
 ## History:
 ##    2011/01/12 - [Haowei Lo] Create
 ##
-## Copyright (C) 2004-2011, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
-## This file is produced by perl.
-##/
 
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/micron_mt9t002_mipi/make.inc b/drivers/vin/sensors/micron_mt9t002_mipi/make.inc
index e8854fc..4604977 100644
--- a/drivers/vin/sensors/micron_mt9t002_mipi/make.inc
+++ b/drivers/vin/sensors/micron_mt9t002_mipi/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/04 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_MT9T002_MIPI), y)
diff --git a/drivers/vin/sensors/micron_mt9t002_mipi/mt9t002.c b/drivers/vin/sensors/micron_mt9t002_mipi/mt9t002.c
index 1861991..f133e21 100644
--- a/drivers/vin/sensors/micron_mt9t002_mipi/mt9t002.c
+++ b/drivers/vin/sensors/micron_mt9t002_mipi/mt9t002.c
@@ -4,15 +4,33 @@
  * History:
  *    2012/03/23 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2013, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
diff --git a/drivers/vin/sensors/micron_mt9t002_mipi/mt9t002.h b/drivers/vin/sensors/micron_mt9t002_mipi/mt9t002.h
index e3304bb..0486177 100644
--- a/drivers/vin/sensors/micron_mt9t002_mipi/mt9t002.h
+++ b/drivers/vin/sensors/micron_mt9t002_mipi/mt9t002.h
@@ -4,15 +4,33 @@
  * History:
  *    2012/03/23 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2013, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #ifndef __MT9T002_PRI_H__
 #define __MT9T002_PRI_H__
 
diff --git a/drivers/vin/sensors/micron_mt9t002_mipi/mt9t002_table.c b/drivers/vin/sensors/micron_mt9t002_mipi/mt9t002_table.c
index 312c6d3..075a38f 100644
--- a/drivers/vin/sensors/micron_mt9t002_mipi/mt9t002_table.c
+++ b/drivers/vin/sensors/micron_mt9t002_mipi/mt9t002_table.c
@@ -4,14 +4,33 @@
  * History:
  *    2012/03/23 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2013, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_reg_16_16 mt9t002_pll_regs[][15] = {
 	{// For 3M 29.97fps
 		{0x302A, 6	}, 	/* vt_pix_clk_div */
diff --git a/drivers/vin/sensors/micron_mt9t002_parallel/Kbuild b/drivers/vin/sensors/micron_mt9t002_parallel/Kbuild
index 07a6395..4da04e1 100644
--- a/drivers/vin/sensors/micron_mt9t002_parallel/Kbuild
+++ b/drivers/vin/sensors/micron_mt9t002_parallel/Kbuild
@@ -4,15 +4,30 @@
 ## History:
 ##    2011/01/12 - [Haowei Lo] Create
 ##
-## Copyright (C) 2004-2011, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
-## This file is produced by perl.
-##/
 
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/micron_mt9t002_parallel/make.inc b/drivers/vin/sensors/micron_mt9t002_parallel/make.inc
index 3a6506d..63999f9 100644
--- a/drivers/vin/sensors/micron_mt9t002_parallel/make.inc
+++ b/drivers/vin/sensors/micron_mt9t002_parallel/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/04 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_MT9T002_PARALLEL), y)
diff --git a/drivers/vin/sensors/micron_mt9t002_parallel/mt9t002.c b/drivers/vin/sensors/micron_mt9t002_parallel/mt9t002.c
index b78043c..5d061e2 100644
--- a/drivers/vin/sensors/micron_mt9t002_parallel/mt9t002.c
+++ b/drivers/vin/sensors/micron_mt9t002_parallel/mt9t002.c
@@ -4,15 +4,33 @@
  * History:
  *    2011/01/12 - [Haowei Lo] Create
  *
- * Copyright (C) 2004-2011, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
diff --git a/drivers/vin/sensors/micron_mt9t002_parallel/mt9t002.h b/drivers/vin/sensors/micron_mt9t002_parallel/mt9t002.h
index 4801194..e1e93a9 100644
--- a/drivers/vin/sensors/micron_mt9t002_parallel/mt9t002.h
+++ b/drivers/vin/sensors/micron_mt9t002_parallel/mt9t002.h
@@ -4,15 +4,33 @@
  * History:
  *    2011/01/12 - [Haowei Lo] Create
  *
- * Copyright (C) 2004-2011, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #ifndef __MT9T002_PRI_H__
 #define __MT9T002_PRI_H__
 
diff --git a/drivers/vin/sensors/micron_mt9t002_parallel/mt9t002_table.c b/drivers/vin/sensors/micron_mt9t002_parallel/mt9t002_table.c
index 0eb0895..74107be 100644
--- a/drivers/vin/sensors/micron_mt9t002_parallel/mt9t002_table.c
+++ b/drivers/vin/sensors/micron_mt9t002_parallel/mt9t002_table.c
@@ -4,14 +4,33 @@
  * History:
  *    2011/01/12 - [Haowei Lo] Create
  *
- * Copyright (C) 2004-2011, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_reg_16_16 mt9t002_pll_regs[][7] = {
 	{/* 2304x1296@30fps */
 		{0x302A, 8	}, 	/* vt_pix_clk_div */
diff --git a/drivers/vin/sensors/omnivision_ov2732_mipi/Kbuild b/drivers/vin/sensors/omnivision_ov2732_mipi/Kbuild
new file mode 100644
index 0000000..c929bab
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2732_mipi/Kbuild
@@ -0,0 +1,39 @@
+##
+## Filename : Kbuild
+##
+## History:
+##    2016/12/16 - [Hao Zeng] created file
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+
+EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
+EXTRA_AFLAGS		+= $(AMBARELLA_DRV_AFLAGS)
+EXTRA_LDFLAGS		+= $(AMBARELLA_DRV_LDFLAGS)
+
+obj-m := ov2732_mipi.o
+ov2732_mipi-y := ov2732.o
+
diff --git a/drivers/vin/sensors/omnivision_ov2732_mipi/make.inc b/drivers/vin/sensors/omnivision_ov2732_mipi/make.inc
new file mode 100644
index 0000000..9695c49
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2732_mipi/make.inc
@@ -0,0 +1,45 @@
+##
+## kernel/private/platform/vin/sensors/omnivision_ov2732_mipi/make.inc
+##
+## History:
+##    2016/12/16 - [Hao Zeng] created file
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+ifeq ($(CONFIG_SENSOR_OV2732_MIPI), y)
+
+LOCAL_PATH	:= $(call my-dir)
+
+###
+include $(CLEAR_VARS)
+
+LOCAL_SRCS	:= $(wildcard $(LOCAL_PATH)/*.c) $(wildcard $(LOCAL_PATH)/*.h)
+LOCAL_SRCS	+= $(LOCAL_PATH)/Kbuild
+
+include $(BUILD_DRIVER)
+
+endif
+
diff --git a/drivers/vin/sensors/omnivision_ov2732_mipi/ov2732.c b/drivers/vin/sensors/omnivision_ov2732_mipi/ov2732.c
new file mode 100644
index 0000000..cd3f42e
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2732_mipi/ov2732.c
@@ -0,0 +1,793 @@
+/*
+ * Filename : ov2732.c
+ *
+ * History:
+ *    2016/12/16 - [Hao Zeng] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/ambpriv_device.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <iav_utils.h>
+#include <vin_api.h>
+#include "ov2732.h"
+#include "ov2732_table.c"
+
+static int bus_addr = (0 << 16) | (0x6C >> 1);
+module_param(bus_addr, int, 0644);
+MODULE_PARM_DESC(bus_addr, " bus and addr: bit16~bit31: bus, bit0~bit15: addr");
+
+struct ov2732_priv {
+	void *control_data;
+	struct vindev_wdr_gp_s wdr_again_gp;
+	struct vindev_wdr_gp_s wdr_dgain_gp;
+	struct vindev_wdr_gp_s wdr_shutter_gp;
+	u32 line_length;
+	u32 frame_length_lines;
+	u32 max_short;
+};
+
+static int ov2732_write_reg(struct vin_device *vdev, u32 subaddr, u32 data)
+{
+	int rval;
+	struct ov2732_priv *ov2732;
+	struct i2c_client *client;
+	struct i2c_msg msgs[1];
+	u8 pbuf[3];
+
+	ov2732 = (struct ov2732_priv *)vdev->priv;
+	client = ov2732->control_data;
+
+	pbuf[0] = (subaddr >> 8);
+	pbuf[1] = (subaddr & 0xff);
+	pbuf[2] = data;
+
+	msgs[0].len = 3;
+	msgs[0].addr = client->addr;
+
+	if (unlikely(subaddr == OV2732_SWRESET))
+		msgs[0].flags = client->flags | I2C_M_IGNORE_NAK;
+	else
+		msgs[0].flags = client->flags;
+
+	msgs[0].buf = pbuf;
+	rval = i2c_transfer(client->adapter, msgs, 1);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x:0x%x]\n", rval, subaddr, data);
+		return rval;
+	}
+
+	return 0;
+}
+
+static int ov2732_write_reg2(struct vin_device *vdev, u32 subaddr, u32 data)
+{
+	int rval;
+	struct ov2732_priv *ov2732;
+	struct i2c_client *client;
+	struct i2c_msg msgs[1];
+	u8 pbuf[4];
+
+	ov2732 = (struct ov2732_priv *)vdev->priv;
+	client = ov2732->control_data;
+
+	pbuf[0] = (subaddr >> 8);
+	pbuf[1] = (subaddr & 0xff);
+	pbuf[2] = data >> 8;
+	pbuf[3] = data & 0xff;
+
+	msgs[0].len = 4;
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].buf = pbuf;
+
+	rval = i2c_transfer(client->adapter, msgs, 1);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x:0x%x]\n", rval, subaddr, data);
+		return rval;
+	}
+
+	return 0;
+}
+
+static int ov2732_read_reg(struct vin_device *vdev, u32 subaddr, u32 *data)
+{
+	int rval = 0;
+	struct ov2732_priv *ov2732;
+	struct i2c_client *client;
+	struct i2c_msg msgs[2];
+	u8 pbuf0[2];
+	u8 pbuf[1];
+
+	ov2732 = (struct ov2732_priv *)vdev->priv;
+	client = ov2732->control_data;
+
+	pbuf0[0] = (subaddr >> 8);
+	pbuf0[1] = (subaddr & 0xff);
+
+	msgs[0].len = 2;
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].buf = pbuf0;
+
+	msgs[1].addr = client->addr;
+	msgs[1].flags = client->flags | I2C_M_RD;
+	msgs[1].buf = pbuf;
+	msgs[1].len = 1;
+
+	rval = i2c_transfer(client->adapter, msgs, 2);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x]\n", rval, subaddr);
+		return rval;
+	}
+
+	*data = pbuf[0];
+
+	return 0;
+}
+
+static int ov2732_set_vin_mode(struct vin_device *vdev, struct vin_video_format *format)
+{
+	struct vin_device_config ov2732_config;
+
+	memset(&ov2732_config, 0, sizeof(ov2732_config));
+
+	ov2732_config.interface_type = SENSOR_MIPI;
+	ov2732_config.sync_mode = SENSOR_SYNC_MODE_MASTER;
+
+	ov2732_config.mipi_cfg.lane_number = SENSOR_2_LANE;
+
+	ov2732_config.cap_win.x = format->def_start_x;
+	ov2732_config.cap_win.y = format->def_start_y;
+	ov2732_config.cap_win.width = format->def_width;
+	ov2732_config.cap_win.height = format->def_height;
+
+	/* for hdr sensor */
+	ov2732_config.hdr_cfg.act_win.x = format->act_start_x;
+	ov2732_config.hdr_cfg.act_win.y = format->act_start_y;
+	ov2732_config.hdr_cfg.act_win.width = format->act_width;
+	ov2732_config.hdr_cfg.act_win.height = format->act_height;
+
+	ov2732_config.sensor_id	= GENERIC_SENSOR;
+	ov2732_config.input_format	= AMBA_VIN_INPUT_FORMAT_RGB_RAW;
+	ov2732_config.bayer_pattern	= format->bayer_pattern;
+	ov2732_config.video_format	= format->format;
+	ov2732_config.bit_resolution	= format->bits;
+
+	return ambarella_set_vin_config(vdev, &ov2732_config);
+}
+
+static void ov2732_sw_reset(struct vin_device *vdev)
+{
+	ov2732_write_reg(vdev, OV2732_SWRESET, 0x01);
+	msleep(5);
+}
+
+static int ov2732_init_device(struct vin_device *vdev)
+{
+	ov2732_sw_reset(vdev);
+	return 0;
+}
+
+static void ov2732_start_streaming(struct vin_device *vdev)
+{
+	ov2732_write_reg(vdev, OV2732_STANDBY, 0x01); /* streaming */
+}
+
+static int ov2732_get_line_time(struct vin_device *vdev)
+{
+	u64 h_clks;
+	struct ov2732_priv *pinfo = (struct ov2732_priv *)vdev->priv;
+
+	h_clks = (u64)pinfo->line_length * 512000000;
+	h_clks = DIV64_CLOSEST(h_clks, vdev->cur_pll->pixelclk);
+
+	vdev->cur_format->line_time = (u32)h_clks;
+
+	return 0;
+}
+
+static int ov2732_update_hv_info(struct vin_device *vdev)
+{
+	struct ov2732_priv *pinfo = (struct ov2732_priv *)vdev->priv;
+	u32 data_h, data_l;
+
+	ov2732_read_reg(vdev, OV2732_HTS_MSB, &data_h);
+	ov2732_read_reg(vdev, OV2732_HTS_LSB, &data_l);
+	pinfo->line_length = (data_h<<8) + data_l;
+	if (unlikely(!pinfo->line_length)) {
+		vin_error("line length is 0!\n");
+		return -EIO;
+	}
+
+	ov2732_read_reg(vdev, OV2732_VTS_MSB, &data_h);
+	ov2732_read_reg(vdev, OV2732_VTS_LSB, &data_l);
+	pinfo->frame_length_lines = (data_h<<8) + data_l;
+
+	if (vdev->cur_format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {
+		if (vdev->cur_format->video_mode == AMBA_VIDEO_MODE_1080P)
+			pinfo->max_short = S_MAX_EXPO_1080P;
+		else if (vdev->cur_format->video_mode == AMBA_VIDEO_MODE_720P)
+			pinfo->max_short = S_MAX_EXPO_720P;
+		ov2732_write_reg2(vdev, OV2732_S_MAX_EXPO_MSB, pinfo->max_short);
+	}
+
+	vin_debug("line_length:%d, frame_length_lines:%d, max_short:%d\n",
+		pinfo->line_length, pinfo->frame_length_lines, pinfo->max_short);
+
+	return 0;
+}
+
+static int ov2732_set_format(struct vin_device *vdev, struct vin_video_format *format)
+{
+	int rval;
+	struct vin_reg_16_8 *regs;
+	int i, regs_num;
+
+	switch (format->hdr_mode) {
+	case AMBA_VIDEO_LINEAR_MODE:
+		regs = ov2732_linear_mode_regs;
+		regs_num = ARRAY_SIZE(ov2732_linear_mode_regs);
+		break;
+	case AMBA_VIDEO_2X_HDR_MODE:
+		regs = ov2732_hdr_mode_regs;
+		regs_num = ARRAY_SIZE(ov2732_hdr_mode_regs);
+		break;
+	default:
+		regs = NULL;
+		regs_num = 0;
+		vin_error("Unknown mode\n");
+		return -EINVAL;
+	}
+	for (i = 0; i < regs_num; i++)
+		ov2732_write_reg(vdev, regs[i].addr, regs[i].data);
+
+	regs = ov2732_mode_regs[format->device_mode];
+	regs_num = ARRAY_SIZE(ov2732_mode_regs[format->device_mode]);
+	for (i = 0; i < regs_num; i++)
+		ov2732_write_reg(vdev, regs[i].addr, regs[i].data);
+
+	rval = ov2732_update_hv_info(vdev);
+	if (rval < 0)
+		return rval;
+
+	ov2732_get_line_time(vdev);
+
+	/* Enable Streaming */
+	ov2732_start_streaming(vdev);
+
+	/* communicate with IAV */
+	rval = ov2732_set_vin_mode(vdev, format);
+	if (rval < 0)
+		return rval;
+
+	return 0;
+}
+
+static int ov2732_set_hold_mode(struct vin_device *vdev, u32 hold_mode)
+{
+	if (hold_mode) {
+		ov2732_write_reg(vdev, OV2732_GRP_ACCESS, 0x00);
+	} else {
+		ov2732_write_reg(vdev, OV2732_GRP_ACCESS, 0x10);
+		ov2732_write_reg(vdev, OV2732_GRP_ACCESS, 0xA0);
+	}
+
+	return 0;
+}
+
+static int ov2732_set_shutter_row(struct vin_device *vdev, u32 row)
+{
+	struct ov2732_priv *pinfo = (struct ov2732_priv *)vdev->priv;
+	u64 exposure_lines;
+	u32 num_line, min_line, max_line;
+	int rval = 0;
+
+	num_line = row;
+
+	/* FIXME: shutter width: 4 ~ (Frame format(V) - 4) */
+	min_line = 4;
+	max_line = pinfo->frame_length_lines - 4;
+	num_line = clamp(num_line, min_line, max_line);
+
+	num_line <<= 4; /* the register value should be exposure time * 16 */
+	ov2732_write_reg2(vdev, OV2732_L_EXPO_HSB, (num_line >> 8) & 0x0FFF);
+	ov2732_write_reg(vdev, OV2732_L_EXPO_LSB, num_line & 0xFF);
+	num_line >>= 4;
+
+	exposure_lines = num_line;
+	exposure_lines = exposure_lines * (u64)pinfo->line_length * 512000000;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, vdev->cur_pll->pixelclk);
+
+	vdev->shutter_time = (u32)exposure_lines;
+	vin_debug("shutter_time:%d, row:%d\n", vdev->shutter_time, num_line);
+
+	return rval;
+}
+
+static int ov2732_shutter2row(struct vin_device *vdev, u32 *shutter_time)
+{
+	struct ov2732_priv *pinfo = (struct ov2732_priv *)vdev->priv;
+	u64 exposure_lines;
+	int rval = 0;
+
+	/* for fast boot, it may call set shutter time directly, so we must read line length/frame line */
+	if (!pinfo->line_length) {
+		rval = ov2732_update_hv_info(vdev);
+		if (rval < 0)
+			return rval;
+
+		ov2732_get_line_time(vdev);
+	}
+
+	exposure_lines = (*shutter_time) * (u64)vdev->cur_pll->pixelclk;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, pinfo->line_length);
+	exposure_lines = DIV64_CLOSEST(exposure_lines, 512000000);
+
+	*shutter_time = exposure_lines;
+
+	return rval;
+}
+
+static int ov2732_set_wdr_shutter_row_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_shutter_gp)
+{
+	struct ov2732_priv *pinfo = (struct ov2732_priv *)vdev->priv;
+	int shutter_long, shutter_short1, max_short;
+	u32 frame_length_lines;
+
+	frame_length_lines = pinfo->frame_length_lines;
+	max_short = (pinfo->max_short >> 1) - 4;
+
+	/* long shutter */
+	shutter_long = p_shutter_gp->l;
+
+	/* short shutter 1 */
+	shutter_short1 = p_shutter_gp->s1;
+
+	/* shutter limitation check */
+	if (shutter_short1 > max_short) {
+		vin_error("short shutter %d exceeds limitation %d\n", shutter_short1, max_short);
+		return -EPERM;
+	}
+
+	if (shutter_long + max_short > frame_length_lines - 4) {
+		vin_error("shutter exceeds limitation! long:%d, max short:%d, V:%d\n",
+			shutter_long, max_short, frame_length_lines);
+		return -EPERM;
+	}
+
+	/* long shutter */
+	shutter_long = shutter_long << 4;
+	ov2732_write_reg2(vdev, OV2732_L_EXPO_HSB, (shutter_long >> 8) & 0x0FFF);
+	ov2732_write_reg(vdev, OV2732_L_EXPO_LSB, shutter_long & 0xFF);
+
+	/* short shutter 1 */
+	shutter_short1 = shutter_short1 << 4;
+	ov2732_write_reg2(vdev, OV2732_S_EXPO_HSB, (shutter_short1 >> 8) & 0x0FFF);
+	ov2732_write_reg(vdev, OV2732_S_EXPO_LSB, shutter_short1 & 0xFF);
+
+	memcpy(&(pinfo->wdr_shutter_gp),  p_shutter_gp, sizeof(struct vindev_wdr_gp_s));
+
+	vin_debug("shutter long:%d, short1:%d\n", p_shutter_gp->l,
+		p_shutter_gp->s1);
+
+	return 0;
+}
+
+static int ov2732_get_wdr_shutter_row_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_shutter_gp)
+{
+	struct ov2732_priv *pinfo = (struct ov2732_priv *)vdev->priv;
+	memcpy(p_shutter_gp, &(pinfo->wdr_shutter_gp), sizeof(struct vindev_wdr_gp_s));
+
+	return 0;
+}
+
+static int ov2732_set_fps(struct vin_device *vdev, int fps)
+{
+	struct ov2732_priv *pinfo = (struct ov2732_priv *)vdev->priv;
+	u64 pixelclk, v_lines, vb_time;
+
+	pixelclk = vdev->cur_pll->pixelclk;
+
+	v_lines = fps * pixelclk;
+	v_lines = DIV64_CLOSEST(v_lines, pinfo->line_length);
+	v_lines = DIV64_CLOSEST(v_lines, 512000000);
+
+	/* temporally disable VTS write for hdr mode */
+	if (vdev->cur_format->hdr_mode == AMBA_VIDEO_LINEAR_MODE)
+		ov2732_write_reg2(vdev, OV2732_VTS_MSB, v_lines & 0xFFFF);
+
+	pinfo->frame_length_lines = v_lines;
+
+	v_lines = pinfo->frame_length_lines - vdev->cur_format->height;
+	vb_time = pinfo->line_length * (u64)v_lines * 1000000000;
+	vb_time = DIV64_CLOSEST(vb_time, pixelclk);
+	vdev->cur_format->vb_time = vb_time;
+
+	return 0;
+}
+
+static int ov2732_set_agc_index(struct vin_device *vdev, int agc_idx)
+{
+	if (agc_idx > OV2732_GAIN_MAXDB) {
+		vin_warn("agc index %d exceeds maximum %d\n", agc_idx, OV2732_GAIN_MAXDB);
+		agc_idx = OV2732_GAIN_MAXDB;
+	}
+
+	/* Analog Gain */
+	ov2732_write_reg2(vdev, OV2732_L_AGAIN_MSB, OV2732_GAIN_TABLE[agc_idx][OV2732_GAIN_COL_AGAIN]);
+	/* Digital Gain */
+	ov2732_write_reg2(vdev, OV2732_L_DGAIN_MSB, OV2732_GAIN_TABLE[agc_idx][OV2732_GAIN_COL_DGAIN]);
+
+	return 0;
+}
+
+static int ov2732_set_wdr_again_idx_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_again_gp)
+{
+	struct ov2732_priv *pinfo = (struct ov2732_priv *)vdev->priv;
+	u32 gain_index;
+
+	/* long frame */
+	gain_index = p_again_gp->l;
+	ov2732_write_reg2(vdev, OV2732_L_AGAIN_MSB, OV2732_GAIN_TABLE[gain_index][OV2732_GAIN_COL_AGAIN]);
+	ov2732_write_reg2(vdev, OV2732_L_DGAIN_MSB, OV2732_GAIN_TABLE[gain_index][OV2732_GAIN_COL_DGAIN]);
+
+	/* short frame 1 */
+	gain_index = p_again_gp->s1;
+	ov2732_write_reg2(vdev, OV2732_S_AGAIN_MSB, OV2732_GAIN_TABLE[gain_index][OV2732_GAIN_COL_AGAIN]);
+	ov2732_write_reg2(vdev, OV2732_S_DGAIN_MSB, OV2732_GAIN_TABLE[gain_index][OV2732_GAIN_COL_DGAIN]);
+
+	memcpy(&(pinfo->wdr_again_gp), p_again_gp, sizeof(struct vindev_wdr_gp_s));
+
+	vin_debug("long again index:%d, short1 again index:%d\n",
+		p_again_gp->l, p_again_gp->s1);
+
+	return 0;
+}
+
+static int ov2732_get_wdr_again_idx_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_again_gp)
+{
+	struct ov2732_priv *pinfo = (struct ov2732_priv *)vdev->priv;
+
+	memcpy(p_again_gp, &(pinfo->wdr_again_gp), sizeof(struct vindev_wdr_gp_s));
+	return 0;
+}
+
+static int ov2732_set_wdr_dgain_idx_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_dgain_gp)
+{
+	struct ov2732_priv *pinfo = (struct ov2732_priv *)vdev->priv;
+
+	memcpy(&(pinfo->wdr_dgain_gp), p_dgain_gp, sizeof(struct vindev_wdr_gp_s));
+
+	vin_debug("long dgain index:%d, short1 dgain index:%d\n",
+		p_dgain_gp->l, p_dgain_gp->s1);
+
+	return 0;
+}
+
+static int ov2732_get_wdr_dgain_idx_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_dgain_gp)
+{
+	struct ov2732_priv *pinfo = (struct ov2732_priv *)vdev->priv;
+
+	memcpy(p_dgain_gp, &(pinfo->wdr_dgain_gp), sizeof(struct vindev_wdr_gp_s));
+	return 0;
+}
+
+static int ov2732_wdr_shutter2row(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_shutter2row)
+{
+	struct ov2732_priv *pinfo = (struct ov2732_priv *)vdev->priv;
+	u64 exposure_lines;
+	int rval = 0;
+
+	/* for fast boot, it may call set shutter time directly, so we must read line length/frame line */
+	if (!pinfo->line_length) {
+		rval = ov2732_update_hv_info(vdev);
+		if (rval < 0)
+			return rval;
+
+		ov2732_get_line_time(vdev);
+	}
+
+	/* long shutter */
+	exposure_lines = p_shutter2row->l * (u64)vdev->cur_pll->pixelclk;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, pinfo->line_length);
+	exposure_lines = DIV64_CLOSEST(exposure_lines, 512000000);
+	p_shutter2row->l = (u32)exposure_lines;
+
+	/* short shutter 1 */
+	exposure_lines = p_shutter2row->s1 * (u64)vdev->cur_pll->pixelclk;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, pinfo->line_length);
+	exposure_lines = DIV64_CLOSEST(exposure_lines, 512000000);
+	p_shutter2row->s1 = (u32)exposure_lines;
+
+	return rval;
+}
+
+static int ov2732_set_mirror_mode(struct vin_device *vdev,
+	struct vindev_mirror *mirror_mode)
+{
+	int rval = 0;
+	u32 tmp_reg, bayer_pattern, v_flip = 0, h_mirror = 0;
+
+	switch (mirror_mode->pattern) {
+	case VINDEV_MIRROR_AUTO:
+		return 0;
+
+	case VINDEV_MIRROR_HORRIZONTALLY_VERTICALLY:
+		v_flip = OV2732_V_FLIP;
+		h_mirror = OV2732_H_MIRROR;
+		bayer_pattern = VINDEV_BAYER_PATTERN_BG;
+		break;
+
+	case VINDEV_MIRROR_HORRIZONTALLY:
+		v_flip = 0;
+		h_mirror = OV2732_H_MIRROR;
+		bayer_pattern = VINDEV_BAYER_PATTERN_BG;
+		break;
+
+	case VINDEV_MIRROR_VERTICALLY:
+		v_flip = OV2732_V_FLIP;
+		h_mirror = 0;
+		bayer_pattern = VINDEV_BAYER_PATTERN_BG;
+		break;
+
+	case VINDEV_MIRROR_NONE:
+		v_flip = 0;
+		h_mirror = 0;
+		bayer_pattern = VINDEV_BAYER_PATTERN_BG;
+		break;
+
+	default:
+		vin_error("do not support cmd mirror mode\n");
+		return -EINVAL;
+	}
+
+	ov2732_read_reg(vdev, OV2732_FORMAT1, &tmp_reg);
+	tmp_reg &= (~OV2732_V_FLIP);
+	tmp_reg |= OV2732_H_MIRROR;
+	tmp_reg |= v_flip;
+	tmp_reg ^= h_mirror;
+	ov2732_write_reg(vdev, OV2732_FORMAT1, tmp_reg);
+
+	if (mirror_mode->bayer_pattern == VINDEV_BAYER_PATTERN_AUTO)
+		mirror_mode->bayer_pattern = bayer_pattern;
+
+	return rval;
+}
+
+static int ov2732_get_chip_status(struct vin_device *vdev,
+	struct vindev_chip_status *chip_status)
+{
+	u32 tmp_reg;
+
+	ov2732_read_reg(vdev, OV2732_TPM_TRIGGER, &tmp_reg);
+	tmp_reg |= 0x01;
+	ov2732_write_reg(vdev, OV2732_TPM_TRIGGER, tmp_reg);
+	/* wait some time to read temperature */
+	msleep(5);
+	ov2732_read_reg(vdev, OV2732_TPM_READ, &tmp_reg);
+
+	chip_status->temperature = (tmp_reg & 0xFF) - OV2732_TPM_OFFSET;
+
+	return 0;
+}
+
+static int ov2732_get_eis_info(struct vin_device *vdev,
+	struct vindev_eisinfo *eis_info)
+{
+	eis_info->sensor_cell_width = 200;/* 2.0 um */
+	eis_info->sensor_cell_height = 200;/* 2.0 um */
+	eis_info->column_bin = 1;
+	eis_info->row_bin = 1;
+	eis_info->vb_time = vdev->cur_format->vb_time;
+
+	return 0;
+}
+
+static int ov2732_get_aaa_info(struct vin_device *vdev,
+	struct vindev_aaa_info *aaa_info)
+{
+	struct ov2732_priv *pinfo = (struct ov2732_priv *)vdev->priv;
+
+	aaa_info->sht0_max = pinfo->frame_length_lines - 4;
+	aaa_info->sht1_max = (pinfo->max_short >> 1) - 4;
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int ov2732_suspend(struct vin_device *vdev)
+{
+	u32 i, tmp;
+
+	for (i = 0; i < ARRAY_SIZE(pm_regs); i++) {
+		ov2732_read_reg(vdev, pm_regs[i].addr, &tmp);
+		pm_regs[i].data = (u8)tmp;
+	}
+
+	return 0;
+}
+
+static int ov2732_resume(struct vin_device *vdev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(pm_regs); i++)
+		ov2732_write_reg(vdev, pm_regs[i].addr, pm_regs[i].data);
+
+	return 0;
+}
+#endif
+
+static struct vin_ops ov2732_ops = {
+	.init_device		= ov2732_init_device,
+	.set_format		= ov2732_set_format,
+	.set_shutter_row	= ov2732_set_shutter_row,
+	.shutter2row		= ov2732_shutter2row,
+	.set_frame_rate	= ov2732_set_fps,
+	.set_agc_index		= ov2732_set_agc_index,
+	.set_mirror_mode	= ov2732_set_mirror_mode,
+	.set_hold_mode		= ov2732_set_hold_mode,
+	.get_chip_status	= ov2732_get_chip_status,
+	.get_eis_info		= ov2732_get_eis_info,
+	.get_aaa_info		= ov2732_get_aaa_info,
+	.read_reg			= ov2732_read_reg,
+	.write_reg		= ov2732_write_reg,
+#ifdef CONFIG_PM
+	.suspend		= ov2732_suspend,
+	.resume			= ov2732_resume,
+#endif
+
+	/* for wdr sensor */
+	.set_wdr_again_idx_gp = ov2732_set_wdr_again_idx_group,
+	.get_wdr_again_idx_gp = ov2732_get_wdr_again_idx_group,
+	.set_wdr_dgain_idx_gp = ov2732_set_wdr_dgain_idx_group,
+	.get_wdr_dgain_idx_gp = ov2732_get_wdr_dgain_idx_group,
+	.set_wdr_shutter_row_gp = ov2732_set_wdr_shutter_row_group,
+	.get_wdr_shutter_row_gp = ov2732_get_wdr_shutter_row_group,
+	.wdr_shutter2row = ov2732_wdr_shutter2row,
+};
+
+/* ========================================================================== */
+static int ov2732_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	int rval = 0;
+	struct vin_device *vdev;
+	struct ov2732_priv *ov2732;
+	u32 cid_l, cid_m;
+
+	vdev = ambarella_vin_create_device(client->name,
+		SENSOR_OV2732, sizeof(struct ov2732_priv));
+	if (!vdev)
+		return -ENOMEM;
+
+	vdev->intf_id = 0;
+	vdev->dev_type = VINDEV_TYPE_SENSOR;
+	vdev->sub_type = VINDEV_SUBTYPE_CMOS;
+	vdev->default_mode = AMBA_VIDEO_MODE_1080P;
+	vdev->default_hdr_mode = AMBA_VIDEO_LINEAR_MODE;
+	vdev->agc_db_max = 0x24000000;  /* 36dB */
+	vdev->agc_db_min = 0x00000000;  /* 0dB */
+	vdev->agc_db_step = 0x00180000; /* 0.09375dB */
+	vdev->wdr_again_idx_min = 0;
+	vdev->wdr_again_idx_max = OV2732_GAIN_MAXDB;
+	vdev->wdr_dgain_idx_min = 0;
+	vdev->wdr_dgain_idx_max = 0;
+
+	i2c_set_clientdata(client, vdev);
+
+	ov2732 = (struct ov2732_priv *)vdev->priv;
+	ov2732->control_data = client;
+
+	rval = ambarella_vin_register_device(vdev, &ov2732_ops,
+		ov2732_formats, ARRAY_SIZE(ov2732_formats),
+		ov2732_plls, ARRAY_SIZE(ov2732_plls));
+	if (rval < 0)
+		goto ov2732_probe_err;
+
+	/* query sensor id */
+	ov2732_read_reg(vdev, OV2732_CID_M, &cid_m);
+	ov2732_read_reg(vdev, OV2732_CID_L, &cid_l);
+	vin_info("OV2732 init(2-lane mipi), sensor ID: 0x%x\n", (cid_m<<8)+cid_l);
+
+	return 0;
+
+ov2732_probe_err:
+	ambarella_vin_free_device(vdev);
+	return rval;
+}
+
+static int ov2732_remove(struct i2c_client *client)
+{
+	struct vin_device *vdev;
+
+	vdev = (struct vin_device *)i2c_get_clientdata(client);
+	ambarella_vin_unregister_device(vdev);
+	ambarella_vin_free_device(vdev);
+
+	return 0;
+}
+
+static const struct i2c_device_id ov2732_idtable[] = {
+	{ "ov2732", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ov2732_idtable);
+
+static struct i2c_driver i2c_driver_ov2732 = {
+	.driver = {
+		.name	= "ov2732",
+	},
+
+	.id_table	= ov2732_idtable,
+	.probe		= ov2732_probe,
+	.remove		= ov2732_remove,
+
+};
+
+static int __init ov2732_init(void)
+{
+	int bus, addr, rval;
+
+	bus = bus_addr >> 16;
+	addr = bus_addr & 0xffff;
+
+	rval = ambpriv_i2c_update_addr("ov2732", bus, addr);
+	if (rval < 0)
+		return rval;
+
+	rval = i2c_add_driver(&i2c_driver_ov2732);
+	if (rval < 0)
+		return rval;
+
+	return 0;
+}
+
+static void __exit ov2732_exit(void)
+{
+	i2c_del_driver(&i2c_driver_ov2732);
+}
+
+module_init(ov2732_init);
+module_exit(ov2732_exit);
+
+MODULE_DESCRIPTION("OV2732 1/4-Inch, 1920x1080, 2-Megapixel CMOS Digital Image Sensor");
+MODULE_AUTHOR("Hao Zeng <haozeng@ambarella.com>");
+MODULE_LICENSE("Proprietary");
+
diff --git a/drivers/vin/sensors/omnivision_ov2732_mipi/ov2732.h b/drivers/vin/sensors/omnivision_ov2732_mipi/ov2732.h
new file mode 100644
index 0000000..f349f13
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2732_mipi/ov2732.h
@@ -0,0 +1,88 @@
+/*
+ * Filename : ov2732.h
+ *
+ * History:
+ *    2016/12/16 - [Hao Zeng] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __OV2732_H__
+#define __OV2732_H__
+
+#define OV2732_STANDBY			0x0100
+#define OV2732_SWRESET			0x0103
+
+#define OV2732_CID_M			0x300B
+#define OV2732_CID_L			0x300C
+
+#define OV2732_GRP_ACCESS		0x3208
+
+#define OV2732_HTS_MSB			0x380C
+#define OV2732_HTS_LSB			0x380D
+#define OV2732_VTS_MSB			0x380E
+#define OV2732_VTS_LSB			0x380F
+
+#define OV2732_L_EXPO_HSB		0x3500
+#define OV2732_L_EXPO_MSB		0x3501
+#define OV2732_L_EXPO_LSB		0x3502
+
+#define OV2732_L_AGAIN_MSB		0x3508
+#define OV2732_L_AGAIN_LSB		0x3509
+#define OV2732_L_DGAIN_MSB		0x350A
+#define OV2732_L_DGAIN_LSB		0x350B
+
+#define OV2732_S_AGAIN_MSB		0x350C
+#define OV2732_S_AGAIN_LSB		0x350D
+#define OV2732_S_DGAIN_MSB		0x350E
+#define OV2732_S_DGAIN_LSB		0x350F
+
+#define OV2732_S_EXPO_HSB		0x3510
+#define OV2732_S_EXPO_MSB		0x3511
+#define OV2732_S_EXPO_LSB		0x3512
+
+#define OV2732_S_MAX_EXPO_MSB	0x377C
+#define OV2732_S_MAX_EXPO_LSB	0x377D
+
+#define OV2732_MIPI_CTRL00		0x4800
+
+#define OV2732_MIPI_GATE		(1<<5)
+
+#define OV2732_FORMAT1		0x3820
+
+#define OV2732_V_FLIP			(1<<4)
+#define OV2732_H_MIRROR		(1<<3)
+#define OV2732_MIRROR_MASK	(OV2732_H_MIRROR + OV2732_V_FLIP)
+
+#define OV2732_TPM_TRIGGER	0x4D12
+#define OV2732_TPM_READ		0x4D13
+#define OV2732_TPM_OFFSET	64
+
+#define S_MAX_EXPO_1080P		288
+#define S_MAX_EXPO_720P		288
+
+#endif /* __OV2732_H__ */
+
diff --git a/drivers/vin/sensors/omnivision_ov2732_mipi/ov2732_table.c b/drivers/vin/sensors/omnivision_ov2732_mipi/ov2732_table.c
new file mode 100644
index 0000000..50ad5cc
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2732_mipi/ov2732_table.c
@@ -0,0 +1,1245 @@
+/*
+ * Filename : ov2732_table.c
+ *
+ * History:
+ *    2016/12/16 - [Hao Zeng] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+static struct vin_video_pll ov2732_plls[] = {
+	/* for linear mode */
+	{0, 24000000, 45000000},
+	/* for hdr mode */
+	{0, 24000000, 22500000},
+};
+
+static struct vin_reg_16_8 ov2732_mode_regs[][16] = {
+	{	/* 1080p linear */
+		{0x3800, 0x00},
+		{0x3801, 0x00},
+		{0x3802, 0x00},
+		{0x3803, 0x04},
+		{0x3804, 0x07},
+		{0x3805, 0x8f},
+		{0x3806, 0x04},
+		{0x3807, 0x43},
+		{0x3808, 0x07},
+		{0x3809, 0x80},
+		{0x380a, 0x04},
+		{0x380b, 0x38},
+		{0x380c, 0x02},
+		{0x380d, 0x78},
+		{0x380e, 0x04},
+		{0x380f, 0xa0},
+	},
+	{	/* 720p linear */
+		{0x3800, 0x01},
+		{0x3801, 0x40},
+		{0x3802, 0x00},
+		{0x3803, 0xb8},
+		{0x3804, 0x06},
+		{0x3805, 0x4f},
+		{0x3806, 0x03},
+		{0x3807, 0x8f},
+		{0x3808, 0x05},
+		{0x3809, 0x00},
+		{0x380a, 0x02},
+		{0x380b, 0xd0},
+		{0x380c, 0x02},
+		{0x380d, 0x78},
+		{0x380e, 0x03},
+		{0x380f, 0x16},
+	},
+	{	/* 1080p hdr */
+		{0x3800, 0x00},
+		{0x3801, 0x00},
+		{0x3802, 0x00},
+		{0x3803, 0x04},
+		{0x3804, 0x07},
+		{0x3805, 0x8f},
+		{0x3806, 0x04},
+		{0x3807, 0x43},
+		{0x3808, 0x07},
+		{0x3809, 0x80},
+		{0x380a, 0x04},
+		{0x380b, 0x38},
+		{0x380c, 0x02},
+		{0x380d, 0x78},
+		{0x380e, 0x05},
+		{0x380f, 0xa0},
+	},
+	{	/* 720p hdr */
+		{0x3800, 0x01},
+		{0x3801, 0x40},
+		{0x3802, 0x00},
+		{0x3803, 0xb8},
+		{0x3804, 0x06},
+		{0x3805, 0x4f},
+		{0x3806, 0x03},
+		{0x3807, 0x8f},
+		{0x3808, 0x05},
+		{0x3809, 0x00},
+		{0x380a, 0x02},
+		{0x380b, 0xd0},
+		{0x380c, 0x02},
+		{0x380d, 0x78},
+		{0x380e, 0x05},
+		{0x380f, 0xa0},
+	},
+};
+
+static struct vin_video_format ov2732_formats[] = {
+	{
+		.video_mode = AMBA_VIDEO_MODE_1080P,
+		.def_start_x = 0,
+		.def_start_y = 0,
+		.def_width = 1920,
+		.def_height = 1080,
+		/* sensor mode */
+		.device_mode = 0,
+		.pll_idx = 0,
+		.width = 1920,
+		.height = 1080,
+		.format = AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type = AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits = AMBA_VIDEO_BITS_10,
+		.ratio = AMBA_VIDEO_RATIO_16_9,
+		.max_fps = AMBA_VIDEO_FPS_60,
+		.default_fps = AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern = VINDEV_BAYER_PATTERN_BG,
+	},
+	{
+		.video_mode = AMBA_VIDEO_MODE_720P,
+		.def_start_x = 0,
+		.def_start_y = 0,
+		.def_width = 1280,
+		.def_height = 720,
+		/* sensor mode */
+		.device_mode = 1,
+		.pll_idx = 0,
+		.width = 1280,
+		.height = 720,
+		.format = AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type = AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits = AMBA_VIDEO_BITS_10,
+		.ratio = AMBA_VIDEO_RATIO_16_9,
+		.max_fps = AMBA_VIDEO_FPS(90),
+		.default_fps = AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern = VINDEV_BAYER_PATTERN_BG,
+	},
+	{
+		.video_mode = AMBA_VIDEO_MODE_1080P,
+		.def_start_x	= 0,
+		.def_start_y	= 0,
+		.def_width	= 1920,
+		.def_height	= (1080 + (S_MAX_EXPO_1080P>>1)) * 2,
+		.act_start_x	= 0,
+		.act_start_y	= 0,
+		.act_width	= 1920,
+		.act_height	= 1080,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_2X_HDR_MODE,
+		.device_mode	= 2,
+		.pll_idx	= 1,
+		.width		= 1920 * 2,
+		.height		= 1080 + S_MAX_EXPO_1080P,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_10,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_25,
+		.default_fps	= AMBA_VIDEO_FPS_25,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_30,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_BG,
+		.hdr_long_offset = 0,
+		.hdr_short1_offset = (S_MAX_EXPO_1080P>>1) * 2 + 1, /* 2 x S_MAX_EXPO + 1 */
+	},
+	{
+		.video_mode = AMBA_VIDEO_MODE_720P,
+		.def_start_x	= 0,
+		.def_start_y	= 0,
+		.def_width	= 1280,
+		.def_height	= (720 + (S_MAX_EXPO_720P>>1)) * 2,
+		.act_start_x	= 0,
+		.act_start_y	= 0,
+		.act_width	= 1280,
+		.act_height	= 720,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_2X_HDR_MODE,
+		.device_mode	= 3,
+		.pll_idx	= 1,
+		.width		= 1280 * 2,
+		.height		= 720 + S_MAX_EXPO_1080P,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_10,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_30,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_BG,
+		.hdr_long_offset = 0,
+		.hdr_short1_offset = (S_MAX_EXPO_720P>>1) * 2 + 1, /* 2 x S_MAX_EXPO + 1 */
+	},
+};
+
+static struct vin_reg_16_8 ov2732_linear_mode_regs[] = {
+	{0x0103, 0x01},
+	{0x0305, 0x3c},
+	{0x0307, 0x00},
+	{0x0308, 0x03},
+	{0x0309, 0x03},
+	{0x0327, 0x07},
+	{0x3016, 0x32},
+	{0x3000, 0x00},
+	{0x3001, 0x00},
+	{0x3002, 0x00},
+	{0x3013, 0x00},
+	{0x301f, 0xf0},
+	{0x3023, 0xf0},
+	{0x3020, 0x9b},
+	{0x3022, 0x51},
+	{0x3106, 0x11},
+	{0x3107, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x40},
+	{0x3502, 0x00},
+	{0x3503, 0x88},
+	{0x3505, 0x83},
+	{0x3508, 0x01},
+	{0x3509, 0x80},
+	{0x350a, 0x04},
+	{0x350b, 0x00},
+	{0x350c, 0x00},
+	{0x350d, 0x80},
+	{0x350e, 0x04},
+	{0x350f, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x00},
+	{0x3512, 0x20},
+	{0x3600, 0x55},
+	{0x3601, 0x54},
+	{0x3612, 0xb5},
+	{0x3613, 0xb3},
+	{0x3616, 0x83},
+	{0x3621, 0x00},
+	{0x3624, 0x06},
+	{0x3642, 0x88},
+	{0x3660, 0x00},
+	{0x3661, 0x00},
+	{0x366a, 0x64},
+	{0x366c, 0x00},
+	{0x366e, 0x44},
+	{0x366f, 0x4f},
+	{0x3677, 0x11},
+	{0x3678, 0x11},
+	{0x3680, 0xff},
+	{0x3681, 0xd2},
+	{0x3682, 0xa9},
+	{0x3683, 0x91},
+	{0x3684, 0x8a},
+	{0x3620, 0x80},
+	{0x3662, 0x10},
+	{0x3663, 0x24},
+	{0x3665, 0xa0},
+	{0x3667, 0xa6},
+	{0x3674, 0x01},
+	{0x373d, 0x24},
+	{0x3741, 0x28},
+	{0x3743, 0x28},
+	{0x3745, 0x28},
+	{0x3747, 0x28},
+	{0x3748, 0x00},
+	{0x3749, 0x78},
+	{0x374a, 0x00},
+	{0x374b, 0x78},
+	{0x374c, 0x00},
+	{0x374d, 0x78},
+	{0x374e, 0x00},
+	{0x374f, 0x78},
+	{0x3766, 0x12},
+	{0x37e0, 0x00},
+	{0x37e6, 0x04},
+	{0x37e5, 0x04},
+	{0x37e1, 0x04},
+	{0x3737, 0x04},
+	{0x37d0, 0x0a},
+	{0x37d8, 0x04},
+	{0x37e2, 0x08},
+	{0x3739, 0x10},
+	{0x37e4, 0x18},
+	{0x37e3, 0x04},
+	{0x37d9, 0x10},
+	{0x4040, 0x04},
+	{0x4041, 0x0f},
+	{0x4008, 0x00},
+	{0x4009, 0x0d},
+	{0x37a1, 0x14},
+	{0x37a8, 0x16},
+	{0x37ab, 0x10},
+	{0x37c2, 0x04},
+	{0x3705, 0x00},
+	{0x3706, 0x28},
+	{0x370a, 0x00},
+	{0x370b, 0x78},
+	{0x3714, 0x24},
+	{0x371a, 0x1e},
+	{0x372a, 0x03},
+	{0x3756, 0x00},
+	{0x3757, 0x0e},
+	{0x377b, 0x00},
+	{0x377c, 0x0c},
+	{0x377d, 0x20},
+	{0x3790, 0x28},
+	{0x3791, 0x78},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x04},
+	{0x3804, 0x07},
+	{0x3805, 0x8f},
+	{0x3806, 0x04},
+	{0x3807, 0x43},
+	{0x3808, 0x07},
+	{0x3809, 0x80},
+	{0x380a, 0x04},
+	{0x380b, 0x38},
+	{0x380c, 0x02},
+	{0x380d, 0x78},
+	{0x380e, 0x04},
+	{0x380f, 0xa0},
+	{0x3811, 0x08},
+	{0x3813, 0x04},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x01},
+	{0x3817, 0x01},
+	{0x381d, 0x40},
+	{0x381e, 0x02},
+	{0x3820, 0x88},
+	{0x3821, 0x00},
+	{0x3822, 0x04},
+	{0x3835, 0x00},
+	{0x4303, 0x19},
+	{0x4304, 0x19},
+	{0x4305, 0x03},
+	{0x4306, 0x81},
+	{0x4503, 0x00},
+	{0x4508, 0x14},
+	{0x450a, 0x00},
+	{0x450b, 0x40},
+	{0x4833, 0x08},
+	{0x5000, 0xa9},
+	{0x5001, 0x09},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3c80, 0x08},
+	{0x3c82, 0x00},
+	{0x3c83, 0xb1},
+	{0x3c87, 0x08},
+	{0x3c8c, 0x10},
+	{0x3c8d, 0x00},
+	{0x3c90, 0x00},
+	{0x3c91, 0x00},
+	{0x3c92, 0x00},
+	{0x3c93, 0x00},
+	{0x3c94, 0x00},
+	{0x3c95, 0x00},
+	{0x3c96, 0x00},
+	{0x3c97, 0x00},
+	{0x3c98, 0x00},
+	{0x4000, 0xf3},
+	{0x4001, 0x60},
+	{0x4002, 0x00},
+	{0x4003, 0x40},
+	{0x4090, 0x14},
+	{0x4601, 0x10},
+	{0x4701, 0x00},
+	{0x4708, 0x09},
+	{0x470a, 0x00},
+	{0x470b, 0x40},
+	{0x470c, 0x81},
+	{0x480c, 0x12},
+	{0x4710, 0x06},
+	{0x4711, 0x00},
+	{0x4837, 0x12},
+	{0x4800, 0x00},
+	{0x4c01, 0x00},
+	{0x5036, 0x00},
+	{0x5037, 0x00},
+	{0x580b, 0x0f},
+	{0x4903, 0x80},
+	{0x4003, 0x40},
+	{0x5000, 0xf9},
+	{0x5200, 0x1b},
+	{0x4837, 0x16},
+	{0x3500, 0x00},
+	{0x3501, 0x49},
+	{0x3502, 0x80},
+	{0x3508, 0x02},
+	{0x3509, 0x80},
+	{0x3d8c, 0x11},
+	{0x3d8d, 0xf0},
+	{0x5180, 0x00},
+	{0x5181, 0x10},
+	{0x36a0, 0x16},
+	{0x36a1, 0x50},
+	{0x36a2, 0x60},
+	{0x36a3, 0x80},
+	{0x36a4, 0x00},
+	{0x36a5, 0xa0},
+	{0x36a6, 0x00},
+	{0x36a7, 0x50},
+	{0x36a8, 0x00},
+	{0x36a9, 0x50},
+	{0x36aa, 0x00},
+	{0x36ab, 0x50},
+	{0x36ac, 0x00},
+	{0x36ad, 0x50},
+	{0x36ae, 0x00},
+	{0x36af, 0x50},
+	{0x36b0, 0x00},
+	{0x36b1, 0x50},
+	{0x36b2, 0x00},
+	{0x36b3, 0x50},
+	{0x36b4, 0x00},
+	{0x36b5, 0x50},
+	{0x36b9, 0xee},
+	{0x36ba, 0xee},
+	{0x36bb, 0xee},
+	{0x36bc, 0xee},
+	{0x36bd, 0x0e},
+	{0x36b6, 0x08},
+	{0x36b7, 0x08},
+	{0x36b8, 0x10},
+	{0x0100, 0x01},
+};
+
+static struct vin_reg_16_8 ov2732_hdr_mode_regs[] = {
+	{0x0103, 0x01},
+	{0x0305, 0x3c},
+	{0x0307, 0x00},
+	{0x0308, 0x03},
+	{0x0309, 0x03},
+	{0x0327, 0x07},
+	{0x3016, 0x32},
+	{0x3000, 0x00},
+	{0x3001, 0x00},
+	{0x3002, 0x00},
+	{0x3013, 0x00},
+	{0x301f, 0xf0},
+	{0x3023, 0xf0},
+	{0x3020, 0x9b},
+	{0x3022, 0x51},
+	{0x3106, 0x11},
+	{0x3107, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x40},
+	{0x3502, 0x00},
+	{0x3503, 0x88},
+	{0x3505, 0x83},
+	{0x3508, 0x01},
+	{0x3509, 0x80},
+	{0x350a, 0x04},
+	{0x350b, 0x00},
+	{0x350c, 0x00},
+	{0x350d, 0x80},
+	{0x350e, 0x04},
+	{0x350f, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x00},
+	{0x3512, 0x20},
+	{0x3600, 0x55},
+	{0x3601, 0x54},
+	{0x3612, 0xb5},
+	{0x3613, 0xb3},
+	{0x3616, 0x83},
+	{0x3621, 0x00},
+	{0x3624, 0x06},
+	{0x3642, 0x88},
+	{0x3660, 0x00},
+	{0x3661, 0x00},
+	{0x366a, 0x64},
+	{0x366c, 0x00},
+	{0x366e, 0x44},
+	{0x366f, 0x4f},
+	{0x3677, 0x11},
+	{0x3678, 0x11},
+	{0x3680, 0xff},
+	{0x3681, 0xd2},
+	{0x3682, 0xa9},
+	{0x3683, 0x91},
+	{0x3684, 0x8a},
+	{0x3620, 0x80},
+	{0x3662, 0x10},
+	{0x3663, 0x24},
+	{0x3665, 0xa0},
+	{0x3667, 0xa6},
+	{0x3674, 0x01},
+	{0x373d, 0x24},
+	{0x3741, 0x28},
+	{0x3743, 0x28},
+	{0x3745, 0x28},
+	{0x3747, 0x28},
+	{0x3748, 0x00},
+	{0x3749, 0x78},
+	{0x374a, 0x00},
+	{0x374b, 0x78},
+	{0x374c, 0x00},
+	{0x374d, 0x78},
+	{0x374e, 0x00},
+	{0x374f, 0x78},
+	{0x3766, 0x12},
+	{0x37e0, 0x00},
+	{0x37e6, 0x04},
+	{0x37e5, 0x04},
+	{0x37e1, 0x04},
+	{0x3737, 0x04},
+	{0x37d0, 0x0a},
+	{0x37d8, 0x04},
+	{0x37e2, 0x08},
+	{0x3739, 0x10},
+	{0x37e4, 0x18},
+	{0x37e3, 0x04},
+	{0x37d9, 0x10},
+	{0x4040, 0x04},
+	{0x4041, 0x0f},
+	{0x4008, 0x00},
+	{0x4009, 0x0d},
+	{0x37a1, 0x14},
+	{0x37a8, 0x16},
+	{0x37ab, 0x10},
+	{0x37c2, 0x04},
+	{0x3705, 0x00},
+	{0x3706, 0x28},
+	{0x370a, 0x00},
+	{0x370b, 0x78},
+	{0x3714, 0x24},
+	{0x371a, 0x1e},
+	{0x372a, 0x03},
+	{0x3756, 0x00},
+	{0x3757, 0x0e},
+	{0x377b, 0x00},
+	{0x377c, 0x0c},
+	{0x377d, 0x20},
+	{0x3790, 0x28},
+	{0x3791, 0x78},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x04},
+	{0x3804, 0x07},
+	{0x3805, 0x8f},
+	{0x3806, 0x04},
+	{0x3807, 0x43},
+	{0x3808, 0x07},
+	{0x3809, 0x80},
+	{0x380a, 0x04},
+	{0x380b, 0x38},
+	{0x380c, 0x02},
+	{0x380d, 0x78},
+	{0x380e, 0x04},
+	{0x380f, 0xa0},
+	{0x3811, 0x08},
+	{0x3813, 0x04},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x01},
+	{0x3817, 0x01},
+	{0x381d, 0x40},
+	{0x381e, 0x02},
+	{0x3820, 0x88},
+	{0x3821, 0x00},
+	{0x3822, 0x04},
+	{0x3835, 0x00},
+	{0x4303, 0x19},
+	{0x4304, 0x19},
+	{0x4305, 0x03},
+	{0x4306, 0x81},
+	{0x4503, 0x00},
+	{0x4508, 0x14},
+	{0x450a, 0x00},
+	{0x450b, 0x40},
+	{0x4833, 0x08},
+	{0x5000, 0xa9},
+	{0x5001, 0x09},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3c80, 0x08},
+	{0x3c82, 0x00},
+	{0x3c83, 0xb1},
+	{0x3c87, 0x08},
+	{0x3c8c, 0x10},
+	{0x3c8d, 0x00},
+	{0x3c90, 0x00},
+	{0x3c91, 0x00},
+	{0x3c92, 0x00},
+	{0x3c93, 0x00},
+	{0x3c94, 0x00},
+	{0x3c95, 0x00},
+	{0x3c96, 0x00},
+	{0x3c97, 0x00},
+	{0x3c98, 0x00},
+	{0x4000, 0xf3},
+	{0x4001, 0x60},
+	{0x4002, 0x00},
+	{0x4003, 0x40},
+	{0x4090, 0x14},
+	{0x4601, 0x10},
+	{0x4701, 0x00},
+	{0x4708, 0x09},
+	{0x470a, 0x00},
+	{0x470b, 0x40},
+	{0x470c, 0x81},
+	{0x480c, 0x12},
+	{0x4710, 0x06},
+	{0x4711, 0x00},
+	{0x4837, 0x12},
+	{0x4800, 0x00},
+	{0x4c01, 0x00},
+	{0x5036, 0x00},
+	{0x5037, 0x00},
+	{0x580b, 0x0f},
+	{0x4903, 0x80},
+	{0x4003, 0x40},
+	{0x5000, 0xf9},
+	{0x5200, 0x1b},
+	{0x4837, 0x16},
+	{0x380e, 0x04},
+	{0x380f, 0xa0},
+	{0x3500, 0x00},
+	{0x3501, 0x49},
+	{0x3502, 0x80},
+	{0x3508, 0x02},
+	{0x3509, 0x80},
+	{0x3d8c, 0x11},
+	{0x3d8d, 0xf0},
+	{0x5180, 0x00},
+	{0x5181, 0x10},
+	{0x36a0, 0x16},
+	{0x36a1, 0x50},
+	{0x36a2, 0x60},
+	{0x36a3, 0x80},
+	{0x36a4, 0x00},
+	{0x36a5, 0xa0},
+	{0x36a6, 0x00},
+	{0x36a7, 0x50},
+	{0x36a8, 0x00},
+	{0x36a9, 0x50},
+	{0x36aa, 0x00},
+	{0x36ab, 0x50},
+	{0x36ac, 0x00},
+	{0x36ad, 0x50},
+	{0x36ae, 0x00},
+	{0x36af, 0x50},
+	{0x36b0, 0x00},
+	{0x36b1, 0x50},
+	{0x36b2, 0x00},
+	{0x36b3, 0x50},
+	{0x36b4, 0x00},
+	{0x36b5, 0x50},
+	{0x36b9, 0xee},
+	{0x36ba, 0xee},
+	{0x36bb, 0xee},
+	{0x36bc, 0xee},
+	{0x36bd, 0x0e},
+	{0x36b6, 0x08},
+	{0x36b7, 0x08},
+	{0x36b8, 0x10},
+	{0x3508, 0x03},
+	{0x3509, 0xaa},
+	{0x350c, 0x01},
+	{0x350d, 0x55},
+	{0x3511, 0x0f},
+	{0x3512, 0xc0},
+	{0x366c, 0x30},
+	{0x372a, 0x83},
+	{0x3757, 0x00},
+	{0x377b, 0xa8},
+	{0x377c, 0x02},
+	{0x377d, 0x00},
+	{0x380e, 0x05},
+	{0x3821, 0x04},
+	{0x4305, 0x1b},
+	{0x4306, 0x80},
+	{0x5036, 0x80},
+	{0x5037, 0x01},
+	{0x4903, 0x81},
+	{0x0100, 0x01},
+};
+
+#ifdef CONFIG_PM
+static struct vin_reg_16_8 pm_regs[] = {
+	{OV2732_L_EXPO_HSB, 0x00},
+	{OV2732_L_EXPO_MSB, 0x00},
+	{OV2732_L_EXPO_LSB, 0x00},
+	{OV2732_S_EXPO_HSB, 0x00},
+	{OV2732_S_EXPO_MSB, 0x00},
+	{OV2732_S_EXPO_LSB, 0x00},
+	{OV2732_L_AGAIN_MSB, 0x00},
+	{OV2732_L_AGAIN_LSB, 0x00},
+	{OV2732_L_DGAIN_MSB, 0x00},
+	{OV2732_L_DGAIN_LSB, 0x00},
+	{OV2732_S_AGAIN_MSB, 0x00},
+	{OV2732_S_AGAIN_LSB, 0x00},
+	{OV2732_S_DGAIN_MSB, 0x00},
+	{OV2732_S_DGAIN_LSB, 0x00},
+};
+#endif
+
+/* Gain table */
+#define OV2732_GAIN_ROWS               (513)
+#define OV2732_GAIN_COLS               (2)
+#define OV2732_GAIN_MAXDB              (512)
+
+#define OV2732_GAIN_COL_AGAIN          (0)
+#define OV2732_GAIN_COL_DGAIN          (1)
+
+static const u16 OV2732_GAIN_TABLE[OV2732_GAIN_ROWS][OV2732_GAIN_COLS] = {
+	{0x0080, 0x0400}, /* index:0, gain:0.00000db -> x1.000000, again:x1.000000, dgain:x1.000000 */
+	{0x0081, 0x0400}, /* index:1, gain:0.09375db -> x1.010852, again:x1.010852, dgain:x1.000000 */
+	{0x0082, 0x0400}, /* index:2, gain:0.18750db -> x1.021821, again:x1.021821, dgain:x1.000000 */
+	{0x0084, 0x0400}, /* index:3, gain:0.28125db -> x1.032910, again:x1.032910, dgain:x1.000000 */
+	{0x0085, 0x0400}, /* index:4, gain:0.37500db -> x1.044119, again:x1.044119, dgain:x1.000000 */
+	{0x0087, 0x0400}, /* index:5, gain:0.46875db -> x1.055450, again:x1.055450, dgain:x1.000000 */
+	{0x0088, 0x0400}, /* index:6, gain:0.56250db -> x1.066903, again:x1.066903, dgain:x1.000000 */
+	{0x008a, 0x0400}, /* index:7, gain:0.65625db -> x1.078481, again:x1.078481, dgain:x1.000000 */
+	{0x008b, 0x0400}, /* index:8, gain:0.75000db -> x1.090184, again:x1.090184, dgain:x1.000000 */
+	{0x008d, 0x0400}, /* index:9, gain:0.84375db -> x1.102015, again:x1.102015, dgain:x1.000000 */
+	{0x008e, 0x0400}, /* index:10, gain:0.93750db -> x1.113974, again:x1.113974, dgain:x1.000000 */
+	{0x0090, 0x0400}, /* index:11, gain:1.03125db -> x1.126063, again:x1.126063, dgain:x1.000000 */
+	{0x0091, 0x0400}, /* index:12, gain:1.12500db -> x1.138282, again:x1.138282, dgain:x1.000000 */
+	{0x0093, 0x0400}, /* index:13, gain:1.21875db -> x1.150635, again:x1.150635, dgain:x1.000000 */
+	{0x0094, 0x0400}, /* index:14, gain:1.31250db -> x1.163121, again:x1.163121, dgain:x1.000000 */
+	{0x0096, 0x0400}, /* index:15, gain:1.40625db -> x1.175743, again:x1.175743, dgain:x1.000000 */
+	{0x0098, 0x0400}, /* index:16, gain:1.50000db -> x1.188502, again:x1.188502, dgain:x1.000000 */
+	{0x0099, 0x0400}, /* index:17, gain:1.59375db -> x1.201400, again:x1.201400, dgain:x1.000000 */
+	{0x009b, 0x0400}, /* index:18, gain:1.68750db -> x1.214437, again:x1.214437, dgain:x1.000000 */
+	{0x009d, 0x0400}, /* index:19, gain:1.78125db -> x1.227616, again:x1.227616, dgain:x1.000000 */
+	{0x009e, 0x0400}, /* index:20, gain:1.87500db -> x1.240938, again:x1.240938, dgain:x1.000000 */
+	{0x00a0, 0x0400}, /* index:21, gain:1.96875db -> x1.254404, again:x1.254404, dgain:x1.000000 */
+	{0x00a2, 0x0400}, /* index:22, gain:2.06250db -> x1.268017, again:x1.268017, dgain:x1.000000 */
+	{0x00a4, 0x0400}, /* index:23, gain:2.15625db -> x1.281777, again:x1.281777, dgain:x1.000000 */
+	{0x00a5, 0x0400}, /* index:24, gain:2.25000db -> x1.295687, again:x1.295687, dgain:x1.000000 */
+	{0x00a7, 0x0400}, /* index:25, gain:2.34375db -> x1.309747, again:x1.309747, dgain:x1.000000 */
+	{0x00a9, 0x0400}, /* index:26, gain:2.43750db -> x1.323960, again:x1.323960, dgain:x1.000000 */
+	{0x00ab, 0x0400}, /* index:27, gain:2.53125db -> x1.338328, again:x1.338328, dgain:x1.000000 */
+	{0x00ad, 0x0400}, /* index:28, gain:2.62500db -> x1.352851, again:x1.352851, dgain:x1.000000 */
+	{0x00af, 0x0400}, /* index:29, gain:2.71875db -> x1.367532, again:x1.367532, dgain:x1.000000 */
+	{0x00b0, 0x0400}, /* index:30, gain:2.81250db -> x1.382372, again:x1.382372, dgain:x1.000000 */
+	{0x00b2, 0x0400}, /* index:31, gain:2.90625db -> x1.397374, again:x1.397374, dgain:x1.000000 */
+	{0x00b4, 0x0400}, /* index:32, gain:3.00000db -> x1.412538, again:x1.412538, dgain:x1.000000 */
+	{0x00b6, 0x0400}, /* index:33, gain:3.09375db -> x1.427866, again:x1.427866, dgain:x1.000000 */
+	{0x00b8, 0x0400}, /* index:34, gain:3.18750db -> x1.443361, again:x1.443361, dgain:x1.000000 */
+	{0x00ba, 0x0400}, /* index:35, gain:3.28125db -> x1.459024, again:x1.459024, dgain:x1.000000 */
+	{0x00bc, 0x0400}, /* index:36, gain:3.37500db -> x1.474857, again:x1.474857, dgain:x1.000000 */
+	{0x00be, 0x0400}, /* index:37, gain:3.46875db -> x1.490862, again:x1.490862, dgain:x1.000000 */
+	{0x00c0, 0x0400}, /* index:38, gain:3.56250db -> x1.507041, again:x1.507041, dgain:x1.000000 */
+	{0x00c2, 0x0400}, /* index:39, gain:3.65625db -> x1.523395, again:x1.523395, dgain:x1.000000 */
+	{0x00c5, 0x0400}, /* index:40, gain:3.75000db -> x1.539927, again:x1.539927, dgain:x1.000000 */
+	{0x00c7, 0x0400}, /* index:41, gain:3.84375db -> x1.556638, again:x1.556638, dgain:x1.000000 */
+	{0x00c9, 0x0400}, /* index:42, gain:3.93750db -> x1.573530, again:x1.573530, dgain:x1.000000 */
+	{0x00cb, 0x0400}, /* index:43, gain:4.03125db -> x1.590606, again:x1.590606, dgain:x1.000000 */
+	{0x00cd, 0x0400}, /* index:44, gain:4.12500db -> x1.607867, again:x1.607867, dgain:x1.000000 */
+	{0x00d0, 0x0400}, /* index:45, gain:4.21875db -> x1.625315, again:x1.625315, dgain:x1.000000 */
+	{0x00d2, 0x0400}, /* index:46, gain:4.31250db -> x1.642952, again:x1.642952, dgain:x1.000000 */
+	{0x00d4, 0x0400}, /* index:47, gain:4.40625db -> x1.660782, again:x1.660782, dgain:x1.000000 */
+	{0x00d6, 0x0400}, /* index:48, gain:4.50000db -> x1.678804, again:x1.678804, dgain:x1.000000 */
+	{0x00d9, 0x0400}, /* index:49, gain:4.59375db -> x1.697022, again:x1.697022, dgain:x1.000000 */
+	{0x00db, 0x0400}, /* index:50, gain:4.68750db -> x1.715438, again:x1.715438, dgain:x1.000000 */
+	{0x00dd, 0x0400}, /* index:51, gain:4.78125db -> x1.734054, again:x1.734054, dgain:x1.000000 */
+	{0x00e0, 0x0400}, /* index:52, gain:4.87500db -> x1.752871, again:x1.752871, dgain:x1.000000 */
+	{0x00e2, 0x0400}, /* index:53, gain:4.96875db -> x1.771893, again:x1.771893, dgain:x1.000000 */
+	{0x00e5, 0x0400}, /* index:54, gain:5.06250db -> x1.791121, again:x1.791121, dgain:x1.000000 */
+	{0x00e7, 0x0400}, /* index:55, gain:5.15625db -> x1.810558, again:x1.810558, dgain:x1.000000 */
+	{0x00ea, 0x0400}, /* index:56, gain:5.25000db -> x1.830206, again:x1.830206, dgain:x1.000000 */
+	{0x00ec, 0x0400}, /* index:57, gain:5.34375db -> x1.850067, again:x1.850067, dgain:x1.000000 */
+	{0x00ef, 0x0400}, /* index:58, gain:5.43750db -> x1.870144, again:x1.870144, dgain:x1.000000 */
+	{0x00f1, 0x0400}, /* index:59, gain:5.53125db -> x1.890438, again:x1.890438, dgain:x1.000000 */
+	{0x00f4, 0x0400}, /* index:60, gain:5.62500db -> x1.910953, again:x1.910953, dgain:x1.000000 */
+	{0x00f7, 0x0400}, /* index:61, gain:5.71875db -> x1.931690, again:x1.931690, dgain:x1.000000 */
+	{0x00f9, 0x0400}, /* index:62, gain:5.81250db -> x1.952653, again:x1.952653, dgain:x1.000000 */
+	{0x00fc, 0x0400}, /* index:63, gain:5.90625db -> x1.973842, again:x1.973842, dgain:x1.000000 */
+	{0x00ff, 0x0400}, /* index:64, gain:6.00000db -> x1.995262, again:x1.995262, dgain:x1.000000 */
+	{0x0102, 0x0400}, /* index:65, gain:6.09375db -> x2.016915, again:x2.016915, dgain:x1.000000 */
+	{0x0104, 0x0400}, /* index:66, gain:6.18750db -> x2.038802, again:x2.038802, dgain:x1.000000 */
+	{0x0107, 0x0400}, /* index:67, gain:6.28125db -> x2.060927, again:x2.060927, dgain:x1.000000 */
+	{0x010a, 0x0400}, /* index:68, gain:6.37500db -> x2.083291, again:x2.083291, dgain:x1.000000 */
+	{0x010d, 0x0400}, /* index:69, gain:6.46875db -> x2.105899, again:x2.105899, dgain:x1.000000 */
+	{0x0110, 0x0400}, /* index:70, gain:6.56250db -> x2.128752, again:x2.128752, dgain:x1.000000 */
+	{0x0113, 0x0400}, /* index:71, gain:6.65625db -> x2.151852, again:x2.151852, dgain:x1.000000 */
+	{0x0116, 0x0400}, /* index:72, gain:6.75000db -> x2.175204, again:x2.175204, dgain:x1.000000 */
+	{0x0119, 0x0400}, /* index:73, gain:6.84375db -> x2.198809, again:x2.198809, dgain:x1.000000 */
+	{0x011c, 0x0400}, /* index:74, gain:6.93750db -> x2.222670, again:x2.222670, dgain:x1.000000 */
+	{0x011f, 0x0400}, /* index:75, gain:7.03125db -> x2.246790, again:x2.246790, dgain:x1.000000 */
+	{0x0122, 0x0400}, /* index:76, gain:7.12500db -> x2.271172, again:x2.271172, dgain:x1.000000 */
+	{0x0125, 0x0400}, /* index:77, gain:7.21875db -> x2.295818, again:x2.295818, dgain:x1.000000 */
+	{0x0129, 0x0400}, /* index:78, gain:7.31250db -> x2.320732, again:x2.320732, dgain:x1.000000 */
+	{0x012c, 0x0400}, /* index:79, gain:7.40625db -> x2.345916, again:x2.345916, dgain:x1.000000 */
+	{0x012f, 0x0400}, /* index:80, gain:7.50000db -> x2.371374, again:x2.371374, dgain:x1.000000 */
+	{0x0132, 0x0400}, /* index:81, gain:7.59375db -> x2.397107, again:x2.397107, dgain:x1.000000 */
+	{0x0136, 0x0400}, /* index:82, gain:7.68750db -> x2.423120, again:x2.423120, dgain:x1.000000 */
+	{0x0139, 0x0400}, /* index:83, gain:7.78125db -> x2.449416, again:x2.449416, dgain:x1.000000 */
+	{0x013c, 0x0400}, /* index:84, gain:7.87500db -> x2.475996, again:x2.475996, dgain:x1.000000 */
+	{0x0140, 0x0400}, /* index:85, gain:7.96875db -> x2.502865, again:x2.502865, dgain:x1.000000 */
+	{0x0143, 0x0400}, /* index:86, gain:8.06250db -> x2.530026, again:x2.530026, dgain:x1.000000 */
+	{0x0147, 0x0400}, /* index:87, gain:8.15625db -> x2.557482, again:x2.557482, dgain:x1.000000 */
+	{0x014a, 0x0400}, /* index:88, gain:8.25000db -> x2.585235, again:x2.585235, dgain:x1.000000 */
+	{0x014e, 0x0400}, /* index:89, gain:8.34375db -> x2.613289, again:x2.613289, dgain:x1.000000 */
+	{0x0152, 0x0400}, /* index:90, gain:8.43750db -> x2.641648, again:x2.641648, dgain:x1.000000 */
+	{0x0155, 0x0400}, /* index:91, gain:8.53125db -> x2.670315, again:x2.670315, dgain:x1.000000 */
+	{0x0159, 0x0400}, /* index:92, gain:8.62500db -> x2.699293, again:x2.699293, dgain:x1.000000 */
+	{0x015d, 0x0400}, /* index:93, gain:8.71875db -> x2.728585, again:x2.728585, dgain:x1.000000 */
+	{0x0161, 0x0400}, /* index:94, gain:8.81250db -> x2.758195, again:x2.758195, dgain:x1.000000 */
+	{0x0164, 0x0400}, /* index:95, gain:8.90625db -> x2.788127, again:x2.788127, dgain:x1.000000 */
+	{0x0168, 0x0400}, /* index:96, gain:9.00000db -> x2.818383, again:x2.818383, dgain:x1.000000 */
+	{0x016c, 0x0400}, /* index:97, gain:9.09375db -> x2.848968, again:x2.848968, dgain:x1.000000 */
+	{0x0170, 0x0400}, /* index:98, gain:9.18750db -> x2.879884, again:x2.879884, dgain:x1.000000 */
+	{0x0174, 0x0400}, /* index:99, gain:9.28125db -> x2.911136, again:x2.911136, dgain:x1.000000 */
+	{0x0178, 0x0400}, /* index:100, gain:9.37500db -> x2.942727, again:x2.942727, dgain:x1.000000 */
+	{0x017c, 0x0400}, /* index:101, gain:9.46875db -> x2.974661, again:x2.974661, dgain:x1.000000 */
+	{0x0180, 0x0400}, /* index:102, gain:9.56250db -> x3.006942, again:x3.006942, dgain:x1.000000 */
+	{0x0185, 0x0400}, /* index:103, gain:9.65625db -> x3.039572, again:x3.039572, dgain:x1.000000 */
+	{0x0189, 0x0400}, /* index:104, gain:9.75000db -> x3.072557, again:x3.072557, dgain:x1.000000 */
+	{0x018d, 0x0400}, /* index:105, gain:9.84375db -> x3.105900, again:x3.105900, dgain:x1.000000 */
+	{0x0191, 0x0400}, /* index:106, gain:9.93750db -> x3.139605, again:x3.139605, dgain:x1.000000 */
+	{0x0196, 0x0400}, /* index:107, gain:10.03125db -> x3.173675, again:x3.173675, dgain:x1.000000 */
+	{0x019a, 0x0400}, /* index:108, gain:10.12500db -> x3.208116, again:x3.208116, dgain:x1.000000 */
+	{0x019f, 0x0400}, /* index:109, gain:10.21875db -> x3.242930, again:x3.242930, dgain:x1.000000 */
+	{0x01a3, 0x0400}, /* index:110, gain:10.31250db -> x3.278121, again:x3.278121, dgain:x1.000000 */
+	{0x01a8, 0x0400}, /* index:111, gain:10.40625db -> x3.313695, again:x3.313695, dgain:x1.000000 */
+	{0x01ac, 0x0400}, /* index:112, gain:10.50000db -> x3.349654, again:x3.349654, dgain:x1.000000 */
+	{0x01b1, 0x0400}, /* index:113, gain:10.59375db -> x3.386004, again:x3.386004, dgain:x1.000000 */
+	{0x01b6, 0x0400}, /* index:114, gain:10.68750db -> x3.422749, again:x3.422749, dgain:x1.000000 */
+	{0x01ba, 0x0400}, /* index:115, gain:10.78125db -> x3.459892, again:x3.459892, dgain:x1.000000 */
+	{0x01bf, 0x0400}, /* index:116, gain:10.87500db -> x3.497438, again:x3.497438, dgain:x1.000000 */
+	{0x01c4, 0x0400}, /* index:117, gain:10.96875db -> x3.535391, again:x3.535391, dgain:x1.000000 */
+	{0x01c9, 0x0400}, /* index:118, gain:11.06250db -> x3.573757, again:x3.573757, dgain:x1.000000 */
+	{0x01ce, 0x0400}, /* index:119, gain:11.15625db -> x3.612539, again:x3.612539, dgain:x1.000000 */
+	{0x01d3, 0x0400}, /* index:120, gain:11.25000db -> x3.651741, again:x3.651741, dgain:x1.000000 */
+	{0x01d8, 0x0400}, /* index:121, gain:11.34375db -> x3.691369, again:x3.691369, dgain:x1.000000 */
+	{0x01dd, 0x0400}, /* index:122, gain:11.43750db -> x3.731427, again:x3.731427, dgain:x1.000000 */
+	{0x01e2, 0x0400}, /* index:123, gain:11.53125db -> x3.771920, again:x3.771920, dgain:x1.000000 */
+	{0x01e8, 0x0400}, /* index:124, gain:11.62500db -> x3.812853, again:x3.812853, dgain:x1.000000 */
+	{0x01ed, 0x0400}, /* index:125, gain:11.71875db -> x3.854229, again:x3.854229, dgain:x1.000000 */
+	{0x01f2, 0x0400}, /* index:126, gain:11.81250db -> x3.896054, again:x3.896054, dgain:x1.000000 */
+	{0x01f8, 0x0400}, /* index:127, gain:11.90625db -> x3.938333, again:x3.938333, dgain:x1.000000 */
+	{0x01fd, 0x0400}, /* index:128, gain:12.00000db -> x3.981072, again:x3.981072, dgain:x1.000000 */
+	{0x0203, 0x0400}, /* index:129, gain:12.09375db -> x4.024274, again:x4.024274, dgain:x1.000000 */
+	{0x0208, 0x0400}, /* index:130, gain:12.18750db -> x4.067944, again:x4.067944, dgain:x1.000000 */
+	{0x020e, 0x0400}, /* index:131, gain:12.28125db -> x4.112089, again:x4.112089, dgain:x1.000000 */
+	{0x0214, 0x0400}, /* index:132, gain:12.37500db -> x4.156712, again:x4.156712, dgain:x1.000000 */
+	{0x0219, 0x0400}, /* index:133, gain:12.46875db -> x4.201821, again:x4.201821, dgain:x1.000000 */
+	{0x021f, 0x0400}, /* index:134, gain:12.56250db -> x4.247418, again:x4.247418, dgain:x1.000000 */
+	{0x0225, 0x0400}, /* index:135, gain:12.65625db -> x4.293510, again:x4.293510, dgain:x1.000000 */
+	{0x022b, 0x0400}, /* index:136, gain:12.75000db -> x4.340103, again:x4.340103, dgain:x1.000000 */
+	{0x0231, 0x0400}, /* index:137, gain:12.84375db -> x4.387200, again:x4.387200, dgain:x1.000000 */
+	{0x0237, 0x0400}, /* index:138, gain:12.93750db -> x4.434810, again:x4.434810, dgain:x1.000000 */
+	{0x023d, 0x0400}, /* index:139, gain:13.03125db -> x4.482936, again:x4.482936, dgain:x1.000000 */
+	{0x0244, 0x0400}, /* index:140, gain:13.12500db -> x4.531584, again:x4.531584, dgain:x1.000000 */
+	{0x024a, 0x0400}, /* index:141, gain:13.21875db -> x4.580759, again:x4.580759, dgain:x1.000000 */
+	{0x0250, 0x0400}, /* index:142, gain:13.31250db -> x4.630469, again:x4.630469, dgain:x1.000000 */
+	{0x0257, 0x0400}, /* index:143, gain:13.40625db -> x4.680719, again:x4.680719, dgain:x1.000000 */
+	{0x025d, 0x0400}, /* index:144, gain:13.50000db -> x4.731513, again:x4.731513, dgain:x1.000000 */
+	{0x0264, 0x0400}, /* index:145, gain:13.59375db -> x4.782858, again:x4.782858, dgain:x1.000000 */
+	{0x026a, 0x0400}, /* index:146, gain:13.68750db -> x4.834761, again:x4.834761, dgain:x1.000000 */
+	{0x0271, 0x0400}, /* index:147, gain:13.78125db -> x4.887227, again:x4.887227, dgain:x1.000000 */
+	{0x0278, 0x0400}, /* index:148, gain:13.87500db -> x4.940262, again:x4.940262, dgain:x1.000000 */
+	{0x027f, 0x0400}, /* index:149, gain:13.96875db -> x4.993873, again:x4.993873, dgain:x1.000000 */
+	{0x0286, 0x0400}, /* index:150, gain:14.06250db -> x5.048066, again:x5.048066, dgain:x1.000000 */
+	{0x028d, 0x0400}, /* index:151, gain:14.15625db -> x5.102846, again:x5.102846, dgain:x1.000000 */
+	{0x0294, 0x0400}, /* index:152, gain:14.25000db -> x5.158221, again:x5.158221, dgain:x1.000000 */
+	{0x029b, 0x0400}, /* index:153, gain:14.34375db -> x5.214198, again:x5.214198, dgain:x1.000000 */
+	{0x02a2, 0x0400}, /* index:154, gain:14.43750db -> x5.270781, again:x5.270781, dgain:x1.000000 */
+	{0x02a9, 0x0400}, /* index:155, gain:14.53125db -> x5.327979, again:x5.327979, dgain:x1.000000 */
+	{0x02b1, 0x0400}, /* index:156, gain:14.62500db -> x5.385797, again:x5.385797, dgain:x1.000000 */
+	{0x02b8, 0x0400}, /* index:157, gain:14.71875db -> x5.444243, again:x5.444243, dgain:x1.000000 */
+	{0x02c0, 0x0400}, /* index:158, gain:14.81250db -> x5.503323, again:x5.503323, dgain:x1.000000 */
+	{0x02c8, 0x0400}, /* index:159, gain:14.90625db -> x5.563044, again:x5.563044, dgain:x1.000000 */
+	{0x02cf, 0x0400}, /* index:160, gain:15.00000db -> x5.623413, again:x5.623413, dgain:x1.000000 */
+	{0x02d7, 0x0400}, /* index:161, gain:15.09375db -> x5.684437, again:x5.684437, dgain:x1.000000 */
+	{0x02df, 0x0400}, /* index:162, gain:15.18750db -> x5.746124, again:x5.746124, dgain:x1.000000 */
+	{0x02e7, 0x0400}, /* index:163, gain:15.28125db -> x5.808480, again:x5.808480, dgain:x1.000000 */
+	{0x02ef, 0x0400}, /* index:164, gain:15.37500db -> x5.871513, again:x5.871513, dgain:x1.000000 */
+	{0x02f7, 0x0400}, /* index:165, gain:15.46875db -> x5.935229, again:x5.935229, dgain:x1.000000 */
+	{0x02ff, 0x0400}, /* index:166, gain:15.56250db -> x5.999637, again:x5.999637, dgain:x1.000000 */
+	{0x0308, 0x0400}, /* index:167, gain:15.65625db -> x6.064744, again:x6.064744, dgain:x1.000000 */
+	{0x0310, 0x0400}, /* index:168, gain:15.75000db -> x6.130558, again:x6.130558, dgain:x1.000000 */
+	{0x0319, 0x0400}, /* index:169, gain:15.84375db -> x6.197086, again:x6.197086, dgain:x1.000000 */
+	{0x0321, 0x0400}, /* index:170, gain:15.93750db -> x6.264335, again:x6.264335, dgain:x1.000000 */
+	{0x032a, 0x0400}, /* index:171, gain:16.03125db -> x6.332315, again:x6.332315, dgain:x1.000000 */
+	{0x0333, 0x0400}, /* index:172, gain:16.12500db -> x6.401032, again:x6.401032, dgain:x1.000000 */
+	{0x033c, 0x0400}, /* index:173, gain:16.21875db -> x6.470495, again:x6.470495, dgain:x1.000000 */
+	{0x0345, 0x0400}, /* index:174, gain:16.31250db -> x6.540712, again:x6.540712, dgain:x1.000000 */
+	{0x034e, 0x0400}, /* index:175, gain:16.40625db -> x6.611690, again:x6.611690, dgain:x1.000000 */
+	{0x0357, 0x0400}, /* index:176, gain:16.50000db -> x6.683439, again:x6.683439, dgain:x1.000000 */
+	{0x0360, 0x0400}, /* index:177, gain:16.59375db -> x6.755966, again:x6.755966, dgain:x1.000000 */
+	{0x036a, 0x0400}, /* index:178, gain:16.68750db -> x6.829282, again:x6.829282, dgain:x1.000000 */
+	{0x0373, 0x0400}, /* index:179, gain:16.78125db -> x6.903392, again:x6.903392, dgain:x1.000000 */
+	{0x037d, 0x0400}, /* index:180, gain:16.87500db -> x6.978306, again:x6.978306, dgain:x1.000000 */
+	{0x0386, 0x0400}, /* index:181, gain:16.96875db -> x7.054033, again:x7.054033, dgain:x1.000000 */
+	{0x0390, 0x0400}, /* index:182, gain:17.06250db -> x7.130582, again:x7.130582, dgain:x1.000000 */
+	{0x039a, 0x0400}, /* index:183, gain:17.15625db -> x7.207963, again:x7.207963, dgain:x1.000000 */
+	{0x03a4, 0x0400}, /* index:184, gain:17.25000db -> x7.286182, again:x7.286182, dgain:x1.000000 */
+	{0x03ae, 0x0400}, /* index:185, gain:17.34375db -> x7.365250, again:x7.365250, dgain:x1.000000 */
+	{0x03b8, 0x0400}, /* index:186, gain:17.43750db -> x7.445176, again:x7.445176, dgain:x1.000000 */
+	{0x03c3, 0x0400}, /* index:187, gain:17.53125db -> x7.525970, again:x7.525970, dgain:x1.000000 */
+	{0x03cd, 0x0400}, /* index:188, gain:17.62500db -> x7.607641, again:x7.607641, dgain:x1.000000 */
+	{0x03d8, 0x0400}, /* index:189, gain:17.71875db -> x7.690198, again:x7.690198, dgain:x1.000000 */
+	{0x03e3, 0x0400}, /* index:190, gain:17.81250db -> x7.773650, again:x7.773650, dgain:x1.000000 */
+	{0x03ed, 0x0400}, /* index:191, gain:17.90625db -> x7.858008, again:x7.858008, dgain:x1.000000 */
+	{0x03f8, 0x0400}, /* index:192, gain:18.00000db -> x7.943282, again:x7.943282, dgain:x1.000000 */
+	{0x0403, 0x0400}, /* index:193, gain:18.09375db -> x8.029482, again:x8.029482, dgain:x1.000000 */
+	{0x040e, 0x0400}, /* index:194, gain:18.18750db -> x8.116616, again:x8.116616, dgain:x1.000000 */
+	{0x041a, 0x0400}, /* index:195, gain:18.28125db -> x8.204696, again:x8.204696, dgain:x1.000000 */
+	{0x0425, 0x0400}, /* index:196, gain:18.37500db -> x8.293732, again:x8.293732, dgain:x1.000000 */
+	{0x0431, 0x0400}, /* index:197, gain:18.46875db -> x8.383734, again:x8.383734, dgain:x1.000000 */
+	{0x043c, 0x0400}, /* index:198, gain:18.56250db -> x8.474713, again:x8.474713, dgain:x1.000000 */
+	{0x0448, 0x0400}, /* index:199, gain:18.65625db -> x8.566679, again:x8.566679, dgain:x1.000000 */
+	{0x0454, 0x0400}, /* index:200, gain:18.75000db -> x8.659643, again:x8.659643, dgain:x1.000000 */
+	{0x0460, 0x0400}, /* index:201, gain:18.84375db -> x8.753616, again:x8.753616, dgain:x1.000000 */
+	{0x046c, 0x0400}, /* index:202, gain:18.93750db -> x8.848608, again:x8.848608, dgain:x1.000000 */
+	{0x0478, 0x0400}, /* index:203, gain:19.03125db -> x8.944633, again:x8.944633, dgain:x1.000000 */
+	{0x0485, 0x0400}, /* index:204, gain:19.12500db -> x9.041698, again:x9.041698, dgain:x1.000000 */
+	{0x0491, 0x0400}, /* index:205, gain:19.21875db -> x9.139817, again:x9.139817, dgain:x1.000000 */
+	{0x049e, 0x0400}, /* index:206, gain:19.31250db -> x9.239000, again:x9.239000, dgain:x1.000000 */
+	{0x04ab, 0x0400}, /* index:207, gain:19.40625db -> x9.339260, again:x9.339260, dgain:x1.000000 */
+	{0x04b8, 0x0400}, /* index:208, gain:19.50000db -> x9.440609, again:x9.440609, dgain:x1.000000 */
+	{0x04c5, 0x0400}, /* index:209, gain:19.59375db -> x9.543057, again:x9.543057, dgain:x1.000000 */
+	{0x04d2, 0x0400}, /* index:210, gain:19.68750db -> x9.646616, again:x9.646616, dgain:x1.000000 */
+	{0x04e0, 0x0400}, /* index:211, gain:19.78125db -> x9.751299, again:x9.751299, dgain:x1.000000 */
+	{0x04ed, 0x0400}, /* index:212, gain:19.87500db -> x9.857118, again:x9.857118, dgain:x1.000000 */
+	{0x04fb, 0x0400}, /* index:213, gain:19.96875db -> x9.964087, again:x9.964087, dgain:x1.000000 */
+	{0x0509, 0x0400}, /* index:214, gain:20.06250db -> x10.072214, again:x10.072214, dgain:x1.000000 */
+	{0x0517, 0x0400}, /* index:215, gain:20.15625db -> x10.181517, again:x10.181517, dgain:x1.000000 */
+	{0x0525, 0x0400}, /* index:216, gain:20.25000db -> x10.292006, again:x10.292006, dgain:x1.000000 */
+	{0x0533, 0x0400}, /* index:217, gain:20.34375db -> x10.403692, again:x10.403692, dgain:x1.000000 */
+	{0x0542, 0x0400}, /* index:218, gain:20.43750db -> x10.516592, again:x10.516592, dgain:x1.000000 */
+	{0x0550, 0x0400}, /* index:219, gain:20.53125db -> x10.630714, again:x10.630714, dgain:x1.000000 */
+	{0x055f, 0x0400}, /* index:220, gain:20.62500db -> x10.746078, again:x10.746078, dgain:x1.000000 */
+	{0x056e, 0x0400}, /* index:221, gain:20.71875db -> x10.862694, again:x10.862694, dgain:x1.000000 */
+	{0x057d, 0x0400}, /* index:222, gain:20.81250db -> x10.980572, again:x10.980572, dgain:x1.000000 */
+	{0x058c, 0x0400}, /* index:223, gain:20.90625db -> x11.099733, again:x11.099733, dgain:x1.000000 */
+	{0x059c, 0x0400}, /* index:224, gain:21.00000db -> x11.220183, again:x11.220183, dgain:x1.000000 */
+	{0x05ab, 0x0400}, /* index:225, gain:21.09375db -> x11.341944, again:x11.341944, dgain:x1.000000 */
+	{0x05bb, 0x0400}, /* index:226, gain:21.18750db -> x11.465026, again:x11.465026, dgain:x1.000000 */
+	{0x05cb, 0x0400}, /* index:227, gain:21.28125db -> x11.589441, again:x11.589441, dgain:x1.000000 */
+	{0x05db, 0x0400}, /* index:228, gain:21.37500db -> x11.715209, again:x11.715209, dgain:x1.000000 */
+	{0x05eb, 0x0400}, /* index:229, gain:21.46875db -> x11.842338, again:x11.842338, dgain:x1.000000 */
+	{0x05fc, 0x0400}, /* index:230, gain:21.56250db -> x11.970850, again:x11.970850, dgain:x1.000000 */
+	{0x060c, 0x0400}, /* index:231, gain:21.65625db -> x12.100757, again:x12.100757, dgain:x1.000000 */
+	{0x061d, 0x0400}, /* index:232, gain:21.75000db -> x12.232071, again:x12.232071, dgain:x1.000000 */
+	{0x062e, 0x0400}, /* index:233, gain:21.84375db -> x12.364812, again:x12.364812, dgain:x1.000000 */
+	{0x063f, 0x0400}, /* index:234, gain:21.93750db -> x12.498991, again:x12.498991, dgain:x1.000000 */
+	{0x0651, 0x0400}, /* index:235, gain:22.03125db -> x12.634629, again:x12.634629, dgain:x1.000000 */
+	{0x0662, 0x0400}, /* index:236, gain:22.12500db -> x12.771739, again:x12.771739, dgain:x1.000000 */
+	{0x0674, 0x0400}, /* index:237, gain:22.21875db -> x12.910334, again:x12.910334, dgain:x1.000000 */
+	{0x0686, 0x0400}, /* index:238, gain:22.31250db -> x13.050436, again:x13.050436, dgain:x1.000000 */
+	{0x0698, 0x0400}, /* index:239, gain:22.40625db -> x13.192055, again:x13.192055, dgain:x1.000000 */
+	{0x06aa, 0x0400}, /* index:240, gain:22.50000db -> x13.335214, again:x13.335214, dgain:x1.000000 */
+	{0x06bd, 0x0400}, /* index:241, gain:22.59375db -> x13.479927, again:x13.479927, dgain:x1.000000 */
+	{0x06d0, 0x0400}, /* index:242, gain:22.68750db -> x13.626207, again:x13.626207, dgain:x1.000000 */
+	{0x06e3, 0x0400}, /* index:243, gain:22.78125db -> x13.774078, again:x13.774078, dgain:x1.000000 */
+	{0x06f6, 0x0400}, /* index:244, gain:22.87500db -> x13.923549, again:x13.923549, dgain:x1.000000 */
+	{0x0709, 0x0400}, /* index:245, gain:22.96875db -> x14.074647, again:x14.074647, dgain:x1.000000 */
+	{0x071d, 0x0400}, /* index:246, gain:23.06250db -> x14.227384, again:x14.227384, dgain:x1.000000 */
+	{0x0730, 0x0400}, /* index:247, gain:23.15625db -> x14.381775, again:x14.381775, dgain:x1.000000 */
+	{0x0744, 0x0400}, /* index:248, gain:23.25000db -> x14.537845, again:x14.537845, dgain:x1.000000 */
+	{0x0759, 0x0400}, /* index:249, gain:23.34375db -> x14.695604, again:x14.695604, dgain:x1.000000 */
+	{0x076d, 0x0400}, /* index:250, gain:23.43750db -> x14.855080, again:x14.855080, dgain:x1.000000 */
+	{0x0782, 0x0400}, /* index:251, gain:23.53125db -> x15.016287, again:x15.016287, dgain:x1.000000 */
+	{0x0796, 0x0400}, /* index:252, gain:23.62500db -> x15.179238, again:x15.179238, dgain:x1.000000 */
+	{0x07ac, 0x0400}, /* index:253, gain:23.71875db -> x15.343962, again:x15.343962, dgain:x1.000000 */
+	{0x07c1, 0x0400}, /* index:254, gain:23.81250db -> x15.510470, again:x15.510470, dgain:x1.000000 */
+	{0x07d6, 0x0400}, /* index:255, gain:23.90625db -> x15.678788, again:x15.678788, dgain:x1.000000 */
+	{0x07ec, 0x0400}, /* index:256, gain:24.00000db -> x15.848934, again:x15.848934, dgain:x1.000000 */
+	{0x07ff, 0x0401}, /* index:257, gain:24.09375db -> x16.020921, again:x15.992188, dgain:x1.001797 */
+	{0x07ff, 0x040c}, /* index:258, gain:24.18750db -> x16.194779, again:x15.992188, dgain:x1.012668 */
+	{0x07ff, 0x0418}, /* index:259, gain:24.28125db -> x16.370519, again:x15.992188, dgain:x1.023657 */
+	{0x07ff, 0x0423}, /* index:260, gain:24.37500db -> x16.548171, again:x15.992188, dgain:x1.034766 */
+	{0x07ff, 0x042f}, /* index:261, gain:24.46875db -> x16.727751, again:x15.992188, dgain:x1.045995 */
+	{0x07ff, 0x043a}, /* index:262, gain:24.56250db -> x16.909275, again:x15.992188, dgain:x1.057346 */
+	{0x07ff, 0x0446}, /* index:263, gain:24.65625db -> x17.092773, again:x15.992188, dgain:x1.068820 */
+	{0x07ff, 0x0452}, /* index:264, gain:24.75000db -> x17.278258, again:x15.992188, dgain:x1.080419 */
+	{0x07ff, 0x045e}, /* index:265, gain:24.84375db -> x17.465760, again:x15.992188, dgain:x1.092143 */
+	{0x07ff, 0x046a}, /* index:266, gain:24.93750db -> x17.655298, again:x15.992188, dgain:x1.103995 */
+	{0x07ff, 0x0476}, /* index:267, gain:25.03125db -> x17.846887, again:x15.992188, dgain:x1.115975 */
+	{0x07ff, 0x0483}, /* index:268, gain:25.12500db -> x18.040560, again:x15.992188, dgain:x1.128086 */
+	{0x07ff, 0x048f}, /* index:269, gain:25.21875db -> x18.236330, again:x15.992188, dgain:x1.140327 */
+	{0x07ff, 0x049c}, /* index:270, gain:25.31250db -> x18.434230, again:x15.992188, dgain:x1.152702 */
+	{0x07ff, 0x04a9}, /* index:271, gain:25.40625db -> x18.634277, again:x15.992188, dgain:x1.165211 */
+	{0x07ff, 0x04b6}, /* index:272, gain:25.50000db -> x18.836490, again:x15.992188, dgain:x1.177856 */
+	{0x07ff, 0x04c3}, /* index:273, gain:25.59375db -> x19.040902, again:x15.992188, dgain:x1.190638 */
+	{0x07ff, 0x04d0}, /* index:274, gain:25.68750db -> x19.247528, again:x15.992188, dgain:x1.203558 */
+	{0x07ff, 0x04dd}, /* index:275, gain:25.78125db -> x19.456401, again:x15.992188, dgain:x1.216619 */
+	{0x07ff, 0x04eb}, /* index:276, gain:25.87500db -> x19.667540, again:x15.992188, dgain:x1.229822 */
+	{0x07ff, 0x04f9}, /* index:277, gain:25.96875db -> x19.880966, again:x15.992188, dgain:x1.243167 */
+	{0x07ff, 0x0506}, /* index:278, gain:26.06250db -> x20.096713, again:x15.992188, dgain:x1.256658 */
+	{0x07ff, 0x0514}, /* index:279, gain:26.15625db -> x20.314795, again:x15.992188, dgain:x1.270295 */
+	{0x07ff, 0x0522}, /* index:280, gain:26.25000db -> x20.535250, again:x15.992188, dgain:x1.284080 */
+	{0x07ff, 0x0531}, /* index:281, gain:26.34375db -> x20.758098, again:x15.992188, dgain:x1.298015 */
+	{0x07ff, 0x053f}, /* index:282, gain:26.43750db -> x20.983357, again:x15.992188, dgain:x1.312101 */
+	{0x07ff, 0x054e}, /* index:283, gain:26.53125db -> x21.211067, again:x15.992188, dgain:x1.326339 */
+	{0x07ff, 0x055c}, /* index:284, gain:26.62500db -> x21.441243, again:x15.992188, dgain:x1.340732 */
+	{0x07ff, 0x056b}, /* index:285, gain:26.71875db -> x21.673922, again:x15.992188, dgain:x1.355282 */
+	{0x07ff, 0x057a}, /* index:286, gain:26.81250db -> x21.909126, again:x15.992188, dgain:x1.369989 */
+	{0x07ff, 0x058a}, /* index:287, gain:26.90625db -> x22.146876, again:x15.992188, dgain:x1.384856 */
+	{0x07ff, 0x0599}, /* index:288, gain:27.00000db -> x22.387213, again:x15.992188, dgain:x1.399884 */
+	{0x07ff, 0x05a9}, /* index:289, gain:27.09375db -> x22.630151, again:x15.992188, dgain:x1.415075 */
+	{0x07ff, 0x05b8}, /* index:290, gain:27.18750db -> x22.875732, again:x15.992188, dgain:x1.430432 */
+	{0x07ff, 0x05c8}, /* index:291, gain:27.28125db -> x23.123978, again:x15.992188, dgain:x1.445955 */
+	{0x07ff, 0x05d8}, /* index:292, gain:27.37500db -> x23.374912, again:x15.992188, dgain:x1.461646 */
+	{0x07ff, 0x05e8}, /* index:293, gain:27.46875db -> x23.628575, again:x15.992188, dgain:x1.477507 */
+	{0x07ff, 0x05f9}, /* index:294, gain:27.56250db -> x23.884984, again:x15.992188, dgain:x1.493541 */
+	{0x07ff, 0x0609}, /* index:295, gain:27.65625db -> x24.144182, again:x15.992188, dgain:x1.509749 */
+	{0x07ff, 0x061a}, /* index:296, gain:27.75000db -> x24.406193, again:x15.992188, dgain:x1.526132 */
+	{0x07ff, 0x062b}, /* index:297, gain:27.84375db -> x24.671041, again:x15.992188, dgain:x1.542693 */
+	{0x07ff, 0x063c}, /* index:298, gain:27.93750db -> x24.938770, again:x15.992188, dgain:x1.559435 */
+	{0x07ff, 0x064e}, /* index:299, gain:28.03125db -> x25.209397, again:x15.992188, dgain:x1.576357 */
+	{0x07ff, 0x065f}, /* index:300, gain:28.12500db -> x25.482967, again:x15.992188, dgain:x1.593464 */
+	{0x07ff, 0x0671}, /* index:301, gain:28.21875db -> x25.759507, again:x15.992188, dgain:x1.610756 */
+	{0x07ff, 0x0683}, /* index:302, gain:28.31250db -> x26.039040, again:x15.992188, dgain:x1.628235 */
+	{0x07ff, 0x0695}, /* index:303, gain:28.40625db -> x26.321614, again:x15.992188, dgain:x1.645905 */
+	{0x07ff, 0x06a7}, /* index:304, gain:28.50000db -> x26.607248, again:x15.992188, dgain:x1.663765 */
+	{0x07ff, 0x06ba}, /* index:305, gain:28.59375db -> x26.895988, again:x15.992188, dgain:x1.681820 */
+	{0x07ff, 0x06cc}, /* index:306, gain:28.68750db -> x27.187861, again:x15.992188, dgain:x1.700071 */
+	{0x07ff, 0x06df}, /* index:307, gain:28.78125db -> x27.482895, again:x15.992188, dgain:x1.718520 */
+	{0x07ff, 0x06f2}, /* index:308, gain:28.87500db -> x27.781137, again:x15.992188, dgain:x1.737169 */
+	{0x07ff, 0x0706}, /* index:309, gain:28.96875db -> x28.082609, again:x15.992188, dgain:x1.756020 */
+	{0x07ff, 0x0719}, /* index:310, gain:29.06250db -> x28.387360, again:x15.992188, dgain:x1.775077 */
+	{0x07ff, 0x072d}, /* index:311, gain:29.15625db -> x28.695417, again:x15.992188, dgain:x1.794340 */
+	{0x07ff, 0x0741}, /* index:312, gain:29.25000db -> x29.006810, again:x15.992188, dgain:x1.813811 */
+	{0x07ff, 0x0755}, /* index:313, gain:29.34375db -> x29.321590, again:x15.992188, dgain:x1.833495 */
+	{0x07ff, 0x0769}, /* index:314, gain:29.43750db -> x29.639778, again:x15.992188, dgain:x1.853391 */
+	{0x07ff, 0x077e}, /* index:315, gain:29.53125db -> x29.961427, again:x15.992188, dgain:x1.873504 */
+	{0x07ff, 0x0793}, /* index:316, gain:29.62500db -> x30.286567, again:x15.992188, dgain:x1.893835 */
+	{0x07ff, 0x07a8}, /* index:317, gain:29.71875db -> x30.615226, again:x15.992188, dgain:x1.914386 */
+	{0x07ff, 0x07bd}, /* index:318, gain:29.81250db -> x30.947461, again:x15.992188, dgain:x1.935161 */
+	{0x07ff, 0x07d3}, /* index:319, gain:29.90625db -> x31.283292, again:x15.992188, dgain:x1.956161 */
+	{0x07ff, 0x07e8}, /* index:320, gain:30.00000db -> x31.622777, again:x15.992188, dgain:x1.977389 */
+	{0x07ff, 0x07fe}, /* index:321, gain:30.09375db -> x31.965945, again:x15.992188, dgain:x1.998848 */
+	{0x07ff, 0x0815}, /* index:322, gain:30.18750db -> x32.312829, again:x15.992188, dgain:x2.020538 */
+	{0x07ff, 0x082b}, /* index:323, gain:30.28125db -> x32.663485, again:x15.992188, dgain:x2.042465 */
+	{0x07ff, 0x0842}, /* index:324, gain:30.37500db -> x33.017938, again:x15.992188, dgain:x2.064629 */
+	{0x07ff, 0x0859}, /* index:325, gain:30.46875db -> x33.376247, again:x15.992188, dgain:x2.087034 */
+	{0x07ff, 0x0870}, /* index:326, gain:30.56250db -> x33.738444, again:x15.992188, dgain:x2.109683 */
+	{0x07ff, 0x0887}, /* index:327, gain:30.65625db -> x34.104562, again:x15.992188, dgain:x2.132576 */
+	{0x07ff, 0x089f}, /* index:328, gain:30.75000db -> x34.474663, again:x15.992188, dgain:x2.155719 */
+	{0x07ff, 0x08b7}, /* index:329, gain:30.84375db -> x34.848770, again:x15.992188, dgain:x2.179112 */
+	{0x07ff, 0x08cf}, /* index:330, gain:30.93750db -> x35.226947, again:x15.992188, dgain:x2.202760 */
+	{0x07ff, 0x08e8}, /* index:331, gain:31.03125db -> x35.609227, again:x15.992188, dgain:x2.226664 */
+	{0x07ff, 0x0900}, /* index:332, gain:31.12500db -> x35.995646, again:x15.992188, dgain:x2.250827 */
+	{0x07ff, 0x0919}, /* index:333, gain:31.21875db -> x36.386269, again:x15.992188, dgain:x2.275253 */
+	{0x07ff, 0x0933}, /* index:334, gain:31.31250db -> x36.781120, again:x15.992188, dgain:x2.299943 */
+	{0x07ff, 0x094c}, /* index:335, gain:31.40625db -> x37.180267, again:x15.992188, dgain:x2.324902 */
+	{0x07ff, 0x0966}, /* index:336, gain:31.50000db -> x37.583745, again:x15.992188, dgain:x2.350132 */
+	{0x07ff, 0x0980}, /* index:337, gain:31.59375db -> x37.991591, again:x15.992188, dgain:x2.375634 */
+	{0x07ff, 0x099b}, /* index:338, gain:31.68750db -> x38.403873, again:x15.992188, dgain:x2.401415 */
+	{0x07ff, 0x09b5}, /* index:339, gain:31.78125db -> x38.820619, again:x15.992188, dgain:x2.427474 */
+	{0x07ff, 0x09d0}, /* index:340, gain:31.87500db -> x39.241898, again:x15.992188, dgain:x2.453817 */
+	{0x07ff, 0x09eb}, /* index:341, gain:31.96875db -> x39.667748, again:x15.992188, dgain:x2.480445 */
+	{0x07ff, 0x0a07}, /* index:342, gain:32.06250db -> x40.098209, again:x15.992188, dgain:x2.507362 */
+	{0x07ff, 0x0a23}, /* index:343, gain:32.15625db -> x40.533352, again:x15.992188, dgain:x2.534572 */
+	{0x07ff, 0x0a3f}, /* index:344, gain:32.25000db -> x40.973206, again:x15.992188, dgain:x2.562076 */
+	{0x07ff, 0x0a5c}, /* index:345, gain:32.34375db -> x41.417845, again:x15.992188, dgain:x2.589880 */
+	{0x07ff, 0x0a78}, /* index:346, gain:32.43750db -> x41.867309, again:x15.992188, dgain:x2.617985 */
+	{0x07ff, 0x0a95}, /* index:347, gain:32.53125db -> x42.321639, again:x15.992188, dgain:x2.646395 */
+	{0x07ff, 0x0ab3}, /* index:348, gain:32.62500db -> x42.780911, again:x15.992188, dgain:x2.675113 */
+	{0x07ff, 0x0ad1}, /* index:349, gain:32.71875db -> x43.245154, again:x15.992188, dgain:x2.704143 */
+	{0x07ff, 0x0aef}, /* index:350, gain:32.81250db -> x43.714448, again:x15.992188, dgain:x2.733488 */
+	{0x07ff, 0x0b0d}, /* index:351, gain:32.90625db -> x44.188835, again:x15.992188, dgain:x2.763151 */
+	{0x07ff, 0x0b2c}, /* index:352, gain:33.00000db -> x44.668357, again:x15.992188, dgain:x2.793136 */
+	{0x07ff, 0x0b4b}, /* index:353, gain:33.09375db -> x45.153095, again:x15.992188, dgain:x2.823447 */
+	{0x07ff, 0x0b6a}, /* index:354, gain:33.18750db -> x45.643081, again:x15.992188, dgain:x2.854086 */
+	{0x07ff, 0x0b8a}, /* index:355, gain:33.28125db -> x46.138397, again:x15.992188, dgain:x2.885059 */
+	{0x07ff, 0x0baa}, /* index:356, gain:33.37500db -> x46.639088, again:x15.992188, dgain:x2.916367 */
+	{0x07ff, 0x0bca}, /* index:357, gain:33.46875db -> x47.145199, again:x15.992188, dgain:x2.948014 */
+	{0x07ff, 0x0beb}, /* index:358, gain:33.56250db -> x47.656816, again:x15.992188, dgain:x2.980006 */
+	{0x07ff, 0x0c0c}, /* index:359, gain:33.65625db -> x48.173972, again:x15.992188, dgain:x3.012344 */
+	{0x07ff, 0x0c2e}, /* index:360, gain:33.75000db -> x48.696753, again:x15.992188, dgain:x3.045034 */
+	{0x07ff, 0x0c4f}, /* index:361, gain:33.84375db -> x49.225207, again:x15.992188, dgain:x3.078078 */
+	{0x07ff, 0x0c72}, /* index:362, gain:33.93750db -> x49.759382, again:x15.992188, dgain:x3.111481 */
+	{0x07ff, 0x0c94}, /* index:363, gain:34.03125db -> x50.299367, again:x15.992188, dgain:x3.145246 */
+	{0x07ff, 0x0cb7}, /* index:364, gain:34.12500db -> x50.845199, again:x15.992188, dgain:x3.179377 */
+	{0x07ff, 0x0cdb}, /* index:365, gain:34.21875db -> x51.396968, again:x15.992188, dgain:x3.213880 */
+	{0x07ff, 0x0cfe}, /* index:366, gain:34.31250db -> x51.954725, again:x15.992188, dgain:x3.248757 */
+	{0x07ff, 0x0d22}, /* index:367, gain:34.40625db -> x52.518520, again:x15.992188, dgain:x3.284011 */
+	{0x07ff, 0x0d47}, /* index:368, gain:34.50000db -> x53.088447, again:x15.992188, dgain:x3.319649 */
+	{0x07ff, 0x0d6c}, /* index:369, gain:34.59375db -> x53.664545, again:x15.992188, dgain:x3.355673 */
+	{0x07ff, 0x0d91}, /* index:370, gain:34.68750db -> x54.246909, again:x15.992188, dgain:x3.392088 */
+	{0x07ff, 0x0db7}, /* index:371, gain:34.78125db -> x54.835593, again:x15.992188, dgain:x3.428899 */
+	{0x07ff, 0x0ddd}, /* index:372, gain:34.87500db -> x55.430651, again:x15.992188, dgain:x3.466108 */
+	{0x07ff, 0x0e03}, /* index:373, gain:34.96875db -> x56.032181, again:x15.992188, dgain:x3.503722 */
+	{0x07ff, 0x0e2a}, /* index:374, gain:35.06250db -> x56.640223, again:x15.992188, dgain:x3.541743 */
+	{0x07ff, 0x0e52}, /* index:375, gain:35.15625db -> x57.254879, again:x15.992188, dgain:x3.580178 */
+	{0x07ff, 0x0e79}, /* index:376, gain:35.25000db -> x57.876205, again:x15.992188, dgain:x3.619030 */
+	{0x07ff, 0x0ea2}, /* index:377, gain:35.34375db -> x58.504258, again:x15.992188, dgain:x3.658302 */
+	{0x07ff, 0x0eca}, /* index:378, gain:35.43750db -> x59.139143, again:x15.992188, dgain:x3.698002 */
+	{0x07ff, 0x0ef3}, /* index:379, gain:35.53125db -> x59.780900, again:x15.992188, dgain:x3.738132 */
+	{0x07ff, 0x0f1d}, /* index:380, gain:35.62500db -> x60.429639, again:x15.992188, dgain:x3.778698 */
+	{0x07ff, 0x0f47}, /* index:381, gain:35.71875db -> x61.085418, again:x15.992188, dgain:x3.819704 */
+	{0x07ff, 0x0f71}, /* index:382, gain:35.81250db -> x61.748296, again:x15.992188, dgain:x3.861154 */
+	{0x07ff, 0x0f9c}, /* index:383, gain:35.90625db -> x62.418384, again:x15.992188, dgain:x3.903055 */
+	{0x07ff, 0x0fc8}, /* index:384, gain:36.00000db -> x63.095728, again:x15.992188, dgain:x3.945409 */
+	{0x07ff, 0x0ff3}, /* index:385, gain:36.09375db -> x63.780438, again:x15.992188, dgain:x3.988225 */
+	{0x07ff, 0x1020}, /* index:386, gain:36.18750db -> x64.472580, again:x15.992188, dgain:x4.031505 */
+	{0x07ff, 0x104d}, /* index:387, gain:36.28125db -> x65.172214, again:x15.992188, dgain:x4.075253 */
+	{0x07ff, 0x107a}, /* index:388, gain:36.37500db -> x65.879459, again:x15.992188, dgain:x4.119478 */
+	{0x07ff, 0x10a8}, /* index:389, gain:36.46875db -> x66.594360, again:x15.992188, dgain:x4.164181 */
+	{0x07ff, 0x10d6}, /* index:390, gain:36.56250db -> x67.317038, again:x15.992188, dgain:x4.209370 */
+	{0x07ff, 0x1105}, /* index:391, gain:36.65625db -> x68.047559, again:x15.992188, dgain:x4.255050 */
+	{0x07ff, 0x1134}, /* index:392, gain:36.75000db -> x68.785987, again:x15.992188, dgain:x4.301224 */
+	{0x07ff, 0x1164}, /* index:393, gain:36.84375db -> x69.532449, again:x15.992188, dgain:x4.347901 */
+	{0x07ff, 0x1194}, /* index:394, gain:36.93750db -> x70.286991, again:x15.992188, dgain:x4.395083 */
+	{0x07ff, 0x11c5}, /* index:395, gain:37.03125db -> x71.049741, again:x15.992188, dgain:x4.442778 */
+	{0x07ff, 0x11f6}, /* index:396, gain:37.12500db -> x71.820768, again:x15.992188, dgain:x4.490991 */
+	{0x07ff, 0x1228}, /* index:397, gain:37.21875db -> x72.600143, again:x15.992188, dgain:x4.539726 */
+	{0x07ff, 0x125b}, /* index:398, gain:37.31250db -> x73.387995, again:x15.992188, dgain:x4.588990 */
+	{0x07ff, 0x128e}, /* index:399, gain:37.40625db -> x74.184377, again:x15.992188, dgain:x4.638789 */
+	{0x07ff, 0x12c1}, /* index:400, gain:37.50000db -> x74.989421, again:x15.992188, dgain:x4.689128 */
+	{0x07ff, 0x12f5}, /* index:401, gain:37.59375db -> x75.803201, again:x15.992188, dgain:x4.740015 */
+	{0x07ff, 0x132a}, /* index:402, gain:37.68750db -> x76.625792, again:x15.992188, dgain:x4.791452 */
+	{0x07ff, 0x135f}, /* index:403, gain:37.78125db -> x77.457330, again:x15.992188, dgain:x4.843448 */
+	{0x07ff, 0x1395}, /* index:404, gain:37.87500db -> x78.297871, again:x15.992188, dgain:x4.896008 */
+	{0x07ff, 0x13cb}, /* index:405, gain:37.96875db -> x79.147554, again:x15.992188, dgain:x4.949139 */
+	{0x07ff, 0x1402}, /* index:406, gain:38.06250db -> x80.006459, again:x15.992188, dgain:x5.002846 */
+	{0x07ff, 0x143a}, /* index:407, gain:38.15625db -> x80.874662, again:x15.992188, dgain:x5.057136 */
+	{0x07ff, 0x1472}, /* index:408, gain:38.25000db -> x81.752308, again:x15.992188, dgain:x5.112015 */
+	{0x07ff, 0x14ab}, /* index:409, gain:38.34375db -> x82.639457, again:x15.992188, dgain:x5.167489 */
+	{0x07ff, 0x14e4}, /* index:410, gain:38.43750db -> x83.536255, again:x15.992188, dgain:x5.223566 */
+	{0x07ff, 0x151e}, /* index:411, gain:38.53125db -> x84.442785, again:x15.992188, dgain:x5.280252 */
+	{0x07ff, 0x1559}, /* index:412, gain:38.62500db -> x85.359129, again:x15.992188, dgain:x5.337552 */
+	{0x07ff, 0x1594}, /* index:413, gain:38.71875db -> x86.285441, again:x15.992188, dgain:x5.395475 */
+	{0x07ff, 0x15d0}, /* index:414, gain:38.81250db -> x87.221781, again:x15.992188, dgain:x5.454024 */
+	{0x07ff, 0x160d}, /* index:415, gain:38.90625db -> x88.168307, again:x15.992188, dgain:x5.513211 */
+	{0x07ff, 0x164a}, /* index:416, gain:39.00000db -> x89.125104, again:x15.992188, dgain:x5.573040 */
+	{0x07ff, 0x1688}, /* index:417, gain:39.09375db -> x90.092259, again:x15.992188, dgain:x5.633517 */
+	{0x07ff, 0x16c7}, /* index:418, gain:39.18750db -> x91.069934, again:x15.992188, dgain:x5.694651 */
+	{0x07ff, 0x1706}, /* index:419, gain:39.28125db -> x92.058194, again:x15.992188, dgain:x5.756448 */
+	{0x07ff, 0x1746}, /* index:420, gain:39.37500db -> x93.057204, again:x15.992188, dgain:x5.818917 */
+	{0x07ff, 0x1787}, /* index:421, gain:39.46875db -> x94.067055, again:x15.992188, dgain:x5.882063 */
+	{0x07ff, 0x17c8}, /* index:422, gain:39.56250db -> x95.087839, again:x15.992188, dgain:x5.945893 */
+	{0x07ff, 0x180a}, /* index:423, gain:39.65625db -> x96.119726, again:x15.992188, dgain:x6.010418 */
+	{0x07ff, 0x184d}, /* index:424, gain:39.75000db -> x97.162784, again:x15.992188, dgain:x6.075641 */
+	{0x07ff, 0x1890}, /* index:425, gain:39.84375db -> x98.217189, again:x15.992188, dgain:x6.141573 */
+	{0x07ff, 0x18d5}, /* index:426, gain:39.93750db -> x99.283036, again:x15.992188, dgain:x6.208221 */
+	{0x07ff, 0x191a}, /* index:427, gain:40.03125db -> x100.360449, again:x15.992188, dgain:x6.275592 */
+	{0x07ff, 0x195f}, /* index:428, gain:40.12500db -> x101.449499, again:x15.992188, dgain:x6.343691 */
+	{0x07ff, 0x19a6}, /* index:429, gain:40.21875db -> x102.550422, again:x15.992188, dgain:x6.412533 */
+	{0x07ff, 0x19ed}, /* index:430, gain:40.31250db -> x103.663293, again:x15.992188, dgain:x6.482121 */
+	{0x07ff, 0x1a35}, /* index:431, gain:40.40625db -> x104.788240, again:x15.992188, dgain:x6.552464 */
+	{0x07ff, 0x1a7e}, /* index:432, gain:40.50000db -> x105.925396, again:x15.992188, dgain:x6.623571 */
+	{0x07ff, 0x1ac8}, /* index:433, gain:40.59375db -> x107.074833, again:x15.992188, dgain:x6.695446 */
+	{0x07ff, 0x1b12}, /* index:434, gain:40.68750db -> x108.236802, again:x15.992188, dgain:x6.768105 */
+	{0x07ff, 0x1b5d}, /* index:435, gain:40.78125db -> x109.411381, again:x15.992188, dgain:x6.841552 */
+	{0x07ff, 0x1ba9}, /* index:436, gain:40.87500db -> x110.598706, again:x15.992188, dgain:x6.915796 */
+	{0x07ff, 0x1bf6}, /* index:437, gain:40.96875db -> x111.798917, again:x15.992188, dgain:x6.990846 */
+	{0x07ff, 0x1c44}, /* index:438, gain:41.06250db -> x113.012089, again:x15.992188, dgain:x7.066706 */
+	{0x07ff, 0x1c92}, /* index:439, gain:41.15625db -> x114.238490, again:x15.992188, dgain:x7.143394 */
+	{0x07ff, 0x1ce2}, /* index:440, gain:41.25000db -> x115.478198, again:x15.992188, dgain:x7.220913 */
+	{0x07ff, 0x1d32}, /* index:441, gain:41.34375db -> x116.731361, again:x15.992188, dgain:x7.299274 */
+	{0x07ff, 0x1d83}, /* index:442, gain:41.43750db -> x117.998122, again:x15.992188, dgain:x7.378485 */
+	{0x07ff, 0x1dd5}, /* index:443, gain:41.53125db -> x119.278565, again:x15.992188, dgain:x7.458552 */
+	{0x07ff, 0x1e28}, /* index:444, gain:41.62500db -> x120.572968, again:x15.992188, dgain:x7.539492 */
+	{0x07ff, 0x1e7c}, /* index:445, gain:41.71875db -> x121.881418, again:x15.992188, dgain:x7.621310 */
+	{0x07ff, 0x1ed0}, /* index:446, gain:41.81250db -> x123.204068, again:x15.992188, dgain:x7.704016 */
+	{0x07ff, 0x1f26}, /* index:447, gain:41.90625db -> x124.541071, again:x15.992188, dgain:x7.787619 */
+	{0x07ff, 0x1f7d}, /* index:448, gain:42.00000db -> x125.892514, again:x15.992188, dgain:x7.872126 */
+	{0x07ff, 0x1fd4}, /* index:449, gain:42.09375db -> x127.258691, again:x15.992188, dgain:x7.957554 */
+	{0x07ff, 0x202c}, /* index:450, gain:42.18750db -> x128.639694, again:x15.992188, dgain:x8.043909 */
+	{0x07ff, 0x2086}, /* index:451, gain:42.28125db -> x130.035684, again:x15.992188, dgain:x8.131201 */
+	{0x07ff, 0x20e0}, /* index:452, gain:42.37500db -> x131.446823, again:x15.992188, dgain:x8.219440 */
+	{0x07ff, 0x213c}, /* index:453, gain:42.46875db -> x132.873203, again:x15.992188, dgain:x8.308632 */
+	{0x07ff, 0x2198}, /* index:454, gain:42.56250db -> x134.315135, again:x15.992188, dgain:x8.398797 */
+	{0x07ff, 0x21f5}, /* index:455, gain:42.65625db -> x135.772714, again:x15.992188, dgain:x8.489940 */
+	{0x07ff, 0x2254}, /* index:456, gain:42.75000db -> x137.246111, again:x15.992188, dgain:x8.582072 */
+	{0x07ff, 0x22b3}, /* index:457, gain:42.84375db -> x138.735497, again:x15.992188, dgain:x8.675205 */
+	{0x07ff, 0x2313}, /* index:458, gain:42.93750db -> x140.240969, again:x15.992188, dgain:x8.769342 */
+	{0x07ff, 0x2375}, /* index:459, gain:43.03125db -> x141.762855, again:x15.992188, dgain:x8.864507 */
+	{0x07ff, 0x23d7}, /* index:460, gain:43.12500db -> x143.301257, again:x15.992188, dgain:x8.960704 */
+	{0x07ff, 0x243b}, /* index:461, gain:43.21875db -> x144.856353, again:x15.992188, dgain:x9.057945 */
+	{0x07ff, 0x249f}, /* index:462, gain:43.31250db -> x146.428325, again:x15.992188, dgain:x9.156241 */
+	{0x07ff, 0x2505}, /* index:463, gain:43.40625db -> x148.017275, again:x15.992188, dgain:x9.255599 */
+	{0x07ff, 0x256c}, /* index:464, gain:43.50000db -> x149.623549, again:x15.992188, dgain:x9.356040 */
+	{0x07ff, 0x25d4}, /* index:465, gain:43.59375db -> x151.247255, again:x15.992188, dgain:x9.457571 */
+	{0x07ff, 0x263d}, /* index:466, gain:43.68750db -> x152.888580, again:x15.992188, dgain:x9.560204 */
+	{0x07ff, 0x26a7}, /* index:467, gain:43.78125db -> x154.547717, again:x15.992188, dgain:x9.663951 */
+	{0x07ff, 0x2713}, /* index:468, gain:43.87500db -> x156.224774, again:x15.992188, dgain:x9.768818 */
+	{0x07ff, 0x277f}, /* index:469, gain:43.96875db -> x157.920115, again:x15.992188, dgain:x9.874829 */
+	{0x07ff, 0x27ed}, /* index:470, gain:44.06250db -> x159.633854, again:x15.992188, dgain:x9.981990 */
+	{0x07ff, 0x285c}, /* index:471, gain:44.15625db -> x161.366191, again:x15.992188, dgain:x10.090314 */
+	{0x07ff, 0x28cc}, /* index:472, gain:44.25000db -> x163.117327, again:x15.992188, dgain:x10.199813 */
+	{0x07ff, 0x293d}, /* index:473, gain:44.34375db -> x164.887375, again:x15.992188, dgain:x10.310495 */
+	{0x07ff, 0x29b0}, /* index:474, gain:44.43750db -> x166.676723, again:x15.992188, dgain:x10.422384 */
+	{0x07ff, 0x2a24}, /* index:475, gain:44.53125db -> x168.485488, again:x15.992188, dgain:x10.535487 */
+	{0x07ff, 0x2a99}, /* index:476, gain:44.62500db -> x170.313882, again:x15.992188, dgain:x10.649818 */
+	{0x07ff, 0x2b0f}, /* index:477, gain:44.71875db -> x172.162117, again:x15.992188, dgain:x10.765389 */
+	{0x07ff, 0x2b87}, /* index:478, gain:44.81250db -> x174.030314, again:x15.992188, dgain:x10.882208 */
+	{0x07ff, 0x2c00}, /* index:479, gain:44.90625db -> x175.918880, again:x15.992188, dgain:x11.000301 */
+	{0x07ff, 0x2c7a}, /* index:480, gain:45.00000db -> x177.827941, again:x15.992188, dgain:x11.119676 */
+	{0x07ff, 0x2cf6}, /* index:481, gain:45.09375db -> x179.757719, again:x15.992188, dgain:x11.240346 */
+	{0x07ff, 0x2d73}, /* index:482, gain:45.18750db -> x181.708438, again:x15.992188, dgain:x11.362325 */
+	{0x07ff, 0x2df1}, /* index:483, gain:45.28125db -> x183.680226, again:x15.992188, dgain:x11.485622 */
+	{0x07ff, 0x2e70}, /* index:484, gain:45.37500db -> x185.673512, again:x15.992188, dgain:x11.610264 */
+	{0x07ff, 0x2ef1}, /* index:485, gain:45.46875db -> x187.688429, again:x15.992188, dgain:x11.736257 */
+	{0x07ff, 0x2f74}, /* index:486, gain:45.56250db -> x189.725212, again:x15.992188, dgain:x11.863619 */
+	{0x07ff, 0x2ff8}, /* index:487, gain:45.65625db -> x191.784098, again:x15.992188, dgain:x11.992362 */
+	{0x07ff, 0x307d}, /* index:488, gain:45.75000db -> x193.865221, again:x15.992188, dgain:x12.122496 */
+	{0x07ff, 0x3104}, /* index:489, gain:45.84375db -> x195.969034, again:x15.992188, dgain:x12.254048 */
+	{0x07ff, 0x318c}, /* index:490, gain:45.93750db -> x198.095678, again:x15.992188, dgain:x12.387028 */
+	{0x07ff, 0x3215}, /* index:491, gain:46.03125db -> x200.245400, again:x15.992188, dgain:x12.521451 */
+	{0x07ff, 0x32a1}, /* index:492, gain:46.12500db -> x202.418450, again:x15.992188, dgain:x12.657333 */
+	{0x07ff, 0x332d}, /* index:493, gain:46.21875db -> x204.614970, again:x15.992188, dgain:x12.794683 */
+	{0x07ff, 0x33bb}, /* index:494, gain:46.31250db -> x206.835439, again:x15.992188, dgain:x12.933530 */
+	{0x07ff, 0x344b}, /* index:495, gain:46.40625db -> x209.080004, again:x15.992188, dgain:x13.073884 */
+	{0x07ff, 0x34dc}, /* index:496, gain:46.50000db -> x211.348927, again:x15.992188, dgain:x13.215761 */
+	{0x07ff, 0x356f}, /* index:497, gain:46.59375db -> x213.642472, again:x15.992188, dgain:x13.359178 */
+	{0x07ff, 0x3604}, /* index:498, gain:46.68750db -> x215.960789, again:x15.992188, dgain:x13.504143 */
+	{0x07ff, 0x369a}, /* index:499, gain:46.78125db -> x218.304381, again:x15.992188, dgain:x13.650689 */
+	{0x07ff, 0x3731}, /* index:500, gain:46.87500db -> x220.673407, again:x15.992188, dgain:x13.798826 */
+	{0x07ff, 0x37cb}, /* index:501, gain:46.96875db -> x223.068141, again:x15.992188, dgain:x13.948570 */
+	{0x07ff, 0x3866}, /* index:502, gain:47.06250db -> x225.488862, again:x15.992188, dgain:x14.099939 */
+	{0x07ff, 0x3903}, /* index:503, gain:47.15625db -> x227.935728, again:x15.992188, dgain:x14.252942 */
+	{0x07ff, 0x39a1}, /* index:504, gain:47.25000db -> x230.409272, again:x15.992188, dgain:x14.407614 */
+	{0x07ff, 0x3a41}, /* index:505, gain:47.34375db -> x232.909659, again:x15.992188, dgain:x14.563965 */
+	{0x07ff, 0x3ae3}, /* index:506, gain:47.43750db -> x235.437180, again:x15.992188, dgain:x14.722012 */
+	{0x07ff, 0x3b86}, /* index:507, gain:47.53125db -> x237.992130, again:x15.992188, dgain:x14.881775 */
+	{0x07ff, 0x3c2c}, /* index:508, gain:47.62500db -> x240.574673, again:x15.992188, dgain:x15.043262 */
+	{0x07ff, 0x3cd3}, /* index:509, gain:47.71875db -> x243.185374, again:x15.992188, dgain:x15.206511 */
+	{0x07ff, 0x3d7c}, /* index:510, gain:47.81250db -> x245.824407, again:x15.992188, dgain:x15.371531 */
+	{0x07ff, 0x3e27}, /* index:511, gain:47.90625db -> x248.492078, again:x15.992188, dgain:x15.538342 */
+	{0x07ff, 0x3ed3}, /* index:512, gain:48.00000db -> x251.188698, again:x15.992188, dgain:x15.706963 */
+};
+
diff --git a/drivers/vin/sensors/omnivision_ov2732_parallel/Kbuild b/drivers/vin/sensors/omnivision_ov2732_parallel/Kbuild
new file mode 100644
index 0000000..17bffe5
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2732_parallel/Kbuild
@@ -0,0 +1,39 @@
+##
+## Filename : Kbuild
+##
+## History:
+##    2016/12/16 - [Hao Zeng] created file
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+
+EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
+EXTRA_AFLAGS		+= $(AMBARELLA_DRV_AFLAGS)
+EXTRA_LDFLAGS		+= $(AMBARELLA_DRV_LDFLAGS)
+
+obj-m := ov2732_parallel.o
+ov2732_parallel-y := ov2732.o
+
diff --git a/drivers/vin/sensors/omnivision_ov2732_parallel/make.inc b/drivers/vin/sensors/omnivision_ov2732_parallel/make.inc
new file mode 100644
index 0000000..ba50100
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2732_parallel/make.inc
@@ -0,0 +1,45 @@
+##
+## kernel/private/platform/vin/sensors/omnivision_ov2732_parallel/make.inc
+##
+## History:
+##    2016/12/16 - [Hao Zeng] created file
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+ifeq ($(CONFIG_SENSOR_OV2732_PARALLEL), y)
+
+LOCAL_PATH	:= $(call my-dir)
+
+###
+include $(CLEAR_VARS)
+
+LOCAL_SRCS	:= $(wildcard $(LOCAL_PATH)/*.c) $(wildcard $(LOCAL_PATH)/*.h)
+LOCAL_SRCS	+= $(LOCAL_PATH)/Kbuild
+
+include $(BUILD_DRIVER)
+
+endif
+
diff --git a/drivers/vin/sensors/omnivision_ov2732_parallel/ov2732.c b/drivers/vin/sensors/omnivision_ov2732_parallel/ov2732.c
new file mode 100644
index 0000000..e9531a2
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2732_parallel/ov2732.c
@@ -0,0 +1,607 @@
+/*
+ * Filename : ov2732.c
+ *
+ * History:
+ *    2016/12/16 - [Hao Zeng] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/ambpriv_device.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <iav_utils.h>
+#include <vin_api.h>
+#include "ov2732.h"
+#include "ov2732_table.c"
+
+static int bus_addr = (0 << 16) | (0x6C >> 1);
+module_param(bus_addr, int, 0644);
+MODULE_PARM_DESC(bus_addr, " bus and addr: bit16~bit31: bus, bit0~bit15: addr");
+
+static int bayer_pattern = VINDEV_BAYER_PATTERN_AUTO;
+module_param(bayer_pattern, int, 0644);
+MODULE_PARM_DESC(bayer_pattern, "set bayer pattern: 0:RG, 1:BG, 2:GR, 3:GB, 255:default");
+
+struct ov2732_priv {
+	void *control_data;
+	u32 line_length;
+	u32 frame_length_lines;
+};
+
+static int ov2732_write_reg(struct vin_device *vdev, u32 subaddr, u32 data)
+{
+	int rval;
+	struct ov2732_priv *ov2732;
+	struct i2c_client *client;
+	struct i2c_msg msgs[1];
+	u8 pbuf[3];
+
+	ov2732 = (struct ov2732_priv *)vdev->priv;
+	client = ov2732->control_data;
+
+	pbuf[0] = (subaddr >> 8);
+	pbuf[1] = (subaddr & 0xff);
+	pbuf[2] = data;
+
+	msgs[0].len = 3;
+	msgs[0].addr = client->addr;
+
+	if (unlikely(subaddr == OV2732_SWRESET))
+		msgs[0].flags = client->flags | I2C_M_IGNORE_NAK;
+	else
+		msgs[0].flags = client->flags;
+
+	msgs[0].buf = pbuf;
+	rval = i2c_transfer(client->adapter, msgs, 1);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x:0x%x]\n", rval, subaddr, data);
+		return rval;
+	}
+
+	return 0;
+}
+
+static int ov2732_write_reg2(struct vin_device *vdev, u32 subaddr, u32 data)
+{
+	int rval;
+	struct ov2732_priv *ov2732;
+	struct i2c_client *client;
+	struct i2c_msg msgs[1];
+	u8 pbuf[4];
+
+	ov2732 = (struct ov2732_priv *)vdev->priv;
+	client = ov2732->control_data;
+
+	pbuf[0] = (subaddr >> 8);
+	pbuf[1] = (subaddr & 0xff);
+	pbuf[2] = data >> 8;
+	pbuf[3] = data & 0xff;
+
+	msgs[0].len = 4;
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].buf = pbuf;
+
+	rval = i2c_transfer(client->adapter, msgs, 1);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x:0x%x]\n", rval, subaddr, data);
+		return rval;
+	}
+
+	return 0;
+}
+
+static int ov2732_read_reg(struct vin_device *vdev, u32 subaddr, u32 *data)
+{
+	int rval = 0;
+	struct ov2732_priv *ov2732;
+	struct i2c_client *client;
+	struct i2c_msg msgs[2];
+	u8 pbuf0[2];
+	u8 pbuf[1];
+
+	ov2732 = (struct ov2732_priv *)vdev->priv;
+	client = ov2732->control_data;
+
+	pbuf0[0] = (subaddr >> 8);
+	pbuf0[1] = (subaddr & 0xff);
+
+	msgs[0].len = 2;
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].buf = pbuf0;
+
+	msgs[1].addr = client->addr;
+	msgs[1].flags = client->flags | I2C_M_RD;
+	msgs[1].buf = pbuf;
+	msgs[1].len = 1;
+
+	rval = i2c_transfer(client->adapter, msgs, 2);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x]\n", rval, subaddr);
+		return rval;
+	}
+
+	*data = pbuf[0];
+
+	return 0;
+}
+
+static int ov2732_set_vin_mode(struct vin_device *vdev, struct vin_video_format *format)
+{
+	struct vin_device_config ov2732_config;
+
+	memset(&ov2732_config, 0, sizeof(ov2732_config));
+
+	ov2732_config.interface_type = SENSOR_PARALLEL_LVCMOS;
+	ov2732_config.input_mode = SENSOR_RGB_1PIX;
+
+	ov2732_config.plvcmos_cfg.vs_hs_polarity = SENSOR_VS_LOW | SENSOR_HS_HIGH;
+	ov2732_config.plvcmos_cfg.data_edge = SENSOR_DATA_RISING_EDGE;
+	ov2732_config.plvcmos_cfg.paralle_sync_type = SENSOR_PARALLEL_SYNC_601;
+
+	ov2732_config.cap_win.x = format->def_start_x;
+	ov2732_config.cap_win.y = format->def_start_y;
+	ov2732_config.cap_win.width = format->def_width;
+	ov2732_config.cap_win.height = format->def_height;
+
+	ov2732_config.sensor_id	= GENERIC_SENSOR;
+	ov2732_config.input_format	= AMBA_VIN_INPUT_FORMAT_RGB_RAW;
+	ov2732_config.bayer_pattern	= format->bayer_pattern;
+	ov2732_config.video_format	= format->format;
+	ov2732_config.bit_resolution	= format->bits;
+
+	return ambarella_set_vin_config(vdev, &ov2732_config);
+}
+
+static void ov2732_sw_reset(struct vin_device *vdev)
+{
+	ov2732_write_reg(vdev, OV2732_SWRESET, 0x01);
+	msleep(5);
+}
+
+static int ov2732_init_device(struct vin_device *vdev)
+{
+	ov2732_sw_reset(vdev);
+	return 0;
+}
+
+static void ov2732_start_streaming(struct vin_device *vdev)
+{
+	ov2732_write_reg(vdev, OV2732_STANDBY, 0x01); /* streaming */
+}
+
+static int ov2732_get_line_time(struct vin_device *vdev)
+{
+	u64 h_clks;
+	struct ov2732_priv *pinfo = (struct ov2732_priv *)vdev->priv;
+
+	h_clks = (u64)pinfo->line_length * 512000000;
+	h_clks = DIV64_CLOSEST(h_clks, vdev->cur_pll->pixelclk);
+
+	vdev->cur_format->line_time = (u32)h_clks;
+
+	return 0;
+}
+
+static int ov2732_update_hv_info(struct vin_device *vdev)
+{
+	struct ov2732_priv *pinfo = (struct ov2732_priv *)vdev->priv;
+	u32 data_h, data_l;
+
+	ov2732_read_reg(vdev, OV2732_HTS_MSB, &data_h);
+	ov2732_read_reg(vdev, OV2732_HTS_LSB, &data_l);
+	pinfo->line_length = (data_h<<8) + data_l;
+	if (unlikely(!pinfo->line_length)) {
+		vin_error("line length is 0!\n");
+		return -EIO;
+	}
+
+	ov2732_read_reg(vdev, OV2732_VTS_MSB, &data_h);
+	ov2732_read_reg(vdev, OV2732_VTS_LSB, &data_l);
+	pinfo->frame_length_lines = (data_h<<8) + data_l;
+
+	vin_debug("line_length:%d, frame_length_lines:%d\n",
+		pinfo->line_length, pinfo->frame_length_lines);
+
+	return 0;
+}
+
+static int ov2732_set_format(struct vin_device *vdev, struct vin_video_format *format)
+{
+	int rval;
+	struct vin_reg_16_8 *regs;
+	int i, regs_num;
+
+	regs = ov2732_share_regs;
+	regs_num = ARRAY_SIZE(ov2732_share_regs);
+	for (i = 0; i < regs_num; i++)
+		ov2732_write_reg(vdev, regs[i].addr, regs[i].data);
+
+	regs = ov2732_mode_regs[format->device_mode];
+	regs_num = ARRAY_SIZE(ov2732_mode_regs[format->device_mode]);
+	for (i = 0; i < regs_num; i++)
+		ov2732_write_reg(vdev, regs[i].addr, regs[i].data);
+
+	rval = ov2732_update_hv_info(vdev);
+	if (rval < 0)
+		return rval;
+
+	ov2732_get_line_time(vdev);
+
+	/* Enable Streaming */
+	ov2732_start_streaming(vdev);
+
+	/* communicate with IAV */
+	rval = ov2732_set_vin_mode(vdev, format);
+	if (rval < 0)
+		return rval;
+
+	return 0;
+}
+
+static int ov2732_set_hold_mode(struct vin_device *vdev, u32 hold_mode)
+{
+	if (hold_mode)
+		ov2732_write_reg(vdev, OV2732_GRP_ACCESS, 0x00);
+	else {
+		ov2732_write_reg(vdev, OV2732_GRP_ACCESS, 0x10);
+		ov2732_write_reg(vdev, OV2732_GRP_ACCESS, 0xA0);
+	}
+
+	return 0;
+}
+
+static int ov2732_set_shutter_row(struct vin_device *vdev, u32 row)
+{
+	struct ov2732_priv *pinfo = (struct ov2732_priv *)vdev->priv;
+	u64 exposure_lines;
+	u32 num_line, min_line, max_line;
+	int rval = 0;
+
+	num_line = row;
+
+	/* FIXME: shutter width: 4 ~ (Frame format(V) - 4) */
+	min_line = 4;
+	max_line = pinfo->frame_length_lines - 4;
+	num_line = clamp(num_line, min_line, max_line);
+
+	num_line <<= 4; /* the register value should be exposure time * 16 */
+	ov2732_write_reg2(vdev, OV2732_L_EXPO_HSB, (num_line >> 8) & 0x0FFF);
+	ov2732_write_reg(vdev, OV2732_L_EXPO_LSB, num_line & 0xFF);
+	num_line >>= 4;
+
+	exposure_lines = num_line;
+	exposure_lines = exposure_lines * (u64)pinfo->line_length * 512000000;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, vdev->cur_pll->pixelclk);
+
+	vdev->shutter_time = (u32)exposure_lines;
+	vin_debug("shutter_time:%d, row:%d\n", vdev->shutter_time, num_line);
+
+	return rval;
+}
+
+static int ov2732_shutter2row(struct vin_device *vdev, u32 *shutter_time)
+{
+	u64 exposure_lines;
+	int rval = 0;
+	struct ov2732_priv *pinfo = (struct ov2732_priv *)vdev->priv;
+
+	/* for fast boot, it may call set shutter time directly, so we must read line length/frame line */
+	if (unlikely(!pinfo->line_length)) {
+		rval = ov2732_update_hv_info(vdev);
+		if (rval < 0)
+			return rval;
+	}
+
+	exposure_lines = (*shutter_time) * (u64)vdev->cur_pll->pixelclk;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, pinfo->line_length);
+	exposure_lines = DIV64_CLOSEST(exposure_lines, 512000000);
+
+	*shutter_time = exposure_lines;
+
+	return rval;
+}
+
+static int ov2732_set_fps(struct vin_device *vdev, int fps)
+{
+	struct ov2732_priv *pinfo = (struct ov2732_priv *)vdev->priv;
+	u64 pixelclk, v_lines, vb_time;
+
+	pixelclk = vdev->cur_pll->pixelclk;
+
+	v_lines = fps * pixelclk;
+	v_lines = DIV64_CLOSEST(v_lines, pinfo->line_length);
+	v_lines = DIV64_CLOSEST(v_lines, 512000000);
+	ov2732_write_reg2(vdev, OV2732_VTS_MSB, v_lines & 0xFFFF);
+
+	pinfo->frame_length_lines = v_lines;
+
+	v_lines = pinfo->frame_length_lines - vdev->cur_format->height;
+	vb_time = pinfo->line_length * (u64)v_lines * 1000000000;
+	vb_time = DIV64_CLOSEST(vb_time, pixelclk);
+	vdev->cur_format->vb_time = vb_time;
+
+	return 0;
+}
+
+static int ov2732_set_agc_index(struct vin_device *vdev, int agc_idx)
+{
+	if (agc_idx > OV2732_GAIN_MAXDB) {
+		vin_warn("agc index %d exceeds maximum %d\n", agc_idx, OV2732_GAIN_MAXDB);
+		agc_idx = OV2732_GAIN_MAXDB;
+	}
+
+	/* Analog Gain */
+	ov2732_write_reg2(vdev, OV2732_L_AGAIN_MSB, OV2732_GAIN_TABLE[agc_idx][OV2732_GAIN_COL_AGAIN]);
+	/* Digital Gain */
+	ov2732_write_reg2(vdev, OV2732_L_DGAIN_MSB, OV2732_GAIN_TABLE[agc_idx][OV2732_GAIN_COL_DGAIN]);
+
+	return 0;
+}
+
+static int ov2732_set_mirror_mode(struct vin_device *vdev,
+	struct vindev_mirror *mirror_mode)
+{
+	int rval = 0;
+	u32 tmp_reg, bayer_pattern, v_flip = 0, h_mirror = 0;
+
+	switch (mirror_mode->pattern) {
+	case VINDEV_MIRROR_AUTO:
+		return 0;
+
+	case VINDEV_MIRROR_HORRIZONTALLY_VERTICALLY:
+		v_flip = OV2732_V_FLIP;
+		h_mirror = OV2732_H_MIRROR;
+		bayer_pattern = VINDEV_BAYER_PATTERN_BG;
+		break;
+
+	case VINDEV_MIRROR_HORRIZONTALLY:
+		v_flip = 0;
+		h_mirror = OV2732_H_MIRROR;
+		bayer_pattern = VINDEV_BAYER_PATTERN_BG;
+		break;
+
+	case VINDEV_MIRROR_VERTICALLY:
+		v_flip = OV2732_V_FLIP;
+		h_mirror = 0;
+		bayer_pattern = VINDEV_BAYER_PATTERN_BG;
+		break;
+
+	case VINDEV_MIRROR_NONE:
+		v_flip = 0;
+		h_mirror = 0;
+		bayer_pattern = VINDEV_BAYER_PATTERN_BG;
+		break;
+
+	default:
+		vin_error("do not support cmd mirror mode\n");
+		return -EINVAL;
+	}
+
+	ov2732_read_reg(vdev, OV2732_FORMAT1, &tmp_reg);
+	tmp_reg &= (~OV2732_V_FLIP);
+	tmp_reg |= OV2732_H_MIRROR;
+	tmp_reg |= v_flip;
+	tmp_reg ^= h_mirror;
+	ov2732_write_reg(vdev, OV2732_FORMAT1, tmp_reg);
+
+	if (mirror_mode->bayer_pattern == VINDEV_BAYER_PATTERN_AUTO)
+		mirror_mode->bayer_pattern = bayer_pattern;
+
+	return rval;
+}
+
+static int ov2732_get_chip_status(struct vin_device *vdev,
+	struct vindev_chip_status *chip_status)
+{
+	u32 tmp_reg;
+
+	ov2732_read_reg(vdev, OV2732_TPM_TRIGGER, &tmp_reg);
+	tmp_reg |= 0x01;
+	ov2732_write_reg(vdev, OV2732_TPM_TRIGGER, tmp_reg);
+	/* wait some time to read temperature */
+	msleep(5);
+	ov2732_read_reg(vdev, OV2732_TPM_READ, &tmp_reg);
+
+	chip_status->temperature = (tmp_reg & 0xFF) - OV2732_TPM_OFFSET;
+
+	return 0;
+}
+
+static int ov2732_get_eis_info(struct vin_device *vdev,
+	struct vindev_eisinfo *eis_info)
+{
+	eis_info->sensor_cell_width = 200;/* 2.0 um */
+	eis_info->sensor_cell_height = 200;/* 2.0 um */
+	eis_info->column_bin = 1;
+	eis_info->row_bin = 1;
+	eis_info->vb_time = vdev->cur_format->vb_time;
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int ov2732_suspend(struct vin_device *vdev)
+{
+	u32 i, tmp;
+
+	for (i = 0; i < ARRAY_SIZE(pm_regs); i++) {
+		ov2732_read_reg(vdev, pm_regs[i].addr, &tmp);
+		pm_regs[i].data = (u8)tmp;
+	}
+
+	return 0;
+}
+
+static int ov2732_resume(struct vin_device *vdev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(pm_regs); i++)
+		ov2732_write_reg(vdev, pm_regs[i].addr, pm_regs[i].data);
+
+	return 0;
+}
+#endif
+
+static struct vin_ops ov2732_ops = {
+	.init_device		= ov2732_init_device,
+	.set_format		= ov2732_set_format,
+	.set_shutter_row	= ov2732_set_shutter_row,
+	.shutter2row		= ov2732_shutter2row,
+	.set_frame_rate	= ov2732_set_fps,
+	.set_agc_index		= ov2732_set_agc_index,
+	.set_mirror_mode	= ov2732_set_mirror_mode,
+	.set_hold_mode		= ov2732_set_hold_mode,
+	.get_chip_status	= ov2732_get_chip_status,
+	.get_eis_info		= ov2732_get_eis_info,
+	.read_reg			= ov2732_read_reg,
+	.write_reg		= ov2732_write_reg,
+#ifdef CONFIG_PM
+	.suspend		= ov2732_suspend,
+	.resume			= ov2732_resume,
+#endif
+};
+
+/* ========================================================================== */
+static int ov2732_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	int i, rval = 0;
+	struct vin_device *vdev;
+	struct ov2732_priv *ov2732;
+	u32 cid_l, cid_m;
+
+	vdev = ambarella_vin_create_device(client->name,
+		SENSOR_OV2732, sizeof(struct ov2732_priv));
+	if (!vdev)
+		return -ENOMEM;
+
+	vdev->intf_id = 0;
+	vdev->dev_type = VINDEV_TYPE_SENSOR;
+	vdev->sub_type = VINDEV_SUBTYPE_CMOS;
+	vdev->default_mode = AMBA_VIDEO_MODE_1080P;
+	vdev->default_hdr_mode = AMBA_VIDEO_LINEAR_MODE;
+	vdev->agc_db_max = 0x24000000;  /* 36dB */
+	vdev->agc_db_min = 0x00000000;  /* 0dB */
+	vdev->agc_db_step = 0x00180000; /* 0.09375dB */
+
+	i2c_set_clientdata(client, vdev);
+
+	ov2732 = (struct ov2732_priv *)vdev->priv;
+	ov2732->control_data = client;
+
+	if (bayer_pattern != VINDEV_BAYER_PATTERN_AUTO) {
+		if (bayer_pattern > VINDEV_BAYER_PATTERN_GB) {
+			vin_error("invalid bayer pattern:%d\n", bayer_pattern);
+			return -EINVAL;
+		} else {
+			for (i = 0; i < ARRAY_SIZE(ov2732_formats); i++)
+				ov2732_formats[i].default_bayer_pattern = bayer_pattern;
+		}
+	}
+
+	rval = ambarella_vin_register_device(vdev, &ov2732_ops,
+		ov2732_formats, ARRAY_SIZE(ov2732_formats),
+		ov2732_plls, ARRAY_SIZE(ov2732_plls));
+	if (rval < 0)
+		goto ov2732_probe_err;
+
+	/* query sensor id */
+	ov2732_read_reg(vdev, OV2732_CID_M, &cid_m);
+	ov2732_read_reg(vdev, OV2732_CID_L, &cid_l);
+	vin_info("OV2732 init(parallel), sensor ID: 0x%x\n", (cid_m<<8)+cid_l);
+
+	return 0;
+
+ov2732_probe_err:
+	ambarella_vin_free_device(vdev);
+	return rval;
+}
+
+static int ov2732_remove(struct i2c_client *client)
+{
+	struct vin_device *vdev;
+
+	vdev = (struct vin_device *)i2c_get_clientdata(client);
+	ambarella_vin_unregister_device(vdev);
+	ambarella_vin_free_device(vdev);
+
+	return 0;
+}
+
+static const struct i2c_device_id ov2732_idtable[] = {
+	{ "ov2732", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ov2732_idtable);
+
+static struct i2c_driver i2c_driver_ov2732 = {
+	.driver = {
+		.name	= "ov2732",
+	},
+
+	.id_table	= ov2732_idtable,
+	.probe		= ov2732_probe,
+	.remove		= ov2732_remove,
+
+};
+
+static int __init ov2732_init(void)
+{
+	int bus, addr, rval;
+
+	bus = bus_addr >> 16;
+	addr = bus_addr & 0xffff;
+
+	rval = ambpriv_i2c_update_addr("ov2732", bus, addr);
+	if (rval < 0)
+		return rval;
+
+	rval = i2c_add_driver(&i2c_driver_ov2732);
+	if (rval < 0)
+		return rval;
+
+	return 0;
+}
+
+static void __exit ov2732_exit(void)
+{
+	i2c_del_driver(&i2c_driver_ov2732);
+}
+
+module_init(ov2732_init);
+module_exit(ov2732_exit);
+
+MODULE_DESCRIPTION("OV2732 1/4-Inch, 1920x1080, 2-Megapixel CMOS Digital Image Sensor");
+MODULE_AUTHOR("Hao Zeng <haozeng@ambarella.com>");
+MODULE_LICENSE("Proprietary");
+
diff --git a/drivers/vin/sensors/omnivision_ov2732_parallel/ov2732.h b/drivers/vin/sensors/omnivision_ov2732_parallel/ov2732.h
new file mode 100644
index 0000000..7a47490
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2732_parallel/ov2732.h
@@ -0,0 +1,73 @@
+/*
+ * Filename : ov2732.h
+ *
+ * History:
+ *    2016/12/16 - [Hao Zeng] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __OV2732_H__
+#define __OV2732_H__
+
+#define OV2732_STANDBY			0x0100
+#define OV2732_SWRESET			0x0103
+
+#define OV2732_CID_M			0x300B
+#define OV2732_CID_L			0x300C
+
+#define OV2732_GRP_ACCESS		0x3208
+
+#define OV2732_HTS_MSB			0x380C
+#define OV2732_HTS_LSB			0x380D
+#define OV2732_VTS_MSB			0x380E
+#define OV2732_VTS_LSB			0x380F
+
+#define OV2732_L_EXPO_HSB		0x3500
+#define OV2732_L_EXPO_MSB		0x3501
+#define OV2732_L_EXPO_LSB		0x3502
+
+#define OV2732_L_AGAIN_MSB		0x3508
+#define OV2732_L_AGAIN_LSB		0x3509
+#define OV2732_L_DGAIN_MSB		0x350A
+#define OV2732_L_DGAIN_LSB		0x350B
+
+#define OV2732_MIPI_CTRL00		0x4800
+
+#define OV2732_MIPI_GATE		(1<<5)
+
+#define OV2732_FORMAT1		0x3820
+
+#define OV2732_V_FLIP			(1<<4)
+#define OV2732_H_MIRROR		(1<<3)
+#define OV2732_MIRROR_MASK	(OV2732_H_MIRROR + OV2732_V_FLIP)
+
+#define OV2732_TPM_TRIGGER	0x4D12
+#define OV2732_TPM_READ		0x4D13
+#define OV2732_TPM_OFFSET	64
+
+#endif /* __OV2732_H__ */
+
diff --git a/drivers/vin/sensors/omnivision_ov2732_parallel/ov2732_table.c b/drivers/vin/sensors/omnivision_ov2732_parallel/ov2732_table.c
new file mode 100644
index 0000000..2097f2d
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2732_parallel/ov2732_table.c
@@ -0,0 +1,891 @@
+/*
+ * Filename : ov2732_table.c
+ *
+ * History:
+ *    2016/12/16 - [Hao Zeng] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+static struct vin_video_pll ov2732_plls[] = {
+	{0, 24000000, 45000000},
+};
+
+static struct vin_reg_16_8 ov2732_mode_regs[][16] = {
+	{	/* 1080p */
+		{0x3801, 0x00},
+		{0x3802, 0x00},
+		{0x3803, 0x04},
+		{0x3804, 0x07},
+		{0x3805, 0x8f},
+		{0x3806, 0x04},
+		{0x3807, 0x43},
+		{0x3808, 0x07},
+		{0x3809, 0x80},
+		{0x380a, 0x04},
+		{0x380b, 0x38},
+		{0x380c, 0x04},
+		{0x380d, 0xf0},
+		{0x380e, 0x04},
+		{0x380f, 0xa0},
+	},
+	{	/* 720p */
+		{0x3800, 0x01},
+		{0x3801, 0x40},
+		{0x3802, 0x00},
+		{0x3803, 0xb8},
+		{0x3804, 0x06},
+		{0x3805, 0x4f},
+		{0x3806, 0x03},
+		{0x3807, 0x8f},
+		{0x3808, 0x05},
+		{0x3809, 0x00},
+		{0x380a, 0x02},
+		{0x380b, 0xd0},
+		{0x380c, 0x04},
+		{0x380d, 0xf0},
+		{0x380e, 0x03},
+		{0x380f, 0x16},
+	},
+};
+
+static struct vin_video_format ov2732_formats[] = {
+	{
+		.video_mode = AMBA_VIDEO_MODE_1080P,
+		.def_start_x = 0,
+		.def_start_y = 0,
+		.def_width = 1920,
+		.def_height = 1080,
+		/* sensor mode */
+		.device_mode = 0,
+		.pll_idx = 0,
+		.width = 1920,
+		.height = 1080,
+		.format = AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type = AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits = AMBA_VIDEO_BITS_12,
+		.ratio = AMBA_VIDEO_RATIO_16_9,
+		.max_fps = AMBA_VIDEO_FPS_30,
+		.default_fps = AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern = VINDEV_BAYER_PATTERN_BG,
+	},
+	{
+		.video_mode = AMBA_VIDEO_MODE_720P,
+		.def_start_x = 0,
+		.def_start_y = 0,
+		.def_width = 1280,
+		.def_height = 720,
+		/* sensor mode */
+		.device_mode = 1,
+		.pll_idx = 0,
+		.width = 1280,
+		.height = 720,
+		.format = AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type = AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits = AMBA_VIDEO_BITS_12,
+		.ratio = AMBA_VIDEO_RATIO_16_9,
+		.max_fps = AMBA_VIDEO_FPS(45),
+		.default_fps = AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern = VINDEV_BAYER_PATTERN_BG,
+	},
+};
+
+static struct vin_reg_16_8 ov2732_share_regs[] = {
+	/* DVP_1920x1080_30FPS_90M-out_24M-in_10bits */
+	{0x0103, 0x01},
+	{0x0305, 0x3c},
+	{0x0307, 0x00},
+	{0x0308, 0x03},
+	{0x0309, 0x06},
+	{0x0327, 0x07},
+	{0x3016, 0x3e},
+	{0x3000, 0x0f},
+	{0x3001, 0xff},
+	{0x3002, 0xfe},
+	{0x3013, 0x00},
+	{0x301f, 0xf0},
+	{0x3023, 0xf0},
+	{0x3020, 0x93},
+	{0x3022, 0x51},
+	{0x3106, 0x11},
+	{0x3107, 0x01},
+	{0x3500, 0x00},
+	{0x3501, 0x40},
+	{0x3502, 0x00},
+	{0x3503, 0x88},
+	{0x3505, 0x83},
+	{0x3508, 0x01},
+	{0x3509, 0x80},
+	{0x350a, 0x04},
+	{0x350b, 0x00},
+	{0x350c, 0x00},
+	{0x350d, 0x80},
+	{0x350e, 0x04},
+	{0x350f, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x00},
+	{0x3512, 0x20},
+	{0x3600, 0x55},
+	{0x3601, 0x54},
+	{0x3612, 0xb5},
+	{0x3613, 0xb3},
+	{0x3616, 0x83},
+	{0x3621, 0x00},
+	{0x3624, 0x06},
+	{0x3642, 0x88},
+	{0x3660, 0x00},
+	{0x3661, 0x00},
+	{0x366a, 0x64},
+	{0x366c, 0x00},
+	{0x366e, 0x44},
+	{0x366f, 0x4f},
+	{0x3677, 0x11},
+	{0x3678, 0x11},
+	{0x3680, 0xff},
+	{0x3681, 0xd2},
+	{0x3682, 0xa9},
+	{0x3683, 0x91},
+	{0x3684, 0x8a},
+	{0x3620, 0x80},
+	{0x3662, 0x10},
+	{0x3663, 0x27},
+	{0x3665, 0xa1},
+	{0x3667, 0xa6},
+	{0x3674, 0x00},
+	{0x373d, 0x24},
+	{0x3741, 0x28},
+	{0x3743, 0x28},
+	{0x3745, 0x28},
+	{0x3747, 0x28},
+	{0x3748, 0x00},
+	{0x3749, 0x78},
+	{0x374a, 0x00},
+	{0x374b, 0x78},
+	{0x374c, 0x00},
+	{0x374d, 0x78},
+	{0x374e, 0x00},
+	{0x374f, 0x78},
+	{0x3766, 0x12},
+	{0x37e0, 0x00},
+	{0x37e6, 0x04},
+	{0x37e5, 0x04},
+	{0x37e1, 0x04},
+	{0x3737, 0x04},
+	{0x37d0, 0x0a},
+	{0x37d8, 0x04},
+	{0x37e2, 0x08},
+	{0x3739, 0x10},
+	{0x37e4, 0x18},
+	{0x37e3, 0x04},
+	{0x37d9, 0x10},
+	{0x4040, 0x04},
+	{0x4041, 0x0f},
+	{0x4008, 0x00},
+	{0x4009, 0x0d},
+	{0x37a1, 0x14},
+	{0x37a8, 0x16},
+	{0x37ab, 0x10},
+	{0x37c2, 0x04},
+	{0x3705, 0x00},
+	{0x3706, 0x28},
+	{0x370a, 0x00},
+	{0x370b, 0x78},
+	{0x3714, 0x24},
+	{0x371a, 0x1e},
+	{0x372a, 0x03},
+	{0x3756, 0x00},
+	{0x3757, 0x0e},
+	{0x377b, 0x00},
+	{0x377c, 0x0c},
+	{0x377d, 0x20},
+	{0x3790, 0x28},
+	{0x3791, 0x78},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x04},
+	{0x3804, 0x07},
+	{0x3805, 0x8f},
+	{0x3806, 0x04},
+	{0x3807, 0x43},
+	{0x3808, 0x07},
+	{0x3809, 0x80},
+	{0x380a, 0x04},
+	{0x380b, 0x38},
+	{0x380c, 0x04},
+	{0x380d, 0xf0},
+	{0x380e, 0x04},
+	{0x380f, 0xa0},
+	{0x3811, 0x08},
+	{0x3813, 0x04},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x01},
+	{0x3817, 0x01},
+	{0x381d, 0x40},
+	{0x381e, 0x02},
+	{0x3820, 0x88},
+	{0x3821, 0x00},
+	{0x3822, 0x04},
+	{0x3835, 0x00},
+	{0x4303, 0x19},
+	{0x4304, 0x19},
+	{0x4305, 0x03},
+	{0x4306, 0x81},
+	{0x4503, 0x00},
+	{0x4508, 0x14},
+	{0x450a, 0x00},
+	{0x450b, 0x40},
+	{0x4833, 0x08},
+	{0x5000, 0xa9},
+	{0x5001, 0x09},
+	{0x3b00, 0x00},
+	{0x3b02, 0x00},
+	{0x3b03, 0x00},
+	{0x3c80, 0x08},
+	{0x3c82, 0x00},
+	{0x3c83, 0xb1},
+	{0x3c87, 0x08},
+	{0x3c8c, 0x10},
+	{0x3c8d, 0x00},
+	{0x3c90, 0x00},
+	{0x3c91, 0x00},
+	{0x3c92, 0x00},
+	{0x3c93, 0x00},
+	{0x3c94, 0x00},
+	{0x3c95, 0x00},
+	{0x3c96, 0x00},
+	{0x3c97, 0x00},
+	{0x3c98, 0x00},
+	{0x4000, 0xf3},
+	{0x4001, 0x60},
+	{0x4002, 0x00},
+	{0x4003, 0x40},
+	{0x4090, 0x14},
+	{0x4601, 0x10},
+	{0x4701, 0x00},
+	{0x4708, 0x09},
+	{0x470a, 0x00},
+	{0x470b, 0x40},
+	{0x470c, 0x85},
+	{0x480c, 0x12},
+	{0x4710, 0x06},
+	{0x4711, 0x00},
+	{0x4837, 0x12},
+	{0x4800, 0x00},
+	{0x4c01, 0x00},
+	{0x5036, 0x00},
+	{0x5037, 0x00},
+	{0x580b, 0x0f},
+	{0x4903, 0x80},
+	{0x4003, 0x40},
+	{0x5000, 0xf9},
+	{0x5200, 0x1b},
+	{0x4837, 0x16},
+	{0x380e, 0x04},
+	{0x380f, 0xa0},
+	{0x3500, 0x00},
+	{0x3501, 0x49},
+	{0x3502, 0x80},
+	{0x3508, 0x02},
+	{0x3509, 0x80},
+	{0x3d8c, 0x11},
+	{0x3d8d, 0xf0},
+	{0x5180, 0x00},
+	{0x5181, 0x10},
+	{0x36a0, 0x16},
+	{0x36a1, 0x50},
+	{0x36a2, 0x60},
+	{0x36a3, 0x80},
+	{0x36a4, 0x00},
+	{0x36a5, 0xa0},
+	{0x36a6, 0x00},
+	{0x36a7, 0x50},
+	{0x36a8, 0x00},
+	{0x36a9, 0x50},
+	{0x36aa, 0x00},
+	{0x36ab, 0x50},
+	{0x36ac, 0x00},
+	{0x36ad, 0x50},
+	{0x36ae, 0x00},
+	{0x36af, 0x50},
+	{0x36b0, 0x00},
+	{0x36b1, 0x50},
+	{0x36b2, 0x00},
+	{0x36b3, 0x50},
+	{0x36b4, 0x00},
+	{0x36b5, 0x50},
+	{0x36b9, 0xee},
+	{0x36ba, 0xee},
+	{0x36bb, 0xee},
+	{0x36bc, 0xee},
+	{0x36bd, 0x0e},
+	{0x36b6, 0x08},
+	{0x36b7, 0x08},
+	{0x36b8, 0x10},
+	{0x0100, 0x01},
+};
+
+#ifdef CONFIG_PM
+static struct vin_reg_16_8 pm_regs[] = {
+	{OV2732_L_EXPO_HSB, 0x00},
+	{OV2732_L_EXPO_MSB, 0x00},
+	{OV2732_L_EXPO_LSB, 0x00},
+	{OV2732_L_AGAIN_MSB, 0x00},
+	{OV2732_L_AGAIN_LSB, 0x00},
+	{OV2732_L_DGAIN_MSB, 0x00},
+	{OV2732_L_DGAIN_LSB, 0x00},
+};
+#endif
+
+/* Gain table */
+#define OV2732_GAIN_ROWS               (513)
+#define OV2732_GAIN_COLS               (2)
+#define OV2732_GAIN_MAXDB              (512)
+
+#define OV2732_GAIN_COL_AGAIN          (0)
+#define OV2732_GAIN_COL_DGAIN          (1)
+
+static const u16 OV2732_GAIN_TABLE[OV2732_GAIN_ROWS][OV2732_GAIN_COLS] = {
+	{0x0080, 0x0400}, /* index:0, gain:0.00000db -> x1.000000, again:x1.000000, dgain:x1.000000 */
+	{0x0081, 0x0400}, /* index:1, gain:0.09375db -> x1.010852, again:x1.010852, dgain:x1.000000 */
+	{0x0082, 0x0400}, /* index:2, gain:0.18750db -> x1.021821, again:x1.021821, dgain:x1.000000 */
+	{0x0084, 0x0400}, /* index:3, gain:0.28125db -> x1.032910, again:x1.032910, dgain:x1.000000 */
+	{0x0085, 0x0400}, /* index:4, gain:0.37500db -> x1.044119, again:x1.044119, dgain:x1.000000 */
+	{0x0087, 0x0400}, /* index:5, gain:0.46875db -> x1.055450, again:x1.055450, dgain:x1.000000 */
+	{0x0088, 0x0400}, /* index:6, gain:0.56250db -> x1.066903, again:x1.066903, dgain:x1.000000 */
+	{0x008a, 0x0400}, /* index:7, gain:0.65625db -> x1.078481, again:x1.078481, dgain:x1.000000 */
+	{0x008b, 0x0400}, /* index:8, gain:0.75000db -> x1.090184, again:x1.090184, dgain:x1.000000 */
+	{0x008d, 0x0400}, /* index:9, gain:0.84375db -> x1.102015, again:x1.102015, dgain:x1.000000 */
+	{0x008e, 0x0400}, /* index:10, gain:0.93750db -> x1.113974, again:x1.113974, dgain:x1.000000 */
+	{0x0090, 0x0400}, /* index:11, gain:1.03125db -> x1.126063, again:x1.126063, dgain:x1.000000 */
+	{0x0091, 0x0400}, /* index:12, gain:1.12500db -> x1.138282, again:x1.138282, dgain:x1.000000 */
+	{0x0093, 0x0400}, /* index:13, gain:1.21875db -> x1.150635, again:x1.150635, dgain:x1.000000 */
+	{0x0094, 0x0400}, /* index:14, gain:1.31250db -> x1.163121, again:x1.163121, dgain:x1.000000 */
+	{0x0096, 0x0400}, /* index:15, gain:1.40625db -> x1.175743, again:x1.175743, dgain:x1.000000 */
+	{0x0098, 0x0400}, /* index:16, gain:1.50000db -> x1.188502, again:x1.188502, dgain:x1.000000 */
+	{0x0099, 0x0400}, /* index:17, gain:1.59375db -> x1.201400, again:x1.201400, dgain:x1.000000 */
+	{0x009b, 0x0400}, /* index:18, gain:1.68750db -> x1.214437, again:x1.214437, dgain:x1.000000 */
+	{0x009d, 0x0400}, /* index:19, gain:1.78125db -> x1.227616, again:x1.227616, dgain:x1.000000 */
+	{0x009e, 0x0400}, /* index:20, gain:1.87500db -> x1.240938, again:x1.240938, dgain:x1.000000 */
+	{0x00a0, 0x0400}, /* index:21, gain:1.96875db -> x1.254404, again:x1.254404, dgain:x1.000000 */
+	{0x00a2, 0x0400}, /* index:22, gain:2.06250db -> x1.268017, again:x1.268017, dgain:x1.000000 */
+	{0x00a4, 0x0400}, /* index:23, gain:2.15625db -> x1.281777, again:x1.281777, dgain:x1.000000 */
+	{0x00a5, 0x0400}, /* index:24, gain:2.25000db -> x1.295687, again:x1.295687, dgain:x1.000000 */
+	{0x00a7, 0x0400}, /* index:25, gain:2.34375db -> x1.309747, again:x1.309747, dgain:x1.000000 */
+	{0x00a9, 0x0400}, /* index:26, gain:2.43750db -> x1.323960, again:x1.323960, dgain:x1.000000 */
+	{0x00ab, 0x0400}, /* index:27, gain:2.53125db -> x1.338328, again:x1.338328, dgain:x1.000000 */
+	{0x00ad, 0x0400}, /* index:28, gain:2.62500db -> x1.352851, again:x1.352851, dgain:x1.000000 */
+	{0x00af, 0x0400}, /* index:29, gain:2.71875db -> x1.367532, again:x1.367532, dgain:x1.000000 */
+	{0x00b0, 0x0400}, /* index:30, gain:2.81250db -> x1.382372, again:x1.382372, dgain:x1.000000 */
+	{0x00b2, 0x0400}, /* index:31, gain:2.90625db -> x1.397374, again:x1.397374, dgain:x1.000000 */
+	{0x00b4, 0x0400}, /* index:32, gain:3.00000db -> x1.412538, again:x1.412538, dgain:x1.000000 */
+	{0x00b6, 0x0400}, /* index:33, gain:3.09375db -> x1.427866, again:x1.427866, dgain:x1.000000 */
+	{0x00b8, 0x0400}, /* index:34, gain:3.18750db -> x1.443361, again:x1.443361, dgain:x1.000000 */
+	{0x00ba, 0x0400}, /* index:35, gain:3.28125db -> x1.459024, again:x1.459024, dgain:x1.000000 */
+	{0x00bc, 0x0400}, /* index:36, gain:3.37500db -> x1.474857, again:x1.474857, dgain:x1.000000 */
+	{0x00be, 0x0400}, /* index:37, gain:3.46875db -> x1.490862, again:x1.490862, dgain:x1.000000 */
+	{0x00c0, 0x0400}, /* index:38, gain:3.56250db -> x1.507041, again:x1.507041, dgain:x1.000000 */
+	{0x00c2, 0x0400}, /* index:39, gain:3.65625db -> x1.523395, again:x1.523395, dgain:x1.000000 */
+	{0x00c5, 0x0400}, /* index:40, gain:3.75000db -> x1.539927, again:x1.539927, dgain:x1.000000 */
+	{0x00c7, 0x0400}, /* index:41, gain:3.84375db -> x1.556638, again:x1.556638, dgain:x1.000000 */
+	{0x00c9, 0x0400}, /* index:42, gain:3.93750db -> x1.573530, again:x1.573530, dgain:x1.000000 */
+	{0x00cb, 0x0400}, /* index:43, gain:4.03125db -> x1.590606, again:x1.590606, dgain:x1.000000 */
+	{0x00cd, 0x0400}, /* index:44, gain:4.12500db -> x1.607867, again:x1.607867, dgain:x1.000000 */
+	{0x00d0, 0x0400}, /* index:45, gain:4.21875db -> x1.625315, again:x1.625315, dgain:x1.000000 */
+	{0x00d2, 0x0400}, /* index:46, gain:4.31250db -> x1.642952, again:x1.642952, dgain:x1.000000 */
+	{0x00d4, 0x0400}, /* index:47, gain:4.40625db -> x1.660782, again:x1.660782, dgain:x1.000000 */
+	{0x00d6, 0x0400}, /* index:48, gain:4.50000db -> x1.678804, again:x1.678804, dgain:x1.000000 */
+	{0x00d9, 0x0400}, /* index:49, gain:4.59375db -> x1.697022, again:x1.697022, dgain:x1.000000 */
+	{0x00db, 0x0400}, /* index:50, gain:4.68750db -> x1.715438, again:x1.715438, dgain:x1.000000 */
+	{0x00dd, 0x0400}, /* index:51, gain:4.78125db -> x1.734054, again:x1.734054, dgain:x1.000000 */
+	{0x00e0, 0x0400}, /* index:52, gain:4.87500db -> x1.752871, again:x1.752871, dgain:x1.000000 */
+	{0x00e2, 0x0400}, /* index:53, gain:4.96875db -> x1.771893, again:x1.771893, dgain:x1.000000 */
+	{0x00e5, 0x0400}, /* index:54, gain:5.06250db -> x1.791121, again:x1.791121, dgain:x1.000000 */
+	{0x00e7, 0x0400}, /* index:55, gain:5.15625db -> x1.810558, again:x1.810558, dgain:x1.000000 */
+	{0x00ea, 0x0400}, /* index:56, gain:5.25000db -> x1.830206, again:x1.830206, dgain:x1.000000 */
+	{0x00ec, 0x0400}, /* index:57, gain:5.34375db -> x1.850067, again:x1.850067, dgain:x1.000000 */
+	{0x00ef, 0x0400}, /* index:58, gain:5.43750db -> x1.870144, again:x1.870144, dgain:x1.000000 */
+	{0x00f1, 0x0400}, /* index:59, gain:5.53125db -> x1.890438, again:x1.890438, dgain:x1.000000 */
+	{0x00f4, 0x0400}, /* index:60, gain:5.62500db -> x1.910953, again:x1.910953, dgain:x1.000000 */
+	{0x00f7, 0x0400}, /* index:61, gain:5.71875db -> x1.931690, again:x1.931690, dgain:x1.000000 */
+	{0x00f9, 0x0400}, /* index:62, gain:5.81250db -> x1.952653, again:x1.952653, dgain:x1.000000 */
+	{0x00fc, 0x0400}, /* index:63, gain:5.90625db -> x1.973842, again:x1.973842, dgain:x1.000000 */
+	{0x00ff, 0x0400}, /* index:64, gain:6.00000db -> x1.995262, again:x1.995262, dgain:x1.000000 */
+	{0x0102, 0x0400}, /* index:65, gain:6.09375db -> x2.016915, again:x2.016915, dgain:x1.000000 */
+	{0x0104, 0x0400}, /* index:66, gain:6.18750db -> x2.038802, again:x2.038802, dgain:x1.000000 */
+	{0x0107, 0x0400}, /* index:67, gain:6.28125db -> x2.060927, again:x2.060927, dgain:x1.000000 */
+	{0x010a, 0x0400}, /* index:68, gain:6.37500db -> x2.083291, again:x2.083291, dgain:x1.000000 */
+	{0x010d, 0x0400}, /* index:69, gain:6.46875db -> x2.105899, again:x2.105899, dgain:x1.000000 */
+	{0x0110, 0x0400}, /* index:70, gain:6.56250db -> x2.128752, again:x2.128752, dgain:x1.000000 */
+	{0x0113, 0x0400}, /* index:71, gain:6.65625db -> x2.151852, again:x2.151852, dgain:x1.000000 */
+	{0x0116, 0x0400}, /* index:72, gain:6.75000db -> x2.175204, again:x2.175204, dgain:x1.000000 */
+	{0x0119, 0x0400}, /* index:73, gain:6.84375db -> x2.198809, again:x2.198809, dgain:x1.000000 */
+	{0x011c, 0x0400}, /* index:74, gain:6.93750db -> x2.222670, again:x2.222670, dgain:x1.000000 */
+	{0x011f, 0x0400}, /* index:75, gain:7.03125db -> x2.246790, again:x2.246790, dgain:x1.000000 */
+	{0x0122, 0x0400}, /* index:76, gain:7.12500db -> x2.271172, again:x2.271172, dgain:x1.000000 */
+	{0x0125, 0x0400}, /* index:77, gain:7.21875db -> x2.295818, again:x2.295818, dgain:x1.000000 */
+	{0x0129, 0x0400}, /* index:78, gain:7.31250db -> x2.320732, again:x2.320732, dgain:x1.000000 */
+	{0x012c, 0x0400}, /* index:79, gain:7.40625db -> x2.345916, again:x2.345916, dgain:x1.000000 */
+	{0x012f, 0x0400}, /* index:80, gain:7.50000db -> x2.371374, again:x2.371374, dgain:x1.000000 */
+	{0x0132, 0x0400}, /* index:81, gain:7.59375db -> x2.397107, again:x2.397107, dgain:x1.000000 */
+	{0x0136, 0x0400}, /* index:82, gain:7.68750db -> x2.423120, again:x2.423120, dgain:x1.000000 */
+	{0x0139, 0x0400}, /* index:83, gain:7.78125db -> x2.449416, again:x2.449416, dgain:x1.000000 */
+	{0x013c, 0x0400}, /* index:84, gain:7.87500db -> x2.475996, again:x2.475996, dgain:x1.000000 */
+	{0x0140, 0x0400}, /* index:85, gain:7.96875db -> x2.502865, again:x2.502865, dgain:x1.000000 */
+	{0x0143, 0x0400}, /* index:86, gain:8.06250db -> x2.530026, again:x2.530026, dgain:x1.000000 */
+	{0x0147, 0x0400}, /* index:87, gain:8.15625db -> x2.557482, again:x2.557482, dgain:x1.000000 */
+	{0x014a, 0x0400}, /* index:88, gain:8.25000db -> x2.585235, again:x2.585235, dgain:x1.000000 */
+	{0x014e, 0x0400}, /* index:89, gain:8.34375db -> x2.613289, again:x2.613289, dgain:x1.000000 */
+	{0x0152, 0x0400}, /* index:90, gain:8.43750db -> x2.641648, again:x2.641648, dgain:x1.000000 */
+	{0x0155, 0x0400}, /* index:91, gain:8.53125db -> x2.670315, again:x2.670315, dgain:x1.000000 */
+	{0x0159, 0x0400}, /* index:92, gain:8.62500db -> x2.699293, again:x2.699293, dgain:x1.000000 */
+	{0x015d, 0x0400}, /* index:93, gain:8.71875db -> x2.728585, again:x2.728585, dgain:x1.000000 */
+	{0x0161, 0x0400}, /* index:94, gain:8.81250db -> x2.758195, again:x2.758195, dgain:x1.000000 */
+	{0x0164, 0x0400}, /* index:95, gain:8.90625db -> x2.788127, again:x2.788127, dgain:x1.000000 */
+	{0x0168, 0x0400}, /* index:96, gain:9.00000db -> x2.818383, again:x2.818383, dgain:x1.000000 */
+	{0x016c, 0x0400}, /* index:97, gain:9.09375db -> x2.848968, again:x2.848968, dgain:x1.000000 */
+	{0x0170, 0x0400}, /* index:98, gain:9.18750db -> x2.879884, again:x2.879884, dgain:x1.000000 */
+	{0x0174, 0x0400}, /* index:99, gain:9.28125db -> x2.911136, again:x2.911136, dgain:x1.000000 */
+	{0x0178, 0x0400}, /* index:100, gain:9.37500db -> x2.942727, again:x2.942727, dgain:x1.000000 */
+	{0x017c, 0x0400}, /* index:101, gain:9.46875db -> x2.974661, again:x2.974661, dgain:x1.000000 */
+	{0x0180, 0x0400}, /* index:102, gain:9.56250db -> x3.006942, again:x3.006942, dgain:x1.000000 */
+	{0x0185, 0x0400}, /* index:103, gain:9.65625db -> x3.039572, again:x3.039572, dgain:x1.000000 */
+	{0x0189, 0x0400}, /* index:104, gain:9.75000db -> x3.072557, again:x3.072557, dgain:x1.000000 */
+	{0x018d, 0x0400}, /* index:105, gain:9.84375db -> x3.105900, again:x3.105900, dgain:x1.000000 */
+	{0x0191, 0x0400}, /* index:106, gain:9.93750db -> x3.139605, again:x3.139605, dgain:x1.000000 */
+	{0x0196, 0x0400}, /* index:107, gain:10.03125db -> x3.173675, again:x3.173675, dgain:x1.000000 */
+	{0x019a, 0x0400}, /* index:108, gain:10.12500db -> x3.208116, again:x3.208116, dgain:x1.000000 */
+	{0x019f, 0x0400}, /* index:109, gain:10.21875db -> x3.242930, again:x3.242930, dgain:x1.000000 */
+	{0x01a3, 0x0400}, /* index:110, gain:10.31250db -> x3.278121, again:x3.278121, dgain:x1.000000 */
+	{0x01a8, 0x0400}, /* index:111, gain:10.40625db -> x3.313695, again:x3.313695, dgain:x1.000000 */
+	{0x01ac, 0x0400}, /* index:112, gain:10.50000db -> x3.349654, again:x3.349654, dgain:x1.000000 */
+	{0x01b1, 0x0400}, /* index:113, gain:10.59375db -> x3.386004, again:x3.386004, dgain:x1.000000 */
+	{0x01b6, 0x0400}, /* index:114, gain:10.68750db -> x3.422749, again:x3.422749, dgain:x1.000000 */
+	{0x01ba, 0x0400}, /* index:115, gain:10.78125db -> x3.459892, again:x3.459892, dgain:x1.000000 */
+	{0x01bf, 0x0400}, /* index:116, gain:10.87500db -> x3.497438, again:x3.497438, dgain:x1.000000 */
+	{0x01c4, 0x0400}, /* index:117, gain:10.96875db -> x3.535391, again:x3.535391, dgain:x1.000000 */
+	{0x01c9, 0x0400}, /* index:118, gain:11.06250db -> x3.573757, again:x3.573757, dgain:x1.000000 */
+	{0x01ce, 0x0400}, /* index:119, gain:11.15625db -> x3.612539, again:x3.612539, dgain:x1.000000 */
+	{0x01d3, 0x0400}, /* index:120, gain:11.25000db -> x3.651741, again:x3.651741, dgain:x1.000000 */
+	{0x01d8, 0x0400}, /* index:121, gain:11.34375db -> x3.691369, again:x3.691369, dgain:x1.000000 */
+	{0x01dd, 0x0400}, /* index:122, gain:11.43750db -> x3.731427, again:x3.731427, dgain:x1.000000 */
+	{0x01e2, 0x0400}, /* index:123, gain:11.53125db -> x3.771920, again:x3.771920, dgain:x1.000000 */
+	{0x01e8, 0x0400}, /* index:124, gain:11.62500db -> x3.812853, again:x3.812853, dgain:x1.000000 */
+	{0x01ed, 0x0400}, /* index:125, gain:11.71875db -> x3.854229, again:x3.854229, dgain:x1.000000 */
+	{0x01f2, 0x0400}, /* index:126, gain:11.81250db -> x3.896054, again:x3.896054, dgain:x1.000000 */
+	{0x01f8, 0x0400}, /* index:127, gain:11.90625db -> x3.938333, again:x3.938333, dgain:x1.000000 */
+	{0x01fd, 0x0400}, /* index:128, gain:12.00000db -> x3.981072, again:x3.981072, dgain:x1.000000 */
+	{0x0203, 0x0400}, /* index:129, gain:12.09375db -> x4.024274, again:x4.024274, dgain:x1.000000 */
+	{0x0208, 0x0400}, /* index:130, gain:12.18750db -> x4.067944, again:x4.067944, dgain:x1.000000 */
+	{0x020e, 0x0400}, /* index:131, gain:12.28125db -> x4.112089, again:x4.112089, dgain:x1.000000 */
+	{0x0214, 0x0400}, /* index:132, gain:12.37500db -> x4.156712, again:x4.156712, dgain:x1.000000 */
+	{0x0219, 0x0400}, /* index:133, gain:12.46875db -> x4.201821, again:x4.201821, dgain:x1.000000 */
+	{0x021f, 0x0400}, /* index:134, gain:12.56250db -> x4.247418, again:x4.247418, dgain:x1.000000 */
+	{0x0225, 0x0400}, /* index:135, gain:12.65625db -> x4.293510, again:x4.293510, dgain:x1.000000 */
+	{0x022b, 0x0400}, /* index:136, gain:12.75000db -> x4.340103, again:x4.340103, dgain:x1.000000 */
+	{0x0231, 0x0400}, /* index:137, gain:12.84375db -> x4.387200, again:x4.387200, dgain:x1.000000 */
+	{0x0237, 0x0400}, /* index:138, gain:12.93750db -> x4.434810, again:x4.434810, dgain:x1.000000 */
+	{0x023d, 0x0400}, /* index:139, gain:13.03125db -> x4.482936, again:x4.482936, dgain:x1.000000 */
+	{0x0244, 0x0400}, /* index:140, gain:13.12500db -> x4.531584, again:x4.531584, dgain:x1.000000 */
+	{0x024a, 0x0400}, /* index:141, gain:13.21875db -> x4.580759, again:x4.580759, dgain:x1.000000 */
+	{0x0250, 0x0400}, /* index:142, gain:13.31250db -> x4.630469, again:x4.630469, dgain:x1.000000 */
+	{0x0257, 0x0400}, /* index:143, gain:13.40625db -> x4.680719, again:x4.680719, dgain:x1.000000 */
+	{0x025d, 0x0400}, /* index:144, gain:13.50000db -> x4.731513, again:x4.731513, dgain:x1.000000 */
+	{0x0264, 0x0400}, /* index:145, gain:13.59375db -> x4.782858, again:x4.782858, dgain:x1.000000 */
+	{0x026a, 0x0400}, /* index:146, gain:13.68750db -> x4.834761, again:x4.834761, dgain:x1.000000 */
+	{0x0271, 0x0400}, /* index:147, gain:13.78125db -> x4.887227, again:x4.887227, dgain:x1.000000 */
+	{0x0278, 0x0400}, /* index:148, gain:13.87500db -> x4.940262, again:x4.940262, dgain:x1.000000 */
+	{0x027f, 0x0400}, /* index:149, gain:13.96875db -> x4.993873, again:x4.993873, dgain:x1.000000 */
+	{0x0286, 0x0400}, /* index:150, gain:14.06250db -> x5.048066, again:x5.048066, dgain:x1.000000 */
+	{0x028d, 0x0400}, /* index:151, gain:14.15625db -> x5.102846, again:x5.102846, dgain:x1.000000 */
+	{0x0294, 0x0400}, /* index:152, gain:14.25000db -> x5.158221, again:x5.158221, dgain:x1.000000 */
+	{0x029b, 0x0400}, /* index:153, gain:14.34375db -> x5.214198, again:x5.214198, dgain:x1.000000 */
+	{0x02a2, 0x0400}, /* index:154, gain:14.43750db -> x5.270781, again:x5.270781, dgain:x1.000000 */
+	{0x02a9, 0x0400}, /* index:155, gain:14.53125db -> x5.327979, again:x5.327979, dgain:x1.000000 */
+	{0x02b1, 0x0400}, /* index:156, gain:14.62500db -> x5.385797, again:x5.385797, dgain:x1.000000 */
+	{0x02b8, 0x0400}, /* index:157, gain:14.71875db -> x5.444243, again:x5.444243, dgain:x1.000000 */
+	{0x02c0, 0x0400}, /* index:158, gain:14.81250db -> x5.503323, again:x5.503323, dgain:x1.000000 */
+	{0x02c8, 0x0400}, /* index:159, gain:14.90625db -> x5.563044, again:x5.563044, dgain:x1.000000 */
+	{0x02cf, 0x0400}, /* index:160, gain:15.00000db -> x5.623413, again:x5.623413, dgain:x1.000000 */
+	{0x02d7, 0x0400}, /* index:161, gain:15.09375db -> x5.684437, again:x5.684437, dgain:x1.000000 */
+	{0x02df, 0x0400}, /* index:162, gain:15.18750db -> x5.746124, again:x5.746124, dgain:x1.000000 */
+	{0x02e7, 0x0400}, /* index:163, gain:15.28125db -> x5.808480, again:x5.808480, dgain:x1.000000 */
+	{0x02ef, 0x0400}, /* index:164, gain:15.37500db -> x5.871513, again:x5.871513, dgain:x1.000000 */
+	{0x02f7, 0x0400}, /* index:165, gain:15.46875db -> x5.935229, again:x5.935229, dgain:x1.000000 */
+	{0x02ff, 0x0400}, /* index:166, gain:15.56250db -> x5.999637, again:x5.999637, dgain:x1.000000 */
+	{0x0308, 0x0400}, /* index:167, gain:15.65625db -> x6.064744, again:x6.064744, dgain:x1.000000 */
+	{0x0310, 0x0400}, /* index:168, gain:15.75000db -> x6.130558, again:x6.130558, dgain:x1.000000 */
+	{0x0319, 0x0400}, /* index:169, gain:15.84375db -> x6.197086, again:x6.197086, dgain:x1.000000 */
+	{0x0321, 0x0400}, /* index:170, gain:15.93750db -> x6.264335, again:x6.264335, dgain:x1.000000 */
+	{0x032a, 0x0400}, /* index:171, gain:16.03125db -> x6.332315, again:x6.332315, dgain:x1.000000 */
+	{0x0333, 0x0400}, /* index:172, gain:16.12500db -> x6.401032, again:x6.401032, dgain:x1.000000 */
+	{0x033c, 0x0400}, /* index:173, gain:16.21875db -> x6.470495, again:x6.470495, dgain:x1.000000 */
+	{0x0345, 0x0400}, /* index:174, gain:16.31250db -> x6.540712, again:x6.540712, dgain:x1.000000 */
+	{0x034e, 0x0400}, /* index:175, gain:16.40625db -> x6.611690, again:x6.611690, dgain:x1.000000 */
+	{0x0357, 0x0400}, /* index:176, gain:16.50000db -> x6.683439, again:x6.683439, dgain:x1.000000 */
+	{0x0360, 0x0400}, /* index:177, gain:16.59375db -> x6.755966, again:x6.755966, dgain:x1.000000 */
+	{0x036a, 0x0400}, /* index:178, gain:16.68750db -> x6.829282, again:x6.829282, dgain:x1.000000 */
+	{0x0373, 0x0400}, /* index:179, gain:16.78125db -> x6.903392, again:x6.903392, dgain:x1.000000 */
+	{0x037d, 0x0400}, /* index:180, gain:16.87500db -> x6.978306, again:x6.978306, dgain:x1.000000 */
+	{0x0386, 0x0400}, /* index:181, gain:16.96875db -> x7.054033, again:x7.054033, dgain:x1.000000 */
+	{0x0390, 0x0400}, /* index:182, gain:17.06250db -> x7.130582, again:x7.130582, dgain:x1.000000 */
+	{0x039a, 0x0400}, /* index:183, gain:17.15625db -> x7.207963, again:x7.207963, dgain:x1.000000 */
+	{0x03a4, 0x0400}, /* index:184, gain:17.25000db -> x7.286182, again:x7.286182, dgain:x1.000000 */
+	{0x03ae, 0x0400}, /* index:185, gain:17.34375db -> x7.365250, again:x7.365250, dgain:x1.000000 */
+	{0x03b8, 0x0400}, /* index:186, gain:17.43750db -> x7.445176, again:x7.445176, dgain:x1.000000 */
+	{0x03c3, 0x0400}, /* index:187, gain:17.53125db -> x7.525970, again:x7.525970, dgain:x1.000000 */
+	{0x03cd, 0x0400}, /* index:188, gain:17.62500db -> x7.607641, again:x7.607641, dgain:x1.000000 */
+	{0x03d8, 0x0400}, /* index:189, gain:17.71875db -> x7.690198, again:x7.690198, dgain:x1.000000 */
+	{0x03e3, 0x0400}, /* index:190, gain:17.81250db -> x7.773650, again:x7.773650, dgain:x1.000000 */
+	{0x03ed, 0x0400}, /* index:191, gain:17.90625db -> x7.858008, again:x7.858008, dgain:x1.000000 */
+	{0x03f8, 0x0400}, /* index:192, gain:18.00000db -> x7.943282, again:x7.943282, dgain:x1.000000 */
+	{0x0403, 0x0400}, /* index:193, gain:18.09375db -> x8.029482, again:x8.029482, dgain:x1.000000 */
+	{0x040e, 0x0400}, /* index:194, gain:18.18750db -> x8.116616, again:x8.116616, dgain:x1.000000 */
+	{0x041a, 0x0400}, /* index:195, gain:18.28125db -> x8.204696, again:x8.204696, dgain:x1.000000 */
+	{0x0425, 0x0400}, /* index:196, gain:18.37500db -> x8.293732, again:x8.293732, dgain:x1.000000 */
+	{0x0431, 0x0400}, /* index:197, gain:18.46875db -> x8.383734, again:x8.383734, dgain:x1.000000 */
+	{0x043c, 0x0400}, /* index:198, gain:18.56250db -> x8.474713, again:x8.474713, dgain:x1.000000 */
+	{0x0448, 0x0400}, /* index:199, gain:18.65625db -> x8.566679, again:x8.566679, dgain:x1.000000 */
+	{0x0454, 0x0400}, /* index:200, gain:18.75000db -> x8.659643, again:x8.659643, dgain:x1.000000 */
+	{0x0460, 0x0400}, /* index:201, gain:18.84375db -> x8.753616, again:x8.753616, dgain:x1.000000 */
+	{0x046c, 0x0400}, /* index:202, gain:18.93750db -> x8.848608, again:x8.848608, dgain:x1.000000 */
+	{0x0478, 0x0400}, /* index:203, gain:19.03125db -> x8.944633, again:x8.944633, dgain:x1.000000 */
+	{0x0485, 0x0400}, /* index:204, gain:19.12500db -> x9.041698, again:x9.041698, dgain:x1.000000 */
+	{0x0491, 0x0400}, /* index:205, gain:19.21875db -> x9.139817, again:x9.139817, dgain:x1.000000 */
+	{0x049e, 0x0400}, /* index:206, gain:19.31250db -> x9.239000, again:x9.239000, dgain:x1.000000 */
+	{0x04ab, 0x0400}, /* index:207, gain:19.40625db -> x9.339260, again:x9.339260, dgain:x1.000000 */
+	{0x04b8, 0x0400}, /* index:208, gain:19.50000db -> x9.440609, again:x9.440609, dgain:x1.000000 */
+	{0x04c5, 0x0400}, /* index:209, gain:19.59375db -> x9.543057, again:x9.543057, dgain:x1.000000 */
+	{0x04d2, 0x0400}, /* index:210, gain:19.68750db -> x9.646616, again:x9.646616, dgain:x1.000000 */
+	{0x04e0, 0x0400}, /* index:211, gain:19.78125db -> x9.751299, again:x9.751299, dgain:x1.000000 */
+	{0x04ed, 0x0400}, /* index:212, gain:19.87500db -> x9.857118, again:x9.857118, dgain:x1.000000 */
+	{0x04fb, 0x0400}, /* index:213, gain:19.96875db -> x9.964087, again:x9.964087, dgain:x1.000000 */
+	{0x0509, 0x0400}, /* index:214, gain:20.06250db -> x10.072214, again:x10.072214, dgain:x1.000000 */
+	{0x0517, 0x0400}, /* index:215, gain:20.15625db -> x10.181517, again:x10.181517, dgain:x1.000000 */
+	{0x0525, 0x0400}, /* index:216, gain:20.25000db -> x10.292006, again:x10.292006, dgain:x1.000000 */
+	{0x0533, 0x0400}, /* index:217, gain:20.34375db -> x10.403692, again:x10.403692, dgain:x1.000000 */
+	{0x0542, 0x0400}, /* index:218, gain:20.43750db -> x10.516592, again:x10.516592, dgain:x1.000000 */
+	{0x0550, 0x0400}, /* index:219, gain:20.53125db -> x10.630714, again:x10.630714, dgain:x1.000000 */
+	{0x055f, 0x0400}, /* index:220, gain:20.62500db -> x10.746078, again:x10.746078, dgain:x1.000000 */
+	{0x056e, 0x0400}, /* index:221, gain:20.71875db -> x10.862694, again:x10.862694, dgain:x1.000000 */
+	{0x057d, 0x0400}, /* index:222, gain:20.81250db -> x10.980572, again:x10.980572, dgain:x1.000000 */
+	{0x058c, 0x0400}, /* index:223, gain:20.90625db -> x11.099733, again:x11.099733, dgain:x1.000000 */
+	{0x059c, 0x0400}, /* index:224, gain:21.00000db -> x11.220183, again:x11.220183, dgain:x1.000000 */
+	{0x05ab, 0x0400}, /* index:225, gain:21.09375db -> x11.341944, again:x11.341944, dgain:x1.000000 */
+	{0x05bb, 0x0400}, /* index:226, gain:21.18750db -> x11.465026, again:x11.465026, dgain:x1.000000 */
+	{0x05cb, 0x0400}, /* index:227, gain:21.28125db -> x11.589441, again:x11.589441, dgain:x1.000000 */
+	{0x05db, 0x0400}, /* index:228, gain:21.37500db -> x11.715209, again:x11.715209, dgain:x1.000000 */
+	{0x05eb, 0x0400}, /* index:229, gain:21.46875db -> x11.842338, again:x11.842338, dgain:x1.000000 */
+	{0x05fc, 0x0400}, /* index:230, gain:21.56250db -> x11.970850, again:x11.970850, dgain:x1.000000 */
+	{0x060c, 0x0400}, /* index:231, gain:21.65625db -> x12.100757, again:x12.100757, dgain:x1.000000 */
+	{0x061d, 0x0400}, /* index:232, gain:21.75000db -> x12.232071, again:x12.232071, dgain:x1.000000 */
+	{0x062e, 0x0400}, /* index:233, gain:21.84375db -> x12.364812, again:x12.364812, dgain:x1.000000 */
+	{0x063f, 0x0400}, /* index:234, gain:21.93750db -> x12.498991, again:x12.498991, dgain:x1.000000 */
+	{0x0651, 0x0400}, /* index:235, gain:22.03125db -> x12.634629, again:x12.634629, dgain:x1.000000 */
+	{0x0662, 0x0400}, /* index:236, gain:22.12500db -> x12.771739, again:x12.771739, dgain:x1.000000 */
+	{0x0674, 0x0400}, /* index:237, gain:22.21875db -> x12.910334, again:x12.910334, dgain:x1.000000 */
+	{0x0686, 0x0400}, /* index:238, gain:22.31250db -> x13.050436, again:x13.050436, dgain:x1.000000 */
+	{0x0698, 0x0400}, /* index:239, gain:22.40625db -> x13.192055, again:x13.192055, dgain:x1.000000 */
+	{0x06aa, 0x0400}, /* index:240, gain:22.50000db -> x13.335214, again:x13.335214, dgain:x1.000000 */
+	{0x06bd, 0x0400}, /* index:241, gain:22.59375db -> x13.479927, again:x13.479927, dgain:x1.000000 */
+	{0x06d0, 0x0400}, /* index:242, gain:22.68750db -> x13.626207, again:x13.626207, dgain:x1.000000 */
+	{0x06e3, 0x0400}, /* index:243, gain:22.78125db -> x13.774078, again:x13.774078, dgain:x1.000000 */
+	{0x06f6, 0x0400}, /* index:244, gain:22.87500db -> x13.923549, again:x13.923549, dgain:x1.000000 */
+	{0x0709, 0x0400}, /* index:245, gain:22.96875db -> x14.074647, again:x14.074647, dgain:x1.000000 */
+	{0x071d, 0x0400}, /* index:246, gain:23.06250db -> x14.227384, again:x14.227384, dgain:x1.000000 */
+	{0x0730, 0x0400}, /* index:247, gain:23.15625db -> x14.381775, again:x14.381775, dgain:x1.000000 */
+	{0x0744, 0x0400}, /* index:248, gain:23.25000db -> x14.537845, again:x14.537845, dgain:x1.000000 */
+	{0x0759, 0x0400}, /* index:249, gain:23.34375db -> x14.695604, again:x14.695604, dgain:x1.000000 */
+	{0x076d, 0x0400}, /* index:250, gain:23.43750db -> x14.855080, again:x14.855080, dgain:x1.000000 */
+	{0x0782, 0x0400}, /* index:251, gain:23.53125db -> x15.016287, again:x15.016287, dgain:x1.000000 */
+	{0x0796, 0x0400}, /* index:252, gain:23.62500db -> x15.179238, again:x15.179238, dgain:x1.000000 */
+	{0x07ac, 0x0400}, /* index:253, gain:23.71875db -> x15.343962, again:x15.343962, dgain:x1.000000 */
+	{0x07c1, 0x0400}, /* index:254, gain:23.81250db -> x15.510470, again:x15.510470, dgain:x1.000000 */
+	{0x07d6, 0x0400}, /* index:255, gain:23.90625db -> x15.678788, again:x15.678788, dgain:x1.000000 */
+	{0x07ec, 0x0400}, /* index:256, gain:24.00000db -> x15.848934, again:x15.848934, dgain:x1.000000 */
+	{0x07ff, 0x0401}, /* index:257, gain:24.09375db -> x16.020921, again:x15.992188, dgain:x1.001797 */
+	{0x07ff, 0x040c}, /* index:258, gain:24.18750db -> x16.194779, again:x15.992188, dgain:x1.012668 */
+	{0x07ff, 0x0418}, /* index:259, gain:24.28125db -> x16.370519, again:x15.992188, dgain:x1.023657 */
+	{0x07ff, 0x0423}, /* index:260, gain:24.37500db -> x16.548171, again:x15.992188, dgain:x1.034766 */
+	{0x07ff, 0x042f}, /* index:261, gain:24.46875db -> x16.727751, again:x15.992188, dgain:x1.045995 */
+	{0x07ff, 0x043a}, /* index:262, gain:24.56250db -> x16.909275, again:x15.992188, dgain:x1.057346 */
+	{0x07ff, 0x0446}, /* index:263, gain:24.65625db -> x17.092773, again:x15.992188, dgain:x1.068820 */
+	{0x07ff, 0x0452}, /* index:264, gain:24.75000db -> x17.278258, again:x15.992188, dgain:x1.080419 */
+	{0x07ff, 0x045e}, /* index:265, gain:24.84375db -> x17.465760, again:x15.992188, dgain:x1.092143 */
+	{0x07ff, 0x046a}, /* index:266, gain:24.93750db -> x17.655298, again:x15.992188, dgain:x1.103995 */
+	{0x07ff, 0x0476}, /* index:267, gain:25.03125db -> x17.846887, again:x15.992188, dgain:x1.115975 */
+	{0x07ff, 0x0483}, /* index:268, gain:25.12500db -> x18.040560, again:x15.992188, dgain:x1.128086 */
+	{0x07ff, 0x048f}, /* index:269, gain:25.21875db -> x18.236330, again:x15.992188, dgain:x1.140327 */
+	{0x07ff, 0x049c}, /* index:270, gain:25.31250db -> x18.434230, again:x15.992188, dgain:x1.152702 */
+	{0x07ff, 0x04a9}, /* index:271, gain:25.40625db -> x18.634277, again:x15.992188, dgain:x1.165211 */
+	{0x07ff, 0x04b6}, /* index:272, gain:25.50000db -> x18.836490, again:x15.992188, dgain:x1.177856 */
+	{0x07ff, 0x04c3}, /* index:273, gain:25.59375db -> x19.040902, again:x15.992188, dgain:x1.190638 */
+	{0x07ff, 0x04d0}, /* index:274, gain:25.68750db -> x19.247528, again:x15.992188, dgain:x1.203558 */
+	{0x07ff, 0x04dd}, /* index:275, gain:25.78125db -> x19.456401, again:x15.992188, dgain:x1.216619 */
+	{0x07ff, 0x04eb}, /* index:276, gain:25.87500db -> x19.667540, again:x15.992188, dgain:x1.229822 */
+	{0x07ff, 0x04f9}, /* index:277, gain:25.96875db -> x19.880966, again:x15.992188, dgain:x1.243167 */
+	{0x07ff, 0x0506}, /* index:278, gain:26.06250db -> x20.096713, again:x15.992188, dgain:x1.256658 */
+	{0x07ff, 0x0514}, /* index:279, gain:26.15625db -> x20.314795, again:x15.992188, dgain:x1.270295 */
+	{0x07ff, 0x0522}, /* index:280, gain:26.25000db -> x20.535250, again:x15.992188, dgain:x1.284080 */
+	{0x07ff, 0x0531}, /* index:281, gain:26.34375db -> x20.758098, again:x15.992188, dgain:x1.298015 */
+	{0x07ff, 0x053f}, /* index:282, gain:26.43750db -> x20.983357, again:x15.992188, dgain:x1.312101 */
+	{0x07ff, 0x054e}, /* index:283, gain:26.53125db -> x21.211067, again:x15.992188, dgain:x1.326339 */
+	{0x07ff, 0x055c}, /* index:284, gain:26.62500db -> x21.441243, again:x15.992188, dgain:x1.340732 */
+	{0x07ff, 0x056b}, /* index:285, gain:26.71875db -> x21.673922, again:x15.992188, dgain:x1.355282 */
+	{0x07ff, 0x057a}, /* index:286, gain:26.81250db -> x21.909126, again:x15.992188, dgain:x1.369989 */
+	{0x07ff, 0x058a}, /* index:287, gain:26.90625db -> x22.146876, again:x15.992188, dgain:x1.384856 */
+	{0x07ff, 0x0599}, /* index:288, gain:27.00000db -> x22.387213, again:x15.992188, dgain:x1.399884 */
+	{0x07ff, 0x05a9}, /* index:289, gain:27.09375db -> x22.630151, again:x15.992188, dgain:x1.415075 */
+	{0x07ff, 0x05b8}, /* index:290, gain:27.18750db -> x22.875732, again:x15.992188, dgain:x1.430432 */
+	{0x07ff, 0x05c8}, /* index:291, gain:27.28125db -> x23.123978, again:x15.992188, dgain:x1.445955 */
+	{0x07ff, 0x05d8}, /* index:292, gain:27.37500db -> x23.374912, again:x15.992188, dgain:x1.461646 */
+	{0x07ff, 0x05e8}, /* index:293, gain:27.46875db -> x23.628575, again:x15.992188, dgain:x1.477507 */
+	{0x07ff, 0x05f9}, /* index:294, gain:27.56250db -> x23.884984, again:x15.992188, dgain:x1.493541 */
+	{0x07ff, 0x0609}, /* index:295, gain:27.65625db -> x24.144182, again:x15.992188, dgain:x1.509749 */
+	{0x07ff, 0x061a}, /* index:296, gain:27.75000db -> x24.406193, again:x15.992188, dgain:x1.526132 */
+	{0x07ff, 0x062b}, /* index:297, gain:27.84375db -> x24.671041, again:x15.992188, dgain:x1.542693 */
+	{0x07ff, 0x063c}, /* index:298, gain:27.93750db -> x24.938770, again:x15.992188, dgain:x1.559435 */
+	{0x07ff, 0x064e}, /* index:299, gain:28.03125db -> x25.209397, again:x15.992188, dgain:x1.576357 */
+	{0x07ff, 0x065f}, /* index:300, gain:28.12500db -> x25.482967, again:x15.992188, dgain:x1.593464 */
+	{0x07ff, 0x0671}, /* index:301, gain:28.21875db -> x25.759507, again:x15.992188, dgain:x1.610756 */
+	{0x07ff, 0x0683}, /* index:302, gain:28.31250db -> x26.039040, again:x15.992188, dgain:x1.628235 */
+	{0x07ff, 0x0695}, /* index:303, gain:28.40625db -> x26.321614, again:x15.992188, dgain:x1.645905 */
+	{0x07ff, 0x06a7}, /* index:304, gain:28.50000db -> x26.607248, again:x15.992188, dgain:x1.663765 */
+	{0x07ff, 0x06ba}, /* index:305, gain:28.59375db -> x26.895988, again:x15.992188, dgain:x1.681820 */
+	{0x07ff, 0x06cc}, /* index:306, gain:28.68750db -> x27.187861, again:x15.992188, dgain:x1.700071 */
+	{0x07ff, 0x06df}, /* index:307, gain:28.78125db -> x27.482895, again:x15.992188, dgain:x1.718520 */
+	{0x07ff, 0x06f2}, /* index:308, gain:28.87500db -> x27.781137, again:x15.992188, dgain:x1.737169 */
+	{0x07ff, 0x0706}, /* index:309, gain:28.96875db -> x28.082609, again:x15.992188, dgain:x1.756020 */
+	{0x07ff, 0x0719}, /* index:310, gain:29.06250db -> x28.387360, again:x15.992188, dgain:x1.775077 */
+	{0x07ff, 0x072d}, /* index:311, gain:29.15625db -> x28.695417, again:x15.992188, dgain:x1.794340 */
+	{0x07ff, 0x0741}, /* index:312, gain:29.25000db -> x29.006810, again:x15.992188, dgain:x1.813811 */
+	{0x07ff, 0x0755}, /* index:313, gain:29.34375db -> x29.321590, again:x15.992188, dgain:x1.833495 */
+	{0x07ff, 0x0769}, /* index:314, gain:29.43750db -> x29.639778, again:x15.992188, dgain:x1.853391 */
+	{0x07ff, 0x077e}, /* index:315, gain:29.53125db -> x29.961427, again:x15.992188, dgain:x1.873504 */
+	{0x07ff, 0x0793}, /* index:316, gain:29.62500db -> x30.286567, again:x15.992188, dgain:x1.893835 */
+	{0x07ff, 0x07a8}, /* index:317, gain:29.71875db -> x30.615226, again:x15.992188, dgain:x1.914386 */
+	{0x07ff, 0x07bd}, /* index:318, gain:29.81250db -> x30.947461, again:x15.992188, dgain:x1.935161 */
+	{0x07ff, 0x07d3}, /* index:319, gain:29.90625db -> x31.283292, again:x15.992188, dgain:x1.956161 */
+	{0x07ff, 0x07e8}, /* index:320, gain:30.00000db -> x31.622777, again:x15.992188, dgain:x1.977389 */
+	{0x07ff, 0x07fe}, /* index:321, gain:30.09375db -> x31.965945, again:x15.992188, dgain:x1.998848 */
+	{0x07ff, 0x0815}, /* index:322, gain:30.18750db -> x32.312829, again:x15.992188, dgain:x2.020538 */
+	{0x07ff, 0x082b}, /* index:323, gain:30.28125db -> x32.663485, again:x15.992188, dgain:x2.042465 */
+	{0x07ff, 0x0842}, /* index:324, gain:30.37500db -> x33.017938, again:x15.992188, dgain:x2.064629 */
+	{0x07ff, 0x0859}, /* index:325, gain:30.46875db -> x33.376247, again:x15.992188, dgain:x2.087034 */
+	{0x07ff, 0x0870}, /* index:326, gain:30.56250db -> x33.738444, again:x15.992188, dgain:x2.109683 */
+	{0x07ff, 0x0887}, /* index:327, gain:30.65625db -> x34.104562, again:x15.992188, dgain:x2.132576 */
+	{0x07ff, 0x089f}, /* index:328, gain:30.75000db -> x34.474663, again:x15.992188, dgain:x2.155719 */
+	{0x07ff, 0x08b7}, /* index:329, gain:30.84375db -> x34.848770, again:x15.992188, dgain:x2.179112 */
+	{0x07ff, 0x08cf}, /* index:330, gain:30.93750db -> x35.226947, again:x15.992188, dgain:x2.202760 */
+	{0x07ff, 0x08e8}, /* index:331, gain:31.03125db -> x35.609227, again:x15.992188, dgain:x2.226664 */
+	{0x07ff, 0x0900}, /* index:332, gain:31.12500db -> x35.995646, again:x15.992188, dgain:x2.250827 */
+	{0x07ff, 0x0919}, /* index:333, gain:31.21875db -> x36.386269, again:x15.992188, dgain:x2.275253 */
+	{0x07ff, 0x0933}, /* index:334, gain:31.31250db -> x36.781120, again:x15.992188, dgain:x2.299943 */
+	{0x07ff, 0x094c}, /* index:335, gain:31.40625db -> x37.180267, again:x15.992188, dgain:x2.324902 */
+	{0x07ff, 0x0966}, /* index:336, gain:31.50000db -> x37.583745, again:x15.992188, dgain:x2.350132 */
+	{0x07ff, 0x0980}, /* index:337, gain:31.59375db -> x37.991591, again:x15.992188, dgain:x2.375634 */
+	{0x07ff, 0x099b}, /* index:338, gain:31.68750db -> x38.403873, again:x15.992188, dgain:x2.401415 */
+	{0x07ff, 0x09b5}, /* index:339, gain:31.78125db -> x38.820619, again:x15.992188, dgain:x2.427474 */
+	{0x07ff, 0x09d0}, /* index:340, gain:31.87500db -> x39.241898, again:x15.992188, dgain:x2.453817 */
+	{0x07ff, 0x09eb}, /* index:341, gain:31.96875db -> x39.667748, again:x15.992188, dgain:x2.480445 */
+	{0x07ff, 0x0a07}, /* index:342, gain:32.06250db -> x40.098209, again:x15.992188, dgain:x2.507362 */
+	{0x07ff, 0x0a23}, /* index:343, gain:32.15625db -> x40.533352, again:x15.992188, dgain:x2.534572 */
+	{0x07ff, 0x0a3f}, /* index:344, gain:32.25000db -> x40.973206, again:x15.992188, dgain:x2.562076 */
+	{0x07ff, 0x0a5c}, /* index:345, gain:32.34375db -> x41.417845, again:x15.992188, dgain:x2.589880 */
+	{0x07ff, 0x0a78}, /* index:346, gain:32.43750db -> x41.867309, again:x15.992188, dgain:x2.617985 */
+	{0x07ff, 0x0a95}, /* index:347, gain:32.53125db -> x42.321639, again:x15.992188, dgain:x2.646395 */
+	{0x07ff, 0x0ab3}, /* index:348, gain:32.62500db -> x42.780911, again:x15.992188, dgain:x2.675113 */
+	{0x07ff, 0x0ad1}, /* index:349, gain:32.71875db -> x43.245154, again:x15.992188, dgain:x2.704143 */
+	{0x07ff, 0x0aef}, /* index:350, gain:32.81250db -> x43.714448, again:x15.992188, dgain:x2.733488 */
+	{0x07ff, 0x0b0d}, /* index:351, gain:32.90625db -> x44.188835, again:x15.992188, dgain:x2.763151 */
+	{0x07ff, 0x0b2c}, /* index:352, gain:33.00000db -> x44.668357, again:x15.992188, dgain:x2.793136 */
+	{0x07ff, 0x0b4b}, /* index:353, gain:33.09375db -> x45.153095, again:x15.992188, dgain:x2.823447 */
+	{0x07ff, 0x0b6a}, /* index:354, gain:33.18750db -> x45.643081, again:x15.992188, dgain:x2.854086 */
+	{0x07ff, 0x0b8a}, /* index:355, gain:33.28125db -> x46.138397, again:x15.992188, dgain:x2.885059 */
+	{0x07ff, 0x0baa}, /* index:356, gain:33.37500db -> x46.639088, again:x15.992188, dgain:x2.916367 */
+	{0x07ff, 0x0bca}, /* index:357, gain:33.46875db -> x47.145199, again:x15.992188, dgain:x2.948014 */
+	{0x07ff, 0x0beb}, /* index:358, gain:33.56250db -> x47.656816, again:x15.992188, dgain:x2.980006 */
+	{0x07ff, 0x0c0c}, /* index:359, gain:33.65625db -> x48.173972, again:x15.992188, dgain:x3.012344 */
+	{0x07ff, 0x0c2e}, /* index:360, gain:33.75000db -> x48.696753, again:x15.992188, dgain:x3.045034 */
+	{0x07ff, 0x0c4f}, /* index:361, gain:33.84375db -> x49.225207, again:x15.992188, dgain:x3.078078 */
+	{0x07ff, 0x0c72}, /* index:362, gain:33.93750db -> x49.759382, again:x15.992188, dgain:x3.111481 */
+	{0x07ff, 0x0c94}, /* index:363, gain:34.03125db -> x50.299367, again:x15.992188, dgain:x3.145246 */
+	{0x07ff, 0x0cb7}, /* index:364, gain:34.12500db -> x50.845199, again:x15.992188, dgain:x3.179377 */
+	{0x07ff, 0x0cdb}, /* index:365, gain:34.21875db -> x51.396968, again:x15.992188, dgain:x3.213880 */
+	{0x07ff, 0x0cfe}, /* index:366, gain:34.31250db -> x51.954725, again:x15.992188, dgain:x3.248757 */
+	{0x07ff, 0x0d22}, /* index:367, gain:34.40625db -> x52.518520, again:x15.992188, dgain:x3.284011 */
+	{0x07ff, 0x0d47}, /* index:368, gain:34.50000db -> x53.088447, again:x15.992188, dgain:x3.319649 */
+	{0x07ff, 0x0d6c}, /* index:369, gain:34.59375db -> x53.664545, again:x15.992188, dgain:x3.355673 */
+	{0x07ff, 0x0d91}, /* index:370, gain:34.68750db -> x54.246909, again:x15.992188, dgain:x3.392088 */
+	{0x07ff, 0x0db7}, /* index:371, gain:34.78125db -> x54.835593, again:x15.992188, dgain:x3.428899 */
+	{0x07ff, 0x0ddd}, /* index:372, gain:34.87500db -> x55.430651, again:x15.992188, dgain:x3.466108 */
+	{0x07ff, 0x0e03}, /* index:373, gain:34.96875db -> x56.032181, again:x15.992188, dgain:x3.503722 */
+	{0x07ff, 0x0e2a}, /* index:374, gain:35.06250db -> x56.640223, again:x15.992188, dgain:x3.541743 */
+	{0x07ff, 0x0e52}, /* index:375, gain:35.15625db -> x57.254879, again:x15.992188, dgain:x3.580178 */
+	{0x07ff, 0x0e79}, /* index:376, gain:35.25000db -> x57.876205, again:x15.992188, dgain:x3.619030 */
+	{0x07ff, 0x0ea2}, /* index:377, gain:35.34375db -> x58.504258, again:x15.992188, dgain:x3.658302 */
+	{0x07ff, 0x0eca}, /* index:378, gain:35.43750db -> x59.139143, again:x15.992188, dgain:x3.698002 */
+	{0x07ff, 0x0ef3}, /* index:379, gain:35.53125db -> x59.780900, again:x15.992188, dgain:x3.738132 */
+	{0x07ff, 0x0f1d}, /* index:380, gain:35.62500db -> x60.429639, again:x15.992188, dgain:x3.778698 */
+	{0x07ff, 0x0f47}, /* index:381, gain:35.71875db -> x61.085418, again:x15.992188, dgain:x3.819704 */
+	{0x07ff, 0x0f71}, /* index:382, gain:35.81250db -> x61.748296, again:x15.992188, dgain:x3.861154 */
+	{0x07ff, 0x0f9c}, /* index:383, gain:35.90625db -> x62.418384, again:x15.992188, dgain:x3.903055 */
+	{0x07ff, 0x0fc8}, /* index:384, gain:36.00000db -> x63.095728, again:x15.992188, dgain:x3.945409 */
+	{0x07ff, 0x0ff3}, /* index:385, gain:36.09375db -> x63.780438, again:x15.992188, dgain:x3.988225 */
+	{0x07ff, 0x1020}, /* index:386, gain:36.18750db -> x64.472580, again:x15.992188, dgain:x4.031505 */
+	{0x07ff, 0x104d}, /* index:387, gain:36.28125db -> x65.172214, again:x15.992188, dgain:x4.075253 */
+	{0x07ff, 0x107a}, /* index:388, gain:36.37500db -> x65.879459, again:x15.992188, dgain:x4.119478 */
+	{0x07ff, 0x10a8}, /* index:389, gain:36.46875db -> x66.594360, again:x15.992188, dgain:x4.164181 */
+	{0x07ff, 0x10d6}, /* index:390, gain:36.56250db -> x67.317038, again:x15.992188, dgain:x4.209370 */
+	{0x07ff, 0x1105}, /* index:391, gain:36.65625db -> x68.047559, again:x15.992188, dgain:x4.255050 */
+	{0x07ff, 0x1134}, /* index:392, gain:36.75000db -> x68.785987, again:x15.992188, dgain:x4.301224 */
+	{0x07ff, 0x1164}, /* index:393, gain:36.84375db -> x69.532449, again:x15.992188, dgain:x4.347901 */
+	{0x07ff, 0x1194}, /* index:394, gain:36.93750db -> x70.286991, again:x15.992188, dgain:x4.395083 */
+	{0x07ff, 0x11c5}, /* index:395, gain:37.03125db -> x71.049741, again:x15.992188, dgain:x4.442778 */
+	{0x07ff, 0x11f6}, /* index:396, gain:37.12500db -> x71.820768, again:x15.992188, dgain:x4.490991 */
+	{0x07ff, 0x1228}, /* index:397, gain:37.21875db -> x72.600143, again:x15.992188, dgain:x4.539726 */
+	{0x07ff, 0x125b}, /* index:398, gain:37.31250db -> x73.387995, again:x15.992188, dgain:x4.588990 */
+	{0x07ff, 0x128e}, /* index:399, gain:37.40625db -> x74.184377, again:x15.992188, dgain:x4.638789 */
+	{0x07ff, 0x12c1}, /* index:400, gain:37.50000db -> x74.989421, again:x15.992188, dgain:x4.689128 */
+	{0x07ff, 0x12f5}, /* index:401, gain:37.59375db -> x75.803201, again:x15.992188, dgain:x4.740015 */
+	{0x07ff, 0x132a}, /* index:402, gain:37.68750db -> x76.625792, again:x15.992188, dgain:x4.791452 */
+	{0x07ff, 0x135f}, /* index:403, gain:37.78125db -> x77.457330, again:x15.992188, dgain:x4.843448 */
+	{0x07ff, 0x1395}, /* index:404, gain:37.87500db -> x78.297871, again:x15.992188, dgain:x4.896008 */
+	{0x07ff, 0x13cb}, /* index:405, gain:37.96875db -> x79.147554, again:x15.992188, dgain:x4.949139 */
+	{0x07ff, 0x1402}, /* index:406, gain:38.06250db -> x80.006459, again:x15.992188, dgain:x5.002846 */
+	{0x07ff, 0x143a}, /* index:407, gain:38.15625db -> x80.874662, again:x15.992188, dgain:x5.057136 */
+	{0x07ff, 0x1472}, /* index:408, gain:38.25000db -> x81.752308, again:x15.992188, dgain:x5.112015 */
+	{0x07ff, 0x14ab}, /* index:409, gain:38.34375db -> x82.639457, again:x15.992188, dgain:x5.167489 */
+	{0x07ff, 0x14e4}, /* index:410, gain:38.43750db -> x83.536255, again:x15.992188, dgain:x5.223566 */
+	{0x07ff, 0x151e}, /* index:411, gain:38.53125db -> x84.442785, again:x15.992188, dgain:x5.280252 */
+	{0x07ff, 0x1559}, /* index:412, gain:38.62500db -> x85.359129, again:x15.992188, dgain:x5.337552 */
+	{0x07ff, 0x1594}, /* index:413, gain:38.71875db -> x86.285441, again:x15.992188, dgain:x5.395475 */
+	{0x07ff, 0x15d0}, /* index:414, gain:38.81250db -> x87.221781, again:x15.992188, dgain:x5.454024 */
+	{0x07ff, 0x160d}, /* index:415, gain:38.90625db -> x88.168307, again:x15.992188, dgain:x5.513211 */
+	{0x07ff, 0x164a}, /* index:416, gain:39.00000db -> x89.125104, again:x15.992188, dgain:x5.573040 */
+	{0x07ff, 0x1688}, /* index:417, gain:39.09375db -> x90.092259, again:x15.992188, dgain:x5.633517 */
+	{0x07ff, 0x16c7}, /* index:418, gain:39.18750db -> x91.069934, again:x15.992188, dgain:x5.694651 */
+	{0x07ff, 0x1706}, /* index:419, gain:39.28125db -> x92.058194, again:x15.992188, dgain:x5.756448 */
+	{0x07ff, 0x1746}, /* index:420, gain:39.37500db -> x93.057204, again:x15.992188, dgain:x5.818917 */
+	{0x07ff, 0x1787}, /* index:421, gain:39.46875db -> x94.067055, again:x15.992188, dgain:x5.882063 */
+	{0x07ff, 0x17c8}, /* index:422, gain:39.56250db -> x95.087839, again:x15.992188, dgain:x5.945893 */
+	{0x07ff, 0x180a}, /* index:423, gain:39.65625db -> x96.119726, again:x15.992188, dgain:x6.010418 */
+	{0x07ff, 0x184d}, /* index:424, gain:39.75000db -> x97.162784, again:x15.992188, dgain:x6.075641 */
+	{0x07ff, 0x1890}, /* index:425, gain:39.84375db -> x98.217189, again:x15.992188, dgain:x6.141573 */
+	{0x07ff, 0x18d5}, /* index:426, gain:39.93750db -> x99.283036, again:x15.992188, dgain:x6.208221 */
+	{0x07ff, 0x191a}, /* index:427, gain:40.03125db -> x100.360449, again:x15.992188, dgain:x6.275592 */
+	{0x07ff, 0x195f}, /* index:428, gain:40.12500db -> x101.449499, again:x15.992188, dgain:x6.343691 */
+	{0x07ff, 0x19a6}, /* index:429, gain:40.21875db -> x102.550422, again:x15.992188, dgain:x6.412533 */
+	{0x07ff, 0x19ed}, /* index:430, gain:40.31250db -> x103.663293, again:x15.992188, dgain:x6.482121 */
+	{0x07ff, 0x1a35}, /* index:431, gain:40.40625db -> x104.788240, again:x15.992188, dgain:x6.552464 */
+	{0x07ff, 0x1a7e}, /* index:432, gain:40.50000db -> x105.925396, again:x15.992188, dgain:x6.623571 */
+	{0x07ff, 0x1ac8}, /* index:433, gain:40.59375db -> x107.074833, again:x15.992188, dgain:x6.695446 */
+	{0x07ff, 0x1b12}, /* index:434, gain:40.68750db -> x108.236802, again:x15.992188, dgain:x6.768105 */
+	{0x07ff, 0x1b5d}, /* index:435, gain:40.78125db -> x109.411381, again:x15.992188, dgain:x6.841552 */
+	{0x07ff, 0x1ba9}, /* index:436, gain:40.87500db -> x110.598706, again:x15.992188, dgain:x6.915796 */
+	{0x07ff, 0x1bf6}, /* index:437, gain:40.96875db -> x111.798917, again:x15.992188, dgain:x6.990846 */
+	{0x07ff, 0x1c44}, /* index:438, gain:41.06250db -> x113.012089, again:x15.992188, dgain:x7.066706 */
+	{0x07ff, 0x1c92}, /* index:439, gain:41.15625db -> x114.238490, again:x15.992188, dgain:x7.143394 */
+	{0x07ff, 0x1ce2}, /* index:440, gain:41.25000db -> x115.478198, again:x15.992188, dgain:x7.220913 */
+	{0x07ff, 0x1d32}, /* index:441, gain:41.34375db -> x116.731361, again:x15.992188, dgain:x7.299274 */
+	{0x07ff, 0x1d83}, /* index:442, gain:41.43750db -> x117.998122, again:x15.992188, dgain:x7.378485 */
+	{0x07ff, 0x1dd5}, /* index:443, gain:41.53125db -> x119.278565, again:x15.992188, dgain:x7.458552 */
+	{0x07ff, 0x1e28}, /* index:444, gain:41.62500db -> x120.572968, again:x15.992188, dgain:x7.539492 */
+	{0x07ff, 0x1e7c}, /* index:445, gain:41.71875db -> x121.881418, again:x15.992188, dgain:x7.621310 */
+	{0x07ff, 0x1ed0}, /* index:446, gain:41.81250db -> x123.204068, again:x15.992188, dgain:x7.704016 */
+	{0x07ff, 0x1f26}, /* index:447, gain:41.90625db -> x124.541071, again:x15.992188, dgain:x7.787619 */
+	{0x07ff, 0x1f7d}, /* index:448, gain:42.00000db -> x125.892514, again:x15.992188, dgain:x7.872126 */
+	{0x07ff, 0x1fd4}, /* index:449, gain:42.09375db -> x127.258691, again:x15.992188, dgain:x7.957554 */
+	{0x07ff, 0x202c}, /* index:450, gain:42.18750db -> x128.639694, again:x15.992188, dgain:x8.043909 */
+	{0x07ff, 0x2086}, /* index:451, gain:42.28125db -> x130.035684, again:x15.992188, dgain:x8.131201 */
+	{0x07ff, 0x20e0}, /* index:452, gain:42.37500db -> x131.446823, again:x15.992188, dgain:x8.219440 */
+	{0x07ff, 0x213c}, /* index:453, gain:42.46875db -> x132.873203, again:x15.992188, dgain:x8.308632 */
+	{0x07ff, 0x2198}, /* index:454, gain:42.56250db -> x134.315135, again:x15.992188, dgain:x8.398797 */
+	{0x07ff, 0x21f5}, /* index:455, gain:42.65625db -> x135.772714, again:x15.992188, dgain:x8.489940 */
+	{0x07ff, 0x2254}, /* index:456, gain:42.75000db -> x137.246111, again:x15.992188, dgain:x8.582072 */
+	{0x07ff, 0x22b3}, /* index:457, gain:42.84375db -> x138.735497, again:x15.992188, dgain:x8.675205 */
+	{0x07ff, 0x2313}, /* index:458, gain:42.93750db -> x140.240969, again:x15.992188, dgain:x8.769342 */
+	{0x07ff, 0x2375}, /* index:459, gain:43.03125db -> x141.762855, again:x15.992188, dgain:x8.864507 */
+	{0x07ff, 0x23d7}, /* index:460, gain:43.12500db -> x143.301257, again:x15.992188, dgain:x8.960704 */
+	{0x07ff, 0x243b}, /* index:461, gain:43.21875db -> x144.856353, again:x15.992188, dgain:x9.057945 */
+	{0x07ff, 0x249f}, /* index:462, gain:43.31250db -> x146.428325, again:x15.992188, dgain:x9.156241 */
+	{0x07ff, 0x2505}, /* index:463, gain:43.40625db -> x148.017275, again:x15.992188, dgain:x9.255599 */
+	{0x07ff, 0x256c}, /* index:464, gain:43.50000db -> x149.623549, again:x15.992188, dgain:x9.356040 */
+	{0x07ff, 0x25d4}, /* index:465, gain:43.59375db -> x151.247255, again:x15.992188, dgain:x9.457571 */
+	{0x07ff, 0x263d}, /* index:466, gain:43.68750db -> x152.888580, again:x15.992188, dgain:x9.560204 */
+	{0x07ff, 0x26a7}, /* index:467, gain:43.78125db -> x154.547717, again:x15.992188, dgain:x9.663951 */
+	{0x07ff, 0x2713}, /* index:468, gain:43.87500db -> x156.224774, again:x15.992188, dgain:x9.768818 */
+	{0x07ff, 0x277f}, /* index:469, gain:43.96875db -> x157.920115, again:x15.992188, dgain:x9.874829 */
+	{0x07ff, 0x27ed}, /* index:470, gain:44.06250db -> x159.633854, again:x15.992188, dgain:x9.981990 */
+	{0x07ff, 0x285c}, /* index:471, gain:44.15625db -> x161.366191, again:x15.992188, dgain:x10.090314 */
+	{0x07ff, 0x28cc}, /* index:472, gain:44.25000db -> x163.117327, again:x15.992188, dgain:x10.199813 */
+	{0x07ff, 0x293d}, /* index:473, gain:44.34375db -> x164.887375, again:x15.992188, dgain:x10.310495 */
+	{0x07ff, 0x29b0}, /* index:474, gain:44.43750db -> x166.676723, again:x15.992188, dgain:x10.422384 */
+	{0x07ff, 0x2a24}, /* index:475, gain:44.53125db -> x168.485488, again:x15.992188, dgain:x10.535487 */
+	{0x07ff, 0x2a99}, /* index:476, gain:44.62500db -> x170.313882, again:x15.992188, dgain:x10.649818 */
+	{0x07ff, 0x2b0f}, /* index:477, gain:44.71875db -> x172.162117, again:x15.992188, dgain:x10.765389 */
+	{0x07ff, 0x2b87}, /* index:478, gain:44.81250db -> x174.030314, again:x15.992188, dgain:x10.882208 */
+	{0x07ff, 0x2c00}, /* index:479, gain:44.90625db -> x175.918880, again:x15.992188, dgain:x11.000301 */
+	{0x07ff, 0x2c7a}, /* index:480, gain:45.00000db -> x177.827941, again:x15.992188, dgain:x11.119676 */
+	{0x07ff, 0x2cf6}, /* index:481, gain:45.09375db -> x179.757719, again:x15.992188, dgain:x11.240346 */
+	{0x07ff, 0x2d73}, /* index:482, gain:45.18750db -> x181.708438, again:x15.992188, dgain:x11.362325 */
+	{0x07ff, 0x2df1}, /* index:483, gain:45.28125db -> x183.680226, again:x15.992188, dgain:x11.485622 */
+	{0x07ff, 0x2e70}, /* index:484, gain:45.37500db -> x185.673512, again:x15.992188, dgain:x11.610264 */
+	{0x07ff, 0x2ef1}, /* index:485, gain:45.46875db -> x187.688429, again:x15.992188, dgain:x11.736257 */
+	{0x07ff, 0x2f74}, /* index:486, gain:45.56250db -> x189.725212, again:x15.992188, dgain:x11.863619 */
+	{0x07ff, 0x2ff8}, /* index:487, gain:45.65625db -> x191.784098, again:x15.992188, dgain:x11.992362 */
+	{0x07ff, 0x307d}, /* index:488, gain:45.75000db -> x193.865221, again:x15.992188, dgain:x12.122496 */
+	{0x07ff, 0x3104}, /* index:489, gain:45.84375db -> x195.969034, again:x15.992188, dgain:x12.254048 */
+	{0x07ff, 0x318c}, /* index:490, gain:45.93750db -> x198.095678, again:x15.992188, dgain:x12.387028 */
+	{0x07ff, 0x3215}, /* index:491, gain:46.03125db -> x200.245400, again:x15.992188, dgain:x12.521451 */
+	{0x07ff, 0x32a1}, /* index:492, gain:46.12500db -> x202.418450, again:x15.992188, dgain:x12.657333 */
+	{0x07ff, 0x332d}, /* index:493, gain:46.21875db -> x204.614970, again:x15.992188, dgain:x12.794683 */
+	{0x07ff, 0x33bb}, /* index:494, gain:46.31250db -> x206.835439, again:x15.992188, dgain:x12.933530 */
+	{0x07ff, 0x344b}, /* index:495, gain:46.40625db -> x209.080004, again:x15.992188, dgain:x13.073884 */
+	{0x07ff, 0x34dc}, /* index:496, gain:46.50000db -> x211.348927, again:x15.992188, dgain:x13.215761 */
+	{0x07ff, 0x356f}, /* index:497, gain:46.59375db -> x213.642472, again:x15.992188, dgain:x13.359178 */
+	{0x07ff, 0x3604}, /* index:498, gain:46.68750db -> x215.960789, again:x15.992188, dgain:x13.504143 */
+	{0x07ff, 0x369a}, /* index:499, gain:46.78125db -> x218.304381, again:x15.992188, dgain:x13.650689 */
+	{0x07ff, 0x3731}, /* index:500, gain:46.87500db -> x220.673407, again:x15.992188, dgain:x13.798826 */
+	{0x07ff, 0x37cb}, /* index:501, gain:46.96875db -> x223.068141, again:x15.992188, dgain:x13.948570 */
+	{0x07ff, 0x3866}, /* index:502, gain:47.06250db -> x225.488862, again:x15.992188, dgain:x14.099939 */
+	{0x07ff, 0x3903}, /* index:503, gain:47.15625db -> x227.935728, again:x15.992188, dgain:x14.252942 */
+	{0x07ff, 0x39a1}, /* index:504, gain:47.25000db -> x230.409272, again:x15.992188, dgain:x14.407614 */
+	{0x07ff, 0x3a41}, /* index:505, gain:47.34375db -> x232.909659, again:x15.992188, dgain:x14.563965 */
+	{0x07ff, 0x3ae3}, /* index:506, gain:47.43750db -> x235.437180, again:x15.992188, dgain:x14.722012 */
+	{0x07ff, 0x3b86}, /* index:507, gain:47.53125db -> x237.992130, again:x15.992188, dgain:x14.881775 */
+	{0x07ff, 0x3c2c}, /* index:508, gain:47.62500db -> x240.574673, again:x15.992188, dgain:x15.043262 */
+	{0x07ff, 0x3cd3}, /* index:509, gain:47.71875db -> x243.185374, again:x15.992188, dgain:x15.206511 */
+	{0x07ff, 0x3d7c}, /* index:510, gain:47.81250db -> x245.824407, again:x15.992188, dgain:x15.371531 */
+	{0x07ff, 0x3e27}, /* index:511, gain:47.90625db -> x248.492078, again:x15.992188, dgain:x15.538342 */
+	{0x07ff, 0x3ed3}, /* index:512, gain:48.00000db -> x251.188698, again:x15.992188, dgain:x15.706963 */
+};
+
diff --git a/drivers/vin/sensors/omnivision_ov2735_mipi/Kbuild b/drivers/vin/sensors/omnivision_ov2735_mipi/Kbuild
new file mode 100644
index 0000000..06bffe0
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2735_mipi/Kbuild
@@ -0,0 +1,39 @@
+##
+## Filename : Kbuild
+##
+## History:
+##    2017/01/03 - [Hao Zeng] created file
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+
+EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
+EXTRA_AFLAGS		+= $(AMBARELLA_DRV_AFLAGS)
+EXTRA_LDFLAGS		+= $(AMBARELLA_DRV_LDFLAGS)
+
+obj-m := ov2735_mipi.o
+ov2735_mipi-y := ov2735.o
+
diff --git a/drivers/vin/sensors/omnivision_ov2735_mipi/make.inc b/drivers/vin/sensors/omnivision_ov2735_mipi/make.inc
new file mode 100644
index 0000000..d93abb9
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2735_mipi/make.inc
@@ -0,0 +1,45 @@
+##
+## kernel/private/drivers/vin/sensors/omnivision_ov2735_mipi/make.inc
+##
+## History:
+##    2017/01/03 - [Hao Zeng] created file
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+ifeq ($(CONFIG_SENSOR_OV2735_MIPI), y)
+
+LOCAL_PATH	:= $(call my-dir)
+
+###
+include $(CLEAR_VARS)
+
+LOCAL_SRCS	:= $(wildcard $(LOCAL_PATH)/*.c) $(wildcard $(LOCAL_PATH)/*.h)
+LOCAL_SRCS	+= $(LOCAL_PATH)/Kbuild
+
+include $(BUILD_DRIVER)
+
+endif
+
diff --git a/drivers/vin/sensors/omnivision_ov2735_mipi/ov2735.c b/drivers/vin/sensors/omnivision_ov2735_mipi/ov2735.c
new file mode 100644
index 0000000..7d3dadf
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2735_mipi/ov2735.c
@@ -0,0 +1,558 @@
+/*
+ * Filename : ov2735.c
+ *
+ * History:
+ *    2017/01/03 - [Hao Zeng] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/ambpriv_device.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <iav_utils.h>
+#include <vin_api.h>
+#include "ov2735.h"
+#include "ov2735_table.c"
+
+static int bus_addr = (0 << 16) | (0x78 >> 1);
+module_param(bus_addr, int, 0644);
+MODULE_PARM_DESC(bus_addr, " bus and addr: bit16~bit31: bus, bit0~bit15: addr");
+
+struct ov2735_priv {
+	void *control_data;
+	u32 line_length;
+	u32 frame_length_lines;
+	u32 vblank;
+	u32 vts;
+};
+
+static int ov2735_write_reg(struct vin_device *vdev, u32 subaddr, u32 data)
+{
+	int rval;
+	struct ov2735_priv *ov2735;
+	struct i2c_client *client;
+	struct i2c_msg msgs[1];
+	u8 pbuf[2];
+
+	ov2735 = (struct ov2735_priv *)vdev->priv;
+	client = ov2735->control_data;
+
+	pbuf[0] = (subaddr & 0xff);
+	pbuf[1] = data;
+
+	msgs[0].len = 2;
+	msgs[0].addr = client->addr;
+	if (unlikely(subaddr == OV2735_SWRESET))
+		msgs[0].flags = client->flags | I2C_M_IGNORE_NAK;
+	else
+		msgs[0].flags = client->flags;
+	msgs[0].buf = pbuf;
+
+	rval = i2c_transfer(client->adapter, msgs, 1);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x:0x%x]\n", rval, subaddr, data);
+		return rval;
+	}
+
+	return 0;
+}
+
+static int ov2735_write_reg2(struct vin_device *vdev, u32 subaddr, u32 data)
+{
+	int rval;
+	struct ov2735_priv *ov2735;
+	struct i2c_client *client;
+	struct i2c_msg msgs[1];
+	u8 pbuf[3];
+
+	ov2735 = (struct ov2735_priv *)vdev->priv;
+	client = ov2735->control_data;
+
+	pbuf[0] = (subaddr & 0xff);
+	pbuf[1] = (data >> 8) & 0xff;
+	pbuf[2] = (data & 0xff);
+
+	msgs[0].len = 3;
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].buf = pbuf;
+
+	rval = i2c_transfer(client->adapter, msgs, 1);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x:0x%x]\n", rval, subaddr, data);
+		return rval;
+	}
+
+	return 0;
+}
+
+static int ov2735_read_reg(struct vin_device *vdev, u32 subaddr, u32 *data)
+{
+	int rval = 0;
+	struct ov2735_priv *ov2735;
+	struct i2c_client *client;
+	struct i2c_msg msgs[2];
+	u8 pbuf0[1];
+	u8 pbuf[1];
+
+	ov2735 = (struct ov2735_priv *)vdev->priv;
+	client = ov2735->control_data;
+
+	pbuf0[0] = (subaddr & 0xff);
+
+	msgs[0].len = 1;
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].buf = pbuf0;
+
+	msgs[1].addr = client->addr;
+	msgs[1].flags = client->flags | I2C_M_RD;
+	msgs[1].buf = pbuf;
+	msgs[1].len = 1;
+
+	rval = i2c_transfer(client->adapter, msgs, 2);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x]\n", rval, subaddr);
+		return rval;
+	}
+
+	*data = pbuf[0];
+
+	return 0;
+}
+
+static int ov2735_set_vin_mode(struct vin_device *vdev, struct vin_video_format *format)
+{
+	struct vin_device_config ov2735_config;
+
+	memset(&ov2735_config, 0, sizeof(ov2735_config));
+
+	ov2735_config.interface_type = SENSOR_MIPI;
+	ov2735_config.sync_mode = SENSOR_SYNC_MODE_MASTER;
+
+	ov2735_config.mipi_cfg.lane_number = SENSOR_2_LANE;
+
+	ov2735_config.cap_win.x = format->def_start_x;
+	ov2735_config.cap_win.y = format->def_start_y;
+	ov2735_config.cap_win.width = format->def_width;
+	ov2735_config.cap_win.height = format->def_height;
+
+	ov2735_config.sensor_id	= GENERIC_SENSOR;
+	ov2735_config.input_format	= AMBA_VIN_INPUT_FORMAT_RGB_RAW;
+	ov2735_config.bayer_pattern	= format->bayer_pattern;
+	ov2735_config.video_format	= format->format;
+	ov2735_config.bit_resolution	= format->bits;
+
+	return ambarella_set_vin_config(vdev, &ov2735_config);
+}
+
+static void ov2735_sw_reset(struct vin_device *vdev)
+{
+	ov2735_write_reg(vdev, OV2735_PAGE_FLG, 0x00);
+	ov2735_write_reg(vdev, OV2735_SWRESET, 0x00);/* Software reset */
+	msleep(3);
+}
+
+static int ov2735_init_device(struct vin_device *vdev)
+{
+	ov2735_sw_reset(vdev);
+	return 0;
+}
+
+static void ov2735_start_streaming(struct vin_device *vdev)
+{
+	ov2735_write_reg(vdev, OV2735_FR_SYNC_EN, 0x01);
+	/* wait some time for register effective */
+	msleep(30);
+}
+
+static int ov2735_update_hv_info(struct vin_device *vdev)
+{
+	u32 val_high, val_low;
+	struct ov2735_priv *pinfo = (struct ov2735_priv *)vdev->priv;
+
+	ov2735_write_reg(vdev, OV2735_PAGE_FLG, 0x01);
+
+	ov2735_read_reg(vdev, OV2735_HTS_MSB, &val_high);
+	ov2735_read_reg(vdev, OV2735_HTS_LSB, &val_low);
+	pinfo->line_length = (val_high << 8) + val_low;
+	if (unlikely(!pinfo->line_length)) {
+		vin_error("line length is 0!\n");
+		return -EIO;
+	}
+
+	ov2735_read_reg(vdev, OV2735_VTS_MSB, &val_high);
+	ov2735_read_reg(vdev, OV2735_VTS_LSB, &val_low);
+	pinfo->vts = (val_high << 8) + val_low;
+
+	ov2735_read_reg(vdev, OV2735_FR_LENGTH_MSB, &val_high);
+	ov2735_read_reg(vdev, OV2735_FR_LENGTH_LSB, &val_low);
+	pinfo->frame_length_lines = (val_high << 8) + val_low;
+
+	ov2735_read_reg(vdev, OV2735_VB_MSB, &val_high);
+	ov2735_read_reg(vdev, OV2735_VB_LSB, &val_low);
+	pinfo->vblank = (val_high << 8) + val_low;
+
+	vin_debug("hts:%d, vts:%d, frame_length_lines:%d, vblank:%d\n",
+		pinfo->line_length, pinfo->vts, pinfo->frame_length_lines, pinfo->vblank);
+
+	return 0;
+}
+
+static int ov2735_get_line_time(struct vin_device *vdev)
+{
+	u64 h_clks;
+	struct ov2735_priv *pinfo = (struct ov2735_priv *)vdev->priv;
+
+	h_clks = (u64)pinfo->line_length * 512000000;
+	h_clks = DIV64_CLOSEST(h_clks, vdev->cur_pll->pixelclk);
+
+	vdev->cur_format->line_time = (u32)h_clks;
+
+	return 0;
+}
+
+static int ov2735_set_format(struct vin_device *vdev, struct vin_video_format *format)
+{
+	int rval;
+	struct vin_reg_8_8 *regs;
+	int i, regs_num;
+
+	switch (format->video_mode) {
+	case AMBA_VIDEO_MODE_1080P:
+		regs = ov2735_1080p_regs;
+		regs_num = ARRAY_SIZE(ov2735_1080p_regs);
+		break;
+	case AMBA_VIDEO_MODE_720P:
+		regs = ov2735_720p_regs;
+		regs_num = ARRAY_SIZE(ov2735_720p_regs);
+		break;
+	default:
+		regs = NULL;
+		regs_num = 0;
+		vin_error("Unknown mode\n");
+		return -EINVAL;
+	}
+	for (i = 0; i < regs_num; i++) {
+		ov2735_write_reg(vdev, regs[i].addr, regs[i].data);
+		if (unlikely(regs[i].addr == OV2735_SWRESET))
+			msleep(3);
+	}
+
+	/* Enable Streaming */
+	ov2735_start_streaming(vdev);
+
+	rval = ov2735_update_hv_info(vdev);
+	if (rval < 0)
+		return rval;
+
+	ov2735_get_line_time(vdev);
+
+	/* communicate with IAV */
+	rval = ov2735_set_vin_mode(vdev, format);
+	if (rval < 0)
+		return rval;
+
+	return 0;
+}
+
+static int ov2735_set_hold_mode(struct vin_device *vdev, u32 hold_mode)
+{
+	if (hold_mode)
+		ov2735_write_reg(vdev, OV2735_PAGE_FLG, 0x01);
+	else
+		ov2735_write_reg(vdev, OV2735_FR_SYNC_EN, 0x01);
+
+	return 0;
+}
+
+static int ov2735_set_shutter_row(struct vin_device *vdev, u32 row)
+{
+	u64 exposure_lines;
+	u32 num_line, min_line, max_line;
+	int rval = 0;
+	struct ov2735_priv *pinfo = (struct ov2735_priv *)vdev->priv;
+
+	num_line = row;
+
+	/* FIXME: shutter width: 2 ~ (Frame format(V) - 4) */
+	min_line = 2;
+	max_line = pinfo->vts - 4;
+	num_line = clamp(num_line, min_line, max_line);
+
+	ov2735_write_reg2(vdev, OV2735_EXPO_MSB, num_line & 0xFFFF);
+
+	exposure_lines = num_line;
+	exposure_lines = exposure_lines * (u64)pinfo->line_length * 512000000;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, vdev->cur_pll->pixelclk);
+
+	vdev->shutter_time = (u32)exposure_lines;
+	vin_debug("shutter_time:%d, row:%d\n", vdev->shutter_time, num_line);
+
+	return rval;
+}
+
+static int ov2735_shutter2row(struct vin_device *vdev, u32 *shutter_time)
+{
+	u64 exposure_lines;
+	int rval = 0;
+	struct ov2735_priv *pinfo = (struct ov2735_priv *)vdev->priv;
+
+	/* for fast boot, it may call set shutter time directly, so we must read line length/frame line */
+	if (unlikely(!pinfo->line_length)) {
+		rval = ov2735_update_hv_info(vdev);
+		if (rval < 0)
+			return rval;
+	}
+
+	exposure_lines = (*shutter_time) * (u64)vdev->cur_pll->pixelclk;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, pinfo->line_length);
+	exposure_lines = DIV64_CLOSEST(exposure_lines, 512000000);
+
+	*shutter_time = exposure_lines;
+
+	return rval;
+}
+
+static int ov2735_set_fps(struct vin_device *vdev, int fps)
+{
+	u64 v_lines, vb_time;
+	u32 vb_lines;
+	struct ov2735_priv *pinfo = (struct ov2735_priv *)vdev->priv;
+
+	v_lines = fps * (u64)vdev->cur_pll->pixelclk;
+	v_lines = DIV64_CLOSEST(v_lines, pinfo->line_length);
+	v_lines = DIV64_CLOSEST(v_lines, 512000000);
+
+	if (unlikely(v_lines < pinfo->frame_length_lines + 1)) {
+		vin_error("VTS:%lld should be larger than frame_length_lines:%d\n",
+			v_lines, pinfo->frame_length_lines);
+		return -EPERM;
+	} else {
+		vb_lines = v_lines - pinfo->frame_length_lines - 1;
+	}
+
+	ov2735_write_reg(vdev, OV2735_PAGE_FLG, 0x01);
+	ov2735_write_reg2(vdev, OV2735_VB_MSB, vb_lines & 0xFFFF);
+	ov2735_write_reg(vdev, OV2735_FR_SYNC_EN, 0x01);
+
+	pinfo->vts = (u32)v_lines;
+
+	vb_time = pinfo->line_length * (u64)(v_lines - vdev->cur_format->height) * 1000000000;
+	vb_time = DIV64_CLOSEST(vb_time, vdev->cur_pll->pixelclk);
+	vdev->cur_format->vb_time = vb_time;
+
+	return 0;
+}
+
+static int ov2735_set_agc_index(struct vin_device *vdev, int agc_idx)
+{
+	if (agc_idx > OV2735_GAIN_MAXDB) {
+		vin_warn("agc index %d exceeds maximum %d\n", agc_idx, OV2735_GAIN_MAXDB);
+		agc_idx = OV2735_GAIN_MAXDB;
+	}
+
+	/* Analog Gain */
+	ov2735_write_reg(vdev, OV2735_AGAIN_LSB, OV2735_GAIN_TABLE[agc_idx][OV2735_GAIN_COL_AGAIN]);
+
+	return 0;
+}
+
+static int ov2735_set_mirror_mode(struct vin_device *vdev,
+	struct vindev_mirror *mirror_mode)
+{
+	int rval = 0;
+	u32 tmp_reg, bayer_pattern, readmode = 0;
+	u32 reg_f8;
+
+	switch (mirror_mode->pattern) {
+	case VINDEV_MIRROR_AUTO:
+		return 0;
+
+	case VINDEV_MIRROR_NONE:
+		bayer_pattern = VINDEV_BAYER_PATTERN_RG;
+		reg_f8 = 0x02;
+		break;
+
+	case VINDEV_MIRROR_VERTICALLY:
+		readmode = OV2735_V_FLIP;
+		bayer_pattern = VINDEV_BAYER_PATTERN_GB;
+		reg_f8 = 0x00;
+		break;
+
+	case VINDEV_MIRROR_HORRIZONTALLY:
+		readmode = OV2735_H_MIRROR;
+		bayer_pattern = VINDEV_BAYER_PATTERN_GR;
+		reg_f8 = 0x00;
+		break;
+
+	case VINDEV_MIRROR_HORRIZONTALLY_VERTICALLY:
+		readmode = OV2735_V_FLIP + OV2735_H_MIRROR;
+		bayer_pattern = VINDEV_BAYER_PATTERN_BG;
+		reg_f8 = 0x02;
+		break;
+
+	default:
+		vin_error("do not support cmd mirror mode\n");
+		return -EINVAL;
+	}
+
+	ov2735_write_reg(vdev, OV2735_PAGE_FLG, 0x01);
+	ov2735_read_reg(vdev, OV2735_UPDOWN_MIRROR, &tmp_reg);
+	tmp_reg |= OV2735_MIRROR_MASK;
+	tmp_reg ^= readmode;
+	ov2735_write_reg(vdev, OV2735_UPDOWN_MIRROR, tmp_reg);
+	ov2735_write_reg(vdev, 0xf8, reg_f8);
+	ov2735_write_reg(vdev, OV2735_FR_SYNC_EN, 0x01);
+
+	if (mirror_mode->bayer_pattern == VINDEV_BAYER_PATTERN_AUTO)
+		mirror_mode->bayer_pattern = bayer_pattern;
+
+	return rval;
+}
+
+static struct vin_ops ov2735_ops = {
+	.init_device		= ov2735_init_device,
+	.set_format		= ov2735_set_format,
+	.set_shutter_row	= ov2735_set_shutter_row,
+	.shutter2row		= ov2735_shutter2row,
+	.set_frame_rate	= ov2735_set_fps,
+	.set_agc_index		= ov2735_set_agc_index,
+	.set_mirror_mode	= ov2735_set_mirror_mode,
+	.set_hold_mode		= ov2735_set_hold_mode,
+	.shutter2row		= ov2735_shutter2row,
+	.read_reg		= ov2735_read_reg,
+	.write_reg		= ov2735_write_reg,
+};
+
+/* ========================================================================== */
+static int ov2735_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	int rval = 0;
+	struct vin_device *vdev;
+	struct ov2735_priv *ov2735;
+	u32 cid_l, cid_h;
+
+	vdev = ambarella_vin_create_device(client->name,
+		SENSOR_OV2735, sizeof(struct ov2735_priv));
+	if (!vdev)
+		return -ENOMEM;
+
+	vdev->intf_id = 0;
+	vdev->dev_type = VINDEV_TYPE_SENSOR;
+	vdev->sub_type = VINDEV_SUBTYPE_CMOS;
+	vdev->default_mode = AMBA_VIDEO_MODE_1080P;
+	vdev->default_hdr_mode = AMBA_VIDEO_LINEAR_MODE;
+	vdev->agc_db_max = 0x18000000;  /* 24dB */
+	vdev->agc_db_min = 0x00000000;  /* 0dB */
+	vdev->agc_db_step = 0x00180000; /* 0.09375dB */
+
+	i2c_set_clientdata(client, vdev);
+
+	ov2735 = (struct ov2735_priv *)vdev->priv;
+	ov2735->control_data = client;
+
+	rval = ambarella_vin_register_device(vdev, &ov2735_ops,
+		ov2735_formats, ARRAY_SIZE(ov2735_formats),
+		ov2735_plls, ARRAY_SIZE(ov2735_plls));
+	if (rval < 0)
+		goto ov2735_probe_err;
+
+	/* query sensor id and revision */
+	ov2735_read_reg(vdev, OV2735_CHIP_ID_H, &cid_h);
+	ov2735_read_reg(vdev, OV2735_CHIP_ID_L, &cid_l);
+	vin_info("OV2735 init(2-lane mipi), Chip ID:0x%x\n", (cid_h<<8)+cid_l);
+
+	return 0;
+
+ov2735_probe_err:
+	ambarella_vin_free_device(vdev);
+	return rval;
+}
+
+static int ov2735_remove(struct i2c_client *client)
+{
+	struct vin_device *vdev;
+
+	vdev = (struct vin_device *)i2c_get_clientdata(client);
+	ambarella_vin_unregister_device(vdev);
+	ambarella_vin_free_device(vdev);
+
+	return 0;
+}
+
+static const struct i2c_device_id ov2735_idtable[] = {
+	{ "ov2735", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ov2735_idtable);
+
+static struct i2c_driver i2c_driver_ov2735 = {
+	.driver = {
+		.name	= "ov2735",
+	},
+
+	.id_table	= ov2735_idtable,
+	.probe		= ov2735_probe,
+	.remove		= ov2735_remove,
+
+};
+
+static int __init ov2735_init(void)
+{
+	int bus, addr, rval;
+
+	bus = bus_addr >> 16;
+	addr = bus_addr & 0xffff;
+
+	rval = ambpriv_i2c_update_addr("ov2735", bus, addr);
+	if (rval < 0)
+		return rval;
+
+	rval = i2c_add_driver(&i2c_driver_ov2735);
+	if (rval < 0)
+		return rval;
+
+	return 0;
+}
+
+static void __exit ov2735_exit(void)
+{
+	i2c_del_driver(&i2c_driver_ov2735);
+}
+
+module_init(ov2735_init);
+module_exit(ov2735_exit);
+
+MODULE_DESCRIPTION("OV2735 1/2.7-Inch, 1920x1080, 2-Megapixel CMOS Digital Image Sensor");
+MODULE_AUTHOR("Hao Zeng, <haozeng@ambarella.com>");
+MODULE_LICENSE("Proprietary");
+
diff --git a/drivers/vin/sensors/omnivision_ov2735_mipi/ov2735.h b/drivers/vin/sensors/omnivision_ov2735_mipi/ov2735.h
new file mode 100644
index 0000000..456df6c
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2735_mipi/ov2735.h
@@ -0,0 +1,76 @@
+/*
+ * Filename : ov2735.h
+ *
+ * History:
+ *    2017/01/03 - [Hao Zeng] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __OV2735_H__
+#define __OV2735_H__
+
+/****** page 0 ******/
+#define OV2735_SWRESET		0x20
+
+#define OV2735_CHIP_ID_H		0x02
+#define OV2735_CHIP_ID_L		0x03
+
+#define OV2735_PAGE_FLG		0xFD
+
+/****** page 1 ******/
+#define OV2735_FR_SYNC_EN	0x01
+
+#define OV2735_EXPO_MSB		0x03
+#define OV2735_EXPO_LSB		0x04
+
+#define OV2735_AGAIN_MSB		0x38
+#define OV2735_AGAIN_LSB		0x24
+#define OV2735_DGAIN			0x39
+#define OV2735_R_GAIN			0x40
+#define OV2735_GR_GAIN		0x41
+#define OV2735_GB_GAIN		0x42
+#define OV2735_B_GAIN			0x43
+
+#define OV2735_VB_MSB			0x05
+#define OV2735_VB_LSB			0x06
+
+#define OV2735_FR_LENGTH_CTRL	0x0D
+#define OV2735_FR_LENGTH_MSB		0x0E
+#define OV2735_FR_LENGTH_LSB		0x0F
+#define OV2735_VTS_MSB		0x4E
+#define OV2735_VTS_LSB		0x4F
+#define OV2735_HTS_MSB		0x8C
+#define OV2735_HTS_LSB		0x8D
+
+#define OV2735_UPDOWN_MIRROR	0x3F
+
+#define OV2735_V_FLIP				(1<<1)
+#define OV2735_H_MIRROR			(1<<0)
+#define OV2735_MIRROR_MASK		(OV2735_H_MIRROR + OV2735_V_FLIP)
+
+#endif /* __OV2735_H__ */
+
diff --git a/drivers/vin/sensors/omnivision_ov2735_mipi/ov2735_table.c b/drivers/vin/sensors/omnivision_ov2735_mipi/ov2735_table.c
new file mode 100644
index 0000000..5eae68a
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2735_mipi/ov2735_table.c
@@ -0,0 +1,598 @@
+/*
+ * Filename : ov2735_table.c
+ *
+ * History:
+ *    2017/01/03 - [Hao Zeng] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+static struct vin_video_pll ov2735_plls[] = {
+	{0, 24000000, 42000000},
+};
+
+static struct vin_video_format ov2735_formats[] = {
+	{
+		.video_mode = AMBA_VIDEO_MODE_1080P,
+		.def_start_x = 0,
+		.def_start_y = 0,
+		.def_width = 1920,
+		.def_height = 1080,
+		/* sensor mode */
+		.device_mode = 0,
+		.pll_idx = 0,
+		.width = 1920,
+		.height = 1080,
+		.format = AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type = AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits = AMBA_VIDEO_BITS_10,
+		.ratio = AMBA_VIDEO_RATIO_16_9,
+		.max_fps = AMBA_VIDEO_FPS_30,
+		.default_fps = AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern = VINDEV_BAYER_PATTERN_RG,
+	},
+	{
+		.video_mode = AMBA_VIDEO_MODE_720P,
+		.def_start_x = 0,
+		.def_start_y = 0,
+		.def_width = 1280,
+		.def_height = 720,
+		/* sensor mode */
+		.device_mode = 1,
+		.pll_idx = 0,
+		.width = 1280,
+		.height = 720,
+		.format = AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type = AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits = AMBA_VIDEO_BITS_10,
+		.ratio = AMBA_VIDEO_RATIO_16_9,
+		.max_fps = AMBA_VIDEO_FPS_60,
+		.default_fps = AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern = VINDEV_BAYER_PATTERN_RG,
+	},
+};
+
+static struct vin_reg_8_8 ov2735_1080p_regs[] = {
+	/* MIPI_1920x1080_2lane_30fps_420Mbps_24M-in_10bits, fpn optimization */
+	{0xfd, 0x00},
+	{0x20, 0x00},
+	{0xfd, 0x00},
+	{0x2f, 0x10},
+	{0x34, 0x00},
+	{0x30, 0x15},
+	{0x33, 0x01},
+	{0x35, 0x20},
+	{0xfd, 0x01},
+	{0x0d, 0x00},
+	{0x30, 0x00},
+	{0x03, 0x01},
+	{0x04, 0x8f},
+	{0x01, 0x01},
+	{0x09, 0x00},
+	{0x0a, 0x20},
+	{0x06, 0x0a},
+	{0x24, 0x10},
+	{0x01, 0x01},
+	{0xfb, 0x73},
+	{0x01, 0x01},
+	{0xfd, 0x01},
+	{0x1a, 0x6b},
+	{0x1c, 0xea},
+	{0x16, 0x0c},
+	{0x21, 0x00},
+	{0x11, 0xe8},
+	{0x19, 0xc3},
+	{0x26, 0xda},
+	{0x29, 0x01},
+	{0x33, 0x6f},
+	{0x2a, 0xd2},
+	{0x2c, 0x40},
+	{0xd0, 0x02},
+	{0xd1, 0x01},
+	{0xd2, 0x20},
+	{0xd3, 0x03},
+	{0xd4, 0xa4},
+	{0x50, 0x00},
+	{0x51, 0x2c},
+	{0x52, 0x29},
+	{0x53, 0x00},
+	{0x55, 0x44},
+	{0x58, 0x29},
+	{0x5a, 0x00},
+	{0x5b, 0x00},
+	{0x5d, 0x00},
+	{0x64, 0x2f},
+	{0x66, 0x62},
+	{0x68, 0x5b},
+	{0x75, 0x46},
+	{0x76, 0xf0},
+	{0x77, 0x4f},
+	{0x78, 0xef},
+	{0x72, 0xcf},
+	{0x73, 0x36},
+	{0x7d, 0x0d},
+	{0x7e, 0x0d},
+	{0x8a, 0x77},
+	{0x8b, 0x77},
+	{0xfd, 0x01},
+	{0xb1, 0x83}, /* DPHY enable 8b */
+	{0xb3, 0x0b},
+	{0xb4, 0x14}, /* MIPI PLL enable */
+	{0x9d, 0x40}, /* mipi hs dc level */
+	{0xa1, 0x05}, /* speed/03 */
+	{0x94, 0x44}, /* dphy time */
+	{0x95, 0x33}, /* dphy time */
+	{0x96, 0x1f}, /* dphy time */
+	{0x98, 0x45}, /* dphy time */
+	{0x9c, 0x10}, /* dphy time */
+	{0xb5, 0x70}, /* 30 */
+
+	{0x25, 0xe0},
+	{0x20, 0x7b},
+	{0x8f, 0x88},
+	{0x91, 0x40},
+
+	{0xfd, 0x02},
+	{0x5e, 0x03},
+	{0xa1, 0x04},
+	{0xa3, 0x40},
+	{0xa5, 0x02},
+	{0xa7, 0xc4},
+	{0xfd, 0x01},
+	{0x86, 0x77},
+	{0x89, 0x77},
+	{0x87, 0x74},
+	{0x88, 0x74},
+	{0xfc, 0xe0},
+	{0xfe, 0xe0},
+	{0xf0, 0x40},
+	{0xf1, 0x40},
+	{0xf2, 0x40},
+	{0xf3, 0x40},
+
+	/* crop to 1920x1080 */
+	{0xfd, 0x02},
+	{0xa0, 0x00},	/* Image vertical start MSB3bits */
+	{0xa1, 0x08},	/* Image vertical start LSB8bits */
+	{0xa2, 0x04},	/* image vertical size  MSB8bits */
+	{0xa3, 0x38},	/* image vertical size  LSB8bits */
+	{0xa4, 0x00},
+	{0xa5, 0x04},	/* H start 8Lsb, keep center */
+	{0xa6, 0x03},
+	{0xa7, 0xc0},	/* Half H size Lsb8bits */
+	{0xfd, 0x01},
+	{0x8e, 0x07},
+	{0x8f, 0x80},	/* MIPI column number */
+	{0x90, 0x04},	/* MIPI row number */
+	{0x91, 0x38},
+
+	{0xfd, 0x03},
+	{0xc0, 0x01},	/* enable transfer OTP BP information */
+	{0xfd, 0x04},
+	{0x21, 0x14},
+	{0x22, 0x14},
+	{0x23, 0x14},	/* enhance normal and dummy BPC */
+
+	/* Default Mirror_On_Flip_On */
+	{0xfd, 0x01},
+	{0x3f, 0x03},
+	{0xf8, 0x02},
+
+	{0x01, 0x01},
+	{0xfd, 0x02},
+	{0x62, 0x48},
+	{0x63, 0x04},
+	{0xfd, 0x01},
+	{0x06, 0xe0},	/* insert dummy line , the frame rate is 30.01 */
+	{0x01, 0x01},
+	{0xa0, 0x01},	/* MIPI enable, stream on */
+};
+
+static struct vin_reg_8_8 ov2735_720p_regs[] = {
+	/* MIPI_1280x720_raw10_2lane_60fps */
+	{0xfd, 0x00},
+	{0x20, 0x00},
+	{0xfd, 0x00},
+	{0x2f, 0x10},
+	{0x34, 0x00},
+	{0x30, 0x15},
+	{0x33, 0x01},
+	{0x35, 0x20},
+	{0xfd, 0x01},
+	{0x31, 0x01},
+	{0x0d, 0x00},
+	{0x30, 0x00},
+	{0x09, 0x00},
+	{0x0a, 0x80},
+	{0x06, 0x0a},
+	{0x24, 0x10},
+	{0x01, 0x01},
+	{0xfb, 0x73},
+	{0xfd, 0x01},
+	{0x1a, 0x6b},
+	{0x1c, 0xea},
+	{0x16, 0x0c},
+	{0x21, 0x00},
+	{0x11, 0x56},
+	{0x19, 0xc3},
+	{0x25, 0xe0},
+	{0x26, 0x5a},
+	{0x29, 0x01},
+	{0x33, 0x5f},
+	{0x2a, 0xd2},
+	{0x2c, 0x40},
+	{0xd0, 0x02},
+	{0xd1, 0x01},
+	{0xd2, 0x20},
+	{0xd3, 0x04},
+	{0xd4, 0x2a},
+	{0x50, 0x00},
+	{0x51, 0x2c},
+	{0x52, 0x29},
+	{0x53, 0x00},
+	{0x55, 0x46},
+	{0x58, 0x29},
+	{0x5a, 0x00},
+	{0x5b, 0x00},
+	{0x5d, 0x00},
+	{0x64, 0x2f},
+	{0x66, 0x62},
+	{0x68, 0x5b},
+	{0x75, 0x46},
+	{0x76, 0x36},
+	{0x77, 0x4f},
+	{0x78, 0xef},
+	{0x72, 0xbf},
+	{0x73, 0x36},
+	{0x7d, 0x0d},
+	{0x7e, 0x0d},
+	{0x8a, 0x77},
+	{0x8b, 0x77},
+	{0xfd, 0x01},
+	{0xb1, 0x83},/* DPHY enable 8b */
+	{0xb3, 0x0b},
+	{0xb4, 0x14},/* MIPI PLL enable */
+	{0x9d, 0x40},/* mipi hs dc level */
+	{0xa1, 0x05},/* speed/03 */
+	{0x94, 0x44},/* dphy time */
+	{0x95, 0x33},/* dphy time */
+	{0x96, 0x1f},/* dphy time */
+	{0x98, 0x45},/* dphy time */
+	{0x9c, 0x10},/* dphy time */
+	{0xb5, 0x30},
+	{0xa0, 0x01},/* mipi enable */
+
+	{0xfd, 0x01},
+	{0x86, 0x77},
+	{0x89, 0x77},
+	{0x87, 0x74},
+	{0x88, 0x74},
+	{0xfc, 0xe0},
+	{0xfe, 0xe0},
+	{0xf0, 0x40},
+	{0xf1, 0x40},
+	{0xf2, 0x40},
+	{0xf3, 0x40},
+
+	/* crop to 1280x720 */
+	{0xfd, 0x02},
+	{0xa0, 0x00},/* Image vertical start MSB3bits */
+	{0xa1, 0x04},/* Image vertical start LSB8bits */
+	{0xa2, 0x02},/* image vertical size  MSB8bits */
+	{0xa3, 0xd0},/* image vertical size  LSB8bits */
+	{0xa4, 0x00},
+	{0xa5, 0x04},/* H start 8Lsb */
+	{0xa6, 0x02},
+	{0xa7, 0x80},/* Half H size Lsb8bits */
+	{0xfd, 0x01},
+	{0x8e, 0x05},
+	{0x8f, 0x00},/* MIPI column number */
+	{0x90, 0x02},
+	{0x91, 0xd0},/* MIPI row number */
+
+	/* Default Mirror_On_Flip_On */
+	{0xfd, 0x01},
+	{0x3f, 0x03},
+	{0xf8, 0x02},
+
+	{0xfd, 0x01},
+	{0x0e, 0x02},
+	{0x0f, 0xf0},
+	{0x06, 0x18},/* insert dummy line */
+	{0x01, 0x01},
+};
+
+/* Gain table */
+/* OV2735 global gain table row size */
+#define OV2735_GAIN_ROWS  		(256 + 1)
+#define OV2735_GAIN_COLS  		(1)
+#define OV2735_GAIN_MAXDB		(256)
+
+#define OV2735_GAIN_COL_AGAIN	(0)
+static const u8 OV2735_GAIN_TABLE[OV2735_GAIN_ROWS][OV2735_GAIN_COLS] = {
+	{0x10}, /* index:0, gain:0.00000db -> x1.000000, again:x1.000000 */
+	{0x10}, /* index:1, gain:0.09375db -> x1.010852, again:x1.010852 */
+	{0x10}, /* index:2, gain:0.18750db -> x1.021821, again:x1.021821 */
+	{0x10}, /* index:3, gain:0.28125db -> x1.032910, again:x1.032910 */
+	{0x10}, /* index:4, gain:0.37500db -> x1.044119, again:x1.044119 */
+	{0x10}, /* index:5, gain:0.46875db -> x1.055450, again:x1.055450 */
+	{0x11}, /* index:6, gain:0.56250db -> x1.066903, again:x1.066903 */
+	{0x11}, /* index:7, gain:0.65625db -> x1.078481, again:x1.078481 */
+	{0x11}, /* index:8, gain:0.75000db -> x1.090184, again:x1.090184 */
+	{0x11}, /* index:9, gain:0.84375db -> x1.102015, again:x1.102015 */
+	{0x11}, /* index:10, gain:0.93750db -> x1.113974, again:x1.113974 */
+	{0x12}, /* index:11, gain:1.03125db -> x1.126063, again:x1.126063 */
+	{0x12}, /* index:12, gain:1.12500db -> x1.138282, again:x1.138282 */
+	{0x12}, /* index:13, gain:1.21875db -> x1.150635, again:x1.150635 */
+	{0x12}, /* index:14, gain:1.31250db -> x1.163121, again:x1.163121 */
+	{0x12}, /* index:15, gain:1.40625db -> x1.175743, again:x1.175743 */
+	{0x13}, /* index:16, gain:1.50000db -> x1.188502, again:x1.188502 */
+	{0x13}, /* index:17, gain:1.59375db -> x1.201400, again:x1.201400 */
+	{0x13}, /* index:18, gain:1.68750db -> x1.214437, again:x1.214437 */
+	{0x13}, /* index:19, gain:1.78125db -> x1.227616, again:x1.227616 */
+	{0x13}, /* index:20, gain:1.87500db -> x1.240938, again:x1.240938 */
+	{0x14}, /* index:21, gain:1.96875db -> x1.254404, again:x1.254404 */
+	{0x14}, /* index:22, gain:2.06250db -> x1.268017, again:x1.268017 */
+	{0x14}, /* index:23, gain:2.15625db -> x1.281777, again:x1.281777 */
+	{0x14}, /* index:24, gain:2.25000db -> x1.295687, again:x1.295687 */
+	{0x14}, /* index:25, gain:2.34375db -> x1.309747, again:x1.309747 */
+	{0x15}, /* index:26, gain:2.43750db -> x1.323960, again:x1.323960 */
+	{0x15}, /* index:27, gain:2.53125db -> x1.338328, again:x1.338328 */
+	{0x15}, /* index:28, gain:2.62500db -> x1.352851, again:x1.352851 */
+	{0x15}, /* index:29, gain:2.71875db -> x1.367532, again:x1.367532 */
+	{0x16}, /* index:30, gain:2.81250db -> x1.382372, again:x1.382372 */
+	{0x16}, /* index:31, gain:2.90625db -> x1.397374, again:x1.397374 */
+	{0x16}, /* index:32, gain:3.00000db -> x1.412538, again:x1.412538 */
+	{0x16}, /* index:33, gain:3.09375db -> x1.427866, again:x1.427866 */
+	{0x17}, /* index:34, gain:3.18750db -> x1.443361, again:x1.443361 */
+	{0x17}, /* index:35, gain:3.28125db -> x1.459024, again:x1.459024 */
+	{0x17}, /* index:36, gain:3.37500db -> x1.474857, again:x1.474857 */
+	{0x17}, /* index:37, gain:3.46875db -> x1.490862, again:x1.490862 */
+	{0x18}, /* index:38, gain:3.56250db -> x1.507041, again:x1.507041 */
+	{0x18}, /* index:39, gain:3.65625db -> x1.523395, again:x1.523395 */
+	{0x18}, /* index:40, gain:3.75000db -> x1.539927, again:x1.539927 */
+	{0x18}, /* index:41, gain:3.84375db -> x1.556638, again:x1.556638 */
+	{0x19}, /* index:42, gain:3.93750db -> x1.573530, again:x1.573530 */
+	{0x19}, /* index:43, gain:4.03125db -> x1.590606, again:x1.590606 */
+	{0x19}, /* index:44, gain:4.12500db -> x1.607867, again:x1.607867 */
+	{0x1a}, /* index:45, gain:4.21875db -> x1.625315, again:x1.625315 */
+	{0x1a}, /* index:46, gain:4.31250db -> x1.642952, again:x1.642952 */
+	{0x1a}, /* index:47, gain:4.40625db -> x1.660782, again:x1.660782 */
+	{0x1a}, /* index:48, gain:4.50000db -> x1.678804, again:x1.678804 */
+	{0x1b}, /* index:49, gain:4.59375db -> x1.697022, again:x1.697022 */
+	{0x1b}, /* index:50, gain:4.68750db -> x1.715438, again:x1.715438 */
+	{0x1b}, /* index:51, gain:4.78125db -> x1.734054, again:x1.734054 */
+	{0x1c}, /* index:52, gain:4.87500db -> x1.752871, again:x1.752871 */
+	{0x1c}, /* index:53, gain:4.96875db -> x1.771893, again:x1.771893 */
+	{0x1c}, /* index:54, gain:5.06250db -> x1.791121, again:x1.791121 */
+	{0x1c}, /* index:55, gain:5.15625db -> x1.810558, again:x1.810558 */
+	{0x1d}, /* index:56, gain:5.25000db -> x1.830206, again:x1.830206 */
+	{0x1d}, /* index:57, gain:5.34375db -> x1.850067, again:x1.850067 */
+	{0x1d}, /* index:58, gain:5.43750db -> x1.870144, again:x1.870144 */
+	{0x1e}, /* index:59, gain:5.53125db -> x1.890438, again:x1.890438 */
+	{0x1e}, /* index:60, gain:5.62500db -> x1.910953, again:x1.910953 */
+	{0x1e}, /* index:61, gain:5.71875db -> x1.931690, again:x1.931690 */
+	{0x1f}, /* index:62, gain:5.81250db -> x1.952653, again:x1.952653 */
+	{0x1f}, /* index:63, gain:5.90625db -> x1.973842, again:x1.973842 */
+	{0x1f}, /* index:64, gain:6.00000db -> x1.995262, again:x1.995262 */
+	{0x20}, /* index:65, gain:6.09375db -> x2.016915, again:x2.016915 */
+	{0x20}, /* index:66, gain:6.18750db -> x2.038802, again:x2.038802 */
+	{0x20}, /* index:67, gain:6.28125db -> x2.060927, again:x2.060927 */
+	{0x21}, /* index:68, gain:6.37500db -> x2.083291, again:x2.083291 */
+	{0x21}, /* index:69, gain:6.46875db -> x2.105899, again:x2.105899 */
+	{0x22}, /* index:70, gain:6.56250db -> x2.128752, again:x2.128752 */
+	{0x22}, /* index:71, gain:6.65625db -> x2.151852, again:x2.151852 */
+	{0x22}, /* index:72, gain:6.75000db -> x2.175204, again:x2.175204 */
+	{0x23}, /* index:73, gain:6.84375db -> x2.198809, again:x2.198809 */
+	{0x23}, /* index:74, gain:6.93750db -> x2.222670, again:x2.222670 */
+	{0x23}, /* index:75, gain:7.03125db -> x2.246790, again:x2.246790 */
+	{0x24}, /* index:76, gain:7.12500db -> x2.271172, again:x2.271172 */
+	{0x24}, /* index:77, gain:7.21875db -> x2.295818, again:x2.295818 */
+	{0x25}, /* index:78, gain:7.31250db -> x2.320732, again:x2.320732 */
+	{0x25}, /* index:79, gain:7.40625db -> x2.345916, again:x2.345916 */
+	{0x25}, /* index:80, gain:7.50000db -> x2.371374, again:x2.371374 */
+	{0x26}, /* index:81, gain:7.59375db -> x2.397107, again:x2.397107 */
+	{0x26}, /* index:82, gain:7.68750db -> x2.423120, again:x2.423120 */
+	{0x27}, /* index:83, gain:7.78125db -> x2.449416, again:x2.449416 */
+	{0x27}, /* index:84, gain:7.87500db -> x2.475996, again:x2.475996 */
+	{0x28}, /* index:85, gain:7.96875db -> x2.502865, again:x2.502865 */
+	{0x28}, /* index:86, gain:8.06250db -> x2.530026, again:x2.530026 */
+	{0x28}, /* index:87, gain:8.15625db -> x2.557482, again:x2.557482 */
+	{0x29}, /* index:88, gain:8.25000db -> x2.585235, again:x2.585235 */
+	{0x29}, /* index:89, gain:8.34375db -> x2.613289, again:x2.613289 */
+	{0x2a}, /* index:90, gain:8.43750db -> x2.641648, again:x2.641648 */
+	{0x2a}, /* index:91, gain:8.53125db -> x2.670315, again:x2.670315 */
+	{0x2b}, /* index:92, gain:8.62500db -> x2.699293, again:x2.699293 */
+	{0x2b}, /* index:93, gain:8.71875db -> x2.728585, again:x2.728585 */
+	{0x2c}, /* index:94, gain:8.81250db -> x2.758195, again:x2.758195 */
+	{0x2c}, /* index:95, gain:8.90625db -> x2.788127, again:x2.788127 */
+	{0x2d}, /* index:96, gain:9.00000db -> x2.818383, again:x2.818383 */
+	{0x2d}, /* index:97, gain:9.09375db -> x2.848968, again:x2.848968 */
+	{0x2e}, /* index:98, gain:9.18750db -> x2.879884, again:x2.879884 */
+	{0x2e}, /* index:99, gain:9.28125db -> x2.911136, again:x2.911136 */
+	{0x2f}, /* index:100, gain:9.37500db -> x2.942727, again:x2.942727 */
+	{0x2f}, /* index:101, gain:9.46875db -> x2.974661, again:x2.974661 */
+	{0x30}, /* index:102, gain:9.56250db -> x3.006942, again:x3.006942 */
+	{0x30}, /* index:103, gain:9.65625db -> x3.039572, again:x3.039572 */
+	{0x31}, /* index:104, gain:9.75000db -> x3.072557, again:x3.072557 */
+	{0x31}, /* index:105, gain:9.84375db -> x3.105900, again:x3.105900 */
+	{0x32}, /* index:106, gain:9.93750db -> x3.139605, again:x3.139605 */
+	{0x32}, /* index:107, gain:10.03125db -> x3.173675, again:x3.173675 */
+	{0x33}, /* index:108, gain:10.12500db -> x3.208116, again:x3.208116 */
+	{0x33}, /* index:109, gain:10.21875db -> x3.242930, again:x3.242930 */
+	{0x34}, /* index:110, gain:10.31250db -> x3.278121, again:x3.278121 */
+	{0x35}, /* index:111, gain:10.40625db -> x3.313695, again:x3.313695 */
+	{0x35}, /* index:112, gain:10.50000db -> x3.349654, again:x3.349654 */
+	{0x36}, /* index:113, gain:10.59375db -> x3.386004, again:x3.386004 */
+	{0x36}, /* index:114, gain:10.68750db -> x3.422749, again:x3.422749 */
+	{0x37}, /* index:115, gain:10.78125db -> x3.459892, again:x3.459892 */
+	{0x37}, /* index:116, gain:10.87500db -> x3.497438, again:x3.497438 */
+	{0x38}, /* index:117, gain:10.96875db -> x3.535391, again:x3.535391 */
+	{0x39}, /* index:118, gain:11.06250db -> x3.573757, again:x3.573757 */
+	{0x39}, /* index:119, gain:11.15625db -> x3.612539, again:x3.612539 */
+	{0x3a}, /* index:120, gain:11.25000db -> x3.651741, again:x3.651741 */
+	{0x3b}, /* index:121, gain:11.34375db -> x3.691369, again:x3.691369 */
+	{0x3b}, /* index:122, gain:11.43750db -> x3.731427, again:x3.731427 */
+	{0x3c}, /* index:123, gain:11.53125db -> x3.771920, again:x3.771920 */
+	{0x3d}, /* index:124, gain:11.62500db -> x3.812853, again:x3.812853 */
+	{0x3d}, /* index:125, gain:11.71875db -> x3.854229, again:x3.854229 */
+	{0x3e}, /* index:126, gain:11.81250db -> x3.896054, again:x3.896054 */
+	{0x3f}, /* index:127, gain:11.90625db -> x3.938333, again:x3.938333 */
+	{0x3f}, /* index:128, gain:12.00000db -> x3.981072, again:x3.981072 */
+	{0x40}, /* index:129, gain:12.09375db -> x4.024274, again:x4.024274 */
+	{0x41}, /* index:130, gain:12.18750db -> x4.067944, again:x4.067944 */
+	{0x41}, /* index:131, gain:12.28125db -> x4.112089, again:x4.112089 */
+	{0x42}, /* index:132, gain:12.37500db -> x4.156712, again:x4.156712 */
+	{0x43}, /* index:133, gain:12.46875db -> x4.201821, again:x4.201821 */
+	{0x43}, /* index:134, gain:12.56250db -> x4.247418, again:x4.247418 */
+	{0x44}, /* index:135, gain:12.65625db -> x4.293510, again:x4.293510 */
+	{0x45}, /* index:136, gain:12.75000db -> x4.340103, again:x4.340103 */
+	{0x46}, /* index:137, gain:12.84375db -> x4.387200, again:x4.387200 */
+	{0x46}, /* index:138, gain:12.93750db -> x4.434810, again:x4.434810 */
+	{0x47}, /* index:139, gain:13.03125db -> x4.482936, again:x4.482936 */
+	{0x48}, /* index:140, gain:13.12500db -> x4.531584, again:x4.531584 */
+	{0x49}, /* index:141, gain:13.21875db -> x4.580759, again:x4.580759 */
+	{0x4a}, /* index:142, gain:13.31250db -> x4.630469, again:x4.630469 */
+	{0x4a}, /* index:143, gain:13.40625db -> x4.680719, again:x4.680719 */
+	{0x4b}, /* index:144, gain:13.50000db -> x4.731513, again:x4.731513 */
+	{0x4c}, /* index:145, gain:13.59375db -> x4.782858, again:x4.782858 */
+	{0x4d}, /* index:146, gain:13.68750db -> x4.834761, again:x4.834761 */
+	{0x4e}, /* index:147, gain:13.78125db -> x4.887227, again:x4.887227 */
+	{0x4f}, /* index:148, gain:13.87500db -> x4.940262, again:x4.940262 */
+	{0x4f}, /* index:149, gain:13.96875db -> x4.993873, again:x4.993873 */
+	{0x50}, /* index:150, gain:14.06250db -> x5.048066, again:x5.048066 */
+	{0x51}, /* index:151, gain:14.15625db -> x5.102846, again:x5.102846 */
+	{0x52}, /* index:152, gain:14.25000db -> x5.158221, again:x5.158221 */
+	{0x53}, /* index:153, gain:14.34375db -> x5.214198, again:x5.214198 */
+	{0x54}, /* index:154, gain:14.43750db -> x5.270781, again:x5.270781 */
+	{0x55}, /* index:155, gain:14.53125db -> x5.327979, again:x5.327979 */
+	{0x56}, /* index:156, gain:14.62500db -> x5.385797, again:x5.385797 */
+	{0x57}, /* index:157, gain:14.71875db -> x5.444243, again:x5.444243 */
+	{0x58}, /* index:158, gain:14.81250db -> x5.503323, again:x5.503323 */
+	{0x59}, /* index:159, gain:14.90625db -> x5.563044, again:x5.563044 */
+	{0x59}, /* index:160, gain:15.00000db -> x5.623413, again:x5.623413 */
+	{0x5a}, /* index:161, gain:15.09375db -> x5.684437, again:x5.684437 */
+	{0x5b}, /* index:162, gain:15.18750db -> x5.746124, again:x5.746124 */
+	{0x5c}, /* index:163, gain:15.28125db -> x5.808480, again:x5.808480 */
+	{0x5d}, /* index:164, gain:15.37500db -> x5.871513, again:x5.871513 */
+	{0x5e}, /* index:165, gain:15.46875db -> x5.935229, again:x5.935229 */
+	{0x5f}, /* index:166, gain:15.56250db -> x5.999637, again:x5.999637 */
+	{0x61}, /* index:167, gain:15.65625db -> x6.064744, again:x6.064744 */
+	{0x62}, /* index:168, gain:15.75000db -> x6.130558, again:x6.130558 */
+	{0x63}, /* index:169, gain:15.84375db -> x6.197086, again:x6.197086 */
+	{0x64}, /* index:170, gain:15.93750db -> x6.264335, again:x6.264335 */
+	{0x65}, /* index:171, gain:16.03125db -> x6.332315, again:x6.332315 */
+	{0x66}, /* index:172, gain:16.12500db -> x6.401032, again:x6.401032 */
+	{0x67}, /* index:173, gain:16.21875db -> x6.470495, again:x6.470495 */
+	{0x68}, /* index:174, gain:16.31250db -> x6.540712, again:x6.540712 */
+	{0x69}, /* index:175, gain:16.40625db -> x6.611690, again:x6.611690 */
+	{0x6a}, /* index:176, gain:16.50000db -> x6.683439, again:x6.683439 */
+	{0x6c}, /* index:177, gain:16.59375db -> x6.755966, again:x6.755966 */
+	{0x6d}, /* index:178, gain:16.68750db -> x6.829282, again:x6.829282 */
+	{0x6e}, /* index:179, gain:16.78125db -> x6.903392, again:x6.903392 */
+	{0x6f}, /* index:180, gain:16.87500db -> x6.978306, again:x6.978306 */
+	{0x70}, /* index:181, gain:16.96875db -> x7.054033, again:x7.054033 */
+	{0x72}, /* index:182, gain:17.06250db -> x7.130582, again:x7.130582 */
+	{0x73}, /* index:183, gain:17.15625db -> x7.207963, again:x7.207963 */
+	{0x74}, /* index:184, gain:17.25000db -> x7.286182, again:x7.286182 */
+	{0x75}, /* index:185, gain:17.34375db -> x7.365250, again:x7.365250 */
+	{0x77}, /* index:186, gain:17.43750db -> x7.445176, again:x7.445176 */
+	{0x78}, /* index:187, gain:17.53125db -> x7.525970, again:x7.525970 */
+	{0x79}, /* index:188, gain:17.62500db -> x7.607641, again:x7.607641 */
+	{0x7b}, /* index:189, gain:17.71875db -> x7.690198, again:x7.690198 */
+	{0x7c}, /* index:190, gain:17.81250db -> x7.773650, again:x7.773650 */
+	{0x7d}, /* index:191, gain:17.90625db -> x7.858008, again:x7.858008 */
+	{0x7f}, /* index:192, gain:18.00000db -> x7.943282, again:x7.943282 */
+	{0x80}, /* index:193, gain:18.09375db -> x8.029482, again:x8.029482 */
+	{0x81}, /* index:194, gain:18.18750db -> x8.116616, again:x8.116616 */
+	{0x83}, /* index:195, gain:18.28125db -> x8.204696, again:x8.204696 */
+	{0x84}, /* index:196, gain:18.37500db -> x8.293732, again:x8.293732 */
+	{0x86}, /* index:197, gain:18.46875db -> x8.383734, again:x8.383734 */
+	{0x87}, /* index:198, gain:18.56250db -> x8.474713, again:x8.474713 */
+	{0x89}, /* index:199, gain:18.65625db -> x8.566679, again:x8.566679 */
+	{0x8a}, /* index:200, gain:18.75000db -> x8.659643, again:x8.659643 */
+	{0x8c}, /* index:201, gain:18.84375db -> x8.753616, again:x8.753616 */
+	{0x8d}, /* index:202, gain:18.93750db -> x8.848608, again:x8.848608 */
+	{0x8f}, /* index:203, gain:19.03125db -> x8.944633, again:x8.944633 */
+	{0x90}, /* index:204, gain:19.12500db -> x9.041698, again:x9.041698 */
+	{0x92}, /* index:205, gain:19.21875db -> x9.139817, again:x9.139817 */
+	{0x93}, /* index:206, gain:19.31250db -> x9.239000, again:x9.239000 */
+	{0x95}, /* index:207, gain:19.40625db -> x9.339260, again:x9.339260 */
+	{0x97}, /* index:208, gain:19.50000db -> x9.440609, again:x9.440609 */
+	{0x98}, /* index:209, gain:19.59375db -> x9.543057, again:x9.543057 */
+	{0x9a}, /* index:210, gain:19.68750db -> x9.646616, again:x9.646616 */
+	{0x9c}, /* index:211, gain:19.78125db -> x9.751299, again:x9.751299 */
+	{0x9d}, /* index:212, gain:19.87500db -> x9.857118, again:x9.857118 */
+	{0x9f}, /* index:213, gain:19.96875db -> x9.964087, again:x9.964087 */
+	{0xa1}, /* index:214, gain:20.06250db -> x10.072214, again:x10.072214 */
+	{0xa2}, /* index:215, gain:20.15625db -> x10.181517, again:x10.181517 */
+	{0xa4}, /* index:216, gain:20.25000db -> x10.292006, again:x10.292006 */
+	{0xa6}, /* index:217, gain:20.34375db -> x10.403692, again:x10.403692 */
+	{0xa8}, /* index:218, gain:20.43750db -> x10.516592, again:x10.516592 */
+	{0xaa}, /* index:219, gain:20.53125db -> x10.630714, again:x10.630714 */
+	{0xab}, /* index:220, gain:20.62500db -> x10.746078, again:x10.746078 */
+	{0xad}, /* index:221, gain:20.71875db -> x10.862694, again:x10.862694 */
+	{0xaf}, /* index:222, gain:20.81250db -> x10.980572, again:x10.980572 */
+	{0xb1}, /* index:223, gain:20.90625db -> x11.099733, again:x11.099733 */
+	{0xb3}, /* index:224, gain:21.00000db -> x11.220183, again:x11.220183 */
+	{0xb5}, /* index:225, gain:21.09375db -> x11.341944, again:x11.341944 */
+	{0xb7}, /* index:226, gain:21.18750db -> x11.465026, again:x11.465026 */
+	{0xb9}, /* index:227, gain:21.28125db -> x11.589441, again:x11.589441 */
+	{0xbb}, /* index:228, gain:21.37500db -> x11.715209, again:x11.715209 */
+	{0xbd}, /* index:229, gain:21.46875db -> x11.842338, again:x11.842338 */
+	{0xbf}, /* index:230, gain:21.56250db -> x11.970850, again:x11.970850 */
+	{0xc1}, /* index:231, gain:21.65625db -> x12.100757, again:x12.100757 */
+	{0xc3}, /* index:232, gain:21.75000db -> x12.232071, again:x12.232071 */
+	{0xc5}, /* index:233, gain:21.84375db -> x12.364812, again:x12.364812 */
+	{0xc7}, /* index:234, gain:21.93750db -> x12.498991, again:x12.498991 */
+	{0xca}, /* index:235, gain:22.03125db -> x12.634629, again:x12.634629 */
+	{0xcc}, /* index:236, gain:22.12500db -> x12.771739, again:x12.771739 */
+	{0xce}, /* index:237, gain:22.21875db -> x12.910334, again:x12.910334 */
+	{0xd0}, /* index:238, gain:22.31250db -> x13.050436, again:x13.050436 */
+	{0xd3}, /* index:239, gain:22.40625db -> x13.192055, again:x13.192055 */
+	{0xd5}, /* index:240, gain:22.50000db -> x13.335214, again:x13.335214 */
+	{0xd7}, /* index:241, gain:22.59375db -> x13.479927, again:x13.479927 */
+	{0xda}, /* index:242, gain:22.68750db -> x13.626207, again:x13.626207 */
+	{0xdc}, /* index:243, gain:22.78125db -> x13.774078, again:x13.774078 */
+	{0xde}, /* index:244, gain:22.87500db -> x13.923549, again:x13.923549 */
+	{0xe1}, /* index:245, gain:22.96875db -> x14.074647, again:x14.074647 */
+	{0xe3}, /* index:246, gain:23.06250db -> x14.227384, again:x14.227384 */
+	{0xe6}, /* index:247, gain:23.15625db -> x14.381775, again:x14.381775 */
+	{0xe8}, /* index:248, gain:23.25000db -> x14.537845, again:x14.537845 */
+	{0xeb}, /* index:249, gain:23.34375db -> x14.695604, again:x14.695604 */
+	{0xed}, /* index:250, gain:23.43750db -> x14.855080, again:x14.855080 */
+	{0xf0}, /* index:251, gain:23.53125db -> x15.016287, again:x15.016287 */
+	{0xf2}, /* index:252, gain:23.62500db -> x15.179238, again:x15.179238 */
+	{0xf5}, /* index:253, gain:23.71875db -> x15.343962, again:x15.343962 */
+	{0xf8}, /* index:254, gain:23.81250db -> x15.510470, again:x15.510470 */
+	{0xfa}, /* index:255, gain:23.90625db -> x15.678788, again:x15.678788 */
+	{0xfd}, /* index:256, gain:24.00000db -> x15.848934, again:x15.848934 */
+};
+
diff --git a/drivers/vin/sensors/omnivision_ov2735_parallel/Kbuild b/drivers/vin/sensors/omnivision_ov2735_parallel/Kbuild
new file mode 100644
index 0000000..10efc5b
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2735_parallel/Kbuild
@@ -0,0 +1,39 @@
+##
+## Filename : Kbuild
+##
+## History:
+##    2017/01/10 - [Hao Zeng] created file
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+
+EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
+EXTRA_AFLAGS		+= $(AMBARELLA_DRV_AFLAGS)
+EXTRA_LDFLAGS		+= $(AMBARELLA_DRV_LDFLAGS)
+
+obj-m := ov2735_parallel.o
+ov2735_parallel-y := ov2735.o
+
diff --git a/drivers/vin/sensors/omnivision_ov2735_parallel/make.inc b/drivers/vin/sensors/omnivision_ov2735_parallel/make.inc
new file mode 100644
index 0000000..80d86c3
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2735_parallel/make.inc
@@ -0,0 +1,45 @@
+##
+## kernel/private/drivers/vin/sensors/omnivision_ov2735_parallel/make.inc
+##
+## History:
+##    2017/01/10 - [Hao Zeng] created file
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+ifeq ($(CONFIG_SENSOR_OV2735_PARALLEL), y)
+
+LOCAL_PATH	:= $(call my-dir)
+
+###
+include $(CLEAR_VARS)
+
+LOCAL_SRCS	:= $(wildcard $(LOCAL_PATH)/*.c) $(wildcard $(LOCAL_PATH)/*.h)
+LOCAL_SRCS	+= $(LOCAL_PATH)/Kbuild
+
+include $(BUILD_DRIVER)
+
+endif
+
diff --git a/drivers/vin/sensors/omnivision_ov2735_parallel/ov2735.c b/drivers/vin/sensors/omnivision_ov2735_parallel/ov2735.c
new file mode 100644
index 0000000..89e8c31
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2735_parallel/ov2735.c
@@ -0,0 +1,574 @@
+/*
+ * Filename : ov2735.c
+ *
+ * History:
+ *    2017/01/10 - [Hao Zeng] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/ambpriv_device.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <iav_utils.h>
+#include <vin_api.h>
+#include "ov2735.h"
+#include "ov2735_table.c"
+
+static int bus_addr = (0 << 16) | (0x78 >> 1);
+module_param(bus_addr, int, 0644);
+MODULE_PARM_DESC(bus_addr, " bus and addr: bit16~bit31: bus, bit0~bit15: addr");
+
+static int bayer_pattern = VINDEV_BAYER_PATTERN_AUTO;
+module_param(bayer_pattern, int, 0644);
+MODULE_PARM_DESC(bayer_pattern, "set bayer pattern: 0:RG, 1:BG, 2:GR, 3:GB, 255:default");
+
+struct ov2735_priv {
+	void *control_data;
+	u32 line_length;
+	u32 frame_length_lines;
+	u32 vblank;
+	u32 vts;
+};
+
+static int ov2735_write_reg(struct vin_device *vdev, u32 subaddr, u32 data)
+{
+	int rval;
+	struct ov2735_priv *ov2735;
+	struct i2c_client *client;
+	struct i2c_msg msgs[1];
+	u8 pbuf[2];
+
+	ov2735 = (struct ov2735_priv *)vdev->priv;
+	client = ov2735->control_data;
+
+	pbuf[0] = (subaddr & 0xff);
+	pbuf[1] = data;
+
+	msgs[0].len = 2;
+	msgs[0].addr = client->addr;
+	if (unlikely(subaddr == OV2735_SWRESET))
+		msgs[0].flags = client->flags | I2C_M_IGNORE_NAK;
+	else
+		msgs[0].flags = client->flags;
+	msgs[0].buf = pbuf;
+
+	rval = i2c_transfer(client->adapter, msgs, 1);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x:0x%x]\n", rval, subaddr, data);
+		return rval;
+	}
+
+	return 0;
+}
+
+static int ov2735_write_reg2(struct vin_device *vdev, u32 subaddr, u32 data)
+{
+	int rval;
+	struct ov2735_priv *ov2735;
+	struct i2c_client *client;
+	struct i2c_msg msgs[1];
+	u8 pbuf[3];
+
+	ov2735 = (struct ov2735_priv *)vdev->priv;
+	client = ov2735->control_data;
+
+	pbuf[0] = (subaddr & 0xff);
+	pbuf[1] = (data >> 8) & 0xff;
+	pbuf[2] = (data & 0xff);
+
+	msgs[0].len = 3;
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].buf = pbuf;
+
+	rval = i2c_transfer(client->adapter, msgs, 1);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x:0x%x]\n", rval, subaddr, data);
+		return rval;
+	}
+
+	return 0;
+}
+
+static int ov2735_read_reg(struct vin_device *vdev, u32 subaddr, u32 *data)
+{
+	int rval = 0;
+	struct ov2735_priv *ov2735;
+	struct i2c_client *client;
+	struct i2c_msg msgs[2];
+	u8 pbuf0[1];
+	u8 pbuf[1];
+
+	ov2735 = (struct ov2735_priv *)vdev->priv;
+	client = ov2735->control_data;
+
+	pbuf0[0] = (subaddr & 0xff);
+
+	msgs[0].len = 1;
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].buf = pbuf0;
+
+	msgs[1].addr = client->addr;
+	msgs[1].flags = client->flags | I2C_M_RD;
+	msgs[1].buf = pbuf;
+	msgs[1].len = 1;
+
+	rval = i2c_transfer(client->adapter, msgs, 2);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x]\n", rval, subaddr);
+		return rval;
+	}
+
+	*data = pbuf[0];
+
+	return 0;
+}
+
+static int ov2735_set_vin_mode(struct vin_device *vdev, struct vin_video_format *format)
+{
+	struct vin_device_config ov2735_config;
+
+	memset(&ov2735_config, 0, sizeof(ov2735_config));
+
+	ov2735_config.interface_type = SENSOR_PARALLEL_LVCMOS;
+	ov2735_config.input_mode = SENSOR_RGB_1PIX;
+
+	ov2735_config.plvcmos_cfg.vs_hs_polarity = SENSOR_VS_LOW | SENSOR_HS_HIGH;
+	ov2735_config.plvcmos_cfg.data_edge = SENSOR_DATA_RISING_EDGE;
+	ov2735_config.plvcmos_cfg.paralle_sync_type = SENSOR_PARALLEL_SYNC_601;
+
+	ov2735_config.cap_win.x = format->def_start_x;
+	ov2735_config.cap_win.y = format->def_start_y;
+	ov2735_config.cap_win.width = format->def_width;
+	ov2735_config.cap_win.height = format->def_height;
+
+	ov2735_config.sensor_id	= GENERIC_SENSOR;
+	ov2735_config.input_format	= AMBA_VIN_INPUT_FORMAT_RGB_RAW;
+	ov2735_config.bayer_pattern	= format->bayer_pattern;
+	ov2735_config.video_format	= format->format;
+	ov2735_config.bit_resolution	= format->bits;
+
+	return ambarella_set_vin_config(vdev, &ov2735_config);
+}
+
+static void ov2735_sw_reset(struct vin_device *vdev)
+{
+	ov2735_write_reg(vdev, OV2735_PAGE_FLG, 0x00);
+	ov2735_write_reg(vdev, OV2735_SWRESET, 0x00);/* Software reset */
+	msleep(3);
+}
+
+static int ov2735_init_device(struct vin_device *vdev)
+{
+	ov2735_sw_reset(vdev);
+	return 0;
+}
+
+static void ov2735_start_streaming(struct vin_device *vdev)
+{
+	ov2735_write_reg(vdev, OV2735_FR_SYNC_EN, 0x01);
+	/* wait some time for register effective */
+	msleep(30);
+}
+
+static int ov2735_update_hv_info(struct vin_device *vdev)
+{
+	u32 val_high, val_low;
+	struct ov2735_priv *pinfo = (struct ov2735_priv *)vdev->priv;
+
+	ov2735_write_reg(vdev, OV2735_PAGE_FLG, 0x01);
+
+	ov2735_read_reg(vdev, OV2735_HTS_MSB, &val_high);
+	ov2735_read_reg(vdev, OV2735_HTS_LSB, &val_low);
+	pinfo->line_length = (val_high << 8) + val_low;
+	if (unlikely(!pinfo->line_length)) {
+		vin_error("line length is 0!\n");
+		return -EIO;
+	}
+
+	ov2735_read_reg(vdev, OV2735_VTS_MSB, &val_high);
+	ov2735_read_reg(vdev, OV2735_VTS_LSB, &val_low);
+	pinfo->vts = (val_high << 8) + val_low;
+
+	ov2735_read_reg(vdev, OV2735_FR_LENGTH_MSB, &val_high);
+	ov2735_read_reg(vdev, OV2735_FR_LENGTH_LSB, &val_low);
+	pinfo->frame_length_lines = (val_high << 8) + val_low;
+
+	ov2735_read_reg(vdev, OV2735_VB_MSB, &val_high);
+	ov2735_read_reg(vdev, OV2735_VB_LSB, &val_low);
+	pinfo->vblank = (val_high << 8) + val_low;
+
+	vin_debug("hts:%d, vts:%d, frame_length_lines:%d, vblank:%d\n",
+		pinfo->line_length, pinfo->vts, pinfo->frame_length_lines, pinfo->vblank);
+
+	return 0;
+}
+
+static int ov2735_get_line_time(struct vin_device *vdev)
+{
+	u64 h_clks;
+	struct ov2735_priv *pinfo = (struct ov2735_priv *)vdev->priv;
+
+	h_clks = (u64)pinfo->line_length * 512000000;
+	h_clks = DIV64_CLOSEST(h_clks, vdev->cur_pll->pixelclk);
+
+	vdev->cur_format->line_time = (u32)h_clks;
+
+	return 0;
+}
+
+static int ov2735_set_format(struct vin_device *vdev, struct vin_video_format *format)
+{
+	int rval;
+	struct vin_reg_8_8 *regs;
+	int i, regs_num;
+
+	switch (format->video_mode) {
+	case AMBA_VIDEO_MODE_1080P:
+		regs = ov2735_1080p_regs;
+		regs_num = ARRAY_SIZE(ov2735_1080p_regs);
+		break;
+	case AMBA_VIDEO_MODE_720P:
+		regs = ov2735_720p_regs;
+		regs_num = ARRAY_SIZE(ov2735_720p_regs);
+		break;
+	default:
+		regs = NULL;
+		regs_num = 0;
+		vin_error("Unknown mode\n");
+		return -EINVAL;
+	}
+	for (i = 0; i < regs_num; i++) {
+		ov2735_write_reg(vdev, regs[i].addr, regs[i].data);
+		if (unlikely(regs[i].addr == OV2735_SWRESET))
+			msleep(3);
+	}
+
+	/* Enable Streaming */
+	ov2735_start_streaming(vdev);
+
+	rval = ov2735_update_hv_info(vdev);
+	if (rval < 0)
+		return rval;
+
+	ov2735_get_line_time(vdev);
+
+	/* communicate with IAV */
+	rval = ov2735_set_vin_mode(vdev, format);
+	if (rval < 0)
+		return rval;
+
+	return 0;
+}
+
+static int ov2735_set_hold_mode(struct vin_device *vdev, u32 hold_mode)
+{
+	if (hold_mode)
+		ov2735_write_reg(vdev, OV2735_PAGE_FLG, 0x01);
+	else
+		ov2735_write_reg(vdev, OV2735_FR_SYNC_EN, 0x01);
+
+	return 0;
+}
+
+static int ov2735_set_shutter_row(struct vin_device *vdev, u32 row)
+{
+	u64 exposure_lines;
+	u32 num_line, min_line, max_line;
+	int rval = 0;
+	struct ov2735_priv *pinfo = (struct ov2735_priv *)vdev->priv;
+
+	num_line = row;
+
+	/* FIXME: shutter width: 2 ~ (Frame format(V) - 4) */
+	min_line = 2;
+	max_line = pinfo->vts - 4;
+	num_line = clamp(num_line, min_line, max_line);
+
+	ov2735_write_reg2(vdev, OV2735_EXPO_MSB, num_line & 0xFFFF);
+
+	exposure_lines = num_line;
+	exposure_lines = exposure_lines * (u64)pinfo->line_length * 512000000;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, vdev->cur_pll->pixelclk);
+
+	vdev->shutter_time = (u32)exposure_lines;
+	vin_debug("shutter_time:%d, row:%d\n", vdev->shutter_time, num_line);
+
+	return rval;
+}
+
+static int ov2735_shutter2row(struct vin_device *vdev, u32 *shutter_time)
+{
+	u64 exposure_lines;
+	int rval = 0;
+	struct ov2735_priv *pinfo = (struct ov2735_priv *)vdev->priv;
+
+	/* for fast boot, it may call set shutter time directly, so we must read line length/frame line */
+	if (unlikely(!pinfo->line_length)) {
+		rval = ov2735_update_hv_info(vdev);
+		if (rval < 0)
+			return rval;
+	}
+
+	exposure_lines = (*shutter_time) * (u64)vdev->cur_pll->pixelclk;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, pinfo->line_length);
+	exposure_lines = DIV64_CLOSEST(exposure_lines, 512000000);
+
+	*shutter_time = exposure_lines;
+
+	return rval;
+}
+
+static int ov2735_set_fps(struct vin_device *vdev, int fps)
+{
+	u64 v_lines, vb_time;
+	u32 vb_lines;
+	struct ov2735_priv *pinfo = (struct ov2735_priv *)vdev->priv;
+
+	v_lines = fps * (u64)vdev->cur_pll->pixelclk;
+	v_lines = DIV64_CLOSEST(v_lines, pinfo->line_length);
+	v_lines = DIV64_CLOSEST(v_lines, 512000000);
+
+	if (unlikely(v_lines < pinfo->frame_length_lines + 1)) {
+		vin_error("VTS:%lld should be larger than frame_length_lines:%d\n",
+			v_lines, pinfo->frame_length_lines);
+		return -EPERM;
+	} else {
+		vb_lines = v_lines - pinfo->frame_length_lines - 1;
+	}
+
+	ov2735_write_reg(vdev, OV2735_PAGE_FLG, 0x01);
+	ov2735_write_reg2(vdev, OV2735_VB_MSB, vb_lines & 0xFFFF);
+	ov2735_write_reg(vdev, OV2735_FR_SYNC_EN, 0x01);
+
+	pinfo->vts = (u32)v_lines;
+
+	vb_time = pinfo->line_length * (u64)(v_lines - vdev->cur_format->height) * 1000000000;
+	vb_time = DIV64_CLOSEST(vb_time, vdev->cur_pll->pixelclk);
+	vdev->cur_format->vb_time = vb_time;
+
+	return 0;
+}
+
+static int ov2735_set_agc_index(struct vin_device *vdev, int agc_idx)
+{
+	if (agc_idx > OV2735_GAIN_MAXDB) {
+		vin_warn("agc index %d exceeds maximum %d\n", agc_idx, OV2735_GAIN_MAXDB);
+		agc_idx = OV2735_GAIN_MAXDB;
+	}
+
+	/* Analog Gain */
+	ov2735_write_reg(vdev, OV2735_AGAIN_LSB, OV2735_GAIN_TABLE[agc_idx][OV2735_GAIN_COL_AGAIN]);
+
+	return 0;
+}
+
+static int ov2735_set_mirror_mode(struct vin_device *vdev,
+	struct vindev_mirror *mirror_mode)
+{
+	int rval = 0;
+	u32 tmp_reg, bayer_pattern, readmode = 0;
+	u32 reg_f8;
+
+	switch (mirror_mode->pattern) {
+	case VINDEV_MIRROR_AUTO:
+		return 0;
+
+	case VINDEV_MIRROR_NONE:
+		bayer_pattern = VINDEV_BAYER_PATTERN_RG;
+		reg_f8 = 0x02;
+		break;
+
+	case VINDEV_MIRROR_VERTICALLY:
+		readmode = OV2735_V_FLIP;
+		bayer_pattern = VINDEV_BAYER_PATTERN_GB;
+		reg_f8 = 0x00;
+		break;
+
+	case VINDEV_MIRROR_HORRIZONTALLY:
+		readmode = OV2735_H_MIRROR;
+		bayer_pattern = VINDEV_BAYER_PATTERN_GR;
+		reg_f8 = 0x00;
+		break;
+
+	case VINDEV_MIRROR_HORRIZONTALLY_VERTICALLY:
+		readmode = OV2735_V_FLIP + OV2735_H_MIRROR;
+		bayer_pattern = VINDEV_BAYER_PATTERN_BG;
+		reg_f8 = 0x02;
+		break;
+
+	default:
+		vin_error("do not support cmd mirror mode\n");
+		return -EINVAL;
+	}
+
+	ov2735_write_reg(vdev, OV2735_PAGE_FLG, 0x01);
+	ov2735_read_reg(vdev, OV2735_UPDOWN_MIRROR, &tmp_reg);
+	tmp_reg |= OV2735_MIRROR_MASK;
+	tmp_reg ^= readmode;
+	ov2735_write_reg(vdev, OV2735_UPDOWN_MIRROR, tmp_reg);
+	ov2735_write_reg(vdev, 0xf8, reg_f8);
+	ov2735_write_reg(vdev, OV2735_FR_SYNC_EN, 0x01);
+
+	if (mirror_mode->bayer_pattern == VINDEV_BAYER_PATTERN_AUTO)
+		mirror_mode->bayer_pattern = bayer_pattern;
+
+	return rval;
+}
+
+static struct vin_ops ov2735_ops = {
+	.init_device		= ov2735_init_device,
+	.set_format		= ov2735_set_format,
+	.set_shutter_row	= ov2735_set_shutter_row,
+	.shutter2row		= ov2735_shutter2row,
+	.set_frame_rate	= ov2735_set_fps,
+	.set_agc_index		= ov2735_set_agc_index,
+	.set_mirror_mode	= ov2735_set_mirror_mode,
+	.set_hold_mode		= ov2735_set_hold_mode,
+	.shutter2row		= ov2735_shutter2row,
+	.read_reg		= ov2735_read_reg,
+	.write_reg		= ov2735_write_reg,
+};
+
+/* ========================================================================== */
+static int ov2735_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	int i, rval = 0;
+	struct vin_device *vdev;
+	struct ov2735_priv *ov2735;
+	u32 cid_l, cid_h;
+
+	vdev = ambarella_vin_create_device(client->name,
+		SENSOR_OV2735, sizeof(struct ov2735_priv));
+	if (!vdev)
+		return -ENOMEM;
+
+	vdev->intf_id = 0;
+	vdev->dev_type = VINDEV_TYPE_SENSOR;
+	vdev->sub_type = VINDEV_SUBTYPE_CMOS;
+	vdev->default_mode = AMBA_VIDEO_MODE_1080P;
+	vdev->default_hdr_mode = AMBA_VIDEO_LINEAR_MODE;
+	vdev->agc_db_max = 0x18000000;  /* 24dB */
+	vdev->agc_db_min = 0x00000000;  /* 0dB */
+	vdev->agc_db_step = 0x00180000; /* 0.09375dB */
+
+	i2c_set_clientdata(client, vdev);
+
+	ov2735 = (struct ov2735_priv *)vdev->priv;
+	ov2735->control_data = client;
+
+	if (bayer_pattern != VINDEV_BAYER_PATTERN_AUTO) {
+		if (bayer_pattern > VINDEV_BAYER_PATTERN_GB) {
+			vin_error("invalid bayer pattern:%d\n", bayer_pattern);
+			return -EINVAL;
+		} else {
+			for (i = 0; i < ARRAY_SIZE(ov2735_formats); i++)
+				ov2735_formats[i].default_bayer_pattern = bayer_pattern;
+		}
+	}
+
+	rval = ambarella_vin_register_device(vdev, &ov2735_ops,
+		ov2735_formats, ARRAY_SIZE(ov2735_formats),
+		ov2735_plls, ARRAY_SIZE(ov2735_plls));
+	if (rval < 0)
+		goto ov2735_probe_err;
+
+	/* query sensor id and revision */
+	ov2735_read_reg(vdev, OV2735_CHIP_ID_H, &cid_h);
+	ov2735_read_reg(vdev, OV2735_CHIP_ID_L, &cid_l);
+	vin_info("OV2735 init(parallel), Chip ID:0x%x\n", (cid_h<<8)+cid_l);
+
+	return 0;
+
+ov2735_probe_err:
+	ambarella_vin_free_device(vdev);
+	return rval;
+}
+
+static int ov2735_remove(struct i2c_client *client)
+{
+	struct vin_device *vdev;
+
+	vdev = (struct vin_device *)i2c_get_clientdata(client);
+	ambarella_vin_unregister_device(vdev);
+	ambarella_vin_free_device(vdev);
+
+	return 0;
+}
+
+static const struct i2c_device_id ov2735_idtable[] = {
+	{ "ov2735", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ov2735_idtable);
+
+static struct i2c_driver i2c_driver_ov2735 = {
+	.driver = {
+		.name	= "ov2735",
+	},
+
+	.id_table	= ov2735_idtable,
+	.probe		= ov2735_probe,
+	.remove		= ov2735_remove,
+
+};
+
+static int __init ov2735_init(void)
+{
+	int bus, addr, rval;
+
+	bus = bus_addr >> 16;
+	addr = bus_addr & 0xffff;
+
+	rval = ambpriv_i2c_update_addr("ov2735", bus, addr);
+	if (rval < 0)
+		return rval;
+
+	rval = i2c_add_driver(&i2c_driver_ov2735);
+	if (rval < 0)
+		return rval;
+
+	return 0;
+}
+
+static void __exit ov2735_exit(void)
+{
+	i2c_del_driver(&i2c_driver_ov2735);
+}
+
+module_init(ov2735_init);
+module_exit(ov2735_exit);
+
+MODULE_DESCRIPTION("OV2735 1/2.7-Inch, 1920x1080, 2-Megapixel CMOS Digital Image Sensor");
+MODULE_AUTHOR("Hao Zeng, <haozeng@ambarella.com>");
+MODULE_LICENSE("Proprietary");
+
diff --git a/drivers/vin/sensors/omnivision_ov2735_parallel/ov2735.h b/drivers/vin/sensors/omnivision_ov2735_parallel/ov2735.h
new file mode 100644
index 0000000..3903db9
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2735_parallel/ov2735.h
@@ -0,0 +1,76 @@
+/*
+ * Filename : ov2735.h
+ *
+ * History:
+ *    2017/01/10 - [Hao Zeng] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __OV2735_H__
+#define __OV2735_H__
+
+/****** page 0 ******/
+#define OV2735_SWRESET		0x20
+
+#define OV2735_CHIP_ID_H		0x02
+#define OV2735_CHIP_ID_L		0x03
+
+#define OV2735_PAGE_FLG		0xFD
+
+/****** page 1 ******/
+#define OV2735_FR_SYNC_EN	0x01
+
+#define OV2735_EXPO_MSB		0x03
+#define OV2735_EXPO_LSB		0x04
+
+#define OV2735_AGAIN_MSB		0x38
+#define OV2735_AGAIN_LSB		0x24
+#define OV2735_DGAIN			0x39
+#define OV2735_R_GAIN			0x40
+#define OV2735_GR_GAIN		0x41
+#define OV2735_GB_GAIN		0x42
+#define OV2735_B_GAIN			0x43
+
+#define OV2735_VB_MSB			0x05
+#define OV2735_VB_LSB			0x06
+
+#define OV2735_FR_LENGTH_CTRL	0x0D
+#define OV2735_FR_LENGTH_MSB		0x0E
+#define OV2735_FR_LENGTH_LSB		0x0F
+#define OV2735_VTS_MSB		0x4E
+#define OV2735_VTS_LSB		0x4F
+#define OV2735_HTS_MSB		0x8C
+#define OV2735_HTS_LSB		0x8D
+
+#define OV2735_UPDOWN_MIRROR	0x3F
+
+#define OV2735_V_FLIP				(1<<1)
+#define OV2735_H_MIRROR			(1<<0)
+#define OV2735_MIRROR_MASK		(OV2735_H_MIRROR + OV2735_V_FLIP)
+
+#endif /* __OV2735_H__ */
+
diff --git a/drivers/vin/sensors/omnivision_ov2735_parallel/ov2735_table.c b/drivers/vin/sensors/omnivision_ov2735_parallel/ov2735_table.c
new file mode 100644
index 0000000..81ad991
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2735_parallel/ov2735_table.c
@@ -0,0 +1,585 @@
+/*
+ * Filename : ov2735_table.c
+ *
+ * History:
+ *    2017/01/10 - [Hao Zeng] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+static struct vin_video_pll ov2735_plls[] = {
+	{0, 24000000, 41993148},
+	{0, 24000000, 41964000},
+};
+
+static struct vin_video_format ov2735_formats[] = {
+	{
+		.video_mode = AMBA_VIDEO_MODE_1080P,
+		.def_start_x = 0,
+		.def_start_y = 0,
+		.def_width = 1920,
+		.def_height = 1080,
+		/* sensor mode */
+		.device_mode = 0,
+		.pll_idx = 0,
+		.width = 1920,
+		.height = 1080,
+		.format = AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type = AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits = AMBA_VIDEO_BITS_10,
+		.ratio = AMBA_VIDEO_RATIO_16_9,
+		.max_fps = AMBA_VIDEO_FPS_30,
+		.default_fps = AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern = VINDEV_BAYER_PATTERN_RG,
+	},
+	{
+		.video_mode = AMBA_VIDEO_MODE_720P,
+		.def_start_x = 0,
+		.def_start_y = 0,
+		.def_width = 1280,
+		.def_height = 720,
+		/* sensor mode */
+		.device_mode = 1,
+		.pll_idx = 1,
+		.width = 1280,
+		.height = 720,
+		.format = AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type = AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits = AMBA_VIDEO_BITS_10,
+		.ratio = AMBA_VIDEO_RATIO_16_9,
+		.max_fps = AMBA_VIDEO_FPS_60,
+		.default_fps = AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern = VINDEV_BAYER_PATTERN_RG,
+	},
+};
+
+static struct vin_reg_8_8 ov2735_1080p_regs[] = {
+	/* DVP_1920x1080_84M_raw10_30fps */
+	{0xfd, 0x00},
+	{0x20, 0x00},
+	{0xfd, 0x00},
+	{0x2f, 0x10},
+	{0x34, 0x00},
+	{0x30, 0x15},
+	{0x33, 0x01},
+	{0x35, 0x20},
+	{0x1b, 0x00},
+	{0x1d, 0xa5},
+	{0xfd, 0x01},
+	{0x0d, 0x00},
+	{0x30, 0x00},
+	{0x03, 0x01},
+	{0x04, 0x8f},
+	{0x01, 0x01},
+	{0x09, 0x00},
+	{0x0a, 0x20},
+	{0x06, 0x0a},
+	{0x24, 0x10},
+	{0x01, 0x01},
+	{0xfb, 0x73},
+	{0x01, 0x01},
+	{0xfd, 0x01},
+	{0x1a, 0x6b},
+	{0x1c, 0xea},
+	{0x16, 0x0c},
+	{0x21, 0x00},
+	{0x11, 0x63},
+	{0x19, 0xc3},
+	{0x26, 0x5a},
+	{0x29, 0x01},
+	{0x33, 0x6f},
+	{0x2a, 0xd2},
+	{0x2c, 0x40},
+	{0xd0, 0x02},
+	{0xd1, 0x01},
+	{0xd2, 0x20},
+	{0xd3, 0x04},
+	{0xd4, 0x2a},
+	{0x50, 0x00},
+	{0x51, 0x2c},
+	{0x52, 0x29},
+	{0x53, 0x00},
+	{0x55, 0x44},
+	{0x58, 0x29},
+	{0x5a, 0x00},
+	{0x5b, 0x00},
+	{0x5d, 0x00},
+	{0x64, 0x2f},
+	{0x66, 0x62},
+	{0x68, 0x5b},
+	{0x75, 0x46},
+	{0x76, 0x36},
+	{0x77, 0x4f},
+	{0x78, 0xef},
+	{0x72, 0xcf},
+	{0x73, 0x36},
+	{0x7d, 0x0d},
+	{0x7e, 0x0d},
+	{0x8a, 0x77},
+	{0x8b, 0x77},
+	{0xfd, 0x01},
+	{0xb1, 0x82},
+	{0xb3, 0x0b},
+	{0xb4, 0x14},
+	{0x9d, 0x40},
+	{0xa1, 0x05},
+	{0x94, 0x44},
+	{0x95, 0x33},
+	{0x96, 0x1f},
+	{0x98, 0x45},
+	{0x9c, 0x10},
+	{0xb5, 0x70},
+	{0xa0, 0x00},
+	{0x25, 0xe0},
+	{0x20, 0x7b},
+	{0x8f, 0x88},
+	{0x91, 0x40},
+	{0xfd, 0x01},
+	{0xfd, 0x02},
+	{0xa1, 0x04},
+	{0xa3, 0x40},
+	{0xa5, 0x02},
+	{0xa7, 0xc4},
+	{0xfd, 0x01},
+	{0x86, 0x77},
+	{0x89, 0x77},
+	{0x87, 0x74},
+	{0x88, 0x74},
+	{0xfc, 0xe0},
+	{0xfe, 0xe0},
+	{0xf0, 0x40},
+	{0xf1, 0x40},
+	{0xf2, 0x40},
+	{0xf3, 0x40},
+	{0xfd, 0x02},
+	{0x36, 0x08},/* invert Vsync polarity for Gaia */
+	{0xa0, 0x00},/* Image vertical start MSB3bits */
+	{0xa1, 0x08},/* Image vertical start LSB8bits */
+	{0xa2, 0x04},/* image vertical size  MSB8bits */
+	{0xa3, 0x38},/* image vertical size  LSB8bits */
+	{0xa4, 0x00},
+	{0xa5, 0x08},/* H start 8Lsb */
+	{0xa6, 0x03},
+	{0xa7, 0xc0},/* Half H size Lsb8bits */
+
+	/* Default Mirror_On_Flip_On */
+	{0xfd, 0x01},
+	{0x3f, 0x03},
+	{0xf8, 0x02},
+
+	{0xfd, 0x01},
+	{0x06, 0xe0},/* insert dummy line , the frame rate is 30.01. */
+	{0x01, 0x01},
+};
+
+static struct vin_reg_8_8 ov2735_720p_regs[] = {
+	/* DVP_1280x720_84M_raw10_60fps */
+	{0xfd, 0x00},
+	{0x20, 0x00},
+	{0xfd, 0x00},
+	{0x2f, 0x10},
+	{0x34, 0x00},
+	{0x30, 0x15},
+	{0x33, 0x01},
+	{0x35, 0x20},
+	{0x1b, 0x00},
+	{0x1d, 0xa5},
+	{0xfd, 0x01},
+	{0x31, 0x01},
+	{0x0d, 0x00},
+	{0x30, 0x00},
+	{0x03, 0x01},
+	{0x04, 0xd5},
+	{0x09, 0x00},
+	{0x0a, 0x80},
+	{0x06, 0x0a},
+	{0x24, 0x10},
+	{0x01, 0x01},
+	{0xfb, 0x73},
+	{0xfd, 0x01},
+	{0x1a, 0x6b},
+	{0x1c, 0xea},
+	{0x16, 0x0c},
+	{0x21, 0x00},
+	{0x25, 0xe0},
+	{0x26, 0x5a},
+	{0x11, 0x56},
+	{0x19, 0xc3},
+	{0x29, 0x01},
+	{0x33, 0x5f},
+	{0x2a, 0xd2},
+	{0x2c, 0x40},
+	{0xd0, 0x02},
+	{0xd1, 0x01},
+	{0xd2, 0x20},
+	{0xd3, 0x04},
+	{0xd4, 0x2a},
+	{0x50, 0x00},
+	{0x51, 0x2c},
+	{0x52, 0x29},
+	{0x53, 0x00},
+	{0x55, 0x46},
+	{0x58, 0x29},
+	{0x5a, 0x00},
+	{0x5b, 0x00},
+	{0x5d, 0x00},
+	{0x64, 0x2f},
+	{0x66, 0x62},
+	{0x68, 0x5b},
+	{0x75, 0x46},
+	{0x76, 0x36},
+	{0x77, 0x4f},
+	{0x78, 0xef},
+	{0x72, 0xbf},
+	{0x73, 0x36},
+	{0x7d, 0x0d},
+	{0x7e, 0x0d},
+	{0x8a, 0x77},
+	{0x8b, 0x77},
+	{0xfd, 0x01},
+	{0xb1, 0x82},
+	{0xb3, 0x0b},
+	{0xb4, 0x14},
+	{0x9d, 0x40},
+	{0xa1, 0x05},
+	{0x94, 0x44},
+	{0x95, 0x33},
+	{0x96, 0x1f},
+	{0x98, 0x45},
+	{0x9c, 0x10},
+	{0xb5, 0x30},
+	{0xa0, 0x00},
+	{0x8e, 0x05},
+	{0x8f, 0x08},
+	{0x90, 0x02},
+	{0x91, 0xd8},
+	{0xfd, 0x01},
+	{0x86, 0x77},
+	{0x89, 0x77},
+	{0x87, 0x74},
+	{0x88, 0x74},
+	{0xfc, 0xe0},
+	{0xfe, 0xe0},
+	{0xf0, 0x40},
+	{0xf1, 0x40},
+	{0xf2, 0x40},
+	{0xf3, 0x40},
+	{0xfd, 0x02},
+	{0x36, 0x08},
+	{0xfd, 0x02},
+	{0x36, 0x08},/* invert Vsync polarity for Gaia */
+	{0xa0, 0x00},/* Image vertical start MSB3bits */
+	{0xa1, 0x04},/* Image vertical start LSB8bits */
+	{0xa2, 0x02},/* image vertical size  MSB8bits */
+	{0xa3, 0xd0},/* image vertical size  LSB8bits */
+	{0xa4, 0x00},
+	{0xa5, 0x04},/* H start 8Lsb */
+	{0xa6, 0x02},
+	{0xa7, 0x80},/* Half H size Lsb8bits */
+
+	/* Default Mirror_On_Flip_On */
+	{0xfd, 0x01},
+	{0x3f, 0x03},
+	{0xf8, 0x02},
+
+	{0xfd, 0x01},
+	{0x0e, 0x02},
+	{0x0f, 0xf0},
+	{0x06, 0x19},/* insert dummy line */
+	{0x01, 0x01},
+};
+
+/* Gain table */
+/* OV2735 global gain table row size */
+#define OV2735_GAIN_ROWS  		(256 + 1)
+#define OV2735_GAIN_COLS  		(1)
+#define OV2735_GAIN_MAXDB		(256)
+
+#define OV2735_GAIN_COL_AGAIN	(0)
+static const u8 OV2735_GAIN_TABLE[OV2735_GAIN_ROWS][OV2735_GAIN_COLS] = {
+	{0x10}, /* index:0, gain:0.00000db -> x1.000000, again:x1.000000 */
+	{0x10}, /* index:1, gain:0.09375db -> x1.010852, again:x1.010852 */
+	{0x10}, /* index:2, gain:0.18750db -> x1.021821, again:x1.021821 */
+	{0x10}, /* index:3, gain:0.28125db -> x1.032910, again:x1.032910 */
+	{0x10}, /* index:4, gain:0.37500db -> x1.044119, again:x1.044119 */
+	{0x10}, /* index:5, gain:0.46875db -> x1.055450, again:x1.055450 */
+	{0x11}, /* index:6, gain:0.56250db -> x1.066903, again:x1.066903 */
+	{0x11}, /* index:7, gain:0.65625db -> x1.078481, again:x1.078481 */
+	{0x11}, /* index:8, gain:0.75000db -> x1.090184, again:x1.090184 */
+	{0x11}, /* index:9, gain:0.84375db -> x1.102015, again:x1.102015 */
+	{0x11}, /* index:10, gain:0.93750db -> x1.113974, again:x1.113974 */
+	{0x12}, /* index:11, gain:1.03125db -> x1.126063, again:x1.126063 */
+	{0x12}, /* index:12, gain:1.12500db -> x1.138282, again:x1.138282 */
+	{0x12}, /* index:13, gain:1.21875db -> x1.150635, again:x1.150635 */
+	{0x12}, /* index:14, gain:1.31250db -> x1.163121, again:x1.163121 */
+	{0x12}, /* index:15, gain:1.40625db -> x1.175743, again:x1.175743 */
+	{0x13}, /* index:16, gain:1.50000db -> x1.188502, again:x1.188502 */
+	{0x13}, /* index:17, gain:1.59375db -> x1.201400, again:x1.201400 */
+	{0x13}, /* index:18, gain:1.68750db -> x1.214437, again:x1.214437 */
+	{0x13}, /* index:19, gain:1.78125db -> x1.227616, again:x1.227616 */
+	{0x13}, /* index:20, gain:1.87500db -> x1.240938, again:x1.240938 */
+	{0x14}, /* index:21, gain:1.96875db -> x1.254404, again:x1.254404 */
+	{0x14}, /* index:22, gain:2.06250db -> x1.268017, again:x1.268017 */
+	{0x14}, /* index:23, gain:2.15625db -> x1.281777, again:x1.281777 */
+	{0x14}, /* index:24, gain:2.25000db -> x1.295687, again:x1.295687 */
+	{0x14}, /* index:25, gain:2.34375db -> x1.309747, again:x1.309747 */
+	{0x15}, /* index:26, gain:2.43750db -> x1.323960, again:x1.323960 */
+	{0x15}, /* index:27, gain:2.53125db -> x1.338328, again:x1.338328 */
+	{0x15}, /* index:28, gain:2.62500db -> x1.352851, again:x1.352851 */
+	{0x15}, /* index:29, gain:2.71875db -> x1.367532, again:x1.367532 */
+	{0x16}, /* index:30, gain:2.81250db -> x1.382372, again:x1.382372 */
+	{0x16}, /* index:31, gain:2.90625db -> x1.397374, again:x1.397374 */
+	{0x16}, /* index:32, gain:3.00000db -> x1.412538, again:x1.412538 */
+	{0x16}, /* index:33, gain:3.09375db -> x1.427866, again:x1.427866 */
+	{0x17}, /* index:34, gain:3.18750db -> x1.443361, again:x1.443361 */
+	{0x17}, /* index:35, gain:3.28125db -> x1.459024, again:x1.459024 */
+	{0x17}, /* index:36, gain:3.37500db -> x1.474857, again:x1.474857 */
+	{0x17}, /* index:37, gain:3.46875db -> x1.490862, again:x1.490862 */
+	{0x18}, /* index:38, gain:3.56250db -> x1.507041, again:x1.507041 */
+	{0x18}, /* index:39, gain:3.65625db -> x1.523395, again:x1.523395 */
+	{0x18}, /* index:40, gain:3.75000db -> x1.539927, again:x1.539927 */
+	{0x18}, /* index:41, gain:3.84375db -> x1.556638, again:x1.556638 */
+	{0x19}, /* index:42, gain:3.93750db -> x1.573530, again:x1.573530 */
+	{0x19}, /* index:43, gain:4.03125db -> x1.590606, again:x1.590606 */
+	{0x19}, /* index:44, gain:4.12500db -> x1.607867, again:x1.607867 */
+	{0x1a}, /* index:45, gain:4.21875db -> x1.625315, again:x1.625315 */
+	{0x1a}, /* index:46, gain:4.31250db -> x1.642952, again:x1.642952 */
+	{0x1a}, /* index:47, gain:4.40625db -> x1.660782, again:x1.660782 */
+	{0x1a}, /* index:48, gain:4.50000db -> x1.678804, again:x1.678804 */
+	{0x1b}, /* index:49, gain:4.59375db -> x1.697022, again:x1.697022 */
+	{0x1b}, /* index:50, gain:4.68750db -> x1.715438, again:x1.715438 */
+	{0x1b}, /* index:51, gain:4.78125db -> x1.734054, again:x1.734054 */
+	{0x1c}, /* index:52, gain:4.87500db -> x1.752871, again:x1.752871 */
+	{0x1c}, /* index:53, gain:4.96875db -> x1.771893, again:x1.771893 */
+	{0x1c}, /* index:54, gain:5.06250db -> x1.791121, again:x1.791121 */
+	{0x1c}, /* index:55, gain:5.15625db -> x1.810558, again:x1.810558 */
+	{0x1d}, /* index:56, gain:5.25000db -> x1.830206, again:x1.830206 */
+	{0x1d}, /* index:57, gain:5.34375db -> x1.850067, again:x1.850067 */
+	{0x1d}, /* index:58, gain:5.43750db -> x1.870144, again:x1.870144 */
+	{0x1e}, /* index:59, gain:5.53125db -> x1.890438, again:x1.890438 */
+	{0x1e}, /* index:60, gain:5.62500db -> x1.910953, again:x1.910953 */
+	{0x1e}, /* index:61, gain:5.71875db -> x1.931690, again:x1.931690 */
+	{0x1f}, /* index:62, gain:5.81250db -> x1.952653, again:x1.952653 */
+	{0x1f}, /* index:63, gain:5.90625db -> x1.973842, again:x1.973842 */
+	{0x1f}, /* index:64, gain:6.00000db -> x1.995262, again:x1.995262 */
+	{0x20}, /* index:65, gain:6.09375db -> x2.016915, again:x2.016915 */
+	{0x20}, /* index:66, gain:6.18750db -> x2.038802, again:x2.038802 */
+	{0x20}, /* index:67, gain:6.28125db -> x2.060927, again:x2.060927 */
+	{0x21}, /* index:68, gain:6.37500db -> x2.083291, again:x2.083291 */
+	{0x21}, /* index:69, gain:6.46875db -> x2.105899, again:x2.105899 */
+	{0x22}, /* index:70, gain:6.56250db -> x2.128752, again:x2.128752 */
+	{0x22}, /* index:71, gain:6.65625db -> x2.151852, again:x2.151852 */
+	{0x22}, /* index:72, gain:6.75000db -> x2.175204, again:x2.175204 */
+	{0x23}, /* index:73, gain:6.84375db -> x2.198809, again:x2.198809 */
+	{0x23}, /* index:74, gain:6.93750db -> x2.222670, again:x2.222670 */
+	{0x23}, /* index:75, gain:7.03125db -> x2.246790, again:x2.246790 */
+	{0x24}, /* index:76, gain:7.12500db -> x2.271172, again:x2.271172 */
+	{0x24}, /* index:77, gain:7.21875db -> x2.295818, again:x2.295818 */
+	{0x25}, /* index:78, gain:7.31250db -> x2.320732, again:x2.320732 */
+	{0x25}, /* index:79, gain:7.40625db -> x2.345916, again:x2.345916 */
+	{0x25}, /* index:80, gain:7.50000db -> x2.371374, again:x2.371374 */
+	{0x26}, /* index:81, gain:7.59375db -> x2.397107, again:x2.397107 */
+	{0x26}, /* index:82, gain:7.68750db -> x2.423120, again:x2.423120 */
+	{0x27}, /* index:83, gain:7.78125db -> x2.449416, again:x2.449416 */
+	{0x27}, /* index:84, gain:7.87500db -> x2.475996, again:x2.475996 */
+	{0x28}, /* index:85, gain:7.96875db -> x2.502865, again:x2.502865 */
+	{0x28}, /* index:86, gain:8.06250db -> x2.530026, again:x2.530026 */
+	{0x28}, /* index:87, gain:8.15625db -> x2.557482, again:x2.557482 */
+	{0x29}, /* index:88, gain:8.25000db -> x2.585235, again:x2.585235 */
+	{0x29}, /* index:89, gain:8.34375db -> x2.613289, again:x2.613289 */
+	{0x2a}, /* index:90, gain:8.43750db -> x2.641648, again:x2.641648 */
+	{0x2a}, /* index:91, gain:8.53125db -> x2.670315, again:x2.670315 */
+	{0x2b}, /* index:92, gain:8.62500db -> x2.699293, again:x2.699293 */
+	{0x2b}, /* index:93, gain:8.71875db -> x2.728585, again:x2.728585 */
+	{0x2c}, /* index:94, gain:8.81250db -> x2.758195, again:x2.758195 */
+	{0x2c}, /* index:95, gain:8.90625db -> x2.788127, again:x2.788127 */
+	{0x2d}, /* index:96, gain:9.00000db -> x2.818383, again:x2.818383 */
+	{0x2d}, /* index:97, gain:9.09375db -> x2.848968, again:x2.848968 */
+	{0x2e}, /* index:98, gain:9.18750db -> x2.879884, again:x2.879884 */
+	{0x2e}, /* index:99, gain:9.28125db -> x2.911136, again:x2.911136 */
+	{0x2f}, /* index:100, gain:9.37500db -> x2.942727, again:x2.942727 */
+	{0x2f}, /* index:101, gain:9.46875db -> x2.974661, again:x2.974661 */
+	{0x30}, /* index:102, gain:9.56250db -> x3.006942, again:x3.006942 */
+	{0x30}, /* index:103, gain:9.65625db -> x3.039572, again:x3.039572 */
+	{0x31}, /* index:104, gain:9.75000db -> x3.072557, again:x3.072557 */
+	{0x31}, /* index:105, gain:9.84375db -> x3.105900, again:x3.105900 */
+	{0x32}, /* index:106, gain:9.93750db -> x3.139605, again:x3.139605 */
+	{0x32}, /* index:107, gain:10.03125db -> x3.173675, again:x3.173675 */
+	{0x33}, /* index:108, gain:10.12500db -> x3.208116, again:x3.208116 */
+	{0x33}, /* index:109, gain:10.21875db -> x3.242930, again:x3.242930 */
+	{0x34}, /* index:110, gain:10.31250db -> x3.278121, again:x3.278121 */
+	{0x35}, /* index:111, gain:10.40625db -> x3.313695, again:x3.313695 */
+	{0x35}, /* index:112, gain:10.50000db -> x3.349654, again:x3.349654 */
+	{0x36}, /* index:113, gain:10.59375db -> x3.386004, again:x3.386004 */
+	{0x36}, /* index:114, gain:10.68750db -> x3.422749, again:x3.422749 */
+	{0x37}, /* index:115, gain:10.78125db -> x3.459892, again:x3.459892 */
+	{0x37}, /* index:116, gain:10.87500db -> x3.497438, again:x3.497438 */
+	{0x38}, /* index:117, gain:10.96875db -> x3.535391, again:x3.535391 */
+	{0x39}, /* index:118, gain:11.06250db -> x3.573757, again:x3.573757 */
+	{0x39}, /* index:119, gain:11.15625db -> x3.612539, again:x3.612539 */
+	{0x3a}, /* index:120, gain:11.25000db -> x3.651741, again:x3.651741 */
+	{0x3b}, /* index:121, gain:11.34375db -> x3.691369, again:x3.691369 */
+	{0x3b}, /* index:122, gain:11.43750db -> x3.731427, again:x3.731427 */
+	{0x3c}, /* index:123, gain:11.53125db -> x3.771920, again:x3.771920 */
+	{0x3d}, /* index:124, gain:11.62500db -> x3.812853, again:x3.812853 */
+	{0x3d}, /* index:125, gain:11.71875db -> x3.854229, again:x3.854229 */
+	{0x3e}, /* index:126, gain:11.81250db -> x3.896054, again:x3.896054 */
+	{0x3f}, /* index:127, gain:11.90625db -> x3.938333, again:x3.938333 */
+	{0x3f}, /* index:128, gain:12.00000db -> x3.981072, again:x3.981072 */
+	{0x40}, /* index:129, gain:12.09375db -> x4.024274, again:x4.024274 */
+	{0x41}, /* index:130, gain:12.18750db -> x4.067944, again:x4.067944 */
+	{0x41}, /* index:131, gain:12.28125db -> x4.112089, again:x4.112089 */
+	{0x42}, /* index:132, gain:12.37500db -> x4.156712, again:x4.156712 */
+	{0x43}, /* index:133, gain:12.46875db -> x4.201821, again:x4.201821 */
+	{0x43}, /* index:134, gain:12.56250db -> x4.247418, again:x4.247418 */
+	{0x44}, /* index:135, gain:12.65625db -> x4.293510, again:x4.293510 */
+	{0x45}, /* index:136, gain:12.75000db -> x4.340103, again:x4.340103 */
+	{0x46}, /* index:137, gain:12.84375db -> x4.387200, again:x4.387200 */
+	{0x46}, /* index:138, gain:12.93750db -> x4.434810, again:x4.434810 */
+	{0x47}, /* index:139, gain:13.03125db -> x4.482936, again:x4.482936 */
+	{0x48}, /* index:140, gain:13.12500db -> x4.531584, again:x4.531584 */
+	{0x49}, /* index:141, gain:13.21875db -> x4.580759, again:x4.580759 */
+	{0x4a}, /* index:142, gain:13.31250db -> x4.630469, again:x4.630469 */
+	{0x4a}, /* index:143, gain:13.40625db -> x4.680719, again:x4.680719 */
+	{0x4b}, /* index:144, gain:13.50000db -> x4.731513, again:x4.731513 */
+	{0x4c}, /* index:145, gain:13.59375db -> x4.782858, again:x4.782858 */
+	{0x4d}, /* index:146, gain:13.68750db -> x4.834761, again:x4.834761 */
+	{0x4e}, /* index:147, gain:13.78125db -> x4.887227, again:x4.887227 */
+	{0x4f}, /* index:148, gain:13.87500db -> x4.940262, again:x4.940262 */
+	{0x4f}, /* index:149, gain:13.96875db -> x4.993873, again:x4.993873 */
+	{0x50}, /* index:150, gain:14.06250db -> x5.048066, again:x5.048066 */
+	{0x51}, /* index:151, gain:14.15625db -> x5.102846, again:x5.102846 */
+	{0x52}, /* index:152, gain:14.25000db -> x5.158221, again:x5.158221 */
+	{0x53}, /* index:153, gain:14.34375db -> x5.214198, again:x5.214198 */
+	{0x54}, /* index:154, gain:14.43750db -> x5.270781, again:x5.270781 */
+	{0x55}, /* index:155, gain:14.53125db -> x5.327979, again:x5.327979 */
+	{0x56}, /* index:156, gain:14.62500db -> x5.385797, again:x5.385797 */
+	{0x57}, /* index:157, gain:14.71875db -> x5.444243, again:x5.444243 */
+	{0x58}, /* index:158, gain:14.81250db -> x5.503323, again:x5.503323 */
+	{0x59}, /* index:159, gain:14.90625db -> x5.563044, again:x5.563044 */
+	{0x59}, /* index:160, gain:15.00000db -> x5.623413, again:x5.623413 */
+	{0x5a}, /* index:161, gain:15.09375db -> x5.684437, again:x5.684437 */
+	{0x5b}, /* index:162, gain:15.18750db -> x5.746124, again:x5.746124 */
+	{0x5c}, /* index:163, gain:15.28125db -> x5.808480, again:x5.808480 */
+	{0x5d}, /* index:164, gain:15.37500db -> x5.871513, again:x5.871513 */
+	{0x5e}, /* index:165, gain:15.46875db -> x5.935229, again:x5.935229 */
+	{0x5f}, /* index:166, gain:15.56250db -> x5.999637, again:x5.999637 */
+	{0x61}, /* index:167, gain:15.65625db -> x6.064744, again:x6.064744 */
+	{0x62}, /* index:168, gain:15.75000db -> x6.130558, again:x6.130558 */
+	{0x63}, /* index:169, gain:15.84375db -> x6.197086, again:x6.197086 */
+	{0x64}, /* index:170, gain:15.93750db -> x6.264335, again:x6.264335 */
+	{0x65}, /* index:171, gain:16.03125db -> x6.332315, again:x6.332315 */
+	{0x66}, /* index:172, gain:16.12500db -> x6.401032, again:x6.401032 */
+	{0x67}, /* index:173, gain:16.21875db -> x6.470495, again:x6.470495 */
+	{0x68}, /* index:174, gain:16.31250db -> x6.540712, again:x6.540712 */
+	{0x69}, /* index:175, gain:16.40625db -> x6.611690, again:x6.611690 */
+	{0x6a}, /* index:176, gain:16.50000db -> x6.683439, again:x6.683439 */
+	{0x6c}, /* index:177, gain:16.59375db -> x6.755966, again:x6.755966 */
+	{0x6d}, /* index:178, gain:16.68750db -> x6.829282, again:x6.829282 */
+	{0x6e}, /* index:179, gain:16.78125db -> x6.903392, again:x6.903392 */
+	{0x6f}, /* index:180, gain:16.87500db -> x6.978306, again:x6.978306 */
+	{0x70}, /* index:181, gain:16.96875db -> x7.054033, again:x7.054033 */
+	{0x72}, /* index:182, gain:17.06250db -> x7.130582, again:x7.130582 */
+	{0x73}, /* index:183, gain:17.15625db -> x7.207963, again:x7.207963 */
+	{0x74}, /* index:184, gain:17.25000db -> x7.286182, again:x7.286182 */
+	{0x75}, /* index:185, gain:17.34375db -> x7.365250, again:x7.365250 */
+	{0x77}, /* index:186, gain:17.43750db -> x7.445176, again:x7.445176 */
+	{0x78}, /* index:187, gain:17.53125db -> x7.525970, again:x7.525970 */
+	{0x79}, /* index:188, gain:17.62500db -> x7.607641, again:x7.607641 */
+	{0x7b}, /* index:189, gain:17.71875db -> x7.690198, again:x7.690198 */
+	{0x7c}, /* index:190, gain:17.81250db -> x7.773650, again:x7.773650 */
+	{0x7d}, /* index:191, gain:17.90625db -> x7.858008, again:x7.858008 */
+	{0x7f}, /* index:192, gain:18.00000db -> x7.943282, again:x7.943282 */
+	{0x80}, /* index:193, gain:18.09375db -> x8.029482, again:x8.029482 */
+	{0x81}, /* index:194, gain:18.18750db -> x8.116616, again:x8.116616 */
+	{0x83}, /* index:195, gain:18.28125db -> x8.204696, again:x8.204696 */
+	{0x84}, /* index:196, gain:18.37500db -> x8.293732, again:x8.293732 */
+	{0x86}, /* index:197, gain:18.46875db -> x8.383734, again:x8.383734 */
+	{0x87}, /* index:198, gain:18.56250db -> x8.474713, again:x8.474713 */
+	{0x89}, /* index:199, gain:18.65625db -> x8.566679, again:x8.566679 */
+	{0x8a}, /* index:200, gain:18.75000db -> x8.659643, again:x8.659643 */
+	{0x8c}, /* index:201, gain:18.84375db -> x8.753616, again:x8.753616 */
+	{0x8d}, /* index:202, gain:18.93750db -> x8.848608, again:x8.848608 */
+	{0x8f}, /* index:203, gain:19.03125db -> x8.944633, again:x8.944633 */
+	{0x90}, /* index:204, gain:19.12500db -> x9.041698, again:x9.041698 */
+	{0x92}, /* index:205, gain:19.21875db -> x9.139817, again:x9.139817 */
+	{0x93}, /* index:206, gain:19.31250db -> x9.239000, again:x9.239000 */
+	{0x95}, /* index:207, gain:19.40625db -> x9.339260, again:x9.339260 */
+	{0x97}, /* index:208, gain:19.50000db -> x9.440609, again:x9.440609 */
+	{0x98}, /* index:209, gain:19.59375db -> x9.543057, again:x9.543057 */
+	{0x9a}, /* index:210, gain:19.68750db -> x9.646616, again:x9.646616 */
+	{0x9c}, /* index:211, gain:19.78125db -> x9.751299, again:x9.751299 */
+	{0x9d}, /* index:212, gain:19.87500db -> x9.857118, again:x9.857118 */
+	{0x9f}, /* index:213, gain:19.96875db -> x9.964087, again:x9.964087 */
+	{0xa1}, /* index:214, gain:20.06250db -> x10.072214, again:x10.072214 */
+	{0xa2}, /* index:215, gain:20.15625db -> x10.181517, again:x10.181517 */
+	{0xa4}, /* index:216, gain:20.25000db -> x10.292006, again:x10.292006 */
+	{0xa6}, /* index:217, gain:20.34375db -> x10.403692, again:x10.403692 */
+	{0xa8}, /* index:218, gain:20.43750db -> x10.516592, again:x10.516592 */
+	{0xaa}, /* index:219, gain:20.53125db -> x10.630714, again:x10.630714 */
+	{0xab}, /* index:220, gain:20.62500db -> x10.746078, again:x10.746078 */
+	{0xad}, /* index:221, gain:20.71875db -> x10.862694, again:x10.862694 */
+	{0xaf}, /* index:222, gain:20.81250db -> x10.980572, again:x10.980572 */
+	{0xb1}, /* index:223, gain:20.90625db -> x11.099733, again:x11.099733 */
+	{0xb3}, /* index:224, gain:21.00000db -> x11.220183, again:x11.220183 */
+	{0xb5}, /* index:225, gain:21.09375db -> x11.341944, again:x11.341944 */
+	{0xb7}, /* index:226, gain:21.18750db -> x11.465026, again:x11.465026 */
+	{0xb9}, /* index:227, gain:21.28125db -> x11.589441, again:x11.589441 */
+	{0xbb}, /* index:228, gain:21.37500db -> x11.715209, again:x11.715209 */
+	{0xbd}, /* index:229, gain:21.46875db -> x11.842338, again:x11.842338 */
+	{0xbf}, /* index:230, gain:21.56250db -> x11.970850, again:x11.970850 */
+	{0xc1}, /* index:231, gain:21.65625db -> x12.100757, again:x12.100757 */
+	{0xc3}, /* index:232, gain:21.75000db -> x12.232071, again:x12.232071 */
+	{0xc5}, /* index:233, gain:21.84375db -> x12.364812, again:x12.364812 */
+	{0xc7}, /* index:234, gain:21.93750db -> x12.498991, again:x12.498991 */
+	{0xca}, /* index:235, gain:22.03125db -> x12.634629, again:x12.634629 */
+	{0xcc}, /* index:236, gain:22.12500db -> x12.771739, again:x12.771739 */
+	{0xce}, /* index:237, gain:22.21875db -> x12.910334, again:x12.910334 */
+	{0xd0}, /* index:238, gain:22.31250db -> x13.050436, again:x13.050436 */
+	{0xd3}, /* index:239, gain:22.40625db -> x13.192055, again:x13.192055 */
+	{0xd5}, /* index:240, gain:22.50000db -> x13.335214, again:x13.335214 */
+	{0xd7}, /* index:241, gain:22.59375db -> x13.479927, again:x13.479927 */
+	{0xda}, /* index:242, gain:22.68750db -> x13.626207, again:x13.626207 */
+	{0xdc}, /* index:243, gain:22.78125db -> x13.774078, again:x13.774078 */
+	{0xde}, /* index:244, gain:22.87500db -> x13.923549, again:x13.923549 */
+	{0xe1}, /* index:245, gain:22.96875db -> x14.074647, again:x14.074647 */
+	{0xe3}, /* index:246, gain:23.06250db -> x14.227384, again:x14.227384 */
+	{0xe6}, /* index:247, gain:23.15625db -> x14.381775, again:x14.381775 */
+	{0xe8}, /* index:248, gain:23.25000db -> x14.537845, again:x14.537845 */
+	{0xeb}, /* index:249, gain:23.34375db -> x14.695604, again:x14.695604 */
+	{0xed}, /* index:250, gain:23.43750db -> x14.855080, again:x14.855080 */
+	{0xf0}, /* index:251, gain:23.53125db -> x15.016287, again:x15.016287 */
+	{0xf2}, /* index:252, gain:23.62500db -> x15.179238, again:x15.179238 */
+	{0xf5}, /* index:253, gain:23.71875db -> x15.343962, again:x15.343962 */
+	{0xf8}, /* index:254, gain:23.81250db -> x15.510470, again:x15.510470 */
+	{0xfa}, /* index:255, gain:23.90625db -> x15.678788, again:x15.678788 */
+	{0xfd}, /* index:256, gain:24.00000db -> x15.848934, again:x15.848934 */
+};
+
diff --git a/drivers/vin/sensors/omnivision_ov4689_mipi/Kbuild b/drivers/vin/sensors/omnivision_ov4689_mipi/Kbuild
index 2ca1604..201c62e 100644
--- a/drivers/vin/sensors/omnivision_ov4689_mipi/Kbuild
+++ b/drivers/vin/sensors/omnivision_ov4689_mipi/Kbuild
@@ -4,15 +4,30 @@
 ## History:
 ##    2011/01/12 - [Haowei Lo] Create
 ##
-## Copyright (C) 2004-2011, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
-## This file is produced by perl.
-##/
 
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/omnivision_ov4689_mipi/make.inc b/drivers/vin/sensors/omnivision_ov4689_mipi/make.inc
index 17f692a..d70775a 100644
--- a/drivers/vin/sensors/omnivision_ov4689_mipi/make.inc
+++ b/drivers/vin/sensors/omnivision_ov4689_mipi/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/04 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_OV4689_MIPI), y)
diff --git a/drivers/vin/sensors/omnivision_ov4689_mipi/ov4689.c b/drivers/vin/sensors/omnivision_ov4689_mipi/ov4689.c
index 8a28924..d466a5c 100644
--- a/drivers/vin/sensors/omnivision_ov4689_mipi/ov4689.c
+++ b/drivers/vin/sensors/omnivision_ov4689_mipi/ov4689.c
@@ -4,15 +4,32 @@
  * History:
  *    2012/03/23 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2013, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
@@ -22,15 +39,26 @@
 #include <iav_utils.h>
 #include <vin_api.h>
 #include "ov4689.h"
+#include "ov4689_table.c"
+
+#define AMBARELLA_I2C_VIN_FDT_NAME		"ambvin"
 
-static int bus_addr = (0 << 16) | (0x6C >> 1);
-module_param(bus_addr, int, 0644);
-MODULE_PARM_DESC(bus_addr, " bus and addr: bit16~bit31: bus, bit0~bit15: addr");
+static int bus_id = 0;
+module_param(bus_id, int, 0644);
+MODULE_PARM_DESC(bus_id, "device bus id");
+
+static int addr = 0x6C >> 1;
+module_param(addr, int, 0644);
+MODULE_PARM_DESC(addr, "device address");
 
 static int lane = 4;
 module_param(lane, int, 0644);
 MODULE_PARM_DESC(lane, "Set MIPI lane number 2:2 lane 4:4 lane");
 
+static int vinc_id = 0x3210;
+module_param(vinc_id, int, 0644);
+MODULE_PARM_DESC(vinc_id, "indicate which vin controller is bind to");
+
 struct ov4689_priv {
 	void *control_data;
 	struct vindev_wdr_gp_s wdr_again_gp;
@@ -38,12 +66,12 @@ struct ov4689_priv {
 	struct vindev_wdr_gp_s wdr_shutter_gp;
 	u32 line_length;
 	u32 frame_length_lines;
+	u32 ori_line_length;
 	u32 max_middle, max_short;
+	u8 ll_mode;
 };
 
-#include "ov4689_table.c"
-
-static int ov4689_write_reg( struct vin_device *vdev, u32 subaddr, u32 data)
+static int ov4689_write_reg(struct vin_device *vdev, u32 subaddr, u32 data)
 {
 	int rval;
 	struct ov4689_priv *ov4689;
@@ -76,7 +104,37 @@ static int ov4689_write_reg( struct vin_device *vdev, u32 subaddr, u32 data)
 	return 0;
 }
 
-static int ov4689_read_reg( struct vin_device *vdev, u32 subaddr, u32 *data)
+static int ov4689_write_reg2(struct vin_device *vdev, u32 subaddr, u32 data)
+{
+	int rval;
+	struct ov4689_priv *ov4689;
+	struct i2c_client *client;
+	struct i2c_msg msgs[1];
+	u8 pbuf[4];
+
+	ov4689 = (struct ov4689_priv *)vdev->priv;
+	client = ov4689->control_data;
+
+	pbuf[0] = (subaddr >> 8);
+	pbuf[1] = (subaddr & 0xff);
+	pbuf[2] = data >> 8;
+	pbuf[3] = data & 0xff;
+
+	msgs[0].len = 4;
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].buf = pbuf;
+
+	rval = i2c_transfer(client->adapter, msgs, 1);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x:0x%x]\n", rval, subaddr, data);
+		return rval;
+	}
+
+	return 0;
+}
+
+static int ov4689_read_reg(struct vin_device *vdev, u32 subaddr, u32 *data)
 {
 	int rval = 0;
 	struct ov4689_priv *ov4689;
@@ -102,7 +160,7 @@ static int ov4689_read_reg( struct vin_device *vdev, u32 subaddr, u32 *data)
 	msgs[1].len = 1;
 
 	rval = i2c_transfer(client->adapter, msgs, 2);
-	if (rval < 0){
+	if (rval < 0) {
 		vin_error("failed(%d): [0x%x]\n", rval, subaddr);
 		return rval;
 	}
@@ -116,12 +174,13 @@ static int ov4689_set_vin_mode(struct vin_device *vdev, struct vin_video_format
 {
 	struct vin_device_config ov4689_config;
 
-	memset(&ov4689_config, 0, sizeof (ov4689_config));
+	memset(&ov4689_config, 0, sizeof(ov4689_config));
 
 	ov4689_config.interface_type = SENSOR_MIPI;
 	ov4689_config.sync_mode = SENSOR_SYNC_MODE_MASTER;
 
 	ov4689_config.mipi_cfg.lane_number = (lane == 4) ? SENSOR_4_LANE : SENSOR_2_LANE;
+	ov4689_config.mipi_cfg.bit_rate = SENSOR_MIPI_BIT_RATE_H;
 
 	ov4689_config.cap_win.x = format->def_start_x;
 	ov4689_config.cap_win.y = format->def_start_y;
@@ -133,8 +192,6 @@ static int ov4689_set_vin_mode(struct vin_device *vdev, struct vin_video_format
 	ov4689_config.hdr_cfg.act_win.y = format->act_start_y;
 	ov4689_config.hdr_cfg.act_win.width = format->act_width;
 	ov4689_config.hdr_cfg.act_win.height = format->act_height;
-	ov4689_config.hdr_cfg.act_win.max_width = format->max_act_width;
-	ov4689_config.hdr_cfg.act_win.max_height = format->max_act_height;
 
 	ov4689_config.sensor_id	= GENERIC_SENSOR;
 	ov4689_config.input_format	= AMBA_VIN_INPUT_FORMAT_RGB_RAW;
@@ -159,7 +216,7 @@ static int ov4689_init_device(struct vin_device *vdev)
 
 static void ov4689_start_streaming(struct vin_device *vdev)
 {
-	ov4689_write_reg(vdev, OV4689_STANDBY, 0x01); //streaming
+	ov4689_write_reg(vdev, OV4689_STANDBY, 0x01); /* streaming */
 }
 
 static int ov4689_get_line_time(struct vin_device *vdev)
@@ -183,7 +240,8 @@ static int ov4689_update_hv_info(struct vin_device *vdev)
 	ov4689_read_reg(vdev, OV4689_HTS_MSB, &data_h);
 	ov4689_read_reg(vdev, OV4689_HTS_LSB, &data_l);
 	pinfo->line_length = (data_h<<8) + data_l;
-	if(unlikely(!pinfo->line_length)) {
+	pinfo->ori_line_length = pinfo->line_length;
+	if (unlikely(!pinfo->line_length)) {
 		vin_error("line length is 0!\n");
 		return -EIO;
 	}
@@ -192,25 +250,26 @@ static int ov4689_update_hv_info(struct vin_device *vdev)
 	ov4689_read_reg(vdev, OV4689_VTS_LSB, &data_l);
 	pinfo->frame_length_lines = (data_h<<8) + data_l;
 
-	if(vdev->cur_format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {
+	if (vdev->cur_format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {
 		ov4689_read_reg(vdev, OV4689_M_MAX_EXPO_MSB, &data_h);
 		ov4689_read_reg(vdev, OV4689_M_MAX_EXPO_LSB, &data_l);
 		pinfo->max_middle = ((data_h)<<8) + data_l;
-		if(unlikely(!pinfo->max_middle)) {
+		if (unlikely(!pinfo->max_middle)) {
 			vin_warn("max_middle is 0!\n");
 		}
-	} else if(vdev->cur_format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE) {
+		pinfo->max_short = 0;
+	} else if (vdev->cur_format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE) {
 		ov4689_read_reg(vdev, OV4689_M_MAX_EXPO_MSB, &data_h);
 		ov4689_read_reg(vdev, OV4689_M_MAX_EXPO_LSB, &data_l);
 		pinfo->max_middle = ((data_h)<<8) + data_l;
-		if(unlikely(!pinfo->max_middle)) {
+		if (unlikely(!pinfo->max_middle)) {
 			vin_warn("max_middle is 0!\n");
 		}
 
 		ov4689_read_reg(vdev, OV4689_S_MAX_EXPO_MSB, &data_h);
 		ov4689_read_reg(vdev, OV4689_S_MAX_EXPO_LSB, &data_l);
 		pinfo->max_short = ((data_h)<<8) + data_l;
-		if(unlikely(!pinfo->max_short)) {
+		if (unlikely(!pinfo->max_short)) {
 			vin_warn("max_short is 0!\n");
 		}
 	}
@@ -226,6 +285,7 @@ static int ov4689_set_format(struct vin_device *vdev, struct vin_video_format *f
 	int rval;
 	struct vin_reg_16_8 *regs;
 	int i, regs_num;
+	struct ov4689_priv *pinfo = (struct ov4689_priv *)vdev->priv;
 
 	switch (format->hdr_mode) {
 	case AMBA_VIDEO_LINEAR_MODE:
@@ -234,25 +294,25 @@ static int ov4689_set_format(struct vin_device *vdev, struct vin_video_format *f
 			regs_num = ARRAY_SIZE(ov4689_4lane_4m_regs);
 			vin_info("4 lane 4M\n");
 		} else if (lane == 2) {
-			switch(format->device_mode) {
-				case 0:
-					regs = ov4689_2lane_4m_regs;
-					regs_num = ARRAY_SIZE(ov4689_2lane_4m_regs);
-					vin_info("2 lane 4M\n");
-					break;
-				case 1:
-					regs = ov4689_2lane_1080p_regs;
-					regs_num = ARRAY_SIZE(ov4689_2lane_1080p_regs);
-					vin_info("2 lane 1080p\n");
-					break;
-				case 2:
-					regs = ov4689_2lane_720p_regs;
-					regs_num = ARRAY_SIZE(ov4689_2lane_720p_regs);
-					vin_info("2 lane 720p\n");
-					break;
-				default:
-					vin_error("2 lane mipi doesn't support mode:%d\n", format->video_mode);
-					return -EINVAL;
+			switch (format->device_mode) {
+			case 0:
+				regs = ov4689_2lane_4m_regs;
+				regs_num = ARRAY_SIZE(ov4689_2lane_4m_regs);
+				vin_info("2 lane 4M\n");
+				break;
+			case 1:
+				regs = ov4689_2lane_1080p_regs;
+				regs_num = ARRAY_SIZE(ov4689_2lane_1080p_regs);
+				vin_info("2 lane 1080p\n");
+				break;
+			case 2:
+				regs = ov4689_2lane_720p_regs;
+				regs_num = ARRAY_SIZE(ov4689_2lane_720p_regs);
+				vin_info("2 lane 720p\n");
+				break;
+			default:
+				vin_error("2 lane mipi doesn't support mode:%d\n", format->video_mode);
+				return -EINVAL;
 			}
 		} else {
 			vin_error("OV4689 can only support 2 or 4 lanes mipi\n");
@@ -295,12 +355,32 @@ static int ov4689_set_format(struct vin_device *vdev, struct vin_video_format *f
 	if (rval < 0)
 		return rval;
 
+	switch (format->hdr_mode) {
+	case AMBA_VIDEO_LINEAR_MODE:
+		vdev->cur_format->hdr_short1_offset = 0;
+		vdev->cur_format->hdr_short2_offset = 0;
+		break;
+	case AMBA_VIDEO_2X_HDR_MODE:
+		vdev->cur_format->hdr_short1_offset = pinfo->max_middle * 2 + 1;
+		vdev->cur_format->hdr_short2_offset = 0;
+		break;
+	case AMBA_VIDEO_3X_HDR_MODE:
+		vdev->cur_format->hdr_short1_offset = pinfo->max_middle * 3 + 1;
+		vdev->cur_format->hdr_short2_offset = (pinfo->max_middle + pinfo->max_short) * 3 + 2;
+		break;
+	default:
+		regs = NULL;
+		vin_error("Unknown mode\n");
+		return -EINVAL;
+	}
+	pinfo->ll_mode = 0;
+
 	ov4689_get_line_time(vdev);
 
 	/* Enable Streaming */
 	ov4689_start_streaming(vdev);
 
-	/* communiate with IAV */
+	/* communicate with IAV */
 	rval = ov4689_set_vin_mode(vdev, format);
 	if (rval < 0)
 		return rval;
@@ -329,7 +409,7 @@ static int ov4689_set_shutter_row(struct vin_device *vdev, u32 row)
 
 	num_line = row;
 
-	/* FIXME: shutter width: 4 ~(Frame format(V) - 4) */
+	/* FIXME: shutter width: 4 ~ (Frame format(V) - 4) */
 	min_line = 4;
 	max_line = pinfo->frame_length_lines - 4;
 	num_line = clamp(num_line, min_line, max_line);
@@ -351,14 +431,14 @@ static int ov4689_set_shutter_row(struct vin_device *vdev, u32 row)
 	return errCode;
 }
 
-static int ov4689_shutter2row(struct vin_device *vdev, u32* shutter_time)
+static int ov4689_shutter2row(struct vin_device *vdev, u32 *shutter_time)
 {
 	struct ov4689_priv *pinfo = (struct ov4689_priv *)vdev->priv;
 	u64 exposure_lines;
 	int rval = 0;
 
 	/* for fast boot, it may call set shutter time directly, so we must read line length/frame line */
-	if(!pinfo->line_length) {
+	if (!pinfo->line_length) {
 		rval = ov4689_update_hv_info(vdev);
 		if (rval < 0)
 			return rval;
@@ -383,8 +463,13 @@ static int ov4689_set_wdr_shutter_row_group(struct vin_device *vdev,
 	u32 frame_length_lines;
 
 	frame_length_lines = pinfo->frame_length_lines;
-	max_middle = pinfo->max_middle;
-	max_short = pinfo->max_short;
+	if (!pinfo->ll_mode) {
+		max_middle = pinfo->max_middle;
+		max_short = pinfo->max_short;
+	} else {
+		max_middle = OV4689_LL_MODE_M_MAX;
+		max_short = OV4689_LL_MODE_S_MAX;
+	}
 
 	/* long shutter */
 	shutter_long = p_shutter_gp->l;
@@ -396,27 +481,24 @@ static int ov4689_set_wdr_shutter_row_group(struct vin_device *vdev,
 	shutter_short2 = p_shutter_gp->s2;
 
 	/* shutter limitation check */
-	if(shutter_short1 > max_middle - 1) {
-		vin_warn("middle shutter %d exceeds limitation %d\n", shutter_short1, max_middle - 1);
+	if (shutter_short1 > max_middle - 1) {
+		vin_error("middle shutter %d exceeds limitation %d\n", shutter_short1, max_middle - 1);
+		return -EPERM;
 	}
 
-	if(vdev->cur_format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE) {
-		if(shutter_short2 > max_short - 1) {
-			vin_warn("short shutter %d exceeds limitation %d\n", shutter_short2 , max_short - 1);
-		}
-		if(shutter_long + shutter_short1 + shutter_short2 >= frame_length_lines - 4){
-			vin_error("shutter exceeds limitation! long:%d, short1:%d, short2:%d, V:%d\n",
-				shutter_long, shutter_short1, shutter_short2, frame_length_lines);
-			return -1;
-		}
-	} else {
-		if(shutter_long + shutter_short1 >= frame_length_lines - 4){
-			vin_error("shutter exceeds limitation! long:%d, short1:%d, V:%d\n",
-				shutter_long, shutter_short1, frame_length_lines);
-			return -1;
+	if (vdev->cur_format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE) {
+		if (shutter_short2 > max_short - 1) {
+			vin_error("short shutter %d exceeds limitation %d\n", shutter_short2 , max_short - 1);
+			return -EPERM;
 		}
 	}
 
+	if (shutter_long + max_middle + max_short > frame_length_lines - 2) {
+		vin_error("shutter exceeds limitation! long:%d, max short1:%d, max short2:%d, V:%d\n",
+			shutter_long, max_middle, max_short, frame_length_lines);
+		return -EPERM;
+	}
+
 	/* long shutter */
 	shutter_long  = shutter_long << 4;
 	ov4689_write_reg(vdev, OV4689_L_EXPO_HSB, (u8)((shutter_long >> 16) & 0xF));
@@ -429,7 +511,7 @@ static int ov4689_set_wdr_shutter_row_group(struct vin_device *vdev,
 	ov4689_write_reg(vdev, OV4689_M_EXPO_MSB, (u8)(shutter_short1 >> 8));
 	ov4689_write_reg(vdev, OV4689_M_EXPO_LSB, (u8)(shutter_short1 & 0xFF));
 
-	if(vdev->cur_format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE) {
+	if (vdev->cur_format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE) {
 		/* short shutter 2 */
 		shutter_short2  = shutter_short2 << 4;
 		ov4689_write_reg(vdev, OV4689_S_EXPO_HSB, (u8)((shutter_short2 >> 16) & 0xF));
@@ -458,20 +540,33 @@ static int ov4689_set_fps(struct vin_device *vdev, int fps)
 {
 	struct ov4689_priv *pinfo = (struct ov4689_priv *)vdev->priv;
 	u64 pixelclk, v_lines, vb_time;
+	u32 factor;
 
 	pixelclk = vdev->cur_pll->pixelclk;
 
 	v_lines = fps * pixelclk;
-	v_lines = DIV64_CLOSEST(v_lines, pinfo->line_length);
+	v_lines = DIV64_CLOSEST(v_lines, pinfo->ori_line_length);
 	v_lines = DIV64_CLOSEST(v_lines, 512000000);
-	ov4689_write_reg(vdev, OV4689_VTS_MSB, (u8)((v_lines & 0xFF00) >> 8));
-	ov4689_write_reg(vdev, OV4689_VTS_LSB, (u8)(v_lines & 0xFF));
+
+	/* workaround for 1fps case */
+	if (v_lines > 0xFFFF) {
+		vin_debug("h_clks:%d, v_lines:%lld\n", pinfo->ori_line_length, v_lines);
+
+		factor = ((u32)v_lines) / 0xFFFF + 1;
+		v_lines = DIV64_CLOSEST(v_lines, factor);
+		pinfo->line_length = pinfo->ori_line_length * factor;
+		ov4689_write_reg2(vdev, OV4689_HTS_MSB, pinfo->line_length);
+	} else if (pinfo->line_length != pinfo->ori_line_length) {
+		pinfo->line_length = pinfo->ori_line_length;
+		ov4689_write_reg2(vdev, OV4689_HTS_MSB, pinfo->line_length);
+	}
+	ov4689_write_reg2(vdev, OV4689_VTS_MSB, v_lines & 0xFFFF);
 
 	pinfo->frame_length_lines = v_lines;
 
 	if (vdev->cur_format->hdr_mode == AMBA_VIDEO_LINEAR_MODE) {
 		v_lines = pinfo->frame_length_lines - vdev->cur_format->height;
-	} else if(vdev->cur_format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {
+	} else if (vdev->cur_format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {
 		v_lines = pinfo->frame_length_lines * 2 - vdev->cur_format->height;
 	} else if (vdev->cur_format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE) {
 		v_lines = pinfo->frame_length_lines * 3 - vdev->cur_format->height;
@@ -617,7 +712,7 @@ static int ov4689_wdr_shutter2row(struct vin_device *vdev,
 	int rval = 0;
 
 	/* for fast boot, it may call set shutter time directly, so we must read line length/frame line */
-	if(!pinfo->line_length) {
+	if (!pinfo->line_length) {
 		rval = ov4689_update_hv_info(vdev);
 		if (rval < 0)
 			return rval;
@@ -650,7 +745,7 @@ static int ov4689_set_mirror_mode(struct vin_device *vdev,
 		struct vindev_mirror *mirror_mode)
 {
 	int errCode = 0;
-	u32 tmp_reg, bayer_pattern, vflip = 0,hflip = 0;
+	u32 tmp_reg, bayer_pattern, vflip = 0, hflip = 0;
 
 	switch (mirror_mode->pattern) {
 	case VINDEV_MIRROR_AUTO:
@@ -680,14 +775,14 @@ static int ov4689_set_mirror_mode(struct vin_device *vdev,
 		return -EINVAL;
 	}
 
-	errCode |= ov4689_read_reg(vdev,OV4689_V_FORMAT,&tmp_reg);
+	errCode |= ov4689_read_reg(vdev, OV4689_V_FORMAT, &tmp_reg);
 	tmp_reg &= (~OV4689_V_FLIP);
 	tmp_reg |= vflip;
 	ov4689_write_reg(vdev, OV4689_V_FORMAT, tmp_reg);
 
-	errCode |= ov4689_read_reg(vdev,OV4689_H_FORMAT,&tmp_reg);
-	tmp_reg &= (~OV4689_H_MIRROR);
-	tmp_reg |= hflip;
+	errCode |= ov4689_read_reg(vdev, OV4689_H_FORMAT, &tmp_reg);
+	tmp_reg |= OV4689_H_MIRROR;
+	tmp_reg ^= hflip;
 	ov4689_write_reg(vdev, OV4689_H_FORMAT, tmp_reg);
 
 	if (mirror_mode->bayer_pattern == VINDEV_BAYER_PATTERN_AUTO)
@@ -701,50 +796,92 @@ static int ov4689_get_chip_status(struct vin_device *vdev,
 {
 	u32 tmp_reg;
 
-	ov4689_read_reg(vdev,OV4689_TPM_TRIGGER,&tmp_reg);
+	ov4689_read_reg(vdev, OV4689_TPM_TRIGGER, &tmp_reg);
 	tmp_reg |= 0x01;
-	ov4689_write_reg(vdev,OV4689_TPM_TRIGGER,tmp_reg);
+	ov4689_write_reg(vdev, OV4689_TPM_TRIGGER, tmp_reg);
 	/* wait some time to read temperature */
 	msleep(5);
-	ov4689_read_reg(vdev,OV4689_TPM_READ,&tmp_reg);
+	ov4689_read_reg(vdev, OV4689_TPM_READ, &tmp_reg);
 
-	chip_status->temperature = (tmp_reg&0xFF) - OV4689_TPM_OFFSET;
+	chip_status->temperature = (tmp_reg & 0xFF) - OV4689_TPM_OFFSET;
 
 	return 0;
 }
 
 static int ov4689_get_eis_info(struct vin_device *vdev,
-		struct vindev_eisinfo *eis_info)
+	struct vindev_eisinfo *eis_info)
 {
-	struct ov4689_priv *pinfo = (struct ov4689_priv *)vdev->priv;
-	struct vin_video_format *format = vdev->cur_format;
-
-	eis_info->cap_start_x = format->act_start_x;
-	eis_info->cap_start_y = format->act_start_y;
-	eis_info->cap_cap_w = format->act_width;
-	eis_info->cap_cap_h = format->act_height;
-	eis_info->source_width = format->width;
-	eis_info->source_height = format->height;
-	eis_info->current_fps = vdev->frame_rate;
-	eis_info->main_fps = format->default_fps;
-	eis_info->current_shutter_time = vdev->shutter_time;
-	eis_info->sensor_cell_width = 200;// 2.0 um
-	eis_info->sensor_cell_height = 200;// 2.0 um
+	eis_info->sensor_cell_width = 200;/* 2.0 um */
+	eis_info->sensor_cell_height = 200;/* 2.0 um */
 	eis_info->column_bin = 1;
 	eis_info->row_bin = 1;
+	eis_info->vb_time = vdev->cur_format->vb_time;
+
+	return 0;
+}
 
-	eis_info->row_time = (u32)DIV64_CLOSEST((u64)format->line_time * 1000, 512);
+static int ov4689_get_aaa_info(struct vin_device *vdev,
+	struct vindev_aaa_info *aaa_info)
+{
+	struct ov4689_priv *pinfo = (struct ov4689_priv *)vdev->priv;
 
-	if (format->hdr_mode == AMBA_VIDEO_LINEAR_MODE) {
-		eis_info->vb_lines = pinfo->frame_length_lines - format->height;
-	} else if(format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {
-		eis_info->vb_lines = pinfo->frame_length_lines * 2 - format->height;
-	} else if (format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE) {
-		eis_info->vb_lines = pinfo->frame_length_lines * 3 - format->height;
+	aaa_info->sht0_max = pinfo->frame_length_lines - 4;
+	if (!pinfo->ll_mode) {
+		aaa_info->sht1_max = pinfo->max_middle - 1;
+		aaa_info->sht2_max = pinfo->max_short - 1;
+	} else {
+		aaa_info->sht1_max = OV4689_LL_MODE_M_MAX - 1;
+		aaa_info->sht2_max = OV4689_LL_MODE_S_MAX - 1;
 	}
+	aaa_info->ll_mode = pinfo->ll_mode;
 
 	return 0;
 }
+
+static int ov4689_set_low_light_mode(struct vin_device *vdev,
+	u32 ll_mode)
+{
+	struct ov4689_priv *pinfo = (struct ov4689_priv *)vdev->priv;
+
+	if (vdev->cur_format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {
+		if (ll_mode) {
+			pinfo->ll_mode = 1;
+			vdev->cur_format->hdr_short1_offset = OV4689_LL_MODE_M_MAX * 2 + 1;
+			ov4689_write_reg(vdev, OV4689_M_MAX_EXPO_MSB, (OV4689_LL_MODE_M_MAX >> 8) & 0xFF);
+			ov4689_write_reg(vdev, OV4689_M_MAX_EXPO_LSB, OV4689_LL_MODE_M_MAX & 0xFF);
+
+		} else {
+			pinfo->ll_mode = 0;
+			vdev->cur_format->hdr_short1_offset = pinfo->max_middle * 2 + 1;
+			ov4689_write_reg(vdev, OV4689_M_MAX_EXPO_MSB, (pinfo->max_middle >> 8) & 0xFF);
+			ov4689_write_reg(vdev, OV4689_M_MAX_EXPO_LSB, pinfo->max_middle & 0xFF);
+		}
+	} else if (vdev->cur_format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE) {
+		if (ll_mode) {
+			pinfo->ll_mode = 1;
+			vdev->cur_format->hdr_short1_offset = OV4689_LL_MODE_M_MAX * 3 + 1;
+			vdev->cur_format->hdr_short2_offset = (OV4689_LL_MODE_M_MAX + OV4689_LL_MODE_S_MAX) * 3 + 2;
+			ov4689_write_reg(vdev, OV4689_S_MAX_EXPO_MSB, (OV4689_LL_MODE_S_MAX >> 8) & 0xFF);
+			ov4689_write_reg(vdev, OV4689_S_MAX_EXPO_LSB, OV4689_LL_MODE_S_MAX & 0xFF);
+			ov4689_write_reg(vdev, OV4689_M_MAX_EXPO_MSB, (OV4689_LL_MODE_M_MAX >> 8) & 0xFF);
+			ov4689_write_reg(vdev, OV4689_M_MAX_EXPO_LSB, OV4689_LL_MODE_M_MAX & 0xFF);
+		} else {
+			pinfo->ll_mode = 0;
+			vdev->cur_format->hdr_short1_offset = pinfo->max_middle * 3 + 1;
+			vdev->cur_format->hdr_short2_offset = (pinfo->max_middle + pinfo->max_short) * 3 + 2;
+			ov4689_write_reg(vdev, OV4689_M_MAX_EXPO_MSB, (pinfo->max_middle >> 8) & 0xFF);
+			ov4689_write_reg(vdev, OV4689_M_MAX_EXPO_LSB, pinfo->max_middle & 0xFF);
+			ov4689_write_reg(vdev, OV4689_S_MAX_EXPO_MSB, (pinfo->max_short >> 8) & 0xFF);
+			ov4689_write_reg(vdev, OV4689_S_MAX_EXPO_LSB, pinfo->max_short & 0xFF);
+		}
+	} else {
+		vin_error("Non HDR mode can't support this API: %s!\n", __func__);
+		return -EPERM;
+	}
+
+	return 0;
+}
+
 #ifdef CONFIG_PM
 static int ov4689_suspend(struct vin_device *vdev)
 {
@@ -752,17 +889,18 @@ static int ov4689_suspend(struct vin_device *vdev)
 
 	for (i = 0; i < ARRAY_SIZE(pm_regs); i++) {
 		ov4689_read_reg(vdev, pm_regs[i].addr, &tmp);
-		pm_regs[i].data = (u16) tmp;
+		pm_regs[i].data = (u8)tmp;
 	}
 
 	return 0;
 }
+
 static int ov4689_resume(struct vin_device *vdev)
 {
 	int i;
 
 	for (i = 0; i < ARRAY_SIZE(pm_regs); i++) {
-		ov4689_write_reg(vdev, pm_regs[i].addr, (u32)pm_regs[i].data);
+		ov4689_write_reg(vdev, pm_regs[i].addr, pm_regs[i].data);
 	}
 
 	return 0;
@@ -772,19 +910,21 @@ static int ov4689_resume(struct vin_device *vdev)
 static struct vin_ops ov4689_ops = {
 	.init_device		= ov4689_init_device,
 	.set_format		= ov4689_set_format,
-	.set_shutter_row 	= ov4689_set_shutter_row,
-	.shutter2row 		= ov4689_shutter2row,
+	.set_shutter_row	= ov4689_set_shutter_row,
+	.shutter2row		= ov4689_shutter2row,
 	.set_frame_rate	= ov4689_set_fps,
-	.set_agc_index	= ov4689_set_agc_index,
+	.set_agc_index		= ov4689_set_agc_index,
 	.set_mirror_mode	= ov4689_set_mirror_mode,
 	.read_reg			= ov4689_read_reg,
 	.write_reg		= ov4689_write_reg,
 	.set_hold_mode	= ov4689_set_hold_mode,
 	.get_chip_status	= ov4689_get_chip_status,
 	.get_eis_info		= ov4689_get_eis_info,
+	.get_aaa_info		= ov4689_get_aaa_info,
+	.set_low_light_mode	= ov4689_set_low_light_mode,
 #ifdef CONFIG_PM
-	.suspend 			= ov4689_suspend,
-	.resume 			= ov4689_resume,
+	.suspend		= ov4689_suspend,
+	.resume			= ov4689_resume,
 #endif
 
 	/* for wdr sensor */
@@ -797,7 +937,6 @@ static struct vin_ops ov4689_ops = {
 	.wdr_shutter2row = ov4689_wdr_shutter2row,
 };
 
-/*	< include init.c here for aptina sensor, which is produce by perl >  */
 /* ========================================================================== */
 static int ov4689_probe(struct i2c_client *client,
 	const struct i2c_device_id *id)
@@ -807,21 +946,33 @@ static int ov4689_probe(struct i2c_client *client,
 	struct ov4689_priv *ov4689;
 	struct vin_video_format *formats;
 	u32 num_formats;
+	u32 intf_id;
+	static u8 probe_num = 0;
+
+	intf_id = (vinc_id >> (probe_num << 2)) & 0xF;
+
+	if (intf_id == 0xF) /* vinc_id end */
+		return 0;
+
+	if (vinc_id > 0xF) { /* multi vin case, use dt ids to load driver automatically */
+		client->addr = addr;
+		strlcpy(client->name, "ov4689", I2C_NAME_SIZE);
+	}
 
 	vdev = ambarella_vin_create_device(client->name,
 			SENSOR_OV4689, sizeof(struct ov4689_priv));
 	if (!vdev)
 		return -ENOMEM;
 
-	vdev->intf_id = 0;
+	vdev->intf_id = intf_id;
 	vdev->dev_type = VINDEV_TYPE_SENSOR;
 	vdev->sub_type = VINDEV_SUBTYPE_CMOS;
 	vdev->default_mode = AMBA_VIDEO_MODE_2688_1512;
 	vdev->default_hdr_mode = AMBA_VIDEO_LINEAR_MODE;
-	vdev->agc_db_max = 0x24000000;	// 36dB
-	vdev->agc_db_min = 0x00000000;	// 0dB
-	vdev->agc_db_step = 0x00180000;	// 0.09375dB
-	vdev->pixel_size = 0x00020000;	/* 2.0um */
+	vdev->agc_db_max = 0x24000000;  /* 36dB */
+	vdev->agc_db_min = 0x00000000;  /* 0dB */
+	vdev->agc_db_step = 0x00180000; /* 0.09375dB */
+	vdev->pixel_size = 0x00020000;  /* 2.0um */
 	vdev->wdr_again_idx_min = 0;
 	vdev->wdr_again_idx_max = OV4689_AGAIN_ROWS - 1;
 	vdev->wdr_dgain_idx_min = 0;
@@ -850,12 +1001,16 @@ static int ov4689_probe(struct i2c_client *client,
 	if (rval < 0)
 		goto ov4689_probe_err;
 
-	vin_info("OV4689 init(%d-lane mipi)\n", lane);
+	vin_info("OV4689 init(%d-lane mipi), [vinc:vsrc]%d:%d\n",
+		lane, vdev->intf_id, vdev->vsrc_id);
+
+	probe_num++;
 
 	return 0;
 
 ov4689_probe_err:
 	ambarella_vin_free_device(vdev);
+	strlcpy(client->name, AMBARELLA_I2C_VIN_FDT_NAME, I2C_NAME_SIZE);
 	return rval;
 }
 
@@ -866,6 +1021,7 @@ static int ov4689_remove(struct i2c_client *client)
 	vdev = (struct vin_device *)i2c_get_clientdata(client);
 	ambarella_vin_unregister_device(vdev);
 	ambarella_vin_free_device(vdev);
+	strlcpy(client->name, AMBARELLA_I2C_VIN_FDT_NAME, I2C_NAME_SIZE);
 
 	return 0;
 }
@@ -876,27 +1032,36 @@ static const struct i2c_device_id ov4689_idtable[] = {
 };
 MODULE_DEVICE_TABLE(i2c, ov4689_idtable);
 
+#ifdef CONFIG_OF
+static const struct of_device_id ov4689_dt_ids[] = {
+	{ .compatible = "ambarella,ambvin", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ov4689_dt_ids);
+#endif
+
 static struct i2c_driver i2c_driver_ov4689 = {
 	.driver = {
 		.name	= "ov4689",
+		.owner	= THIS_MODULE,
 	},
 
 	.id_table	= ov4689_idtable,
 	.probe		= ov4689_probe,
 	.remove		= ov4689_remove,
-
 };
 
 static int __init ov4689_init(void)
 {
-	int bus, addr, rval;
-
-	bus = bus_addr >> 16;
-	addr = bus_addr & 0xffff;
+	int rval;
 
-	rval = ambpriv_i2c_update_addr("ov4689", bus, addr);
-	if (rval < 0)
-		return rval;
+	if (vinc_id > 0xF) { /* multi vin case, use dt ids to load driver automatically */
+		i2c_driver_ov4689.driver.of_match_table = of_match_ptr(ov4689_dt_ids);
+	} else {
+		rval = ambpriv_i2c_update_addr("ov4689", bus_id, addr);
+		if (rval < 0)
+			return rval;
+	}
 
 	rval = i2c_add_driver(&i2c_driver_ov4689);
 	if (rval < 0)
@@ -916,4 +1081,3 @@ module_exit(ov4689_exit);
 MODULE_DESCRIPTION("OV4689 1/3 -Inch, 2688x1520, 4-Megapixel CMOS Digital Image Sensor");
 MODULE_AUTHOR("Long Zhao <longzhao@ambarella.com>");
 MODULE_LICENSE("Proprietary");
-
diff --git a/drivers/vin/sensors/omnivision_ov4689_mipi/ov4689.h b/drivers/vin/sensors/omnivision_ov4689_mipi/ov4689.h
index f997c39..0cb59cc 100644
--- a/drivers/vin/sensors/omnivision_ov4689_mipi/ov4689.h
+++ b/drivers/vin/sensors/omnivision_ov4689_mipi/ov4689.h
@@ -1,20 +1,39 @@
 /*
- * Filename : ov4689_pri.h
+ * Filename : ov4689.h
  *
  * History:
  *    2012/03/23 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2013, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
-#ifndef __OV4689_PRI_H__
-#define __OV4689_PRI_H__
+
+#ifndef __OV4689_H__
+#define __OV4689_H__
+
+#define USE_2X_RATIO			0
 
 #define OV4689_STANDBY			0x0100
 #define OV4689_IMG_ORI			0x0101
@@ -55,10 +74,10 @@
 #define OV4689_S_GAIN_LSB		0x3515
 
 #define OV4689_M_MAX_EXPO_MSB	0x3760
-#define OV4689_M_MAX_EXPO_LSB		0x3761
+#define OV4689_M_MAX_EXPO_LSB	0x3761
 
 #define OV4689_S_MAX_EXPO_MSB	0x3762
-#define OV4689_S_MAX_EXPO_LSB		0x3763
+#define OV4689_S_MAX_EXPO_LSB	0x3763
 
 #define OV4689_L_WB_R_GAIN_MSB	0x500C
 #define OV4689_L_WB_R_GAIN_LSB	0x500D
@@ -91,7 +110,6 @@
 
 #define OV4689_MIPI_GATE		(1<<5)
 
-
 #define OV4689_V_FORMAT		0x3820
 #define OV4689_H_FORMAT		0x3821
 
@@ -102,5 +120,22 @@
 #define OV4689_TPM_READ		0x4D13
 #define OV4689_TPM_OFFSET		64
 
-#endif /* __OV4689_PRI_H__ */
+#if USE_2X_RATIO
+#define M_MAX_EXPO_4M			0x186
+#define M_MAX_EXPO_3M			0x242
+#else
+#define M_MAX_EXPO_4M			0x80
+#define M_MAX_EXPO_3M			0x16e
+#endif
+
+#define M_MAX_EXPO_3X_4M		0xCC
+#define S_MAX_EXPO_3X_4M		0x33
+
+#define M_MAX_EXPO_3X_3M		0x80
+#define S_MAX_EXPO_3X_3M		0x40
+
+#define OV4689_LL_MODE_M_MAX		5
+#define OV4689_LL_MODE_S_MAX		5
+
+#endif /* __OV4689_H__ */
 
diff --git a/drivers/vin/sensors/omnivision_ov4689_mipi/ov4689_table.c b/drivers/vin/sensors/omnivision_ov4689_mipi/ov4689_table.c
index 8fef319..6c5e124 100644
--- a/drivers/vin/sensors/omnivision_ov4689_mipi/ov4689_table.c
+++ b/drivers/vin/sensors/omnivision_ov4689_mipi/ov4689_table.c
@@ -1,19 +1,37 @@
 /*
- * Filename : ov4689_reg_tbl.c
+ * Filename : ov4689_table.c
  *
  * History:
  *    2012/03/23 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2013, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_video_pll ov4689_plls[] = {
-	{0, 24167808, 120839040}, // for linear mode
+	{0, 23993520, 119967600}, // for linear mode
 	{0, 24007680, 60019200}, // for 2x wdr
 	{0, 24167808, 40279680}, // for 3x wdr
 	{0, 23992320, 119961600}, // for 2 lane 1080p
@@ -88,21 +106,19 @@ static struct vin_video_format ov4689_4lane_formats[] = {
 	{
 		.video_mode	= AMBA_VIDEO_MODE_1080P,
 		.def_start_x	= (2368 - 1920) / 2,
-		.def_start_y	= 0,
+		.def_start_y	= (1332 - 1080),
 		.def_width	= 1920,
-		.def_height	= (1332 + 0x16e) * 2,
+		.def_height	= (1080 + M_MAX_EXPO_3M) * 2,
 		.act_start_x	= 0,
-		.act_start_y	= (1332 - 1080) / 2,
+		.act_start_y	= 0,
 		.act_width	= 1920,
 		.act_height	= 1080,
-		.max_act_width = 1920,
-		.max_act_height = 1332,
 		/* sensor mode */
 		.hdr_mode = AMBA_VIDEO_2X_HDR_MODE,
 		.device_mode	= 0,
 		.pll_idx	= 1,
 		.width		= 2368,
-		.height		= (1332 + 0x16e) * 2,
+		.height		= (1332 + M_MAX_EXPO_3M) * 2,
 		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
 		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
 		.bits		= AMBA_VIDEO_BITS_10,
@@ -113,27 +129,25 @@ static struct vin_video_format ov4689_4lane_formats[] = {
 		.default_shutter_time	= AMBA_VIDEO_FPS_30,
 		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_BG,
 		.hdr_long_offset = 0,
-		.hdr_short1_offset = 0x16e * 2 + 1, /* 2 x M_MAX_EXPO + 1 */
+		.hdr_short1_offset = M_MAX_EXPO_3M * 2 + 1, /* 2 x M_MAX_EXPO + 1 */
 	},
 	/* 2x hdr mode - QHD (2560x1440) */
 	{
 		.video_mode	= AMBA_VIDEO_MODE_2560_1440,
-		.def_start_x	= 0,
-		.def_start_y	= 0,
-		.def_width	= 2688,
-		.def_height	= (1520 + 0x80) * 2,
-		.act_start_x	= (2688 - 2560) / 2,
-		.act_start_y	= (1520 - 1440) / 2,
+		.def_start_x	= (2688 - 2560) / 2,
+		.def_start_y	= (1520 - 1440),
+		.def_width	= 2560,
+		.def_height	= (1440 + M_MAX_EXPO_4M) * 2,
+		.act_start_x	= 0,
+		.act_start_y	= 0,
 		.act_width	= 2560,
 		.act_height	= 1440,
-		.max_act_width = 2688,
-		.max_act_height = 1520,
 		/* sensor mode */
 		.hdr_mode = AMBA_VIDEO_2X_HDR_MODE,
 		.device_mode	= 0,
 		.pll_idx	= 1,
 		.width		= 2688,
-		.height		= (1520 + 0x80) * 2,
+		.height		= (1520 + M_MAX_EXPO_4M) * 2,
 		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
 		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
 		.bits		= AMBA_VIDEO_BITS_10,
@@ -144,7 +158,7 @@ static struct vin_video_format ov4689_4lane_formats[] = {
 		.default_shutter_time	= AMBA_VIDEO_FPS_30,
 		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_BG,
 		.hdr_long_offset = 0,
-		.hdr_short1_offset = 0x80 * 2 + 1, /* 2 x M_MAX_EXPO + 1 */
+		.hdr_short1_offset = M_MAX_EXPO_4M * 2 + 1, /* 2 x M_MAX_EXPO + 1 */
 	},
 	/* 2x hdr mode - 4M (2688x1520) */
 	{
@@ -152,19 +166,17 @@ static struct vin_video_format ov4689_4lane_formats[] = {
 		.def_start_x	= 0,
 		.def_start_y	= 0,
 		.def_width	= 2688,
-		.def_height	= (1520 + 0x80) * 2,
+		.def_height	= (1520 + M_MAX_EXPO_4M) * 2,
 		.act_start_x	= 0,
 		.act_start_y	= 0,
 		.act_width	= 2688,
 		.act_height	= 1520,
-		.max_act_width = 2688,
-		.max_act_height = 1520,
 		/* sensor mode */
 		.hdr_mode = AMBA_VIDEO_2X_HDR_MODE,
 		.device_mode	= 0,
 		.pll_idx	= 1,
 		.width		= 2688,
-		.height		= (1520 + 0x80) * 2,
+		.height		= (1520 + M_MAX_EXPO_4M) * 2,
 		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
 		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
 		.bits		= AMBA_VIDEO_BITS_10,
@@ -175,21 +187,19 @@ static struct vin_video_format ov4689_4lane_formats[] = {
 		.default_shutter_time	= AMBA_VIDEO_FPS_30,
 		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_BG,
 		.hdr_long_offset = 0,
-		.hdr_short1_offset = 0x80 * 2 + 1, /* 2 x M_MAX_EXPO + 1 */
+		.hdr_short1_offset = M_MAX_EXPO_4M * 2 + 1, /* 2 x M_MAX_EXPO + 1 */
 	},
 	/* 3x hdr mode */
 	{
 		.video_mode	= AMBA_VIDEO_MODE_1080P,
-		.def_start_x	= 0,
-		.def_start_y	= 0,
-		.def_width	= 2368,
-		.def_height	= (1332 + 0x80 + 0x40) * 3,
-		.act_start_x	= (2368 - 1920) / 2,
-		.act_start_y	= (1332 - 1080) / 2,
+		.def_start_x	= (2368 - 1920) / 2,
+		.def_start_y	= (1332 - 1080) * 3 / 2,
+		.def_width	= 1920,
+		.def_height	= (1080 + 0x80 + 0x40) * 3,
+		.act_start_x	= 0,
+		.act_start_y	= 0,
 		.act_width	= 1920,
 		.act_height	= 1080,
-		.max_act_width = 2368,
-		.max_act_height = 1332,
 		/* sensor mode */
 		.hdr_mode = AMBA_VIDEO_3X_HDR_MODE,
 		.device_mode	= 0,
@@ -206,22 +216,20 @@ static struct vin_video_format ov4689_4lane_formats[] = {
 		.default_shutter_time	= AMBA_VIDEO_FPS_30,
 		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_BG,
 		.hdr_long_offset = 0,
-		.hdr_short1_offset = 0x80 * 3 + 1, /* 3 * M_MAX_EXPO + 1 */
-		.hdr_short2_offset = (0x80 * 3 + 1) + (0x40 * 3 + 1), /* hdr_short1_offset + 3 * S_MAX_EXPO + 1 */
+		.hdr_short1_offset = M_MAX_EXPO_3X_3M * 3 + 1, /* 3 * M_MAX_EXPO + 1 */
+		.hdr_short2_offset = (M_MAX_EXPO_3X_3M * 3 + 1) + (S_MAX_EXPO_3X_3M * 3 + 1), /* hdr_short1_offset + 3 * S_MAX_EXPO + 1 */
 	},
 	/* 3x hdr mode-4M */
 	{
 		.video_mode	= AMBA_VIDEO_MODE_2560_1440,
-		.def_start_x	= 0,
-		.def_start_y	= 0,
-		.def_width	= 2688,
-		.def_height	= (1520 + 0xCC + 0x33) * 3,
-		.act_start_x	= (2688 - 2560) / 2,
-		.act_start_y	= (1520 - 1440) / 2,
+		.def_start_x	= (2688 - 2560) / 2,
+		.def_start_y	= (1520 - 1440) * 3 / 2,
+		.def_width	= 2560,
+		.def_height	= (1440 + 0xCC + 0x33) * 3,
+		.act_start_x	= 0,
+		.act_start_y	= 0,
 		.act_width	= 2560,
 		.act_height	= 1440,
-		.max_act_width = 2688,
-		.max_act_height = 1520,
 		/* sensor mode */
 		.hdr_mode = AMBA_VIDEO_3X_HDR_MODE,
 		.device_mode	= 0,
@@ -238,8 +246,8 @@ static struct vin_video_format ov4689_4lane_formats[] = {
 		.default_shutter_time	= AMBA_VIDEO_FPS_30,
 		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_BG,
 		.hdr_long_offset = 0,
-		.hdr_short1_offset = 0xCC * 3 + 1, /* 3 * M_MAX_EXPO + 1 */
-		.hdr_short2_offset = (0xCC * 3 + 1) + (0x33 * 3 + 1), /* hdr_short1_offset + 3 * S_MAX_EXPO + 1 */
+		.hdr_short1_offset = M_MAX_EXPO_3X_4M * 3 + 1, /* 3 * M_MAX_EXPO + 1 */
+		.hdr_short2_offset = (M_MAX_EXPO_3X_4M * 3 + 1) + (S_MAX_EXPO_3X_4M * 3 + 1), /* hdr_short1_offset + 3 * S_MAX_EXPO + 1 */
 	},
 };
 
@@ -248,7 +256,7 @@ static struct vin_video_format ov4689_2lane_formats[] = {
 	{
 		.video_mode = AMBA_VIDEO_MODE_2688_1512,
 		.def_start_x = 0,
-		.def_start_y = (1520 - 1512)/2,
+		.def_start_y = (1520 - 1512) / 2,
 		.def_width = 2688,
 		.def_height = 1512,
 		/* sensor mode */
@@ -1487,8 +1495,13 @@ static struct vin_reg_16_8 ov4689_2x_hdr_regs[] = {
 	{0x3754, 0xbc},
 	{0x3756, 0x52},
 	{0x375c, 0x00},
+#if USE_2X_RATIO
+	{0x3760, 0x02},
+	{0x3761, 0x42},
+#else
 	{0x3760, 0x01},// 02
 	{0x3761, 0x6e},// ovt@20131001
+#endif
 	{0x3762, 0x00},
 	{0x3763, 0x00},
 	{0x3764, 0x01},// 00
@@ -1906,8 +1919,13 @@ static struct vin_reg_16_8 ov4689_2x_hdr_4m_regs[] = {
 	{0x350c, 0x80},
 
 	// NEW_STG_HDR2
+#if USE_2X_RATIO
+	{0x3760, 0x01},
+	{0x3761, 0x86},
+#else
 	{0x3760, 0x00}, // 02
 	{0x3761, 0x80}, // 00
+#endif
 	{0x3762, 0x00},
 	{0x3763, 0x00},
 	{0x3500, 0x00},
@@ -2512,8 +2530,6 @@ static struct vin_reg_16_8 ov4689_3x_hdr_4m_regs[] = {
 
 #ifdef CONFIG_PM
 static struct vin_reg_16_8 pm_regs[] = {
-	{OV4689_VTS_MSB, 0x00},
-	{OV4689_VTS_LSB, 0x00},
 	{OV4689_L_EXPO_HSB, 0x00},
 	{OV4689_L_EXPO_MSB, 0x00},
 	{OV4689_L_EXPO_LSB, 0x00},
diff --git a/drivers/vin/sensors/omnivision_ov5653/Kbuild b/drivers/vin/sensors/omnivision_ov5653/Kbuild
index 43568e3..d1e4b97 100644
--- a/drivers/vin/sensors/omnivision_ov5653/Kbuild
+++ b/drivers/vin/sensors/omnivision_ov5653/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/08/18 - [Hao Zeng] Create
 ##
-## Copyright (C) 2004-2014, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/omnivision_ov5653/make.inc b/drivers/vin/sensors/omnivision_ov5653/make.inc
index a9fa8ef..3d34306 100644
--- a/drivers/vin/sensors/omnivision_ov5653/make.inc
+++ b/drivers/vin/sensors/omnivision_ov5653/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/08/18 - [Hao Zeng] Created file
 ##
-## Copyright (C) 2004-2014, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_OV5653), y)
diff --git a/drivers/vin/sensors/omnivision_ov5653/ov5653.c b/drivers/vin/sensors/omnivision_ov5653/ov5653.c
index 34bcaa6..c789de2 100644
--- a/drivers/vin/sensors/omnivision_ov5653/ov5653.c
+++ b/drivers/vin/sensors/omnivision_ov5653/ov5653.c
@@ -4,15 +4,33 @@
  * History:
  *    2014/08/18 - [Hao Zeng] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
diff --git a/drivers/vin/sensors/omnivision_ov5653/ov5653.h b/drivers/vin/sensors/omnivision_ov5653/ov5653.h
index b0b4c86..f024849 100644
--- a/drivers/vin/sensors/omnivision_ov5653/ov5653.h
+++ b/drivers/vin/sensors/omnivision_ov5653/ov5653.h
@@ -4,15 +4,33 @@
  * History:
  *    2014/08/18 - [Hao Zeng] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #ifndef __OV5653_PRI_H__
 #define __OV5653_PRI_H__
 
diff --git a/drivers/vin/sensors/omnivision_ov5653/ov5653_table.c b/drivers/vin/sensors/omnivision_ov5653/ov5653_table.c
index fe33b58..a302123 100644
--- a/drivers/vin/sensors/omnivision_ov5653/ov5653_table.c
+++ b/drivers/vin/sensors/omnivision_ov5653/ov5653_table.c
@@ -4,14 +4,33 @@
  * History:
  *    2014/08/18 - [Hao Zeng] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_video_pll ov5653_plls[] = {
 	{0, 24000000, 96000000},
 	{0, 24000000, 95992800},
diff --git a/drivers/vin/sensors/omnivision_ov5658_mipi/Kbuild b/drivers/vin/sensors/omnivision_ov5658_mipi/Kbuild
index 7a8683d..57f61a5 100644
--- a/drivers/vin/sensors/omnivision_ov5658_mipi/Kbuild
+++ b/drivers/vin/sensors/omnivision_ov5658_mipi/Kbuild
@@ -4,15 +4,30 @@
 ## History:
 ##    2011/01/12 - [Haowei Lo] Create
 ##
-## Copyright (C) 2004-2011, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
-## This file is produced by perl.
-##/
 
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/omnivision_ov5658_mipi/make.inc b/drivers/vin/sensors/omnivision_ov5658_mipi/make.inc
index 42fdbbd..093e817 100644
--- a/drivers/vin/sensors/omnivision_ov5658_mipi/make.inc
+++ b/drivers/vin/sensors/omnivision_ov5658_mipi/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/04 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_OV5658_MIPI), y)
diff --git a/drivers/vin/sensors/omnivision_ov5658_mipi/ov5658.c b/drivers/vin/sensors/omnivision_ov5658_mipi/ov5658.c
index 387c0ec..0ce2456 100644
--- a/drivers/vin/sensors/omnivision_ov5658_mipi/ov5658.c
+++ b/drivers/vin/sensors/omnivision_ov5658_mipi/ov5658.c
@@ -4,15 +4,33 @@
  * History:
  *    2014/05/28 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
@@ -372,6 +390,7 @@ static int ov5658_set_mirror_mode(struct vin_device *vdev,
 	ov5658_write_reg(vdev, OV5658_V_FORMAT, tmp_reg);
 
 	errCode |= ov5658_read_reg(vdev,OV5658_H_FORMAT,&tmp_reg);
+	tmp_reg |= OV5658_H_MIRROR;
 	tmp_reg ^= hflip;
 	ov5658_write_reg(vdev, OV5658_H_FORMAT, tmp_reg);
 
diff --git a/drivers/vin/sensors/omnivision_ov5658_mipi/ov5658.h b/drivers/vin/sensors/omnivision_ov5658_mipi/ov5658.h
index 9e16463..c59d9ae 100644
--- a/drivers/vin/sensors/omnivision_ov5658_mipi/ov5658.h
+++ b/drivers/vin/sensors/omnivision_ov5658_mipi/ov5658.h
@@ -4,15 +4,33 @@
  * History:
  *    2014/05/28 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #ifndef __OV5658_PRI_H__
 #define __OV5658_PRI_H__
 
diff --git a/drivers/vin/sensors/omnivision_ov5658_mipi/ov5658_table.c b/drivers/vin/sensors/omnivision_ov5658_mipi/ov5658_table.c
index c61f713..838b8ae 100644
--- a/drivers/vin/sensors/omnivision_ov5658_mipi/ov5658_table.c
+++ b/drivers/vin/sensors/omnivision_ov5658_mipi/ov5658_table.c
@@ -4,14 +4,33 @@
  * History:
  *    2014/05/28 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_video_pll ov5658_plls[] = {
 	{0, 24000000, 191892480},
 	{0, 24000000, 191884800},
diff --git a/drivers/vin/sensors/omnivision_ov9710/Kbuild b/drivers/vin/sensors/omnivision_ov9710/Kbuild
index 6e7efb6..a39badb 100644
--- a/drivers/vin/sensors/omnivision_ov9710/Kbuild
+++ b/drivers/vin/sensors/omnivision_ov9710/Kbuild
@@ -4,15 +4,30 @@
 ## History:
 ##    2014/11/11 - [Hao Zeng] Create
 ##
-## Copyright (C) 2004-2014, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
-## This file is produced by perl.
-##/
 
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/omnivision_ov9710/make.inc b/drivers/vin/sensors/omnivision_ov9710/make.inc
index 0612c38..9df9275 100644
--- a/drivers/vin/sensors/omnivision_ov9710/make.inc
+++ b/drivers/vin/sensors/omnivision_ov9710/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/11/11 - [Hao Zeng] Created file
 ##
-## Copyright (C) 2004-2014, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_OV9710), y)
diff --git a/drivers/vin/sensors/omnivision_ov9710/ov9710.c b/drivers/vin/sensors/omnivision_ov9710/ov9710.c
index ba7dd90..b913ac1 100644
--- a/drivers/vin/sensors/omnivision_ov9710/ov9710.c
+++ b/drivers/vin/sensors/omnivision_ov9710/ov9710.c
@@ -4,15 +4,33 @@
  * History:
  *    2014/11/11 - [Hao Zeng] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
diff --git a/drivers/vin/sensors/omnivision_ov9710/ov9710.h b/drivers/vin/sensors/omnivision_ov9710/ov9710.h
index 3e481b5..0421862 100644
--- a/drivers/vin/sensors/omnivision_ov9710/ov9710.h
+++ b/drivers/vin/sensors/omnivision_ov9710/ov9710.h
@@ -4,15 +4,33 @@
  * History:
  *    2014/11/11 - [Hao Zeng] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #ifndef __OV9710_PRI_H__
 #define __OV9710_PRI_H__
 
diff --git a/drivers/vin/sensors/omnivision_ov9710/ov9710_table.c b/drivers/vin/sensors/omnivision_ov9710/ov9710_table.c
index d4cf53b..5c95a15 100644
--- a/drivers/vin/sensors/omnivision_ov9710/ov9710_table.c
+++ b/drivers/vin/sensors/omnivision_ov9710/ov9710_table.c
@@ -4,14 +4,33 @@
  * History:
  *    2014/11/11 - [Hao Zeng] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_video_pll ov9710_plls[] = {
 	/* for 30fps */
 	{0, 24002537, 42004440},
diff --git a/drivers/vin/sensors/omnivision_ov9718_mipi/Kbuild b/drivers/vin/sensors/omnivision_ov9718_mipi/Kbuild
index 9bc7d3d..45e0f59 100644
--- a/drivers/vin/sensors/omnivision_ov9718_mipi/Kbuild
+++ b/drivers/vin/sensors/omnivision_ov9718_mipi/Kbuild
@@ -4,15 +4,30 @@
 ## History:
 ##    2011/01/12 - [Haowei Lo] Create
 ##
-## Copyright (C) 2004-2011, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
-## This file is produced by perl.
-##/
 
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/omnivision_ov9718_mipi/make.inc b/drivers/vin/sensors/omnivision_ov9718_mipi/make.inc
index 55dc161..74198a4 100644
--- a/drivers/vin/sensors/omnivision_ov9718_mipi/make.inc
+++ b/drivers/vin/sensors/omnivision_ov9718_mipi/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/04 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_OV9718_MIPI), y)
diff --git a/drivers/vin/sensors/omnivision_ov9718_mipi/ov9718.c b/drivers/vin/sensors/omnivision_ov9718_mipi/ov9718.c
index 5769843..2b905aa 100644
--- a/drivers/vin/sensors/omnivision_ov9718_mipi/ov9718.c
+++ b/drivers/vin/sensors/omnivision_ov9718_mipi/ov9718.c
@@ -4,15 +4,33 @@
  * History:
  *    2012/03/23 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2013, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
diff --git a/drivers/vin/sensors/omnivision_ov9718_mipi/ov9718.h b/drivers/vin/sensors/omnivision_ov9718_mipi/ov9718.h
index 3b69d6c..a0ee6b2 100644
--- a/drivers/vin/sensors/omnivision_ov9718_mipi/ov9718.h
+++ b/drivers/vin/sensors/omnivision_ov9718_mipi/ov9718.h
@@ -4,15 +4,33 @@
  * History:
  *    2012/03/23 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2013, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #ifndef __OV9718_PRI_H__
 #define __OV9718_PRI_H__
 
diff --git a/drivers/vin/sensors/omnivision_ov9718_mipi/ov9718_table.c b/drivers/vin/sensors/omnivision_ov9718_mipi/ov9718_table.c
index 693fad6..67fcd47 100644
--- a/drivers/vin/sensors/omnivision_ov9718_mipi/ov9718_table.c
+++ b/drivers/vin/sensors/omnivision_ov9718_mipi/ov9718_table.c
@@ -4,16 +4,35 @@
  * History:
  *    2012/03/23 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2013, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_video_pll ov9718_plls[] = {
-	{0, 24000000, 80000000},
+	{0, 24017940, 80059800},
 };
 
 static struct vin_video_format ov9718_formats[] = {
@@ -254,11 +273,12 @@ static struct vin_reg_16_8 ov9718_share_regs[] = {
 	{0x3094, 0x01},
 	{0x30b3, 0x14},
 	{0x4837, 0x21},
-#endif
+#else
 	//60FPS KEY
 	{0x3094, 0x02},
 	{0x30b3, 0x28},
 	{0x4837, 0x10},
+#endif
 };
 
 /* Gain table */
diff --git a/drivers/vin/sensors/omnivision_ov9732_mipi/Kbuild b/drivers/vin/sensors/omnivision_ov9732_mipi/Kbuild
index dec66d4..8a86adf 100644
--- a/drivers/vin/sensors/omnivision_ov9732_mipi/Kbuild
+++ b/drivers/vin/sensors/omnivision_ov9732_mipi/Kbuild
@@ -4,15 +4,30 @@
 ## History:
 ##    2015/07/28 - [Hao Zeng] Create
 ##
-## Copyright (C) 2004-2015, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
-## This file is produced by perl.
-##/
 
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/omnivision_ov9732_mipi/make.inc b/drivers/vin/sensors/omnivision_ov9732_mipi/make.inc
index 4322e65..5996e41 100644
--- a/drivers/vin/sensors/omnivision_ov9732_mipi/make.inc
+++ b/drivers/vin/sensors/omnivision_ov9732_mipi/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2015/07/28 - [Hao Zeng] Create
 ##
-## Copyright (C) 2004-2015, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_OV9732_MIPI), y)
diff --git a/drivers/vin/sensors/omnivision_ov9732_mipi/ov9732.c b/drivers/vin/sensors/omnivision_ov9732_mipi/ov9732.c
index 67dcdab..de1e191 100644
--- a/drivers/vin/sensors/omnivision_ov9732_mipi/ov9732.c
+++ b/drivers/vin/sensors/omnivision_ov9732_mipi/ov9732.c
@@ -4,15 +4,33 @@
  * History:
  *    2015/07/28 - [Hao Zeng] Create
  *
- * Copyright (C) 2004-2015, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
diff --git a/drivers/vin/sensors/omnivision_ov9732_mipi/ov9732.h b/drivers/vin/sensors/omnivision_ov9732_mipi/ov9732.h
index 1778ac4..8c93bd3 100644
--- a/drivers/vin/sensors/omnivision_ov9732_mipi/ov9732.h
+++ b/drivers/vin/sensors/omnivision_ov9732_mipi/ov9732.h
@@ -4,15 +4,33 @@
  * History:
  *    2015/07/28 - [Hao Zeng] Create
  *
- * Copyright (C) 2004-2015, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #ifndef __OV9732_PRI_H__
 #define __OV9732_PRI_H__
 
diff --git a/drivers/vin/sensors/omnivision_ov9732_mipi/ov9732_table.c b/drivers/vin/sensors/omnivision_ov9732_mipi/ov9732_table.c
index 3801406..2c6e96b 100644
--- a/drivers/vin/sensors/omnivision_ov9732_mipi/ov9732_table.c
+++ b/drivers/vin/sensors/omnivision_ov9732_mipi/ov9732_table.c
@@ -4,14 +4,33 @@
  * History:
  *    2015/07/28 - [Hao Zeng] Create
  *
- * Copyright (C) 2004-2015, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_video_pll ov9732_plls[] = {
 	{0, 24000000, 36000000},
 };
diff --git a/drivers/vin/sensors/omnivision_ov9732_parallel/Kbuild b/drivers/vin/sensors/omnivision_ov9732_parallel/Kbuild
index dac7457..a8f1eac 100644
--- a/drivers/vin/sensors/omnivision_ov9732_parallel/Kbuild
+++ b/drivers/vin/sensors/omnivision_ov9732_parallel/Kbuild
@@ -4,15 +4,30 @@
 ## History:
 ##    2015/07/28 - [Hao Zeng] Create
 ##
-## Copyright (C) 2004-2015, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
-## This file is produced by perl.
-##/
 
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/omnivision_ov9732_parallel/make.inc b/drivers/vin/sensors/omnivision_ov9732_parallel/make.inc
index 2c05a93..a5d2199 100644
--- a/drivers/vin/sensors/omnivision_ov9732_parallel/make.inc
+++ b/drivers/vin/sensors/omnivision_ov9732_parallel/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/07/28 - [Hao Zeng] Create
 ##
-## Copyright (C) 2004-2015, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_OV9732_PARALLEL), y)
diff --git a/drivers/vin/sensors/omnivision_ov9732_parallel/ov9732.c b/drivers/vin/sensors/omnivision_ov9732_parallel/ov9732.c
index 0974ea4..5d27599 100644
--- a/drivers/vin/sensors/omnivision_ov9732_parallel/ov9732.c
+++ b/drivers/vin/sensors/omnivision_ov9732_parallel/ov9732.c
@@ -4,15 +4,33 @@
  * History:
  *    2015/07/28 - [Hao Zeng] Create
  *
- * Copyright (C) 2004-2015, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
diff --git a/drivers/vin/sensors/omnivision_ov9732_parallel/ov9732.h b/drivers/vin/sensors/omnivision_ov9732_parallel/ov9732.h
index 1ba920c..2c58fdb 100644
--- a/drivers/vin/sensors/omnivision_ov9732_parallel/ov9732.h
+++ b/drivers/vin/sensors/omnivision_ov9732_parallel/ov9732.h
@@ -4,15 +4,33 @@
  * History:
  *    2015/07/28 - [Hao Zeng] Create
  *
- * Copyright (C) 2004-2015, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #ifndef __OV9732_PRI_H__
 #define __OV9732_PRI_H__
 
diff --git a/drivers/vin/sensors/omnivision_ov9732_parallel/ov9732_table.c b/drivers/vin/sensors/omnivision_ov9732_parallel/ov9732_table.c
index 7f277a1..63f9c17 100644
--- a/drivers/vin/sensors/omnivision_ov9732_parallel/ov9732_table.c
+++ b/drivers/vin/sensors/omnivision_ov9732_parallel/ov9732_table.c
@@ -4,14 +4,33 @@
  * History:
  *    2015/07/28 - [Hao Zeng] Create
  *
- * Copyright (C) 2004-2015, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_video_pll ov9732_plls[] = {
 	{0, 24000000, 36000000},
 };
diff --git a/drivers/vin/sensors/omnivision_ov9750_mipi/Kbuild b/drivers/vin/sensors/omnivision_ov9750_mipi/Kbuild
index f427316..deaf518 100644
--- a/drivers/vin/sensors/omnivision_ov9750_mipi/Kbuild
+++ b/drivers/vin/sensors/omnivision_ov9750_mipi/Kbuild
@@ -4,15 +4,30 @@
 ## History:
 ##    2014/12/04 - [Hao Zeng] Create
 ##
-## Copyright (C) 2004-2014, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
-## This file is produced by perl.
-##/
 
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/omnivision_ov9750_mipi/make.inc b/drivers/vin/sensors/omnivision_ov9750_mipi/make.inc
index 08559af..0fca021 100644
--- a/drivers/vin/sensors/omnivision_ov9750_mipi/make.inc
+++ b/drivers/vin/sensors/omnivision_ov9750_mipi/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/12/04 - [Hao Zeng] Create
 ##
-## Copyright (C) 2004-2014, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_OV9750_MIPI), y)
diff --git a/drivers/vin/sensors/omnivision_ov9750_mipi/ov9750.c b/drivers/vin/sensors/omnivision_ov9750_mipi/ov9750.c
index c13b968..4e83fcb 100644
--- a/drivers/vin/sensors/omnivision_ov9750_mipi/ov9750.c
+++ b/drivers/vin/sensors/omnivision_ov9750_mipi/ov9750.c
@@ -4,15 +4,33 @@
  * History:
  *    2014/12/04 - [Hao Zeng] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
@@ -27,6 +45,10 @@ static int bus_addr = (0 << 16) | (0x6C >> 1);
 module_param(bus_addr, int, 0644);
 MODULE_PARM_DESC(bus_addr, " bus and addr: bit16~bit31: bus, bit0~bit15: addr");
 
+static bool ir_mode = 0;
+module_param(ir_mode, bool, 0644);
+MODULE_PARM_DESC(ir_mode, " Use IR mode, 0:RGB mode, 1:RGB/IR mode");
+
 struct ov9750_priv {
 	void *control_data;
 	u32 line_length;
@@ -361,26 +383,38 @@ static int ov9750_set_mirror_mode(struct vin_device *vdev,
 		return 0;
 
 	case VINDEV_MIRROR_NONE:
-		bayer_pattern = VINDEV_BAYER_PATTERN_BG;
+		if (ir_mode)
+			bayer_pattern = VINDEV_BAYER_PATTERN_BG_GI;
+		else
+			bayer_pattern = VINDEV_BAYER_PATTERN_BG;
 		r450b = 0x00;
 		break;
 
 	case VINDEV_MIRROR_VERTICALLY:
 		vflip = OV9750_V_FLIP;
-		bayer_pattern = VINDEV_BAYER_PATTERN_BG;
+		if (ir_mode)
+			bayer_pattern = VINDEV_BAYER_PATTERN_BG_GI;
+		else
+			bayer_pattern = VINDEV_BAYER_PATTERN_BG;
 		r450b = 0x20;
 		break;
 
 	case VINDEV_MIRROR_HORRIZONTALLY:
 		hflip = OV9750_H_MIRROR;
-		bayer_pattern = VINDEV_BAYER_PATTERN_BG;
+		if (ir_mode)
+			bayer_pattern = VINDEV_BAYER_PATTERN_BG_GI;
+		else
+			bayer_pattern = VINDEV_BAYER_PATTERN_BG;
 		r450b = 0x00;
 		break;
 
 	case VINDEV_MIRROR_HORRIZONTALLY_VERTICALLY:
 		vflip = OV9750_V_FLIP;
 		hflip = OV9750_H_MIRROR;
-		bayer_pattern = VINDEV_BAYER_PATTERN_BG;
+		if (ir_mode)
+			bayer_pattern = VINDEV_BAYER_PATTERN_BG_GI;
+		else
+			bayer_pattern = VINDEV_BAYER_PATTERN_BG;
 		r450b = 0x20;
 		break;
 
@@ -407,6 +441,31 @@ static int ov9750_set_mirror_mode(struct vin_device *vdev,
 	return errCode;
 }
 
+#ifdef CONFIG_PM
+static int ov9750_suspend(struct vin_device *vdev)
+{
+	u32 i, tmp;
+
+	for (i = 0; i < ARRAY_SIZE(pm_regs); i++) {
+		ov9750_read_reg(vdev, pm_regs[i].addr, &tmp);
+		pm_regs[i].data = (u8)tmp;
+	}
+
+	return 0;
+}
+
+static int ov9750_resume(struct vin_device *vdev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(pm_regs); i++) {
+		ov9750_write_reg(vdev, pm_regs[i].addr, pm_regs[i].data);
+	}
+
+	return 0;
+}
+#endif
+
 static struct vin_ops ov9750_ops = {
 	.init_device		= ov9750_init_device,
 	.set_format		= ov9750_set_format,
@@ -419,6 +478,10 @@ static struct vin_ops ov9750_ops = {
 	.shutter2row		= ov9750_shutter2row,
 	.read_reg		= ov9750_read_reg,
 	.write_reg		= ov9750_write_reg,
+#ifdef CONFIG_PM
+	.suspend 			= ov9750_suspend,
+	.resume 			= ov9750_resume,
+#endif
 };
 
 /*	< include init.c here for aptina sensor, which is produce by perl >  */
@@ -426,7 +489,7 @@ static struct vin_ops ov9750_ops = {
 static int ov9750_probe(struct i2c_client *client,
 	const struct i2c_device_id *id)
 {
-	int rval = 0;
+	int i, rval = 0;
 	struct vin_device *vdev;
 	struct ov9750_priv *ov9750;
 
@@ -449,13 +512,21 @@ static int ov9750_probe(struct i2c_client *client,
 	ov9750 = (struct ov9750_priv *)vdev->priv;
 	ov9750->control_data = client;
 
+	if (ir_mode) {
+		for (i = 0; i < ARRAY_SIZE(ov9750_formats); i++)
+			ov9750_formats[i].default_bayer_pattern = VINDEV_BAYER_PATTERN_BG_GI;
+	}
+
 	rval = ambarella_vin_register_device(vdev, &ov9750_ops,
 			ov9750_formats, ARRAY_SIZE(ov9750_formats),
 			ov9750_plls, ARRAY_SIZE(ov9750_plls));
 	if (rval < 0)
 		goto ov9750_probe_err;
 
-	vin_info("OV9750 init(2-lane mipi)\n");
+	if (ir_mode)
+		vin_info("OV9756 init(2-lane mipi)\n");
+	else
+		vin_info("OV9750 init(2-lane mipi)\n");
 
 	return 0;
 
diff --git a/drivers/vin/sensors/omnivision_ov9750_mipi/ov9750.h b/drivers/vin/sensors/omnivision_ov9750_mipi/ov9750.h
index de94f2e..88697af 100644
--- a/drivers/vin/sensors/omnivision_ov9750_mipi/ov9750.h
+++ b/drivers/vin/sensors/omnivision_ov9750_mipi/ov9750.h
@@ -4,15 +4,33 @@
  * History:
  *    2014/12/04 - [Hao Zeng] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #ifndef __OV9750_PRI_H__
 #define __OV9750_PRI_H__
 
diff --git a/drivers/vin/sensors/omnivision_ov9750_mipi/ov9750_table.c b/drivers/vin/sensors/omnivision_ov9750_mipi/ov9750_table.c
index 164f869..9372ea1 100644
--- a/drivers/vin/sensors/omnivision_ov9750_mipi/ov9750_table.c
+++ b/drivers/vin/sensors/omnivision_ov9750_mipi/ov9750_table.c
@@ -4,14 +4,33 @@
  * History:
  *    2014/12/04 - [Hao Zeng] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_video_pll ov9750_plls[] = {
 	{0, 24000000, 48000000},
 };
@@ -360,6 +379,24 @@ static struct vin_reg_16_8 ov9750_share_regs[] = {
 	{0x0100, 0x01},
 };
 
+#ifdef CONFIG_PM
+static struct vin_reg_16_8 pm_regs[] = {
+	{OV9750_EXPO0_HSB, 0x00},
+	{OV9750_EXPO0_MSB, 0x00},
+	{OV9750_EXPO0_LSB, 0x00},
+	{OV9750_GAIN_MSB, 0x00},
+	{OV9750_GAIN_LSB, 0x00},
+	{OV9750_GAIN_DCG, 0x00},
+	{OV9750_R_GAIN_MSB, 0x00},
+	{OV9750_R_GAIN_LSB, 0x00},
+	{OV9750_G_GAIN_MSB, 0x00},
+	{OV9750_G_GAIN_LSB, 0x00},
+	{OV9750_B_GAIN_MSB, 0x00},
+	{OV9750_B_GAIN_LSB, 0x00},
+	{0x366A, 0x00},
+};
+#endif
+
 /* Gain table */
 /* OV9750 global gain table row size */
 #define OV9750_GAIN_ROWS  		(459 + 1)
diff --git a/drivers/vin/sensors/omnivision_ov9750_parallel/Kbuild b/drivers/vin/sensors/omnivision_ov9750_parallel/Kbuild
index 18fe20a..4b2e231 100644
--- a/drivers/vin/sensors/omnivision_ov9750_parallel/Kbuild
+++ b/drivers/vin/sensors/omnivision_ov9750_parallel/Kbuild
@@ -4,15 +4,30 @@
 ## History:
 ##    2014/05/08 - [Hao Zeng] Create
 ##
-## Copyright (C) 2004-2015, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
-## This file is produced by perl.
-##/
 
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/omnivision_ov9750_parallel/make.inc b/drivers/vin/sensors/omnivision_ov9750_parallel/make.inc
index e7a57f7..ca7f6a3 100644
--- a/drivers/vin/sensors/omnivision_ov9750_parallel/make.inc
+++ b/drivers/vin/sensors/omnivision_ov9750_parallel/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/05/08 - [Hao Zeng] Create
 ##
-## Copyright (C) 2004-2015, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_OV9750_PARALLEL), y)
diff --git a/drivers/vin/sensors/omnivision_ov9750_parallel/ov9750.c b/drivers/vin/sensors/omnivision_ov9750_parallel/ov9750.c
index b576bf4..32832fa 100644
--- a/drivers/vin/sensors/omnivision_ov9750_parallel/ov9750.c
+++ b/drivers/vin/sensors/omnivision_ov9750_parallel/ov9750.c
@@ -4,15 +4,33 @@
  * History:
  *    2015/05/08 - [Hao Zeng] Create
  *
- * Copyright (C) 2004-2015, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
diff --git a/drivers/vin/sensors/omnivision_ov9750_parallel/ov9750.h b/drivers/vin/sensors/omnivision_ov9750_parallel/ov9750.h
index 245952a..928a137 100644
--- a/drivers/vin/sensors/omnivision_ov9750_parallel/ov9750.h
+++ b/drivers/vin/sensors/omnivision_ov9750_parallel/ov9750.h
@@ -4,15 +4,33 @@
  * History:
  *    2015/05/08 - [Hao Zeng] Create
  *
- * Copyright (C) 2004-2015, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #ifndef __OV9750_PRI_H__
 #define __OV9750_PRI_H__
 
diff --git a/drivers/vin/sensors/omnivision_ov9750_parallel/ov9750_table.c b/drivers/vin/sensors/omnivision_ov9750_parallel/ov9750_table.c
index a435305..1bd49b7 100644
--- a/drivers/vin/sensors/omnivision_ov9750_parallel/ov9750_table.c
+++ b/drivers/vin/sensors/omnivision_ov9750_parallel/ov9750_table.c
@@ -4,14 +4,33 @@
  * History:
  *    2015/05/08 - [Hao Zeng] Create
  *
- * Copyright (C) 2004-2015, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_video_pll ov9750_plls[] = {
 	{0, 24000000, 48000000},
 };
diff --git a/drivers/vin/sensors/panasonic_mn34041pl/Kbuild b/drivers/vin/sensors/panasonic_mn34041pl/Kbuild
index 791ea3c..a610e22 100644
--- a/drivers/vin/sensors/panasonic_mn34041pl/Kbuild
+++ b/drivers/vin/sensors/panasonic_mn34041pl/Kbuild
@@ -4,15 +4,30 @@
 ## History:
 ##    2011/03/07 - [Haowei Lo] Create
 ##
-## Copyright (C) 2004-2011, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
-## This file is produced by perl.
-##/
 
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/panasonic_mn34041pl/make.inc b/drivers/vin/sensors/panasonic_mn34041pl/make.inc
index 7fb0a0a..8193c1b 100644
--- a/drivers/vin/sensors/panasonic_mn34041pl/make.inc
+++ b/drivers/vin/sensors/panasonic_mn34041pl/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/04 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_MN34041PL), y)
diff --git a/drivers/vin/sensors/panasonic_mn34041pl/mn34041pl.c b/drivers/vin/sensors/panasonic_mn34041pl/mn34041pl.c
index 711d795..ef9d5f4 100644
--- a/drivers/vin/sensors/panasonic_mn34041pl/mn34041pl.c
+++ b/drivers/vin/sensors/panasonic_mn34041pl/mn34041pl.c
@@ -4,15 +4,33 @@
  * History:
  *    2011/01/12 - [Haowei Lo] Create
  *
- * Copyright (C) 2004-2011, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
@@ -356,56 +374,17 @@ static int mn34041pl_set_mirror_mode(struct vin_device *vdev,
 	return 0;
 }
 
-static int mn34041pl_get_vb_lines(struct vin_device *vdev)
-{
-	u32 val_high, val_low, v_lines;
-
-	mn34041pl_read_reg(vdev, 0x01A0, &val_low);
-	mn34041pl_read_reg(vdev, 0x01A1, &val_high);
-	v_lines = (val_high & 0x01) << 16 | val_low;
-	v_lines += 1;
-
-	return v_lines - vdev->cur_format->height;
-}
-
-static int mn34041pl_get_row_time( struct vin_device *vdev)
-{
-	u64 h_time, h_clks;
-
-	h_clks = 2400;
-	h_time = h_clks * 1000000000;
-	h_time = DIV64_CLOSEST(h_time, vdev->cur_pll->pixelclk); /* ns */
-
-	return h_time;
-}
-
 static int mn34041pl_get_eis_info(struct vin_device *vdev,
 		struct vindev_eisinfo *eis_info)
 {
-	struct vin_video_format *format = vdev->cur_format;
-
-	memset(eis_info, 0, sizeof (struct vindev_eisinfo));
-
-	eis_info->cap_start_x = format->def_start_x;
-	eis_info->cap_start_y = format->def_start_y;
-	eis_info->cap_cap_w = format->def_width;
-	eis_info->cap_cap_h = format->def_height;
-	eis_info->source_width = format->width;
-	eis_info->source_height = format->height;
-	eis_info->current_fps = vdev->frame_rate;
-	eis_info->main_fps = format->default_fps;
-	eis_info->current_shutter_time = vdev->shutter_time;
 	eis_info->sensor_cell_width = 275;// 2.75 um
 	eis_info->sensor_cell_height = 275;// 2.75 um
-	eis_info->column_bin = 0;
-	eis_info->row_bin = 0;
-
-	eis_info->vb_lines = mn34041pl_get_vb_lines(vdev);
-	eis_info->row_time = mn34041pl_get_row_time(vdev);
+	eis_info->column_bin = 1;
+	eis_info->row_bin = 1;
+	eis_info->vb_time = vdev->cur_format->vb_time;
 
 	return 0;
 }
-EXPORT_SYMBOL(mn34041pl_get_eis_info);
 
 static struct vin_ops mn34041pl_ops = {
 	.init_device		= mn34041pl_init_device,
diff --git a/drivers/vin/sensors/panasonic_mn34041pl/mn34041pl.h b/drivers/vin/sensors/panasonic_mn34041pl/mn34041pl.h
index d327980..d290672 100644
--- a/drivers/vin/sensors/panasonic_mn34041pl/mn34041pl.h
+++ b/drivers/vin/sensors/panasonic_mn34041pl/mn34041pl.h
@@ -4,15 +4,33 @@
  * History:
  *    2011/01/12 - [Haowei Lo] Create
  *
- * Copyright (C) 2004-2011, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #ifndef __MN34041PL_PRI_H__
 #define __MN34041PL_PRI_H__
 
diff --git a/drivers/vin/sensors/panasonic_mn34041pl/mn34041pl_table.c b/drivers/vin/sensors/panasonic_mn34041pl/mn34041pl_table.c
index 6fd6d70..4840c48 100644
--- a/drivers/vin/sensors/panasonic_mn34041pl/mn34041pl_table.c
+++ b/drivers/vin/sensors/panasonic_mn34041pl/mn34041pl_table.c
@@ -4,15 +4,34 @@
  * History:
  *2011/01/12 - [Haowei Lo] Create
  *
- * Copyright (C) 2004-2011, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 static struct vin_reg_16_16 mn34041pl_pll_regs[][6] = {
 	{
 		{0x0001, 0x0036}, {0x0002, 0x0002}, {0x0004, 0x01c2},
diff --git a/drivers/vin/sensors/panasonic_mn34210pl/Kbuild b/drivers/vin/sensors/panasonic_mn34210pl/Kbuild
index cb1665a..2e7f2b3 100644
--- a/drivers/vin/sensors/panasonic_mn34210pl/Kbuild
+++ b/drivers/vin/sensors/panasonic_mn34210pl/Kbuild
@@ -4,15 +4,30 @@
 ## History:
 ##    2015/02/05 - [Hao Zeng] Create
 ##
-## Copyright (C) 2004-2015, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
-## This file is produced by perl.
-##/
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
 EXTRA_AFLAGS		+= $(AMBARELLA_DRV_AFLAGS)
diff --git a/drivers/vin/sensors/panasonic_mn34210pl/make.inc b/drivers/vin/sensors/panasonic_mn34210pl/make.inc
index 4829a9a..5c813f0 100644
--- a/drivers/vin/sensors/panasonic_mn34210pl/make.inc
+++ b/drivers/vin/sensors/panasonic_mn34210pl/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/04 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_MN34210PL), y)
diff --git a/drivers/vin/sensors/panasonic_mn34210pl/mn34210pl.c b/drivers/vin/sensors/panasonic_mn34210pl/mn34210pl.c
index c2f2d0f..3862d6e 100644
--- a/drivers/vin/sensors/panasonic_mn34210pl/mn34210pl.c
+++ b/drivers/vin/sensors/panasonic_mn34210pl/mn34210pl.c
@@ -4,15 +4,33 @@
  * History:
  *    2015/02/05 - [Hao Zeng] Create
  *
- * Copyright (C) 2004-2015, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
diff --git a/drivers/vin/sensors/panasonic_mn34210pl/mn34210pl.h b/drivers/vin/sensors/panasonic_mn34210pl/mn34210pl.h
index 3134d3c..65d26f2 100644
--- a/drivers/vin/sensors/panasonic_mn34210pl/mn34210pl.h
+++ b/drivers/vin/sensors/panasonic_mn34210pl/mn34210pl.h
@@ -4,15 +4,33 @@
  * History:
  *    2015/02/05 - [Hao Zeng] Create
  *
- * Copyright (C) 2004-2015, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #ifndef __MN34210PL_PRI_H__
 #define __MN34210PL_PRI_H__
 
diff --git a/drivers/vin/sensors/panasonic_mn34210pl/mn34210pl_table.c b/drivers/vin/sensors/panasonic_mn34210pl/mn34210pl_table.c
index 4ae4137..e0ff914 100644
--- a/drivers/vin/sensors/panasonic_mn34210pl/mn34210pl_table.c
+++ b/drivers/vin/sensors/panasonic_mn34210pl/mn34210pl_table.c
@@ -4,15 +4,34 @@
  * History:
  *    2015/02/05 - [Hao Zeng] Create
  *
- * Copyright (C) 2004-2015, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 static struct vin_video_pll mn34210pl_plls[] = {
 	/* for linear 30fps */
 	{0, 26987750, 197977500},
@@ -24,7 +43,7 @@ static struct vin_video_format mn34210pl_formats[] = {
 	{
 		.video_mode	= AMBA_VIDEO_MODE_1296_1032,
 		.def_start_x	= 4,
-		.def_start_y	= 18,
+		.def_start_y	= 2+11+5,
 		.def_width	= 1296,
 		.def_height	= 1032,
 		/* sensor mode */
@@ -46,7 +65,7 @@ static struct vin_video_format mn34210pl_formats[] = {
 	{
 		.video_mode	= AMBA_VIDEO_MODE_720P,
 		.def_start_x	= 4,
-		.def_start_y	= 18,
+		.def_start_y	= 2+11+5,
 		.def_width	= 1280,
 		.def_height	= 720,
 		/* sensor mode */
@@ -69,9 +88,9 @@ static struct vin_video_format mn34210pl_formats[] = {
 	{
 		.video_mode	= AMBA_VIDEO_MODE_720P,
 		.def_start_x	= 4,
-		.def_start_y	= 1,
-		.def_width	= 1296,
-		.def_height	= 3000 - 6,
+		.def_start_y	= (2+11+5)*2+(1032-728),
+		.def_width	= 1280,
+		.def_height	= 3000 - (2+11+5)*2, /* VMAX*2 - def_start_y*2 */
 		.act_start_x	= 0,
 		.act_start_y	= 0,
 		.act_width	= 1280,
@@ -98,9 +117,9 @@ static struct vin_video_format mn34210pl_formats[] = {
 	{
 		.video_mode	= AMBA_VIDEO_MODE_720P,
 		.def_start_x	= 4,
-		.def_start_y	= 2,
-		.def_width	= 1296,
-		.def_height	= 4500 - 3,
+		.def_start_y	= (2+11+5)*3+(1032-728)/2*3,
+		.def_width	= 1280,
+		.def_height	= 4500 - (2+11+5)*3, /* VMAX*3 - def_start_y*3 */
 		.act_start_x	= 0,
 		.act_start_y	= 0,
 		.act_width	= 1280,
@@ -127,9 +146,9 @@ static struct vin_video_format mn34210pl_formats[] = {
 	{
 		.video_mode	= AMBA_VIDEO_MODE_720P,
 		.def_start_x	= 4,
-		.def_start_y	= 3,
-		.def_width	= 1296,
-		.def_height	= 4500 - 8,
+		.def_start_y	= (2+11+5)*4+(1032-728)/2*4,
+		.def_width	= 1280,
+		.def_height	= 4500 - (2+11+5)*4, /* VMAX*4 - def_start_y*4 */
 		.act_start_x	= 0,
 		.act_start_y	= 0,
 		.act_width	= 1280,
diff --git a/drivers/vin/sensors/panasonic_mn34220pl/Kbuild b/drivers/vin/sensors/panasonic_mn34220pl/Kbuild
index 0b0ae6f..336e8ba 100644
--- a/drivers/vin/sensors/panasonic_mn34220pl/Kbuild
+++ b/drivers/vin/sensors/panasonic_mn34220pl/Kbuild
@@ -4,15 +4,30 @@
 ## History:
 ##    2012/12/24 - [Long Zhao] Create
 ##
-## Copyright (C) 2004-2012, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
-## This file is produced by perl.
-##/
 
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/panasonic_mn34220pl/make.inc b/drivers/vin/sensors/panasonic_mn34220pl/make.inc
index 37c5a9d..67f4eab 100644
--- a/drivers/vin/sensors/panasonic_mn34220pl/make.inc
+++ b/drivers/vin/sensors/panasonic_mn34220pl/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/04 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_MN34220PL), y)
diff --git a/drivers/vin/sensors/panasonic_mn34220pl/mn34220pl.c b/drivers/vin/sensors/panasonic_mn34220pl/mn34220pl.c
index e932d43..6aef4a7 100644
--- a/drivers/vin/sensors/panasonic_mn34220pl/mn34220pl.c
+++ b/drivers/vin/sensors/panasonic_mn34220pl/mn34220pl.c
@@ -4,15 +4,32 @@
  * History:
  *    2013/06/08 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2013, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
@@ -23,17 +40,12 @@
 #include <iav_utils.h>
 #include <vin_api.h>
 #include "mn34220pl.h"
+#include "mn34220pl_table.c"
 
 static int bus_addr = (0 << 16) | (0x6C >> 1);
 module_param(bus_addr, int, 0644);
 MODULE_PARM_DESC(bus_addr, " bus and addr: bit16~bit31: bus, bit0~bit15: addr");
 
-static int hdr_mode = 0;
-module_param(hdr_mode, int, 0644);
-MODULE_PARM_DESC(hdr_mode, "Set HDR mode 0:linear 1:2x HDR 2:3x HDR 3:4x HDR");
-
-#define GAIN_160_STEPS (1)
-
 struct mn34220pl_priv {
 	void *control_data;
 	struct vindev_wdr_gp_s wdr_again_gp;
@@ -41,11 +53,10 @@ struct mn34220pl_priv {
 	struct vindev_wdr_gp_s wdr_shutter_gp;
 	u32 line_length;
 	u32 frame_length_lines;
+	u32 ori_line_length;
 };
 
-#include "mn34220pl_table.c"
-
-static int mn34220pl_write_reg( struct vin_device *vdev, u32 subaddr, u32 data)
+static int mn34220pl_write_reg(struct vin_device *vdev, u32 subaddr, u32 data)
 {
 	int rval;
 	struct mn34220pl_priv *mn34220pl;
@@ -74,7 +85,37 @@ static int mn34220pl_write_reg( struct vin_device *vdev, u32 subaddr, u32 data)
 	return 0;
 }
 
-static int mn34220pl_read_reg( struct vin_device *vdev, u32 subaddr, u32 *data)
+static int mn34220pl_write_reg2(struct vin_device *vdev, u32 subaddr, u32 data)
+{
+	int rval;
+	struct mn34220pl_priv *mn34220pl;
+	struct i2c_client *client;
+	struct i2c_msg msgs[1];
+	u8 pbuf[4];
+
+	mn34220pl = (struct mn34220pl_priv *)vdev->priv;
+	client = mn34220pl->control_data;
+
+	pbuf[0] = (subaddr & 0xff00) >> 8;
+	pbuf[1] = subaddr & 0xff;
+	pbuf[2] = data >> 8;
+	pbuf[3] = data & 0xff;
+
+	msgs[0].len = 4;
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].buf = pbuf;
+
+	rval = i2c_transfer(client->adapter, msgs, 1);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x:0x%x]\n", rval, subaddr, data);
+		return rval;
+	}
+
+	return 0;
+}
+
+static int mn34220pl_read_reg(struct vin_device *vdev, u32 subaddr, u32 *data)
 {
 	int rval = 0;
 	struct mn34220pl_priv *mn34220pl;
@@ -86,7 +127,7 @@ static int mn34220pl_read_reg( struct vin_device *vdev, u32 subaddr, u32 *data)
 	mn34220pl = (struct mn34220pl_priv *)vdev->priv;
 	client = mn34220pl->control_data;
 
-	pbuf0[0] = (subaddr &0xff00) >> 8;
+	pbuf0[0] = (subaddr & 0xff00) >> 8;
 	pbuf0[1] = subaddr & 0xff;
 
 	msgs[0].len = 2;
@@ -100,7 +141,7 @@ static int mn34220pl_read_reg( struct vin_device *vdev, u32 subaddr, u32 *data)
 	msgs[1].len = 1;
 
 	rval = i2c_transfer(client->adapter, msgs, 2);
-	if (rval < 0){
+	if (rval < 0) {
 		vin_error("failed(%d): [0x%x]\n", rval, subaddr);
 		return rval;
 	}
@@ -114,7 +155,7 @@ static int mn34220pl_set_vin_mode(struct vin_device *vdev, struct vin_video_form
 {
 	struct vin_device_config mn34220pl_config;
 
-	memset(&mn34220pl_config, 0, sizeof (mn34220pl_config));
+	memset(&mn34220pl_config, 0, sizeof(mn34220pl_config));
 
 	mn34220pl_config.interface_type = SENSOR_SERIAL_LVDS;
 	mn34220pl_config.sync_mode = SENSOR_SYNC_MODE_MASTER;
@@ -126,7 +167,7 @@ static int mn34220pl_set_vin_mode(struct vin_device *vdev, struct vin_video_form
 		mn34220pl_config.slvds_cfg.lane_number = SENSOR_6_LANE;
 	}
 
-	if(format->hdr_mode == AMBA_VIDEO_LINEAR_MODE) {
+	if (format->hdr_mode == AMBA_VIDEO_LINEAR_MODE) {
 		mn34220pl_config.slvds_cfg.sync_code_style = SENSOR_SYNC_STYLE_SONY;
 	} else {
 		mn34220pl_config.slvds_cfg.sync_code_style = SENSOR_SYNC_STYLE_PANASONIC;
@@ -142,8 +183,6 @@ static int mn34220pl_set_vin_mode(struct vin_device *vdev, struct vin_video_form
 	mn34220pl_config.hdr_cfg.act_win.y = format->act_start_y;
 	mn34220pl_config.hdr_cfg.act_win.width = format->act_width;
 	mn34220pl_config.hdr_cfg.act_win.height = format->act_height;
-	mn34220pl_config.hdr_cfg.act_win.max_width = format->max_act_width;
-	mn34220pl_config.hdr_cfg.act_win.max_height = format->max_act_height;
 
 	mn34220pl_config.sensor_id	= GENERIC_SENSOR;
 	mn34220pl_config.input_format	= AMBA_VIN_INPUT_FORMAT_RGB_RAW;
@@ -156,7 +195,7 @@ static int mn34220pl_set_vin_mode(struct vin_device *vdev, struct vin_video_form
 
 static void mn34220pl_sw_reset(struct vin_device *vdev)
 {
-	mn34220pl_write_reg(vdev, 0x3001, 0x0000);
+	mn34220pl_write_reg(vdev, MN34220PL_RESET, 0x00);
 }
 
 static int mn34220pl_init_device(struct vin_device *vdev)
@@ -171,16 +210,17 @@ static int mn34220pl_update_hv_info(struct vin_device *vdev)
 	u32 val_high, val_low;
 	struct mn34220pl_priv *pinfo = (struct mn34220pl_priv *)vdev->priv;
 
-	mn34220pl_read_reg(vdev, 0x0343, &val_low);	/* HCYCLE_LSB */
-	mn34220pl_read_reg(vdev, 0x0342, &val_high);	/* HCYCLE_MSB */
+	mn34220pl_read_reg(vdev, MN34220PL_HCYCLE_L, &val_low); /* HCYCLE_LSB */
+	mn34220pl_read_reg(vdev, MN34220PL_HCYCLE_H, &val_high);/* HCYCLE_MSB */
 	pinfo->line_length = (val_high << 8) + val_low;
-	if(unlikely(!pinfo->line_length)) {
+	pinfo->ori_line_length = pinfo->line_length;
+	if (unlikely(!pinfo->line_length)) {
 		vin_error("line length is 0!\n");
 		return -EIO;
 	}
 
-	mn34220pl_read_reg(vdev, 0x0341, &val_low);/* VCYCLE_LSB */
-	mn34220pl_read_reg(vdev, 0x0340, &val_high);/* VCYCLE_MSB */
+	mn34220pl_read_reg(vdev, MN34220PL_VCYCLE_L, &val_low); /* VCYCLE_LSB */
+	mn34220pl_read_reg(vdev, MN34220PL_VCYCLE_H, &val_high);/* VCYCLE_MSB */
 	pinfo->frame_length_lines = (val_high << 8) + val_low;
 
 	return 0;
@@ -201,7 +241,7 @@ static int mn34220pl_get_line_time(struct vin_device *vdev)
 
 static int mn34220pl_set_format(struct vin_device *vdev, struct vin_video_format *format)
 {
-	struct vin_reg_16_16 *regs;
+	struct vin_reg_16_8 *regs;
 	int i, regs_num;
 	int rval;
 
@@ -224,8 +264,8 @@ static int mn34220pl_set_format(struct vin_device *vdev, struct vin_video_format
 	default:
 		regs = NULL;
 		regs_num = 0;
-		vin_info("Unknown mode\n");
-		break;
+		vin_error("Unknown mode\n");
+		return -EPERM;
 	}
 
 	for (i = 0; i < regs_num; i++)
@@ -243,14 +283,26 @@ static int mn34220pl_set_format(struct vin_device *vdev, struct vin_video_format
 static int mn34220pl_set_fps(struct vin_device *vdev, int fps)
 {
 	u64	v_lines, vb_time;
+	u32 factor;
 	struct mn34220pl_priv *pinfo = (struct mn34220pl_priv *)vdev->priv;
 
 	v_lines = fps * (u64)vdev->cur_pll->pixelclk;
-	v_lines = DIV64_CLOSEST(v_lines, pinfo->line_length);
+	v_lines = DIV64_CLOSEST(v_lines, pinfo->ori_line_length);
 	v_lines = DIV64_CLOSEST(v_lines, 512000000);
 
-	mn34220pl_write_reg(vdev, 0x0340, (u8)(v_lines >> 8));
-	mn34220pl_write_reg(vdev, 0x0341, (u8)v_lines);
+	/* workaround for 1fps case */
+	if (v_lines > 0xFFFF) {
+		vin_debug("h_clks:%d, v_lines:%lld\n", pinfo->ori_line_length, v_lines);
+
+		factor = ((u32)v_lines) / 0xFFFF + 1;
+		v_lines = DIV64_CLOSEST(v_lines, factor);
+		pinfo->line_length = pinfo->ori_line_length * factor;
+		mn34220pl_write_reg2(vdev, MN34220PL_HCYCLE_H, pinfo->line_length);
+	} else if (pinfo->line_length != pinfo->ori_line_length) {
+		pinfo->line_length = pinfo->ori_line_length;
+		mn34220pl_write_reg2(vdev, MN34220PL_HCYCLE_H, pinfo->line_length);
+	}
+	mn34220pl_write_reg2(vdev, MN34220PL_VCYCLE_H, v_lines&0xFFFF);
 
 	pinfo->frame_length_lines = (u32)v_lines;
 
@@ -275,20 +327,10 @@ static int mn34220pl_set_agc_index(struct vin_device *vdev, int agc_idx)
 
 	agc_idx = MN34220PL_GAIN_0DB - agc_idx;
 
-	mn34220pl_write_reg(vdev, 0x0204, (MN34220PL_GAIN_TABLE[agc_idx][MN34220PL_GAIN_COL_AGAIN] >> 8) & 0x3);
-	mn34220pl_write_reg(vdev, 0x0205, (u8)MN34220PL_GAIN_TABLE[agc_idx][MN34220PL_GAIN_COL_AGAIN]);
-	/* DGAIN-Gr */
-	mn34220pl_write_reg(vdev, 0x020E, (MN34220PL_GAIN_TABLE[agc_idx][MN34220PL_GAIN_COL_DGAIN] >> 8) & 0x3);
-	mn34220pl_write_reg(vdev, 0x020F, (u8)MN34220PL_GAIN_TABLE[agc_idx][MN34220PL_GAIN_COL_DGAIN]);
-	/* DGAIN-R */
-	mn34220pl_write_reg(vdev, 0x0210, (MN34220PL_GAIN_TABLE[agc_idx][MN34220PL_GAIN_COL_DGAIN] >> 8) & 0x3);
-	mn34220pl_write_reg(vdev, 0x0211, (u8)MN34220PL_GAIN_TABLE[agc_idx][MN34220PL_GAIN_COL_DGAIN]);
-	/* DGAIN-B */
-	mn34220pl_write_reg(vdev, 0x0212, (MN34220PL_GAIN_TABLE[agc_idx][MN34220PL_GAIN_COL_DGAIN] >> 8) & 0x3);
-	mn34220pl_write_reg(vdev, 0x0213, (u8)MN34220PL_GAIN_TABLE[agc_idx][MN34220PL_GAIN_COL_DGAIN]);
-	/* DGAIN-Gb */
-	mn34220pl_write_reg(vdev, 0x0214, (MN34220PL_GAIN_TABLE[agc_idx][MN34220PL_GAIN_COL_DGAIN] >> 8) & 0x3);
-	mn34220pl_write_reg(vdev, 0x0215, (u8)MN34220PL_GAIN_TABLE[agc_idx][MN34220PL_GAIN_COL_DGAIN]);
+	/* AGAIN */
+	mn34220pl_write_reg2(vdev, MN34220PL_AGAIN_H, MN34220PL_GAIN_TABLE[agc_idx][MN34220PL_GAIN_COL_AGAIN] & 0x3FFF);
+	/* DGAIN */
+	mn34220pl_write_reg2(vdev, MN34220PL_DGAIN_H, MN34220PL_GAIN_TABLE[agc_idx][MN34220PL_GAIN_COL_DGAIN] & 0x3FFF);
 
 	return 0;
 }
@@ -319,10 +361,10 @@ static int mn34220pl_set_mirror_mode(struct vin_device *vdev,
 		return -EINVAL;
 	}
 
-	mn34220pl_read_reg(vdev, 0x0101, &tmp_reg);
+	mn34220pl_read_reg(vdev, MN34220PL_MODE, &tmp_reg);
 	tmp_reg &= (~MN34220PL_V_FLIP);
 	tmp_reg |= readmode;
-	mn34220pl_write_reg(vdev, 0x0101, tmp_reg);
+	mn34220pl_write_reg(vdev, MN34220PL_MODE, tmp_reg);
 
 	if (mirror_mode->bayer_pattern == VINDEV_BAYER_PATTERN_AUTO)
 		mirror_mode->bayer_pattern = bayer_pattern;
@@ -354,63 +396,63 @@ static int mn34220pl_set_wdr_shutter_row_group(struct vin_device *vdev,
 	shutter_short3 = p_shutter_gp->s3;
 
 	/* shutter limitation check */
-	switch(vdev->cur_format->hdr_mode){
-		case AMBA_VIDEO_2X_HDR_MODE:
-			if(shutter_long + shutter_short1 + 5 > pinfo->frame_length_lines){
-				vin_error("shutter exceeds limitation! long:%d, short:%d, V:%d\n",
-					shutter_long, shutter_short1, pinfo->frame_length_lines);
-				return -EPERM;
-			}else if(shutter_short1 + 2 > pinfo->frame_length_lines - active_lines) {
-				vin_error("short frame offset exceeds limitation! short:%d, VB:%d\n",
-					shutter_short1, pinfo->frame_length_lines - active_lines);
-			}
-			break;
-		case AMBA_VIDEO_3X_HDR_MODE:
-			if(shutter_long + shutter_short1 + shutter_short2 + 7 > pinfo->frame_length_lines){
-				vin_error("shutter exceeds limitation! long:%d, short1:%d, short2:%d, V:%d\n",
-					shutter_long, shutter_short1, shutter_short2, pinfo->frame_length_lines);
-				return -EPERM;
-			}else if(shutter_short1 + shutter_short2 + 4 > pinfo->frame_length_lines - active_lines) {
-				vin_error("short frame offset exceeds limitation! short1:%d, short2:%d, VB:%d\n",
-					shutter_short1, shutter_short2, pinfo->frame_length_lines - active_lines);
-			}
-			break;
-		case AMBA_VIDEO_4X_HDR_MODE:
-			if(shutter_long + shutter_short1 + shutter_short2 + 9 > pinfo->frame_length_lines){
-				vin_error("shutter exceeds limitation! long:%d, short1:%d, short2:%d, short3:%d, V:%d\n",
-					shutter_long, shutter_short1, shutter_short2, shutter_short3, pinfo->frame_length_lines);
-				return -EPERM;
-			}else if(shutter_short1 + shutter_short2 + shutter_short3 + 6 > pinfo->frame_length_lines - active_lines) {
-				vin_error("short frame offset exceeds limitation! short1:%d, short2:%d, short3:%d, VB:%d\n",
-					shutter_short1, shutter_short2, shutter_short3, pinfo->frame_length_lines - active_lines);
-			}
-			break;
-		case AMBA_VIDEO_LINEAR_MODE:
-		default:
-			vin_error("Unsupported mode\n");
+	switch (vdev->cur_format->hdr_mode) {
+	case AMBA_VIDEO_2X_HDR_MODE:
+		if (shutter_long + shutter_short1 + 5 > pinfo->frame_length_lines) {
+			vin_error("shutter exceeds limitation! long:%d, short:%d, V:%d\n",
+				shutter_long, shutter_short1, pinfo->frame_length_lines);
+			return -EPERM;
+		} else if (shutter_short1 + 2 > pinfo->frame_length_lines - active_lines) {
+			vin_error("short frame offset exceeds limitation! short:%d, VB:%d\n",
+				shutter_short1, pinfo->frame_length_lines - active_lines);
+			return -EPERM;
+		}
+		break;
+	case AMBA_VIDEO_3X_HDR_MODE:
+		if (shutter_long + shutter_short1 + shutter_short2 + 7 > pinfo->frame_length_lines) {
+			vin_error("shutter exceeds limitation! long:%d, short1:%d, short2:%d, V:%d\n",
+				shutter_long, shutter_short1, shutter_short2, pinfo->frame_length_lines);
+			return -EPERM;
+		} else if (shutter_short1 + shutter_short2 + 4 > pinfo->frame_length_lines - active_lines) {
+			vin_error("short frame offset exceeds limitation! short1:%d, short2:%d, VB:%d\n",
+				shutter_short1, shutter_short2, pinfo->frame_length_lines - active_lines);
+			return -EPERM;
+		}
+		break;
+	case AMBA_VIDEO_4X_HDR_MODE:
+		if (shutter_long + shutter_short1 + shutter_short2 + 9 > pinfo->frame_length_lines) {
+			vin_error("shutter exceeds limitation! long:%d, short1:%d, short2:%d, short3:%d, V:%d\n",
+				shutter_long, shutter_short1, shutter_short2, shutter_short3, pinfo->frame_length_lines);
+			return -EPERM;
+		} else if (shutter_short1 + shutter_short2 + shutter_short3 + 6 > pinfo->frame_length_lines - active_lines) {
+			vin_error("short frame offset exceeds limitation! short1:%d, short2:%d, short3:%d, VB:%d\n",
+				shutter_short1, shutter_short2, shutter_short3, pinfo->frame_length_lines - active_lines);
 			return -EPERM;
+		}
+		break;
+	case AMBA_VIDEO_LINEAR_MODE:
+	default:
+		vin_error("Unsupported mode\n");
+		return -EPERM;
 	}
 
 	/* long shutter */
-	mn34220pl_write_reg(vdev, 0x0203, (u8)(shutter_long & 0xFF));
-	mn34220pl_write_reg(vdev, 0x0202, (u8)(shutter_long >> 8));
-	mn34220pl_write_reg(vdev, 0x0221, (u8)((shutter_long >> 16) & 0x1));
+	mn34220pl_write_reg(vdev, MN34220PL_SHTPOS_H, (shutter_long >> 16) & 0x1);
+	mn34220pl_write_reg2(vdev, MN34220PL_SHTPOS_M, shutter_long & 0xFFFF);
 
 	/* short shutter 1 */
-	mn34220pl_write_reg(vdev, 0x312B, (u8)(shutter_short1 & 0xFF));
-	mn34220pl_write_reg(vdev, 0x312A, (u8)(shutter_short1 >> 8));
+	mn34220pl_write_reg2(vdev, MN34220PL_SHTPOS_WDR1_H, shutter_short1 & 0xFFFF);
 
 	/* short shutter 2 */
-	mn34220pl_write_reg(vdev, 0x312D, (u8)(shutter_short2 & 0xFF));
-	mn34220pl_write_reg(vdev, 0x312C, (u8)(shutter_short2 >> 8));
+	if (vdev->cur_format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE)
+		mn34220pl_write_reg2(vdev, MN34220PL_SHTPOS_WDR2_H, shutter_short2 & 0xFFFF);
 
 	/* short shutter 3 */
-	mn34220pl_write_reg(vdev, 0x312F, (u8)(shutter_short3 & 0xFF));
-	mn34220pl_write_reg(vdev, 0x312E, (u8)(shutter_short3 >> 8));
+	//mn34220pl_write_reg2(vdev, MN34220PL_SHTPOS_WDR3_H, shutter_short3 & 0xFFFF);
 
 	memcpy(&(pinfo->wdr_shutter_gp),  p_shutter_gp, sizeof(struct vindev_wdr_gp_s));
 
-	switch(vdev->cur_format->hdr_mode) {
+	switch (vdev->cur_format->hdr_mode) {
 	case AMBA_VIDEO_2X_HDR_MODE:
 		vb_time = pinfo->frame_length_lines - vdev->cur_format->height - pinfo->wdr_shutter_gp.s1;
 		break;
@@ -453,8 +495,7 @@ static int mn34220pl_set_wdr_again_idx_group(struct vin_device *vdev,
 	u32 again_index;
 
 	again_index = MN34220PL_GAIN_0DB - p_again_gp->l;
-	mn34220pl_write_reg(vdev, 0x0204, (MN34220PL_GAIN_TABLE[again_index][MN34220PL_GAIN_COL_AGAIN] >> 8) & 0x3);
-	mn34220pl_write_reg(vdev, 0x0205, (u8)MN34220PL_GAIN_TABLE[again_index][MN34220PL_GAIN_COL_AGAIN]);
+	mn34220pl_write_reg2(vdev, MN34220PL_AGAIN_H, MN34220PL_GAIN_TABLE[again_index][MN34220PL_GAIN_COL_AGAIN] & 0x3FFF);
 
 	memcpy(&(pinfo->wdr_again_gp), p_again_gp, sizeof(struct vindev_wdr_gp_s));
 
@@ -481,72 +522,9 @@ static int mn34220pl_set_wdr_dgain_idx_group(struct vin_device *vdev,
 
 	/* long frame */
 	gain_index = MN34220PL_WDR_GAIN_30DB - p_dgain_gp->l;
-	if(vdev->cur_format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {// Fix me, for 2x setting, use 0x3108 and 0x3109 as dgain
-		mn34220pl_write_reg(vdev, 0x3108, (MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN] >> 8) & 0x3);
-		mn34220pl_write_reg(vdev, 0x3109, (u8)MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN]);
-		return 0;
-	} else {
-		/* DGAIN-Gr */
-		mn34220pl_write_reg(vdev, 0x020E, (MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN] >> 8) & 0x3);
-		mn34220pl_write_reg(vdev, 0x020F, (u8)MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN]);
-		/* DGAIN-R */
-		mn34220pl_write_reg(vdev, 0x0210, (MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN] >> 8) & 0x3);
-		mn34220pl_write_reg(vdev, 0x0211, (u8)MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN]);
-		/* DGAIN-B */
-		mn34220pl_write_reg(vdev, 0x0212, (MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN] >> 8) & 0x3);
-		mn34220pl_write_reg(vdev, 0x0213, (u8)MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN]);
-		/* DGAIN-Gb */
-		mn34220pl_write_reg(vdev, 0x0214, (MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN] >> 8) & 0x3);
-		mn34220pl_write_reg(vdev, 0x0215, (u8)MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN]);
-	}
-
-	/* short frame 1 */
-	gain_index = MN34220PL_WDR_GAIN_30DB - p_dgain_gp->s1;
-	/* DGAIN-Gr */
-	mn34220pl_write_reg(vdev, 0x310A, (MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN] >> 8) & 0x3);
-	mn34220pl_write_reg(vdev, 0x310B, (u8)MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN]);
-	/* DGAIN-R */
-	mn34220pl_write_reg(vdev, 0x310C, (MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN] >> 8) & 0x3);
-	mn34220pl_write_reg(vdev, 0x310D, (u8)MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN]);
-	/* DGAIN-B */
-	mn34220pl_write_reg(vdev, 0x310E, (MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN] >> 8) & 0x3);
-	mn34220pl_write_reg(vdev, 0x310F, (u8)MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN]);
-	/* DGAIN-Gb */
-	mn34220pl_write_reg(vdev, 0x3110, (MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN] >> 8) & 0x3);
-	mn34220pl_write_reg(vdev, 0x3111, (u8)MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN]);
-
-	/* short frame 2 */
-	gain_index = MN34220PL_WDR_GAIN_30DB - p_dgain_gp->s2;
-	/* DGAIN-Gr */
-	mn34220pl_write_reg(vdev, 0x3112, (MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN] >> 8) & 0x3);
-	mn34220pl_write_reg(vdev, 0x3113, (u8)MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN]);
-	/* DGAIN-R */
-	mn34220pl_write_reg(vdev, 0x3114, (MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN] >> 8) & 0x3);
-	mn34220pl_write_reg(vdev, 0x3115, (u8)MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN]);
-	/* DGAIN-B */
-	mn34220pl_write_reg(vdev, 0x3116, (MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN] >> 8) & 0x3);
-	mn34220pl_write_reg(vdev, 0x3117, (u8)MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN]);
-	/* DGAIN-Gb */
-	mn34220pl_write_reg(vdev, 0x3118, (MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN] >> 8) & 0x3);
-	mn34220pl_write_reg(vdev, 0x3119, (u8)MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN]);
-
-	/* short frame 3 */
-	gain_index = MN34220PL_WDR_GAIN_30DB - p_dgain_gp->s3;
-	/* DGAIN-Gr */
-	mn34220pl_write_reg(vdev, 0x311A, (MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN] >> 8) & 0x3);
-	mn34220pl_write_reg(vdev, 0x311B, (u8)MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN]);
-	/* DGAIN-R */
-	mn34220pl_write_reg(vdev, 0x311C, (MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN] >> 8) & 0x3);
-	mn34220pl_write_reg(vdev, 0x311D, (u8)MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN]);
-	/* DGAIN-B */
-	mn34220pl_write_reg(vdev, 0x311E, (MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN] >> 8) & 0x3);
-	mn34220pl_write_reg(vdev, 0x311F, (u8)MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN]);
-	/* DGAIN-Gb */
-	mn34220pl_write_reg(vdev, 0x3120, (MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN] >> 8) & 0x3);
-	mn34220pl_write_reg(vdev, 0x3121, (u8)MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN]);
+	mn34220pl_write_reg2(vdev, MN34220PL_DGAIN_H, MN34220PL_GAIN_TABLE[gain_index][MN34220PL_GAIN_COL_DGAIN] & 0x3FFF);
 
 	memcpy(&(pinfo->wdr_dgain_gp), p_dgain_gp, sizeof(struct vindev_wdr_gp_s));
-
 	return 0;
 }
 
@@ -606,9 +584,8 @@ static int mn34220pl_set_shutter_row(struct vin_device *vdev, u32 row)
 	max_line = pinfo->frame_length_lines - 2;
 	num_line = clamp(num_line, min_line, max_line);
 
-	mn34220pl_write_reg(vdev, 0x0221, (num_line >> 16) & 0x01);
-	mn34220pl_write_reg(vdev, 0x0202, (num_line >> 8) & 0xFF);
-	mn34220pl_write_reg(vdev, 0x0203, num_line & 0xFF);
+	mn34220pl_write_reg(vdev, MN34220PL_SHTPOS_H, (num_line >> 16) & 0x01);
+	mn34220pl_write_reg2(vdev, MN34220PL_SHTPOS_M, num_line & 0xFFFF);
 
 	exposure_lines = num_line;
 	exposure_lines = exposure_lines * (u64)pinfo->line_length * 512000000;
@@ -620,13 +597,13 @@ static int mn34220pl_set_shutter_row(struct vin_device *vdev, u32 row)
 	return 0;
 }
 
-static int mn34220pl_shutter2row(struct vin_device *vdev, u32* shutter_time)
+static int mn34220pl_shutter2row(struct vin_device *vdev, u32 *shutter_time)
 {
 	u64 exposure_lines;
 	int rval = 0;
 	struct mn34220pl_priv *pinfo = (struct mn34220pl_priv *)vdev->priv;
 
-	if(unlikely(!pinfo->line_length)) {
+	if (unlikely(!pinfo->line_length)) {
 		rval = mn34220pl_update_hv_info(vdev);
 		if (rval < 0)
 			return rval;
@@ -641,16 +618,58 @@ static int mn34220pl_shutter2row(struct vin_device *vdev, u32* shutter_time)
 	return rval;
 }
 
+static int mn34220pl_get_aaa_info(struct vin_device *vdev,
+	struct vindev_aaa_info *aaa_info)
+{
+	struct mn34220pl_priv *pinfo = (struct mn34220pl_priv *)vdev->priv;
+
+	aaa_info->sht0_max = pinfo->frame_length_lines - 7;
+	aaa_info->sht1_max = pinfo->frame_length_lines - vdev->cur_format->height - 2;
+	aaa_info->sht2_max = (vdev->cur_format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE) ?
+		(aaa_info->sht1_max - 2) : 0;
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int mn34220pl_suspend(struct vin_device *vdev)
+{
+	u32 i, tmp;
+
+	for (i = 0; i < ARRAY_SIZE(pm_regs); i++) {
+		mn34220pl_read_reg(vdev, pm_regs[i].addr, &tmp);
+		pm_regs[i].data = (u8)tmp;
+	}
+
+	return 0;
+}
+
+static int mn34220pl_resume(struct vin_device *vdev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(pm_regs); i++)
+		mn34220pl_write_reg(vdev, pm_regs[i].addr, pm_regs[i].data);
+
+	return 0;
+}
+#endif
+
 static struct vin_ops mn34220pl_ops = {
 	.init_device		= mn34220pl_init_device,
 	.set_format		= mn34220pl_set_format,
-	.set_shutter_row = mn34220pl_set_shutter_row,
-	.shutter2row = mn34220pl_shutter2row,
+	.set_shutter_row	= mn34220pl_set_shutter_row,
+	.shutter2row		= mn34220pl_shutter2row,
 	.set_frame_rate		= mn34220pl_set_fps,
 	.set_agc_index		= mn34220pl_set_agc_index,
 	.set_mirror_mode	= mn34220pl_set_mirror_mode,
+	.get_aaa_info		= mn34220pl_get_aaa_info,
 	.read_reg		= mn34220pl_read_reg,
 	.write_reg		= mn34220pl_write_reg,
+#ifdef CONFIG_PM
+	.suspend		= mn34220pl_suspend,
+	.resume			= mn34220pl_resume,
+#endif
 
 	/* for wdr sensor */
 	.set_wdr_again_idx_gp = mn34220pl_set_wdr_again_idx_group,
@@ -662,7 +681,6 @@ static struct vin_ops mn34220pl_ops = {
 	.wdr_shutter2row = mn34220pl_wdr_shutter2row,
 };
 
-/*	< include init.c here for aptina sensor, which is produce by perl >  */
 /* ========================================================================== */
 static int mn34220pl_probe(struct i2c_client *client,
 	const struct i2c_device_id *id)
@@ -681,14 +699,14 @@ static int mn34220pl_probe(struct i2c_client *client,
 	vdev->sub_type = VINDEV_SUBTYPE_CMOS;
 	vdev->default_mode = AMBA_VIDEO_MODE_1080P;
 	vdev->default_hdr_mode = AMBA_VIDEO_LINEAR_MODE;
-	vdev->agc_db_max = 0x3C000000;	// 60dB
-	vdev->agc_db_min = 0x00000000;	// 0dB
+	vdev->agc_db_max = 0x3C000000; /* 60dB */
+	vdev->agc_db_min = 0x00000000; /* 0dB */
 #if GAIN_160_STEPS
-	vdev->agc_db_step = 0x00600000;	// 0.375dB
+	vdev->agc_db_step = 0x00600000;/* 0.375dB */
 #else
-	vdev->agc_db_step = 0x00180000;	// 0.09375dB
+	vdev->agc_db_step = 0x00180000;/* 0.09375dB */
 #endif
-	vdev->pixel_size = 0x0002C000;	/* 2.75um */
+	vdev->pixel_size = 0x0002C000; /* 2.75um */
 
 	vdev->wdr_again_idx_min = 0;
 	vdev->wdr_again_idx_max = MN34220PL_WDR_GAIN_30DB;
diff --git a/drivers/vin/sensors/panasonic_mn34220pl/mn34220pl.h b/drivers/vin/sensors/panasonic_mn34220pl/mn34220pl.h
index 81c17f3..ef4fbc5 100644
--- a/drivers/vin/sensors/panasonic_mn34220pl/mn34220pl.h
+++ b/drivers/vin/sensors/panasonic_mn34220pl/mn34220pl.h
@@ -1,26 +1,65 @@
 /*
- * Filename : mn34220pl_pri.h
+ * Filename : mn34220pl.h
  *
  * History:
  *    2013/06/08 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2013, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * This file is produced by perl.
  */
-#ifndef __MN34220PL_PRI_H__
-#define __MN34220PL_PRI_H__
 
-#define MN34220PL_VIDEO_FORMAT_REG_NUM			(0)
-#define MN34220PL_VIDEO_FORMAT_REG_TABLE_SIZE	(4)
-#define MN34220PL_VIDEO_PLL_REG_TABLE_SIZE		(0)
+#ifndef __MN34220PL_H__
+#define __MN34220PL_H__
+
+#define GAIN_160_STEPS (1)
+
+#define MN34220PL_RESET		0x3001
+
+#define MN34220PL_VCYCLE_H	0x0340
+#define MN34220PL_VCYCLE_L	0x0341
+#define MN34220PL_HCYCLE_H	0x0342
+#define MN34220PL_HCYCLE_L	0x0343
+
+#define MN34220PL_AGAIN_H	0x0204
+#define MN34220PL_AGAIN_L	0x0205
+#define MN34220PL_DGAIN_H	0x3108
+#define MN34220PL_DGAIN_L	0x3109
+
+#define MN34220PL_SHTPOS_H	0x0221
+#define MN34220PL_SHTPOS_M	0x0202
+#define MN34220PL_SHTPOS_L	0x0203
+
+#define MN34220PL_SHTPOS_WDR1_H	0x312A
+#define MN34220PL_SHTPOS_WDR1_L	0x312B
+#define MN34220PL_SHTPOS_WDR2_H	0x312C
+#define MN34220PL_SHTPOS_WDR2_L	0x312D
+#define MN34220PL_SHTPOS_WDR3_H	0x312E
+#define MN34220PL_SHTPOS_WDR3_L	0x312F
 
+#define MN34220PL_MODE	0x0101
 #define MN34220PL_V_FLIP (1<<1)
 
-#endif /* __MN34220PL_PRI_H__ */
+#endif /* __MN34220PL_H__ */
 
diff --git a/drivers/vin/sensors/panasonic_mn34220pl/mn34220pl_table.c b/drivers/vin/sensors/panasonic_mn34220pl/mn34220pl_table.c
index fc3b2ff..52ad9ae 100644
--- a/drivers/vin/sensors/panasonic_mn34220pl/mn34220pl_table.c
+++ b/drivers/vin/sensors/panasonic_mn34220pl/mn34220pl_table.c
@@ -1,20 +1,37 @@
 /*
- * Filename : mn34220pl_reg_tbl.c
+ * Filename : mn34220pl_table.c
  *
  * History:
  *	2013/06/08 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2013, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
 static struct vin_video_pll mn34220pl_plls[] = {
-	{0, 27005367, 198000000},// for linear, 2x wdr mode
+	{0, 27000000, 198000000},// for linear, 2x wdr mode
 	{0, 27000000, 297000000},// for 3x, 4x wdr, 120fps mode
 };
 
@@ -67,21 +84,19 @@ static struct vin_video_format mn34220pl_formats[] = {
 	{
 		.video_mode	= AMBA_VIDEO_MODE_1080P,
 		.def_start_x	= 4,
-		.def_start_y	= 0,
+		.def_start_y	= (2+10+4)*2,
 		.def_width	= 1920,
-		.def_height	= 3000 - 20,
+		.def_height	= 3000 - (2+10+4)*2, /* VMAX*2 - def_start_y*2 */
 		.act_start_x	= 0,
 		.act_start_y	= 0,
 		.act_width	= 1920,
 		.act_height	= 1080,
-		.max_act_width = 1920,
-		.max_act_height = 1080,
 		/* sensor mode */
 		.hdr_mode = AMBA_VIDEO_2X_HDR_MODE,
 		.device_mode	= 0,
 		.pll_idx	= 0,
 		.width		= 1956,
-		.height		= 1228,
+		.height		= 1108,
 		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
 		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
 		.bits		= AMBA_VIDEO_BITS_12,
@@ -96,21 +111,19 @@ static struct vin_video_format mn34220pl_formats[] = {
 	{
 		.video_mode	= AMBA_VIDEO_MODE_1080P,
 		.def_start_x	= 4,
-		.def_start_y	= 0,
+		.def_start_y	= (2+10+4)*3,
 		.def_width	= 1920,
-		.def_height	= 4500 - 30,
+		.def_height	= 4500 - (2+10+4)*3, /* VMAX*3 - def_start_y*3 */
 		.act_start_x	= 0,
 		.act_start_y	= 0,
 		.act_width	= 1920,
 		.act_height	= 1080,
-		.max_act_width = 1920,
-		.max_act_height = 1080,
 		/* sensor mode */
 		.hdr_mode = AMBA_VIDEO_3X_HDR_MODE,
 		.device_mode	= 0,
 		.pll_idx	= 1,
 		.width		= 1956,
-		.height		= 1092,
+		.height		= 1108,
 		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
 		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
 		.bits		= AMBA_VIDEO_BITS_12,
@@ -123,317 +136,333 @@ static struct vin_video_format mn34220pl_formats[] = {
 	},
 };
 
-static struct vin_reg_16_16 mn34220pl_linear_mode_regs[] = {
+static struct vin_reg_16_8 mn34220pl_linear_mode_regs[] = {
 	/* N002_S12_P4_WUXGA_V1250_12b_594MHz_60fps_vM17e_141006_Mst_I2C_d_Amb.txt */
 	/* VCYCLE:1250 HCYCLE:360 (@MCLK) */
-	{0x300E, 0x0001},
-	{0x300F, 0x0000},
-	{0x3000, 0x0000},
-	{0x3001, 0x0003},
-	{0x0112, 0x000C},
-	{0x0113, 0x000C},
-	{0x300B, 0x0000},// master mode
-	{0x3018, 0x0043},
-	{0x3019, 0x0010},
-	{0x301A, 0x00B9},
-	{0x3000, 0x0000},
-	{0x3001, 0x0053},
-	{0x300E, 0x0000},
-	{0x300F, 0x0000},
-	{0x0202, 0x0004},
-	{0x0203, 0x00E0},
-	{0x0340, 0x0004},
-	{0x0341, 0x00E2},
-	{0x0342, 0x000A},
-	{0x0343, 0x0050},
-	{0x0347, 0x0000},
-	{0x034B, 0x00BB},
-	{0x034F, 0x00BC},
-	{0x3036, 0x0000},
-	{0x3039, 0x002E},
-	{0x3058, 0x000F},
-	{0x305D, 0x0040},
-	{0x3066, 0x000A},
-	{0x3067, 0x00B0},
-	{0x3068, 0x0008},
-	{0x3069, 0x0000},
-	{0x306A, 0x000B},
-	{0x306B, 0x0060},
-	{0x306C, 0x0009},
-	{0x306D, 0x00D0},
-	{0x306E, 0x000C},
-	{0x306F, 0x0000},
-	{0x3074, 0x0001},
-	{0x3098, 0x0000},
-	{0x3099, 0x0000},
-	{0x309A, 0x0001},
-	{0x3104, 0x0004},
-	{0x3106, 0x0000},
-	{0x3107, 0x00C0},
-	{0x3141, 0x0040},
-	{0x3153, 0x00E3},
-	{0x316F, 0x00C6},
-	{0x3175, 0x0080},
-	{0x318E, 0x0020},
-	{0x318F, 0x0070},
-	{0x3196, 0x0008},
-	{0x3247, 0x00D6},
-	{0x324A, 0x0030},
-	{0x324B, 0x0018},
-	{0x324C, 0x0002},
-	{0x3259, 0x00E6},
-	{0x3272, 0x0055},
-	{0x3280, 0x0030},
-	{0x3288, 0x0001},
-	{0x330E, 0x0005},
-	{0x3310, 0x0002},
-	{0x3315, 0x001F},
-	{0x332C, 0x0002},
-	{0x3339, 0x0002},
-	{0x3000, 0x0000},
-	{0x3001, 0x00D3},
-	{0x0100, 0x0001},
-	{0x0101, 0x0000},
+	{0x300E, 0x01},
+	{0x300F, 0x00},
+	{0x3000, 0x00},
+	{0x3001, 0x03},
+	{0x0112, 0x0C},
+	{0x0113, 0x0C},
+	{0x300B, 0x00},/* master mode */
+	{0x3018, 0x43},
+	{0x3019, 0x10},
+	{0x301A, 0xB9},
+	{0x3000, 0x00},
+	{0x3001, 0x53},
+	{0x300E, 0x00},
+	{0x300F, 0x00},
+	{0x0202, 0x04},
+	{0x0203, 0xE0},
+	{0x0340, 0x04},
+	{0x0341, 0xE2},
+	{0x0342, 0x0A},
+	{0x0343, 0x50},
+	{0x0347, 0x00},
+	{0x034B, 0xBB},
+	{0x034F, 0xBC},
+	{0x3036, 0x00},
+	{0x3039, 0x2E},
+	{0x3058, 0x0F},
+	{0x305D, 0x40},
+	{0x3066, 0x0A},
+	{0x3067, 0xB0},
+	{0x3068, 0x08},
+	{0x3069, 0x00},
+	{0x306A, 0x0B},
+	{0x306B, 0x60},
+	{0x306C, 0x09},
+	{0x306D, 0xD0},
+	{0x306E, 0x0C},
+	{0x306F, 0x00},
+	{0x3074, 0x01},
+	{0x3098, 0x00},
+	{0x3099, 0x00},
+	{0x309A, 0x01},
+	{0x3104, 0x04},
+	{0x3106, 0x00},
+	{0x3107, 0xC0},
+	{0x3141, 0x40},
+	{0x3153, 0xE3},
+	{0x316F, 0xC6},
+	{0x3175, 0x80},
+	{0x318E, 0x20},
+	{0x318F, 0x70},
+	{0x3196, 0x08},
+	{0x3247, 0xD6},
+	{0x324A, 0x30},
+	{0x324B, 0x18},
+	{0x324C, 0x02},
+	{0x3259, 0xE6},
+	{0x3272, 0x55},
+	{0x3280, 0x30},
+	{0x3288, 0x01},
+	{0x330E, 0x05},
+	{0x3310, 0x02},
+	{0x3315, 0x1F},
+	{0x332C, 0x02},
+	{0x3339, 0x02},
+	{0x3000, 0x00},
+	{0x3001, 0xD3},
+	{0x0100, 0x01},
+	{0x0101, 0x00},
 };
 
-static struct vin_reg_16_16 mn34220pl_2x_wdr_mode_regs[] = {
+static struct vin_reg_16_8 mn34220pl_2x_wdr_mode_regs[] = {
 	/* N147_S12_P4_FHD_WDRx2_V1500_12b_594MHz_30fps_vM17e_150602_Mst_I2C_d_Amb.txt */
 	/* VCYCLE:1500 HCYCLE:600 (@MCLK) */
-	{0x300E, 0x0001},
-	{0x300F, 0x0000},
-	{0x3000, 0x0000},
-	{0x3001, 0x0003},
-	{0x0112, 0x000C},
-	{0x0113, 0x000C},
-	{0x300B, 0x0000},// master mode
-	{0x3018, 0x0043},
-	{0x3019, 0x0010},
-	{0x301A, 0x00B9},
-	{0x3000, 0x0000},
-	{0x3001, 0x0053},
-	{0x300E, 0x0000},
-	{0x300F, 0x0000},
-	{0x0202, 0x0005},
-	{0x0203, 0x00DA},
-	{0x020F, 0x003F},
-	{0x0211, 0x003F},
-	{0x0213, 0x003F},
-	{0x0215, 0x003F},
-	{0x0340, 0x0005},
-	{0x0341, 0x00DC},
-	{0x0342, 0x0011},
-	{0x0343, 0x0030},
-	{0x3036, 0x0000},
-	{0x3039, 0x002E},
-	{0x3058, 0x000F},
-	{0x305D, 0x0042},
+	{0x300E, 0x01},
+	{0x300F, 0x00},
+	{0x3000, 0x00},
+	{0x3001, 0x03},
+	{0x0112, 0x0C},
+	{0x0113, 0x0C},
+	{0x300B, 0x00},/* master mode */
+	{0x3018, 0x43},
+	{0x3019, 0x10},
+	{0x301A, 0xB9},
+	{0x3000, 0x00},
+	{0x3001, 0x53},
+	{0x300E, 0x00},
+	{0x300F, 0x00},
+	{0x0202, 0x05},
+	{0x0203, 0xDA},
+	{0x020F, 0x3F},
+	{0x0211, 0x3F},
+	{0x0213, 0x3F},
+	{0x0215, 0x3F},
+	{0x0340, 0x05},
+	{0x0341, 0xDC},
+	{0x0342, 0x11},
+	{0x0343, 0x30},
+	{0x3036, 0x00},
+	{0x3039, 0x2E},
+	{0x3058, 0x0F},
+	{0x305D, 0x42},
 	/*
-	{0x3066, 0x000A},
-	{0x3067, 0x00B0},
-	{0x3068, 0x0008},
-	{0x3069, 0x0000},
-	{0x306A, 0x000B},
-	{0x306B, 0x0060},
-	{0x306C, 0x0009},
-	{0x306D, 0x00D0},
+	{0x3066, 0x0A},
+	{0x3067, 0xB0},
+	{0x3068, 0x08},
+	{0x3069, 0x00},
+	{0x306A, 0x0B},
+	{0x306B, 0x60},
+	{0x306C, 0x09},
+	{0x306D, 0xD0},
 	*/
-	{0x306E, 0x000A},
-	{0x306F, 0x0000},
-	{0x3074, 0x0001},
-	{0x3078, 0x0001},
-	{0x3098, 0x0004},
-	{0x3099, 0x0000},
-	{0x3101, 0x0001},
-	{0x3104, 0x0004},
-	{0x3106, 0x0000},
-	{0x3107, 0x0080},
-	{0x310B, 0x003F},
-	{0x310D, 0x003F},
-	{0x310F, 0x003F},
-	{0x3111, 0x003F},
-	{0x3113, 0x003F},
-	{0x3115, 0x003F},
-	{0x3117, 0x003F},
-	{0x3119, 0x003F},
-	{0x311B, 0x003F},
-	{0x311D, 0x003F},
-	{0x311F, 0x003F},
-	{0x3121, 0x003F},
-	{0x312B, 0x0020},
-	{0x312D, 0x0020},
-	{0x312F, 0x0020},
-	{0x3141, 0x0040},
-	{0x3153, 0x0007},
-	{0x315D, 0x005D},
-	{0x315F, 0x005F},
-	{0x3161, 0x005F},
-	{0x3163, 0x005F},
-	{0x3165, 0x005F},
-	{0x3167, 0x0059},
-	{0x3169, 0x0059},
-	{0x316B, 0x0059},
-	{0x316D, 0x0046},
-	{0x316F, 0x0043},
-	{0x3171, 0x00C6},
-	{0x3173, 0x00C6},
-	{0x3175, 0x0080},
-	{0x318E, 0x0020},
-	{0x318F, 0x0070},
-	{0x3196, 0x0008},
-	{0x323C, 0x0070},
-	{0x323E, 0x0000},
-	{0x3246, 0x0000},
-	{0x3247, 0x008C},
-	{0x324A, 0x0030},
-	{0x324B, 0x0018},
-	{0x324C, 0x0002},
-	{0x3258, 0x0000},
-	{0x3259, 0x00BC},
-	{0x3272, 0x0055},
-	{0x3280, 0x0000},
-	{0x3288, 0x0001},
-	{0x330E, 0x0005},
-	{0x3310, 0x0002},
-	{0x3315, 0x001F},
-	{0x332C, 0x0002},
-	{0x3339, 0x0002},
-	{0x3000, 0x0000},
-	{0x3001, 0x00D3},
-	{0x0100, 0x0001},
-	{0x0101, 0x0000},
+	{0x306E, 0x0A},
+	{0x306F, 0x00},
+	{0x3074, 0x01},
+	{0x3078, 0x01},
+	{0x3098, 0x04},
+	{0x3099, 0x00},
+	{0x3101, 0x01},
+	{0x3104, 0x04},
+	{0x3106, 0x00},
+	{0x3107, 0x80},
+	{0x310B, 0x3F},
+	{0x310D, 0x3F},
+	{0x310F, 0x3F},
+	{0x3111, 0x3F},
+	{0x3113, 0x3F},
+	{0x3115, 0x3F},
+	{0x3117, 0x3F},
+	{0x3119, 0x3F},
+	{0x311B, 0x3F},
+	{0x311D, 0x3F},
+	{0x311F, 0x3F},
+	{0x3121, 0x3F},
+	{0x312B, 0x20},
+	{0x312D, 0x20},
+	{0x312F, 0x20},
+	{0x3141, 0x40},
+	{0x3153, 0x07},
+	{0x315D, 0x5D},
+	{0x315F, 0x5F},
+	{0x3161, 0x5F},
+	{0x3163, 0x5F},
+	{0x3165, 0x5F},
+	{0x3167, 0x59},
+	{0x3169, 0x59},
+	{0x316B, 0x59},
+	{0x316D, 0x46},
+	{0x316F, 0x43},
+	{0x3171, 0xC6},
+	{0x3173, 0xC6},
+	{0x3175, 0x80},
+	{0x318E, 0x20},
+	{0x318F, 0x70},
+	{0x3196, 0x08},
+	{0x323C, 0x70},
+	{0x323E, 0x00},
+	{0x3246, 0x00},
+	{0x3247, 0x8C},
+	{0x324A, 0x30},
+	{0x324B, 0x18},
+	{0x324C, 0x02},
+	{0x3258, 0x00},
+	{0x3259, 0xBC},
+	{0x3272, 0x55},
+	{0x3280, 0x00},
+	{0x3288, 0x01},
+	{0x330E, 0x05},
+	{0x3310, 0x02},
+	{0x3315, 0x1F},
+	{0x332C, 0x02},
+	{0x3339, 0x02},
+	{0x3000, 0x00},
+	{0x3001, 0xD3},
+	{0x0100, 0x01},
+	{0x0101, 0x00},
 };
 
-static struct vin_reg_16_16 mn34220pl_3x_wdr_mode_regs[] = {
+static struct vin_reg_16_8 mn34220pl_3x_wdr_mode_regs[] = {
 	/* N141_S12_P6_FHD_WDRx3_V1500_10b_594MHz_30fps_vM17e_150602_Mst_I2C_d_Amb.txt */
 	/* VCYCLE:1500 HCYCLE:600 (@MCLK) */
-	{0x300E, 0x0001},
-	{0x300F, 0x0000},
-	{0x3000, 0x0000},
-	{0x3001, 0x0003},
-	{0x0112, 0x000C},
-	{0x0113, 0x000C},
-	{0x3004, 0x0004},
-	{0x3008, 0x0001},
-	{0x300B, 0x0000},// master mode
-	{0x3018, 0x0043},
-	{0x3019, 0x0010},
-	{0x301A, 0x00B9},
-	{0x3000, 0x0000},
-	{0x3001, 0x0053},
-	{0x300E, 0x0000},
-	{0x300F, 0x0000},
-	{0x0202, 0x0000},
-	{0x0203, 0x0020},
-	{0x0340, 0x0005},
-	{0x0341, 0x00DC},
-	{0x0342, 0x0019},
-	{0x0343, 0x00C8},
-	{0x3036, 0x0000},
-	{0x3039, 0x002E},
-	{0x3041, 0x0012},
-	{0x3058, 0x0003},
-	{0x305D, 0x0042},
+	{0x300E, 0x01},
+	{0x300F, 0x00},
+	{0x3000, 0x00},
+	{0x3001, 0x03},
+	{0x0112, 0x0C},
+	{0x0113, 0x0C},
+	{0x3004, 0x04},
+	{0x3008, 0x01},
+	{0x300B, 0x00},/* master mode */
+	{0x3018, 0x43},
+	{0x3019, 0x10},
+	{0x301A, 0xB9},
+	{0x3000, 0x00},
+	{0x3001, 0x53},
+	{0x300E, 0x00},
+	{0x300F, 0x00},
+	{0x0202, 0x00},
+	{0x0203, 0x20},
+	{0x0340, 0x05},
+	{0x0341, 0xDC},
+	{0x0342, 0x19},
+	{0x0343, 0xC8},
+	{0x3036, 0x00},
+	{0x3039, 0x2E},
+	{0x3041, 0x12},
+	{0x3058, 0x03},
+	{0x305D, 0x42},
 	/*
-	{0x3066, 0x000A},
-	{0x3067, 0x00B0},
-	{0x3068, 0x0008},
-	{0x3069, 0x0000},
-	{0x306A, 0x000B},
-	{0x306B, 0x0060},
-	{0x306C, 0x0009},
-	{0x306D, 0x00D0},
-	{0x306E, 0x0009},
-	{0x306F, 0x0000},
+	{0x3066, 0x0A},
+	{0x3067, 0xB0},
+	{0x3068, 0x08},
+	{0x3069, 0x00},
+	{0x306A, 0x0B},
+	{0x306B, 0x60},
+	{0x306C, 0x09},
+	{0x306D, 0xD0},
+	{0x306E, 0x09},
+	{0x306F, 0x00},
 	*/
-	{0x3074, 0x0001},
-	{0x3078, 0x0001},
-	{0x3098, 0x0004},
-	{0x3099, 0x0000},
-	{0x309A, 0x0010},
-	{0x3101, 0x0002},
-	{0x3104, 0x0004},
-	{0x3106, 0x0000},
-	{0x3107, 0x0040},
-	{0x312B, 0x0020},
-	{0x312D, 0x0020},
-	{0x312F, 0x0020},
-	{0x3141, 0x0070},
-	{0x3143, 0x0001},
-	{0x3144, 0x0003},
-	{0x3145, 0x0002},
-	{0x3147, 0x0000},
-	{0x3148, 0x0000},
-	{0x3149, 0x0000},
-	{0x314A, 0x0003},
-	{0x314B, 0x0001},
-	{0x314C, 0x0001},
-	{0x314D, 0x0001},
-	{0x314E, 0x0002},
-	{0x314F, 0x0002},
-	{0x3150, 0x0002},
-	{0x3152, 0x0001},
-	{0x3153, 0x0007},
-	{0x3155, 0x0011},
-	{0x3157, 0x0030},
-	{0x3159, 0x0033},
-	{0x315B, 0x0036},
-	{0x315D, 0x0035},
-	{0x315F, 0x003C},
-	{0x3161, 0x003F},
-	{0x3163, 0x003A},
-	{0x3165, 0x0039},
-	{0x3167, 0x0028},
-	{0x3169, 0x002B},
-	{0x316B, 0x002E},
-	{0x316D, 0x002D},
-	{0x316F, 0x0022},
-	{0x3171, 0x0022},
-	{0x3173, 0x0061},
-	{0x3175, 0x0080},
-	{0x318E, 0x0020},
-	{0x318F, 0x0070},
-	{0x3196, 0x0008},
-	{0x31FC, 0x0003},
-	{0x31FE, 0x0006},
-	{0x3201, 0x0001},
-	{0x3202, 0x0003},
-	{0x3203, 0x0035},
-	{0x323C, 0x0070},
-	{0x323E, 0x0000},
-	{0x3243, 0x0075},
-	{0x3246, 0x0000},
-	{0x3247, 0x00C9},
-	{0x324A, 0x0030},
-	{0x324B, 0x001B},
-	{0x324C, 0x0002},
-	{0x3253, 0x007B},
-	{0x3256, 0x0032},
-	{0x3258, 0x0000},
-	{0x3259, 0x005C},
-	{0x325A, 0x0014},
-	{0x3272, 0x000C},
-	{0x3280, 0x0000},
-	{0x3282, 0x0007},
-	{0x3285, 0x0019},
-	{0x3288, 0x0000},
-	{0x3289, 0x0040},
-	{0x330E, 0x0005},
-	{0x3310, 0x0002},
-	{0x3315, 0x001F},
-	{0x331A, 0x0003},
-	{0x331B, 0x0003},
-	{0x3339, 0x0003},
-	{0x336B, 0x0002},
-	{0x339F, 0x0001},
-	{0x33A2, 0x0001},
-	{0x33A3, 0x0001},
-	{0x3000, 0x0000},
-	{0x3001, 0x00D3},
-	{0x3084, 0x0020},//msb
-	{0x0100, 0x0001},
-	{0x0101, 0x0000},
+	{0x3074, 0x01},
+	{0x3078, 0x01},
+	{0x3098, 0x04},
+	{0x3099, 0x00},
+	{0x309A, 0x10},
+	{0x3101, 0x02},
+	{0x3104, 0x04},
+	{0x3106, 0x00},
+	{0x3107, 0x40},
+	{0x312B, 0x20},
+	{0x312D, 0x20},
+	{0x312F, 0x20},
+	{0x3141, 0x70},
+	{0x3143, 0x01},
+	{0x3144, 0x03},
+	{0x3145, 0x02},
+	{0x3147, 0x00},
+	{0x3148, 0x00},
+	{0x3149, 0x00},
+	{0x314A, 0x03},
+	{0x314B, 0x01},
+	{0x314C, 0x01},
+	{0x314D, 0x01},
+	{0x314E, 0x02},
+	{0x314F, 0x02},
+	{0x3150, 0x02},
+	{0x3152, 0x01},
+	{0x3153, 0x07},
+	{0x3155, 0x11},
+	{0x3157, 0x30},
+	{0x3159, 0x33},
+	{0x315B, 0x36},
+	{0x315D, 0x35},
+	{0x315F, 0x3C},
+	{0x3161, 0x3F},
+	{0x3163, 0x3A},
+	{0x3165, 0x39},
+	{0x3167, 0x28},
+	{0x3169, 0x2B},
+	{0x316B, 0x2E},
+	{0x316D, 0x2D},
+	{0x316F, 0x22},
+	{0x3171, 0x22},
+	{0x3173, 0x61},
+	{0x3175, 0x80},
+	{0x318E, 0x20},
+	{0x318F, 0x70},
+	{0x3196, 0x08},
+	{0x31FC, 0x03},
+	{0x31FE, 0x06},
+	{0x3201, 0x01},
+	{0x3202, 0x03},
+	{0x3203, 0x35},
+	{0x323C, 0x70},
+	{0x323E, 0x00},
+	{0x3243, 0x75},
+	{0x3246, 0x00},
+	{0x3247, 0xC9},
+	{0x324A, 0x30},
+	{0x324B, 0x1B},
+	{0x324C, 0x02},
+	{0x3253, 0x7B},
+	{0x3256, 0x32},
+	{0x3258, 0x00},
+	{0x3259, 0x5C},
+	{0x325A, 0x14},
+	{0x3272, 0x0C},
+	{0x3280, 0x00},
+	{0x3282, 0x07},
+	{0x3285, 0x19},
+	{0x3288, 0x00},
+	{0x3289, 0x40},
+	{0x330E, 0x05},
+	{0x3310, 0x02},
+	{0x3315, 0x1F},
+	{0x331A, 0x03},
+	{0x331B, 0x03},
+	{0x3339, 0x03},
+	{0x336B, 0x02},
+	{0x339F, 0x01},
+	{0x33A2, 0x01},
+	{0x33A3, 0x01},
+	{0x3000, 0x00},
+	{0x3001, 0xD3},
+	{0x3084, 0x20},/* msb */
+	{0x0100, 0x01},
+	{0x0101, 0x00},
 };
 
+#ifdef CONFIG_PM
+static struct vin_reg_16_8 pm_regs[] = {
+	{MN34220PL_SHTPOS_H, 0x00},
+	{MN34220PL_SHTPOS_M, 0x00},
+	{MN34220PL_SHTPOS_L, 0x00},
+	{MN34220PL_SHTPOS_WDR1_H, 0x00},
+	{MN34220PL_SHTPOS_WDR1_L, 0x00},
+	{MN34220PL_SHTPOS_WDR2_H, 0x00},
+	{MN34220PL_SHTPOS_WDR2_L, 0x00},
+	{MN34220PL_AGAIN_H, 0x00},
+	{MN34220PL_AGAIN_L, 0x00},
+	{MN34220PL_DGAIN_H, 0x00},
+	{MN34220PL_DGAIN_L, 0x00},
+};
+#endif
+
 #define MN34220PL_GAIN_COLS		(2)
 #define MN34220PL_GAIN_COL_AGAIN	(0)
 #define MN34220PL_GAIN_COL_DGAIN	(1)
@@ -445,8 +474,7 @@ static struct vin_reg_16_16 mn34220pl_3x_wdr_mode_regs[] = {
 #define MN34220PL_WDR_GAIN_30DB		(80)
 
 /* MN34220PL_GAIN_ROWS = 161, MN34220PL_GAIN_COLS = 2 */
-const s16 MN34220PL_GAIN_TABLE[MN34220PL_GAIN_ROWS][MN34220PL_GAIN_COLS] =
-{
+static const u16 MN34220PL_GAIN_TABLE[MN34220PL_GAIN_ROWS][MN34220PL_GAIN_COLS] = {
 	/* Analog Gain,Digital Gain */
 	{0x240, 0x240}, /* index 160, gain_db=60.000000 DB, again_db=30.000000 DB, dgain_db=30.000000 DB */
 	{0x240, 0x23c}, /* index 159, gain_db=59.625000 DB, again_db=30.000000 DB, dgain_db=29.625000 DB */
@@ -618,8 +646,7 @@ const s16 MN34220PL_GAIN_TABLE[MN34220PL_GAIN_ROWS][MN34220PL_GAIN_COLS] =
 #define MN34220PL_WDR_GAIN_30DB		(320)
 
 /* MN34220PL_GAIN_ROWS = 641, MN34220PL_GAIN_COLS = 2 */
-const s16 MN34220PL_GAIN_TABLE[MN34220PL_GAIN_ROWS][MN34220PL_GAIN_COLS] =
-{
+static const u16 MN34220PL_GAIN_TABLE[MN34220PL_GAIN_ROWS][MN34220PL_GAIN_COLS] = {
 	/* Analog Gain,Digital Gain */
 	{0x240, 0x240}, /* index 640, gain_db=60.000000 DB, again_db=30.000000 DB, dgain_db=30.000000 DB */
 	{0x240, 0x23f}, /* index 639, gain_db=59.906250 DB, again_db=30.000000 DB, dgain_db=29.906250 DB */
diff --git a/drivers/vin/sensors/panasonic_mn34420pl/Kbuild b/drivers/vin/sensors/panasonic_mn34420pl/Kbuild
new file mode 100644
index 0000000..9356d59
--- /dev/null
+++ b/drivers/vin/sensors/panasonic_mn34420pl/Kbuild
@@ -0,0 +1,38 @@
+##
+## Filename : Kbuild
+##
+## History:
+##    2015/12/15 - [Hao Zeng] Create
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+
+EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
+EXTRA_AFLAGS		+= $(AMBARELLA_DRV_AFLAGS)
+EXTRA_LDFLAGS		+= $(AMBARELLA_DRV_LDFLAGS)
+
+obj-m := mn34420pl.o
+
diff --git a/drivers/vin/sensors/panasonic_mn34420pl/make.inc b/drivers/vin/sensors/panasonic_mn34420pl/make.inc
new file mode 100644
index 0000000..56d349a
--- /dev/null
+++ b/drivers/vin/sensors/panasonic_mn34420pl/make.inc
@@ -0,0 +1,45 @@
+##
+## kernel/private/drivers/vin/sensors/panasonic_mn34420pl/make.inc
+##
+## History:
+##    2015/12/15 - [Hao Zeng] Create
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+ifeq ($(CONFIG_SENSOR_MN34420PL), y)
+
+LOCAL_PATH	:= $(call my-dir)
+
+###
+include $(CLEAR_VARS)
+
+LOCAL_SRCS	:= $(wildcard $(LOCAL_PATH)/*.c) $(wildcard $(LOCAL_PATH)/*.h)
+LOCAL_SRCS	+= $(LOCAL_PATH)/Kbuild
+
+include $(BUILD_DRIVER)
+
+endif
+
diff --git a/drivers/vin/sensors/panasonic_mn34420pl/mn34420pl.c b/drivers/vin/sensors/panasonic_mn34420pl/mn34420pl.c
new file mode 100644
index 0000000..df06077
--- /dev/null
+++ b/drivers/vin/sensors/panasonic_mn34420pl/mn34420pl.c
@@ -0,0 +1,832 @@
+/*
+ * Filename : mn34420pl.c
+ *
+ * History:
+ *    2015/12/15 - [Hao Zeng] Create
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/ambpriv_device.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <iav_utils.h>
+#include <vin_api.h>
+#include "mn34420pl.h"
+#include "mn34420pl_table.c"
+
+static int bus_addr = (0 << 16) | (0x6C >> 1);
+module_param(bus_addr, int, 0644);
+MODULE_PARM_DESC(bus_addr, " bus and addr: bit16~bit31: bus, bit0~bit15: addr");
+
+struct mn34420pl_priv {
+	void *control_data;
+	struct vindev_wdr_gp_s wdr_again_gp;
+	struct vindev_wdr_gp_s wdr_dgain_gp;
+	struct vindev_wdr_gp_s wdr_shutter_gp;
+	u32 line_length;
+	u32 frame_length_lines;
+	u32 ori_line_length;
+};
+
+static int mn34420pl_write_reg(struct vin_device *vdev, u32 subaddr, u32 data)
+{
+	int rval;
+	struct mn34420pl_priv *mn34420pl;
+	struct i2c_client *client;
+	struct i2c_msg msgs[1];
+	u8 pbuf[3];
+
+	mn34420pl = (struct mn34420pl_priv *)vdev->priv;
+	client = mn34420pl->control_data;
+
+	pbuf[0] = (subaddr & 0xff00) >> 8;
+	pbuf[1] = subaddr & 0xff;
+	pbuf[2] = data;
+
+	msgs[0].len = 3;
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].buf = pbuf;
+
+	rval = i2c_transfer(client->adapter, msgs, 1);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x:0x%x]\n", rval, subaddr, data);
+		return rval;
+	}
+
+	return 0;
+}
+
+static int mn34420pl_write_reg2(struct vin_device *vdev, u32 subaddr, u32 data)
+{
+	int rval;
+	struct mn34420pl_priv *mn34420pl;
+	struct i2c_client *client;
+	struct i2c_msg msgs[1];
+	u8 pbuf[4];
+
+	mn34420pl = (struct mn34420pl_priv *)vdev->priv;
+	client = mn34420pl->control_data;
+
+	pbuf[0] = (subaddr & 0xff00) >> 8;
+	pbuf[1] = subaddr & 0xff;
+	pbuf[2] = data >> 8;
+	pbuf[3] = data & 0xff;
+
+	msgs[0].len = 4;
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].buf = pbuf;
+
+	rval = i2c_transfer(client->adapter, msgs, 1);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x:0x%x]\n", rval, subaddr, data);
+		return rval;
+	}
+
+	return 0;
+}
+
+static int mn34420pl_read_reg(struct vin_device *vdev, u32 subaddr, u32 *data)
+{
+	int rval = 0;
+	struct mn34420pl_priv *mn34420pl;
+	struct i2c_client *client;
+	struct i2c_msg msgs[2];
+	u8 pbuf0[2];
+	u8 pbuf[1];
+
+	mn34420pl = (struct mn34420pl_priv *)vdev->priv;
+	client = mn34420pl->control_data;
+
+	pbuf0[0] = (subaddr & 0xff00) >> 8;
+	pbuf0[1] = subaddr & 0xff;
+
+	msgs[0].len = 2;
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].buf = pbuf0;
+
+	msgs[1].addr = client->addr;
+	msgs[1].flags = client->flags | I2C_M_RD;
+	msgs[1].buf = pbuf;
+	msgs[1].len = 1;
+
+	rval = i2c_transfer(client->adapter, msgs, 2);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x]\n", rval, subaddr);
+		return rval;
+	}
+
+	*data = pbuf[0];
+
+	return 0;
+}
+
+static int mn34420pl_set_vin_mode(struct vin_device *vdev, struct vin_video_format *format)
+{
+	struct vin_device_config mn34420pl_config;
+
+	memset(&mn34420pl_config, 0, sizeof(mn34420pl_config));
+
+	mn34420pl_config.interface_type = SENSOR_SERIAL_LVDS;
+	mn34420pl_config.sync_mode = SENSOR_SYNC_MODE_MASTER;
+
+	switch (format->hdr_mode) {
+	case AMBA_VIDEO_LINEAR_MODE:
+		if (format->bits == AMBA_VIDEO_BITS_10)
+			mn34420pl_config.slvds_cfg.lane_number = SENSOR_2_LANE;
+		else
+			mn34420pl_config.slvds_cfg.lane_number = SENSOR_4_LANE;
+		break;
+	case AMBA_VIDEO_2X_HDR_MODE:
+		mn34420pl_config.slvds_cfg.lane_number = SENSOR_4_LANE;
+		break;
+	case AMBA_VIDEO_3X_HDR_MODE:
+		mn34420pl_config.slvds_cfg.lane_number = SENSOR_6_LANE;
+		break;
+	default:
+		vin_error("Unknown mode\n");
+		return -EINVAL;
+	}
+
+	mn34420pl_config.slvds_cfg.sync_code_style = SENSOR_SYNC_STYLE_PANASONIC;
+
+	mn34420pl_config.cap_win.x = format->def_start_x;
+	mn34420pl_config.cap_win.y = format->def_start_y;
+	mn34420pl_config.cap_win.width = format->def_width;
+	mn34420pl_config.cap_win.height = format->def_height;
+
+	/* for hdr sensor */
+	mn34420pl_config.hdr_cfg.act_win.x = format->act_start_x;
+	mn34420pl_config.hdr_cfg.act_win.y = format->act_start_y;
+	mn34420pl_config.hdr_cfg.act_win.width = format->act_width;
+	mn34420pl_config.hdr_cfg.act_win.height = format->act_height;
+
+	mn34420pl_config.sensor_id	= GENERIC_SENSOR;
+	mn34420pl_config.input_format	= AMBA_VIN_INPUT_FORMAT_RGB_RAW;
+	mn34420pl_config.bayer_pattern	= format->bayer_pattern;
+	mn34420pl_config.video_format	= format->format;
+	mn34420pl_config.bit_resolution	= format->bits;
+
+	return ambarella_set_vin_config(vdev, &mn34420pl_config);
+}
+
+static int mn34420pl_init_device(struct vin_device *vdev)
+{
+	return 0;
+}
+
+static int mn34420pl_set_hold_mode(struct vin_device *vdev, u32 hold_mode)
+{
+	mn34420pl_write_reg(vdev, MN34420PL_VLATCH_HOLD, 0X70 | (hold_mode & 0x01));
+	return 0;
+}
+
+static int mn34420pl_update_hv_info(struct vin_device *vdev)
+{
+	u32 val_high, val_low;
+	struct mn34420pl_priv *pinfo = (struct mn34420pl_priv *)vdev->priv;
+
+	mn34420pl_read_reg(vdev, MN34420PL_HCYCLE_H, &val_high);
+	mn34420pl_read_reg(vdev, MN34420PL_HCYCLE_L, &val_low);
+	pinfo->line_length = (val_high << 8) + val_low + 1;
+	pinfo->ori_line_length = pinfo->line_length;
+	if (unlikely(!pinfo->line_length)) {
+		vin_error("line length is 0!\n");
+		return -EIO;
+	}
+
+	mn34420pl_read_reg(vdev, MN34420PL_VCYCLE_H, &val_high);
+	mn34420pl_read_reg(vdev, MN34420PL_VCYCLE_L, &val_low);
+	pinfo->frame_length_lines = (val_high << 8) + val_low + 1;
+
+	return 0;
+}
+
+static int mn34420pl_get_line_time(struct vin_device *vdev)
+{
+	u64 h_clks;
+	struct mn34420pl_priv *pinfo = (struct mn34420pl_priv *)vdev->priv;
+
+	h_clks = (u64)pinfo->line_length * 512000000;
+	h_clks = DIV64_CLOSEST(h_clks, vdev->cur_pll->pixelclk);
+
+	vdev->cur_format->line_time = (u32)h_clks;
+
+	return 0;
+}
+
+static int mn34420pl_set_format(struct vin_device *vdev, struct vin_video_format *format)
+{
+	struct vin_reg_16_8 *regs;
+	int i, regs_num;
+	int rval;
+
+	switch (format->hdr_mode) {
+	case AMBA_VIDEO_LINEAR_MODE:
+		if (format->bits == AMBA_VIDEO_BITS_10) {
+			if (format->video_mode == AMBA_VIDEO_MODE_WUXGA) {
+				regs = mn34420pl_2lane_wuxga_regs;
+				regs_num = ARRAY_SIZE(mn34420pl_2lane_wuxga_regs);
+			} else {
+				regs = mn34420pl_2lane_1080p_regs;
+				regs_num = ARRAY_SIZE(mn34420pl_2lane_1080p_regs);
+			}
+		} else {
+			regs = mn34420pl_linear_mode_regs;
+			regs_num = ARRAY_SIZE(mn34420pl_linear_mode_regs);
+		}
+		break;
+	case AMBA_VIDEO_2X_HDR_MODE:
+		if (format->bits == AMBA_VIDEO_BITS_10) {
+			regs = mn34420pl_2x_hdr_10bit_mode_regs;
+			regs_num = ARRAY_SIZE(mn34420pl_2x_hdr_10bit_mode_regs);
+		} else {
+			regs = mn34420pl_2x_hdr_mode_regs;
+			regs_num = ARRAY_SIZE(mn34420pl_2x_hdr_mode_regs);
+		}
+		break;
+	case AMBA_VIDEO_3X_HDR_MODE:
+		regs = mn34420pl_3x_hdr_mode_regs;
+		regs_num = ARRAY_SIZE(mn34420pl_3x_hdr_mode_regs);
+		break;
+	default:
+		regs = NULL;
+		regs_num = 0;
+		vin_error("Unknown mode\n");
+		return -EPERM;
+	}
+
+	for (i = 0; i < regs_num; i++)
+		mn34420pl_write_reg(vdev, regs[i].addr, regs[i].data);
+
+	rval = mn34420pl_update_hv_info(vdev);
+	if (rval < 0)
+		return rval;
+
+	mn34420pl_get_line_time(vdev);
+
+	return mn34420pl_set_vin_mode(vdev, format);
+}
+
+static int mn34420pl_set_fps(struct vin_device *vdev, int fps)
+{
+	u64	v_lines, vb_time;
+	u32 factor;
+	struct mn34420pl_priv *pinfo = (struct mn34420pl_priv *)vdev->priv;
+
+	v_lines = fps * (u64)vdev->cur_pll->pixelclk;
+	v_lines = DIV64_CLOSEST(v_lines, pinfo->ori_line_length);
+	v_lines = DIV64_CLOSEST(v_lines, 512000000);
+
+	/* workaround for 1fps case */
+	if (v_lines > 0xFFFF) {
+		vin_debug("h_clks:%d, v_lines:%lld\n", pinfo->ori_line_length, v_lines);
+
+		factor = ((u32)v_lines) / 0xFFFF + 1;
+		v_lines = DIV64_CLOSEST(v_lines, factor);
+		pinfo->line_length = pinfo->ori_line_length * factor;
+		mn34420pl_write_reg2(vdev, MN34420PL_HCYCLE_H, pinfo->line_length);
+	} else if (pinfo->line_length != pinfo->ori_line_length) {
+		pinfo->line_length = pinfo->ori_line_length;
+		mn34420pl_write_reg2(vdev, MN34420PL_HCYCLE_H, pinfo->line_length);
+	}
+	mn34420pl_write_reg2(vdev, MN34420PL_VCYCLE_H, (v_lines - 1)&0xFFFF);
+
+	pinfo->frame_length_lines = (u32)v_lines;
+
+	vb_time = pinfo->line_length * (u64)(v_lines - vdev->cur_format->height) * 1000000000;
+	vb_time = DIV64_CLOSEST(vb_time, vdev->cur_pll->pixelclk);
+	vdev->cur_format->vb_time = vb_time;
+
+	return 0;
+}
+
+static int mn34420pl_set_agc_index(struct vin_device *vdev, int agc_idx)
+{
+	if (vdev->cur_format->hdr_mode != AMBA_VIDEO_LINEAR_MODE) {
+		return 0;
+	}
+
+	if (agc_idx > MN34420PL_GAIN_MAXDB) {
+		vin_warn("agc index %d exceeds maximum %d\n", agc_idx, MN34420PL_GAIN_MAXDB);
+		agc_idx = MN34420PL_GAIN_MAXDB;
+	}
+
+	/* analog gain */
+	mn34420pl_write_reg2(vdev, MN34420PL_AGAIN_H, MN34420PL_GAIN_TABLE[agc_idx][MN34420PL_GAIN_COL_AGAIN]&0x3FFF);
+	/* didgital gain */
+	mn34420pl_write_reg2(vdev, MN34420PL_DGAIN_H, MN34420PL_GAIN_TABLE[agc_idx][MN34420PL_GAIN_COL_DGAIN]&0x3FFF);
+
+	return 0;
+}
+
+static int mn34420pl_set_shutter_row(struct vin_device *vdev, u32 row)
+{
+	u64 exposure_lines;
+	u32 num_line, min_line, max_line;
+	u32 blank_lines;
+	struct mn34420pl_priv *pinfo = (struct mn34420pl_priv *)vdev->priv;
+
+	num_line = row;
+
+	/* FIXME: shutter width: 1 ~ (Frame format(V) - 2) */
+	min_line = 1;
+	max_line = pinfo->frame_length_lines - 2;
+	num_line = clamp(num_line, min_line, max_line);
+
+	blank_lines = pinfo->frame_length_lines - num_line;
+	mn34420pl_write_reg2(vdev, MN34420PL_SHTPOS_H, blank_lines);
+
+	exposure_lines = num_line;
+	exposure_lines = exposure_lines * (u64)pinfo->line_length * 512000000;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, vdev->cur_pll->pixelclk);
+
+	vdev->shutter_time = (u32)exposure_lines;
+	vin_debug("shutter_time:%d, row:%d\n", vdev->shutter_time, num_line);
+
+	return 0;
+}
+
+static int mn34420pl_shutter2row(struct vin_device *vdev, u32 *shutter_time)
+{
+	u64 exposure_lines;
+	int rval = 0;
+	struct mn34420pl_priv *pinfo = (struct mn34420pl_priv *)vdev->priv;
+
+	if (unlikely(!pinfo->line_length)) {
+		rval = mn34420pl_update_hv_info(vdev);
+		if (rval < 0)
+			return rval;
+	}
+
+	exposure_lines = (*shutter_time) * (u64)vdev->cur_pll->pixelclk;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, pinfo->line_length);
+	exposure_lines = DIV64_CLOSEST(exposure_lines, 512000000);
+
+	*shutter_time = exposure_lines;
+
+	return rval;
+}
+
+static int mn34420pl_set_wdr_shutter_row_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_shutter_gp)
+{
+	struct mn34420pl_priv *pinfo = (struct mn34420pl_priv *)vdev->priv;
+	int shutter_long, shutter_short1, shutter_short2, shutter_short3;
+	u32 active_lines;
+	u64 vb_time;
+	int errCode = 0;
+
+	active_lines = vdev->cur_format->height;
+
+	/* long shutter */
+	shutter_long = p_shutter_gp->l;
+	/* short shutter 1 */
+	shutter_short1 = p_shutter_gp->s1;
+	/* short shutter 2 */
+	shutter_short2 = p_shutter_gp->s2;
+	/* short shutter 3 */
+	shutter_short3 = p_shutter_gp->s3;
+
+	/* shutter limitation check */
+	switch (vdev->cur_format->hdr_mode) {
+	case AMBA_VIDEO_2X_HDR_MODE:
+		if (shutter_long + shutter_short1 + 4 > pinfo->frame_length_lines) {
+			vin_error("shutter exceeds limitation! long:%d, short:%d, V:%d\n",
+				shutter_long, shutter_short1, pinfo->frame_length_lines);
+			return -EPERM;
+		} else if (shutter_short1 + 2 > pinfo->frame_length_lines - active_lines) {
+			vin_error("short frame offset exceeds limitation! short:%d, VB:%d\n",
+				shutter_short1, pinfo->frame_length_lines - active_lines);
+			return -EPERM;
+		}
+		break;
+	case AMBA_VIDEO_3X_HDR_MODE:
+		if (shutter_long + shutter_short1 + shutter_short2 + 6 > pinfo->frame_length_lines) {
+			vin_error("shutter exceeds limitation! long:%d, short1:%d, short2:%d, V:%d\n",
+				shutter_long, shutter_short1, shutter_short2, pinfo->frame_length_lines);
+			return -EPERM;
+		} else if (shutter_short1 + shutter_short2 + 4 > pinfo->frame_length_lines - active_lines) {
+			vin_error("short frame offset exceeds limitation! short1:%d, short2:%d, VB:%d\n",
+				shutter_short1, shutter_short2, pinfo->frame_length_lines - active_lines);
+			return -EPERM;
+		}
+		break;
+	case AMBA_VIDEO_4X_HDR_MODE:
+		if (shutter_long + shutter_short1 + shutter_short2 + 8 > pinfo->frame_length_lines) {
+			vin_error("shutter exceeds limitation! long:%d, short1:%d, short2:%d, short3:%d, V:%d\n",
+				shutter_long, shutter_short1, shutter_short2, shutter_short3, pinfo->frame_length_lines);
+			return -EPERM;
+		} else if (shutter_short1 + shutter_short2 + shutter_short3 + 6 > pinfo->frame_length_lines - active_lines) {
+			vin_error("short frame offset exceeds limitation! short1:%d, short2:%d, short3:%d, VB:%d\n",
+				shutter_short1, shutter_short2, shutter_short3, pinfo->frame_length_lines - active_lines);
+			return -EPERM;
+		}
+		break;
+	case AMBA_VIDEO_LINEAR_MODE:
+	default:
+		vin_error("Unsupported mode\n");
+		return -EPERM;
+	}
+
+	/* long shutter */
+	shutter_long = pinfo->frame_length_lines - shutter_long;
+	mn34420pl_write_reg2(vdev, MN34420PL_SHTPOS_H, shutter_long);
+	/* short shutter 1 */
+	mn34420pl_write_reg2(vdev, MN34420PL_SHTPOS_WDR1, shutter_short1);
+	/* short shutter 2 */
+	mn34420pl_write_reg2(vdev, MN34420PL_SHTPOS_WDR2, shutter_short2);
+	/* short shutter 3 */
+	mn34420pl_write_reg2(vdev, MN34420PL_SHTPOS_WDR3, shutter_short3);
+
+	memcpy(&(pinfo->wdr_shutter_gp),  p_shutter_gp, sizeof(struct vindev_wdr_gp_s));
+
+	switch (vdev->cur_format->hdr_mode) {
+	case AMBA_VIDEO_2X_HDR_MODE:
+		vb_time = pinfo->frame_length_lines - vdev->cur_format->height - pinfo->wdr_shutter_gp.s1;
+		break;
+	case AMBA_VIDEO_3X_HDR_MODE:
+		vb_time = pinfo->frame_length_lines - vdev->cur_format->height - pinfo->wdr_shutter_gp.s1
+			- pinfo->wdr_shutter_gp.s2;
+		break;
+	case AMBA_VIDEO_4X_HDR_MODE:
+		vb_time = pinfo->frame_length_lines - vdev->cur_format->height - pinfo->wdr_shutter_gp.s1
+			- pinfo->wdr_shutter_gp.s2 - pinfo->wdr_shutter_gp.s3;
+		break;
+	default:
+		vin_error("Unsupported mode\n");
+		return -EPERM;
+	}
+
+	vb_time = pinfo->line_length * (u64)vb_time * 1000000000;
+	vb_time = DIV64_CLOSEST(vb_time, vdev->cur_pll->pixelclk);
+	vdev->cur_format->vb_time = vb_time;
+
+	vin_debug("shutter long:%d, short1:%d, short2:%d, short3:%d, vb_time:%d\n", p_shutter_gp->l,
+		p_shutter_gp->s1, p_shutter_gp->s2, p_shutter_gp->s3, vdev->cur_format->vb_time);
+
+	return errCode;
+}
+
+static int mn34420pl_get_wdr_shutter_row_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_shutter_gp)
+{
+	struct mn34420pl_priv *pinfo = (struct mn34420pl_priv *)vdev->priv;
+	memcpy(p_shutter_gp, &(pinfo->wdr_shutter_gp), sizeof(struct vindev_wdr_gp_s));
+
+	return 0;
+}
+
+static int mn34420pl_set_wdr_again_idx_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_again_gp)
+{
+	struct mn34420pl_priv *pinfo = (struct mn34420pl_priv *)vdev->priv;
+	u32 again_index;
+
+	again_index = p_again_gp->l;
+	mn34420pl_write_reg2(vdev, MN34420PL_AGAIN_H, MN34420PL_GAIN_TABLE[again_index][MN34420PL_GAIN_COL_AGAIN]&0x3FFF);
+	again_index = p_again_gp->s1;
+	mn34420pl_write_reg2(vdev, MN34420PL_AGAIN_WDR1, MN34420PL_GAIN_TABLE[again_index][MN34420PL_GAIN_COL_AGAIN]&0x3FFF);
+	again_index = p_again_gp->s2;
+	mn34420pl_write_reg2(vdev, MN34420PL_AGAIN_WDR2, MN34420PL_GAIN_TABLE[again_index][MN34420PL_GAIN_COL_AGAIN]&0x3FFF);
+	again_index = p_again_gp->s3;
+	mn34420pl_write_reg2(vdev, MN34420PL_AGAIN_WDR3, MN34420PL_GAIN_TABLE[again_index][MN34420PL_GAIN_COL_AGAIN]&0x3FFF);
+
+	memcpy(&(pinfo->wdr_again_gp), p_again_gp, sizeof(struct vindev_wdr_gp_s));
+
+	vin_debug("long again index:%d, short1 again index:%d, short2 again index:%d\n",
+		p_again_gp->l, p_again_gp->s1, p_again_gp->s2);
+
+	return 0;
+}
+
+static int mn34420pl_get_wdr_again_idx_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_again_gp)
+{
+	struct mn34420pl_priv *pinfo = (struct mn34420pl_priv *)vdev->priv;
+
+	memcpy(p_again_gp, &(pinfo->wdr_again_gp), sizeof(struct vindev_wdr_gp_s));
+	return 0;
+}
+
+static int mn34420pl_set_wdr_dgain_idx_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_dgain_gp)
+{
+	struct mn34420pl_priv *pinfo = (struct mn34420pl_priv *)vdev->priv;
+	int dgain_index;
+
+	/* long frame */
+	dgain_index = p_dgain_gp->l + MN34420PL_WDR_DGAIN_ON;
+	mn34420pl_write_reg2(vdev, MN34420PL_DGAIN_H, MN34420PL_GAIN_TABLE[dgain_index][MN34420PL_GAIN_COL_DGAIN]&0x3FFF);
+	dgain_index = p_dgain_gp->s1 + MN34420PL_WDR_DGAIN_ON;
+	mn34420pl_write_reg2(vdev, MN34420PL_DGAIN_WDR1, MN34420PL_GAIN_TABLE[dgain_index][MN34420PL_GAIN_COL_DGAIN]&0x3FFF);
+	dgain_index = p_dgain_gp->s2 + MN34420PL_WDR_DGAIN_ON;
+	mn34420pl_write_reg2(vdev, MN34420PL_DGAIN_WDR2, MN34420PL_GAIN_TABLE[dgain_index][MN34420PL_GAIN_COL_DGAIN]&0x3FFF);
+	dgain_index = p_dgain_gp->s3 + MN34420PL_WDR_DGAIN_ON;
+	mn34420pl_write_reg2(vdev, MN34420PL_DGAIN_WDR3, MN34420PL_GAIN_TABLE[dgain_index][MN34420PL_GAIN_COL_DGAIN]&0x3FFF);
+
+	memcpy(&(pinfo->wdr_dgain_gp), p_dgain_gp, sizeof(struct vindev_wdr_gp_s));
+	return 0;
+}
+
+static int mn34420pl_get_wdr_dgain_idx_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_dgain_gp)
+{
+	struct mn34420pl_priv *pinfo = (struct mn34420pl_priv *)vdev->priv;
+
+	memcpy(p_dgain_gp, &(pinfo->wdr_dgain_gp), sizeof(struct vindev_wdr_gp_s));
+	return 0;
+}
+
+static int mn34420pl_wdr_shutter2row(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_shutter2row)
+{
+	u64 exposure_lines;
+	int errCode = 0;
+	struct mn34420pl_priv *pinfo = (struct mn34420pl_priv *)vdev->priv;
+
+	/* long shutter */
+	exposure_lines = p_shutter2row->l * (u64)vdev->cur_pll->pixelclk;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, pinfo->line_length);
+	exposure_lines = DIV64_CLOSEST(exposure_lines, 512000000);
+	p_shutter2row->l = (u32)exposure_lines;
+
+	/* short shutter 1 */
+	exposure_lines = p_shutter2row->s1 * (u64)vdev->cur_pll->pixelclk;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, pinfo->line_length);
+	exposure_lines = DIV64_CLOSEST(exposure_lines, 512000000);
+	p_shutter2row->s1 = (u32)exposure_lines;
+
+	/* short shutter 2 */
+	exposure_lines = p_shutter2row->s2 * (u64)vdev->cur_pll->pixelclk;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, pinfo->line_length);
+	exposure_lines = DIV64_CLOSEST(exposure_lines, 512000000);
+	p_shutter2row->s2 = (u32)exposure_lines;
+
+	/* short shutter 3 */
+	exposure_lines = p_shutter2row->s3 * (u64)vdev->cur_pll->pixelclk;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, pinfo->line_length);
+	exposure_lines = DIV64_CLOSEST(exposure_lines, 512000000);
+	p_shutter2row->s3 = (u32)exposure_lines;
+
+	return errCode;
+}
+
+static int mn34420pl_set_mirror_mode(struct vin_device *vdev,
+	struct vindev_mirror *mirror_mode)
+{
+	u32 tmp_reg, readmode, bayer_pattern;
+
+	switch (mirror_mode->pattern) {
+	case VINDEV_MIRROR_AUTO:
+		return 0;
+
+	case VINDEV_MIRROR_VERTICALLY:
+		readmode = MN34420PL_V_FLIP;
+		bayer_pattern = VINDEV_BAYER_PATTERN_BG;
+		break;
+
+	case VINDEV_MIRROR_NONE:
+		readmode = 0;
+		bayer_pattern = VINDEV_BAYER_PATTERN_GR;
+		break;
+
+	case VINDEV_MIRROR_HORRIZONTALLY_VERTICALLY:
+	case VINDEV_MIRROR_HORRIZONTALLY:
+	default:
+		vin_error("do not support cmd mirror mode\n");
+		return -EINVAL;
+	}
+
+	mn34420pl_read_reg(vdev, MN34420PL_MODE, &tmp_reg);
+	tmp_reg &= (~MN34420PL_V_FLIP);
+	tmp_reg |= readmode;
+	mn34420pl_write_reg(vdev, MN34420PL_MODE, tmp_reg);
+
+	if (mirror_mode->bayer_pattern == VINDEV_BAYER_PATTERN_AUTO)
+		mirror_mode->bayer_pattern = bayer_pattern;
+
+	return 0;
+}
+
+static int mn34420pl_get_aaa_info(struct vin_device *vdev,
+	struct vindev_aaa_info *aaa_info)
+{
+	struct mn34420pl_priv *pinfo = (struct mn34420pl_priv *)vdev->priv;
+
+	aaa_info->sht0_max = pinfo->frame_length_lines - 6;
+	aaa_info->sht1_max = pinfo->frame_length_lines - vdev->cur_format->height - 2;
+	aaa_info->sht2_max = (vdev->cur_format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE) ?
+		(aaa_info->sht1_max - 2) : 0;
+
+	return 0;
+}
+
+static int mn34420pl_get_eis_info(struct vin_device *vdev,
+	struct vindev_eisinfo *eis_info)
+{
+	eis_info->sensor_cell_width = 275;/* 2.75 um */
+	eis_info->sensor_cell_height = 275;/* 2.75 um */
+	eis_info->vb_time = vdev->cur_format->vb_time;
+	eis_info->column_bin = 1;
+	eis_info->row_bin = 1;
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int mn34420pl_suspend(struct vin_device *vdev)
+{
+	u32 i, tmp;
+
+	for (i = 0; i < ARRAY_SIZE(pm_regs); i++) {
+		mn34420pl_read_reg(vdev, pm_regs[i].addr, &tmp);
+		pm_regs[i].data = (tmp<<8);
+		mn34420pl_read_reg(vdev, (pm_regs[i].addr)+1, &tmp);
+		pm_regs[i].data |= (u16)tmp;
+	}
+
+	return 0;
+}
+
+static int mn34420pl_resume(struct vin_device *vdev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(pm_regs); i++)
+		mn34420pl_write_reg2(vdev, pm_regs[i].addr, pm_regs[i].data);
+
+	return 0;
+}
+#endif
+
+static struct vin_ops mn34420pl_ops = {
+	.init_device		= mn34420pl_init_device,
+	.set_format		= mn34420pl_set_format,
+	.set_shutter_row	= mn34420pl_set_shutter_row,
+	.shutter2row		= mn34420pl_shutter2row,
+	.set_frame_rate		= mn34420pl_set_fps,
+	.set_agc_index		= mn34420pl_set_agc_index,
+	.set_mirror_mode	= mn34420pl_set_mirror_mode,
+	.set_hold_mode		= mn34420pl_set_hold_mode,
+	.get_aaa_info		= mn34420pl_get_aaa_info,
+	.get_eis_info		= mn34420pl_get_eis_info,
+	.read_reg		= mn34420pl_read_reg,
+	.write_reg		= mn34420pl_write_reg,
+#ifdef CONFIG_PM
+	.suspend		= mn34420pl_suspend,
+	.resume 		= mn34420pl_resume,
+#endif
+
+	/* for wdr sensor */
+	.set_wdr_again_idx_gp = mn34420pl_set_wdr_again_idx_group,
+	.get_wdr_again_idx_gp = mn34420pl_get_wdr_again_idx_group,
+	.set_wdr_dgain_idx_gp = mn34420pl_set_wdr_dgain_idx_group,
+	.get_wdr_dgain_idx_gp = mn34420pl_get_wdr_dgain_idx_group,
+	.set_wdr_shutter_row_gp = mn34420pl_set_wdr_shutter_row_group,
+	.get_wdr_shutter_row_gp = mn34420pl_get_wdr_shutter_row_group,
+	.wdr_shutter2row = mn34420pl_wdr_shutter2row,
+};
+
+/* ========================================================================== */
+static int mn34420pl_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	int rval = 0;
+	struct vin_device *vdev;
+	struct mn34420pl_priv *mn34420pl;
+
+	vdev = ambarella_vin_create_device(client->name,
+			SENSOR_MN34420PL, sizeof(struct mn34420pl_priv));
+	if (!vdev)
+		return -ENOMEM;
+
+	vdev->intf_id = 0;
+	vdev->dev_type = VINDEV_TYPE_SENSOR;
+	vdev->sub_type = VINDEV_SUBTYPE_CMOS;
+	vdev->default_mode = AMBA_VIDEO_MODE_1080P;
+	vdev->default_hdr_mode = AMBA_VIDEO_LINEAR_MODE;
+	vdev->agc_db_min = 0x00000000;  /* 0dB */
+#ifdef USE_GAIN_0P375DB_STEPS
+	vdev->agc_db_max = 0x40800000;  /* 64.50000dB */
+	vdev->agc_db_step = 0x00600000; /* 0.375dB */
+#else
+	vdev->agc_db_max = 0x40C80000;  /* 64.78125dB */
+	vdev->agc_db_step = 0x00180000; /* 0.09375dB */
+#endif
+
+	vdev->wdr_again_idx_min = 0;
+	vdev->wdr_again_idx_max = MN34420PL_WDR_DGAIN_ON;
+	vdev->wdr_dgain_idx_min = 0;
+	vdev->wdr_dgain_idx_max = MN34420PL_WDR_GAIN_30DB;
+
+	/* mode switch needs hw reset */
+	vdev->reset_for_mode_switch = true;
+
+	i2c_set_clientdata(client, vdev);
+
+	mn34420pl = (struct mn34420pl_priv *)vdev->priv;
+	mn34420pl->control_data = client;
+
+	rval = ambarella_vin_register_device(vdev, &mn34420pl_ops,
+			mn34420pl_formats, ARRAY_SIZE(mn34420pl_formats),
+			mn34420pl_plls, ARRAY_SIZE(mn34420pl_plls));
+	if (rval < 0)
+		goto mn34420pl_probe_err;
+
+	vin_info("MN34420PL init(6-lane lvds)\n");
+
+	return 0;
+
+mn34420pl_probe_err:
+	ambarella_vin_free_device(vdev);
+	return rval;
+}
+
+static int mn34420pl_remove(struct i2c_client *client)
+{
+	struct vin_device *vdev;
+
+	vdev = (struct vin_device *)i2c_get_clientdata(client);
+	ambarella_vin_unregister_device(vdev);
+	ambarella_vin_free_device(vdev);
+
+	return 0;
+}
+
+static const struct i2c_device_id mn34420pl_idtable[] = {
+	{ "mn34420pl", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, mn34420pl_idtable);
+
+static struct i2c_driver i2c_driver_mn34420pl = {
+	.driver = {
+		.name	= "mn34420pl",
+	},
+
+	.id_table	= mn34420pl_idtable,
+	.probe		= mn34420pl_probe,
+	.remove		= mn34420pl_remove,
+
+};
+
+static int __init mn34420pl_init(void)
+{
+	int bus, addr, rval;
+
+	bus = bus_addr >> 16;
+	addr = bus_addr & 0xffff;
+
+	rval = ambpriv_i2c_update_addr("mn34420pl", bus, addr);
+	if (rval < 0)
+		return rval;
+
+	rval = i2c_add_driver(&i2c_driver_mn34420pl);
+	if (rval < 0)
+		return rval;
+
+	return 0;
+}
+
+static void __exit mn34420pl_exit(void)
+{
+	i2c_del_driver(&i2c_driver_mn34420pl);
+}
+
+module_init(mn34420pl_init);
+module_exit(mn34420pl_exit);
+
+MODULE_DESCRIPTION("MN34420PL 1/2.86 -Inch, 1944x1212, 2.4-Megapixel CMOS Digital Image Sensor");
+MODULE_AUTHOR("Hao Zeng, <haozeng@ambarella.com>");
+MODULE_LICENSE("Proprietary");
+
diff --git a/drivers/vin/sensors/panasonic_mn34420pl/mn34420pl.h b/drivers/vin/sensors/panasonic_mn34420pl/mn34420pl.h
new file mode 100644
index 0000000..1217310
--- /dev/null
+++ b/drivers/vin/sensors/panasonic_mn34420pl/mn34420pl.h
@@ -0,0 +1,74 @@
+/*
+ * Filename : mn34420pl.h
+ *
+ * History:
+ *    2015/12/15 - [Hao Zeng] Create
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __MN34420PL_H__
+#define __MN34420PL_H__
+
+#define MN34420PL_RESET_REG_H	0x3000
+#define MN34420PL_RESET_REG_L	0x3001
+
+#define MN34420PL_VLATCH_HOLD	0x3041
+
+#define MN34420PL_AGAIN_H	0x3100
+#define MN34420PL_AGAIN_L	0x3101
+#define MN34420PL_DGAIN_H	0x3102
+#define MN34420PL_DGAIN_L	0x3103
+
+#define MN34420PL_AGAIN_WDR1	0x3108
+#define MN34420PL_AGAIN_WDR2	0x3110
+#define MN34420PL_AGAIN_WDR3	0x3116
+#define MN34420PL_DGAIN_WDR1	0x310A
+#define MN34420PL_DGAIN_WDR2	0x3112
+#define MN34420PL_DGAIN_WDR3	0x3118
+
+#define MN34420PL_SHTPOS_H	0x3104
+#define MN34420PL_SHTPOS_L	0x3105
+#define MN34420PL_LONG_EXP	0x3106
+
+#define MN34420PL_SHTPOS_WDR1	0x310C
+#define MN34420PL_SHTPOS_WDR2	0x3114
+#define MN34420PL_SHTPOS_WDR3	0x311A
+
+#define MN34420PL_VCYCLE_H	0x4302
+#define MN34420PL_VCYCLE_L	0x4303
+#define MN34420PL_HCYCLE_H	0x4304
+#define MN34420PL_HCYCLE_L	0x4305
+
+#define MN34420PL_M1_RDPOS_WDR1	0x431A
+#define MN34420PL_M1_RDPOS_WDR2	0x431C
+#define MN34420PL_M1_RDPOS_WDR3	0x431E
+
+#define MN34420PL_MODE	0x4301
+#define MN34420PL_V_FLIP (1<<7)
+
+#endif /* __MN34420PL_H__ */
+
diff --git a/drivers/vin/sensors/panasonic_mn34420pl/mn34420pl_table.c b/drivers/vin/sensors/panasonic_mn34420pl/mn34420pl_table.c
new file mode 100644
index 0000000..42c9738
--- /dev/null
+++ b/drivers/vin/sensors/panasonic_mn34420pl/mn34420pl_table.c
@@ -0,0 +1,5516 @@
+/*
+ * Filename : mn34420pl_table.c
+ *
+ * History:
+ *    2015/12/15 - [Hao Zeng] Create
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+static struct vin_video_pll mn34420pl_plls[] = {
+	{0, 37125000, 55687500},
+	{0, 37125000, 54000000},
+	{0, 27000000, 40500000},
+};
+
+static struct vin_video_format mn34420pl_formats[] = {
+	{
+		.video_mode	= AMBA_VIDEO_MODE_1080P,
+		.def_start_x	= 6+(1944-1920)/2,
+		.def_start_y	= 2+10+4+(1092-1080)/2,
+		.def_width	= 1920,
+		.def_height	= 1080,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_LINEAR_MODE,
+		.device_mode	= 0,
+		.pll_idx	= 0,
+		.width		= 1956,
+		.height		= 1108,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_60,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_GR,
+	},
+	{	/* 2x hdr mode */
+		.video_mode	= AMBA_VIDEO_MODE_1080P,
+		.def_start_x	= 6+(1944-1920)/2,
+		.def_start_y	= (2+10+4)*2+(1092-1080),
+		.def_width	= 1920,
+		.def_height	= 3000 - (2+10+4+6)*2, /* VMAX*2 - def_start_y*2 */
+		.act_start_x	= 0,
+		.act_start_y	= 0,
+		.act_width	= 1920,
+		.act_height	= 1080,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_2X_HDR_MODE,
+		.device_mode	= 1,
+		.pll_idx	= 1,
+		.width		= 1956,
+		.height		= 1108,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_GR,
+	},
+	{	/* 3x hdr mode */
+		.video_mode	= AMBA_VIDEO_MODE_1080P,
+		.def_start_x	= 6+(1944-1920)/2,
+		.def_start_y	= (2+10+4)*3+(1092-1080)/2*3,
+		.def_width	= 1920,
+		.def_height	= 4500 - (2+10+4+6)*3, /* VMAX*3 - def_start_y*3 */
+		.act_start_x	= 0,
+		.act_start_y	= 0,
+		.act_width	= 1920,
+		.act_height	= 1080,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_3X_HDR_MODE,
+		.device_mode	= 2,
+		.pll_idx	= 1,
+		.width		= 1956,
+		.height		= 1108,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_GR,
+	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_WUXGA,
+		.def_start_x	= 6+(1944-1920)/2,
+		.def_start_y	= 2+10+4+(1212-1200)/2,
+		.def_width	= 1920,
+		.def_height	= 1200,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_LINEAR_MODE,
+		.device_mode	= 3,
+		.pll_idx	= 2,
+		.width		= 1956,
+		.height		= 1228,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_10,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_GR,
+	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_1080P,
+		.def_start_x	= 6+(1944-1920)/2,
+		.def_start_y	= 2+10+4+(1092-1080)/2,
+		.def_width	= 1920,
+		.def_height	= 1080,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_LINEAR_MODE,
+		.device_mode	= 4,
+		.pll_idx	= 2,
+		.width		= 1956,
+		.height		= 1108,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_10,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_GR,
+	},
+	{	/* 2x hdr mode */
+		.video_mode	= AMBA_VIDEO_MODE_1080P,
+		.def_start_x	= 6+(1944-1920)/2,
+		.def_start_y	= (2+10+4)*2+(1092-1080),
+		.def_width	= 1920,
+		.def_height	= 2500 - (2+10+4+6)*2, /* VMAX*2 - def_start_y*2 */
+		.act_start_x	= 0,
+		.act_start_y	= 0,
+		.act_width	= 1920,
+		.act_height	= 1080,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_2X_HDR_MODE,
+		.device_mode	= 5,
+		.pll_idx	= 2,
+		.width		= 1956,
+		.height		= 1108,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_10,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_GR,
+	},
+};
+
+static struct vin_reg_16_8 mn34420pl_linear_mode_regs[] = {
+	/* VCYCLE:1125 HCYCLE:825 (@MCLK) */
+	{0x300C, 0x08},
+	{0x300D, 0x20},
+	{0x300E, 0x00},
+	{0x300F, 0x03},
+	{0x3002, 0x30},
+	{0x3003, 0xC0},
+	{0x3004, 0x30},
+	{0x3005, 0x60},
+	{0x3006, 0x02},
+	{0x3007, 0xC0},
+	{0x3008, 0x15},
+	{0x3009, 0x80},
+	{0x300A, 0xCF},
+	{0x300B, 0x30},
+	{0x3000, 0x01},
+	{0x3001, 0x03},
+	{0x3000, 0x01},
+	{0x3001, 0x53},
+	{0x300E, 0x00},
+	{0x300F, 0x00},
+	{0x3200, 0x3F},
+	{0x3201, 0x06},
+	{0x3202, 0x0B},
+	{0x3203, 0x0B},
+	{0x3204, 0x14},
+	{0x3205, 0x00},
+	{0x3206, 0xA7},
+	{0x3207, 0x78},
+	{0x3208, 0x49},
+	{0x320A, 0x00},
+	{0x3010, 0x00},
+	{0x3012, 0x00},
+	{0x3013, 0x03},
+	{0x3014, 0x00},
+	{0x3015, 0x00},
+	{0x3016, 0x00},
+	{0x3017, 0xF0},
+	{0x3018, 0x00},
+	{0x3019, 0x00},
+	{0x301A, 0x00},
+	{0x301B, 0x00},
+	{0x301C, 0x01},
+	{0x301D, 0x00},
+	{0x301E, 0x00},
+	{0x301F, 0x00},
+	{0x3020, 0x00},
+	{0x3021, 0x1A},
+	{0x3022, 0x38},
+	{0x3023, 0x00},
+	{0x3024, 0x00},
+	{0x3025, 0x00},
+	{0x3026, 0x20},
+	{0x3027, 0x00},
+	{0x3028, 0x00},
+	{0x3029, 0x00},
+	{0x302A, 0xFF},
+	{0x302B, 0x9F},
+	{0x302C, 0x08},
+	{0x302D, 0x04},
+	{0x302E, 0x00},
+	{0x302F, 0x00},
+	{0x3030, 0x5E},
+	{0x3031, 0x05},
+	{0x3032, 0x00},
+	{0x3033, 0x00},
+	{0x3035, 0x60},
+	{0x3036, 0x00},
+	{0x3037, 0x00},
+	{0x3039, 0x60},
+	{0x303B, 0x00},
+	{0x303D, 0x00},
+	{0x3040, 0x00},
+	{0x3041, 0x00},
+	{0x3042, 0x42},
+	{0x3043, 0x10},
+	{0x3044, 0x03},
+	{0x3045, 0x00},
+	{0x3046, 0x49},
+	{0x3047, 0x00},
+	{0x3048, 0x00},
+	{0x3049, 0x30},
+	{0x304A, 0xE2},
+	{0x304B, 0x01},
+	{0x304C, 0x31},
+	{0x304D, 0x33},
+	{0x304E, 0x22},
+	{0x304F, 0x33},
+	{0x3050, 0x00},
+	{0x3051, 0x50},
+	{0x3052, 0x00},
+	{0x3053, 0x00},
+	{0x3054, 0x00},
+	{0x3055, 0x00},
+	{0x3056, 0x04},
+	{0x3057, 0x00},
+	{0x3058, 0x7F},
+	{0x3059, 0x7F},
+	{0x305A, 0x7F},
+	{0x305B, 0x03},
+	{0x3060, 0x00},
+	{0x3061, 0x00},
+	{0x3062, 0x00},
+	{0x3063, 0x00},
+	{0x3100, 0x01},
+	{0x3101, 0x20},
+	{0x3102, 0x01},
+	{0x3103, 0x20},
+	{0x3104, 0x00},
+	{0x3105, 0x02},
+	{0x3107, 0x00},
+	{0x3108, 0x01},
+	{0x3109, 0x20},
+	{0x310A, 0x01},
+	{0x310B, 0x20},
+	{0x310C, 0x00},
+	{0x310D, 0x16},
+	{0x3110, 0x01},
+	{0x3111, 0x20},
+	{0x3112, 0x01},
+	{0x3113, 0x20},
+	{0x3114, 0x00},
+	{0x3115, 0x16},
+	{0x3116, 0x01},
+	{0x3117, 0x20},
+	{0x3118, 0x01},
+	{0x3119, 0x20},
+	{0x311A, 0x00},
+	{0x311B, 0x16},
+	{0x311C, 0x00},
+	{0x3120, 0x00},
+	{0x3121, 0x3C},
+	{0x3122, 0x04},
+	{0x3123, 0x7F},
+	{0x3124, 0x00},
+	{0x3125, 0x00},
+	{0x3126, 0x04},
+	{0x3127, 0x54},
+	{0x3131, 0x00},
+	{0x3140, 0x00},
+	{0x3141, 0xE0},
+	{0x3142, 0x00},
+	{0x3143, 0xC7},
+	{0x3151, 0x40},
+	{0x3152, 0x00},
+	{0x3153, 0x00},
+	{0x3154, 0x00},
+	{0x3155, 0x00},
+	{0x3156, 0x00},
+	{0x3157, 0x00},
+	{0x3159, 0x00},
+	{0x3161, 0x40},
+	{0x3162, 0x00},
+	{0x3163, 0x00},
+	{0x3164, 0x00},
+	{0x3165, 0x00},
+	{0x3166, 0x00},
+	{0x3167, 0x00},
+	{0x3169, 0x00},
+	{0x3170, 0x08},
+	{0x3171, 0x00},
+	{0x3172, 0x08},
+	{0x3173, 0x00},
+	{0x4000, 0x00},
+	{0x4001, 0x02},
+	{0x4002, 0x01},
+	{0x4003, 0x07},
+	{0x4004, 0x00},
+	{0x4005, 0x13},
+	{0x4006, 0x00},
+	{0x4007, 0x01},
+	{0x4008, 0x00},
+	{0x4009, 0x00},
+	{0x400A, 0x00},
+	{0x400B, 0x00},
+	{0x400C, 0x00},
+	{0x400D, 0x00},
+	{0x400E, 0x08},
+	{0x400F, 0x00},
+	{0x4010, 0x04},
+	{0x4012, 0x00},
+	{0x4013, 0x25},
+	{0x4014, 0x17},
+	{0x4015, 0x10},
+	{0x4016, 0x40},
+	{0x4017, 0xFF},
+	{0x4018, 0xC0},
+	{0x401A, 0x00},
+	{0x401B, 0x29},
+	{0x401C, 0x00},
+	{0x401D, 0x29},
+	{0x401E, 0x00},
+	{0x401F, 0x2B},
+	{0x4020, 0x00},
+	{0x4021, 0x2A},
+	{0x4022, 0x00},
+	{0x4023, 0x2A},
+	{0x4024, 0x00},
+	{0x4025, 0x2E},
+	{0x4026, 0x00},
+	{0x4027, 0x2D},
+	{0x4028, 0x00},
+	{0x4029, 0x2C},
+	{0x402A, 0x00},
+	{0x402B, 0x24},
+	{0x402C, 0x00},
+	{0x402D, 0x27},
+	{0x402E, 0x00},
+	{0x402F, 0x26},
+	{0x4030, 0x00},
+	{0x4031, 0x23},
+	{0x4032, 0x00},
+	{0x4033, 0x24},
+	{0x4034, 0x00},
+	{0x4035, 0x25},
+	{0x4036, 0x00},
+	{0x4037, 0x22},
+	{0x4038, 0x00},
+	{0x4039, 0x23},
+	{0x403A, 0x00},
+	{0x403B, 0x66},
+	{0x403C, 0x00},
+	{0x403D, 0x62},
+	{0x403E, 0x00},
+	{0x403F, 0x63},
+	{0x4040, 0x00},
+	{0x4041, 0x66},
+	{0x4042, 0x00},
+	{0x4043, 0x66},
+	{0x4044, 0x00},
+	{0x4045, 0x66},
+	{0x4046, 0x00},
+	{0x4047, 0x6C},
+	{0x4048, 0x00},
+	{0x4049, 0x00},
+	{0x404A, 0x1F},
+	{0x404B, 0x1F},
+	{0x404C, 0x1F},
+	{0x404D, 0x06},
+	{0x404E, 0x08},
+	{0x404F, 0x12},
+	{0x4050, 0x0F},
+	{0x4051, 0x0C},
+	{0x4052, 0x0B},
+	{0x4053, 0x0A},
+	{0x4054, 0x08},
+	{0x4055, 0x07},
+	{0x4056, 0x06},
+	{0x4057, 0x04},
+	{0x4058, 0x01},
+	{0x4059, 0x00},
+	{0x405A, 0x00},
+	{0x405B, 0x00},
+	{0x405C, 0x00},
+	{0x405D, 0x00},
+	{0x405E, 0x00},
+	{0x405F, 0x00},
+	{0x4060, 0xFF},
+	{0x4061, 0x07},
+	{0x4062, 0x77},
+	{0x4063, 0x00},
+	{0x4064, 0x44},
+	{0x4066, 0x0C},
+	{0x4067, 0x0C},
+	{0x4068, 0x00},
+	{0x4069, 0x00},
+	{0x406A, 0x00},
+	{0x406B, 0x00},
+	{0x406C, 0x00},
+	{0x406D, 0x00},
+	{0x406E, 0x00},
+	{0x4070, 0x00},
+	{0x4071, 0x00},
+	{0x4072, 0x00},
+	{0x4073, 0x00},
+	{0x4100, 0x10},
+	{0x4101, 0x32},
+	{0x4102, 0x54},
+	{0x4103, 0x76},
+	{0x4104, 0x8B},
+	{0x4105, 0x09},
+	{0x4106, 0x00},
+	{0x4107, 0x00},
+	{0x4108, 0x0A},
+	{0x4109, 0x88},
+	{0x410A, 0x00},
+	{0x410B, 0x00},
+	{0x410C, 0x00},
+	{0x410D, 0x82},
+	{0x410E, 0x22},
+	{0x410F, 0x00},
+	{0x4110, 0x00},
+	{0x4111, 0x22},
+	{0x4112, 0x00},
+	{0x4113, 0x00},
+	{0x4114, 0x3F},
+	{0x4115, 0x33},
+	{0x4116, 0xF6},
+	{0x4117, 0x3F},
+	{0x4118, 0x1C},
+	{0x4119, 0x15},
+	{0x411A, 0x26},
+	{0x411B, 0x00},
+	{0x411C, 0xBA},
+	{0x411D, 0x00},
+	{0x411E, 0x00},
+	{0x411F, 0x22},
+	{0x4120, 0x02},
+	{0x4121, 0x00},
+	{0x4122, 0x40},
+	{0x4124, 0x60},
+	{0x4125, 0x88},
+	{0x4126, 0x00},
+	{0x4127, 0x00},
+	{0x4128, 0x90},
+	{0x4129, 0x99},
+	{0x412A, 0x00},
+	{0x412B, 0x00},
+	{0x412C, 0x00},
+	{0x412D, 0x00},
+	{0x412E, 0x00},
+	{0x412F, 0x00},
+	{0x4130, 0x00},
+	{0x4131, 0x00},
+	{0x4132, 0x00},
+	{0x4133, 0x00},
+	{0x4134, 0x00},
+	{0x4135, 0x00},
+	{0x4136, 0x00},
+	{0x4137, 0x00},
+	{0x4138, 0x00},
+	{0x4139, 0x00},
+	{0x413A, 0x00},
+	{0x413B, 0x00},
+	{0x413C, 0x00},
+	{0x413D, 0x00},
+	{0x413E, 0x00},
+	{0x413F, 0x00},
+	{0x4140, 0x00},
+	{0x4141, 0x00},
+	{0x4142, 0x00},
+	{0x4143, 0x00},
+	{0x4144, 0x00},
+	{0x4145, 0x00},
+	{0x4146, 0x00},
+	{0x4147, 0x00},
+	{0x4148, 0x00},
+	{0x4149, 0x00},
+	{0x414A, 0x00},
+	{0x414B, 0x00},
+	{0x414C, 0x00},
+	{0x414D, 0x00},
+	{0x414E, 0x00},
+	{0x414F, 0x00},
+	{0x4150, 0x00},
+	{0x4151, 0x00},
+	{0x4152, 0x00},
+	{0x4153, 0x00},
+	{0x4154, 0x00},
+	{0x4155, 0x00},
+	{0x4156, 0x00},
+	{0x4157, 0x00},
+	{0x4158, 0x00},
+	{0x4159, 0x00},
+	{0x415A, 0x00},
+	{0x415B, 0x00},
+	{0x415C, 0x00},
+	{0x415D, 0x00},
+	{0x415E, 0x00},
+	{0x415F, 0x00},
+	{0x4200, 0x21},
+	{0x4201, 0x43},
+	{0x4202, 0x65},
+	{0x4203, 0x98},
+	{0x4204, 0x0A},
+	{0x4205, 0x00},
+	{0x4206, 0x00},
+	{0x4207, 0x00},
+	{0x4208, 0x08},
+	{0x4209, 0xAA},
+	{0x420A, 0x88},
+	{0x420B, 0x0A},
+	{0x420C, 0xA0},
+	{0x420D, 0x00},
+	{0x420E, 0x22},
+	{0x420F, 0xA8},
+	{0x4210, 0x02},
+	{0x4211, 0x00},
+	{0x4212, 0x00},
+	{0x4213, 0x00},
+	{0x4214, 0xF0},
+	{0x4215, 0x07},
+	{0x4216, 0x00},
+	{0x4217, 0x00},
+	{0x4218, 0x00},
+	{0x4219, 0x00},
+	{0x421A, 0x00},
+	{0x421B, 0x01},
+	{0x421C, 0x00},
+	{0x421D, 0x00},
+	{0x421E, 0x02},
+	{0x4220, 0x00},
+	{0x4221, 0x00},
+	{0x4222, 0x00},
+	{0x4223, 0x00},
+	{0x4224, 0x00},
+	{0x4225, 0x00},
+	{0x4226, 0x00},
+	{0x4227, 0x00},
+	{0x4228, 0x00},
+	{0x4229, 0x00},
+	{0x422A, 0x21},
+	{0x422B, 0xAA},
+	{0x422C, 0x00},
+	{0x422D, 0x00},
+	{0x422E, 0x00},
+	{0x422F, 0x00},
+	{0x4230, 0x00},
+	{0x4231, 0x00},
+	{0x4232, 0x00},
+	{0x4233, 0x00},
+	{0x4234, 0x00},
+	{0x4235, 0x00},
+	{0x4236, 0x00},
+	{0x4237, 0x00},
+	{0x4238, 0x00},
+	{0x4239, 0x00},
+	{0x423A, 0x00},
+	{0x423B, 0x00},
+	{0x423C, 0x00},
+	{0x423D, 0x00},
+	{0x423E, 0x00},
+	{0x423F, 0x00},
+	{0x4240, 0x00},
+	{0x4241, 0x00},
+	{0x4242, 0x00},
+	{0x4243, 0x00},
+	{0x4244, 0x00},
+	{0x4245, 0x00},
+	{0x4246, 0x00},
+	{0x4247, 0x00},
+	{0x4248, 0x00},
+	{0x4249, 0x00},
+	{0x424A, 0x00},
+	{0x424B, 0x00},
+	{0x424C, 0x00},
+	{0x424D, 0x00},
+	{0x424E, 0x00},
+	{0x424F, 0x00},
+	{0x4250, 0x00},
+	{0x4251, 0x00},
+	{0x4252, 0x00},
+	{0x4253, 0x00},
+	{0x4254, 0x00},
+	{0x4255, 0x00},
+	{0x4256, 0x00},
+	{0x4257, 0x03},
+	{0x4258, 0x00},
+	{0x4259, 0x00},
+	{0x425A, 0x00},
+	{0x425B, 0x01},
+	{0x425C, 0x00},
+	{0x425D, 0x03},
+	{0x425E, 0x00},
+	{0x425F, 0x00},
+	{0x4260, 0x00},
+	{0x4261, 0x00},
+	{0x4262, 0x00},
+	{0x4263, 0x00},
+	{0x4264, 0x00},
+	{0x4265, 0x00},
+	{0x4266, 0x00},
+	{0x4267, 0x00},
+	{0x4268, 0x00},
+	{0x4269, 0x00},
+	{0x4301, 0x00},
+	{0x4302, 0x04},
+	{0x4303, 0x64},
+	{0x4304, 0x03},
+	{0x4305, 0x38},
+	{0x4307, 0x01},
+	{0x4308, 0x00},
+	{0x4309, 0x00},
+	{0x430A, 0x00},
+	{0x430B, 0x00},
+	{0x430C, 0x00},
+	{0x430D, 0x01},
+	{0x430E, 0x00},
+	{0x430F, 0x00},
+	{0x4310, 0x00},
+	{0x4311, 0x00},
+	{0x4312, 0x00},
+	{0x4313, 0x00},
+	{0x4314, 0x00},
+	{0x4315, 0x01},
+	{0x4316, 0x00},
+	{0x4317, 0x01},
+	{0x4318, 0x23},
+	{0x4319, 0x07},
+	{0x431A, 0x00},
+	{0x431B, 0x02},
+	{0x431C, 0x00},
+	{0x431D, 0x02},
+	{0x431E, 0x00},
+	{0x431F, 0x02},
+	{0x4320, 0x00},
+	{0x4321, 0x00},
+	{0x4322, 0x00},
+	{0x4324, 0x04},
+	{0x4325, 0x61},
+	{0x4326, 0x04},
+	{0x4327, 0x2D},
+	{0x4328, 0x04},
+	{0x4329, 0x60},
+	{0x432A, 0x04},
+	{0x432B, 0x56},
+	{0x432C, 0x04},
+	{0x432D, 0x57},
+	{0x432E, 0x04},
+	{0x432F, 0x5F},
+	{0x4330, 0x04},
+	{0x4331, 0x60},
+	{0x4332, 0x04},
+	{0x4333, 0x61},
+	{0x4334, 0x04},
+	{0x4335, 0x61},
+	{0x4336, 0x00},
+	{0x4338, 0x10},
+	{0x4339, 0x00},
+	{0x433A, 0x00},
+	{0x433B, 0x02},
+	{0x433C, 0x00},
+	{0x433D, 0x02},
+	{0x433E, 0x53},
+	{0x433F, 0x53},
+	{0x4340, 0x00},
+	{0x4341, 0x00},
+	{0x4342, 0x00},
+	{0x4343, 0x3C},
+	{0x4344, 0x00},
+	{0x4345, 0x06},
+	{0x4346, 0x02},
+	{0x4347, 0x00},
+	{0x4348, 0x00},
+	{0x434A, 0x00},
+	{0x434B, 0x00},
+	{0x434C, 0x00},
+	{0x434D, 0x00},
+	{0x434E, 0x00},
+	{0x4350, 0x00},
+	{0x4351, 0x0F},
+	{0x4352, 0x00},
+	{0x4353, 0x5A},
+	{0x4354, 0x00},
+	{0x4355, 0x00},
+	{0x4356, 0x00},
+	{0x4357, 0x00},
+	{0x4358, 0x00},
+	{0x4360, 0x00},
+	{0x4361, 0x39},
+	{0x4400, 0xBE},
+	{0x4401, 0x67},
+	{0x4402, 0x00},
+	{0x4403, 0x52},
+	{0x4404, 0x00},
+	{0x4405, 0x0F},
+	{0x4406, 0x01},
+	{0x4407, 0x83},
+	{0x4408, 0x00},
+	{0x4409, 0x00},
+	{0x440A, 0x18},
+	{0x440B, 0x1B},
+	{0x440C, 0x00},
+	{0x440D, 0x00},
+	{0x440E, 0x00},
+	{0x440F, 0x00},
+	{0x4410, 0x00},
+	{0x4411, 0x00},
+	{0x4412, 0x01},
+	{0x4413, 0x00},
+	{0x4414, 0x00},
+	{0x4415, 0x06},
+	{0x4417, 0x00},
+	{0x4418, 0x00},
+	{0x4419, 0x00},
+	{0x441A, 0x00},
+	{0x441B, 0x01},
+	{0x441C, 0x00},
+	{0x441D, 0x1B},
+	{0x441F, 0x0B},
+	{0x4420, 0x01},
+	{0x4421, 0x83},
+	{0x4423, 0x0B},
+	{0x4424, 0x01},
+	{0x4425, 0x83},
+	{0x4427, 0x0B},
+	{0x4428, 0x01},
+	{0x4429, 0x83},
+	{0x442A, 0x00},
+	{0x442B, 0x00},
+	{0x442C, 0x01},
+	{0x442D, 0x07},
+	{0x442E, 0x00},
+	{0x442F, 0x00},
+	{0x4430, 0x01},
+	{0x4431, 0x00},
+	{0x4432, 0x01},
+	{0x4433, 0x08},
+	{0x4434, 0x01},
+	{0x4435, 0x07},
+	{0x4436, 0x00},
+	{0x4437, 0x00},
+	{0x4438, 0x01},
+	{0x4439, 0x00},
+	{0x443A, 0x00},
+	{0x443B, 0x08},
+	{0x443C, 0x01},
+	{0x443D, 0x00},
+	{0x443E, 0x00},
+	{0x443F, 0x08},
+	{0x4441, 0x00},
+	{0x4442, 0x00},
+	{0x4443, 0x00},
+	{0x4444, 0x00},
+	{0x4445, 0x00},
+	{0x4446, 0x02},
+	{0x4447, 0x09},
+	{0x4448, 0x00},
+	{0x4449, 0x00},
+	{0x444A, 0x00},
+	{0x444B, 0x00},
+	{0x444C, 0x00},
+	{0x444D, 0x00},
+	{0x444E, 0x00},
+	{0x444F, 0x01},
+	{0x4450, 0x01},
+	{0x4451, 0x83},
+	{0x4452, 0x03},
+	{0x4453, 0x00},
+	{0x4454, 0x00},
+	{0x4455, 0x00},
+	{0x4457, 0x00},
+	{0x4458, 0x00},
+	{0x4459, 0x18},
+	{0x445A, 0x18},
+	{0x445B, 0x18},
+	{0x445C, 0x00},
+	{0x445D, 0x00},
+	{0x445E, 0x00},
+	{0x445F, 0x00},
+	{0x4460, 0x00},
+	{0x4461, 0x00},
+	{0x4462, 0x01},
+	{0x4463, 0x00},
+	{0x4464, 0x03},
+	{0x4465, 0x00},
+	{0x4466, 0x00},
+	{0x4467, 0x00},
+	{0x4468, 0x00},
+	{0x4469, 0x00},
+	{0x446A, 0x00},
+	{0x446B, 0x00},
+	{0x446C, 0x00},
+	{0x446D, 0x00},
+	{0x446E, 0x00},
+	{0x446F, 0x00},
+	{0x4470, 0x0A},
+	{0x4471, 0x00},
+	{0x4472, 0x00},
+	{0x4473, 0x00},
+	{0x4475, 0x00},
+	{0x4476, 0x00},
+	{0x4477, 0x00},
+	{0x4479, 0x00},
+	{0x447A, 0x00},
+	{0x447B, 0x00},
+	{0x447C, 0x00},
+	{0x447D, 0x00},
+	{0x447E, 0x01},
+	{0x447F, 0x01},
+	{0x4480, 0x00},
+	{0x4481, 0x1B},
+	{0x4482, 0x00},
+	{0x4483, 0x19},
+	{0x4484, 0x00},
+	{0x4485, 0x00},
+	{0x4486, 0x01},
+	{0x4487, 0x07},
+	{0x4488, 0x00},
+	{0x4489, 0x00},
+	{0x448A, 0x01},
+	{0x448B, 0x00},
+	{0x448C, 0x00},
+	{0x448D, 0x08},
+	{0x448E, 0x01},
+	{0x448F, 0x07},
+	{0x4490, 0x00},
+	{0x4491, 0x00},
+	{0x4492, 0x01},
+	{0x4493, 0x00},
+	{0x4494, 0x01},
+	{0x4495, 0x08},
+	{0x4496, 0x01},
+	{0x4497, 0x00},
+	{0x4498, 0x00},
+	{0x4499, 0x08},
+	{0x449B, 0x0B},
+	{0x449C, 0x01},
+	{0x449D, 0x83},
+	{0x449F, 0x0B},
+	{0x44A0, 0x01},
+	{0x44A1, 0x83},
+	{0x44A2, 0x00},
+	{0x44A3, 0x00},
+	{0x44A4, 0x00},
+	{0x44A5, 0x00},
+	{0x44A6, 0x00},
+	{0x44A7, 0x00},
+	{0x44A8, 0x18},
+	{0x44A9, 0x18},
+	{0x44AA, 0x00},
+	{0x44AB, 0x1B},
+	{0x44AC, 0x00},
+	{0x44AD, 0x00},
+	{0x44AE, 0x00},
+	{0x44AF, 0x01},
+	{0x4500, 0x00},
+	{0x4501, 0x19},
+	{0x4502, 0x81},
+	{0x4503, 0x0B},
+	{0x4504, 0x00},
+	{0x4505, 0x73},
+	{0x4506, 0x03},
+	{0x4507, 0x18},
+	{0x4508, 0x00},
+	{0x4509, 0x05},
+	{0x450A, 0x00},
+	{0x450B, 0x8B},
+	{0x450C, 0xD8},
+	{0x450E, 0x00},
+	{0x450F, 0x00},
+	{0x4511, 0x00},
+	{0x4512, 0x00},
+	{0x4513, 0x01},
+	{0x4515, 0x00},
+	{0x4516, 0x00},
+	{0x4517, 0x01},
+	{0x4519, 0x00},
+	{0x451A, 0x00},
+	{0x451B, 0x00},
+	{0x451D, 0x00},
+	{0x451E, 0x00},
+	{0x451F, 0x00},
+	{0x4520, 0x0F},
+	{0x4521, 0x00},
+	{0x4522, 0x07},
+	{0x4523, 0x16},
+	{0x4524, 0x00},
+	{0x4525, 0x01},
+	{0x4527, 0x00},
+	{0x4528, 0x00},
+	{0x4529, 0x01},
+	{0x452B, 0x00},
+	{0x452C, 0x00},
+	{0x452D, 0x00},
+	{0x452E, 0x00},
+	{0x452F, 0x00},
+	{0x4530, 0x0C},
+	{0x4531, 0x3E},
+	{0x4532, 0x0D},
+	{0x4533, 0x02},
+	{0x4534, 0x0D},
+	{0x4535, 0x04},
+	{0x4537, 0x0D},
+	{0x4538, 0x00},
+	{0x4539, 0x00},
+	{0x453B, 0x00},
+	{0x453C, 0x00},
+	{0x453D, 0x00},
+	{0x453F, 0x0D},
+	{0x4540, 0x00},
+	{0x4541, 0x03},
+	{0x4543, 0x00},
+	{0x4544, 0x00},
+	{0x4545, 0x03},
+	{0x4547, 0x0D},
+	{0x4548, 0x00},
+	{0x4549, 0x00},
+	{0x454B, 0x00},
+	{0x454C, 0x00},
+	{0x454D, 0x00},
+	{0x454E, 0x0B},
+	{0x454F, 0x0F},
+	{0x4550, 0x0E},
+	{0x4551, 0x0A},
+	{0x4552, 0x00},
+	{0x4553, 0x05},
+	{0x4554, 0x00},
+	{0x4555, 0x32},
+	{0x4557, 0x00},
+	{0x4558, 0x00},
+	{0x4559, 0x32},
+	{0x455B, 0x00},
+	{0x455C, 0x02},
+	{0x455D, 0x0F},
+	{0x455E, 0x05},
+	{0x455F, 0x0B},
+	{0x4560, 0x03},
+	{0x4561, 0x09},
+	{0x4562, 0x07},
+	{0x4563, 0x18},
+	{0x4564, 0x00},
+	{0x4565, 0x00},
+	{0x4566, 0x00},
+	{0x4567, 0x06},
+	{0x4569, 0x01},
+	{0x456A, 0x02},
+	{0x456B, 0x0A},
+	{0x456C, 0x00},
+	{0x456D, 0x06},
+	{0x456F, 0x06},
+	{0x4570, 0x05},
+	{0x4571, 0x08},
+	{0x4572, 0x0C},
+	{0x4573, 0x08},
+	{0x4574, 0x00},
+	{0x4575, 0x02},
+	{0x4577, 0x00},
+	{0x4578, 0x00},
+	{0x4579, 0x02},
+	{0x457B, 0x02},
+	{0x457C, 0x04},
+	{0x457D, 0x0D},
+	{0x457E, 0x09},
+	{0x457F, 0x18},
+	{0x4581, 0x01},
+	{0x4582, 0x01},
+	{0x4583, 0x18},
+	{0x4584, 0x00},
+	{0x4585, 0x03},
+	{0x4586, 0x00},
+	{0x4587, 0x01},
+	{0x4588, 0x00},
+	{0x4589, 0x08},
+	{0x458A, 0x0D},
+	{0x458B, 0x02},
+	{0x458C, 0x0D},
+	{0x458D, 0x0F},
+	{0x458F, 0x00},
+	{0x4590, 0x00},
+	{0x4591, 0x00},
+	{0x4600, 0x08},
+	{0x4601, 0x60},
+	{0x4602, 0x00},
+	{0x4603, 0x21},
+	{0x4604, 0x00},
+	{0x4605, 0x0F},
+	{0x4606, 0x00},
+	{0x4607, 0xA3},
+	{0x4608, 0x00},
+	{0x4609, 0x00},
+	{0x460A, 0x18},
+	{0x460B, 0x1B},
+	{0x460C, 0x00},
+	{0x460D, 0x00},
+	{0x460E, 0x00},
+	{0x460F, 0x00},
+	{0x4610, 0x00},
+	{0x4611, 0x00},
+	{0x4700, 0x00},
+	{0x4701, 0x19},
+	{0x4702, 0x2E},
+	{0x4703, 0x0B},
+	{0x4704, 0x00},
+	{0x4705, 0x24},
+	{0x4706, 0x03},
+	{0x4707, 0x18},
+	{0x4708, 0x00},
+	{0x4709, 0x17},
+	{0x470A, 0x00},
+	{0x470B, 0xD1},
+	{0x470C, 0x18},
+	{0x470E, 0x00},
+	{0x470F, 0x00},
+	{0x5000, 0x00},
+	{0x5001, 0x00},
+	{0x5002, 0x07},
+	{0x5003, 0xC0},
+	{0x5004, 0x00},
+	{0x5005, 0x02},
+	{0x5006, 0x00},
+	{0x5007, 0x0C},
+	{0x5008, 0x00},
+	{0x5009, 0x24},
+	{0x500A, 0x10},
+	{0x500B, 0x3C},
+	{0x500C, 0x00},
+	{0x500D, 0x0D},
+	{0x500E, 0x10},
+	{0x500F, 0x00},
+	{0x5011, 0x01},
+	{0x5012, 0x07},
+	{0x5013, 0xFF},
+	{0x5014, 0x01},
+	{0x5015, 0x11},
+	{0x5016, 0x10},
+	{0x5017, 0xE4},
+	{0x5018, 0x10},
+	{0x5019, 0xE4},
+	{0x501A, 0x10},
+	{0x501B, 0xE4},
+	{0x501C, 0x11},
+	{0x501D, 0xC8},
+	{0x501E, 0x13},
+	{0x501F, 0x90},
+	{0x5020, 0x17},
+	{0x5021, 0x20},
+	{0x5022, 0x18},
+	{0x5023, 0x68},
+	{0x5024, 0x10},
+	{0x5025, 0xE4},
+	{0x5026, 0x10},
+	{0x5027, 0xE4},
+	{0x5028, 0x10},
+	{0x5029, 0xE4},
+	{0x502A, 0x11},
+	{0x502B, 0xC8},
+	{0x502C, 0x13},
+	{0x502D, 0x90},
+	{0x502E, 0x17},
+	{0x502F, 0x20},
+	{0x5030, 0x18},
+	{0x5031, 0x68},
+	{0x5032, 0x07},
+	{0x5033, 0xFF},
+	{0x5034, 0x07},
+	{0x5035, 0xFF},
+	{0x5036, 0x22},
+	{0x5037, 0x00},
+	{0x5039, 0x03},
+	{0x503A, 0x00},
+	{0x503B, 0x02},
+	{0x503C, 0x00},
+	{0x503D, 0x0A},
+	{0x503E, 0x01},
+	{0x503F, 0xD4},
+	{0x5040, 0x0A},
+	{0x5041, 0x0A},
+	{0x5043, 0x03},
+	{0x5044, 0x01},
+	{0x5045, 0x30},
+	{0x5046, 0xC1},
+	{0x5047, 0x00},
+	{0x5048, 0x00},
+	{0x5049, 0x00},
+	{0x5053, 0x11},
+	{0x5054, 0x01},
+	{0x5055, 0xA2},
+	{0x5056, 0x01},
+	{0x5057, 0xFF},
+	{0x505C, 0x78},
+	{0x505D, 0x00},
+	{0x505E, 0x00},
+	{0x505F, 0x00},
+	{0x5061, 0x00},
+	{0x5062, 0x0F},
+	{0x5063, 0xFE},
+	{0x5064, 0x00},
+	{0x5065, 0x01},
+	{0x5066, 0x01},
+	{0x5067, 0x00},
+	{0x5068, 0x00},
+	{0x5069, 0x06},
+	{0x506B, 0x8E},
+	{0x506C, 0x00},
+	{0x506D, 0x00},
+	{0x506E, 0x00},
+	{0x506F, 0x00},
+	{0x5070, 0x00},
+	{0x5071, 0x00},
+	{0x5072, 0x00},
+	{0x5073, 0x00},
+	{0x5074, 0x00},
+	{0x5075, 0x00},
+	{0x5076, 0x00},
+	{0x5077, 0x00},
+	{0x5078, 0x00},
+	{0x5079, 0x40},
+	{0x5090, 0x00},
+	{0x5091, 0x00},
+	{0x5096, 0x00},
+	{0x5097, 0x00},
+	{0x5098, 0x00},
+	{0x5099, 0x00},
+	{0x509A, 0x00},
+	{0x509B, 0x00},
+	{0x509C, 0x00},
+	{0x509D, 0x00},
+	{0x509E, 0x00},
+	{0x509F, 0x00},
+	{0x50A0, 0x00},
+	{0x50A1, 0x00},
+	{0x50A2, 0x00},
+	{0x50A3, 0x00},
+	{0x50A4, 0x00},
+	{0x50A5, 0x00},
+	{0x50A6, 0x00},
+	{0x50A7, 0x00},
+	{0x50A8, 0x00},
+	{0x50D0, 0x55},
+	{0x50D1, 0x00},
+	{0x50D2, 0x00},
+	{0x50D3, 0x00},
+	{0x50F1, 0x00},
+	{0x50F2, 0x40},
+	{0x50F3, 0x71},
+	{0x50F4, 0x11},
+	{0x50F5, 0x71},
+	{0x50F6, 0x03},
+	{0x50F7, 0xD0},
+	{0x50F8, 0x00},
+	{0x50F9, 0x00},
+	{0x50FA, 0x0A},
+	{0x50FB, 0x00},
+	{0x50FC, 0x00},
+	{0x50FD, 0x00},
+	{0x5100, 0x00},
+	{0x5101, 0x05},
+	{0x5102, 0x02},
+	{0x5103, 0x01},
+	{0x5104, 0x04},
+	{0x5105, 0x03},
+	{0x5108, 0x00},
+	{0x5109, 0x01},
+	{0x510A, 0x02},
+	{0x510B, 0x03},
+	{0x510C, 0x04},
+	{0x510D, 0x05},
+	{0x5110, 0x00},
+
+	/* sync code */
+	{0x5111, 0x4B},
+	{0x5112, 0x20},
+/*
+	{0x5114, 0x0A},
+	{0x5115, 0xB0},
+	{0x5116, 0x0B},
+	{0x5117, 0x60},
+	{0x5118, 0x08},
+	{0x5119, 0x00},
+	{0x511A, 0x09},
+	{0x511B, 0xD0},
+*/
+	{0x5120, 0x2C},
+	{0x5121, 0x13},
+	{0x5122, 0x12},
+	{0x5123, 0x10},
+	{0x5124, 0x00},
+	{0x5125, 0x00},
+	{0x5126, 0x05},
+	{0x5127, 0x00},
+	{0x5129, 0x50},
+	{0x5130, 0x03},
+	{0x5131, 0x14},
+	{0x5132, 0x04},
+	{0x5133, 0x01},
+	{0x5134, 0x0B},
+	{0x5135, 0x08},
+	{0x5136, 0x04},
+	{0x5137, 0x04},
+	{0x5138, 0x09},
+	{0x5139, 0x05},
+	{0x513A, 0x00},
+	{0x513B, 0x09},
+	{0x513D, 0xE4},
+	{0x513E, 0x00},
+	{0x513F, 0x00},
+	{0x5140, 0x04},
+	{0x5141, 0x54},
+	{0x5142, 0x00},
+	{0x5143, 0x00},
+	{0x5144, 0x04},
+	{0x5145, 0x53},
+/*
+	{0x5146, 0x0A},
+	{0x5147, 0xB4},
+	{0x5148, 0x0B},
+	{0x5149, 0x64},
+	{0x514A, 0x08},
+	{0x514B, 0x04},
+	{0x514C, 0x09},
+	{0x514D, 0xD4},
+	{0x514E, 0x0A},
+	{0x514F, 0xB8},
+	{0x5150, 0x0B},
+	{0x5151, 0x68},
+	{0x5152, 0x08},
+	{0x5153, 0x08},
+	{0x5154, 0x09},
+	{0x5155, 0xD8},
+	{0x5156, 0x00},
+	{0x5157, 0x02},
+	{0x5158, 0x00},
+	{0x5159, 0x03},
+	{0x515A, 0x00},
+	{0x515B, 0x00},
+	{0x515C, 0x00},
+	{0x515D, 0x01},
+*/
+	{0x5160, 0x00},
+	{0x5161, 0x00},
+	{0x5162, 0x00},
+	{0x5163, 0x00},
+	{0x5164, 0x00},
+	{0x5165, 0x00},
+	{0x5166, 0x00},
+	{0x5167, 0x00},
+	{0x5168, 0x00},
+	{0x5169, 0x00},
+	{0x516A, 0x00},
+	{0x516B, 0x00},
+	{0x516C, 0x00},
+	{0x516D, 0x00},
+	{0x516E, 0x00},
+	{0x516F, 0x00},
+	{0x5170, 0x00},
+	{0x5171, 0x00},
+	{0x5172, 0x00},
+	{0x5173, 0x00},
+	{0x5174, 0x00},
+	{0x5175, 0x00},
+	{0x5176, 0x00},
+	{0x5177, 0x00},
+	{0x5178, 0xE4},
+	{0x5179, 0x00},
+	{0x517A, 0x04},
+	{0x517B, 0x50},
+	{0x517C, 0x00},
+	{0x517D, 0x00},
+	{0x517E, 0x00},
+	{0x5180, 0x00},
+	{0x5181, 0x00},
+	{0x5182, 0x00},
+	{0x5183, 0x00},
+	{0x5184, 0x00},
+	{0x5186, 0x00},
+	{0x5187, 0x00},
+	{0x5188, 0x00},
+	{0x5189, 0x00},
+	{0x518A, 0x00},
+	{0x518B, 0x00},
+	{0x518D, 0x00},
+	{0x518E, 0x00},
+	{0x518F, 0x00},
+	{0x5190, 0x00},
+	{0x5191, 0x00},
+	{0x5192, 0x00},
+	{0x5194, 0x00},
+	{0x5195, 0x00},
+	{0x5196, 0x00},
+	{0x5197, 0x00},
+	{0x5198, 0x00},
+	{0x5199, 0x00},
+	{0x519B, 0x00},
+	{0x519E, 0xFF},
+	{0x519F, 0xFE},
+	{0x51A0, 0x00},
+	{0x51A1, 0x01},
+	{0x51A2, 0x03},
+	{0x51A3, 0x00},
+	{0x603D, 0x00},
+	{0x603D, 0x01},
+	{0x6000, 0x04},
+	{0x6001, 0xF8},
+	{0x6026, 0x04},
+	{0x6027, 0xF7},
+	{0x3000, 0x01},
+	{0x3001, 0xD3},
+	{0x3000, 0x21},
+	{0x3001, 0xD3},
+};
+
+static struct vin_reg_16_8 mn34420pl_2x_hdr_mode_regs[] = {
+	/* VCYCLE:1500 HCYCLE:1200 (@MCLK) */
+	{0x300C, 0x08},
+	{0x300D, 0x20},
+	{0x300E, 0x00},
+	{0x300F, 0x03},
+	{0x3002, 0x31},
+	{0x3003, 0x00},
+	{0x3004, 0x10},
+	{0x3005, 0x58},
+	{0x3006, 0x02},
+	{0x3007, 0xC0},
+	{0x3008, 0x35},
+	{0x3009, 0x80},
+	{0x300A, 0xCF},
+	{0x300B, 0x30},
+	{0x3000, 0x01},
+	{0x3001, 0x03},
+	{0x3000, 0x01},
+	{0x3001, 0x53},
+	{0x300E, 0x00},
+	{0x300F, 0x00},
+	{0x3200, 0x3F},
+	{0x3201, 0x06},
+	{0x3202, 0x0B},
+	{0x3203, 0x0B},
+	{0x3204, 0x14},
+	{0x3205, 0x00},
+	{0x3206, 0xA7},
+	{0x3207, 0x78},
+	{0x3208, 0x49},
+	{0x320A, 0x00},
+	{0x3010, 0x00},
+	{0x3012, 0x00},
+	{0x3013, 0x03},
+	{0x3014, 0x00},
+	{0x3015, 0x00},
+	{0x3016, 0x00},
+	{0x3017, 0xF0},
+	{0x3018, 0x00},
+	{0x3019, 0x00},
+	{0x301A, 0x00},
+	{0x301B, 0x00},
+	{0x301C, 0x00},
+	{0x301D, 0x00},
+	{0x301E, 0x00},
+	{0x301F, 0x00},
+	{0x3020, 0x00},
+	{0x3021, 0x1A},
+	{0x3022, 0x38},
+	{0x3023, 0x00},
+	{0x3024, 0x00},
+	{0x3025, 0x00},
+	{0x3026, 0x20},
+	{0x3027, 0x00},
+	{0x3028, 0x00},
+	{0x3029, 0x00},
+	{0x302A, 0xFF},
+	{0x302B, 0x1F},
+	{0x302C, 0x08},
+	{0x302D, 0x04},
+	{0x302E, 0x00},
+	{0x302F, 0x00},
+	{0x3030, 0x5E},
+	{0x3031, 0x05},
+	{0x3032, 0x00},
+	{0x3033, 0x00},
+	{0x3035, 0x60},
+	{0x3036, 0x00},
+	{0x3037, 0x00},
+	{0x3039, 0x60},
+	{0x303B, 0x00},
+	{0x303D, 0x00},
+	{0x3040, 0x00},
+	{0x3041, 0x00},
+	{0x3042, 0x42},
+	{0x3043, 0x00},
+	{0x3044, 0x32},
+	{0x3045, 0x00},
+	{0x3046, 0x49},
+	{0x3047, 0x00},
+	{0x3048, 0x00},
+	{0x3049, 0x30},
+	{0x304A, 0xE2},
+	{0x304B, 0x01},
+	{0x304C, 0x31},
+	{0x304D, 0x33},
+	{0x304E, 0x22},
+	{0x304F, 0x33},
+	{0x3050, 0x00},
+	{0x3051, 0x50},
+	{0x3052, 0x00},
+	{0x3053, 0x00},
+	{0x3054, 0x00},
+	{0x3055, 0x00},
+	{0x3056, 0x04},
+	{0x3057, 0x00},
+	{0x3058, 0x7F},
+	{0x3059, 0x7F},
+	{0x305A, 0x7F},
+	{0x305B, 0x03},
+	{0x3060, 0x00},
+	{0x3061, 0x00},
+	{0x3062, 0x00},
+	{0x3063, 0x00},
+	{0x3100, 0x01},
+	{0x3101, 0x20},
+	{0x3102, 0x01},
+	{0x3103, 0x20},
+	{0x3104, 0x02},
+	{0x3105, 0xEE},
+	{0x3107, 0x00},
+	{0x3108, 0x01},
+	{0x3109, 0x20},
+	{0x310A, 0x01},
+	{0x310B, 0x20},
+	{0x310C, 0x00},
+	{0x310D, 0x01},
+	{0x3110, 0x01},
+	{0x3111, 0x20},
+	{0x3112, 0x01},
+	{0x3113, 0x20},
+	{0x3114, 0x00},
+	{0x3115, 0x16},
+	{0x3116, 0x01},
+	{0x3117, 0x20},
+	{0x3118, 0x01},
+	{0x3119, 0x20},
+	{0x311A, 0x00},
+	{0x311B, 0x16},
+	{0x311C, 0x00},
+	{0x3120, 0x00},
+	{0x3121, 0x3C},
+	{0x3122, 0x04},
+	{0x3123, 0x7F},
+	{0x3124, 0x00},
+	{0x3125, 0x00},
+	{0x3126, 0x04},
+	{0x3127, 0x54},
+	{0x3131, 0x00},
+	{0x3140, 0x00},
+	{0x3141, 0xE0},
+	{0x3142, 0x00},
+	{0x3143, 0xC7},
+	{0x3151, 0x40},
+	{0x3152, 0x00},
+	{0x3153, 0x00},
+	{0x3154, 0x00},
+	{0x3155, 0x00},
+	{0x3156, 0x00},
+	{0x3157, 0x00},
+	{0x3159, 0x00},
+	{0x3161, 0x40},
+	{0x3162, 0x00},
+	{0x3163, 0x00},
+	{0x3164, 0x00},
+	{0x3165, 0x00},
+	{0x3166, 0x00},
+	{0x3167, 0x00},
+	{0x3169, 0x00},
+	{0x3170, 0x08},
+	{0x3171, 0x00},
+	{0x3172, 0x08},
+	{0x3173, 0x00},
+	{0x4000, 0x00},
+	{0x4001, 0x02},
+	{0x4002, 0x01},
+	{0x4003, 0x07},
+	{0x4004, 0x00},
+	{0x4005, 0x13},
+	{0x4006, 0x00},
+	{0x4007, 0x01},
+	{0x4008, 0x00},
+	{0x4009, 0x00},
+	{0x400A, 0x07},
+	{0x400B, 0x00},
+	{0x400C, 0x00},
+	{0x400D, 0x00},
+	{0x400E, 0x08},
+	{0x400F, 0x00},
+	{0x4010, 0x04},
+	{0x4012, 0x00},
+	{0x4013, 0x25},
+	{0x4014, 0x17},
+	{0x4015, 0x10},
+	{0x4016, 0x40},
+	{0x4017, 0xFF},
+	{0x4018, 0xC0},
+	{0x401A, 0x00},
+	{0x401B, 0x38},
+	{0x401C, 0x00},
+	{0x401D, 0x38},
+	{0x401E, 0x00},
+	{0x401F, 0x28},
+	{0x4020, 0x00},
+	{0x4021, 0x38},
+	{0x4022, 0x00},
+	{0x4023, 0x28},
+	{0x4024, 0x00},
+	{0x4025, 0x29},
+	{0x4026, 0x00},
+	{0x4027, 0x29},
+	{0x4028, 0x00},
+	{0x4029, 0x29},
+	{0x402A, 0x00},
+	{0x402B, 0x29},
+	{0x402C, 0x00},
+	{0x402D, 0x2B},
+	{0x402E, 0x00},
+	{0x402F, 0x2B},
+	{0x4030, 0x00},
+	{0x4031, 0x2A},
+	{0x4032, 0x00},
+	{0x4033, 0x2E},
+	{0x4034, 0x00},
+	{0x4035, 0x2F},
+	{0x4036, 0x00},
+	{0x4037, 0x2D},
+	{0x4038, 0x00},
+	{0x4039, 0x2D},
+	{0x403A, 0x00},
+	{0x403B, 0x2F},
+	{0x403C, 0x00},
+	{0x403D, 0x2F},
+	{0x403E, 0x00},
+	{0x403F, 0x2E},
+	{0x4040, 0x00},
+	{0x4041, 0x2D},
+	{0x4042, 0x00},
+	{0x4043, 0x25},
+	{0x4044, 0x00},
+	{0x4045, 0x27},
+	{0x4046, 0x00},
+	{0x4047, 0x27},
+	{0x4048, 0x00},
+	{0x4049, 0x00},
+	{0x404A, 0x1F},
+	{0x404B, 0x1F},
+	{0x404C, 0x1F},
+	{0x404D, 0x06},
+	{0x404E, 0x08},
+	{0x404F, 0x12},
+	{0x4050, 0x0F},
+	{0x4051, 0x0C},
+	{0x4052, 0x0B},
+	{0x4053, 0x0A},
+	{0x4054, 0x08},
+	{0x4055, 0x07},
+	{0x4056, 0x06},
+	{0x4057, 0x04},
+	{0x4058, 0x01},
+	{0x4059, 0x00},
+	{0x405A, 0x00},
+	{0x405B, 0x00},
+	{0x405C, 0x00},
+	{0x405D, 0x00},
+	{0x405E, 0x00},
+	{0x405F, 0x00},
+	{0x4060, 0xFF},
+	{0x4061, 0x07},
+	{0x4062, 0x77},
+	{0x4063, 0x00},
+	{0x4064, 0x44},
+	{0x4066, 0x0C},
+	{0x4067, 0x0C},
+	{0x4068, 0x00},
+	{0x4069, 0x00},
+	{0x406A, 0x00},
+	{0x406B, 0x00},
+	{0x406C, 0x00},
+	{0x406D, 0x00},
+	{0x406E, 0x00},
+	{0x4070, 0x00},
+	{0x4071, 0x00},
+	{0x4072, 0x00},
+	{0x4073, 0x00},
+	{0x4100, 0x10},
+	{0x4101, 0x32},
+	{0x4102, 0x54},
+	{0x4103, 0x76},
+	{0x4104, 0x8B},
+	{0x4105, 0x09},
+	{0x4106, 0x00},
+	{0x4107, 0x00},
+	{0x4108, 0x0A},
+	{0x4109, 0x88},
+	{0x410A, 0x00},
+	{0x410B, 0x00},
+	{0x410C, 0x00},
+	{0x410D, 0x82},
+	{0x410E, 0x22},
+	{0x410F, 0x00},
+	{0x4110, 0x00},
+	{0x4111, 0x22},
+	{0x4112, 0x00},
+	{0x4113, 0x00},
+	{0x4114, 0x3F},
+	{0x4115, 0x33},
+	{0x4116, 0xF6},
+	{0x4117, 0x3F},
+	{0x4118, 0x1C},
+	{0x4119, 0x15},
+	{0x411A, 0x26},
+	{0x411B, 0x00},
+	{0x411C, 0xBA},
+	{0x411D, 0x00},
+	{0x411E, 0x00},
+	{0x411F, 0x22},
+	{0x4120, 0x02},
+	{0x4121, 0x00},
+	{0x4122, 0x40},
+	{0x4124, 0x60},
+	{0x4125, 0x88},
+	{0x4126, 0x00},
+	{0x4127, 0x00},
+	{0x4128, 0x90},
+	{0x4129, 0x99},
+	{0x412A, 0x00},
+	{0x412B, 0x00},
+	{0x412C, 0x00},
+	{0x412D, 0x00},
+	{0x412E, 0x00},
+	{0x412F, 0x00},
+	{0x4130, 0x00},
+	{0x4131, 0x00},
+	{0x4132, 0x00},
+	{0x4133, 0x00},
+	{0x4134, 0x00},
+	{0x4135, 0x00},
+	{0x4136, 0x00},
+	{0x4137, 0x00},
+	{0x4138, 0x00},
+	{0x4139, 0x00},
+	{0x413A, 0x00},
+	{0x413B, 0x00},
+	{0x413C, 0x00},
+	{0x413D, 0x00},
+	{0x413E, 0x00},
+	{0x413F, 0x00},
+	{0x4140, 0x00},
+	{0x4141, 0x00},
+	{0x4142, 0x00},
+	{0x4143, 0x00},
+	{0x4144, 0x00},
+	{0x4145, 0x00},
+	{0x4146, 0x00},
+	{0x4147, 0x00},
+	{0x4148, 0x00},
+	{0x4149, 0x00},
+	{0x414A, 0x00},
+	{0x414B, 0x00},
+	{0x414C, 0x00},
+	{0x414D, 0x00},
+	{0x414E, 0x00},
+	{0x414F, 0x00},
+	{0x4150, 0x00},
+	{0x4151, 0x00},
+	{0x4152, 0x00},
+	{0x4153, 0x00},
+	{0x4154, 0x00},
+	{0x4155, 0x00},
+	{0x4156, 0x00},
+	{0x4157, 0x00},
+	{0x4158, 0x00},
+	{0x4159, 0x00},
+	{0x415A, 0x00},
+	{0x415B, 0x00},
+	{0x415C, 0x00},
+	{0x415D, 0x00},
+	{0x415E, 0x00},
+	{0x415F, 0x00},
+	{0x4200, 0x21},
+	{0x4201, 0x43},
+	{0x4202, 0x65},
+	{0x4203, 0x98},
+	{0x4204, 0x0A},
+	{0x4205, 0x00},
+	{0x4206, 0x00},
+	{0x4207, 0x00},
+	{0x4208, 0x08},
+	{0x4209, 0xAA},
+	{0x420A, 0x80},
+	{0x420B, 0x0A},
+	{0x420C, 0xA0},
+	{0x420D, 0x00},
+	{0x420E, 0x22},
+	{0x420F, 0xA8},
+	{0x4210, 0x02},
+	{0x4211, 0x00},
+	{0x4212, 0x00},
+	{0x4213, 0x00},
+	{0x4214, 0xF0},
+	{0x4215, 0x07},
+	{0x4216, 0x00},
+	{0x4217, 0x00},
+	{0x4218, 0x00},
+	{0x4219, 0x00},
+	{0x421A, 0x00},
+	{0x421B, 0x01},
+	{0x421C, 0x00},
+	{0x421D, 0x00},
+	{0x421E, 0x02},
+	{0x4220, 0x00},
+	{0x4221, 0x00},
+	{0x4222, 0x00},
+	{0x4223, 0x00},
+	{0x4224, 0x00},
+	{0x4225, 0x00},
+	{0x4226, 0x00},
+	{0x4227, 0x00},
+	{0x4228, 0x00},
+	{0x4229, 0x00},
+	{0x422A, 0x21},
+	{0x422B, 0xAA},
+	{0x422C, 0x00},
+	{0x422D, 0x00},
+	{0x422E, 0x00},
+	{0x422F, 0x00},
+	{0x4230, 0x00},
+	{0x4231, 0x00},
+	{0x4232, 0x00},
+	{0x4233, 0x00},
+	{0x4234, 0x00},
+	{0x4235, 0x00},
+	{0x4236, 0x00},
+	{0x4237, 0x00},
+	{0x4238, 0x00},
+	{0x4239, 0x00},
+	{0x423A, 0x00},
+	{0x423B, 0x00},
+	{0x423C, 0x00},
+	{0x423D, 0x00},
+	{0x423E, 0x00},
+	{0x423F, 0x00},
+	{0x4240, 0x00},
+	{0x4241, 0x00},
+	{0x4242, 0x00},
+	{0x4243, 0x00},
+	{0x4244, 0x00},
+	{0x4245, 0x00},
+	{0x4246, 0x00},
+	{0x4247, 0x00},
+	{0x4248, 0x00},
+	{0x4249, 0x00},
+	{0x424A, 0x00},
+	{0x424B, 0x00},
+	{0x424C, 0x00},
+	{0x424D, 0x00},
+	{0x424E, 0x00},
+	{0x424F, 0x00},
+	{0x4250, 0x00},
+	{0x4251, 0x00},
+	{0x4252, 0x00},
+	{0x4253, 0x00},
+	{0x4254, 0x00},
+	{0x4255, 0x00},
+	{0x4256, 0x00},
+	{0x4257, 0x03},
+	{0x4258, 0x00},
+	{0x4259, 0x00},
+	{0x425A, 0x00},
+	{0x425B, 0x01},
+	{0x425C, 0x00},
+	{0x425D, 0x03},
+	{0x425E, 0x00},
+	{0x425F, 0x00},
+	{0x4260, 0x00},
+	{0x4261, 0x00},
+	{0x4262, 0x00},
+	{0x4263, 0x00},
+	{0x4264, 0x00},
+	{0x4265, 0x00},
+	{0x4266, 0x00},
+	{0x4267, 0x00},
+	{0x4268, 0x00},
+	{0x4269, 0x00},
+	{0x4301, 0x10},
+	{0x4302, 0x05},
+	{0x4303, 0xDB},
+	{0x4304, 0x04},
+	{0x4305, 0xAF},
+	{0x4307, 0x01},
+	{0x4308, 0x02},
+	{0x4309, 0x55},
+	{0x430A, 0x00},
+	{0x430B, 0x00},
+	{0x430C, 0x00},
+	{0x430D, 0x01},
+	{0x430E, 0x00},
+	{0x430F, 0x00},
+	{0x4310, 0x00},
+	{0x4311, 0x00},
+	{0x4312, 0x00},
+	{0x4313, 0x00},
+	{0x4314, 0x00},
+	{0x4315, 0x01},
+	{0x4316, 0x00},
+	{0x4317, 0x01},
+	{0x4318, 0x23},
+	{0x4319, 0x07},
+	{0x431A, 0x00},
+	{0x431B, 0x02},
+	{0x431C, 0x00},
+	{0x431D, 0x02},
+	{0x431E, 0x00},
+	{0x431F, 0x02},
+	{0x4320, 0x00},
+	{0x4321, 0x00},
+	{0x4322, 0x00},
+	{0x4324, 0x04},
+	{0x4325, 0x61},
+	{0x4326, 0x05},
+	{0x4327, 0xA4},
+	{0x4328, 0x04},
+	{0x4329, 0x60},
+	{0x432A, 0x04},
+	{0x432B, 0x56},
+	{0x432C, 0x04},
+	{0x432D, 0x57},
+	{0x432E, 0x04},
+	{0x432F, 0x5F},
+	{0x4330, 0x04},
+	{0x4331, 0x60},
+	{0x4332, 0x00},
+	{0x4333, 0x00},
+	{0x4334, 0x00},
+	{0x4335, 0x00},
+	{0x4336, 0x00},
+	{0x4338, 0x10},
+	{0x4339, 0x00},
+	{0x433A, 0x00},
+	{0x433B, 0x02},
+	{0x433C, 0x00},
+	{0x433D, 0x02},
+	{0x433E, 0x53},
+	{0x433F, 0x53},
+	{0x4340, 0x00},
+	{0x4341, 0x00},
+	{0x4342, 0x00},
+	{0x4343, 0x2D},
+	{0x4344, 0x00},
+	{0x4345, 0x06},
+	{0x4346, 0x02},
+	{0x4347, 0x00},
+	{0x4348, 0x00},
+	{0x434A, 0x00},
+	{0x434B, 0x00},
+	{0x434C, 0x00},
+	{0x434D, 0x00},
+	{0x434E, 0x00},
+	{0x4350, 0x00},
+	{0x4351, 0x0F},
+	{0x4352, 0x00},
+	{0x4353, 0x5A},
+	{0x4354, 0x00},
+	{0x4355, 0x00},
+	{0x4356, 0x00},
+	{0x4357, 0x00},
+	{0x4358, 0x00},
+	{0x4360, 0x00},
+	{0x4361, 0x39},
+	{0x4400, 0x06},
+	{0x4401, 0x67},
+	{0x4402, 0x00},
+	{0x4403, 0x6E},
+	{0x4404, 0x00},
+	{0x4405, 0x0F},
+	{0x4406, 0x00},
+	{0x4407, 0xA1},
+	{0x4408, 0x00},
+	{0x4409, 0x00},
+	{0x440A, 0x18},
+	{0x440B, 0x1B},
+	{0x440C, 0x00},
+	{0x440D, 0x00},
+	{0x440E, 0x00},
+	{0x440F, 0x00},
+	{0x4410, 0x00},
+	{0x4411, 0x00},
+	{0x4412, 0x01},
+	{0x4413, 0x00},
+	{0x4414, 0x00},
+	{0x4415, 0x06},
+	{0x4417, 0x00},
+	{0x4418, 0x00},
+	{0x4419, 0x00},
+	{0x441A, 0x00},
+	{0x441B, 0x01},
+	{0x441C, 0x00},
+	{0x441D, 0x1B},
+	{0x441F, 0x1C},
+	{0x4420, 0x00},
+	{0x4421, 0xA1},
+	{0x4423, 0x1C},
+	{0x4424, 0x00},
+	{0x4425, 0xA1},
+	{0x4427, 0x1C},
+	{0x4428, 0x00},
+	{0x4429, 0xA1},
+	{0x442A, 0x00},
+	{0x442B, 0x00},
+	{0x442C, 0x01},
+	{0x442D, 0x07},
+	{0x442E, 0x00},
+	{0x442F, 0x00},
+	{0x4430, 0x01},
+	{0x4431, 0x01},
+	{0x4432, 0x00},
+	{0x4433, 0x08},
+	{0x4434, 0x01},
+	{0x4435, 0x07},
+	{0x4436, 0x00},
+	{0x4437, 0x00},
+	{0x4438, 0x01},
+	{0x4439, 0x00},
+	{0x443A, 0x00},
+	{0x443B, 0x08},
+	{0x443C, 0x01},
+	{0x443D, 0x00},
+	{0x443E, 0x00},
+	{0x443F, 0x08},
+	{0x4441, 0x00},
+	{0x4442, 0x00},
+	{0x4443, 0x00},
+	{0x4444, 0x00},
+	{0x4445, 0x00},
+	{0x4446, 0x02},
+	{0x4447, 0x09},
+	{0x4448, 0x00},
+	{0x4449, 0x00},
+	{0x444A, 0x00},
+	{0x444B, 0x00},
+	{0x444C, 0x00},
+	{0x444D, 0x00},
+	{0x444E, 0x00},
+	{0x444F, 0x01},
+	{0x4450, 0x00},
+	{0x4451, 0xA1},
+	{0x4452, 0x01},
+	{0x4453, 0x00},
+	{0x4454, 0x00},
+	{0x4455, 0x00},
+	{0x4457, 0x00},
+	{0x4458, 0x00},
+	{0x4459, 0x18},
+	{0x445A, 0x18},
+	{0x445B, 0x18},
+	{0x445C, 0x00},
+	{0x445D, 0x00},
+	{0x445E, 0x00},
+	{0x445F, 0x00},
+	{0x4460, 0x00},
+	{0x4461, 0x00},
+	{0x4462, 0x01},
+	{0x4463, 0x00},
+	{0x4464, 0x00},
+	{0x4465, 0x00},
+	{0x4466, 0x00},
+	{0x4467, 0x00},
+	{0x4468, 0x00},
+	{0x4469, 0x00},
+	{0x446A, 0x00},
+	{0x446B, 0x00},
+	{0x446C, 0x00},
+	{0x446D, 0x00},
+	{0x446E, 0x00},
+	{0x446F, 0x00},
+	{0x4470, 0x1D},
+	{0x4471, 0x00},
+	{0x4472, 0x00},
+	{0x4473, 0x00},
+	{0x4475, 0x00},
+	{0x4476, 0x00},
+	{0x4477, 0x00},
+	{0x4479, 0x00},
+	{0x447A, 0x00},
+	{0x447B, 0x00},
+	{0x447C, 0x00},
+	{0x447D, 0x00},
+	{0x447E, 0x00},
+	{0x447F, 0x00},
+	{0x4480, 0x00},
+	{0x4481, 0x1B},
+	{0x4482, 0x00},
+	{0x4483, 0x19},
+	{0x4484, 0x00},
+	{0x4485, 0x00},
+	{0x4486, 0x01},
+	{0x4487, 0x07},
+	{0x4488, 0x00},
+	{0x4489, 0x00},
+	{0x448A, 0x01},
+	{0x448B, 0x00},
+	{0x448C, 0x00},
+	{0x448D, 0x08},
+	{0x448E, 0x01},
+	{0x448F, 0x07},
+	{0x4490, 0x00},
+	{0x4491, 0x00},
+	{0x4492, 0x01},
+	{0x4493, 0x01},
+	{0x4494, 0x00},
+	{0x4495, 0x08},
+	{0x4496, 0x01},
+	{0x4497, 0x00},
+	{0x4498, 0x00},
+	{0x4499, 0x08},
+	{0x449B, 0x1C},
+	{0x449C, 0x00},
+	{0x449D, 0xA1},
+	{0x449F, 0x1C},
+	{0x44A0, 0x00},
+	{0x44A1, 0xA1},
+	{0x44A2, 0x00},
+	{0x44A3, 0x00},
+	{0x44A4, 0x00},
+	{0x44A5, 0x00},
+	{0x44A6, 0x00},
+	{0x44A7, 0x00},
+	{0x44A8, 0x18},
+	{0x44A9, 0x18},
+	{0x44AA, 0x00},
+	{0x44AB, 0x1B},
+	{0x44AC, 0x00},
+	{0x44AD, 0x00},
+	{0x44AE, 0x00},
+	{0x44AF, 0x01},
+	{0x4500, 0x00},
+	{0x4501, 0x19},
+	{0x4502, 0x39},
+	{0x4503, 0x0B},
+	{0x4504, 0x00},
+	{0x4505, 0x67},
+	{0x4506, 0x03},
+	{0x4507, 0x18},
+	{0x4508, 0x00},
+	{0x4509, 0x05},
+	{0x450A, 0x00},
+	{0x450B, 0xE9},
+	{0x450C, 0x18},
+	{0x450E, 0x00},
+	{0x450F, 0x00},
+	{0x4511, 0x00},
+	{0x4512, 0x00},
+	{0x4513, 0x01},
+	{0x4515, 0x00},
+	{0x4516, 0x00},
+	{0x4517, 0x01},
+	{0x4519, 0x00},
+	{0x451A, 0x00},
+	{0x451B, 0x00},
+	{0x451D, 0x00},
+	{0x451E, 0x00},
+	{0x451F, 0x00},
+	{0x4520, 0x0F},
+	{0x4521, 0x00},
+	{0x4522, 0x07},
+	{0x4523, 0x3B},
+	{0x4524, 0x00},
+	{0x4525, 0x01},
+	{0x4527, 0x00},
+	{0x4528, 0x00},
+	{0x4529, 0x01},
+	{0x452B, 0x00},
+	{0x452C, 0x00},
+	{0x452D, 0x00},
+	{0x452E, 0x00},
+	{0x452F, 0x00},
+	{0x4530, 0x0C},
+	{0x4531, 0x39},
+	{0x4532, 0x0D},
+	{0x4533, 0x02},
+	{0x4534, 0x0D},
+	{0x4535, 0x04},
+	{0x4537, 0x0D},
+	{0x4538, 0x00},
+	{0x4539, 0x00},
+	{0x453B, 0x00},
+	{0x453C, 0x00},
+	{0x453D, 0x00},
+	{0x453F, 0x0D},
+	{0x4540, 0x00},
+	{0x4541, 0x03},
+	{0x4543, 0x00},
+	{0x4544, 0x00},
+	{0x4545, 0x03},
+	{0x4547, 0x0D},
+	{0x4548, 0x00},
+	{0x4549, 0x00},
+	{0x454B, 0x00},
+	{0x454C, 0x00},
+	{0x454D, 0x00},
+	{0x454E, 0x0B},
+	{0x454F, 0x0F},
+	{0x4550, 0x0E},
+	{0x4551, 0x0A},
+	{0x4552, 0x00},
+	{0x4553, 0x05},
+	{0x4554, 0x00},
+	{0x4555, 0x32},
+	{0x4557, 0x00},
+	{0x4558, 0x00},
+	{0x4559, 0x32},
+	{0x455B, 0x00},
+	{0x455C, 0x02},
+	{0x455D, 0x0F},
+	{0x455E, 0x05},
+	{0x455F, 0x0B},
+	{0x4560, 0x03},
+	{0x4561, 0x09},
+	{0x4562, 0x07},
+	{0x4563, 0x18},
+	{0x4564, 0x00},
+	{0x4565, 0x00},
+	{0x4566, 0x00},
+	{0x4567, 0x06},
+	{0x4569, 0x01},
+	{0x456A, 0x02},
+	{0x456B, 0x0A},
+	{0x456C, 0x00},
+	{0x456D, 0x06},
+	{0x456F, 0x06},
+	{0x4570, 0x05},
+	{0x4571, 0x08},
+	{0x4572, 0x0C},
+	{0x4573, 0x08},
+	{0x4574, 0x00},
+	{0x4575, 0x02},
+	{0x4577, 0x00},
+	{0x4578, 0x00},
+	{0x4579, 0x02},
+	{0x457B, 0x02},
+	{0x457C, 0x04},
+	{0x457D, 0x0D},
+	{0x457E, 0x09},
+	{0x457F, 0x18},
+	{0x4581, 0x01},
+	{0x4582, 0x01},
+	{0x4583, 0x18},
+	{0x4584, 0x00},
+	{0x4585, 0x03},
+	{0x4586, 0x00},
+	{0x4587, 0x01},
+	{0x4588, 0x00},
+	{0x4589, 0x08},
+	{0x458A, 0x0D},
+	{0x458B, 0x02},
+	{0x458C, 0x0D},
+	{0x458D, 0x0F},
+	{0x458F, 0x00},
+	{0x4590, 0x00},
+	{0x4591, 0x00},
+	{0x4600, 0x08},
+	{0x4601, 0x60},
+	{0x4602, 0x00},
+	{0x4603, 0x21},
+	{0x4604, 0x00},
+	{0x4605, 0x0F},
+	{0x4606, 0x00},
+	{0x4607, 0xA3},
+	{0x4608, 0x00},
+	{0x4609, 0x00},
+	{0x460A, 0x18},
+	{0x460B, 0x1B},
+	{0x460C, 0x00},
+	{0x460D, 0x00},
+	{0x460E, 0x00},
+	{0x460F, 0x00},
+	{0x4610, 0x00},
+	{0x4611, 0x00},
+	{0x4700, 0x00},
+	{0x4701, 0x19},
+	{0x4702, 0x2E},
+	{0x4703, 0x0B},
+	{0x4704, 0x00},
+	{0x4705, 0x24},
+	{0x4706, 0x03},
+	{0x4707, 0x18},
+	{0x4708, 0x00},
+	{0x4709, 0x17},
+	{0x470A, 0x00},
+	{0x470B, 0xD1},
+	{0x470C, 0x18},
+	{0x470E, 0x00},
+	{0x470F, 0x00},
+	{0x5000, 0x00},
+	{0x5001, 0x00},
+	{0x5002, 0x07},
+	{0x5003, 0xC0},
+	{0x5004, 0x00},
+	{0x5005, 0x02},
+	{0x5006, 0x00},
+	{0x5007, 0x0C},
+	{0x5008, 0x00},
+	{0x5009, 0x24},
+	{0x500A, 0x10},
+	{0x500B, 0x3C},
+	{0x500C, 0x00},
+	{0x500D, 0x0D},
+	{0x500E, 0x10},
+	{0x500F, 0x00},
+	{0x5011, 0x01},
+	{0x5012, 0x07},
+	{0x5013, 0xFF},
+	{0x5014, 0x01},
+	{0x5015, 0x10},
+	{0x5016, 0x10},
+	{0x5017, 0xE4},
+	{0x5018, 0x10},
+	{0x5019, 0xE4},
+	{0x501A, 0x10},
+	{0x501B, 0xE4},
+	{0x501C, 0x11},
+	{0x501D, 0xC8},
+	{0x501E, 0x13},
+	{0x501F, 0x90},
+	{0x5020, 0x17},
+	{0x5021, 0x20},
+	{0x5022, 0x18},
+	{0x5023, 0x68},
+	{0x5024, 0x10},
+	{0x5025, 0xE4},
+	{0x5026, 0x10},
+	{0x5027, 0xE4},
+	{0x5028, 0x10},
+	{0x5029, 0xE4},
+	{0x502A, 0x11},
+	{0x502B, 0xC8},
+	{0x502C, 0x13},
+	{0x502D, 0x90},
+	{0x502E, 0x17},
+	{0x502F, 0x20},
+	{0x5030, 0x18},
+	{0x5031, 0x68},
+	{0x5032, 0x07},
+	{0x5033, 0xFF},
+	{0x5034, 0x07},
+	{0x5035, 0xFF},
+	{0x5036, 0x22},
+	{0x5037, 0x00},
+	{0x5039, 0x03},
+	{0x503A, 0x00},
+	{0x503B, 0x02},
+	{0x503C, 0x00},
+	{0x503D, 0x0A},
+	{0x503E, 0x01},
+	{0x503F, 0xD4},
+	{0x5040, 0x0A},
+	{0x5041, 0x0A},
+	{0x5043, 0x03},
+	{0x5044, 0x01},
+	{0x5045, 0x30},
+	{0x5046, 0xC1},
+	{0x5047, 0x00},
+	{0x5048, 0x00},
+	{0x5049, 0x00},
+	{0x5053, 0x11},
+	{0x5054, 0x01},
+	{0x5055, 0xA2},
+	{0x5056, 0x01},
+	{0x5057, 0xFF},
+	{0x505C, 0x78},
+	{0x505D, 0x00},
+	{0x505E, 0x00},
+	{0x505F, 0x00},
+	{0x5061, 0x00},
+	{0x5062, 0x0F},
+	{0x5063, 0xFE},
+	{0x5064, 0x00},
+	{0x5065, 0x01},
+	{0x5066, 0x01},
+	{0x5067, 0x00},
+	{0x5068, 0x00},
+	{0x5069, 0x06},
+	{0x506B, 0x8E},
+	{0x506C, 0x00},
+	{0x506D, 0x00},
+	{0x506E, 0x00},
+	{0x506F, 0x00},
+	{0x5070, 0x00},
+	{0x5071, 0x00},
+	{0x5072, 0x00},
+	{0x5073, 0x00},
+	{0x5074, 0x00},
+	{0x5075, 0x00},
+	{0x5076, 0x00},
+	{0x5077, 0x00},
+	{0x5078, 0x00},
+	{0x5079, 0x40},
+	{0x5090, 0x00},
+	{0x5091, 0x00},
+	{0x5096, 0x00},
+	{0x5097, 0x00},
+	{0x5098, 0x00},
+	{0x5099, 0x00},
+	{0x509A, 0x00},
+	{0x509B, 0x00},
+	{0x509C, 0x00},
+	{0x509D, 0x00},
+	{0x509E, 0x00},
+	{0x509F, 0x00},
+	{0x50A0, 0x00},
+	{0x50A1, 0x00},
+	{0x50A2, 0x00},
+	{0x50A3, 0x00},
+	{0x50A4, 0x00},
+	{0x50A5, 0x00},
+	{0x50A6, 0x00},
+	{0x50A7, 0x00},
+	{0x50A8, 0x00},
+	{0x50D0, 0x55},
+	{0x50D1, 0x00},
+	{0x50D2, 0x00},
+	{0x50D3, 0x00},
+	{0x50F1, 0x00},
+	{0x50F2, 0x40},
+	{0x50F3, 0x71},
+	{0x50F4, 0x11},
+	{0x50F5, 0x71},
+	{0x50F6, 0x03},
+	{0x50F7, 0xD0},
+	{0x50F8, 0x00},
+	{0x50F9, 0x00},
+	{0x50FA, 0x0A},
+	{0x50FB, 0x00},
+	{0x50FC, 0x00},
+	{0x50FD, 0x00},
+	{0x5100, 0x00},
+	{0x5101, 0x05},
+	{0x5102, 0x02},
+	{0x5103, 0x01},
+	{0x5104, 0x04},
+	{0x5105, 0x03},
+	{0x5108, 0x00},
+	{0x5109, 0x01},
+	{0x510A, 0x02},
+	{0x510B, 0x03},
+	{0x510C, 0x04},
+	{0x510D, 0x05},
+	{0x5110, 0x00},
+
+	/* sync code */
+	{0x5111, 0x4B},
+	{0x5112, 0x20},
+/*
+	{0x5114, 0x0A},
+	{0x5115, 0xB0},
+	{0x5116, 0x0B},
+	{0x5117, 0x60},
+	{0x5118, 0x08},
+	{0x5119, 0x00},
+	{0x511A, 0x09},
+	{0x511B, 0xD0},
+*/
+	{0x5120, 0x2C},
+	{0x5121, 0x13},
+	{0x5122, 0x12},
+	{0x5123, 0x10},
+	{0x5124, 0x00},
+	{0x5125, 0x00},
+	{0x5126, 0x05},
+	{0x5127, 0x00},
+	{0x5129, 0x50},
+	{0x5130, 0x03},
+	{0x5131, 0x14},
+	{0x5132, 0x04},
+	{0x5133, 0x01},
+	{0x5134, 0x0B},
+	{0x5135, 0x08},
+	{0x5136, 0x04},
+	{0x5137, 0x04},
+	{0x5138, 0x09},
+	{0x5139, 0x05},
+	{0x513A, 0x00},
+	{0x513B, 0x09},
+	{0x513D, 0xE4},
+	{0x513E, 0x00},
+	{0x513F, 0x00},
+	{0x5140, 0x04},
+	{0x5141, 0x54},
+	{0x5142, 0x00},
+	{0x5143, 0x00},
+	{0x5144, 0x04},
+	{0x5145, 0x53},
+/*
+	{0x5146, 0x00},
+	{0x5147, 0x02},
+	{0x5148, 0x00},
+	{0x5149, 0x03},
+	{0x514A, 0x00},
+	{0x514B, 0x00},
+	{0x514C, 0x00},
+	{0x514D, 0x01},
+	{0x514E, 0x00},
+	{0x514F, 0x02},
+	{0x5150, 0x00},
+	{0x5151, 0x03},
+	{0x5152, 0x00},
+	{0x5153, 0x00},
+	{0x5154, 0x00},
+	{0x5155, 0x01},
+	{0x5156, 0x00},
+	{0x5157, 0x02},
+	{0x5158, 0x00},
+	{0x5159, 0x03},
+	{0x515A, 0x00},
+	{0x515B, 0x00},
+	{0x515C, 0x00},
+	{0x515D, 0x01},
+*/
+	{0x5160, 0x00},
+	{0x5161, 0x00},
+	{0x5162, 0x00},
+	{0x5163, 0x00},
+	{0x5164, 0x00},
+	{0x5165, 0x00},
+	{0x5166, 0x00},
+	{0x5167, 0x00},
+	{0x5168, 0x00},
+	{0x5169, 0x00},
+	{0x516A, 0x00},
+	{0x516B, 0x00},
+	{0x516C, 0x00},
+	{0x516D, 0x00},
+	{0x516E, 0x00},
+	{0x516F, 0x00},
+	{0x5170, 0x00},
+	{0x5171, 0x00},
+	{0x5172, 0x00},
+	{0x5173, 0x00},
+	{0x5174, 0x00},
+	{0x5175, 0x00},
+	{0x5176, 0x00},
+	{0x5177, 0x00},
+	{0x5178, 0xE4},
+	{0x5179, 0x00},
+	{0x517A, 0x04},
+	{0x517B, 0x50},
+	{0x517C, 0x00},
+	{0x517D, 0x00},
+	{0x517E, 0x00},
+	{0x5180, 0x00},
+	{0x5181, 0x00},
+	{0x5182, 0x00},
+	{0x5183, 0x00},
+	{0x5184, 0x00},
+	{0x5186, 0x00},
+	{0x5187, 0x00},
+	{0x5188, 0x00},
+	{0x5189, 0x00},
+	{0x518A, 0x00},
+	{0x518B, 0x00},
+	{0x518D, 0x00},
+	{0x518E, 0x00},
+	{0x518F, 0x00},
+	{0x5190, 0x00},
+	{0x5191, 0x00},
+	{0x5192, 0x00},
+	{0x5194, 0x00},
+	{0x5195, 0x00},
+	{0x5196, 0x00},
+	{0x5197, 0x00},
+	{0x5198, 0x00},
+	{0x5199, 0x00},
+	{0x519B, 0x00},
+	{0x519E, 0xFF},
+	{0x519F, 0xFE},
+	{0x51A0, 0x00},
+	{0x51A1, 0x01},
+	{0x51A2, 0x03},
+	{0x51A3, 0x00},
+	{0x603D, 0x00},
+	{0x603D, 0x01},
+	{0x6000, 0x04},
+	{0x6001, 0xF8},
+	{0x6026, 0x04},
+	{0x6027, 0xF7},
+	{0x3000, 0x01},
+	{0x3001, 0xD3},
+	{0x3000, 0x21},
+	{0x3001, 0xD3},
+};
+
+static struct vin_reg_16_8 mn34420pl_3x_hdr_mode_regs[] = {
+	/* VCYCLE:1500 HCYCLE:1200 (@MCLK) */
+	{0x300C, 0x08},
+	{0x300D, 0x20},
+	{0x300E, 0x00},
+	{0x300F, 0x03},
+	{0x3002, 0x31},
+	{0x3003, 0x00},
+	{0x3004, 0x10},
+	{0x3005, 0x58},
+	{0x3006, 0x02},
+	{0x3007, 0xC0},
+	{0x3008, 0x35},
+	{0x3009, 0x80},
+	{0x300A, 0xCF},
+	{0x300B, 0x30},
+	{0x3000, 0x01},
+	{0x3001, 0x03},
+	{0x3000, 0x01},
+	{0x3001, 0x53},
+	{0x300E, 0x00},
+	{0x300F, 0x00},
+	{0x3200, 0x3F},
+	{0x3201, 0x06},
+	{0x3202, 0x0B},
+	{0x3203, 0x0B},
+	{0x3204, 0x14},
+	{0x3205, 0x00},
+	{0x3206, 0xA7},
+	{0x3207, 0x78},
+	{0x3208, 0x49},
+	{0x320A, 0x00},
+	{0x3010, 0x00},
+	{0x3012, 0x00},
+	{0x3013, 0x03},
+	{0x3014, 0x00},
+	{0x3015, 0x00},
+	{0x3016, 0x00},
+	{0x3017, 0xF0},
+	{0x3018, 0x00},
+	{0x3019, 0x00},
+	{0x301A, 0x00},
+	{0x301B, 0x00},
+	{0x301C, 0x00},
+	{0x301D, 0x00},
+	{0x301E, 0x00},
+	{0x301F, 0x00},
+	{0x3020, 0x00},
+	{0x3021, 0x1A},
+	{0x3022, 0x38},
+	{0x3023, 0x00},
+	{0x3024, 0x00},
+	{0x3025, 0x00},
+	{0x3026, 0x20},
+	{0x3027, 0x00},
+	{0x3028, 0x00},
+	{0x3029, 0x00},
+	{0x302A, 0xFF},
+	{0x302B, 0x1F},
+	{0x302C, 0x08},
+	{0x302D, 0x04},
+	{0x302E, 0x00},
+	{0x302F, 0x00},
+	{0x3030, 0x9E},
+	{0x3031, 0x05},
+	{0x3032, 0x00},
+	{0x3033, 0x00},
+	{0x3035, 0x60},
+	{0x3036, 0x00},
+	{0x3037, 0x00},
+	{0x3039, 0x60},
+	{0x303B, 0x00},
+	{0x303D, 0x00},
+	{0x3040, 0x00},
+	{0x3041, 0x00},
+	{0x3042, 0x42},
+	{0x3043, 0x00},
+	{0x3044, 0x32},
+	{0x3045, 0x00},
+	{0x3046, 0x49},
+	{0x3047, 0x00},
+	{0x3048, 0x00},
+	{0x3049, 0x30},
+	{0x304A, 0xE2},
+	{0x304B, 0x01},
+	{0x304C, 0x31},
+	{0x304D, 0x33},
+	{0x304E, 0x22},
+	{0x304F, 0x33},
+	{0x3050, 0x00},
+	{0x3051, 0x50},
+	{0x3052, 0x00},
+	{0x3053, 0x00},
+	{0x3054, 0x00},
+	{0x3055, 0x00},
+	{0x3056, 0x04},
+	{0x3057, 0x00},
+	{0x3058, 0x7F},
+	{0x3059, 0x7F},
+	{0x305A, 0x7F},
+	{0x305B, 0x03},
+	{0x3060, 0x00},
+	{0x3061, 0x00},
+	{0x3062, 0x00},
+	{0x3063, 0x00},
+	{0x3100, 0x01},
+	{0x3101, 0x20},
+	{0x3102, 0x01},
+	{0x3103, 0x20},
+	{0x3104, 0x02},
+	{0x3105, 0xEE},
+	{0x3107, 0x00},
+	{0x3108, 0x01},
+	{0x3109, 0x20},
+	{0x310A, 0x01},
+	{0x310B, 0x20},
+	{0x310C, 0x01},
+	{0x310D, 0x77},
+	{0x3110, 0x01},
+	{0x3111, 0x20},
+	{0x3112, 0x01},
+	{0x3113, 0x20},
+	{0x3114, 0x00},
+	{0x3115, 0x01},
+	{0x3116, 0x01},
+	{0x3117, 0x20},
+	{0x3118, 0x01},
+	{0x3119, 0x20},
+	{0x311A, 0x00},
+	{0x311B, 0x16},
+	{0x311C, 0x00},
+	{0x3120, 0x00},
+	{0x3121, 0x3C},
+	{0x3122, 0x04},
+	{0x3123, 0x7F},
+	{0x3124, 0x00},
+	{0x3125, 0x00},
+	{0x3126, 0x04},
+	{0x3127, 0x54},
+	{0x3131, 0x00},
+	{0x3140, 0x00},
+	{0x3141, 0xE0},
+	{0x3142, 0x00},
+	{0x3143, 0xC7},
+	{0x3151, 0x40},
+	{0x3152, 0x00},
+	{0x3153, 0x00},
+	{0x3154, 0x00},
+	{0x3155, 0x00},
+	{0x3156, 0x00},
+	{0x3157, 0x00},
+	{0x3159, 0x00},
+	{0x3161, 0x40},
+	{0x3162, 0x00},
+	{0x3163, 0x00},
+	{0x3164, 0x00},
+	{0x3165, 0x00},
+	{0x3166, 0x00},
+	{0x3167, 0x00},
+	{0x3169, 0x00},
+	{0x3170, 0x08},
+	{0x3171, 0x00},
+	{0x3172, 0x08},
+	{0x3173, 0x00},
+	{0x4000, 0x00},
+	{0x4001, 0x02},
+	{0x4002, 0x01},
+	{0x4003, 0x07},
+	{0x4004, 0x00},
+	{0x4005, 0x13},
+	{0x4006, 0x00},
+	{0x4007, 0x01},
+	{0x4008, 0x00},
+	{0x4009, 0x00},
+	{0x400A, 0x07},
+	{0x400B, 0x00},
+	{0x400C, 0x00},
+	{0x400D, 0x00},
+	{0x400E, 0x08},
+	{0x400F, 0x00},
+	{0x4010, 0x04},
+	{0x4012, 0x00},
+	{0x4013, 0x25},
+	{0x4014, 0x17},
+	{0x4015, 0x10},
+	{0x4016, 0x40},
+	{0x4017, 0xFF},
+	{0x4018, 0xC0},
+	{0x401A, 0x00},
+	{0x401B, 0x38},
+	{0x401C, 0x00},
+	{0x401D, 0x38},
+	{0x401E, 0x00},
+	{0x401F, 0x28},
+	{0x4020, 0x00},
+	{0x4021, 0x38},
+	{0x4022, 0x00},
+	{0x4023, 0x28},
+	{0x4024, 0x00},
+	{0x4025, 0x29},
+	{0x4026, 0x00},
+	{0x4027, 0x29},
+	{0x4028, 0x00},
+	{0x4029, 0x29},
+	{0x402A, 0x00},
+	{0x402B, 0x29},
+	{0x402C, 0x00},
+	{0x402D, 0x2B},
+	{0x402E, 0x00},
+	{0x402F, 0x2B},
+	{0x4030, 0x00},
+	{0x4031, 0x2A},
+	{0x4032, 0x00},
+	{0x4033, 0x2E},
+	{0x4034, 0x00},
+	{0x4035, 0x2F},
+	{0x4036, 0x00},
+	{0x4037, 0x2D},
+	{0x4038, 0x00},
+	{0x4039, 0x2D},
+	{0x403A, 0x00},
+	{0x403B, 0x2F},
+	{0x403C, 0x00},
+	{0x403D, 0x2F},
+	{0x403E, 0x00},
+	{0x403F, 0x2E},
+	{0x4040, 0x00},
+	{0x4041, 0x2D},
+	{0x4042, 0x00},
+	{0x4043, 0x25},
+	{0x4044, 0x00},
+	{0x4045, 0x27},
+	{0x4046, 0x00},
+	{0x4047, 0x27},
+	{0x4048, 0x00},
+	{0x4049, 0x00},
+	{0x404A, 0x1F},
+	{0x404B, 0x1F},
+	{0x404C, 0x1F},
+	{0x404D, 0x06},
+	{0x404E, 0x08},
+	{0x404F, 0x12},
+	{0x4050, 0x0F},
+	{0x4051, 0x0C},
+	{0x4052, 0x0B},
+	{0x4053, 0x0A},
+	{0x4054, 0x08},
+	{0x4055, 0x07},
+	{0x4056, 0x06},
+	{0x4057, 0x04},
+	{0x4058, 0x01},
+	{0x4059, 0x00},
+	{0x405A, 0x00},
+	{0x405B, 0x00},
+	{0x405C, 0x00},
+	{0x405D, 0x00},
+	{0x405E, 0x00},
+	{0x405F, 0x00},
+	{0x4060, 0xFF},
+	{0x4061, 0x07},
+	{0x4062, 0x77},
+	{0x4063, 0x00},
+	{0x4064, 0x44},
+	{0x4066, 0x0C},
+	{0x4067, 0x0C},
+	{0x4068, 0x00},
+	{0x4069, 0x00},
+	{0x406A, 0x00},
+	{0x406B, 0x00},
+	{0x406C, 0x00},
+	{0x406D, 0x00},
+	{0x406E, 0x00},
+	{0x4070, 0x00},
+	{0x4071, 0x00},
+	{0x4072, 0x00},
+	{0x4073, 0x00},
+	{0x4100, 0x10},
+	{0x4101, 0x32},
+	{0x4102, 0x54},
+	{0x4103, 0x76},
+	{0x4104, 0x8B},
+	{0x4105, 0x09},
+	{0x4106, 0x00},
+	{0x4107, 0x00},
+	{0x4108, 0x0A},
+	{0x4109, 0x88},
+	{0x410A, 0x00},
+	{0x410B, 0x00},
+	{0x410C, 0x00},
+	{0x410D, 0x82},
+	{0x410E, 0x22},
+	{0x410F, 0x00},
+	{0x4110, 0x00},
+	{0x4111, 0x22},
+	{0x4112, 0x00},
+	{0x4113, 0x00},
+	{0x4114, 0x3F},
+	{0x4115, 0x33},
+	{0x4116, 0xF6},
+	{0x4117, 0x3F},
+	{0x4118, 0x1C},
+	{0x4119, 0x15},
+	{0x411A, 0x26},
+	{0x411B, 0x00},
+	{0x411C, 0xBA},
+	{0x411D, 0x00},
+	{0x411E, 0x00},
+	{0x411F, 0x22},
+	{0x4120, 0x02},
+	{0x4121, 0x00},
+	{0x4122, 0x40},
+	{0x4124, 0x60},
+	{0x4125, 0x88},
+	{0x4126, 0x00},
+	{0x4127, 0x00},
+	{0x4128, 0x90},
+	{0x4129, 0x99},
+	{0x412A, 0x00},
+	{0x412B, 0x00},
+	{0x412C, 0x00},
+	{0x412D, 0x00},
+	{0x412E, 0x00},
+	{0x412F, 0x00},
+	{0x4130, 0x00},
+	{0x4131, 0x00},
+	{0x4132, 0x00},
+	{0x4133, 0x00},
+	{0x4134, 0x00},
+	{0x4135, 0x00},
+	{0x4136, 0x00},
+	{0x4137, 0x00},
+	{0x4138, 0x00},
+	{0x4139, 0x00},
+	{0x413A, 0x00},
+	{0x413B, 0x00},
+	{0x413C, 0x00},
+	{0x413D, 0x00},
+	{0x413E, 0x00},
+	{0x413F, 0x00},
+	{0x4140, 0x00},
+	{0x4141, 0x00},
+	{0x4142, 0x00},
+	{0x4143, 0x00},
+	{0x4144, 0x00},
+	{0x4145, 0x00},
+	{0x4146, 0x00},
+	{0x4147, 0x00},
+	{0x4148, 0x00},
+	{0x4149, 0x00},
+	{0x414A, 0x00},
+	{0x414B, 0x00},
+	{0x414C, 0x00},
+	{0x414D, 0x00},
+	{0x414E, 0x00},
+	{0x414F, 0x00},
+	{0x4150, 0x00},
+	{0x4151, 0x00},
+	{0x4152, 0x00},
+	{0x4153, 0x00},
+	{0x4154, 0x00},
+	{0x4155, 0x00},
+	{0x4156, 0x00},
+	{0x4157, 0x00},
+	{0x4158, 0x00},
+	{0x4159, 0x00},
+	{0x415A, 0x00},
+	{0x415B, 0x00},
+	{0x415C, 0x00},
+	{0x415D, 0x00},
+	{0x415E, 0x00},
+	{0x415F, 0x00},
+	{0x4200, 0x21},
+	{0x4201, 0x43},
+	{0x4202, 0x65},
+	{0x4203, 0x98},
+	{0x4204, 0x0A},
+	{0x4205, 0x00},
+	{0x4206, 0x00},
+	{0x4207, 0x00},
+	{0x4208, 0x08},
+	{0x4209, 0xAA},
+	{0x420A, 0x80},
+	{0x420B, 0x0A},
+	{0x420C, 0xA0},
+	{0x420D, 0x00},
+	{0x420E, 0x22},
+	{0x420F, 0xA8},
+	{0x4210, 0x02},
+	{0x4211, 0x00},
+	{0x4212, 0x00},
+	{0x4213, 0x00},
+	{0x4214, 0xF0},
+	{0x4215, 0x07},
+	{0x4216, 0x00},
+	{0x4217, 0x00},
+	{0x4218, 0x00},
+	{0x4219, 0x00},
+	{0x421A, 0x00},
+	{0x421B, 0x01},
+	{0x421C, 0x00},
+	{0x421D, 0x00},
+	{0x421E, 0x02},
+	{0x4220, 0x00},
+	{0x4221, 0x00},
+	{0x4222, 0x00},
+	{0x4223, 0x00},
+	{0x4224, 0x00},
+	{0x4225, 0x00},
+	{0x4226, 0x00},
+	{0x4227, 0x00},
+	{0x4228, 0x00},
+	{0x4229, 0x00},
+	{0x422A, 0x21},
+	{0x422B, 0xAA},
+	{0x422C, 0x00},
+	{0x422D, 0x00},
+	{0x422E, 0x00},
+	{0x422F, 0x00},
+	{0x4230, 0x00},
+	{0x4231, 0x00},
+	{0x4232, 0x00},
+	{0x4233, 0x00},
+	{0x4234, 0x00},
+	{0x4235, 0x00},
+	{0x4236, 0x00},
+	{0x4237, 0x00},
+	{0x4238, 0x00},
+	{0x4239, 0x00},
+	{0x423A, 0x00},
+	{0x423B, 0x00},
+	{0x423C, 0x00},
+	{0x423D, 0x00},
+	{0x423E, 0x00},
+	{0x423F, 0x00},
+	{0x4240, 0x00},
+	{0x4241, 0x00},
+	{0x4242, 0x00},
+	{0x4243, 0x00},
+	{0x4244, 0x00},
+	{0x4245, 0x00},
+	{0x4246, 0x00},
+	{0x4247, 0x00},
+	{0x4248, 0x00},
+	{0x4249, 0x00},
+	{0x424A, 0x00},
+	{0x424B, 0x00},
+	{0x424C, 0x00},
+	{0x424D, 0x00},
+	{0x424E, 0x00},
+	{0x424F, 0x00},
+	{0x4250, 0x00},
+	{0x4251, 0x00},
+	{0x4252, 0x00},
+	{0x4253, 0x00},
+	{0x4254, 0x00},
+	{0x4255, 0x00},
+	{0x4256, 0x00},
+	{0x4257, 0x03},
+	{0x4258, 0x00},
+	{0x4259, 0x00},
+	{0x425A, 0x00},
+	{0x425B, 0x01},
+	{0x425C, 0x00},
+	{0x425D, 0x03},
+	{0x425E, 0x00},
+	{0x425F, 0x00},
+	{0x4260, 0x00},
+	{0x4261, 0x00},
+	{0x4262, 0x00},
+	{0x4263, 0x00},
+	{0x4264, 0x00},
+	{0x4265, 0x00},
+	{0x4266, 0x00},
+	{0x4267, 0x00},
+	{0x4268, 0x00},
+	{0x4269, 0x00},
+	{0x4301, 0x20},
+	{0x4302, 0x05},
+	{0x4303, 0xDB},
+	{0x4304, 0x04},
+	{0x4305, 0xAF},
+	{0x4307, 0x01},
+	{0x4308, 0x01},
+	{0x4309, 0x8D},
+	{0x430A, 0x00},
+	{0x430B, 0x00},
+	{0x430C, 0x00},
+	{0x430D, 0x01},
+	{0x430E, 0x00},
+	{0x430F, 0x00},
+	{0x4310, 0x00},
+	{0x4311, 0x00},
+	{0x4312, 0x00},
+	{0x4313, 0x00},
+	{0x4314, 0x00},
+	{0x4315, 0x01},
+	{0x4316, 0x00},
+	{0x4317, 0x01},
+	{0x4318, 0x23},
+	{0x4319, 0x07},
+	{0x431A, 0x00},
+	{0x431B, 0x02},
+	{0x431C, 0x00},
+	{0x431D, 0x02},
+	{0x431E, 0x00},
+	{0x431F, 0x02},
+	{0x4320, 0x00},
+	{0x4321, 0x00},
+	{0x4322, 0x00},
+	{0x4324, 0x04},
+	{0x4325, 0x61},
+	{0x4326, 0x05},
+	{0x4327, 0xA4},
+	{0x4328, 0x04},
+	{0x4329, 0x60},
+	{0x432A, 0x04},
+	{0x432B, 0x56},
+	{0x432C, 0x04},
+	{0x432D, 0x57},
+	{0x432E, 0x04},
+	{0x432F, 0x5F},
+	{0x4330, 0x04},
+	{0x4331, 0x60},
+	{0x4332, 0x00},
+	{0x4333, 0x00},
+	{0x4334, 0x00},
+	{0x4335, 0x00},
+	{0x4336, 0x00},
+	{0x4338, 0x10},
+	{0x4339, 0x00},
+	{0x433A, 0x00},
+	{0x433B, 0x02},
+	{0x433C, 0x00},
+	{0x433D, 0x02},
+	{0x433E, 0x53},
+	{0x433F, 0x53},
+	{0x4340, 0x00},
+	{0x4341, 0x00},
+	{0x4342, 0x00},
+	{0x4343, 0x20},
+	{0x4344, 0x00},
+	{0x4345, 0x06},
+	{0x4346, 0x02},
+	{0x4347, 0x00},
+	{0x4348, 0x00},
+	{0x434A, 0x00},
+	{0x434B, 0x00},
+	{0x434C, 0x00},
+	{0x434D, 0x00},
+	{0x434E, 0x00},
+	{0x4350, 0x00},
+	{0x4351, 0x0F},
+	{0x4352, 0x00},
+	{0x4353, 0x5A},
+	{0x4354, 0x00},
+	{0x4355, 0x00},
+	{0x4356, 0x00},
+	{0x4357, 0x00},
+	{0x4358, 0x00},
+	{0x4360, 0x00},
+	{0x4361, 0x39},
+	{0x4400, 0x06},
+	{0x4401, 0x67},
+	{0x4402, 0x00},
+	{0x4403, 0x6E},
+	{0x4404, 0x00},
+	{0x4405, 0x0F},
+	{0x4406, 0x00},
+	{0x4407, 0xA1},
+	{0x4408, 0x00},
+	{0x4409, 0x00},
+	{0x440A, 0x18},
+	{0x440B, 0x1B},
+	{0x440C, 0x00},
+	{0x440D, 0x00},
+	{0x440E, 0x00},
+	{0x440F, 0x00},
+	{0x4410, 0x00},
+	{0x4411, 0x00},
+	{0x4412, 0x01},
+	{0x4413, 0x00},
+	{0x4414, 0x00},
+	{0x4415, 0x06},
+	{0x4417, 0x00},
+	{0x4418, 0x00},
+	{0x4419, 0x00},
+	{0x441A, 0x00},
+	{0x441B, 0x01},
+	{0x441C, 0x00},
+	{0x441D, 0x1B},
+	{0x441F, 0x1C},
+	{0x4420, 0x00},
+	{0x4421, 0xA1},
+	{0x4423, 0x1C},
+	{0x4424, 0x00},
+	{0x4425, 0xA1},
+	{0x4427, 0x1C},
+	{0x4428, 0x00},
+	{0x4429, 0xA1},
+	{0x442A, 0x00},
+	{0x442B, 0x00},
+	{0x442C, 0x01},
+	{0x442D, 0x07},
+	{0x442E, 0x00},
+	{0x442F, 0x00},
+	{0x4430, 0x01},
+	{0x4431, 0x01},
+	{0x4432, 0x00},
+	{0x4433, 0x08},
+	{0x4434, 0x01},
+	{0x4435, 0x07},
+	{0x4436, 0x00},
+	{0x4437, 0x00},
+	{0x4438, 0x01},
+	{0x4439, 0x00},
+	{0x443A, 0x00},
+	{0x443B, 0x08},
+	{0x443C, 0x01},
+	{0x443D, 0x00},
+	{0x443E, 0x00},
+	{0x443F, 0x08},
+	{0x4441, 0x00},
+	{0x4442, 0x00},
+	{0x4443, 0x00},
+	{0x4444, 0x00},
+	{0x4445, 0x00},
+	{0x4446, 0x02},
+	{0x4447, 0x09},
+	{0x4448, 0x00},
+	{0x4449, 0x00},
+	{0x444A, 0x00},
+	{0x444B, 0x00},
+	{0x444C, 0x00},
+	{0x444D, 0x00},
+	{0x444E, 0x00},
+	{0x444F, 0x01},
+	{0x4450, 0x00},
+	{0x4451, 0xA1},
+	{0x4452, 0x01},
+	{0x4453, 0x00},
+	{0x4454, 0x00},
+	{0x4455, 0x00},
+	{0x4457, 0x00},
+	{0x4458, 0x00},
+	{0x4459, 0x18},
+	{0x445A, 0x18},
+	{0x445B, 0x18},
+	{0x445C, 0x00},
+	{0x445D, 0x00},
+	{0x445E, 0x00},
+	{0x445F, 0x00},
+	{0x4460, 0x00},
+	{0x4461, 0x00},
+	{0x4462, 0x01},
+	{0x4463, 0x00},
+	{0x4464, 0x00},
+	{0x4465, 0x00},
+	{0x4466, 0x00},
+	{0x4467, 0x00},
+	{0x4468, 0x00},
+	{0x4469, 0x00},
+	{0x446A, 0x00},
+	{0x446B, 0x00},
+	{0x446C, 0x00},
+	{0x446D, 0x00},
+	{0x446E, 0x00},
+	{0x446F, 0x00},
+	{0x4470, 0x1D},
+	{0x4471, 0x00},
+	{0x4472, 0x00},
+	{0x4473, 0x00},
+	{0x4475, 0x00},
+	{0x4476, 0x00},
+	{0x4477, 0x00},
+	{0x4479, 0x00},
+	{0x447A, 0x00},
+	{0x447B, 0x00},
+	{0x447C, 0x00},
+	{0x447D, 0x00},
+	{0x447E, 0x00},
+	{0x447F, 0x00},
+	{0x4480, 0x00},
+	{0x4481, 0x1B},
+	{0x4482, 0x00},
+	{0x4483, 0x19},
+	{0x4484, 0x00},
+	{0x4485, 0x00},
+	{0x4486, 0x01},
+	{0x4487, 0x07},
+	{0x4488, 0x00},
+	{0x4489, 0x00},
+	{0x448A, 0x01},
+	{0x448B, 0x00},
+	{0x448C, 0x00},
+	{0x448D, 0x08},
+	{0x448E, 0x01},
+	{0x448F, 0x07},
+	{0x4490, 0x00},
+	{0x4491, 0x00},
+	{0x4492, 0x01},
+	{0x4493, 0x01},
+	{0x4494, 0x00},
+	{0x4495, 0x08},
+	{0x4496, 0x01},
+	{0x4497, 0x00},
+	{0x4498, 0x00},
+	{0x4499, 0x08},
+	{0x449B, 0x1C},
+	{0x449C, 0x00},
+	{0x449D, 0xA1},
+	{0x449F, 0x1C},
+	{0x44A0, 0x00},
+	{0x44A1, 0xA1},
+	{0x44A2, 0x00},
+	{0x44A3, 0x00},
+	{0x44A4, 0x00},
+	{0x44A5, 0x00},
+	{0x44A6, 0x00},
+	{0x44A7, 0x00},
+	{0x44A8, 0x18},
+	{0x44A9, 0x18},
+	{0x44AA, 0x00},
+	{0x44AB, 0x1B},
+	{0x44AC, 0x00},
+	{0x44AD, 0x00},
+	{0x44AE, 0x00},
+	{0x44AF, 0x01},
+	{0x4500, 0x00},
+	{0x4501, 0x19},
+	{0x4502, 0x39},
+	{0x4503, 0x0B},
+	{0x4504, 0x00},
+	{0x4505, 0x67},
+	{0x4506, 0x03},
+	{0x4507, 0x18},
+	{0x4508, 0x00},
+	{0x4509, 0x05},
+	{0x450A, 0x00},
+	{0x450B, 0xE9},
+	{0x450C, 0x18},
+	{0x450E, 0x00},
+	{0x450F, 0x00},
+	{0x4511, 0x00},
+	{0x4512, 0x00},
+	{0x4513, 0x01},
+	{0x4515, 0x00},
+	{0x4516, 0x00},
+	{0x4517, 0x01},
+	{0x4519, 0x00},
+	{0x451A, 0x00},
+	{0x451B, 0x00},
+	{0x451D, 0x00},
+	{0x451E, 0x00},
+	{0x451F, 0x00},
+	{0x4520, 0x0F},
+	{0x4521, 0x00},
+	{0x4522, 0x07},
+	{0x4523, 0x3B},
+	{0x4524, 0x00},
+	{0x4525, 0x01},
+	{0x4527, 0x00},
+	{0x4528, 0x00},
+	{0x4529, 0x01},
+	{0x452B, 0x00},
+	{0x452C, 0x00},
+	{0x452D, 0x00},
+	{0x452E, 0x00},
+	{0x452F, 0x00},
+	{0x4530, 0x0C},
+	{0x4531, 0x39},
+	{0x4532, 0x0D},
+	{0x4533, 0x02},
+	{0x4534, 0x0D},
+	{0x4535, 0x04},
+	{0x4537, 0x0D},
+	{0x4538, 0x00},
+	{0x4539, 0x00},
+	{0x453B, 0x00},
+	{0x453C, 0x00},
+	{0x453D, 0x00},
+	{0x453F, 0x0D},
+	{0x4540, 0x00},
+	{0x4541, 0x03},
+	{0x4543, 0x00},
+	{0x4544, 0x00},
+	{0x4545, 0x03},
+	{0x4547, 0x0D},
+	{0x4548, 0x00},
+	{0x4549, 0x00},
+	{0x454B, 0x00},
+	{0x454C, 0x00},
+	{0x454D, 0x00},
+	{0x454E, 0x0B},
+	{0x454F, 0x0F},
+	{0x4550, 0x0E},
+	{0x4551, 0x0A},
+	{0x4552, 0x00},
+	{0x4553, 0x05},
+	{0x4554, 0x00},
+	{0x4555, 0x32},
+	{0x4557, 0x00},
+	{0x4558, 0x00},
+	{0x4559, 0x32},
+	{0x455B, 0x00},
+	{0x455C, 0x02},
+	{0x455D, 0x0F},
+	{0x455E, 0x05},
+	{0x455F, 0x0B},
+	{0x4560, 0x03},
+	{0x4561, 0x09},
+	{0x4562, 0x07},
+	{0x4563, 0x18},
+	{0x4564, 0x00},
+	{0x4565, 0x00},
+	{0x4566, 0x00},
+	{0x4567, 0x06},
+	{0x4569, 0x01},
+	{0x456A, 0x02},
+	{0x456B, 0x0A},
+	{0x456C, 0x00},
+	{0x456D, 0x06},
+	{0x456F, 0x06},
+	{0x4570, 0x05},
+	{0x4571, 0x08},
+	{0x4572, 0x0C},
+	{0x4573, 0x08},
+	{0x4574, 0x00},
+	{0x4575, 0x02},
+	{0x4577, 0x00},
+	{0x4578, 0x00},
+	{0x4579, 0x02},
+	{0x457B, 0x02},
+	{0x457C, 0x04},
+	{0x457D, 0x0D},
+	{0x457E, 0x09},
+	{0x457F, 0x18},
+	{0x4581, 0x01},
+	{0x4582, 0x01},
+	{0x4583, 0x18},
+	{0x4584, 0x00},
+	{0x4585, 0x03},
+	{0x4586, 0x00},
+	{0x4587, 0x01},
+	{0x4588, 0x00},
+	{0x4589, 0x08},
+	{0x458A, 0x0D},
+	{0x458B, 0x02},
+	{0x458C, 0x0D},
+	{0x458D, 0x0F},
+	{0x458F, 0x00},
+	{0x4590, 0x00},
+	{0x4591, 0x00},
+	{0x4600, 0x08},
+	{0x4601, 0x60},
+	{0x4602, 0x00},
+	{0x4603, 0x21},
+	{0x4604, 0x00},
+	{0x4605, 0x0F},
+	{0x4606, 0x00},
+	{0x4607, 0xA3},
+	{0x4608, 0x00},
+	{0x4609, 0x00},
+	{0x460A, 0x18},
+	{0x460B, 0x1B},
+	{0x460C, 0x00},
+	{0x460D, 0x00},
+	{0x460E, 0x00},
+	{0x460F, 0x00},
+	{0x4610, 0x00},
+	{0x4611, 0x00},
+	{0x4700, 0x00},
+	{0x4701, 0x19},
+	{0x4702, 0x2E},
+	{0x4703, 0x0B},
+	{0x4704, 0x00},
+	{0x4705, 0x24},
+	{0x4706, 0x03},
+	{0x4707, 0x18},
+	{0x4708, 0x00},
+	{0x4709, 0x17},
+	{0x470A, 0x00},
+	{0x470B, 0xD1},
+	{0x470C, 0x18},
+	{0x470E, 0x00},
+	{0x470F, 0x00},
+	{0x5000, 0x00},
+	{0x5001, 0x00},
+	{0x5002, 0x07},
+	{0x5003, 0xC0},
+	{0x5004, 0x00},
+	{0x5005, 0x02},
+	{0x5006, 0x00},
+	{0x5007, 0x0C},
+	{0x5008, 0x00},
+	{0x5009, 0x24},
+	{0x500A, 0x10},
+	{0x500B, 0x3C},
+	{0x500C, 0x00},
+	{0x500D, 0x0D},
+	{0x500E, 0x10},
+	{0x500F, 0x00},
+	{0x5011, 0x01},
+	{0x5012, 0x07},
+	{0x5013, 0xFF},
+	{0x5014, 0x01},
+	{0x5015, 0x10},
+	{0x5016, 0x10},
+	{0x5017, 0xE4},
+	{0x5018, 0x10},
+	{0x5019, 0xE4},
+	{0x501A, 0x10},
+	{0x501B, 0xE4},
+	{0x501C, 0x11},
+	{0x501D, 0xC8},
+	{0x501E, 0x13},
+	{0x501F, 0x90},
+	{0x5020, 0x17},
+	{0x5021, 0x20},
+	{0x5022, 0x18},
+	{0x5023, 0x68},
+	{0x5024, 0x10},
+	{0x5025, 0xE4},
+	{0x5026, 0x10},
+	{0x5027, 0xE4},
+	{0x5028, 0x10},
+	{0x5029, 0xE4},
+	{0x502A, 0x11},
+	{0x502B, 0xC8},
+	{0x502C, 0x13},
+	{0x502D, 0x90},
+	{0x502E, 0x17},
+	{0x502F, 0x20},
+	{0x5030, 0x18},
+	{0x5031, 0x68},
+	{0x5032, 0x07},
+	{0x5033, 0xFF},
+	{0x5034, 0x07},
+	{0x5035, 0xFF},
+	{0x5036, 0x22},
+	{0x5037, 0x00},
+	{0x5039, 0x03},
+	{0x503A, 0x00},
+	{0x503B, 0x02},
+	{0x503C, 0x00},
+	{0x503D, 0x0A},
+	{0x503E, 0x01},
+	{0x503F, 0xD4},
+	{0x5040, 0x0A},
+	{0x5041, 0x0A},
+	{0x5043, 0x03},
+	{0x5044, 0x01},
+	{0x5045, 0x30},
+	{0x5046, 0xC1},
+	{0x5047, 0x00},
+	{0x5048, 0x00},
+	{0x5049, 0x00},
+	{0x5053, 0x11},
+	{0x5054, 0x01},
+	{0x5055, 0xA2},
+	{0x5056, 0x01},
+	{0x5057, 0xFF},
+	{0x505C, 0x78},
+	{0x505D, 0x00},
+	{0x505E, 0x00},
+	{0x505F, 0x00},
+	{0x5061, 0x00},
+	{0x5062, 0x0F},
+	{0x5063, 0xFE},
+	{0x5064, 0x00},
+	{0x5065, 0x01},
+	{0x5066, 0x01},
+	{0x5067, 0x00},
+	{0x5068, 0x00},
+	{0x5069, 0x06},
+	{0x506B, 0x8E},
+	{0x506C, 0x00},
+	{0x506D, 0x00},
+	{0x506E, 0x00},
+	{0x506F, 0x00},
+	{0x5070, 0x00},
+	{0x5071, 0x00},
+	{0x5072, 0x00},
+	{0x5073, 0x00},
+	{0x5074, 0x00},
+	{0x5075, 0x00},
+	{0x5076, 0x00},
+	{0x5077, 0x00},
+	{0x5078, 0x00},
+	{0x5079, 0x40},
+	{0x5090, 0x00},
+	{0x5091, 0x00},
+	{0x5096, 0x00},
+	{0x5097, 0x00},
+	{0x5098, 0x00},
+	{0x5099, 0x00},
+	{0x509A, 0x00},
+	{0x509B, 0x00},
+	{0x509C, 0x00},
+	{0x509D, 0x00},
+	{0x509E, 0x00},
+	{0x509F, 0x00},
+	{0x50A0, 0x00},
+	{0x50A1, 0x00},
+	{0x50A2, 0x00},
+	{0x50A3, 0x00},
+	{0x50A4, 0x00},
+	{0x50A5, 0x00},
+	{0x50A6, 0x00},
+	{0x50A7, 0x00},
+	{0x50A8, 0x00},
+	{0x50D0, 0x55},
+	{0x50D1, 0x00},
+	{0x50D2, 0x00},
+	{0x50D3, 0x00},
+	{0x50F1, 0x00},
+	{0x50F2, 0x00},
+	{0x50F3, 0x71},
+	{0x50F4, 0x01},
+	{0x50F5, 0x71},
+	{0x50F6, 0x03},
+	{0x50F7, 0xD0},
+	{0x50F8, 0x00},
+	{0x50F9, 0x00},
+	{0x50FA, 0x0A},
+	{0x50FB, 0x00},
+	{0x50FC, 0x00},
+	{0x50FD, 0x00},
+	{0x5100, 0x00},
+	{0x5101, 0x05},
+	{0x5102, 0x02},
+	{0x5103, 0x01},
+	{0x5104, 0x04},
+	{0x5105, 0x03},
+	{0x5108, 0x00},
+	{0x5109, 0x01},
+	{0x510A, 0x02},
+	{0x510B, 0x03},
+	{0x510C, 0x04},
+	{0x510D, 0x05},
+	{0x5110, 0x00},
+
+	/* sync code */
+	{0x5111, 0x4B},
+	{0x5112, 0x20},
+/*
+	{0x5114, 0x0A},
+	{0x5115, 0xB0},
+	{0x5116, 0x0B},
+	{0x5117, 0x60},
+	{0x5118, 0x08},
+	{0x5119, 0x00},
+	{0x511A, 0x09},
+	{0x511B, 0xD0},
+*/
+	{0x5120, 0x2C},
+	{0x5121, 0x13},
+	{0x5122, 0x12},
+	{0x5123, 0x10},
+	{0x5124, 0x00},
+	{0x5125, 0x00},
+	{0x5126, 0x05},
+	{0x5127, 0x00},
+	{0x5129, 0x50},
+	{0x5130, 0x03},
+	{0x5131, 0x14},
+	{0x5132, 0x04},
+	{0x5133, 0x01},
+	{0x5134, 0x0B},
+	{0x5135, 0x08},
+	{0x5136, 0x04},
+	{0x5137, 0x04},
+	{0x5138, 0x09},
+	{0x5139, 0x05},
+	{0x513A, 0x00},
+	{0x513B, 0x09},
+	{0x513D, 0xE4},
+	{0x513E, 0x00},
+	{0x513F, 0x00},
+	{0x5140, 0x04},
+	{0x5141, 0x54},
+	{0x5142, 0x00},
+	{0x5143, 0x00},
+	{0x5144, 0x04},
+	{0x5145, 0x53},
+/*
+	{0x5146, 0x00},
+	{0x5147, 0x02},
+	{0x5148, 0x00},
+	{0x5149, 0x03},
+	{0x514A, 0x00},
+	{0x514B, 0x00},
+	{0x514C, 0x00},
+	{0x514D, 0x01},
+	{0x514E, 0x00},
+	{0x514F, 0x02},
+	{0x5150, 0x00},
+	{0x5151, 0x03},
+	{0x5152, 0x00},
+	{0x5153, 0x00},
+	{0x5154, 0x00},
+	{0x5155, 0x01},
+	{0x5156, 0x00},
+	{0x5157, 0x02},
+	{0x5158, 0x00},
+	{0x5159, 0x03},
+	{0x515A, 0x00},
+	{0x515B, 0x00},
+	{0x515C, 0x00},
+	{0x515D, 0x01},
+*/
+	{0x5160, 0x00},
+	{0x5161, 0x00},
+	{0x5162, 0x00},
+	{0x5163, 0x00},
+	{0x5164, 0x00},
+	{0x5165, 0x00},
+	{0x5166, 0x00},
+	{0x5167, 0x00},
+	{0x5168, 0x00},
+	{0x5169, 0x00},
+	{0x516A, 0x00},
+	{0x516B, 0x00},
+	{0x516C, 0x00},
+	{0x516D, 0x00},
+	{0x516E, 0x00},
+	{0x516F, 0x00},
+	{0x5170, 0x00},
+	{0x5171, 0x00},
+	{0x5172, 0x00},
+	{0x5173, 0x00},
+	{0x5174, 0x00},
+	{0x5175, 0x00},
+	{0x5176, 0x00},
+	{0x5177, 0x00},
+	{0x5178, 0xE4},
+	{0x5179, 0x00},
+	{0x517A, 0x04},
+	{0x517B, 0x50},
+	{0x517C, 0x00},
+	{0x517D, 0x00},
+	{0x517E, 0x00},
+	{0x5180, 0x00},
+	{0x5181, 0x00},
+	{0x5182, 0x00},
+	{0x5183, 0x00},
+	{0x5184, 0x00},
+	{0x5186, 0x00},
+	{0x5187, 0x00},
+	{0x5188, 0x00},
+	{0x5189, 0x00},
+	{0x518A, 0x00},
+	{0x518B, 0x00},
+	{0x518D, 0x00},
+	{0x518E, 0x00},
+	{0x518F, 0x00},
+	{0x5190, 0x00},
+	{0x5191, 0x00},
+	{0x5192, 0x00},
+	{0x5194, 0x00},
+	{0x5195, 0x00},
+	{0x5196, 0x00},
+	{0x5197, 0x00},
+	{0x5198, 0x00},
+	{0x5199, 0x00},
+	{0x519B, 0x00},
+	{0x519E, 0xFF},
+	{0x519F, 0xFE},
+	{0x51A0, 0x00},
+	{0x51A1, 0x01},
+	{0x51A2, 0x03},
+	{0x51A3, 0x00},
+	{0x603D, 0x00},
+	{0x603D, 0x01},
+	{0x6000, 0x04},
+	{0x6001, 0xF8},
+	{0x6026, 0x04},
+	{0x6027, 0xF7},
+	{0x3000, 0x01},
+	{0x3001, 0xD3},
+	{0x3000, 0x21},
+	{0x3001, 0xD3},
+};
+
+static struct vin_reg_16_8 mn34420pl_2lane_wuxga_regs[] = {
+	{0x300D, 0x20},
+	{0x300F, 0x03},
+	{0x3003, 0x84},
+	{0x3005, 0x42},
+	{0x3008, 0x35},
+	{0x3000, 0x01},
+	{0x3001, 0x03},
+	{0x3000, 0x01},
+	{0x3001, 0x53},
+	{0x300E, 0x00},
+	{0x300F, 0x00},
+	{0x3200, 0x3F},
+	{0x3201, 0x06},
+	{0x3206, 0xA7},
+	{0x3207, 0x78},
+	{0x3208, 0x49},
+	{0x3030, 0x0E},
+	{0x3041, 0x00},
+	{0x3049, 0x30},
+	{0x304B, 0x01},
+	{0x304C, 0x31},
+	{0x304D, 0x03},
+	{0x3051, 0x50},
+	{0x3053, 0x00},
+	{0x3056, 0x04},
+	{0x305A, 0x1F},
+	{0x3101, 0x20},
+	{0x3103, 0x20},
+	{0x3104, 0x00},
+	{0x3105, 0x02},
+	{0x3109, 0x20},
+	{0x310B, 0x20},
+	{0x310C, 0x00},
+	{0x310D, 0x16},
+	{0x3111, 0x20},
+	{0x3113, 0x20},
+	{0x3114, 0x00},
+	{0x3115, 0x16},
+	{0x3117, 0x20},
+	{0x3119, 0x20},
+	{0x311A, 0x00},
+	{0x311B, 0x16},
+	{0x3121, 0x00},
+	{0x3123, 0xBB},
+	{0x3127, 0xCC},
+	{0x3140, 0x00},
+	{0x3141, 0xE0},
+	{0x3142, 0x00},
+	{0x3143, 0x47},
+	{0x4003, 0x07},
+	{0x4005, 0x13},
+	{0x400A, 0x00},
+	{0x4013, 0x25},
+	{0x4014, 0x17},
+	{0x4015, 0x10},
+	{0x4016, 0x40},
+	{0x4018, 0xF8},
+	{0x401B, 0x38},
+	{0x401D, 0x38},
+	{0x401F, 0x28},
+	{0x4021, 0x38},
+	{0x4023, 0x28},
+	{0x4025, 0x29},
+	{0x4027, 0x29},
+	{0x4029, 0x29},
+	{0x402B, 0x29},
+	{0x402D, 0x2B},
+	{0x402F, 0x2B},
+	{0x4031, 0x2A},
+	{0x4033, 0x2E},
+	{0x4035, 0x2F},
+	{0x4037, 0x2D},
+	{0x4039, 0x2D},
+	{0x403B, 0x2F},
+	{0x403D, 0x2F},
+	{0x403F, 0x2E},
+	{0x4041, 0x2D},
+	{0x4043, 0x25},
+	{0x4045, 0x27},
+	{0x4047, 0x27},
+	{0x404D, 0x06},
+	{0x404E, 0x08},
+	{0x404F, 0x12},
+	{0x4050, 0x0F},
+	{0x4051, 0x0C},
+	{0x4052, 0x0B},
+	{0x4053, 0x0A},
+	{0x4054, 0x08},
+	{0x4055, 0x07},
+	{0x4056, 0x06},
+	{0x4057, 0x04},
+	{0x4058, 0x01},
+	{0x4062, 0x00},
+	{0x4063, 0x00},
+	{0x4064, 0x31},
+	{0x410A, 0x00},
+	{0x410F, 0x00},
+	{0x4110, 0x00},
+	{0x4111, 0x22},
+	{0x4118, 0x1C},
+	{0x411C, 0xBA},
+	{0x411E, 0x00},
+	{0x411F, 0x22},
+	{0x4120, 0x02},
+	{0x4124, 0x60},
+	{0x4125, 0x88},
+	{0x4128, 0x90},
+	{0x4129, 0x99},
+	{0x4209, 0xAA},
+	{0x420A, 0x80},
+	{0x4214, 0xF0},
+	{0x4303, 0xE1},
+	{0x4304, 0x04},
+	{0x4305, 0x37},
+	{0x4307, 0x01},
+	{0x4308, 0x00},
+	{0x4309, 0x00},
+	{0x4318, 0x23},
+	{0x431B, 0x02},
+	{0x431D, 0x02},
+	{0x431F, 0x02},
+	{0x4325, 0xD9},
+	{0x4327, 0xAA},
+	{0x4329, 0xD8},
+	{0x432B, 0xCE},
+	{0x432D, 0xCF},
+	{0x432F, 0xD7},
+	{0x4331, 0xD8},
+	{0x4332, 0x04},
+	{0x4333, 0xD9},
+	{0x4334, 0x04},
+	{0x4335, 0xD9},
+	{0x4343, 0x3C},
+	{0x4361, 0x39},
+	{0x4400, 0x09},
+	{0x4401, 0x67},
+	{0x4403, 0x63},
+	{0x4406, 0x00},
+	{0x4407, 0x55},
+	{0x440A, 0x29},
+	{0x4412, 0x01},
+	{0x4415, 0x06},
+	{0x441C, 0x30},
+	{0x441F, 0x0B},
+	{0x4420, 0x00},
+	{0x4421, 0x55},
+	{0x4423, 0x0B},
+	{0x4424, 0x00},
+	{0x4425, 0x55},
+	{0x4427, 0x0B},
+	{0x4428, 0x00},
+	{0x4429, 0x55},
+	{0x442C, 0x01},
+	{0x442D, 0x07},
+	{0x4430, 0x31},
+	{0x4431, 0x01},
+	{0x4432, 0x01},
+	{0x4433, 0x08},
+	{0x4434, 0x01},
+	{0x4435, 0x07},
+	{0x4438, 0x31},
+	{0x443B, 0x08},
+	{0x443C, 0x31},
+	{0x443F, 0x08},
+	{0x4445, 0x00},
+	{0x4446, 0x32},
+	{0x4447, 0x39},
+	{0x444F, 0x01},
+	{0x4450, 0x00},
+	{0x4451, 0x55},
+	{0x4452, 0x01},
+	{0x4459, 0x29},
+	{0x445A, 0x29},
+	{0x445B, 0x29},
+	{0x4463, 0x00},
+	{0x4470, 0x0A},
+	{0x4475, 0x30},
+	{0x4477, 0x00},
+	{0x447E, 0x01},
+	{0x447F, 0x01},
+	{0x4482, 0x00},
+	{0x4483, 0x19},
+	{0x4484, 0x30},
+	{0x4486, 0x01},
+	{0x4487, 0x07},
+	{0x448A, 0x31},
+	{0x448D, 0x08},
+	{0x448E, 0x01},
+	{0x448F, 0x07},
+	{0x4492, 0x31},
+	{0x4493, 0x01},
+	{0x4494, 0x01},
+	{0x4495, 0x08},
+	{0x4496, 0x31},
+	{0x4499, 0x08},
+	{0x449B, 0x0B},
+	{0x449C, 0x00},
+	{0x449D, 0x55},
+	{0x449F, 0x0B},
+	{0x44A0, 0x00},
+	{0x44A1, 0x55},
+	{0x44A8, 0x29},
+	{0x44A9, 0x29},
+	{0x44AE, 0x30},
+	{0x44AF, 0x31},
+	{0x4502, 0x24},
+	{0x4505, 0x22},
+	{0x4509, 0x05},
+	{0x450A, 0x00},
+	{0x450B, 0x7D},
+	{0x450C, 0x18},
+	{0x4517, 0x01},
+	{0x451F, 0x00},
+	{0x4520, 0x0F},
+	{0x4522, 0x07},
+	{0x4523, 0x16},
+	{0x4529, 0x01},
+	{0x4530, 0x0C},
+	{0x4531, 0x3E},
+	{0x453D, 0x00},
+	{0x4545, 0x03},
+	{0x454D, 0x00},
+	{0x4555, 0x3F},
+	{0x4559, 0x3F},
+	{0x456D, 0x06},
+	{0x4579, 0x02},
+	{0x5007, 0x0C},
+	{0x5015, 0x11},
+	{0x5016, 0x10},
+	{0x5017, 0xE4},
+	{0x5018, 0x10},
+	{0x5019, 0xE4},
+	{0x501A, 0x10},
+	{0x501B, 0xE4},
+	{0x501C, 0x11},
+	{0x501D, 0xC8},
+	{0x501E, 0x13},
+	{0x501F, 0x90},
+	{0x5020, 0x17},
+	{0x5021, 0x20},
+	{0x5022, 0x18},
+	{0x5023, 0x68},
+	{0x5024, 0x10},
+	{0x5025, 0xE4},
+	{0x5026, 0x10},
+	{0x5027, 0xE4},
+	{0x5028, 0x10},
+	{0x5029, 0xE4},
+	{0x502A, 0x11},
+	{0x502B, 0xC8},
+	{0x502C, 0x13},
+	{0x502D, 0x90},
+	{0x502E, 0x17},
+	{0x502F, 0x20},
+	{0x5030, 0x18},
+	{0x5031, 0x68},
+	{0x503B, 0x02},
+	{0x503D, 0x0A},
+	{0x5043, 0x03},
+	{0x5044, 0x01},
+	{0x5045, 0x30},
+	{0x5046, 0xC1},
+	{0x5053, 0x11},
+	{0x5054, 0x01},
+	{0x5055, 0xA2},
+	{0x5056, 0x01},
+	{0x5057, 0xFF},
+	{0x505C, 0x78},
+	{0x5062, 0x03},
+	{0x5066, 0x00},
+	{0x5067, 0x40},
+	{0x506B, 0x8E},
+	{0x5079, 0x80},
+	{0x50F2, 0x60},
+	{0x50F4, 0x51},
+
+	/* sync code */
+	{0x5111, 0x4B},
+	{0x5112, 0x20},
+	/*
+	{0x5114, 0x02},
+	{0x5115, 0xAC},
+	{0x5116, 0x02},
+	{0x5117, 0xD8},
+	{0x5118, 0x02},
+	{0x5119, 0x00},
+	{0x511A, 0x02},
+	{0x511B, 0x74},
+	*/
+	{0x5141, 0xCC},
+	{0x5145, 0xCB},
+	{0x603D, 0x01},
+	{0x6001, 0xF8},
+	{0x6027, 0xF7},
+	{0x3000, 0x01},
+	{0x3001, 0xD3},
+	{0x3000, 0x21},
+	{0x3001, 0xD3},
+};
+
+static struct vin_reg_16_8 mn34420pl_2lane_1080p_regs[] = {
+	{0x300D, 0x20},
+	{0x300F, 0x03},
+	{0x3003, 0x84},
+	{0x3005, 0x42},
+	{0x3008, 0x35},
+	{0x3000, 0x01},
+	{0x3001, 0x03},
+	{0x3000, 0x01},
+	{0x3001, 0x53},
+	{0x300E, 0x00},
+	{0x300F, 0x00},
+	{0x3200, 0x3F},
+	{0x3201, 0x06},
+	{0x3206, 0xA7},
+	{0x3207, 0x78},
+	{0x3208, 0x49},
+	{0x3030, 0x0E},
+	{0x3041, 0x00},
+	{0x3049, 0x30},
+	{0x304B, 0x01},
+	{0x304C, 0x31},
+	{0x304D, 0x03},
+	{0x3051, 0x50},
+	{0x3053, 0x00},
+	{0x3056, 0x04},
+	{0x305A, 0x1F},
+	{0x3101, 0x20},
+	{0x3103, 0x20},
+	{0x3104, 0x00},
+	{0x3105, 0x02},
+	{0x3109, 0x20},
+	{0x310B, 0x20},
+	{0x310C, 0x00},
+	{0x310D, 0x16},
+	{0x3111, 0x20},
+	{0x3113, 0x20},
+	{0x3114, 0x00},
+	{0x3115, 0x16},
+	{0x3117, 0x20},
+	{0x3119, 0x20},
+	{0x311A, 0x00},
+	{0x311B, 0x16},
+	{0x3121, 0x3C},
+	{0x3123, 0x7F},
+	{0x3127, 0x54},
+	{0x3140, 0x00},
+	{0x3141, 0xE0},
+	{0x3142, 0x00},
+	{0x3143, 0x47},
+	{0x4003, 0x07},
+	{0x400A, 0x00},
+	{0x4013, 0x25},
+	{0x4014, 0x17},
+	{0x4015, 0x10},
+	{0x4016, 0x40},
+	{0x4018, 0xF8},
+	{0x401B, 0x38},
+	{0x401D, 0x38},
+	{0x401F, 0x28},
+	{0x4021, 0x38},
+	{0x4023, 0x28},
+	{0x4025, 0x29},
+	{0x4027, 0x29},
+	{0x4029, 0x29},
+	{0x402B, 0x29},
+	{0x402D, 0x2B},
+	{0x402F, 0x2B},
+	{0x4031, 0x2A},
+	{0x4033, 0x2E},
+	{0x4035, 0x2F},
+	{0x4037, 0x2D},
+	{0x4039, 0x2D},
+	{0x403B, 0x2F},
+	{0x403D, 0x2F},
+	{0x403F, 0x2E},
+	{0x4041, 0x2D},
+	{0x4043, 0x25},
+	{0x4045, 0x27},
+	{0x4047, 0x27},
+	{0x404D, 0x06},
+	{0x404E, 0x08},
+	{0x404F, 0x12},
+	{0x4050, 0x0F},
+	{0x4051, 0x0C},
+	{0x4052, 0x0B},
+	{0x4053, 0x0A},
+	{0x4054, 0x08},
+	{0x4055, 0x07},
+	{0x4056, 0x06},
+	{0x4057, 0x04},
+	{0x4058, 0x01},
+	{0x4062, 0x00},
+	{0x4063, 0x00},
+	{0x4064, 0x31},
+	{0x410A, 0x00},
+	{0x410F, 0x00},
+	{0x4110, 0x00},
+	{0x4111, 0x22},
+	{0x4118, 0x1C},
+	{0x411C, 0xBA},
+	{0x411E, 0x00},
+	{0x411F, 0x22},
+	{0x4120, 0x02},
+	{0x4124, 0x60},
+	{0x4125, 0x88},
+	{0x4128, 0x90},
+	{0x4129, 0x99},
+	{0x4209, 0xAA},
+	{0x420A, 0x80},
+	{0x4214, 0xF0},
+	{0x4303, 0xE1},
+	{0x4304, 0x04},
+	{0x4305, 0x37},
+	{0x4307, 0x01},
+	{0x4308, 0x00},
+	{0x4309, 0x00},
+	{0x4318, 0x23},
+	{0x431B, 0x02},
+	{0x431D, 0x02},
+	{0x431F, 0x02},
+	{0x4325, 0x61},
+	{0x4327, 0xAA},
+	{0x4329, 0x60},
+	{0x432D, 0x57},
+	{0x432F, 0x5F},
+	{0x4332, 0x04},
+	{0x4333, 0x61},
+	{0x4334, 0x04},
+	{0x4335, 0x61},
+	{0x4343, 0x3C},
+	{0x4361, 0x39},
+	{0x4400, 0x09},
+	{0x4401, 0x67},
+	{0x4403, 0x63},
+	{0x4406, 0x00},
+	{0x4407, 0x55},
+	{0x440A, 0x29},
+	{0x4412, 0x01},
+	{0x4415, 0x06},
+	{0x441C, 0x30},
+	{0x441F, 0x0B},
+	{0x4420, 0x00},
+	{0x4421, 0x55},
+	{0x4423, 0x0B},
+	{0x4424, 0x00},
+	{0x4425, 0x55},
+	{0x4427, 0x0B},
+	{0x4428, 0x00},
+	{0x4429, 0x55},
+	{0x442C, 0x01},
+	{0x442D, 0x07},
+	{0x4430, 0x31},
+	{0x4431, 0x01},
+	{0x4432, 0x01},
+	{0x4433, 0x08},
+	{0x4434, 0x01},
+	{0x4435, 0x07},
+	{0x4438, 0x31},
+	{0x443B, 0x08},
+	{0x443C, 0x31},
+	{0x443F, 0x08},
+	{0x4445, 0x00},
+	{0x4446, 0x32},
+	{0x4447, 0x39},
+	{0x444F, 0x01},
+	{0x4450, 0x00},
+	{0x4451, 0x55},
+	{0x4452, 0x01},
+	{0x4459, 0x29},
+	{0x445A, 0x29},
+	{0x445B, 0x29},
+	{0x4463, 0x00},
+	{0x4470, 0x0A},
+	{0x4475, 0x30},
+	{0x4477, 0x00},
+	{0x447E, 0x01},
+	{0x447F, 0x01},
+	{0x4482, 0x00},
+	{0x4483, 0x19},
+	{0x4484, 0x30},
+	{0x4486, 0x01},
+	{0x4487, 0x07},
+	{0x448A, 0x31},
+	{0x448D, 0x08},
+	{0x448E, 0x01},
+	{0x448F, 0x07},
+	{0x4492, 0x31},
+	{0x4493, 0x01},
+	{0x4494, 0x01},
+	{0x4495, 0x08},
+	{0x4496, 0x31},
+	{0x4499, 0x08},
+	{0x449B, 0x0B},
+	{0x449C, 0x00},
+	{0x449D, 0x55},
+	{0x449F, 0x0B},
+	{0x44A0, 0x00},
+	{0x44A1, 0x55},
+	{0x44A8, 0x29},
+	{0x44A9, 0x29},
+	{0x44AE, 0x30},
+	{0x44AF, 0x31},
+	{0x4502, 0x24},
+	{0x4505, 0x22},
+	{0x4509, 0x05},
+	{0x450A, 0x00},
+	{0x450B, 0x7D},
+	{0x450C, 0x18},
+	{0x4517, 0x01},
+	{0x451F, 0x00},
+	{0x4520, 0x0F},
+	{0x4522, 0x07},
+	{0x4523, 0x16},
+	{0x4529, 0x01},
+	{0x4530, 0x0C},
+	{0x4531, 0x3E},
+	{0x453D, 0x00},
+	{0x4545, 0x03},
+	{0x454D, 0x00},
+	{0x4555, 0x3F},
+	{0x4559, 0x3F},
+	{0x456D, 0x06},
+	{0x4579, 0x02},
+	{0x5007, 0x0C},
+	{0x5015, 0x11},
+	{0x5016, 0x10},
+	{0x5017, 0xE4},
+	{0x5018, 0x10},
+	{0x5019, 0xE4},
+	{0x501A, 0x10},
+	{0x501B, 0xE4},
+	{0x501C, 0x11},
+	{0x501D, 0xC8},
+	{0x501E, 0x13},
+	{0x501F, 0x90},
+	{0x5020, 0x17},
+	{0x5021, 0x20},
+	{0x5022, 0x18},
+	{0x5023, 0x68},
+	{0x5024, 0x10},
+	{0x5025, 0xE4},
+	{0x5026, 0x10},
+	{0x5027, 0xE4},
+	{0x5028, 0x10},
+	{0x5029, 0xE4},
+	{0x502A, 0x11},
+	{0x502B, 0xC8},
+	{0x502C, 0x13},
+	{0x502D, 0x90},
+	{0x502E, 0x17},
+	{0x502F, 0x20},
+	{0x5030, 0x18},
+	{0x5031, 0x68},
+	{0x503B, 0x02},
+	{0x503D, 0x0A},
+	{0x5043, 0x03},
+	{0x5044, 0x01},
+	{0x5045, 0x30},
+	{0x5046, 0xC1},
+	{0x5053, 0x11},
+	{0x5054, 0x01},
+	{0x5055, 0xA2},
+	{0x5056, 0x01},
+	{0x5057, 0xFF},
+	{0x505C, 0x78},
+	{0x5062, 0x03},
+	{0x5066, 0x00},
+	{0x5067, 0x40},
+	{0x506B, 0x8E},
+	{0x5079, 0x80},
+	{0x50F2, 0x60},
+	{0x50F4, 0x51},
+
+	/* sync code */
+	{0x5111, 0x4B},
+	{0x5112, 0x20},
+
+	{0x603D, 0x00},
+	{0x603D, 0x01},
+	{0x6001, 0xF8},
+	{0x6027, 0xF7},
+	{0x3000, 0x01},
+	{0x3001, 0xD3},
+	{0x3000, 0x21},
+	{0x3001, 0xD3},
+};
+
+static struct vin_reg_16_8 mn34420pl_2x_hdr_10bit_mode_regs[] = {
+	/* VCYCLE:1500 HCYCLE:1200 (@MCLK) */
+	{0x300D, 0x20},
+	{0x300F, 0x03},
+	{0x3003, 0x84},
+	{0x3005, 0x42},
+	{0x3008, 0x35},
+	{0x3000, 0x01},
+	{0x3001, 0x03},
+	{0x3000, 0x01},
+	{0x3001, 0x53},
+	{0x300E, 0x00},
+	{0x300F, 0x00},
+	{0x3200, 0x3F},
+	{0x3201, 0x06},
+	{0x3206, 0xA7},
+	{0x3207, 0x78},
+	{0x3208, 0x49},
+	{0x301C, 0x00},
+	{0x302B, 0x1F},
+	{0x3030, 0x4E},
+	{0x3041, 0x00},
+	{0x3049, 0x30},
+	{0x304B, 0x01},
+	{0x304C, 0x31},
+	{0x304D, 0x03},
+	{0x3051, 0x50},
+	{0x3053, 0x00},
+	{0x3056, 0x04},
+	{0x305A, 0x1F},
+	{0x3101, 0x20},
+	{0x3103, 0x20},
+	{0x3104, 0x02},
+	{0x3105, 0x71},
+	{0x3109, 0x20},
+	{0x310B, 0x20},
+	{0x310C, 0x00},
+	{0x310D, 0x01},
+	{0x3111, 0x20},
+	{0x3113, 0x20},
+	{0x3114, 0x00},
+	{0x3115, 0x16},
+	{0x3117, 0x20},
+	{0x3119, 0x20},
+	{0x311A, 0x00},
+	{0x311B, 0x16},
+	{0x3121, 0x3C},
+	{0x3123, 0x7F},
+	{0x3127, 0x54},
+	{0x3140, 0x00},
+	{0x3141, 0xE0},
+	{0x3142, 0x00},
+	{0x3143, 0x47},
+	{0x4003, 0x07},
+	{0x400A, 0x01},
+	{0x4013, 0x25},
+	{0x4014, 0x17},
+	{0x4015, 0x10},
+	{0x4016, 0x40},
+	{0x4018, 0xF8},
+	{0x401B, 0x38},
+	{0x401D, 0x38},
+	{0x401F, 0x28},
+	{0x4021, 0x38},
+	{0x4023, 0x28},
+	{0x4025, 0x29},
+	{0x4027, 0x29},
+	{0x4029, 0x29},
+	{0x402B, 0x29},
+	{0x402D, 0x2B},
+	{0x402F, 0x2B},
+	{0x4031, 0x2A},
+	{0x4033, 0x2E},
+	{0x4035, 0x2F},
+	{0x4037, 0x2D},
+	{0x4039, 0x2D},
+	{0x403B, 0x2F},
+	{0x403D, 0x2F},
+	{0x403F, 0x2E},
+	{0x4041, 0x2D},
+	{0x4043, 0x25},
+	{0x4045, 0x27},
+	{0x4047, 0x27},
+	{0x404D, 0x06},
+	{0x404E, 0x08},
+	{0x404F, 0x12},
+	{0x4050, 0x0F},
+	{0x4051, 0x0C},
+	{0x4052, 0x0B},
+	{0x4053, 0x0A},
+	{0x4054, 0x08},
+	{0x4055, 0x07},
+	{0x4056, 0x06},
+	{0x4057, 0x04},
+	{0x4058, 0x01},
+	{0x4062, 0x00},
+	{0x4063, 0x00},
+	{0x4064, 0x31},
+	{0x410A, 0x00},
+	{0x410F, 0x00},
+	{0x4110, 0x00},
+	{0x4111, 0x22},
+	{0x4118, 0x1C},
+	{0x411C, 0xBA},
+	{0x411E, 0x00},
+	{0x411F, 0x22},
+	{0x4120, 0x02},
+	{0x4124, 0x60},
+	{0x4125, 0x88},
+	{0x4128, 0x90},
+	{0x4129, 0x99},
+	{0x4209, 0xAA},
+	{0x420A, 0x80},
+	{0x4214, 0xF0},
+	{0x4301, 0x10},
+	{0x4303, 0xE1},
+	{0x4304, 0x04},
+	{0x4305, 0x37},
+	{0x4307, 0x01},
+	{0x4308, 0x02},
+	{0x4309, 0x19},
+	{0x4318, 0x23},
+	{0x431B, 0x02},
+	{0x431D, 0x02},
+	{0x431F, 0x02},
+	{0x4325, 0x61},
+	{0x4327, 0xAA},
+	{0x4329, 0x60},
+	{0x432D, 0x57},
+	{0x432F, 0x5F},
+	{0x4343, 0x3C},
+	{0x4361, 0x39},
+	{0x4400, 0x09},
+	{0x4401, 0x67},
+	{0x4403, 0x63},
+	{0x4406, 0x00},
+	{0x4407, 0x55},
+	{0x440A, 0x29},
+	{0x4412, 0x01},
+	{0x4415, 0x06},
+	{0x441C, 0x30},
+	{0x441F, 0x0B},
+	{0x4420, 0x00},
+	{0x4421, 0x55},
+	{0x4423, 0x0B},
+	{0x4424, 0x00},
+	{0x4425, 0x55},
+	{0x4427, 0x0B},
+	{0x4428, 0x00},
+	{0x4429, 0x55},
+	{0x442C, 0x01},
+	{0x442D, 0x07},
+	{0x4430, 0x31},
+	{0x4431, 0x01},
+	{0x4432, 0x01},
+	{0x4433, 0x08},
+	{0x4434, 0x01},
+	{0x4435, 0x07},
+	{0x4438, 0x31},
+	{0x443B, 0x08},
+	{0x443C, 0x31},
+	{0x443F, 0x08},
+	{0x4445, 0x00},
+	{0x4446, 0x32},
+	{0x4447, 0x39},
+	{0x444F, 0x01},
+	{0x4450, 0x00},
+	{0x4451, 0x55},
+	{0x4452, 0x01},
+	{0x4459, 0x29},
+	{0x445A, 0x29},
+	{0x445B, 0x29},
+	{0x4463, 0x00},
+	{0x4470, 0x0A},
+	{0x4475, 0x30},
+	{0x4477, 0x00},
+	{0x447E, 0x01},
+	{0x447F, 0x01},
+	{0x4482, 0x00},
+	{0x4483, 0x19},
+	{0x4484, 0x30},
+	{0x4486, 0x01},
+	{0x4487, 0x07},
+	{0x448A, 0x31},
+	{0x448D, 0x08},
+	{0x448E, 0x01},
+	{0x448F, 0x07},
+	{0x4492, 0x31},
+	{0x4493, 0x01},
+	{0x4494, 0x01},
+	{0x4495, 0x08},
+	{0x4496, 0x31},
+	{0x4499, 0x08},
+	{0x449B, 0x0B},
+	{0x449C, 0x00},
+	{0x449D, 0x55},
+	{0x449F, 0x0B},
+	{0x44A0, 0x00},
+	{0x44A1, 0x55},
+	{0x44A8, 0x29},
+	{0x44A9, 0x29},
+	{0x44AE, 0x30},
+	{0x44AF, 0x31},
+	{0x4502, 0x24},
+	{0x4505, 0x22},
+	{0x4509, 0x05},
+	{0x450A, 0x00},
+	{0x450B, 0x7D},
+	{0x450C, 0x18},
+	{0x4517, 0x01},
+	{0x451F, 0x00},
+	{0x4520, 0x0F},
+	{0x4522, 0x07},
+	{0x4523, 0x16},
+	{0x4529, 0x01},
+	{0x4530, 0x0C},
+	{0x4531, 0x3E},
+	{0x453D, 0x00},
+	{0x4545, 0x03},
+	{0x454D, 0x00},
+	{0x4555, 0x3F},
+	{0x4559, 0x3F},
+	{0x456D, 0x06},
+	{0x4579, 0x02},
+	{0x5007, 0x0C},
+	{0x5015, 0x11},
+	{0x5016, 0x10},
+	{0x5017, 0xE4},
+	{0x5018, 0x10},
+	{0x5019, 0xE4},
+	{0x501A, 0x10},
+	{0x501B, 0xE4},
+	{0x501C, 0x11},
+	{0x501D, 0xC8},
+	{0x501E, 0x13},
+	{0x501F, 0x90},
+	{0x5020, 0x17},
+	{0x5021, 0x20},
+	{0x5022, 0x18},
+	{0x5023, 0x68},
+	{0x5024, 0x10},
+	{0x5025, 0xE4},
+	{0x5026, 0x10},
+	{0x5027, 0xE4},
+	{0x5028, 0x10},
+	{0x5029, 0xE4},
+	{0x502A, 0x11},
+	{0x502B, 0xC8},
+	{0x502C, 0x13},
+	{0x502D, 0x90},
+	{0x502E, 0x17},
+	{0x502F, 0x20},
+	{0x5030, 0x18},
+	{0x5031, 0x68},
+	{0x503B, 0x02},
+	{0x503D, 0x0A},
+	{0x5043, 0x03},
+	{0x5044, 0x01},
+	{0x5045, 0x30},
+	{0x5046, 0xC1},
+	{0x5053, 0x11},
+	{0x5054, 0x01},
+	{0x5055, 0xA2},
+	{0x5056, 0x01},
+	{0x5057, 0xFF},
+	{0x505C, 0x78},
+	{0x5062, 0x03},
+	{0x5066, 0x00},
+	{0x5067, 0x40},
+	{0x506B, 0x8E},
+	{0x5079, 0x80},
+	{0x50F2, 0x40},
+	{0x50F4, 0x11},
+
+	/* sync code */
+	{0x5111, 0x4B},
+	{0x5112, 0x20},
+
+	{0x603D, 0x00},
+	{0x603D, 0x01},
+	{0x6001, 0xF8},
+	{0x6027, 0xF7},
+	{0x3000, 0x01},
+	{0x3001, 0xD3},
+	{0x3000, 0x21},
+	{0x3001, 0xD3},
+};
+
+#ifdef CONFIG_PM
+static struct vin_reg_16_16 pm_regs[] = {
+	{MN34420PL_SHTPOS_H, 0x0000},
+	{MN34420PL_SHTPOS_WDR1, 0x0000},
+	{MN34420PL_SHTPOS_WDR2, 0x0000},
+	{MN34420PL_AGAIN_H, 0x0000},
+	{MN34420PL_DGAIN_H, 0x0000},
+	{MN34420PL_AGAIN_WDR1, 0x0000},
+	{MN34420PL_AGAIN_WDR2, 0x0000},
+	{MN34420PL_DGAIN_WDR1, 0x0000},
+	{MN34420PL_DGAIN_WDR2, 0x0000},
+};
+#endif
+
+#define MN34420PL_GAIN_COLS		(2)
+#define MN34420PL_GAIN_COL_AGAIN	(0)
+#define MN34420PL_GAIN_COL_DGAIN	(1)
+
+#ifdef USE_GAIN_0P375DB_STEPS
+/** MN34420PL global gain table row size */
+#define MN34420PL_GAIN_ROWS		(172 + 1)
+#define MN34420PL_GAIN_MAXDB		(172)
+#define MN34420PL_WDR_GAIN_30DB	(80)
+#define MN34420PL_WDR_DGAIN_ON	(92)
+
+/* MN34420PL_GAIN_ROWS = 173, MN34420PL_GAIN_COLS = 2, typical pixel gain = 4.50db */
+static const u16 MN34420PL_GAIN_TABLE[MN34420PL_GAIN_ROWS][MN34420PL_GAIN_COLS] = {
+	{0x0120, 0x0120}, /* index:0, gain:0.00000db, again:0.00000db, dgain:0.00000db, pixel gain: OFF */
+	{0x0124, 0x0120}, /* index:1, gain:0.37500db, again:0.37500db, dgain:0.00000db, pixel gain: OFF */
+	{0x0128, 0x0120}, /* index:2, gain:0.75000db, again:0.75000db, dgain:0.00000db, pixel gain: OFF */
+	{0x012c, 0x0120}, /* index:3, gain:1.12500db, again:1.12500db, dgain:0.00000db, pixel gain: OFF */
+	{0x0130, 0x0120}, /* index:4, gain:1.50000db, again:1.50000db, dgain:0.00000db, pixel gain: OFF */
+	{0x0134, 0x0120}, /* index:5, gain:1.87500db, again:1.87500db, dgain:0.00000db, pixel gain: OFF */
+	{0x0138, 0x0120}, /* index:6, gain:2.25000db, again:2.25000db, dgain:0.00000db, pixel gain: OFF */
+	{0x013c, 0x0120}, /* index:7, gain:2.62500db, again:2.62500db, dgain:0.00000db, pixel gain: OFF */
+	{0x0140, 0x0120}, /* index:8, gain:3.00000db, again:3.00000db, dgain:0.00000db, pixel gain: OFF */
+	{0x0144, 0x0120}, /* index:9, gain:3.37500db, again:3.37500db, dgain:0.00000db, pixel gain: OFF */
+	{0x0148, 0x0120}, /* index:10, gain:3.75000db, again:3.75000db, dgain:0.00000db, pixel gain: OFF */
+	{0x014c, 0x0120}, /* index:11, gain:4.12500db, again:4.12500db, dgain:0.00000db, pixel gain: OFF */
+	{0x1120, 0x0120}, /* index:12, gain:4.50000db, again:0.00000db, dgain:0.00000db, pixel gain: ON */
+	{0x1124, 0x0120}, /* index:13, gain:4.87500db, again:0.37500db, dgain:0.00000db, pixel gain: ON */
+	{0x1128, 0x0120}, /* index:14, gain:5.25000db, again:0.75000db, dgain:0.00000db, pixel gain: ON */
+	{0x112c, 0x0120}, /* index:15, gain:5.62500db, again:1.12500db, dgain:0.00000db, pixel gain: ON */
+	{0x1130, 0x0120}, /* index:16, gain:6.00000db, again:1.50000db, dgain:0.00000db, pixel gain: ON */
+	{0x1134, 0x0120}, /* index:17, gain:6.37500db, again:1.87500db, dgain:0.00000db, pixel gain: ON */
+	{0x1138, 0x0120}, /* index:18, gain:6.75000db, again:2.25000db, dgain:0.00000db, pixel gain: ON */
+	{0x113c, 0x0120}, /* index:19, gain:7.12500db, again:2.62500db, dgain:0.00000db, pixel gain: ON */
+	{0x1140, 0x0120}, /* index:20, gain:7.50000db, again:3.00000db, dgain:0.00000db, pixel gain: ON */
+	{0x1144, 0x0120}, /* index:21, gain:7.87500db, again:3.37500db, dgain:0.00000db, pixel gain: ON */
+	{0x1148, 0x0120}, /* index:22, gain:8.25000db, again:3.75000db, dgain:0.00000db, pixel gain: ON */
+	{0x114c, 0x0120}, /* index:23, gain:8.62500db, again:4.12500db, dgain:0.00000db, pixel gain: ON */
+	{0x1150, 0x0120}, /* index:24, gain:9.00000db, again:4.50000db, dgain:0.00000db, pixel gain: ON */
+	{0x1154, 0x0120}, /* index:25, gain:9.37500db, again:4.87500db, dgain:0.00000db, pixel gain: ON */
+	{0x1158, 0x0120}, /* index:26, gain:9.75000db, again:5.25000db, dgain:0.00000db, pixel gain: ON */
+	{0x115c, 0x0120}, /* index:27, gain:10.12500db, again:5.62500db, dgain:0.00000db, pixel gain: ON */
+	{0x1160, 0x0120}, /* index:28, gain:10.50000db, again:6.00000db, dgain:0.00000db, pixel gain: ON */
+	{0x1164, 0x0120}, /* index:29, gain:10.87500db, again:6.37500db, dgain:0.00000db, pixel gain: ON */
+	{0x1168, 0x0120}, /* index:30, gain:11.25000db, again:6.75000db, dgain:0.00000db, pixel gain: ON */
+	{0x116c, 0x0120}, /* index:31, gain:11.62500db, again:7.12500db, dgain:0.00000db, pixel gain: ON */
+	{0x1170, 0x0120}, /* index:32, gain:12.00000db, again:7.50000db, dgain:0.00000db, pixel gain: ON */
+	{0x1174, 0x0120}, /* index:33, gain:12.37500db, again:7.87500db, dgain:0.00000db, pixel gain: ON */
+	{0x1178, 0x0120}, /* index:34, gain:12.75000db, again:8.25000db, dgain:0.00000db, pixel gain: ON */
+	{0x117c, 0x0120}, /* index:35, gain:13.12500db, again:8.62500db, dgain:0.00000db, pixel gain: ON */
+	{0x1180, 0x0120}, /* index:36, gain:13.50000db, again:9.00000db, dgain:0.00000db, pixel gain: ON */
+	{0x1184, 0x0120}, /* index:37, gain:13.87500db, again:9.37500db, dgain:0.00000db, pixel gain: ON */
+	{0x1188, 0x0120}, /* index:38, gain:14.25000db, again:9.75000db, dgain:0.00000db, pixel gain: ON */
+	{0x118c, 0x0120}, /* index:39, gain:14.62500db, again:10.12500db, dgain:0.00000db, pixel gain: ON */
+	{0x1190, 0x0120}, /* index:40, gain:15.00000db, again:10.50000db, dgain:0.00000db, pixel gain: ON */
+	{0x1194, 0x0120}, /* index:41, gain:15.37500db, again:10.87500db, dgain:0.00000db, pixel gain: ON */
+	{0x1198, 0x0120}, /* index:42, gain:15.75000db, again:11.25000db, dgain:0.00000db, pixel gain: ON */
+	{0x119c, 0x0120}, /* index:43, gain:16.12500db, again:11.62500db, dgain:0.00000db, pixel gain: ON */
+	{0x11a0, 0x0120}, /* index:44, gain:16.50000db, again:12.00000db, dgain:0.00000db, pixel gain: ON */
+	{0x11a4, 0x0120}, /* index:45, gain:16.87500db, again:12.37500db, dgain:0.00000db, pixel gain: ON */
+	{0x11a8, 0x0120}, /* index:46, gain:17.25000db, again:12.75000db, dgain:0.00000db, pixel gain: ON */
+	{0x11ac, 0x0120}, /* index:47, gain:17.62500db, again:13.12500db, dgain:0.00000db, pixel gain: ON */
+	{0x11b0, 0x0120}, /* index:48, gain:18.00000db, again:13.50000db, dgain:0.00000db, pixel gain: ON */
+	{0x11b4, 0x0120}, /* index:49, gain:18.37500db, again:13.87500db, dgain:0.00000db, pixel gain: ON */
+	{0x11b8, 0x0120}, /* index:50, gain:18.75000db, again:14.25000db, dgain:0.00000db, pixel gain: ON */
+	{0x11bc, 0x0120}, /* index:51, gain:19.12500db, again:14.62500db, dgain:0.00000db, pixel gain: ON */
+	{0x11c0, 0x0120}, /* index:52, gain:19.50000db, again:15.00000db, dgain:0.00000db, pixel gain: ON */
+	{0x11c4, 0x0120}, /* index:53, gain:19.87500db, again:15.37500db, dgain:0.00000db, pixel gain: ON */
+	{0x11c8, 0x0120}, /* index:54, gain:20.25000db, again:15.75000db, dgain:0.00000db, pixel gain: ON */
+	{0x11cc, 0x0120}, /* index:55, gain:20.62500db, again:16.12500db, dgain:0.00000db, pixel gain: ON */
+	{0x11d0, 0x0120}, /* index:56, gain:21.00000db, again:16.50000db, dgain:0.00000db, pixel gain: ON */
+	{0x11d4, 0x0120}, /* index:57, gain:21.37500db, again:16.87500db, dgain:0.00000db, pixel gain: ON */
+	{0x11d8, 0x0120}, /* index:58, gain:21.75000db, again:17.25000db, dgain:0.00000db, pixel gain: ON */
+	{0x11dc, 0x0120}, /* index:59, gain:22.12500db, again:17.62500db, dgain:0.00000db, pixel gain: ON */
+	{0x11e0, 0x0120}, /* index:60, gain:22.50000db, again:18.00000db, dgain:0.00000db, pixel gain: ON */
+	{0x11e4, 0x0120}, /* index:61, gain:22.87500db, again:18.37500db, dgain:0.00000db, pixel gain: ON */
+	{0x11e8, 0x0120}, /* index:62, gain:23.25000db, again:18.75000db, dgain:0.00000db, pixel gain: ON */
+	{0x11ec, 0x0120}, /* index:63, gain:23.62500db, again:19.12500db, dgain:0.00000db, pixel gain: ON */
+	{0x11f0, 0x0120}, /* index:64, gain:24.00000db, again:19.50000db, dgain:0.00000db, pixel gain: ON */
+	{0x11f4, 0x0120}, /* index:65, gain:24.37500db, again:19.87500db, dgain:0.00000db, pixel gain: ON */
+	{0x11f8, 0x0120}, /* index:66, gain:24.75000db, again:20.25000db, dgain:0.00000db, pixel gain: ON */
+	{0x11fc, 0x0120}, /* index:67, gain:25.12500db, again:20.62500db, dgain:0.00000db, pixel gain: ON */
+	{0x1200, 0x0120}, /* index:68, gain:25.50000db, again:21.00000db, dgain:0.00000db, pixel gain: ON */
+	{0x1204, 0x0120}, /* index:69, gain:25.87500db, again:21.37500db, dgain:0.00000db, pixel gain: ON */
+	{0x1208, 0x0120}, /* index:70, gain:26.25000db, again:21.75000db, dgain:0.00000db, pixel gain: ON */
+	{0x120c, 0x0120}, /* index:71, gain:26.62500db, again:22.12500db, dgain:0.00000db, pixel gain: ON */
+	{0x1210, 0x0120}, /* index:72, gain:27.00000db, again:22.50000db, dgain:0.00000db, pixel gain: ON */
+	{0x1214, 0x0120}, /* index:73, gain:27.37500db, again:22.87500db, dgain:0.00000db, pixel gain: ON */
+	{0x1218, 0x0120}, /* index:74, gain:27.75000db, again:23.25000db, dgain:0.00000db, pixel gain: ON */
+	{0x121c, 0x0120}, /* index:75, gain:28.12500db, again:23.62500db, dgain:0.00000db, pixel gain: ON */
+	{0x1220, 0x0120}, /* index:76, gain:28.50000db, again:24.00000db, dgain:0.00000db, pixel gain: ON */
+	{0x1224, 0x0120}, /* index:77, gain:28.87500db, again:24.37500db, dgain:0.00000db, pixel gain: ON */
+	{0x1228, 0x0120}, /* index:78, gain:29.25000db, again:24.75000db, dgain:0.00000db, pixel gain: ON */
+	{0x122c, 0x0120}, /* index:79, gain:29.62500db, again:25.12500db, dgain:0.00000db, pixel gain: ON */
+	{0x1230, 0x0120}, /* index:80, gain:30.00000db, again:25.50000db, dgain:0.00000db, pixel gain: ON */
+	{0x1234, 0x0120}, /* index:81, gain:30.37500db, again:25.87500db, dgain:0.00000db, pixel gain: ON */
+	{0x1238, 0x0120}, /* index:82, gain:30.75000db, again:26.25000db, dgain:0.00000db, pixel gain: ON */
+	{0x123c, 0x0120}, /* index:83, gain:31.12500db, again:26.62500db, dgain:0.00000db, pixel gain: ON */
+	{0x1240, 0x0120}, /* index:84, gain:31.50000db, again:27.00000db, dgain:0.00000db, pixel gain: ON */
+	{0x1244, 0x0120}, /* index:85, gain:31.87500db, again:27.37500db, dgain:0.00000db, pixel gain: ON */
+	{0x1248, 0x0120}, /* index:86, gain:32.25000db, again:27.75000db, dgain:0.00000db, pixel gain: ON */
+	{0x124c, 0x0120}, /* index:87, gain:32.62500db, again:28.12500db, dgain:0.00000db, pixel gain: ON */
+	{0x1250, 0x0120}, /* index:88, gain:33.00000db, again:28.50000db, dgain:0.00000db, pixel gain: ON */
+	{0x1254, 0x0120}, /* index:89, gain:33.37500db, again:28.87500db, dgain:0.00000db, pixel gain: ON */
+	{0x1258, 0x0120}, /* index:90, gain:33.75000db, again:29.25000db, dgain:0.00000db, pixel gain: ON */
+	{0x125c, 0x0120}, /* index:91, gain:34.12500db, again:29.62500db, dgain:0.00000db, pixel gain: ON */
+	{0x1260, 0x0120}, /* index:92, gain:34.50000db, again:30.00000db, dgain:0.00000db, pixel gain: ON */
+	{0x1260, 0x0124}, /* index:93, gain:34.87500db, again:30.00000db, dgain:0.37500db, pixel gain: ON */
+	{0x1260, 0x0128}, /* index:94, gain:35.25000db, again:30.00000db, dgain:0.75000db, pixel gain: ON */
+	{0x1260, 0x012c}, /* index:95, gain:35.62500db, again:30.00000db, dgain:1.12500db, pixel gain: ON */
+	{0x1260, 0x0130}, /* index:96, gain:36.00000db, again:30.00000db, dgain:1.50000db, pixel gain: ON */
+	{0x1260, 0x0134}, /* index:97, gain:36.37500db, again:30.00000db, dgain:1.87500db, pixel gain: ON */
+	{0x1260, 0x0138}, /* index:98, gain:36.75000db, again:30.00000db, dgain:2.25000db, pixel gain: ON */
+	{0x1260, 0x013c}, /* index:99, gain:37.12500db, again:30.00000db, dgain:2.62500db, pixel gain: ON */
+	{0x1260, 0x0140}, /* index:100, gain:37.50000db, again:30.00000db, dgain:3.00000db, pixel gain: ON */
+	{0x1260, 0x0144}, /* index:101, gain:37.87500db, again:30.00000db, dgain:3.37500db, pixel gain: ON */
+	{0x1260, 0x0148}, /* index:102, gain:38.25000db, again:30.00000db, dgain:3.75000db, pixel gain: ON */
+	{0x1260, 0x014c}, /* index:103, gain:38.62500db, again:30.00000db, dgain:4.12500db, pixel gain: ON */
+	{0x1260, 0x0150}, /* index:104, gain:39.00000db, again:30.00000db, dgain:4.50000db, pixel gain: ON */
+	{0x1260, 0x0154}, /* index:105, gain:39.37500db, again:30.00000db, dgain:4.87500db, pixel gain: ON */
+	{0x1260, 0x0158}, /* index:106, gain:39.75000db, again:30.00000db, dgain:5.25000db, pixel gain: ON */
+	{0x1260, 0x015c}, /* index:107, gain:40.12500db, again:30.00000db, dgain:5.62500db, pixel gain: ON */
+	{0x1260, 0x0160}, /* index:108, gain:40.50000db, again:30.00000db, dgain:6.00000db, pixel gain: ON */
+	{0x1260, 0x0164}, /* index:109, gain:40.87500db, again:30.00000db, dgain:6.37500db, pixel gain: ON */
+	{0x1260, 0x0168}, /* index:110, gain:41.25000db, again:30.00000db, dgain:6.75000db, pixel gain: ON */
+	{0x1260, 0x016c}, /* index:111, gain:41.62500db, again:30.00000db, dgain:7.12500db, pixel gain: ON */
+	{0x1260, 0x0170}, /* index:112, gain:42.00000db, again:30.00000db, dgain:7.50000db, pixel gain: ON */
+	{0x1260, 0x0174}, /* index:113, gain:42.37500db, again:30.00000db, dgain:7.87500db, pixel gain: ON */
+	{0x1260, 0x0178}, /* index:114, gain:42.75000db, again:30.00000db, dgain:8.25000db, pixel gain: ON */
+	{0x1260, 0x017c}, /* index:115, gain:43.12500db, again:30.00000db, dgain:8.62500db, pixel gain: ON */
+	{0x1260, 0x0180}, /* index:116, gain:43.50000db, again:30.00000db, dgain:9.00000db, pixel gain: ON */
+	{0x1260, 0x0184}, /* index:117, gain:43.87500db, again:30.00000db, dgain:9.37500db, pixel gain: ON */
+	{0x1260, 0x0188}, /* index:118, gain:44.25000db, again:30.00000db, dgain:9.75000db, pixel gain: ON */
+	{0x1260, 0x018c}, /* index:119, gain:44.62500db, again:30.00000db, dgain:10.12500db, pixel gain: ON */
+	{0x1260, 0x0190}, /* index:120, gain:45.00000db, again:30.00000db, dgain:10.50000db, pixel gain: ON */
+	{0x1260, 0x0194}, /* index:121, gain:45.37500db, again:30.00000db, dgain:10.87500db, pixel gain: ON */
+	{0x1260, 0x0198}, /* index:122, gain:45.75000db, again:30.00000db, dgain:11.25000db, pixel gain: ON */
+	{0x1260, 0x019c}, /* index:123, gain:46.12500db, again:30.00000db, dgain:11.62500db, pixel gain: ON */
+	{0x1260, 0x01a0}, /* index:124, gain:46.50000db, again:30.00000db, dgain:12.00000db, pixel gain: ON */
+	{0x1260, 0x01a4}, /* index:125, gain:46.87500db, again:30.00000db, dgain:12.37500db, pixel gain: ON */
+	{0x1260, 0x01a8}, /* index:126, gain:47.25000db, again:30.00000db, dgain:12.75000db, pixel gain: ON */
+	{0x1260, 0x01ac}, /* index:127, gain:47.62500db, again:30.00000db, dgain:13.12500db, pixel gain: ON */
+	{0x1260, 0x01b0}, /* index:128, gain:48.00000db, again:30.00000db, dgain:13.50000db, pixel gain: ON */
+	{0x1260, 0x01b4}, /* index:129, gain:48.37500db, again:30.00000db, dgain:13.87500db, pixel gain: ON */
+	{0x1260, 0x01b8}, /* index:130, gain:48.75000db, again:30.00000db, dgain:14.25000db, pixel gain: ON */
+	{0x1260, 0x01bc}, /* index:131, gain:49.12500db, again:30.00000db, dgain:14.62500db, pixel gain: ON */
+	{0x1260, 0x01c0}, /* index:132, gain:49.50000db, again:30.00000db, dgain:15.00000db, pixel gain: ON */
+	{0x1260, 0x01c4}, /* index:133, gain:49.87500db, again:30.00000db, dgain:15.37500db, pixel gain: ON */
+	{0x1260, 0x01c8}, /* index:134, gain:50.25000db, again:30.00000db, dgain:15.75000db, pixel gain: ON */
+	{0x1260, 0x01cc}, /* index:135, gain:50.62500db, again:30.00000db, dgain:16.12500db, pixel gain: ON */
+	{0x1260, 0x01d0}, /* index:136, gain:51.00000db, again:30.00000db, dgain:16.50000db, pixel gain: ON */
+	{0x1260, 0x01d4}, /* index:137, gain:51.37500db, again:30.00000db, dgain:16.87500db, pixel gain: ON */
+	{0x1260, 0x01d8}, /* index:138, gain:51.75000db, again:30.00000db, dgain:17.25000db, pixel gain: ON */
+	{0x1260, 0x01dc}, /* index:139, gain:52.12500db, again:30.00000db, dgain:17.62500db, pixel gain: ON */
+	{0x1260, 0x01e0}, /* index:140, gain:52.50000db, again:30.00000db, dgain:18.00000db, pixel gain: ON */
+	{0x1260, 0x01e4}, /* index:141, gain:52.87500db, again:30.00000db, dgain:18.37500db, pixel gain: ON */
+	{0x1260, 0x01e8}, /* index:142, gain:53.25000db, again:30.00000db, dgain:18.75000db, pixel gain: ON */
+	{0x1260, 0x01ec}, /* index:143, gain:53.62500db, again:30.00000db, dgain:19.12500db, pixel gain: ON */
+	{0x1260, 0x01f0}, /* index:144, gain:54.00000db, again:30.00000db, dgain:19.50000db, pixel gain: ON */
+	{0x1260, 0x01f4}, /* index:145, gain:54.37500db, again:30.00000db, dgain:19.87500db, pixel gain: ON */
+	{0x1260, 0x01f8}, /* index:146, gain:54.75000db, again:30.00000db, dgain:20.25000db, pixel gain: ON */
+	{0x1260, 0x01fc}, /* index:147, gain:55.12500db, again:30.00000db, dgain:20.62500db, pixel gain: ON */
+	{0x1260, 0x0200}, /* index:148, gain:55.50000db, again:30.00000db, dgain:21.00000db, pixel gain: ON */
+	{0x1260, 0x0204}, /* index:149, gain:55.87500db, again:30.00000db, dgain:21.37500db, pixel gain: ON */
+	{0x1260, 0x0208}, /* index:150, gain:56.25000db, again:30.00000db, dgain:21.75000db, pixel gain: ON */
+	{0x1260, 0x020c}, /* index:151, gain:56.62500db, again:30.00000db, dgain:22.12500db, pixel gain: ON */
+	{0x1260, 0x0210}, /* index:152, gain:57.00000db, again:30.00000db, dgain:22.50000db, pixel gain: ON */
+	{0x1260, 0x0214}, /* index:153, gain:57.37500db, again:30.00000db, dgain:22.87500db, pixel gain: ON */
+	{0x1260, 0x0218}, /* index:154, gain:57.75000db, again:30.00000db, dgain:23.25000db, pixel gain: ON */
+	{0x1260, 0x021c}, /* index:155, gain:58.12500db, again:30.00000db, dgain:23.62500db, pixel gain: ON */
+	{0x1260, 0x0220}, /* index:156, gain:58.50000db, again:30.00000db, dgain:24.00000db, pixel gain: ON */
+	{0x1260, 0x0224}, /* index:157, gain:58.87500db, again:30.00000db, dgain:24.37500db, pixel gain: ON */
+	{0x1260, 0x0228}, /* index:158, gain:59.25000db, again:30.00000db, dgain:24.75000db, pixel gain: ON */
+	{0x1260, 0x022c}, /* index:159, gain:59.62500db, again:30.00000db, dgain:25.12500db, pixel gain: ON */
+	{0x1260, 0x0230}, /* index:160, gain:60.00000db, again:30.00000db, dgain:25.50000db, pixel gain: ON */
+	{0x1260, 0x0234}, /* index:161, gain:60.37500db, again:30.00000db, dgain:25.87500db, pixel gain: ON */
+	{0x1260, 0x0238}, /* index:162, gain:60.75000db, again:30.00000db, dgain:26.25000db, pixel gain: ON */
+	{0x1260, 0x023c}, /* index:163, gain:61.12500db, again:30.00000db, dgain:26.62500db, pixel gain: ON */
+	{0x1260, 0x0240}, /* index:164, gain:61.50000db, again:30.00000db, dgain:27.00000db, pixel gain: ON */
+	{0x1260, 0x0244}, /* index:165, gain:61.87500db, again:30.00000db, dgain:27.37500db, pixel gain: ON */
+	{0x1260, 0x0248}, /* index:166, gain:62.25000db, again:30.00000db, dgain:27.75000db, pixel gain: ON */
+	{0x1260, 0x024c}, /* index:167, gain:62.62500db, again:30.00000db, dgain:28.12500db, pixel gain: ON */
+	{0x1260, 0x0250}, /* index:168, gain:63.00000db, again:30.00000db, dgain:28.50000db, pixel gain: ON */
+	{0x1260, 0x0254}, /* index:169, gain:63.37500db, again:30.00000db, dgain:28.87500db, pixel gain: ON */
+	{0x1260, 0x0258}, /* index:170, gain:63.75000db, again:30.00000db, dgain:29.25000db, pixel gain: ON */
+	{0x1260, 0x025c}, /* index:171, gain:64.12500db, again:30.00000db, dgain:29.62500db, pixel gain: ON */
+	{0x1260, 0x0260}, /* index:172, gain:64.50000db, again:30.00000db, dgain:30.00000db, pixel gain: ON */
+};
+#else
+/** MN34420PL global gain table row size */
+#define MN34420PL_GAIN_ROWS		(691 + 1)
+#define MN34420PL_GAIN_MAXDB		(691)
+#define MN34420PL_WDR_GAIN_30DB	(320)
+#define MN34420PL_WDR_DGAIN_ON	(371)
+
+/* MN34420PL_GAIN_ROWS = 692, MN34420PL_GAIN_COLS = 2, typical pixel gain = 4.78125db */
+static const u16 MN34420PL_GAIN_TABLE[MN34420PL_GAIN_ROWS][MN34420PL_GAIN_COLS] = {
+	{0x0120, 0x0120}, /* index:0, gain:0.00000db, again:0.00000db, dgain:0.00000db, pixel gain: OFF */
+	{0x0121, 0x0120}, /* index:1, gain:0.09375db, again:0.09375db, dgain:0.00000db, pixel gain: OFF */
+	{0x0122, 0x0120}, /* index:2, gain:0.18750db, again:0.18750db, dgain:0.00000db, pixel gain: OFF */
+	{0x0123, 0x0120}, /* index:3, gain:0.28125db, again:0.28125db, dgain:0.00000db, pixel gain: OFF */
+	{0x0124, 0x0120}, /* index:4, gain:0.37500db, again:0.37500db, dgain:0.00000db, pixel gain: OFF */
+	{0x0125, 0x0120}, /* index:5, gain:0.46875db, again:0.46875db, dgain:0.00000db, pixel gain: OFF */
+	{0x0126, 0x0120}, /* index:6, gain:0.56250db, again:0.56250db, dgain:0.00000db, pixel gain: OFF */
+	{0x0127, 0x0120}, /* index:7, gain:0.65625db, again:0.65625db, dgain:0.00000db, pixel gain: OFF */
+	{0x0128, 0x0120}, /* index:8, gain:0.75000db, again:0.75000db, dgain:0.00000db, pixel gain: OFF */
+	{0x0129, 0x0120}, /* index:9, gain:0.84375db, again:0.84375db, dgain:0.00000db, pixel gain: OFF */
+	{0x012a, 0x0120}, /* index:10, gain:0.93750db, again:0.93750db, dgain:0.00000db, pixel gain: OFF */
+	{0x012b, 0x0120}, /* index:11, gain:1.03125db, again:1.03125db, dgain:0.00000db, pixel gain: OFF */
+	{0x012c, 0x0120}, /* index:12, gain:1.12500db, again:1.12500db, dgain:0.00000db, pixel gain: OFF */
+	{0x012d, 0x0120}, /* index:13, gain:1.21875db, again:1.21875db, dgain:0.00000db, pixel gain: OFF */
+	{0x012e, 0x0120}, /* index:14, gain:1.31250db, again:1.31250db, dgain:0.00000db, pixel gain: OFF */
+	{0x012f, 0x0120}, /* index:15, gain:1.40625db, again:1.40625db, dgain:0.00000db, pixel gain: OFF */
+	{0x0130, 0x0120}, /* index:16, gain:1.50000db, again:1.50000db, dgain:0.00000db, pixel gain: OFF */
+	{0x0131, 0x0120}, /* index:17, gain:1.59375db, again:1.59375db, dgain:0.00000db, pixel gain: OFF */
+	{0x0132, 0x0120}, /* index:18, gain:1.68750db, again:1.68750db, dgain:0.00000db, pixel gain: OFF */
+	{0x0133, 0x0120}, /* index:19, gain:1.78125db, again:1.78125db, dgain:0.00000db, pixel gain: OFF */
+	{0x0134, 0x0120}, /* index:20, gain:1.87500db, again:1.87500db, dgain:0.00000db, pixel gain: OFF */
+	{0x0135, 0x0120}, /* index:21, gain:1.96875db, again:1.96875db, dgain:0.00000db, pixel gain: OFF */
+	{0x0136, 0x0120}, /* index:22, gain:2.06250db, again:2.06250db, dgain:0.00000db, pixel gain: OFF */
+	{0x0137, 0x0120}, /* index:23, gain:2.15625db, again:2.15625db, dgain:0.00000db, pixel gain: OFF */
+	{0x0138, 0x0120}, /* index:24, gain:2.25000db, again:2.25000db, dgain:0.00000db, pixel gain: OFF */
+	{0x0139, 0x0120}, /* index:25, gain:2.34375db, again:2.34375db, dgain:0.00000db, pixel gain: OFF */
+	{0x013a, 0x0120}, /* index:26, gain:2.43750db, again:2.43750db, dgain:0.00000db, pixel gain: OFF */
+	{0x013b, 0x0120}, /* index:27, gain:2.53125db, again:2.53125db, dgain:0.00000db, pixel gain: OFF */
+	{0x013c, 0x0120}, /* index:28, gain:2.62500db, again:2.62500db, dgain:0.00000db, pixel gain: OFF */
+	{0x013d, 0x0120}, /* index:29, gain:2.71875db, again:2.71875db, dgain:0.00000db, pixel gain: OFF */
+	{0x013e, 0x0120}, /* index:30, gain:2.81250db, again:2.81250db, dgain:0.00000db, pixel gain: OFF */
+	{0x013f, 0x0120}, /* index:31, gain:2.90625db, again:2.90625db, dgain:0.00000db, pixel gain: OFF */
+	{0x0140, 0x0120}, /* index:32, gain:3.00000db, again:3.00000db, dgain:0.00000db, pixel gain: OFF */
+	{0x0141, 0x0120}, /* index:33, gain:3.09375db, again:3.09375db, dgain:0.00000db, pixel gain: OFF */
+	{0x0142, 0x0120}, /* index:34, gain:3.18750db, again:3.18750db, dgain:0.00000db, pixel gain: OFF */
+	{0x0143, 0x0120}, /* index:35, gain:3.28125db, again:3.28125db, dgain:0.00000db, pixel gain: OFF */
+	{0x0144, 0x0120}, /* index:36, gain:3.37500db, again:3.37500db, dgain:0.00000db, pixel gain: OFF */
+	{0x0145, 0x0120}, /* index:37, gain:3.46875db, again:3.46875db, dgain:0.00000db, pixel gain: OFF */
+	{0x0146, 0x0120}, /* index:38, gain:3.56250db, again:3.56250db, dgain:0.00000db, pixel gain: OFF */
+	{0x0147, 0x0120}, /* index:39, gain:3.65625db, again:3.65625db, dgain:0.00000db, pixel gain: OFF */
+	{0x0148, 0x0120}, /* index:40, gain:3.75000db, again:3.75000db, dgain:0.00000db, pixel gain: OFF */
+	{0x0149, 0x0120}, /* index:41, gain:3.84375db, again:3.84375db, dgain:0.00000db, pixel gain: OFF */
+	{0x014a, 0x0120}, /* index:42, gain:3.93750db, again:3.93750db, dgain:0.00000db, pixel gain: OFF */
+	{0x014b, 0x0120}, /* index:43, gain:4.03125db, again:4.03125db, dgain:0.00000db, pixel gain: OFF */
+	{0x014c, 0x0120}, /* index:44, gain:4.12500db, again:4.12500db, dgain:0.00000db, pixel gain: OFF */
+	{0x014d, 0x0120}, /* index:45, gain:4.21875db, again:4.21875db, dgain:0.00000db, pixel gain: OFF */
+	{0x014e, 0x0120}, /* index:46, gain:4.31250db, again:4.31250db, dgain:0.00000db, pixel gain: OFF */
+	{0x014f, 0x0120}, /* index:47, gain:4.40625db, again:4.40625db, dgain:0.00000db, pixel gain: OFF */
+	{0x0150, 0x0120}, /* index:48, gain:4.50000db, again:4.50000db, dgain:0.00000db, pixel gain: OFF */
+	{0x0151, 0x0120}, /* index:49, gain:4.59375db, again:4.59375db, dgain:0.00000db, pixel gain: OFF */
+	{0x0152, 0x0120}, /* index:50, gain:4.68750db, again:4.68750db, dgain:0.00000db, pixel gain: OFF */
+	{0x1120, 0x0120}, /* index:51, gain:4.78125db, again:0.00000db, dgain:0.00000db, pixel gain: ON */
+	{0x1121, 0x0120}, /* index:52, gain:4.87500db, again:0.09375db, dgain:0.00000db, pixel gain: ON */
+	{0x1122, 0x0120}, /* index:53, gain:4.96875db, again:0.18750db, dgain:0.00000db, pixel gain: ON */
+	{0x1123, 0x0120}, /* index:54, gain:5.06250db, again:0.28125db, dgain:0.00000db, pixel gain: ON */
+	{0x1124, 0x0120}, /* index:55, gain:5.15625db, again:0.37500db, dgain:0.00000db, pixel gain: ON */
+	{0x1125, 0x0120}, /* index:56, gain:5.25000db, again:0.46875db, dgain:0.00000db, pixel gain: ON */
+	{0x1126, 0x0120}, /* index:57, gain:5.34375db, again:0.56250db, dgain:0.00000db, pixel gain: ON */
+	{0x1127, 0x0120}, /* index:58, gain:5.43750db, again:0.65625db, dgain:0.00000db, pixel gain: ON */
+	{0x1128, 0x0120}, /* index:59, gain:5.53125db, again:0.75000db, dgain:0.00000db, pixel gain: ON */
+	{0x1129, 0x0120}, /* index:60, gain:5.62500db, again:0.84375db, dgain:0.00000db, pixel gain: ON */
+	{0x112a, 0x0120}, /* index:61, gain:5.71875db, again:0.93750db, dgain:0.00000db, pixel gain: ON */
+	{0x112b, 0x0120}, /* index:62, gain:5.81250db, again:1.03125db, dgain:0.00000db, pixel gain: ON */
+	{0x112c, 0x0120}, /* index:63, gain:5.90625db, again:1.12500db, dgain:0.00000db, pixel gain: ON */
+	{0x112d, 0x0120}, /* index:64, gain:6.00000db, again:1.21875db, dgain:0.00000db, pixel gain: ON */
+	{0x112e, 0x0120}, /* index:65, gain:6.09375db, again:1.31250db, dgain:0.00000db, pixel gain: ON */
+	{0x112f, 0x0120}, /* index:66, gain:6.18750db, again:1.40625db, dgain:0.00000db, pixel gain: ON */
+	{0x1130, 0x0120}, /* index:67, gain:6.28125db, again:1.50000db, dgain:0.00000db, pixel gain: ON */
+	{0x1131, 0x0120}, /* index:68, gain:6.37500db, again:1.59375db, dgain:0.00000db, pixel gain: ON */
+	{0x1132, 0x0120}, /* index:69, gain:6.46875db, again:1.68750db, dgain:0.00000db, pixel gain: ON */
+	{0x1133, 0x0120}, /* index:70, gain:6.56250db, again:1.78125db, dgain:0.00000db, pixel gain: ON */
+	{0x1134, 0x0120}, /* index:71, gain:6.65625db, again:1.87500db, dgain:0.00000db, pixel gain: ON */
+	{0x1135, 0x0120}, /* index:72, gain:6.75000db, again:1.96875db, dgain:0.00000db, pixel gain: ON */
+	{0x1136, 0x0120}, /* index:73, gain:6.84375db, again:2.06250db, dgain:0.00000db, pixel gain: ON */
+	{0x1137, 0x0120}, /* index:74, gain:6.93750db, again:2.15625db, dgain:0.00000db, pixel gain: ON */
+	{0x1138, 0x0120}, /* index:75, gain:7.03125db, again:2.25000db, dgain:0.00000db, pixel gain: ON */
+	{0x1139, 0x0120}, /* index:76, gain:7.12500db, again:2.34375db, dgain:0.00000db, pixel gain: ON */
+	{0x113a, 0x0120}, /* index:77, gain:7.21875db, again:2.43750db, dgain:0.00000db, pixel gain: ON */
+	{0x113b, 0x0120}, /* index:78, gain:7.31250db, again:2.53125db, dgain:0.00000db, pixel gain: ON */
+	{0x113c, 0x0120}, /* index:79, gain:7.40625db, again:2.62500db, dgain:0.00000db, pixel gain: ON */
+	{0x113d, 0x0120}, /* index:80, gain:7.50000db, again:2.71875db, dgain:0.00000db, pixel gain: ON */
+	{0x113e, 0x0120}, /* index:81, gain:7.59375db, again:2.81250db, dgain:0.00000db, pixel gain: ON */
+	{0x113f, 0x0120}, /* index:82, gain:7.68750db, again:2.90625db, dgain:0.00000db, pixel gain: ON */
+	{0x1140, 0x0120}, /* index:83, gain:7.78125db, again:3.00000db, dgain:0.00000db, pixel gain: ON */
+	{0x1141, 0x0120}, /* index:84, gain:7.87500db, again:3.09375db, dgain:0.00000db, pixel gain: ON */
+	{0x1142, 0x0120}, /* index:85, gain:7.96875db, again:3.18750db, dgain:0.00000db, pixel gain: ON */
+	{0x1143, 0x0120}, /* index:86, gain:8.06250db, again:3.28125db, dgain:0.00000db, pixel gain: ON */
+	{0x1144, 0x0120}, /* index:87, gain:8.15625db, again:3.37500db, dgain:0.00000db, pixel gain: ON */
+	{0x1145, 0x0120}, /* index:88, gain:8.25000db, again:3.46875db, dgain:0.00000db, pixel gain: ON */
+	{0x1146, 0x0120}, /* index:89, gain:8.34375db, again:3.56250db, dgain:0.00000db, pixel gain: ON */
+	{0x1147, 0x0120}, /* index:90, gain:8.43750db, again:3.65625db, dgain:0.00000db, pixel gain: ON */
+	{0x1148, 0x0120}, /* index:91, gain:8.53125db, again:3.75000db, dgain:0.00000db, pixel gain: ON */
+	{0x1149, 0x0120}, /* index:92, gain:8.62500db, again:3.84375db, dgain:0.00000db, pixel gain: ON */
+	{0x114a, 0x0120}, /* index:93, gain:8.71875db, again:3.93750db, dgain:0.00000db, pixel gain: ON */
+	{0x114b, 0x0120}, /* index:94, gain:8.81250db, again:4.03125db, dgain:0.00000db, pixel gain: ON */
+	{0x114c, 0x0120}, /* index:95, gain:8.90625db, again:4.12500db, dgain:0.00000db, pixel gain: ON */
+	{0x114d, 0x0120}, /* index:96, gain:9.00000db, again:4.21875db, dgain:0.00000db, pixel gain: ON */
+	{0x114e, 0x0120}, /* index:97, gain:9.09375db, again:4.31250db, dgain:0.00000db, pixel gain: ON */
+	{0x114f, 0x0120}, /* index:98, gain:9.18750db, again:4.40625db, dgain:0.00000db, pixel gain: ON */
+	{0x1150, 0x0120}, /* index:99, gain:9.28125db, again:4.50000db, dgain:0.00000db, pixel gain: ON */
+	{0x1151, 0x0120}, /* index:100, gain:9.37500db, again:4.59375db, dgain:0.00000db, pixel gain: ON */
+	{0x1152, 0x0120}, /* index:101, gain:9.46875db, again:4.68750db, dgain:0.00000db, pixel gain: ON */
+	{0x1153, 0x0120}, /* index:102, gain:9.56250db, again:4.78125db, dgain:0.00000db, pixel gain: ON */
+	{0x1154, 0x0120}, /* index:103, gain:9.65625db, again:4.87500db, dgain:0.00000db, pixel gain: ON */
+	{0x1155, 0x0120}, /* index:104, gain:9.75000db, again:4.96875db, dgain:0.00000db, pixel gain: ON */
+	{0x1156, 0x0120}, /* index:105, gain:9.84375db, again:5.06250db, dgain:0.00000db, pixel gain: ON */
+	{0x1157, 0x0120}, /* index:106, gain:9.93750db, again:5.15625db, dgain:0.00000db, pixel gain: ON */
+	{0x1158, 0x0120}, /* index:107, gain:10.03125db, again:5.25000db, dgain:0.00000db, pixel gain: ON */
+	{0x1159, 0x0120}, /* index:108, gain:10.12500db, again:5.34375db, dgain:0.00000db, pixel gain: ON */
+	{0x115a, 0x0120}, /* index:109, gain:10.21875db, again:5.43750db, dgain:0.00000db, pixel gain: ON */
+	{0x115b, 0x0120}, /* index:110, gain:10.31250db, again:5.53125db, dgain:0.00000db, pixel gain: ON */
+	{0x115c, 0x0120}, /* index:111, gain:10.40625db, again:5.62500db, dgain:0.00000db, pixel gain: ON */
+	{0x115d, 0x0120}, /* index:112, gain:10.50000db, again:5.71875db, dgain:0.00000db, pixel gain: ON */
+	{0x115e, 0x0120}, /* index:113, gain:10.59375db, again:5.81250db, dgain:0.00000db, pixel gain: ON */
+	{0x115f, 0x0120}, /* index:114, gain:10.68750db, again:5.90625db, dgain:0.00000db, pixel gain: ON */
+	{0x1160, 0x0120}, /* index:115, gain:10.78125db, again:6.00000db, dgain:0.00000db, pixel gain: ON */
+	{0x1161, 0x0120}, /* index:116, gain:10.87500db, again:6.09375db, dgain:0.00000db, pixel gain: ON */
+	{0x1162, 0x0120}, /* index:117, gain:10.96875db, again:6.18750db, dgain:0.00000db, pixel gain: ON */
+	{0x1163, 0x0120}, /* index:118, gain:11.06250db, again:6.28125db, dgain:0.00000db, pixel gain: ON */
+	{0x1164, 0x0120}, /* index:119, gain:11.15625db, again:6.37500db, dgain:0.00000db, pixel gain: ON */
+	{0x1165, 0x0120}, /* index:120, gain:11.25000db, again:6.46875db, dgain:0.00000db, pixel gain: ON */
+	{0x1166, 0x0120}, /* index:121, gain:11.34375db, again:6.56250db, dgain:0.00000db, pixel gain: ON */
+	{0x1167, 0x0120}, /* index:122, gain:11.43750db, again:6.65625db, dgain:0.00000db, pixel gain: ON */
+	{0x1168, 0x0120}, /* index:123, gain:11.53125db, again:6.75000db, dgain:0.00000db, pixel gain: ON */
+	{0x1169, 0x0120}, /* index:124, gain:11.62500db, again:6.84375db, dgain:0.00000db, pixel gain: ON */
+	{0x116a, 0x0120}, /* index:125, gain:11.71875db, again:6.93750db, dgain:0.00000db, pixel gain: ON */
+	{0x116b, 0x0120}, /* index:126, gain:11.81250db, again:7.03125db, dgain:0.00000db, pixel gain: ON */
+	{0x116c, 0x0120}, /* index:127, gain:11.90625db, again:7.12500db, dgain:0.00000db, pixel gain: ON */
+	{0x116d, 0x0120}, /* index:128, gain:12.00000db, again:7.21875db, dgain:0.00000db, pixel gain: ON */
+	{0x116e, 0x0120}, /* index:129, gain:12.09375db, again:7.31250db, dgain:0.00000db, pixel gain: ON */
+	{0x116f, 0x0120}, /* index:130, gain:12.18750db, again:7.40625db, dgain:0.00000db, pixel gain: ON */
+	{0x1170, 0x0120}, /* index:131, gain:12.28125db, again:7.50000db, dgain:0.00000db, pixel gain: ON */
+	{0x1171, 0x0120}, /* index:132, gain:12.37500db, again:7.59375db, dgain:0.00000db, pixel gain: ON */
+	{0x1172, 0x0120}, /* index:133, gain:12.46875db, again:7.68750db, dgain:0.00000db, pixel gain: ON */
+	{0x1173, 0x0120}, /* index:134, gain:12.56250db, again:7.78125db, dgain:0.00000db, pixel gain: ON */
+	{0x1174, 0x0120}, /* index:135, gain:12.65625db, again:7.87500db, dgain:0.00000db, pixel gain: ON */
+	{0x1175, 0x0120}, /* index:136, gain:12.75000db, again:7.96875db, dgain:0.00000db, pixel gain: ON */
+	{0x1176, 0x0120}, /* index:137, gain:12.84375db, again:8.06250db, dgain:0.00000db, pixel gain: ON */
+	{0x1177, 0x0120}, /* index:138, gain:12.93750db, again:8.15625db, dgain:0.00000db, pixel gain: ON */
+	{0x1178, 0x0120}, /* index:139, gain:13.03125db, again:8.25000db, dgain:0.00000db, pixel gain: ON */
+	{0x1179, 0x0120}, /* index:140, gain:13.12500db, again:8.34375db, dgain:0.00000db, pixel gain: ON */
+	{0x117a, 0x0120}, /* index:141, gain:13.21875db, again:8.43750db, dgain:0.00000db, pixel gain: ON */
+	{0x117b, 0x0120}, /* index:142, gain:13.31250db, again:8.53125db, dgain:0.00000db, pixel gain: ON */
+	{0x117c, 0x0120}, /* index:143, gain:13.40625db, again:8.62500db, dgain:0.00000db, pixel gain: ON */
+	{0x117d, 0x0120}, /* index:144, gain:13.50000db, again:8.71875db, dgain:0.00000db, pixel gain: ON */
+	{0x117e, 0x0120}, /* index:145, gain:13.59375db, again:8.81250db, dgain:0.00000db, pixel gain: ON */
+	{0x117f, 0x0120}, /* index:146, gain:13.68750db, again:8.90625db, dgain:0.00000db, pixel gain: ON */
+	{0x1180, 0x0120}, /* index:147, gain:13.78125db, again:9.00000db, dgain:0.00000db, pixel gain: ON */
+	{0x1181, 0x0120}, /* index:148, gain:13.87500db, again:9.09375db, dgain:0.00000db, pixel gain: ON */
+	{0x1182, 0x0120}, /* index:149, gain:13.96875db, again:9.18750db, dgain:0.00000db, pixel gain: ON */
+	{0x1183, 0x0120}, /* index:150, gain:14.06250db, again:9.28125db, dgain:0.00000db, pixel gain: ON */
+	{0x1184, 0x0120}, /* index:151, gain:14.15625db, again:9.37500db, dgain:0.00000db, pixel gain: ON */
+	{0x1185, 0x0120}, /* index:152, gain:14.25000db, again:9.46875db, dgain:0.00000db, pixel gain: ON */
+	{0x1186, 0x0120}, /* index:153, gain:14.34375db, again:9.56250db, dgain:0.00000db, pixel gain: ON */
+	{0x1187, 0x0120}, /* index:154, gain:14.43750db, again:9.65625db, dgain:0.00000db, pixel gain: ON */
+	{0x1188, 0x0120}, /* index:155, gain:14.53125db, again:9.75000db, dgain:0.00000db, pixel gain: ON */
+	{0x1189, 0x0120}, /* index:156, gain:14.62500db, again:9.84375db, dgain:0.00000db, pixel gain: ON */
+	{0x118a, 0x0120}, /* index:157, gain:14.71875db, again:9.93750db, dgain:0.00000db, pixel gain: ON */
+	{0x118b, 0x0120}, /* index:158, gain:14.81250db, again:10.03125db, dgain:0.00000db, pixel gain: ON */
+	{0x118c, 0x0120}, /* index:159, gain:14.90625db, again:10.12500db, dgain:0.00000db, pixel gain: ON */
+	{0x118d, 0x0120}, /* index:160, gain:15.00000db, again:10.21875db, dgain:0.00000db, pixel gain: ON */
+	{0x118e, 0x0120}, /* index:161, gain:15.09375db, again:10.31250db, dgain:0.00000db, pixel gain: ON */
+	{0x118f, 0x0120}, /* index:162, gain:15.18750db, again:10.40625db, dgain:0.00000db, pixel gain: ON */
+	{0x1190, 0x0120}, /* index:163, gain:15.28125db, again:10.50000db, dgain:0.00000db, pixel gain: ON */
+	{0x1191, 0x0120}, /* index:164, gain:15.37500db, again:10.59375db, dgain:0.00000db, pixel gain: ON */
+	{0x1192, 0x0120}, /* index:165, gain:15.46875db, again:10.68750db, dgain:0.00000db, pixel gain: ON */
+	{0x1193, 0x0120}, /* index:166, gain:15.56250db, again:10.78125db, dgain:0.00000db, pixel gain: ON */
+	{0x1194, 0x0120}, /* index:167, gain:15.65625db, again:10.87500db, dgain:0.00000db, pixel gain: ON */
+	{0x1195, 0x0120}, /* index:168, gain:15.75000db, again:10.96875db, dgain:0.00000db, pixel gain: ON */
+	{0x1196, 0x0120}, /* index:169, gain:15.84375db, again:11.06250db, dgain:0.00000db, pixel gain: ON */
+	{0x1197, 0x0120}, /* index:170, gain:15.93750db, again:11.15625db, dgain:0.00000db, pixel gain: ON */
+	{0x1198, 0x0120}, /* index:171, gain:16.03125db, again:11.25000db, dgain:0.00000db, pixel gain: ON */
+	{0x1199, 0x0120}, /* index:172, gain:16.12500db, again:11.34375db, dgain:0.00000db, pixel gain: ON */
+	{0x119a, 0x0120}, /* index:173, gain:16.21875db, again:11.43750db, dgain:0.00000db, pixel gain: ON */
+	{0x119b, 0x0120}, /* index:174, gain:16.31250db, again:11.53125db, dgain:0.00000db, pixel gain: ON */
+	{0x119c, 0x0120}, /* index:175, gain:16.40625db, again:11.62500db, dgain:0.00000db, pixel gain: ON */
+	{0x119d, 0x0120}, /* index:176, gain:16.50000db, again:11.71875db, dgain:0.00000db, pixel gain: ON */
+	{0x119e, 0x0120}, /* index:177, gain:16.59375db, again:11.81250db, dgain:0.00000db, pixel gain: ON */
+	{0x119f, 0x0120}, /* index:178, gain:16.68750db, again:11.90625db, dgain:0.00000db, pixel gain: ON */
+	{0x11a0, 0x0120}, /* index:179, gain:16.78125db, again:12.00000db, dgain:0.00000db, pixel gain: ON */
+	{0x11a1, 0x0120}, /* index:180, gain:16.87500db, again:12.09375db, dgain:0.00000db, pixel gain: ON */
+	{0x11a2, 0x0120}, /* index:181, gain:16.96875db, again:12.18750db, dgain:0.00000db, pixel gain: ON */
+	{0x11a3, 0x0120}, /* index:182, gain:17.06250db, again:12.28125db, dgain:0.00000db, pixel gain: ON */
+	{0x11a4, 0x0120}, /* index:183, gain:17.15625db, again:12.37500db, dgain:0.00000db, pixel gain: ON */
+	{0x11a5, 0x0120}, /* index:184, gain:17.25000db, again:12.46875db, dgain:0.00000db, pixel gain: ON */
+	{0x11a6, 0x0120}, /* index:185, gain:17.34375db, again:12.56250db, dgain:0.00000db, pixel gain: ON */
+	{0x11a7, 0x0120}, /* index:186, gain:17.43750db, again:12.65625db, dgain:0.00000db, pixel gain: ON */
+	{0x11a8, 0x0120}, /* index:187, gain:17.53125db, again:12.75000db, dgain:0.00000db, pixel gain: ON */
+	{0x11a9, 0x0120}, /* index:188, gain:17.62500db, again:12.84375db, dgain:0.00000db, pixel gain: ON */
+	{0x11aa, 0x0120}, /* index:189, gain:17.71875db, again:12.93750db, dgain:0.00000db, pixel gain: ON */
+	{0x11ab, 0x0120}, /* index:190, gain:17.81250db, again:13.03125db, dgain:0.00000db, pixel gain: ON */
+	{0x11ac, 0x0120}, /* index:191, gain:17.90625db, again:13.12500db, dgain:0.00000db, pixel gain: ON */
+	{0x11ad, 0x0120}, /* index:192, gain:18.00000db, again:13.21875db, dgain:0.00000db, pixel gain: ON */
+	{0x11ae, 0x0120}, /* index:193, gain:18.09375db, again:13.31250db, dgain:0.00000db, pixel gain: ON */
+	{0x11af, 0x0120}, /* index:194, gain:18.18750db, again:13.40625db, dgain:0.00000db, pixel gain: ON */
+	{0x11b0, 0x0120}, /* index:195, gain:18.28125db, again:13.50000db, dgain:0.00000db, pixel gain: ON */
+	{0x11b1, 0x0120}, /* index:196, gain:18.37500db, again:13.59375db, dgain:0.00000db, pixel gain: ON */
+	{0x11b2, 0x0120}, /* index:197, gain:18.46875db, again:13.68750db, dgain:0.00000db, pixel gain: ON */
+	{0x11b3, 0x0120}, /* index:198, gain:18.56250db, again:13.78125db, dgain:0.00000db, pixel gain: ON */
+	{0x11b4, 0x0120}, /* index:199, gain:18.65625db, again:13.87500db, dgain:0.00000db, pixel gain: ON */
+	{0x11b5, 0x0120}, /* index:200, gain:18.75000db, again:13.96875db, dgain:0.00000db, pixel gain: ON */
+	{0x11b6, 0x0120}, /* index:201, gain:18.84375db, again:14.06250db, dgain:0.00000db, pixel gain: ON */
+	{0x11b7, 0x0120}, /* index:202, gain:18.93750db, again:14.15625db, dgain:0.00000db, pixel gain: ON */
+	{0x11b8, 0x0120}, /* index:203, gain:19.03125db, again:14.25000db, dgain:0.00000db, pixel gain: ON */
+	{0x11b9, 0x0120}, /* index:204, gain:19.12500db, again:14.34375db, dgain:0.00000db, pixel gain: ON */
+	{0x11ba, 0x0120}, /* index:205, gain:19.21875db, again:14.43750db, dgain:0.00000db, pixel gain: ON */
+	{0x11bb, 0x0120}, /* index:206, gain:19.31250db, again:14.53125db, dgain:0.00000db, pixel gain: ON */
+	{0x11bc, 0x0120}, /* index:207, gain:19.40625db, again:14.62500db, dgain:0.00000db, pixel gain: ON */
+	{0x11bd, 0x0120}, /* index:208, gain:19.50000db, again:14.71875db, dgain:0.00000db, pixel gain: ON */
+	{0x11be, 0x0120}, /* index:209, gain:19.59375db, again:14.81250db, dgain:0.00000db, pixel gain: ON */
+	{0x11bf, 0x0120}, /* index:210, gain:19.68750db, again:14.90625db, dgain:0.00000db, pixel gain: ON */
+	{0x11c0, 0x0120}, /* index:211, gain:19.78125db, again:15.00000db, dgain:0.00000db, pixel gain: ON */
+	{0x11c1, 0x0120}, /* index:212, gain:19.87500db, again:15.09375db, dgain:0.00000db, pixel gain: ON */
+	{0x11c2, 0x0120}, /* index:213, gain:19.96875db, again:15.18750db, dgain:0.00000db, pixel gain: ON */
+	{0x11c3, 0x0120}, /* index:214, gain:20.06250db, again:15.28125db, dgain:0.00000db, pixel gain: ON */
+	{0x11c4, 0x0120}, /* index:215, gain:20.15625db, again:15.37500db, dgain:0.00000db, pixel gain: ON */
+	{0x11c5, 0x0120}, /* index:216, gain:20.25000db, again:15.46875db, dgain:0.00000db, pixel gain: ON */
+	{0x11c6, 0x0120}, /* index:217, gain:20.34375db, again:15.56250db, dgain:0.00000db, pixel gain: ON */
+	{0x11c7, 0x0120}, /* index:218, gain:20.43750db, again:15.65625db, dgain:0.00000db, pixel gain: ON */
+	{0x11c8, 0x0120}, /* index:219, gain:20.53125db, again:15.75000db, dgain:0.00000db, pixel gain: ON */
+	{0x11c9, 0x0120}, /* index:220, gain:20.62500db, again:15.84375db, dgain:0.00000db, pixel gain: ON */
+	{0x11ca, 0x0120}, /* index:221, gain:20.71875db, again:15.93750db, dgain:0.00000db, pixel gain: ON */
+	{0x11cb, 0x0120}, /* index:222, gain:20.81250db, again:16.03125db, dgain:0.00000db, pixel gain: ON */
+	{0x11cc, 0x0120}, /* index:223, gain:20.90625db, again:16.12500db, dgain:0.00000db, pixel gain: ON */
+	{0x11cd, 0x0120}, /* index:224, gain:21.00000db, again:16.21875db, dgain:0.00000db, pixel gain: ON */
+	{0x11ce, 0x0120}, /* index:225, gain:21.09375db, again:16.31250db, dgain:0.00000db, pixel gain: ON */
+	{0x11cf, 0x0120}, /* index:226, gain:21.18750db, again:16.40625db, dgain:0.00000db, pixel gain: ON */
+	{0x11d0, 0x0120}, /* index:227, gain:21.28125db, again:16.50000db, dgain:0.00000db, pixel gain: ON */
+	{0x11d1, 0x0120}, /* index:228, gain:21.37500db, again:16.59375db, dgain:0.00000db, pixel gain: ON */
+	{0x11d2, 0x0120}, /* index:229, gain:21.46875db, again:16.68750db, dgain:0.00000db, pixel gain: ON */
+	{0x11d3, 0x0120}, /* index:230, gain:21.56250db, again:16.78125db, dgain:0.00000db, pixel gain: ON */
+	{0x11d4, 0x0120}, /* index:231, gain:21.65625db, again:16.87500db, dgain:0.00000db, pixel gain: ON */
+	{0x11d5, 0x0120}, /* index:232, gain:21.75000db, again:16.96875db, dgain:0.00000db, pixel gain: ON */
+	{0x11d6, 0x0120}, /* index:233, gain:21.84375db, again:17.06250db, dgain:0.00000db, pixel gain: ON */
+	{0x11d7, 0x0120}, /* index:234, gain:21.93750db, again:17.15625db, dgain:0.00000db, pixel gain: ON */
+	{0x11d8, 0x0120}, /* index:235, gain:22.03125db, again:17.25000db, dgain:0.00000db, pixel gain: ON */
+	{0x11d9, 0x0120}, /* index:236, gain:22.12500db, again:17.34375db, dgain:0.00000db, pixel gain: ON */
+	{0x11da, 0x0120}, /* index:237, gain:22.21875db, again:17.43750db, dgain:0.00000db, pixel gain: ON */
+	{0x11db, 0x0120}, /* index:238, gain:22.31250db, again:17.53125db, dgain:0.00000db, pixel gain: ON */
+	{0x11dc, 0x0120}, /* index:239, gain:22.40625db, again:17.62500db, dgain:0.00000db, pixel gain: ON */
+	{0x11dd, 0x0120}, /* index:240, gain:22.50000db, again:17.71875db, dgain:0.00000db, pixel gain: ON */
+	{0x11de, 0x0120}, /* index:241, gain:22.59375db, again:17.81250db, dgain:0.00000db, pixel gain: ON */
+	{0x11df, 0x0120}, /* index:242, gain:22.68750db, again:17.90625db, dgain:0.00000db, pixel gain: ON */
+	{0x11e0, 0x0120}, /* index:243, gain:22.78125db, again:18.00000db, dgain:0.00000db, pixel gain: ON */
+	{0x11e1, 0x0120}, /* index:244, gain:22.87500db, again:18.09375db, dgain:0.00000db, pixel gain: ON */
+	{0x11e2, 0x0120}, /* index:245, gain:22.96875db, again:18.18750db, dgain:0.00000db, pixel gain: ON */
+	{0x11e3, 0x0120}, /* index:246, gain:23.06250db, again:18.28125db, dgain:0.00000db, pixel gain: ON */
+	{0x11e4, 0x0120}, /* index:247, gain:23.15625db, again:18.37500db, dgain:0.00000db, pixel gain: ON */
+	{0x11e5, 0x0120}, /* index:248, gain:23.25000db, again:18.46875db, dgain:0.00000db, pixel gain: ON */
+	{0x11e6, 0x0120}, /* index:249, gain:23.34375db, again:18.56250db, dgain:0.00000db, pixel gain: ON */
+	{0x11e7, 0x0120}, /* index:250, gain:23.43750db, again:18.65625db, dgain:0.00000db, pixel gain: ON */
+	{0x11e8, 0x0120}, /* index:251, gain:23.53125db, again:18.75000db, dgain:0.00000db, pixel gain: ON */
+	{0x11e9, 0x0120}, /* index:252, gain:23.62500db, again:18.84375db, dgain:0.00000db, pixel gain: ON */
+	{0x11ea, 0x0120}, /* index:253, gain:23.71875db, again:18.93750db, dgain:0.00000db, pixel gain: ON */
+	{0x11eb, 0x0120}, /* index:254, gain:23.81250db, again:19.03125db, dgain:0.00000db, pixel gain: ON */
+	{0x11ec, 0x0120}, /* index:255, gain:23.90625db, again:19.12500db, dgain:0.00000db, pixel gain: ON */
+	{0x11ed, 0x0120}, /* index:256, gain:24.00000db, again:19.21875db, dgain:0.00000db, pixel gain: ON */
+	{0x11ee, 0x0120}, /* index:257, gain:24.09375db, again:19.31250db, dgain:0.00000db, pixel gain: ON */
+	{0x11ef, 0x0120}, /* index:258, gain:24.18750db, again:19.40625db, dgain:0.00000db, pixel gain: ON */
+	{0x11f0, 0x0120}, /* index:259, gain:24.28125db, again:19.50000db, dgain:0.00000db, pixel gain: ON */
+	{0x11f1, 0x0120}, /* index:260, gain:24.37500db, again:19.59375db, dgain:0.00000db, pixel gain: ON */
+	{0x11f2, 0x0120}, /* index:261, gain:24.46875db, again:19.68750db, dgain:0.00000db, pixel gain: ON */
+	{0x11f3, 0x0120}, /* index:262, gain:24.56250db, again:19.78125db, dgain:0.00000db, pixel gain: ON */
+	{0x11f4, 0x0120}, /* index:263, gain:24.65625db, again:19.87500db, dgain:0.00000db, pixel gain: ON */
+	{0x11f5, 0x0120}, /* index:264, gain:24.75000db, again:19.96875db, dgain:0.00000db, pixel gain: ON */
+	{0x11f6, 0x0120}, /* index:265, gain:24.84375db, again:20.06250db, dgain:0.00000db, pixel gain: ON */
+	{0x11f7, 0x0120}, /* index:266, gain:24.93750db, again:20.15625db, dgain:0.00000db, pixel gain: ON */
+	{0x11f8, 0x0120}, /* index:267, gain:25.03125db, again:20.25000db, dgain:0.00000db, pixel gain: ON */
+	{0x11f9, 0x0120}, /* index:268, gain:25.12500db, again:20.34375db, dgain:0.00000db, pixel gain: ON */
+	{0x11fa, 0x0120}, /* index:269, gain:25.21875db, again:20.43750db, dgain:0.00000db, pixel gain: ON */
+	{0x11fb, 0x0120}, /* index:270, gain:25.31250db, again:20.53125db, dgain:0.00000db, pixel gain: ON */
+	{0x11fc, 0x0120}, /* index:271, gain:25.40625db, again:20.62500db, dgain:0.00000db, pixel gain: ON */
+	{0x11fd, 0x0120}, /* index:272, gain:25.50000db, again:20.71875db, dgain:0.00000db, pixel gain: ON */
+	{0x11fe, 0x0120}, /* index:273, gain:25.59375db, again:20.81250db, dgain:0.00000db, pixel gain: ON */
+	{0x11ff, 0x0120}, /* index:274, gain:25.68750db, again:20.90625db, dgain:0.00000db, pixel gain: ON */
+	{0x1200, 0x0120}, /* index:275, gain:25.78125db, again:21.00000db, dgain:0.00000db, pixel gain: ON */
+	{0x1201, 0x0120}, /* index:276, gain:25.87500db, again:21.09375db, dgain:0.00000db, pixel gain: ON */
+	{0x1202, 0x0120}, /* index:277, gain:25.96875db, again:21.18750db, dgain:0.00000db, pixel gain: ON */
+	{0x1203, 0x0120}, /* index:278, gain:26.06250db, again:21.28125db, dgain:0.00000db, pixel gain: ON */
+	{0x1204, 0x0120}, /* index:279, gain:26.15625db, again:21.37500db, dgain:0.00000db, pixel gain: ON */
+	{0x1205, 0x0120}, /* index:280, gain:26.25000db, again:21.46875db, dgain:0.00000db, pixel gain: ON */
+	{0x1206, 0x0120}, /* index:281, gain:26.34375db, again:21.56250db, dgain:0.00000db, pixel gain: ON */
+	{0x1207, 0x0120}, /* index:282, gain:26.43750db, again:21.65625db, dgain:0.00000db, pixel gain: ON */
+	{0x1208, 0x0120}, /* index:283, gain:26.53125db, again:21.75000db, dgain:0.00000db, pixel gain: ON */
+	{0x1209, 0x0120}, /* index:284, gain:26.62500db, again:21.84375db, dgain:0.00000db, pixel gain: ON */
+	{0x120a, 0x0120}, /* index:285, gain:26.71875db, again:21.93750db, dgain:0.00000db, pixel gain: ON */
+	{0x120b, 0x0120}, /* index:286, gain:26.81250db, again:22.03125db, dgain:0.00000db, pixel gain: ON */
+	{0x120c, 0x0120}, /* index:287, gain:26.90625db, again:22.12500db, dgain:0.00000db, pixel gain: ON */
+	{0x120d, 0x0120}, /* index:288, gain:27.00000db, again:22.21875db, dgain:0.00000db, pixel gain: ON */
+	{0x120e, 0x0120}, /* index:289, gain:27.09375db, again:22.31250db, dgain:0.00000db, pixel gain: ON */
+	{0x120f, 0x0120}, /* index:290, gain:27.18750db, again:22.40625db, dgain:0.00000db, pixel gain: ON */
+	{0x1210, 0x0120}, /* index:291, gain:27.28125db, again:22.50000db, dgain:0.00000db, pixel gain: ON */
+	{0x1211, 0x0120}, /* index:292, gain:27.37500db, again:22.59375db, dgain:0.00000db, pixel gain: ON */
+	{0x1212, 0x0120}, /* index:293, gain:27.46875db, again:22.68750db, dgain:0.00000db, pixel gain: ON */
+	{0x1213, 0x0120}, /* index:294, gain:27.56250db, again:22.78125db, dgain:0.00000db, pixel gain: ON */
+	{0x1214, 0x0120}, /* index:295, gain:27.65625db, again:22.87500db, dgain:0.00000db, pixel gain: ON */
+	{0x1215, 0x0120}, /* index:296, gain:27.75000db, again:22.96875db, dgain:0.00000db, pixel gain: ON */
+	{0x1216, 0x0120}, /* index:297, gain:27.84375db, again:23.06250db, dgain:0.00000db, pixel gain: ON */
+	{0x1217, 0x0120}, /* index:298, gain:27.93750db, again:23.15625db, dgain:0.00000db, pixel gain: ON */
+	{0x1218, 0x0120}, /* index:299, gain:28.03125db, again:23.25000db, dgain:0.00000db, pixel gain: ON */
+	{0x1219, 0x0120}, /* index:300, gain:28.12500db, again:23.34375db, dgain:0.00000db, pixel gain: ON */
+	{0x121a, 0x0120}, /* index:301, gain:28.21875db, again:23.43750db, dgain:0.00000db, pixel gain: ON */
+	{0x121b, 0x0120}, /* index:302, gain:28.31250db, again:23.53125db, dgain:0.00000db, pixel gain: ON */
+	{0x121c, 0x0120}, /* index:303, gain:28.40625db, again:23.62500db, dgain:0.00000db, pixel gain: ON */
+	{0x121d, 0x0120}, /* index:304, gain:28.50000db, again:23.71875db, dgain:0.00000db, pixel gain: ON */
+	{0x121e, 0x0120}, /* index:305, gain:28.59375db, again:23.81250db, dgain:0.00000db, pixel gain: ON */
+	{0x121f, 0x0120}, /* index:306, gain:28.68750db, again:23.90625db, dgain:0.00000db, pixel gain: ON */
+	{0x1220, 0x0120}, /* index:307, gain:28.78125db, again:24.00000db, dgain:0.00000db, pixel gain: ON */
+	{0x1221, 0x0120}, /* index:308, gain:28.87500db, again:24.09375db, dgain:0.00000db, pixel gain: ON */
+	{0x1222, 0x0120}, /* index:309, gain:28.96875db, again:24.18750db, dgain:0.00000db, pixel gain: ON */
+	{0x1223, 0x0120}, /* index:310, gain:29.06250db, again:24.28125db, dgain:0.00000db, pixel gain: ON */
+	{0x1224, 0x0120}, /* index:311, gain:29.15625db, again:24.37500db, dgain:0.00000db, pixel gain: ON */
+	{0x1225, 0x0120}, /* index:312, gain:29.25000db, again:24.46875db, dgain:0.00000db, pixel gain: ON */
+	{0x1226, 0x0120}, /* index:313, gain:29.34375db, again:24.56250db, dgain:0.00000db, pixel gain: ON */
+	{0x1227, 0x0120}, /* index:314, gain:29.43750db, again:24.65625db, dgain:0.00000db, pixel gain: ON */
+	{0x1228, 0x0120}, /* index:315, gain:29.53125db, again:24.75000db, dgain:0.00000db, pixel gain: ON */
+	{0x1229, 0x0120}, /* index:316, gain:29.62500db, again:24.84375db, dgain:0.00000db, pixel gain: ON */
+	{0x122a, 0x0120}, /* index:317, gain:29.71875db, again:24.93750db, dgain:0.00000db, pixel gain: ON */
+	{0x122b, 0x0120}, /* index:318, gain:29.81250db, again:25.03125db, dgain:0.00000db, pixel gain: ON */
+	{0x122c, 0x0120}, /* index:319, gain:29.90625db, again:25.12500db, dgain:0.00000db, pixel gain: ON */
+	{0x122d, 0x0120}, /* index:320, gain:30.00000db, again:25.21875db, dgain:0.00000db, pixel gain: ON */
+	{0x122e, 0x0120}, /* index:321, gain:30.09375db, again:25.31250db, dgain:0.00000db, pixel gain: ON */
+	{0x122f, 0x0120}, /* index:322, gain:30.18750db, again:25.40625db, dgain:0.00000db, pixel gain: ON */
+	{0x1230, 0x0120}, /* index:323, gain:30.28125db, again:25.50000db, dgain:0.00000db, pixel gain: ON */
+	{0x1231, 0x0120}, /* index:324, gain:30.37500db, again:25.59375db, dgain:0.00000db, pixel gain: ON */
+	{0x1232, 0x0120}, /* index:325, gain:30.46875db, again:25.68750db, dgain:0.00000db, pixel gain: ON */
+	{0x1233, 0x0120}, /* index:326, gain:30.56250db, again:25.78125db, dgain:0.00000db, pixel gain: ON */
+	{0x1234, 0x0120}, /* index:327, gain:30.65625db, again:25.87500db, dgain:0.00000db, pixel gain: ON */
+	{0x1235, 0x0120}, /* index:328, gain:30.75000db, again:25.96875db, dgain:0.00000db, pixel gain: ON */
+	{0x1236, 0x0120}, /* index:329, gain:30.84375db, again:26.06250db, dgain:0.00000db, pixel gain: ON */
+	{0x1237, 0x0120}, /* index:330, gain:30.93750db, again:26.15625db, dgain:0.00000db, pixel gain: ON */
+	{0x1238, 0x0120}, /* index:331, gain:31.03125db, again:26.25000db, dgain:0.00000db, pixel gain: ON */
+	{0x1239, 0x0120}, /* index:332, gain:31.12500db, again:26.34375db, dgain:0.00000db, pixel gain: ON */
+	{0x123a, 0x0120}, /* index:333, gain:31.21875db, again:26.43750db, dgain:0.00000db, pixel gain: ON */
+	{0x123b, 0x0120}, /* index:334, gain:31.31250db, again:26.53125db, dgain:0.00000db, pixel gain: ON */
+	{0x123c, 0x0120}, /* index:335, gain:31.40625db, again:26.62500db, dgain:0.00000db, pixel gain: ON */
+	{0x123d, 0x0120}, /* index:336, gain:31.50000db, again:26.71875db, dgain:0.00000db, pixel gain: ON */
+	{0x123e, 0x0120}, /* index:337, gain:31.59375db, again:26.81250db, dgain:0.00000db, pixel gain: ON */
+	{0x123f, 0x0120}, /* index:338, gain:31.68750db, again:26.90625db, dgain:0.00000db, pixel gain: ON */
+	{0x1240, 0x0120}, /* index:339, gain:31.78125db, again:27.00000db, dgain:0.00000db, pixel gain: ON */
+	{0x1241, 0x0120}, /* index:340, gain:31.87500db, again:27.09375db, dgain:0.00000db, pixel gain: ON */
+	{0x1242, 0x0120}, /* index:341, gain:31.96875db, again:27.18750db, dgain:0.00000db, pixel gain: ON */
+	{0x1243, 0x0120}, /* index:342, gain:32.06250db, again:27.28125db, dgain:0.00000db, pixel gain: ON */
+	{0x1244, 0x0120}, /* index:343, gain:32.15625db, again:27.37500db, dgain:0.00000db, pixel gain: ON */
+	{0x1245, 0x0120}, /* index:344, gain:32.25000db, again:27.46875db, dgain:0.00000db, pixel gain: ON */
+	{0x1246, 0x0120}, /* index:345, gain:32.34375db, again:27.56250db, dgain:0.00000db, pixel gain: ON */
+	{0x1247, 0x0120}, /* index:346, gain:32.43750db, again:27.65625db, dgain:0.00000db, pixel gain: ON */
+	{0x1248, 0x0120}, /* index:347, gain:32.53125db, again:27.75000db, dgain:0.00000db, pixel gain: ON */
+	{0x1249, 0x0120}, /* index:348, gain:32.62500db, again:27.84375db, dgain:0.00000db, pixel gain: ON */
+	{0x124a, 0x0120}, /* index:349, gain:32.71875db, again:27.93750db, dgain:0.00000db, pixel gain: ON */
+	{0x124b, 0x0120}, /* index:350, gain:32.81250db, again:28.03125db, dgain:0.00000db, pixel gain: ON */
+	{0x124c, 0x0120}, /* index:351, gain:32.90625db, again:28.12500db, dgain:0.00000db, pixel gain: ON */
+	{0x124d, 0x0120}, /* index:352, gain:33.00000db, again:28.21875db, dgain:0.00000db, pixel gain: ON */
+	{0x124e, 0x0120}, /* index:353, gain:33.09375db, again:28.31250db, dgain:0.00000db, pixel gain: ON */
+	{0x124f, 0x0120}, /* index:354, gain:33.18750db, again:28.40625db, dgain:0.00000db, pixel gain: ON */
+	{0x1250, 0x0120}, /* index:355, gain:33.28125db, again:28.50000db, dgain:0.00000db, pixel gain: ON */
+	{0x1251, 0x0120}, /* index:356, gain:33.37500db, again:28.59375db, dgain:0.00000db, pixel gain: ON */
+	{0x1252, 0x0120}, /* index:357, gain:33.46875db, again:28.68750db, dgain:0.00000db, pixel gain: ON */
+	{0x1253, 0x0120}, /* index:358, gain:33.56250db, again:28.78125db, dgain:0.00000db, pixel gain: ON */
+	{0x1254, 0x0120}, /* index:359, gain:33.65625db, again:28.87500db, dgain:0.00000db, pixel gain: ON */
+	{0x1255, 0x0120}, /* index:360, gain:33.75000db, again:28.96875db, dgain:0.00000db, pixel gain: ON */
+	{0x1256, 0x0120}, /* index:361, gain:33.84375db, again:29.06250db, dgain:0.00000db, pixel gain: ON */
+	{0x1257, 0x0120}, /* index:362, gain:33.93750db, again:29.15625db, dgain:0.00000db, pixel gain: ON */
+	{0x1258, 0x0120}, /* index:363, gain:34.03125db, again:29.25000db, dgain:0.00000db, pixel gain: ON */
+	{0x1259, 0x0120}, /* index:364, gain:34.12500db, again:29.34375db, dgain:0.00000db, pixel gain: ON */
+	{0x125a, 0x0120}, /* index:365, gain:34.21875db, again:29.43750db, dgain:0.00000db, pixel gain: ON */
+	{0x125b, 0x0120}, /* index:366, gain:34.31250db, again:29.53125db, dgain:0.00000db, pixel gain: ON */
+	{0x125c, 0x0120}, /* index:367, gain:34.40625db, again:29.62500db, dgain:0.00000db, pixel gain: ON */
+	{0x125d, 0x0120}, /* index:368, gain:34.50000db, again:29.71875db, dgain:0.00000db, pixel gain: ON */
+	{0x125e, 0x0120}, /* index:369, gain:34.59375db, again:29.81250db, dgain:0.00000db, pixel gain: ON */
+	{0x125f, 0x0120}, /* index:370, gain:34.68750db, again:29.90625db, dgain:0.00000db, pixel gain: ON */
+	{0x1260, 0x0120}, /* index:371, gain:34.78125db, again:30.00000db, dgain:0.00000db, pixel gain: ON */
+	{0x1260, 0x0121}, /* index:372, gain:34.87500db, again:30.00000db, dgain:0.09375db, pixel gain: ON */
+	{0x1260, 0x0122}, /* index:373, gain:34.96875db, again:30.00000db, dgain:0.18750db, pixel gain: ON */
+	{0x1260, 0x0123}, /* index:374, gain:35.06250db, again:30.00000db, dgain:0.28125db, pixel gain: ON */
+	{0x1260, 0x0124}, /* index:375, gain:35.15625db, again:30.00000db, dgain:0.37500db, pixel gain: ON */
+	{0x1260, 0x0125}, /* index:376, gain:35.25000db, again:30.00000db, dgain:0.46875db, pixel gain: ON */
+	{0x1260, 0x0126}, /* index:377, gain:35.34375db, again:30.00000db, dgain:0.56250db, pixel gain: ON */
+	{0x1260, 0x0127}, /* index:378, gain:35.43750db, again:30.00000db, dgain:0.65625db, pixel gain: ON */
+	{0x1260, 0x0128}, /* index:379, gain:35.53125db, again:30.00000db, dgain:0.75000db, pixel gain: ON */
+	{0x1260, 0x0129}, /* index:380, gain:35.62500db, again:30.00000db, dgain:0.84375db, pixel gain: ON */
+	{0x1260, 0x012a}, /* index:381, gain:35.71875db, again:30.00000db, dgain:0.93750db, pixel gain: ON */
+	{0x1260, 0x012b}, /* index:382, gain:35.81250db, again:30.00000db, dgain:1.03125db, pixel gain: ON */
+	{0x1260, 0x012c}, /* index:383, gain:35.90625db, again:30.00000db, dgain:1.12500db, pixel gain: ON */
+	{0x1260, 0x012d}, /* index:384, gain:36.00000db, again:30.00000db, dgain:1.21875db, pixel gain: ON */
+	{0x1260, 0x012e}, /* index:385, gain:36.09375db, again:30.00000db, dgain:1.31250db, pixel gain: ON */
+	{0x1260, 0x012f}, /* index:386, gain:36.18750db, again:30.00000db, dgain:1.40625db, pixel gain: ON */
+	{0x1260, 0x0130}, /* index:387, gain:36.28125db, again:30.00000db, dgain:1.50000db, pixel gain: ON */
+	{0x1260, 0x0131}, /* index:388, gain:36.37500db, again:30.00000db, dgain:1.59375db, pixel gain: ON */
+	{0x1260, 0x0132}, /* index:389, gain:36.46875db, again:30.00000db, dgain:1.68750db, pixel gain: ON */
+	{0x1260, 0x0133}, /* index:390, gain:36.56250db, again:30.00000db, dgain:1.78125db, pixel gain: ON */
+	{0x1260, 0x0134}, /* index:391, gain:36.65625db, again:30.00000db, dgain:1.87500db, pixel gain: ON */
+	{0x1260, 0x0135}, /* index:392, gain:36.75000db, again:30.00000db, dgain:1.96875db, pixel gain: ON */
+	{0x1260, 0x0136}, /* index:393, gain:36.84375db, again:30.00000db, dgain:2.06250db, pixel gain: ON */
+	{0x1260, 0x0137}, /* index:394, gain:36.93750db, again:30.00000db, dgain:2.15625db, pixel gain: ON */
+	{0x1260, 0x0138}, /* index:395, gain:37.03125db, again:30.00000db, dgain:2.25000db, pixel gain: ON */
+	{0x1260, 0x0139}, /* index:396, gain:37.12500db, again:30.00000db, dgain:2.34375db, pixel gain: ON */
+	{0x1260, 0x013a}, /* index:397, gain:37.21875db, again:30.00000db, dgain:2.43750db, pixel gain: ON */
+	{0x1260, 0x013b}, /* index:398, gain:37.31250db, again:30.00000db, dgain:2.53125db, pixel gain: ON */
+	{0x1260, 0x013c}, /* index:399, gain:37.40625db, again:30.00000db, dgain:2.62500db, pixel gain: ON */
+	{0x1260, 0x013d}, /* index:400, gain:37.50000db, again:30.00000db, dgain:2.71875db, pixel gain: ON */
+	{0x1260, 0x013e}, /* index:401, gain:37.59375db, again:30.00000db, dgain:2.81250db, pixel gain: ON */
+	{0x1260, 0x013f}, /* index:402, gain:37.68750db, again:30.00000db, dgain:2.90625db, pixel gain: ON */
+	{0x1260, 0x0140}, /* index:403, gain:37.78125db, again:30.00000db, dgain:3.00000db, pixel gain: ON */
+	{0x1260, 0x0141}, /* index:404, gain:37.87500db, again:30.00000db, dgain:3.09375db, pixel gain: ON */
+	{0x1260, 0x0142}, /* index:405, gain:37.96875db, again:30.00000db, dgain:3.18750db, pixel gain: ON */
+	{0x1260, 0x0143}, /* index:406, gain:38.06250db, again:30.00000db, dgain:3.28125db, pixel gain: ON */
+	{0x1260, 0x0144}, /* index:407, gain:38.15625db, again:30.00000db, dgain:3.37500db, pixel gain: ON */
+	{0x1260, 0x0145}, /* index:408, gain:38.25000db, again:30.00000db, dgain:3.46875db, pixel gain: ON */
+	{0x1260, 0x0146}, /* index:409, gain:38.34375db, again:30.00000db, dgain:3.56250db, pixel gain: ON */
+	{0x1260, 0x0147}, /* index:410, gain:38.43750db, again:30.00000db, dgain:3.65625db, pixel gain: ON */
+	{0x1260, 0x0148}, /* index:411, gain:38.53125db, again:30.00000db, dgain:3.75000db, pixel gain: ON */
+	{0x1260, 0x0149}, /* index:412, gain:38.62500db, again:30.00000db, dgain:3.84375db, pixel gain: ON */
+	{0x1260, 0x014a}, /* index:413, gain:38.71875db, again:30.00000db, dgain:3.93750db, pixel gain: ON */
+	{0x1260, 0x014b}, /* index:414, gain:38.81250db, again:30.00000db, dgain:4.03125db, pixel gain: ON */
+	{0x1260, 0x014c}, /* index:415, gain:38.90625db, again:30.00000db, dgain:4.12500db, pixel gain: ON */
+	{0x1260, 0x014d}, /* index:416, gain:39.00000db, again:30.00000db, dgain:4.21875db, pixel gain: ON */
+	{0x1260, 0x014e}, /* index:417, gain:39.09375db, again:30.00000db, dgain:4.31250db, pixel gain: ON */
+	{0x1260, 0x014f}, /* index:418, gain:39.18750db, again:30.00000db, dgain:4.40625db, pixel gain: ON */
+	{0x1260, 0x0150}, /* index:419, gain:39.28125db, again:30.00000db, dgain:4.50000db, pixel gain: ON */
+	{0x1260, 0x0151}, /* index:420, gain:39.37500db, again:30.00000db, dgain:4.59375db, pixel gain: ON */
+	{0x1260, 0x0152}, /* index:421, gain:39.46875db, again:30.00000db, dgain:4.68750db, pixel gain: ON */
+	{0x1260, 0x0153}, /* index:422, gain:39.56250db, again:30.00000db, dgain:4.78125db, pixel gain: ON */
+	{0x1260, 0x0154}, /* index:423, gain:39.65625db, again:30.00000db, dgain:4.87500db, pixel gain: ON */
+	{0x1260, 0x0155}, /* index:424, gain:39.75000db, again:30.00000db, dgain:4.96875db, pixel gain: ON */
+	{0x1260, 0x0156}, /* index:425, gain:39.84375db, again:30.00000db, dgain:5.06250db, pixel gain: ON */
+	{0x1260, 0x0157}, /* index:426, gain:39.93750db, again:30.00000db, dgain:5.15625db, pixel gain: ON */
+	{0x1260, 0x0158}, /* index:427, gain:40.03125db, again:30.00000db, dgain:5.25000db, pixel gain: ON */
+	{0x1260, 0x0159}, /* index:428, gain:40.12500db, again:30.00000db, dgain:5.34375db, pixel gain: ON */
+	{0x1260, 0x015a}, /* index:429, gain:40.21875db, again:30.00000db, dgain:5.43750db, pixel gain: ON */
+	{0x1260, 0x015b}, /* index:430, gain:40.31250db, again:30.00000db, dgain:5.53125db, pixel gain: ON */
+	{0x1260, 0x015c}, /* index:431, gain:40.40625db, again:30.00000db, dgain:5.62500db, pixel gain: ON */
+	{0x1260, 0x015d}, /* index:432, gain:40.50000db, again:30.00000db, dgain:5.71875db, pixel gain: ON */
+	{0x1260, 0x015e}, /* index:433, gain:40.59375db, again:30.00000db, dgain:5.81250db, pixel gain: ON */
+	{0x1260, 0x015f}, /* index:434, gain:40.68750db, again:30.00000db, dgain:5.90625db, pixel gain: ON */
+	{0x1260, 0x0160}, /* index:435, gain:40.78125db, again:30.00000db, dgain:6.00000db, pixel gain: ON */
+	{0x1260, 0x0161}, /* index:436, gain:40.87500db, again:30.00000db, dgain:6.09375db, pixel gain: ON */
+	{0x1260, 0x0162}, /* index:437, gain:40.96875db, again:30.00000db, dgain:6.18750db, pixel gain: ON */
+	{0x1260, 0x0163}, /* index:438, gain:41.06250db, again:30.00000db, dgain:6.28125db, pixel gain: ON */
+	{0x1260, 0x0164}, /* index:439, gain:41.15625db, again:30.00000db, dgain:6.37500db, pixel gain: ON */
+	{0x1260, 0x0165}, /* index:440, gain:41.25000db, again:30.00000db, dgain:6.46875db, pixel gain: ON */
+	{0x1260, 0x0166}, /* index:441, gain:41.34375db, again:30.00000db, dgain:6.56250db, pixel gain: ON */
+	{0x1260, 0x0167}, /* index:442, gain:41.43750db, again:30.00000db, dgain:6.65625db, pixel gain: ON */
+	{0x1260, 0x0168}, /* index:443, gain:41.53125db, again:30.00000db, dgain:6.75000db, pixel gain: ON */
+	{0x1260, 0x0169}, /* index:444, gain:41.62500db, again:30.00000db, dgain:6.84375db, pixel gain: ON */
+	{0x1260, 0x016a}, /* index:445, gain:41.71875db, again:30.00000db, dgain:6.93750db, pixel gain: ON */
+	{0x1260, 0x016b}, /* index:446, gain:41.81250db, again:30.00000db, dgain:7.03125db, pixel gain: ON */
+	{0x1260, 0x016c}, /* index:447, gain:41.90625db, again:30.00000db, dgain:7.12500db, pixel gain: ON */
+	{0x1260, 0x016d}, /* index:448, gain:42.00000db, again:30.00000db, dgain:7.21875db, pixel gain: ON */
+	{0x1260, 0x016e}, /* index:449, gain:42.09375db, again:30.00000db, dgain:7.31250db, pixel gain: ON */
+	{0x1260, 0x016f}, /* index:450, gain:42.18750db, again:30.00000db, dgain:7.40625db, pixel gain: ON */
+	{0x1260, 0x0170}, /* index:451, gain:42.28125db, again:30.00000db, dgain:7.50000db, pixel gain: ON */
+	{0x1260, 0x0171}, /* index:452, gain:42.37500db, again:30.00000db, dgain:7.59375db, pixel gain: ON */
+	{0x1260, 0x0172}, /* index:453, gain:42.46875db, again:30.00000db, dgain:7.68750db, pixel gain: ON */
+	{0x1260, 0x0173}, /* index:454, gain:42.56250db, again:30.00000db, dgain:7.78125db, pixel gain: ON */
+	{0x1260, 0x0174}, /* index:455, gain:42.65625db, again:30.00000db, dgain:7.87500db, pixel gain: ON */
+	{0x1260, 0x0175}, /* index:456, gain:42.75000db, again:30.00000db, dgain:7.96875db, pixel gain: ON */
+	{0x1260, 0x0176}, /* index:457, gain:42.84375db, again:30.00000db, dgain:8.06250db, pixel gain: ON */
+	{0x1260, 0x0177}, /* index:458, gain:42.93750db, again:30.00000db, dgain:8.15625db, pixel gain: ON */
+	{0x1260, 0x0178}, /* index:459, gain:43.03125db, again:30.00000db, dgain:8.25000db, pixel gain: ON */
+	{0x1260, 0x0179}, /* index:460, gain:43.12500db, again:30.00000db, dgain:8.34375db, pixel gain: ON */
+	{0x1260, 0x017a}, /* index:461, gain:43.21875db, again:30.00000db, dgain:8.43750db, pixel gain: ON */
+	{0x1260, 0x017b}, /* index:462, gain:43.31250db, again:30.00000db, dgain:8.53125db, pixel gain: ON */
+	{0x1260, 0x017c}, /* index:463, gain:43.40625db, again:30.00000db, dgain:8.62500db, pixel gain: ON */
+	{0x1260, 0x017d}, /* index:464, gain:43.50000db, again:30.00000db, dgain:8.71875db, pixel gain: ON */
+	{0x1260, 0x017e}, /* index:465, gain:43.59375db, again:30.00000db, dgain:8.81250db, pixel gain: ON */
+	{0x1260, 0x017f}, /* index:466, gain:43.68750db, again:30.00000db, dgain:8.90625db, pixel gain: ON */
+	{0x1260, 0x0180}, /* index:467, gain:43.78125db, again:30.00000db, dgain:9.00000db, pixel gain: ON */
+	{0x1260, 0x0181}, /* index:468, gain:43.87500db, again:30.00000db, dgain:9.09375db, pixel gain: ON */
+	{0x1260, 0x0182}, /* index:469, gain:43.96875db, again:30.00000db, dgain:9.18750db, pixel gain: ON */
+	{0x1260, 0x0183}, /* index:470, gain:44.06250db, again:30.00000db, dgain:9.28125db, pixel gain: ON */
+	{0x1260, 0x0184}, /* index:471, gain:44.15625db, again:30.00000db, dgain:9.37500db, pixel gain: ON */
+	{0x1260, 0x0185}, /* index:472, gain:44.25000db, again:30.00000db, dgain:9.46875db, pixel gain: ON */
+	{0x1260, 0x0186}, /* index:473, gain:44.34375db, again:30.00000db, dgain:9.56250db, pixel gain: ON */
+	{0x1260, 0x0187}, /* index:474, gain:44.43750db, again:30.00000db, dgain:9.65625db, pixel gain: ON */
+	{0x1260, 0x0188}, /* index:475, gain:44.53125db, again:30.00000db, dgain:9.75000db, pixel gain: ON */
+	{0x1260, 0x0189}, /* index:476, gain:44.62500db, again:30.00000db, dgain:9.84375db, pixel gain: ON */
+	{0x1260, 0x018a}, /* index:477, gain:44.71875db, again:30.00000db, dgain:9.93750db, pixel gain: ON */
+	{0x1260, 0x018b}, /* index:478, gain:44.81250db, again:30.00000db, dgain:10.03125db, pixel gain: ON */
+	{0x1260, 0x018c}, /* index:479, gain:44.90625db, again:30.00000db, dgain:10.12500db, pixel gain: ON */
+	{0x1260, 0x018d}, /* index:480, gain:45.00000db, again:30.00000db, dgain:10.21875db, pixel gain: ON */
+	{0x1260, 0x018e}, /* index:481, gain:45.09375db, again:30.00000db, dgain:10.31250db, pixel gain: ON */
+	{0x1260, 0x018f}, /* index:482, gain:45.18750db, again:30.00000db, dgain:10.40625db, pixel gain: ON */
+	{0x1260, 0x0190}, /* index:483, gain:45.28125db, again:30.00000db, dgain:10.50000db, pixel gain: ON */
+	{0x1260, 0x0191}, /* index:484, gain:45.37500db, again:30.00000db, dgain:10.59375db, pixel gain: ON */
+	{0x1260, 0x0192}, /* index:485, gain:45.46875db, again:30.00000db, dgain:10.68750db, pixel gain: ON */
+	{0x1260, 0x0193}, /* index:486, gain:45.56250db, again:30.00000db, dgain:10.78125db, pixel gain: ON */
+	{0x1260, 0x0194}, /* index:487, gain:45.65625db, again:30.00000db, dgain:10.87500db, pixel gain: ON */
+	{0x1260, 0x0195}, /* index:488, gain:45.75000db, again:30.00000db, dgain:10.96875db, pixel gain: ON */
+	{0x1260, 0x0196}, /* index:489, gain:45.84375db, again:30.00000db, dgain:11.06250db, pixel gain: ON */
+	{0x1260, 0x0197}, /* index:490, gain:45.93750db, again:30.00000db, dgain:11.15625db, pixel gain: ON */
+	{0x1260, 0x0198}, /* index:491, gain:46.03125db, again:30.00000db, dgain:11.25000db, pixel gain: ON */
+	{0x1260, 0x0199}, /* index:492, gain:46.12500db, again:30.00000db, dgain:11.34375db, pixel gain: ON */
+	{0x1260, 0x019a}, /* index:493, gain:46.21875db, again:30.00000db, dgain:11.43750db, pixel gain: ON */
+	{0x1260, 0x019b}, /* index:494, gain:46.31250db, again:30.00000db, dgain:11.53125db, pixel gain: ON */
+	{0x1260, 0x019c}, /* index:495, gain:46.40625db, again:30.00000db, dgain:11.62500db, pixel gain: ON */
+	{0x1260, 0x019d}, /* index:496, gain:46.50000db, again:30.00000db, dgain:11.71875db, pixel gain: ON */
+	{0x1260, 0x019e}, /* index:497, gain:46.59375db, again:30.00000db, dgain:11.81250db, pixel gain: ON */
+	{0x1260, 0x019f}, /* index:498, gain:46.68750db, again:30.00000db, dgain:11.90625db, pixel gain: ON */
+	{0x1260, 0x01a0}, /* index:499, gain:46.78125db, again:30.00000db, dgain:12.00000db, pixel gain: ON */
+	{0x1260, 0x01a1}, /* index:500, gain:46.87500db, again:30.00000db, dgain:12.09375db, pixel gain: ON */
+	{0x1260, 0x01a2}, /* index:501, gain:46.96875db, again:30.00000db, dgain:12.18750db, pixel gain: ON */
+	{0x1260, 0x01a3}, /* index:502, gain:47.06250db, again:30.00000db, dgain:12.28125db, pixel gain: ON */
+	{0x1260, 0x01a4}, /* index:503, gain:47.15625db, again:30.00000db, dgain:12.37500db, pixel gain: ON */
+	{0x1260, 0x01a5}, /* index:504, gain:47.25000db, again:30.00000db, dgain:12.46875db, pixel gain: ON */
+	{0x1260, 0x01a6}, /* index:505, gain:47.34375db, again:30.00000db, dgain:12.56250db, pixel gain: ON */
+	{0x1260, 0x01a7}, /* index:506, gain:47.43750db, again:30.00000db, dgain:12.65625db, pixel gain: ON */
+	{0x1260, 0x01a8}, /* index:507, gain:47.53125db, again:30.00000db, dgain:12.75000db, pixel gain: ON */
+	{0x1260, 0x01a9}, /* index:508, gain:47.62500db, again:30.00000db, dgain:12.84375db, pixel gain: ON */
+	{0x1260, 0x01aa}, /* index:509, gain:47.71875db, again:30.00000db, dgain:12.93750db, pixel gain: ON */
+	{0x1260, 0x01ab}, /* index:510, gain:47.81250db, again:30.00000db, dgain:13.03125db, pixel gain: ON */
+	{0x1260, 0x01ac}, /* index:511, gain:47.90625db, again:30.00000db, dgain:13.12500db, pixel gain: ON */
+	{0x1260, 0x01ad}, /* index:512, gain:48.00000db, again:30.00000db, dgain:13.21875db, pixel gain: ON */
+	{0x1260, 0x01ae}, /* index:513, gain:48.09375db, again:30.00000db, dgain:13.31250db, pixel gain: ON */
+	{0x1260, 0x01af}, /* index:514, gain:48.18750db, again:30.00000db, dgain:13.40625db, pixel gain: ON */
+	{0x1260, 0x01b0}, /* index:515, gain:48.28125db, again:30.00000db, dgain:13.50000db, pixel gain: ON */
+	{0x1260, 0x01b1}, /* index:516, gain:48.37500db, again:30.00000db, dgain:13.59375db, pixel gain: ON */
+	{0x1260, 0x01b2}, /* index:517, gain:48.46875db, again:30.00000db, dgain:13.68750db, pixel gain: ON */
+	{0x1260, 0x01b3}, /* index:518, gain:48.56250db, again:30.00000db, dgain:13.78125db, pixel gain: ON */
+	{0x1260, 0x01b4}, /* index:519, gain:48.65625db, again:30.00000db, dgain:13.87500db, pixel gain: ON */
+	{0x1260, 0x01b5}, /* index:520, gain:48.75000db, again:30.00000db, dgain:13.96875db, pixel gain: ON */
+	{0x1260, 0x01b6}, /* index:521, gain:48.84375db, again:30.00000db, dgain:14.06250db, pixel gain: ON */
+	{0x1260, 0x01b7}, /* index:522, gain:48.93750db, again:30.00000db, dgain:14.15625db, pixel gain: ON */
+	{0x1260, 0x01b8}, /* index:523, gain:49.03125db, again:30.00000db, dgain:14.25000db, pixel gain: ON */
+	{0x1260, 0x01b9}, /* index:524, gain:49.12500db, again:30.00000db, dgain:14.34375db, pixel gain: ON */
+	{0x1260, 0x01ba}, /* index:525, gain:49.21875db, again:30.00000db, dgain:14.43750db, pixel gain: ON */
+	{0x1260, 0x01bb}, /* index:526, gain:49.31250db, again:30.00000db, dgain:14.53125db, pixel gain: ON */
+	{0x1260, 0x01bc}, /* index:527, gain:49.40625db, again:30.00000db, dgain:14.62500db, pixel gain: ON */
+	{0x1260, 0x01bd}, /* index:528, gain:49.50000db, again:30.00000db, dgain:14.71875db, pixel gain: ON */
+	{0x1260, 0x01be}, /* index:529, gain:49.59375db, again:30.00000db, dgain:14.81250db, pixel gain: ON */
+	{0x1260, 0x01bf}, /* index:530, gain:49.68750db, again:30.00000db, dgain:14.90625db, pixel gain: ON */
+	{0x1260, 0x01c0}, /* index:531, gain:49.78125db, again:30.00000db, dgain:15.00000db, pixel gain: ON */
+	{0x1260, 0x01c1}, /* index:532, gain:49.87500db, again:30.00000db, dgain:15.09375db, pixel gain: ON */
+	{0x1260, 0x01c2}, /* index:533, gain:49.96875db, again:30.00000db, dgain:15.18750db, pixel gain: ON */
+	{0x1260, 0x01c3}, /* index:534, gain:50.06250db, again:30.00000db, dgain:15.28125db, pixel gain: ON */
+	{0x1260, 0x01c4}, /* index:535, gain:50.15625db, again:30.00000db, dgain:15.37500db, pixel gain: ON */
+	{0x1260, 0x01c5}, /* index:536, gain:50.25000db, again:30.00000db, dgain:15.46875db, pixel gain: ON */
+	{0x1260, 0x01c6}, /* index:537, gain:50.34375db, again:30.00000db, dgain:15.56250db, pixel gain: ON */
+	{0x1260, 0x01c7}, /* index:538, gain:50.43750db, again:30.00000db, dgain:15.65625db, pixel gain: ON */
+	{0x1260, 0x01c8}, /* index:539, gain:50.53125db, again:30.00000db, dgain:15.75000db, pixel gain: ON */
+	{0x1260, 0x01c9}, /* index:540, gain:50.62500db, again:30.00000db, dgain:15.84375db, pixel gain: ON */
+	{0x1260, 0x01ca}, /* index:541, gain:50.71875db, again:30.00000db, dgain:15.93750db, pixel gain: ON */
+	{0x1260, 0x01cb}, /* index:542, gain:50.81250db, again:30.00000db, dgain:16.03125db, pixel gain: ON */
+	{0x1260, 0x01cc}, /* index:543, gain:50.90625db, again:30.00000db, dgain:16.12500db, pixel gain: ON */
+	{0x1260, 0x01cd}, /* index:544, gain:51.00000db, again:30.00000db, dgain:16.21875db, pixel gain: ON */
+	{0x1260, 0x01ce}, /* index:545, gain:51.09375db, again:30.00000db, dgain:16.31250db, pixel gain: ON */
+	{0x1260, 0x01cf}, /* index:546, gain:51.18750db, again:30.00000db, dgain:16.40625db, pixel gain: ON */
+	{0x1260, 0x01d0}, /* index:547, gain:51.28125db, again:30.00000db, dgain:16.50000db, pixel gain: ON */
+	{0x1260, 0x01d1}, /* index:548, gain:51.37500db, again:30.00000db, dgain:16.59375db, pixel gain: ON */
+	{0x1260, 0x01d2}, /* index:549, gain:51.46875db, again:30.00000db, dgain:16.68750db, pixel gain: ON */
+	{0x1260, 0x01d3}, /* index:550, gain:51.56250db, again:30.00000db, dgain:16.78125db, pixel gain: ON */
+	{0x1260, 0x01d4}, /* index:551, gain:51.65625db, again:30.00000db, dgain:16.87500db, pixel gain: ON */
+	{0x1260, 0x01d5}, /* index:552, gain:51.75000db, again:30.00000db, dgain:16.96875db, pixel gain: ON */
+	{0x1260, 0x01d6}, /* index:553, gain:51.84375db, again:30.00000db, dgain:17.06250db, pixel gain: ON */
+	{0x1260, 0x01d7}, /* index:554, gain:51.93750db, again:30.00000db, dgain:17.15625db, pixel gain: ON */
+	{0x1260, 0x01d8}, /* index:555, gain:52.03125db, again:30.00000db, dgain:17.25000db, pixel gain: ON */
+	{0x1260, 0x01d9}, /* index:556, gain:52.12500db, again:30.00000db, dgain:17.34375db, pixel gain: ON */
+	{0x1260, 0x01da}, /* index:557, gain:52.21875db, again:30.00000db, dgain:17.43750db, pixel gain: ON */
+	{0x1260, 0x01db}, /* index:558, gain:52.31250db, again:30.00000db, dgain:17.53125db, pixel gain: ON */
+	{0x1260, 0x01dc}, /* index:559, gain:52.40625db, again:30.00000db, dgain:17.62500db, pixel gain: ON */
+	{0x1260, 0x01dd}, /* index:560, gain:52.50000db, again:30.00000db, dgain:17.71875db, pixel gain: ON */
+	{0x1260, 0x01de}, /* index:561, gain:52.59375db, again:30.00000db, dgain:17.81250db, pixel gain: ON */
+	{0x1260, 0x01df}, /* index:562, gain:52.68750db, again:30.00000db, dgain:17.90625db, pixel gain: ON */
+	{0x1260, 0x01e0}, /* index:563, gain:52.78125db, again:30.00000db, dgain:18.00000db, pixel gain: ON */
+	{0x1260, 0x01e1}, /* index:564, gain:52.87500db, again:30.00000db, dgain:18.09375db, pixel gain: ON */
+	{0x1260, 0x01e2}, /* index:565, gain:52.96875db, again:30.00000db, dgain:18.18750db, pixel gain: ON */
+	{0x1260, 0x01e3}, /* index:566, gain:53.06250db, again:30.00000db, dgain:18.28125db, pixel gain: ON */
+	{0x1260, 0x01e4}, /* index:567, gain:53.15625db, again:30.00000db, dgain:18.37500db, pixel gain: ON */
+	{0x1260, 0x01e5}, /* index:568, gain:53.25000db, again:30.00000db, dgain:18.46875db, pixel gain: ON */
+	{0x1260, 0x01e6}, /* index:569, gain:53.34375db, again:30.00000db, dgain:18.56250db, pixel gain: ON */
+	{0x1260, 0x01e7}, /* index:570, gain:53.43750db, again:30.00000db, dgain:18.65625db, pixel gain: ON */
+	{0x1260, 0x01e8}, /* index:571, gain:53.53125db, again:30.00000db, dgain:18.75000db, pixel gain: ON */
+	{0x1260, 0x01e9}, /* index:572, gain:53.62500db, again:30.00000db, dgain:18.84375db, pixel gain: ON */
+	{0x1260, 0x01ea}, /* index:573, gain:53.71875db, again:30.00000db, dgain:18.93750db, pixel gain: ON */
+	{0x1260, 0x01eb}, /* index:574, gain:53.81250db, again:30.00000db, dgain:19.03125db, pixel gain: ON */
+	{0x1260, 0x01ec}, /* index:575, gain:53.90625db, again:30.00000db, dgain:19.12500db, pixel gain: ON */
+	{0x1260, 0x01ed}, /* index:576, gain:54.00000db, again:30.00000db, dgain:19.21875db, pixel gain: ON */
+	{0x1260, 0x01ee}, /* index:577, gain:54.09375db, again:30.00000db, dgain:19.31250db, pixel gain: ON */
+	{0x1260, 0x01ef}, /* index:578, gain:54.18750db, again:30.00000db, dgain:19.40625db, pixel gain: ON */
+	{0x1260, 0x01f0}, /* index:579, gain:54.28125db, again:30.00000db, dgain:19.50000db, pixel gain: ON */
+	{0x1260, 0x01f1}, /* index:580, gain:54.37500db, again:30.00000db, dgain:19.59375db, pixel gain: ON */
+	{0x1260, 0x01f2}, /* index:581, gain:54.46875db, again:30.00000db, dgain:19.68750db, pixel gain: ON */
+	{0x1260, 0x01f3}, /* index:582, gain:54.56250db, again:30.00000db, dgain:19.78125db, pixel gain: ON */
+	{0x1260, 0x01f4}, /* index:583, gain:54.65625db, again:30.00000db, dgain:19.87500db, pixel gain: ON */
+	{0x1260, 0x01f5}, /* index:584, gain:54.75000db, again:30.00000db, dgain:19.96875db, pixel gain: ON */
+	{0x1260, 0x01f6}, /* index:585, gain:54.84375db, again:30.00000db, dgain:20.06250db, pixel gain: ON */
+	{0x1260, 0x01f7}, /* index:586, gain:54.93750db, again:30.00000db, dgain:20.15625db, pixel gain: ON */
+	{0x1260, 0x01f8}, /* index:587, gain:55.03125db, again:30.00000db, dgain:20.25000db, pixel gain: ON */
+	{0x1260, 0x01f9}, /* index:588, gain:55.12500db, again:30.00000db, dgain:20.34375db, pixel gain: ON */
+	{0x1260, 0x01fa}, /* index:589, gain:55.21875db, again:30.00000db, dgain:20.43750db, pixel gain: ON */
+	{0x1260, 0x01fb}, /* index:590, gain:55.31250db, again:30.00000db, dgain:20.53125db, pixel gain: ON */
+	{0x1260, 0x01fc}, /* index:591, gain:55.40625db, again:30.00000db, dgain:20.62500db, pixel gain: ON */
+	{0x1260, 0x01fd}, /* index:592, gain:55.50000db, again:30.00000db, dgain:20.71875db, pixel gain: ON */
+	{0x1260, 0x01fe}, /* index:593, gain:55.59375db, again:30.00000db, dgain:20.81250db, pixel gain: ON */
+	{0x1260, 0x01ff}, /* index:594, gain:55.68750db, again:30.00000db, dgain:20.90625db, pixel gain: ON */
+	{0x1260, 0x0200}, /* index:595, gain:55.78125db, again:30.00000db, dgain:21.00000db, pixel gain: ON */
+	{0x1260, 0x0201}, /* index:596, gain:55.87500db, again:30.00000db, dgain:21.09375db, pixel gain: ON */
+	{0x1260, 0x0202}, /* index:597, gain:55.96875db, again:30.00000db, dgain:21.18750db, pixel gain: ON */
+	{0x1260, 0x0203}, /* index:598, gain:56.06250db, again:30.00000db, dgain:21.28125db, pixel gain: ON */
+	{0x1260, 0x0204}, /* index:599, gain:56.15625db, again:30.00000db, dgain:21.37500db, pixel gain: ON */
+	{0x1260, 0x0205}, /* index:600, gain:56.25000db, again:30.00000db, dgain:21.46875db, pixel gain: ON */
+	{0x1260, 0x0206}, /* index:601, gain:56.34375db, again:30.00000db, dgain:21.56250db, pixel gain: ON */
+	{0x1260, 0x0207}, /* index:602, gain:56.43750db, again:30.00000db, dgain:21.65625db, pixel gain: ON */
+	{0x1260, 0x0208}, /* index:603, gain:56.53125db, again:30.00000db, dgain:21.75000db, pixel gain: ON */
+	{0x1260, 0x0209}, /* index:604, gain:56.62500db, again:30.00000db, dgain:21.84375db, pixel gain: ON */
+	{0x1260, 0x020a}, /* index:605, gain:56.71875db, again:30.00000db, dgain:21.93750db, pixel gain: ON */
+	{0x1260, 0x020b}, /* index:606, gain:56.81250db, again:30.00000db, dgain:22.03125db, pixel gain: ON */
+	{0x1260, 0x020c}, /* index:607, gain:56.90625db, again:30.00000db, dgain:22.12500db, pixel gain: ON */
+	{0x1260, 0x020d}, /* index:608, gain:57.00000db, again:30.00000db, dgain:22.21875db, pixel gain: ON */
+	{0x1260, 0x020e}, /* index:609, gain:57.09375db, again:30.00000db, dgain:22.31250db, pixel gain: ON */
+	{0x1260, 0x020f}, /* index:610, gain:57.18750db, again:30.00000db, dgain:22.40625db, pixel gain: ON */
+	{0x1260, 0x0210}, /* index:611, gain:57.28125db, again:30.00000db, dgain:22.50000db, pixel gain: ON */
+	{0x1260, 0x0211}, /* index:612, gain:57.37500db, again:30.00000db, dgain:22.59375db, pixel gain: ON */
+	{0x1260, 0x0212}, /* index:613, gain:57.46875db, again:30.00000db, dgain:22.68750db, pixel gain: ON */
+	{0x1260, 0x0213}, /* index:614, gain:57.56250db, again:30.00000db, dgain:22.78125db, pixel gain: ON */
+	{0x1260, 0x0214}, /* index:615, gain:57.65625db, again:30.00000db, dgain:22.87500db, pixel gain: ON */
+	{0x1260, 0x0215}, /* index:616, gain:57.75000db, again:30.00000db, dgain:22.96875db, pixel gain: ON */
+	{0x1260, 0x0216}, /* index:617, gain:57.84375db, again:30.00000db, dgain:23.06250db, pixel gain: ON */
+	{0x1260, 0x0217}, /* index:618, gain:57.93750db, again:30.00000db, dgain:23.15625db, pixel gain: ON */
+	{0x1260, 0x0218}, /* index:619, gain:58.03125db, again:30.00000db, dgain:23.25000db, pixel gain: ON */
+	{0x1260, 0x0219}, /* index:620, gain:58.12500db, again:30.00000db, dgain:23.34375db, pixel gain: ON */
+	{0x1260, 0x021a}, /* index:621, gain:58.21875db, again:30.00000db, dgain:23.43750db, pixel gain: ON */
+	{0x1260, 0x021b}, /* index:622, gain:58.31250db, again:30.00000db, dgain:23.53125db, pixel gain: ON */
+	{0x1260, 0x021c}, /* index:623, gain:58.40625db, again:30.00000db, dgain:23.62500db, pixel gain: ON */
+	{0x1260, 0x021d}, /* index:624, gain:58.50000db, again:30.00000db, dgain:23.71875db, pixel gain: ON */
+	{0x1260, 0x021e}, /* index:625, gain:58.59375db, again:30.00000db, dgain:23.81250db, pixel gain: ON */
+	{0x1260, 0x021f}, /* index:626, gain:58.68750db, again:30.00000db, dgain:23.90625db, pixel gain: ON */
+	{0x1260, 0x0220}, /* index:627, gain:58.78125db, again:30.00000db, dgain:24.00000db, pixel gain: ON */
+	{0x1260, 0x0221}, /* index:628, gain:58.87500db, again:30.00000db, dgain:24.09375db, pixel gain: ON */
+	{0x1260, 0x0222}, /* index:629, gain:58.96875db, again:30.00000db, dgain:24.18750db, pixel gain: ON */
+	{0x1260, 0x0223}, /* index:630, gain:59.06250db, again:30.00000db, dgain:24.28125db, pixel gain: ON */
+	{0x1260, 0x0224}, /* index:631, gain:59.15625db, again:30.00000db, dgain:24.37500db, pixel gain: ON */
+	{0x1260, 0x0225}, /* index:632, gain:59.25000db, again:30.00000db, dgain:24.46875db, pixel gain: ON */
+	{0x1260, 0x0226}, /* index:633, gain:59.34375db, again:30.00000db, dgain:24.56250db, pixel gain: ON */
+	{0x1260, 0x0227}, /* index:634, gain:59.43750db, again:30.00000db, dgain:24.65625db, pixel gain: ON */
+	{0x1260, 0x0228}, /* index:635, gain:59.53125db, again:30.00000db, dgain:24.75000db, pixel gain: ON */
+	{0x1260, 0x0229}, /* index:636, gain:59.62500db, again:30.00000db, dgain:24.84375db, pixel gain: ON */
+	{0x1260, 0x022a}, /* index:637, gain:59.71875db, again:30.00000db, dgain:24.93750db, pixel gain: ON */
+	{0x1260, 0x022b}, /* index:638, gain:59.81250db, again:30.00000db, dgain:25.03125db, pixel gain: ON */
+	{0x1260, 0x022c}, /* index:639, gain:59.90625db, again:30.00000db, dgain:25.12500db, pixel gain: ON */
+	{0x1260, 0x022d}, /* index:640, gain:60.00000db, again:30.00000db, dgain:25.21875db, pixel gain: ON */
+	{0x1260, 0x022e}, /* index:641, gain:60.09375db, again:30.00000db, dgain:25.31250db, pixel gain: ON */
+	{0x1260, 0x022f}, /* index:642, gain:60.18750db, again:30.00000db, dgain:25.40625db, pixel gain: ON */
+	{0x1260, 0x0230}, /* index:643, gain:60.28125db, again:30.00000db, dgain:25.50000db, pixel gain: ON */
+	{0x1260, 0x0231}, /* index:644, gain:60.37500db, again:30.00000db, dgain:25.59375db, pixel gain: ON */
+	{0x1260, 0x0232}, /* index:645, gain:60.46875db, again:30.00000db, dgain:25.68750db, pixel gain: ON */
+	{0x1260, 0x0233}, /* index:646, gain:60.56250db, again:30.00000db, dgain:25.78125db, pixel gain: ON */
+	{0x1260, 0x0234}, /* index:647, gain:60.65625db, again:30.00000db, dgain:25.87500db, pixel gain: ON */
+	{0x1260, 0x0235}, /* index:648, gain:60.75000db, again:30.00000db, dgain:25.96875db, pixel gain: ON */
+	{0x1260, 0x0236}, /* index:649, gain:60.84375db, again:30.00000db, dgain:26.06250db, pixel gain: ON */
+	{0x1260, 0x0237}, /* index:650, gain:60.93750db, again:30.00000db, dgain:26.15625db, pixel gain: ON */
+	{0x1260, 0x0238}, /* index:651, gain:61.03125db, again:30.00000db, dgain:26.25000db, pixel gain: ON */
+	{0x1260, 0x0239}, /* index:652, gain:61.12500db, again:30.00000db, dgain:26.34375db, pixel gain: ON */
+	{0x1260, 0x023a}, /* index:653, gain:61.21875db, again:30.00000db, dgain:26.43750db, pixel gain: ON */
+	{0x1260, 0x023b}, /* index:654, gain:61.31250db, again:30.00000db, dgain:26.53125db, pixel gain: ON */
+	{0x1260, 0x023c}, /* index:655, gain:61.40625db, again:30.00000db, dgain:26.62500db, pixel gain: ON */
+	{0x1260, 0x023d}, /* index:656, gain:61.50000db, again:30.00000db, dgain:26.71875db, pixel gain: ON */
+	{0x1260, 0x023e}, /* index:657, gain:61.59375db, again:30.00000db, dgain:26.81250db, pixel gain: ON */
+	{0x1260, 0x023f}, /* index:658, gain:61.68750db, again:30.00000db, dgain:26.90625db, pixel gain: ON */
+	{0x1260, 0x0240}, /* index:659, gain:61.78125db, again:30.00000db, dgain:27.00000db, pixel gain: ON */
+	{0x1260, 0x0241}, /* index:660, gain:61.87500db, again:30.00000db, dgain:27.09375db, pixel gain: ON */
+	{0x1260, 0x0242}, /* index:661, gain:61.96875db, again:30.00000db, dgain:27.18750db, pixel gain: ON */
+	{0x1260, 0x0243}, /* index:662, gain:62.06250db, again:30.00000db, dgain:27.28125db, pixel gain: ON */
+	{0x1260, 0x0244}, /* index:663, gain:62.15625db, again:30.00000db, dgain:27.37500db, pixel gain: ON */
+	{0x1260, 0x0245}, /* index:664, gain:62.25000db, again:30.00000db, dgain:27.46875db, pixel gain: ON */
+	{0x1260, 0x0246}, /* index:665, gain:62.34375db, again:30.00000db, dgain:27.56250db, pixel gain: ON */
+	{0x1260, 0x0247}, /* index:666, gain:62.43750db, again:30.00000db, dgain:27.65625db, pixel gain: ON */
+	{0x1260, 0x0248}, /* index:667, gain:62.53125db, again:30.00000db, dgain:27.75000db, pixel gain: ON */
+	{0x1260, 0x0249}, /* index:668, gain:62.62500db, again:30.00000db, dgain:27.84375db, pixel gain: ON */
+	{0x1260, 0x024a}, /* index:669, gain:62.71875db, again:30.00000db, dgain:27.93750db, pixel gain: ON */
+	{0x1260, 0x024b}, /* index:670, gain:62.81250db, again:30.00000db, dgain:28.03125db, pixel gain: ON */
+	{0x1260, 0x024c}, /* index:671, gain:62.90625db, again:30.00000db, dgain:28.12500db, pixel gain: ON */
+	{0x1260, 0x024d}, /* index:672, gain:63.00000db, again:30.00000db, dgain:28.21875db, pixel gain: ON */
+	{0x1260, 0x024e}, /* index:673, gain:63.09375db, again:30.00000db, dgain:28.31250db, pixel gain: ON */
+	{0x1260, 0x024f}, /* index:674, gain:63.18750db, again:30.00000db, dgain:28.40625db, pixel gain: ON */
+	{0x1260, 0x0250}, /* index:675, gain:63.28125db, again:30.00000db, dgain:28.50000db, pixel gain: ON */
+	{0x1260, 0x0251}, /* index:676, gain:63.37500db, again:30.00000db, dgain:28.59375db, pixel gain: ON */
+	{0x1260, 0x0252}, /* index:677, gain:63.46875db, again:30.00000db, dgain:28.68750db, pixel gain: ON */
+	{0x1260, 0x0253}, /* index:678, gain:63.56250db, again:30.00000db, dgain:28.78125db, pixel gain: ON */
+	{0x1260, 0x0254}, /* index:679, gain:63.65625db, again:30.00000db, dgain:28.87500db, pixel gain: ON */
+	{0x1260, 0x0255}, /* index:680, gain:63.75000db, again:30.00000db, dgain:28.96875db, pixel gain: ON */
+	{0x1260, 0x0256}, /* index:681, gain:63.84375db, again:30.00000db, dgain:29.06250db, pixel gain: ON */
+	{0x1260, 0x0257}, /* index:682, gain:63.93750db, again:30.00000db, dgain:29.15625db, pixel gain: ON */
+	{0x1260, 0x0258}, /* index:683, gain:64.03125db, again:30.00000db, dgain:29.25000db, pixel gain: ON */
+	{0x1260, 0x0259}, /* index:684, gain:64.12500db, again:30.00000db, dgain:29.34375db, pixel gain: ON */
+	{0x1260, 0x025a}, /* index:685, gain:64.21875db, again:30.00000db, dgain:29.43750db, pixel gain: ON */
+	{0x1260, 0x025b}, /* index:686, gain:64.31250db, again:30.00000db, dgain:29.53125db, pixel gain: ON */
+	{0x1260, 0x025c}, /* index:687, gain:64.40625db, again:30.00000db, dgain:29.62500db, pixel gain: ON */
+	{0x1260, 0x025d}, /* index:688, gain:64.50000db, again:30.00000db, dgain:29.71875db, pixel gain: ON */
+	{0x1260, 0x025e}, /* index:689, gain:64.59375db, again:30.00000db, dgain:29.81250db, pixel gain: ON */
+	{0x1260, 0x025f}, /* index:690, gain:64.68750db, again:30.00000db, dgain:29.90625db, pixel gain: ON */
+	{0x1260, 0x0260}, /* index:691, gain:64.78125db, again:30.00000db, dgain:30.00000db, pixel gain: ON */
+};
+#endif
+
diff --git a/drivers/vin/sensors/sony_imx104/Kbuild b/drivers/vin/sensors/sony_imx104/Kbuild
index f80d31f..9810d50 100644
--- a/drivers/vin/sensors/sony_imx104/Kbuild
+++ b/drivers/vin/sensors/sony_imx104/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/02/21 - [Long Zhao] Create
 ##
-## Copyright (C) 2004-2012, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/sony_imx104/imx104.c b/drivers/vin/sensors/sony_imx104/imx104.c
index ba46910..9a1f5dd 100644
--- a/drivers/vin/sensors/sony_imx104/imx104.c
+++ b/drivers/vin/sensors/sony_imx104/imx104.c
@@ -4,14 +4,33 @@
  * History:
  *    2012/02/21 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2012, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
diff --git a/drivers/vin/sensors/sony_imx104/imx104.h b/drivers/vin/sensors/sony_imx104/imx104.h
index 7903901..6780fb4 100644
--- a/drivers/vin/sensors/sony_imx104/imx104.h
+++ b/drivers/vin/sensors/sony_imx104/imx104.h
@@ -4,15 +4,34 @@
  * History:
  *    2012/02/21 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2012, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #ifndef __IMX104_PRI_H__
 #define __IMX104_PRI_H__
 
diff --git a/drivers/vin/sensors/sony_imx104/imx104_table.c b/drivers/vin/sensors/sony_imx104/imx104_table.c
index ef1bdb7..a5ed4bd 100644
--- a/drivers/vin/sensors/sony_imx104/imx104_table.c
+++ b/drivers/vin/sensors/sony_imx104/imx104_table.c
@@ -4,14 +4,33 @@
  * History:
  *    2012/02/21 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2012, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_video_pll imx104_plls[] = {
 	{0, 37125000, 148500000},
 };
diff --git a/drivers/vin/sensors/sony_imx104/make.inc b/drivers/vin/sensors/sony_imx104/make.inc
index 650f51a..008ae64 100644
--- a/drivers/vin/sensors/sony_imx104/make.inc
+++ b/drivers/vin/sensors/sony_imx104/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/04 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_IMX104), y)
diff --git a/drivers/vin/sensors/sony_imx123/Kbuild b/drivers/vin/sensors/sony_imx123/Kbuild
index ff2f2a7..fd5ee77 100644
--- a/drivers/vin/sensors/sony_imx123/Kbuild
+++ b/drivers/vin/sensors/sony_imx123/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/08/05 - [Long Zhao] Create
 ##
-## Copyright (C) 2004-2014, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/sony_imx123/imx123.c b/drivers/vin/sensors/sony_imx123/imx123.c
index b06c76b..8606308 100644
--- a/drivers/vin/sensors/sony_imx123/imx123.c
+++ b/drivers/vin/sensors/sony_imx123/imx123.c
@@ -1,17 +1,35 @@
 /*
- * kernel/private/drivers/ambarella/vin/sensors/sony_imx123/imx123.c
+ * imx123.c
  *
  * History:
  *    2014/08/05 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
@@ -21,6 +39,7 @@
 #include <iav_utils.h>
 #include <vin_api.h>
 #include "imx123.h"
+#include "imx123_table.c"
 
 static int bus_addr = (0 << 16) | (0x34 >> 1);
 module_param(bus_addr, int, 0644);
@@ -38,9 +57,9 @@ struct imx123_priv {
 	u32 line_length;
 	u32 frame_length_lines;
 	u32 fsc, rhs1, rhs2;
+	u32 ll_mode;
 };
 
-#include "imx123_table.c"
 
 static int imx123_write_reg( struct vin_device *vdev, u32 subaddr, u32 data)
 {
@@ -133,6 +152,7 @@ static int imx123_set_vin_mode(struct vin_device *vdev, struct vin_video_format
 		imx123_config.slvds_cfg.sync_code_style = SENSOR_SYNC_STYLE_SONY_DOL;
 		/* use split width to make VIN divide the long expo lines */
 		imx123_config.hdr_cfg.split_width = IMX123_H_PERIOD;
+		imx123_config.hdr_cfg.num_splits = format->hdr_mode;
 	}
 
 	imx123_config.cap_win.x = format->def_start_x;
@@ -145,8 +165,6 @@ static int imx123_set_vin_mode(struct vin_device *vdev, struct vin_video_format
 	imx123_config.hdr_cfg.act_win.y = format->act_start_y;
 	imx123_config.hdr_cfg.act_win.width = format->act_width;
 	imx123_config.hdr_cfg.act_win.height = format->act_height;
-	imx123_config.hdr_cfg.act_win.max_width = format->max_act_width;
-	imx123_config.hdr_cfg.act_win.max_height = format->max_act_height;
 
 	imx123_config.sensor_id	= GENERIC_SENSOR;
 	imx123_config.input_format = AMBA_VIN_INPUT_FORMAT_RGB_RAW;
@@ -255,8 +273,6 @@ static int imx123_set_format(struct vin_device *vdev, struct vin_video_format *f
 	struct vin_reg_16_8 *regs;
 	int i, regs_num, rval;
 
-	imx123_init_device(vdev);
-
 	if (format->hdr_mode == AMBA_VIDEO_LINEAR_MODE || dual_gain) {
 		regs = imx123_linear_mode_regs[format->device_mode];
 		regs_num = ARRAY_SIZE(imx123_linear_mode_regs[format->device_mode]);
@@ -294,7 +310,7 @@ static int imx123_set_format(struct vin_device *vdev, struct vin_video_format *f
 	}
 
 	/* for DOL mode, set RHS registers */
-	if (format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {
+	if (format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE && !dual_gain) {
 		imx123_write_reg(vdev, IMX123_RHS1_HSB, IMX123_QXGA_2X_RHS1 >> 16);
 		imx123_write_reg(vdev, IMX123_RHS1_MSB, IMX123_QXGA_2X_RHS1 >> 8);
 		imx123_write_reg(vdev, IMX123_RHS1_LSB, IMX123_QXGA_2X_RHS1 & 0xff);
@@ -312,8 +328,9 @@ static int imx123_set_format(struct vin_device *vdev, struct vin_video_format *f
 		pinfo->rhs1 = IMX123_QXGA_3X_RHS1;
 		pinfo->rhs2 = IMX123_QXGA_3X_RHS2;
 	}
-
-	imx123_set_pll(vdev, vdev->cur_format->pll_idx);
+	vdev->cur_format->hdr_short1_offset = pinfo->rhs1;
+	vdev->cur_format->hdr_short2_offset = pinfo->rhs2;
+	pinfo->ll_mode = 0;
 
 	rval = imx123_update_hv_info(vdev);
 	if (rval < 0)
@@ -324,7 +341,7 @@ static int imx123_set_format(struct vin_device *vdev, struct vin_video_format *f
 	/* TG reset release ( Enable Streaming )*/
 	imx123_start_streaming(vdev);
 
-	/* communiate with IAV */
+	/* communicate with IAV */
 	rval = imx123_set_vin_mode(vdev, format);
 	if (rval < 0)
 		return rval;
@@ -398,8 +415,10 @@ static int imx123_set_fps( struct vin_device *vdev, int fps)
 	if (vdev->cur_format->hdr_mode == AMBA_VIDEO_LINEAR_MODE || dual_gain) {
 		v_lines = pinfo->fsc;/* FSC = VMAX */
 	} else if(vdev->cur_format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {
+		pinfo->fsc &= (~0x1);
 		v_lines = pinfo->fsc >> 1; /* FSC = VMAX * 2 */
 	} else if (vdev->cur_format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE) {
+		pinfo->fsc &= (~0x3);
 		v_lines = pinfo->fsc >> 2; /* FSC = VMAX * 4 */
 	}
 
@@ -444,28 +463,42 @@ static int imx123_set_mirror_mode(struct vin_device *vdev,
 
 	case VINDEV_MIRROR_HORRIZONTALLY_VERTICALLY:
 		readmode = IMX123_H_MIRROR | IMX123_V_FLIP;
-		if (vdev->cur_format->hdr_mode == AMBA_VIDEO_LINEAR_MODE || dual_gain)
-			bayer_pattern = VINDEV_BAYER_PATTERN_RG;
-		else
-			bayer_pattern = VINDEV_BAYER_PATTERN_GB;
+		bayer_pattern = VINDEV_BAYER_PATTERN_RG;
+		if (vdev->cur_format->hdr_mode != AMBA_VIDEO_LINEAR_MODE && !dual_gain) {
+			imx123_write_reg(vdev, IMX123_WINMODE, 0x40);
+			imx123_write_reg(vdev, IMX123_WINWV_OB, 0x0b);
+			imx123_write_reg(vdev, IMX123_WINPV_LSB, 0x01);
+		}
 		break;
 
 	case VINDEV_MIRROR_HORRIZONTALLY:
 		readmode = IMX123_H_MIRROR;
-		if (vdev->cur_format->hdr_mode == AMBA_VIDEO_LINEAR_MODE || dual_gain)
-			bayer_pattern = VINDEV_BAYER_PATTERN_RG;
-		else
-			bayer_pattern = VINDEV_BAYER_PATTERN_GB;
+		bayer_pattern = VINDEV_BAYER_PATTERN_RG;
+		if (vdev->cur_format->hdr_mode != AMBA_VIDEO_LINEAR_MODE && !dual_gain) {
+			imx123_write_reg(vdev, IMX123_WINMODE, 0x00);
+			imx123_write_reg(vdev, IMX123_WINWV_OB, 0x0c);
+			imx123_write_reg(vdev, IMX123_WINPV_LSB, 0x00);
+		}
 		break;
 
 	case VINDEV_MIRROR_VERTICALLY:
 		readmode = IMX123_V_FLIP;
 		bayer_pattern = VINDEV_BAYER_PATTERN_RG;
+		if (vdev->cur_format->hdr_mode != AMBA_VIDEO_LINEAR_MODE && !dual_gain) {
+			imx123_write_reg(vdev, IMX123_WINMODE, 0x40);
+			imx123_write_reg(vdev, IMX123_WINWV_OB, 0x0b);
+			imx123_write_reg(vdev, IMX123_WINPV_LSB, 0x01);
+		}
 		break;
 
 	case VINDEV_MIRROR_NONE:
 		readmode = 0;
 		bayer_pattern = VINDEV_BAYER_PATTERN_RG;
+		if (vdev->cur_format->hdr_mode != AMBA_VIDEO_LINEAR_MODE && !dual_gain) {
+			imx123_write_reg(vdev, IMX123_WINMODE, 0x00);
+			imx123_write_reg(vdev, IMX123_WINWV_OB, 0x0c);
+			imx123_write_reg(vdev, IMX123_WINPV_LSB, 0x00);
+		}
 		break;
 
 	default:
@@ -544,10 +577,25 @@ static int imx123_set_wdr_shutter_row_group(struct vin_device *vdev,
 	u32 fsc, rhs1, rhs2;
 	int shutter_long, shutter_short1, shutter_short2;
 	int errCode = 0;
-
+/*
 	rhs1 = pinfo->rhs1;
 	rhs2 = pinfo->rhs2;
 	fsc = pinfo->fsc;
+*/
+	fsc = pinfo->fsc;
+	if (!pinfo->ll_mode) {
+		rhs1 = pinfo->rhs1;
+		rhs2 = pinfo->rhs2;
+	} else {
+		if (vdev->cur_format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {
+			rhs1 = IMX123_LL_MODE_2X_RHS1;
+			rhs2 = 0;
+		} else {
+			rhs1 = IMX123_LL_MODE_3X_RHS1;
+			rhs2 = IMX123_LL_MODE_3X_RHS2;
+		}
+	}
+
 
 	/* long shutter */
 	shutter_long = p_shutter_gp->l;
@@ -711,25 +759,91 @@ static int imx123_wdr_shutter2row(struct vin_device *vdev,
 static int imx123_get_eis_info(struct vin_device *vdev,
 		struct vindev_eisinfo *eis_info)
 {
-	struct imx123_priv *pinfo = (struct imx123_priv *)vdev->priv;
-	struct vin_video_format *format = vdev->cur_format;
-
-	eis_info->cap_start_x = format->act_start_x;
-	eis_info->cap_start_y = format->act_start_y;
-	eis_info->cap_cap_w = format->act_width;
-	eis_info->cap_cap_h = format->act_height;
-	eis_info->source_width = format->width;
-	eis_info->source_height = format->height;
-	eis_info->current_fps = vdev->frame_rate;
-	eis_info->main_fps = format->default_fps;
-	eis_info->current_shutter_time = vdev->shutter_time;
 	eis_info->sensor_cell_width = 250;/* 2.5 um */
 	eis_info->sensor_cell_height = 250;/* 2.5 um */
 	eis_info->column_bin = 1;
 	eis_info->row_bin = 1;
+	eis_info->vb_time = vdev->cur_format->vb_time;
 
-	eis_info->vb_lines = pinfo->fsc - format->height;
-	eis_info->row_time = (u32)DIV64_CLOSEST((u64)format->line_time * 1000, 512);
+	return 0;
+}
+
+static int imx123_get_aaa_info(struct vin_device *vdev,
+	struct vindev_aaa_info *aaa_info)
+{
+	struct imx123_priv *pinfo = (struct imx123_priv *)vdev->priv;
+	if (!pinfo->ll_mode) {
+		aaa_info->sht0_max = pinfo->frame_length_lines - 14;
+		aaa_info->sht1_max = pinfo->rhs1 - 7;
+		aaa_info->sht2_max = (vdev->cur_format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE) ?
+			(pinfo->rhs2 - pinfo->rhs1 - 9) : 0;
+	} else {
+		aaa_info->sht0_max = pinfo->frame_length_lines - 14;
+		aaa_info->sht1_max = (vdev->cur_format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE) ?
+			(IMX123_LL_MODE_3X_RHS1 - 7) : (IMX123_LL_MODE_2X_RHS1 - 7);
+		aaa_info->sht2_max = (vdev->cur_format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE) ?
+			(IMX123_LL_MODE_3X_RHS2 - IMX123_LL_MODE_3X_RHS1 - 9) : 0;
+	}
+	return 0;
+}
+
+static int imx123_set_low_light_mode(struct vin_device *vdev,
+	u32 ll_mode)
+{
+	struct imx123_priv *pinfo = (struct imx123_priv *)vdev->priv;
+
+	if (vdev->cur_format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {
+		if (ll_mode) {
+			pinfo->ll_mode = 1;
+			vdev->cur_format->hdr_short1_offset = IMX123_LL_MODE_2X_RHS1;
+			imx123_write_reg(vdev, IMX123_SHS1_HSB, (IMX123_LL_MODE_2X_RHS1 - 2) >> 16);
+			imx123_write_reg(vdev, IMX123_SHS1_MSB, (IMX123_LL_MODE_2X_RHS1 - 2) >> 8);
+			imx123_write_reg(vdev, IMX123_SHS1_LSB, (IMX123_LL_MODE_2X_RHS1 - 2) & 0xFF);
+			imx123_write_reg(vdev, IMX123_RHS1_HSB, IMX123_LL_MODE_2X_RHS1 >> 16);
+			imx123_write_reg(vdev, IMX123_RHS1_MSB, IMX123_LL_MODE_2X_RHS1 >> 8);
+			imx123_write_reg(vdev, IMX123_RHS1_LSB, IMX123_LL_MODE_2X_RHS1 & 0xFF);
+		} else {
+			pinfo->ll_mode = 0;
+			vdev->cur_format->hdr_short1_offset = pinfo->rhs1;
+			imx123_write_reg(vdev, IMX123_RHS1_HSB, pinfo->rhs1 >> 16);
+			imx123_write_reg(vdev, IMX123_RHS1_MSB, pinfo->rhs1 >> 8);
+			imx123_write_reg(vdev, IMX123_RHS1_LSB, pinfo->rhs1 & 0xFF);
+		}
+	} else if (vdev->cur_format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE) {
+		if (ll_mode) {
+			pinfo->ll_mode = 1;
+			vdev->cur_format->hdr_short1_offset = IMX123_LL_MODE_3X_RHS1;
+			vdev->cur_format->hdr_short2_offset = IMX123_LL_MODE_3X_RHS2;
+			imx123_write_reg(vdev, IMX123_SHS1_HSB, (IMX123_LL_MODE_3X_RHS1 - 2) >> 16);
+			imx123_write_reg(vdev, IMX123_SHS1_MSB, (IMX123_LL_MODE_3X_RHS1 - 2) >> 8);
+			imx123_write_reg(vdev, IMX123_SHS1_LSB, (IMX123_LL_MODE_3X_RHS1 - 2) & 0xFF);
+			imx123_write_reg(vdev, IMX123_RHS1_HSB, IMX123_LL_MODE_3X_RHS1 >> 16);
+			imx123_write_reg(vdev, IMX123_RHS1_MSB, IMX123_LL_MODE_3X_RHS1 >> 8);
+			imx123_write_reg(vdev, IMX123_RHS1_LSB, IMX123_LL_MODE_3X_RHS1 & 0xFF);
+			imx123_write_reg(vdev, IMX123_SHS2_HSB, (IMX123_LL_MODE_3X_RHS2 - 2) >> 16);
+			imx123_write_reg(vdev, IMX123_SHS2_MSB, (IMX123_LL_MODE_3X_RHS2 - 2) >> 8);
+			imx123_write_reg(vdev, IMX123_SHS2_LSB, (IMX123_LL_MODE_3X_RHS2 - 2) & 0xFF);
+			imx123_write_reg(vdev, IMX123_RHS2_HSB, IMX123_LL_MODE_3X_RHS2 >> 16);
+			imx123_write_reg(vdev, IMX123_RHS2_MSB, IMX123_LL_MODE_3X_RHS2 >> 8);
+			imx123_write_reg(vdev, IMX123_RHS2_LSB, IMX123_LL_MODE_3X_RHS2 & 0xff);
+		} else {
+			pinfo->ll_mode = 0;
+			vdev->cur_format->hdr_short1_offset = pinfo->rhs1;
+			vdev->cur_format->hdr_short2_offset = pinfo->rhs2;
+			imx123_write_reg(vdev, IMX123_RHS2_HSB, pinfo->rhs2 >> 16);
+			imx123_write_reg(vdev, IMX123_RHS2_MSB, pinfo->rhs2 >> 8);
+			imx123_write_reg(vdev, IMX123_RHS2_LSB, pinfo->rhs2 & 0xff);
+			imx123_write_reg(vdev, IMX123_SHS2_HSB, (pinfo->rhs2 - 2) >> 16);
+			imx123_write_reg(vdev, IMX123_SHS2_MSB, (pinfo->rhs2 - 2) >> 8);
+			imx123_write_reg(vdev, IMX123_SHS2_LSB, (pinfo->rhs2 - 2) & 0xFF);
+			imx123_write_reg(vdev, IMX123_RHS1_HSB, pinfo->rhs1 >> 16);
+			imx123_write_reg(vdev, IMX123_RHS1_MSB, pinfo->rhs1 >> 8);
+			imx123_write_reg(vdev, IMX123_RHS1_LSB, pinfo->rhs1 & 0xFF);
+		}
+	} else {
+		vin_error("Non HDR mode can't support this API: %s!\n", __func__);
+		return -EPERM;
+	}
 
 	return 0;
 }
@@ -747,6 +861,8 @@ static struct vin_ops imx123_ops = {
 	.write_reg		= imx123_write_reg,
 	.set_hold_mode		= imx123_set_hold_mode,
 	.get_eis_info		= imx123_get_eis_info,
+	.get_aaa_info		= imx123_get_aaa_info,
+	.set_low_light_mode     = imx123_set_low_light_mode,
 
 	/* for wdr sensor */
 	.set_wdr_again_idx_gp = imx123_set_wdr_again_idx_group,
@@ -789,6 +905,9 @@ static int imx123_probe(struct i2c_client *client,
 	vdev->agc_db_min = 0x00000000;	// 0dB
 	vdev->agc_db_step = 0x00199999;	// 0.1dB
 
+	/* mode switch needs hw reset */
+	vdev->reset_for_mode_switch = true;
+
 	if (dual_gain) {
 		vdev->wdr_again_idx_min = 0;
 		vdev->wdr_again_idx_max = IMX123_DUAL_GAIN_MAX_DB;
diff --git a/drivers/vin/sensors/sony_imx123/imx123.h b/drivers/vin/sensors/sony_imx123/imx123.h
index 215a409..0159aad 100644
--- a/drivers/vin/sensors/sony_imx123/imx123.h
+++ b/drivers/vin/sensors/sony_imx123/imx123.h
@@ -1,20 +1,38 @@
 /*
- * kernel/private/drivers/ambarella/vin/sensors/sony_imx123/imx123_pri.h
+ * imx123.h
  *
  * History:
  *    2014/08/05 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
-#ifndef __IMX123_PRI_H__
-#define __IMX123_PRI_H__
+
+#ifndef __IMX123_H__
+#define __IMX123_H__
 
 #define IMX123_STANDBY    		0x3000
 #define IMX123_REGHOLD			0x3001
@@ -52,6 +70,10 @@
 #define IMX123_RHS2_MSB   		0x3032
 #define IMX123_RHS2_HSB   		0x3033
 
+#define IMX123_WINWV_OB			0x3036
+#define IMX123_WINPV_LSB			0x3038
+#define IMX123_WINPV_MSB			0x3039
+
 #define IMX123_DCKRST			0x3044
 
 #define IMX123_GAIN2_LSB    		0x30F2
@@ -66,13 +88,17 @@
 #define IMX123_1080P_BRL		(1108)
 #define IMX123_QXGA_H_PIXEL	(2048)
 #define IMX123_1080P_H_PIXEL	(1936)
-#define IMX123_H_PERIOD		(2250)
+#define IMX123_H_PERIOD		(2256)
 #define IMX123_QXGA_HBLANK	(192)
 
-#define IMX123_QXGA_2X_RHS1		(0x142)
+#define IMX123_QXGA_2X_RHS1		(0x3C2) /* max RHS1 is 0x4EA for 30fps(VMAX=2200) */
 
 #define IMX123_QXGA_3X_RHS1		(0x26C)
 #define IMX123_QXGA_3X_RHS2		(0x2C8)
 
-#endif /* __IMX123_PRI_H__ */
+#define IMX123_LL_MODE_2X_RHS1	(10)
+#define IMX123_LL_MODE_3X_RHS1	(14)
+#define IMX123_LL_MODE_3X_RHS2	(28)
+
+#endif /* __IMX123_H__ */
 
diff --git a/drivers/vin/sensors/sony_imx123/imx123_table.c b/drivers/vin/sensors/sony_imx123/imx123_table.c
index 15e1be5..d57f8c2 100644
--- a/drivers/vin/sensors/sony_imx123/imx123_table.c
+++ b/drivers/vin/sensors/sony_imx123/imx123_table.c
@@ -1,22 +1,42 @@
 /*
- * kernel/private/drivers/ambarella/vin/sensors/sony_imx123/imx123_table.c
+ * imx123_table.c
  *
  * History:
  *    2014/08/05 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_video_pll imx123_plls[] = {
 	/* for QXGA */
 	{0, 27000000, 72000000},
 	/* for 1080p */
 	{0, 27000000, 74250000},
+	/* for 3M 2X DOL */
+	{0, 37125000, 49500000},
 };
 
 static struct vin_reg_16_8 imx123_pll_regs[][6] = {
@@ -36,6 +56,14 @@ static struct vin_reg_16_8 imx123_pll_regs[][6] = {
 		{0x3170, 0x60}, /* IMX123_INCKSEL5 */
 		{0x3171, 0x16}, /* IMX123_INCKSEL6 */
 	},
+	{	/* for 3M 2X DOL */
+		{0x3061, 0xB1}, /* IMX123_INCKSEL1 */
+		{0x3062, 0x00}, /* IMX123_INCKSEL2 */
+		{0x316C, 0x20}, /* IMX123_INCKSEL3 */
+		{0x316D, 0x09}, /* IMX123_INCKSEL4 */
+		{0x3170, 0x61}, /* IMX123_INCKSEL5 */
+		{0x3171, 0x18}, /* IMX123_INCKSEL6 */
+	},
 };
 
 static struct vin_reg_16_8 imx123_linear_mode_regs[][11] = {
@@ -84,29 +112,29 @@ static struct vin_reg_16_8 imx123_dual_gain_share_regs[] = {
 };
 
 static struct vin_reg_16_8 imx123_3m_2x_regs[] = {
-	/* 2X WDR setting QXGA 30 fps */
+	/* 2X WDR setting QXGA 40 fps */
 	{0x3007, 0x00}, /* WINMODE */
-	{0x3009, 0x01}, /* DRSEL from 120fps to 60fps */
+	{0x3009, 0x00}, /* DRSEL */
 	{0x300C, 0x14}, /* WDSEL */
 	{0x3044, 0x35}, /* ODBIT */
 	{0x3046, 0x44}, /* XVSMSKCNT/XHSMSKCNT */
-	{0x30C8, 0xC0}, /* {0x30C8, 0x90},HBLANK1, Tentative */
+	{0x30C8, 0xC0}, /* HBLANK1, Tentative */
 	{0x30C9, 0x40}, /* HBLANK1, Tentative */
 	{0x30CA, 0xCD}, /* HBLANK2, Tentative */
 	{0x30CB, 0x20}, /* HBLANK2, XVSMSKCNT_INT */
-	{0x3018, 0x40}, /* VMAX_LSB */
+	{0x3018, 0x72}, /* VMAX_LSB */
 	{0x3019, 0x06}, /* VMAX_MSB */
 	{0x301A, 0x00}, /* VMAX_HSB */
-	{0x301B, 0xEE}, /* HMAX_LSB from 120fps to 60fps */
-	{0x301C, 0x02}, /* HMAX_MSB from 120fps to 60fps */
+	{0x301B, 0x77}, /* HMAX_LSB */
+	{0x301C, 0x01}, /* HMAX_MSB */
 
-	/* SHS1 7h */
-	{0x301E, 0x07}, /* SHS1_LSB */
+	/* SHS1 3Ah */
+	{0x301E, 0x3A}, /* SHS1_LSB */
 	{0x301F, 0x00}, /* SHS1_MSB */
 	{0x3020, 0x00}, /* SHS1_HSB */
-	/* SHS2 2F0h */
-	{0x3021, 0xF0}, /* SHS2_LSB */
-	{0x3022, 0x02}, /* SHS2_MSB */
+	/* SHS2 E4h */
+	{0x3021, 0xE4}, /* SHS2_LSB */
+	{0x3022, 0x00}, /* SHS2_MSB */
 	{0x3023, 0x00}, /* SHS2_HSB */
 };
 
@@ -195,20 +223,18 @@ static struct vin_video_format imx123_formats[] = {
 		.act_start_y	= 0,
 		.act_width	= 2048,
 		.act_height	= 1536,
-		.max_act_width = 2048,
-		.max_act_height = IMX123_QXGA_BRL,
 		/* sensor mode */
 		.hdr_mode = AMBA_VIDEO_2X_HDR_MODE,
 		.device_mode	= 2,
-		.pll_idx	= 0,
+		.pll_idx	= 2,
 		.width		= IMX123_QXGA_H_PIXEL,
 		.height		= IMX123_QXGA_BRL * 2 + (IMX123_QXGA_2X_RHS1 - 2),
 		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
 		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
 		.bits		= AMBA_VIDEO_BITS_12,
 		.ratio		= AMBA_VIDEO_RATIO_16_9,
-		.max_fps	= AMBA_VIDEO_FPS_25,
-		.default_fps	= AMBA_VIDEO_FPS_25,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
 		.default_agc	= 0,
 		.default_shutter_time	= AMBA_VIDEO_FPS_60,
 		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
@@ -225,8 +251,6 @@ static struct vin_video_format imx123_formats[] = {
 		.act_start_y	= 0,
 		.act_width	= 2048,
 		.act_height	= 1536,
-		.max_act_width = 2048,
-		.max_act_height = IMX123_QXGA_BRL,
 		/* sensor mode */
 		.hdr_mode = AMBA_VIDEO_3X_HDR_MODE,
 		.device_mode	= 3,
@@ -246,6 +270,56 @@ static struct vin_video_format imx123_formats[] = {
 		.hdr_short1_offset = (IMX123_QXGA_3X_RHS1 - 2) + 1, /* hdr_long_offset + 3 x VBP1 + 1 */
 		.hdr_short2_offset = (IMX123_QXGA_3X_RHS2 - 4) + 2, /* hdr_long_offset + 3 x VBP2 + 2 */
 	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_UXGA,
+		.def_start_x	= 8+(2048-1600)/2,
+		.def_start_y	= 1+12+8+(1536-1200)/2,
+		.def_width	= 1600,
+		.def_height	= 1200,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_LINEAR_MODE,
+		.device_mode	= 0,
+		.pll_idx	= 0,
+		.width		= 1600,
+		.height		= 1200,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_4_3,
+		.max_fps	= AMBA_VIDEO_FPS_60,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_UXGA,
+		.def_start_x	= 8+(2048-1600)/2,
+		.def_start_y	= (1+12+8)*2+(1536-1200),
+		.def_width	= 1600,
+		.def_height	= 1200 * 2 + (IMX123_QXGA_2X_RHS1 - 2),/* (1200 + VBP1)*2 */
+		.act_start_x	= 0,
+		.act_start_y	= 0,
+		.act_width	= 1600,
+		.act_height	= 1200,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_2X_HDR_MODE,
+		.device_mode	= 2,
+		.pll_idx	= 2,
+		.width		= IMX123_QXGA_H_PIXEL,
+		.height		= IMX123_QXGA_BRL * 2 + (IMX123_QXGA_2X_RHS1 - 2),
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+		.hdr_long_offset = 0,
+		.hdr_short1_offset = (IMX123_QXGA_2X_RHS1 - 2) + 1, /* hdr_long_offset + 2 x VBP1 + 1 */
+	},
 };
 
 static struct vin_video_format imx123_dual_gain_formats[] = {
@@ -259,8 +333,6 @@ static struct vin_video_format imx123_dual_gain_formats[] = {
 		.act_start_y	= 0,
 		.act_width	= 2048,
 		.act_height	= 1536,
-		.max_act_width = 2048,
-		.max_act_height = 1536,
 		/* sensor mode */
 		.hdr_mode = AMBA_VIDEO_2X_HDR_MODE,
 		.device_mode	= 0,
@@ -290,12 +362,10 @@ static struct vin_video_format imx123_dual_gain_formats[] = {
 		.act_start_y	= 0,
 		.act_width	= 1920,
 		.act_height	= 1080,
-		.max_act_width = 1920,
-		.max_act_height = 1080,
 		/* sensor mode */
 		.hdr_mode = AMBA_VIDEO_2X_HDR_MODE,
 		.device_mode	= 1,
-		.pll_idx	= 0,
+		.pll_idx	= 1,
 		.width		= 1920,
 		.height		= 1080*2,
 		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
diff --git a/drivers/vin/sensors/sony_imx123/make.inc b/drivers/vin/sensors/sony_imx123/make.inc
index 5c90aea..91fce7a 100644
--- a/drivers/vin/sensors/sony_imx123/make.inc
+++ b/drivers/vin/sensors/sony_imx123/make.inc
@@ -1,15 +1,32 @@
 ##
-## kernel/private/drivers/vin/sensors/sony_imx123/make.inc
+## make.inc
 ##
 ## History:
 ##    2012/06/04 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_IMX123), y)
diff --git a/drivers/vin/sensors/sony_imx124/Kbuild b/drivers/vin/sensors/sony_imx124/Kbuild
index d645276..a52e817 100644
--- a/drivers/vin/sensors/sony_imx124/Kbuild
+++ b/drivers/vin/sensors/sony_imx124/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/07/23 - [Long Zhao] Create
 ##
-## Copyright (C) 2004-2014, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/sony_imx124/imx124.c b/drivers/vin/sensors/sony_imx124/imx124.c
index e93e4e5..dce6e81 100644
--- a/drivers/vin/sensors/sony_imx124/imx124.c
+++ b/drivers/vin/sensors/sony_imx124/imx124.c
@@ -4,14 +4,33 @@
  * History:
  *    2014/07/23 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
diff --git a/drivers/vin/sensors/sony_imx124/imx124.h b/drivers/vin/sensors/sony_imx124/imx124.h
index efeec32..ceb729d 100644
--- a/drivers/vin/sensors/sony_imx124/imx124.h
+++ b/drivers/vin/sensors/sony_imx124/imx124.h
@@ -4,15 +4,34 @@
  * History:
  *    2014/07/23 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #ifndef __IMX124_PRI_H__
 #define __IMX124_PRI_H__
 
diff --git a/drivers/vin/sensors/sony_imx124/imx124_table.c b/drivers/vin/sensors/sony_imx124/imx124_table.c
index 0cc6e2c..52d6995 100644
--- a/drivers/vin/sensors/sony_imx124/imx124_table.c
+++ b/drivers/vin/sensors/sony_imx124/imx124_table.c
@@ -4,14 +4,33 @@
  * History:
  *    2014/07/23 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_video_pll imx124_plls[] = {
 	{0, 27000000, 72000000}, /* for 3M */
 	{0, 27000000, 74250000}, /* for 1080p */
diff --git a/drivers/vin/sensors/sony_imx124/make.inc b/drivers/vin/sensors/sony_imx124/make.inc
index d9940bb..f14a0ac 100644
--- a/drivers/vin/sensors/sony_imx124/make.inc
+++ b/drivers/vin/sensors/sony_imx124/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/04 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_IMX124), y)
diff --git a/drivers/vin/sensors/sony_imx136/Kbuild b/drivers/vin/sensors/sony_imx136/Kbuild
index 2c09c7a..17542c4 100644
--- a/drivers/vin/sensors/sony_imx136/Kbuild
+++ b/drivers/vin/sensors/sony_imx136/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/02/21 - [Long Zhao] Create
 ##
-## Copyright (C) 2004-2012, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/sony_imx136/imx136.c b/drivers/vin/sensors/sony_imx136/imx136.c
index 5d673a7..4429319 100644
--- a/drivers/vin/sensors/sony_imx136/imx136.c
+++ b/drivers/vin/sensors/sony_imx136/imx136.c
@@ -4,14 +4,33 @@
  * History:
  *    2012/02/21 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2012, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
diff --git a/drivers/vin/sensors/sony_imx136/imx136.h b/drivers/vin/sensors/sony_imx136/imx136.h
index e1e10f4..f5e6192 100644
--- a/drivers/vin/sensors/sony_imx136/imx136.h
+++ b/drivers/vin/sensors/sony_imx136/imx136.h
@@ -4,15 +4,34 @@
  * History:
  *    2012/02/21 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2012, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #ifndef __IMX136_PRI_H__
 #define __IMX136_PRI_H__
 
diff --git a/drivers/vin/sensors/sony_imx136/imx136_table.c b/drivers/vin/sensors/sony_imx136/imx136_table.c
index 0ab3c17..27662b4 100644
--- a/drivers/vin/sensors/sony_imx136/imx136_table.c
+++ b/drivers/vin/sensors/sony_imx136/imx136_table.c
@@ -4,14 +4,33 @@
  * History:
  *    2012/02/21 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2012, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_video_pll imx136_plls[] = {
 	{0, 37125000, 74250000},
 };
diff --git a/drivers/vin/sensors/sony_imx136/make.inc b/drivers/vin/sensors/sony_imx136/make.inc
index 4f22dd9..de79794 100644
--- a/drivers/vin/sensors/sony_imx136/make.inc
+++ b/drivers/vin/sensors/sony_imx136/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/04 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_IMX136), y)
diff --git a/drivers/vin/sensors/sony_imx136_parallel/Kbuild b/drivers/vin/sensors/sony_imx136_parallel/Kbuild
index 476adcb..d80680f 100644
--- a/drivers/vin/sensors/sony_imx136_parallel/Kbuild
+++ b/drivers/vin/sensors/sony_imx136_parallel/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/02/21 - [Long Zhao] Create
 ##
-## Copyright (C) 2004-2012, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/sony_imx136_parallel/imx136.c b/drivers/vin/sensors/sony_imx136_parallel/imx136.c
index d7a3e61..09f0376 100644
--- a/drivers/vin/sensors/sony_imx136_parallel/imx136.c
+++ b/drivers/vin/sensors/sony_imx136_parallel/imx136.c
@@ -4,14 +4,33 @@
  * History:
  *    2012/02/21 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2012, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
diff --git a/drivers/vin/sensors/sony_imx136_parallel/imx136.h b/drivers/vin/sensors/sony_imx136_parallel/imx136.h
index 406c38d..36911a8 100644
--- a/drivers/vin/sensors/sony_imx136_parallel/imx136.h
+++ b/drivers/vin/sensors/sony_imx136_parallel/imx136.h
@@ -4,15 +4,34 @@
  * History:
  *    2012/02/21 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2012, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #ifndef __IMX136_PRI_H__
 #define __IMX136_PRI_H__
 
diff --git a/drivers/vin/sensors/sony_imx136_parallel/imx136_table.c b/drivers/vin/sensors/sony_imx136_parallel/imx136_table.c
index 5a5deae..5d01be2 100644
--- a/drivers/vin/sensors/sony_imx136_parallel/imx136_table.c
+++ b/drivers/vin/sensors/sony_imx136_parallel/imx136_table.c
@@ -4,14 +4,33 @@
  * History:
  *    2012/02/21 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2012, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_video_pll imx136_plls[] = {
 	{0, 37125000, 148500000},
 };
diff --git a/drivers/vin/sensors/sony_imx136_parallel/make.inc b/drivers/vin/sensors/sony_imx136_parallel/make.inc
index 95f683d..4802d00 100644
--- a/drivers/vin/sensors/sony_imx136_parallel/make.inc
+++ b/drivers/vin/sensors/sony_imx136_parallel/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/04 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_IMX136P), y)
diff --git a/drivers/vin/sensors/sony_imx178/AmbaConfig b/drivers/vin/sensors/sony_imx178/AmbaConfig
index 5d06964..a7e8a30 100644
--- a/drivers/vin/sensors/sony_imx178/AmbaConfig
+++ b/drivers/vin/sensors/sony_imx178/AmbaConfig
@@ -4,15 +4,30 @@
 ## History:
 ##    2015/01/30 - [Long Zhao] Create
 ##
-## Copyright (C) 2004-2015, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
-## This file is produced by perl.
-##/
 
 choice
 	prompt "Interface"
diff --git a/drivers/vin/sensors/sony_imx178/Kbuild b/drivers/vin/sensors/sony_imx178/Kbuild
index d743872..d263549 100644
--- a/drivers/vin/sensors/sony_imx178/Kbuild
+++ b/drivers/vin/sensors/sony_imx178/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/02/21 - [Long Zhao] Create
 ##
-## Copyright (C) 2004-2012, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/sony_imx178/imx178.c b/drivers/vin/sensors/sony_imx178/imx178.c
index ff9e364..62e8e06 100644
--- a/drivers/vin/sensors/sony_imx178/imx178.c
+++ b/drivers/vin/sensors/sony_imx178/imx178.c
@@ -4,14 +4,33 @@
  * History:
  *    2012/02/21 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2012, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
diff --git a/drivers/vin/sensors/sony_imx178/imx178.h b/drivers/vin/sensors/sony_imx178/imx178.h
index a113e53..64d8fcd 100644
--- a/drivers/vin/sensors/sony_imx178/imx178.h
+++ b/drivers/vin/sensors/sony_imx178/imx178.h
@@ -4,15 +4,34 @@
  * History:
  *    2012/02/21 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2012, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #ifndef __IMX178_PRI_H__
 #define __IMX178_PRI_H__
 
diff --git a/drivers/vin/sensors/sony_imx178/imx178_table.c b/drivers/vin/sensors/sony_imx178/imx178_table.c
index bfe1b6c..f75ec8d 100644
--- a/drivers/vin/sensors/sony_imx178/imx178_table.c
+++ b/drivers/vin/sensors/sony_imx178/imx178_table.c
@@ -4,14 +4,33 @@
  * History:
  *    2012/02/21 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2012, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_video_pll imx178_plls[] = {
 	{0, 74250000, 74250000},
 	{0, 54054000, 54054000},
diff --git a/drivers/vin/sensors/sony_imx178/make.inc b/drivers/vin/sensors/sony_imx178/make.inc
index 87fb58b..749b927 100644
--- a/drivers/vin/sensors/sony_imx178/make.inc
+++ b/drivers/vin/sensors/sony_imx178/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/04 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_IMX178), y)
diff --git a/drivers/vin/sensors/sony_imx224/Kbuild b/drivers/vin/sensors/sony_imx224/Kbuild
index aac2382..5defb48 100644
--- a/drivers/vin/sensors/sony_imx224/Kbuild
+++ b/drivers/vin/sensors/sony_imx224/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/08/05 - [Long Zhao] Create
 ##
-## Copyright (C) 2004-2014, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/sony_imx224/imx224.c b/drivers/vin/sensors/sony_imx224/imx224.c
index d29c117..6e0e2b9 100644
--- a/drivers/vin/sensors/sony_imx224/imx224.c
+++ b/drivers/vin/sensors/sony_imx224/imx224.c
@@ -1,17 +1,35 @@
 /*
- * kernel/private/drivers/ambarella/vin/sensors/sony_imx224/imx224.c
+ * imx224.c
  *
  * History:
  *    2014/08/05 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
@@ -34,6 +52,7 @@ struct imx224_priv {
 	u32 frame_length_lines;
 	u32 line_length;
 	u32 fsc, rhs1, rhs2;
+	u8 frsel;
 };
 
 #include "imx224_table.c"
@@ -129,6 +148,7 @@ static int imx224_set_vin_mode(struct vin_device *vdev, struct vin_video_format
 		imx224_config.slvds_cfg.sync_code_style = SENSOR_SYNC_STYLE_SONY_DOL;
 		/* use split width to make VIN divide the long expo lines */
 		imx224_config.hdr_cfg.split_width = IMX224_H_PERIOD;
+		imx224_config.hdr_cfg.num_splits = format->hdr_mode;
 	}
 
 	imx224_config.cap_win.x = format->def_start_x;
@@ -141,8 +161,6 @@ static int imx224_set_vin_mode(struct vin_device *vdev, struct vin_video_format
 	imx224_config.hdr_cfg.act_win.y = format->act_start_y;
 	imx224_config.hdr_cfg.act_win.width = format->act_width;
 	imx224_config.hdr_cfg.act_win.height = format->act_height;
-	imx224_config.hdr_cfg.act_win.max_width = format->max_act_width;
-	imx224_config.hdr_cfg.act_win.max_height = format->max_act_height;
 
 	imx224_config.sensor_id	= GENERIC_SENSOR;
 	imx224_config.input_format = AMBA_VIN_INPUT_FORMAT_RGB_RAW;
@@ -239,8 +257,11 @@ static int imx224_set_format(struct vin_device *vdev, struct vin_video_format *f
 	regs = imx224_mode_regs[format->device_mode];
 	regs_num = ARRAY_SIZE(imx224_mode_regs[format->device_mode]);
 
-	for (i = 0; i < regs_num; i++)
+	for (i = 0; i < regs_num; i++) {
 		imx224_write_reg(vdev, regs[i].addr, regs[i].data);
+		if (unlikely(regs[i].addr == IMX224_FRSEL))
+			pinfo->frsel = regs[i].data;
+	}
 
 	/* for DOL mode, set RHS registers */
 	if (format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {
@@ -271,7 +292,7 @@ static int imx224_set_format(struct vin_device *vdev, struct vin_video_format *f
 	/* TG reset release ( Enable Streaming )*/
 	imx224_start_streaming(vdev);
 
-	/* communiate with IAV */
+	/* communicate with IAV */
 	rval = imx224_set_vin_mode(vdev, format);
 	if (rval < 0)
 		return rval;
@@ -288,13 +309,13 @@ static int imx224_set_shutter_row(struct vin_device *vdev, u32 row)
 
 	num_line = row;
 
-	/* FIXME: shutter width: 2 ~ Frame format(V) */
-	min_line = 2;
-	max_line = pinfo->frame_length_lines;
+	/* FIXME: shutter width: 1 ~ (Frame format(V) - 3) */
+	min_line = 1;
+	max_line = pinfo->frame_length_lines - 3;
 	num_line = clamp(num_line, min_line, max_line);
 
 	/* get the shutter sweep time */
-	blank_lines = pinfo->frame_length_lines - num_line;
+	blank_lines = pinfo->frame_length_lines - num_line - 1;
 	imx224_write_reg(vdev, IMX224_SHS1_MSB, blank_lines >> 8);
 	imx224_write_reg(vdev, IMX224_SHS1_LSB, blank_lines & 0xff);
 
@@ -344,8 +365,10 @@ static int imx224_set_fps(struct vin_device *vdev, int fps)
 	if (vdev->cur_format->hdr_mode == AMBA_VIDEO_LINEAR_MODE) {
 		v_lines = pinfo->fsc;/* FSC = VMAX */
 	} else if(vdev->cur_format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {
+		pinfo->fsc &= (~0x1);
 		v_lines = pinfo->fsc >> 1; /* FSC = VMAX * 2 */
 	} else if (vdev->cur_format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE) {
+		pinfo->fsc &= (~0x3);
 		v_lines = pinfo->fsc >> 2; /* FSC = VMAX * 4 */
 	}
 
@@ -364,22 +387,15 @@ static int imx224_set_fps(struct vin_device *vdev, int fps)
 
 static int imx224_set_agc_index(struct vin_device *vdev, int agc_idx)
 {
-	struct imx224_priv *pinfo;
-	u32 tmp;
-
-	pinfo = (struct imx224_priv *)vdev->priv;
+	struct imx224_priv *pinfo = (struct imx224_priv *)vdev->priv;
 
-	/* if gain >= 24db, enable HCG, HCG is 6db */
-	if (agc_idx > 240) {
-		imx224_read_reg(vdev, IMX224_FRSEL, &tmp);
-		tmp |= IMX224_HI_GAIN_MODE;
-		imx224_write_reg(vdev, IMX224_FRSEL, tmp);
+	/* if gain >= 30db, enable HCG, HCG is 6db */
+	if (agc_idx > 300) {
+		pinfo->frsel |= IMX224_HI_GAIN_MODE;
 		vin_debug("high gain mode\n");
 		agc_idx -= 60;
 	} else {
-		imx224_read_reg(vdev, IMX224_FRSEL, &tmp);
-		tmp &= ~IMX224_HI_GAIN_MODE;
-		imx224_write_reg(vdev, IMX224_FRSEL, tmp);
+		pinfo->frsel &= ~IMX224_HI_GAIN_MODE;
 		vin_debug("low gain mode\n");
 	}
 
@@ -388,6 +404,7 @@ static int imx224_set_agc_index(struct vin_device *vdev, int agc_idx)
 		return -EINVAL;
 	}
 
+	imx224_write_reg(vdev, IMX224_FRSEL, pinfo->frsel);
 	imx224_write_reg(vdev, IMX224_GAIN_LSB, (u8)(agc_idx & 0xFF));
 	imx224_write_reg(vdev, IMX224_GAIN_MSB, (u8)(agc_idx >> 8));
 
@@ -642,6 +659,19 @@ static int imx224_set_mirror_mode(struct vin_device *vdev,
 	return 0;
 }
 
+static int imx224_get_aaa_info(struct vin_device *vdev,
+	struct vindev_aaa_info *aaa_info)
+{
+	struct imx224_priv *pinfo = (struct imx224_priv *)vdev->priv;
+
+	aaa_info->sht0_max = pinfo->frame_length_lines - 8;
+	aaa_info->sht1_max = pinfo->rhs1 - 4;
+	aaa_info->sht2_max = (vdev->cur_format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE) ?
+		(pinfo->rhs2 - pinfo->rhs1 - 5) : 0;
+
+	return 0;
+}
+
 static struct vin_ops imx224_ops = {
 	.init_device		= imx224_init_device,
 	.set_pll			= imx224_set_pll,
@@ -652,6 +682,7 @@ static struct vin_ops imx224_ops = {
 	.set_agc_index		= imx224_set_agc_index,
 	.set_mirror_mode	= imx224_set_mirror_mode,
 	.set_hold_mode		= imx224_set_hold_mode,
+	.get_aaa_info		= imx224_get_aaa_info,
 	.read_reg			= imx224_read_reg,
 	.write_reg		= imx224_write_reg,
 
@@ -685,7 +716,7 @@ static int imx224_probe(struct i2c_client *client,
 	vdev->sub_type = VINDEV_SUBTYPE_CMOS;
 	vdev->default_mode = AMBA_VIDEO_MODE_720P;
 	vdev->frame_rate = AMBA_VIDEO_FPS_29_97;
-	vdev->agc_db_max = 0x30000000;	/* 48dB */
+	vdev->agc_db_max = 0x48000000;	/* 72dB */
 	vdev->agc_db_min = 0x00000000;	/* 0dB */
 	vdev->agc_db_step = 0x00199999;	/*0.1dB */
 	vdev->wdr_again_idx_min = 0;
diff --git a/drivers/vin/sensors/sony_imx224/imx224.h b/drivers/vin/sensors/sony_imx224/imx224.h
index 7998fc7..5d07c07 100644
--- a/drivers/vin/sensors/sony_imx224/imx224.h
+++ b/drivers/vin/sensors/sony_imx224/imx224.h
@@ -1,20 +1,38 @@
 /*
- * kernel/private/drivers/ambarella/vin/sensors/sony_imx224/imx224_pri.h
+ * imx224.h
  *
  * History:
  *    2014/08/05 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
-#ifndef __IMX224_PRI_H__
-#define __IMX224_PRI_H__
+
+#ifndef __IMX224_H__
+#define __IMX224_H__
 
 #define USE_960P_2X_30FPS
 
@@ -93,5 +111,5 @@
 #define IMX224_960P_3X_RHS1		(0x208)
 #define IMX224_960P_3X_RHS2		(0x25A)
 
-#endif /* __IMX224_PRI_H__ */
+#endif /* __IMX224_H__ */
 
diff --git a/drivers/vin/sensors/sony_imx224/imx224_table.c b/drivers/vin/sensors/sony_imx224/imx224_table.c
index 4bc9548..00e0213 100644
--- a/drivers/vin/sensors/sony_imx224/imx224_table.c
+++ b/drivers/vin/sensors/sony_imx224/imx224_table.c
@@ -1,17 +1,35 @@
 /*
- * kernel/private/drivers/ambarella/vin/sensors/sony_imx224/imx224_table.c
+ * imx224_table.c
  *
  * History:
  *    2014/08/05 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_video_pll imx224_plls[] = {
 	{0, 37125000, 148500000},
 };
@@ -255,8 +273,6 @@ static struct vin_video_format imx224_formats[] = {
 		.act_start_y	= 0,
 		.act_width	= 1280,
 		.act_height	= 960,
-		.max_act_width = 1280,
-		.max_act_height = IMX224_QVGA_BRL,
 		/* sensor mode */
 		.hdr_mode = AMBA_VIDEO_2X_HDR_MODE,
 		.device_mode	= 3,
@@ -289,8 +305,6 @@ static struct vin_video_format imx224_formats[] = {
 		.act_start_y	= 0,
 		.act_width	= 1280,
 		.act_height	= 960,
-		.max_act_width = 1280,
-		.max_act_height = IMX224_QVGA_BRL,
 		/* sensor mode */
 		.hdr_mode = AMBA_VIDEO_3X_HDR_MODE,
 		.device_mode	= 4,
@@ -317,6 +331,7 @@ static struct vin_reg_16_8 imx224_share_regs[] = {
 	{0x300F, 0x00},
 	{0x3012, 0x2C},
 	{0x3013, 0x01},
+	{0x3016, 0x09},
 	{0x301D, 0xC2},
 	{0x3070, 0x02},
 	{0x3071, 0x01},
@@ -326,6 +341,7 @@ static struct vin_reg_16_8 imx224_share_regs[] = {
 	{0x30B3, 0xFF},
 	{0x30B4, 0x01},
 	{0x30B5, 0x42},
+	{0x30B8, 0x10},
 	{0x30C2, 0x01},
 
 	/* chip ID = 03h, do not change */
@@ -337,8 +353,6 @@ static struct vin_reg_16_8 imx224_share_regs[] = {
 	{0x3114, 0x10},
 	{0x3115, 0x42},
 	{0x3128, 0x1E},
-	{0x31E9, 0x53},
-	{0x31EA, 0x0A},
 	{0x31ED, 0x38},
 
 	/* chip ID = 04h, do not change */
@@ -354,12 +368,9 @@ static struct vin_reg_16_8 imx224_share_regs[] = {
 	{0x329A, 0x12},
 	{0x329B, 0xF1},
 	{0x329C, 0x0C},
-
-	/* chip ID = 05h, do not change */
-	{0x335A, 0x33},
 };
 
 /* Gain table */
-/*0.0 dB - 48.0 dB /0.1 dB step */
-#define IMX224_GAIN_MAX_DB  480
+/*0.0 dB - 72.0 dB /0.1 dB step */
+#define IMX224_GAIN_MAX_DB  720
 
diff --git a/drivers/vin/sensors/sony_imx224/make.inc b/drivers/vin/sensors/sony_imx224/make.inc
index 83ed84c..947490e 100644
--- a/drivers/vin/sensors/sony_imx224/make.inc
+++ b/drivers/vin/sensors/sony_imx224/make.inc
@@ -1,15 +1,32 @@
 ##
-## kernel/private/drivers/vin/sensors/sony_imx224/make.inc
+## make.inc
 ##
 ## History:
 ##    2012/06/04 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_IMX224), y)
diff --git a/drivers/vin/sensors/sony_imx224_mipi/Kbuild b/drivers/vin/sensors/sony_imx224_mipi/Kbuild
index 18574e7..3123d92 100644
--- a/drivers/vin/sensors/sony_imx224_mipi/Kbuild
+++ b/drivers/vin/sensors/sony_imx224_mipi/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/08/05 - [Long Zhao] Create
 ##
-## Copyright (C) 2004-2014, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/sony_imx224_mipi/imx224.c b/drivers/vin/sensors/sony_imx224_mipi/imx224.c
index fc6a1a0..fe7c0f7 100644
--- a/drivers/vin/sensors/sony_imx224_mipi/imx224.c
+++ b/drivers/vin/sensors/sony_imx224_mipi/imx224.c
@@ -1,17 +1,35 @@
 /*
- * kernel/private/drivers/ambarella/vin/sensors/sony_imx224/imx224.c
+ * imx224.c
  *
  * History:
  *    2014/08/05 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
@@ -26,6 +44,10 @@ static int bus_addr = (0 << 16) | (0x34 >> 1);
 module_param(bus_addr, int, 0644);
 MODULE_PARM_DESC(bus_addr, " bus and addr: bit16~bit31: bus, bit0~bit15: addr");
 
+static int lane = 4;
+module_param(lane, int, 0644);
+MODULE_PARM_DESC(lane, "Set MIPI lane number 2:2 lane 4:4 lane");
+
 struct imx224_priv {
 	void *control_data;
 	struct vindev_wdr_gp_s wdr_again_gp;
@@ -34,6 +56,7 @@ struct imx224_priv {
 	u32 frame_length_lines;
 	u32 line_length;
 	u32 fsc, rhs1, rhs2;
+	u8 frsel;
 };
 
 #include "imx224_table.c"
@@ -121,7 +144,7 @@ static int imx224_set_vin_mode(struct vin_device *vdev, struct vin_video_format
 	imx224_config.interface_type = SENSOR_MIPI;
 	imx224_config.sync_mode = SENSOR_SYNC_MODE_MASTER;
 
-	imx224_config.mipi_cfg.lane_number = SENSOR_4_LANE;
+	imx224_config.mipi_cfg.lane_number = (lane == 4) ? SENSOR_4_LANE : SENSOR_2_LANE;
 
 	imx224_config.cap_win.x = format->def_start_x;
 	imx224_config.cap_win.y = format->def_start_y;
@@ -133,8 +156,6 @@ static int imx224_set_vin_mode(struct vin_device *vdev, struct vin_video_format
 	imx224_config.hdr_cfg.act_win.y = format->act_start_y;
 	imx224_config.hdr_cfg.act_win.width = format->act_width;
 	imx224_config.hdr_cfg.act_win.height = format->act_height;
-	imx224_config.hdr_cfg.act_win.max_width = format->max_act_width;
-	imx224_config.hdr_cfg.act_win.max_height = format->max_act_height;
 
 	imx224_config.sensor_id	= GENERIC_SENSOR;
 	imx224_config.input_format = AMBA_VIN_INPUT_FORMAT_RGB_RAW;
@@ -228,11 +249,29 @@ static int imx224_set_format(struct vin_device *vdev, struct vin_video_format *f
 	struct vin_reg_16_8 *regs;
 	int i, regs_num, rval;
 
-	regs = imx224_mode_regs[format->device_mode];
-	regs_num = ARRAY_SIZE(imx224_mode_regs[format->device_mode]);
+	switch(lane) {
+	case 4:
+		regs = imx224_mode_regs[format->device_mode];
+		regs_num = ARRAY_SIZE(imx224_mode_regs[format->device_mode]);
+		vin_info("4 lane mode\n");
+		break;
+	case 2:
+		regs = imx224_2lane_mode_regs[format->device_mode];
+		regs_num = ARRAY_SIZE(imx224_2lane_mode_regs[format->device_mode]);
+		vin_info("2 lane mode\n");
+		break;
+	default:
+		regs = NULL;
+		regs_num = 0;
+		vin_error("imx224 can only support 2 or 4 lane mipi\n");
+		break;
+	}
 
-	for (i = 0; i < regs_num; i++)
+	for (i = 0; i < regs_num; i++) {
 		imx224_write_reg(vdev, regs[i].addr, regs[i].data);
+		if (unlikely(regs[i].addr == IMX224_FRSEL))
+			pinfo->frsel = regs[i].data;
+	}
 
 	/* for DOL mode, set RHS registers */
 	if (format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {
@@ -260,7 +299,7 @@ static int imx224_set_format(struct vin_device *vdev, struct vin_video_format *f
 
 	imx224_get_line_time(vdev);
 
-	/* communiate with IAV */
+	/* communicate with IAV */
 	rval = imx224_set_vin_mode(vdev, format);
 	if (rval < 0)
 		return rval;
@@ -280,13 +319,13 @@ static int imx224_set_shutter_row(struct vin_device *vdev, u32 row)
 
 	num_line = row;
 
-	/* FIXME: shutter width: 2 ~ Frame format(V) */
-	min_line = 2;
-	max_line = pinfo->frame_length_lines;
+	/* FIXME: shutter width: 1 ~ (Frame format(V) - 3) */
+	min_line = 1;
+	max_line = pinfo->frame_length_lines - 3;
 	num_line = clamp(num_line, min_line, max_line);
 
 	/* get the shutter sweep time */
-	blank_lines = pinfo->frame_length_lines - num_line;
+	blank_lines = pinfo->frame_length_lines - num_line - 1;
 	imx224_write_reg(vdev, IMX224_SHS1_MSB, blank_lines >> 8);
 	imx224_write_reg(vdev, IMX224_SHS1_LSB, blank_lines & 0xff);
 
@@ -336,8 +375,10 @@ static int imx224_set_fps( struct vin_device *vdev, int fps)
 	if (vdev->cur_format->hdr_mode == AMBA_VIDEO_LINEAR_MODE) {
 		v_lines = pinfo->fsc;/* FSC = VMAX */
 	} else if(vdev->cur_format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {
+		pinfo->fsc &= (~0x1);
 		v_lines = pinfo->fsc >> 1; /* FSC = VMAX * 2 */
 	} else if (vdev->cur_format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE) {
+		pinfo->fsc &= (~0x3);
 		v_lines = pinfo->fsc >> 2; /* FSC = VMAX * 4 */
 	}
 
@@ -356,22 +397,15 @@ static int imx224_set_fps( struct vin_device *vdev, int fps)
 
 static int imx224_set_agc_index(struct vin_device *vdev, int agc_idx)
 {
-	struct imx224_priv *pinfo;
-	u32 tmp;
-
-	pinfo = (struct imx224_priv *)vdev->priv;
+	struct imx224_priv *pinfo = (struct imx224_priv *)vdev->priv;
 
-	/* if gain >= 24db, enable HCG, HCG is 6db */
-	if (agc_idx > 240) {
-		imx224_read_reg(vdev, IMX224_FRSEL, &tmp);
-		tmp |= IMX224_HI_GAIN_MODE;
-		imx224_write_reg(vdev, IMX224_FRSEL, tmp);
+	/* if gain >= 30db, enable HCG, HCG is 6db */
+	if (agc_idx > 300) {
+		pinfo->frsel |= IMX224_HI_GAIN_MODE;
 		vin_debug("high gain mode\n");
 		agc_idx -= 60;
 	} else {
-		imx224_read_reg(vdev, IMX224_FRSEL, &tmp);
-		tmp &= ~IMX224_HI_GAIN_MODE;
-		imx224_write_reg(vdev, IMX224_FRSEL, tmp);
+		pinfo->frsel &= ~IMX224_HI_GAIN_MODE;
 		vin_debug("low gain mode\n");
 	}
 
@@ -380,6 +414,7 @@ static int imx224_set_agc_index(struct vin_device *vdev, int agc_idx)
 		return -EINVAL;
 	}
 
+	imx224_write_reg(vdev, IMX224_FRSEL, pinfo->frsel);
 	imx224_write_reg(vdev, IMX224_GAIN_LSB, (u8)(agc_idx & 0xFF));
 	imx224_write_reg(vdev, IMX224_GAIN_MSB, (u8)(agc_idx >> 8));
 
@@ -634,6 +669,19 @@ static int imx224_set_mirror_mode(struct vin_device *vdev,
 	return 0;
 }
 
+static int imx224_get_aaa_info(struct vin_device *vdev,
+	struct vindev_aaa_info *aaa_info)
+{
+	struct imx224_priv *pinfo = (struct imx224_priv *)vdev->priv;
+
+	aaa_info->sht0_max = pinfo->frame_length_lines - 8;
+	aaa_info->sht1_max = pinfo->rhs1 - 4;
+	aaa_info->sht2_max = (vdev->cur_format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE) ?
+		(pinfo->rhs2 - pinfo->rhs1 - 5) : 0;
+
+	return 0;
+}
+
 static struct vin_ops imx224_ops = {
 	.init_device		= imx224_init_device,
 	.set_pll			= imx224_set_pll,
@@ -644,6 +692,7 @@ static struct vin_ops imx224_ops = {
 	.set_agc_index		= imx224_set_agc_index,
 	.set_mirror_mode	= imx224_set_mirror_mode,
 	.set_hold_mode		= imx224_set_hold_mode,
+	.get_aaa_info		= imx224_get_aaa_info,
 	.read_reg			= imx224_read_reg,
 	.write_reg		= imx224_write_reg,
 
@@ -665,6 +714,8 @@ static int imx224_probe(struct i2c_client *client,
 	int rval = 0;
 	struct vin_device *vdev;
 	struct imx224_priv *imx224;
+	struct vin_video_format *formats;
+	u32 num_formats;
 
 	vdev = ambarella_vin_create_device(client->name,
 		SENSOR_IMX224, sizeof(struct imx224_priv));
@@ -677,7 +728,7 @@ static int imx224_probe(struct i2c_client *client,
 	vdev->sub_type = VINDEV_SUBTYPE_CMOS;
 	vdev->default_mode = AMBA_VIDEO_MODE_720P;
 	vdev->frame_rate = AMBA_VIDEO_FPS_29_97;
-	vdev->agc_db_max = 0x30000000;	/* 48dB */
+	vdev->agc_db_max = 0x48000000;	/* 72dB */
 	vdev->agc_db_min = 0x00000000;	/* 0dB */
 	vdev->agc_db_step = 0x00199999;	/*0.1dB */
 	vdev->wdr_again_idx_min = 0;
@@ -688,13 +739,28 @@ static int imx224_probe(struct i2c_client *client,
 	imx224 = (struct imx224_priv *)vdev->priv;
 	imx224->control_data = client;
 
+	switch(lane) {
+	case 4:
+		formats = imx224_formats;
+		num_formats = ARRAY_SIZE(imx224_formats);
+		break;
+	case 2:
+		formats = imx224_2lane_formats;
+		num_formats = ARRAY_SIZE(imx224_2lane_formats);
+		break;
+	default:
+		vin_error("imx224 can only support 2 or 4 lane mipi\n");
+		rval = -EINVAL;
+		goto imx224_probe_err;
+	}
+
 	rval = ambarella_vin_register_device(vdev, &imx224_ops,
-		imx224_formats, ARRAY_SIZE(imx224_formats),
+		formats, num_formats,
 		imx224_plls, ARRAY_SIZE(imx224_plls));
 	if (rval < 0)
 		goto imx224_probe_err;
 
-	vin_info("IMX224 init(4-lane mipi)\n");
+	vin_info("IMX224 init(%d-lane mipi)\n", lane);
 
 	return 0;
 
diff --git a/drivers/vin/sensors/sony_imx224_mipi/imx224.h b/drivers/vin/sensors/sony_imx224_mipi/imx224.h
index b5ac99c..f688337 100644
--- a/drivers/vin/sensors/sony_imx224_mipi/imx224.h
+++ b/drivers/vin/sensors/sony_imx224_mipi/imx224.h
@@ -1,20 +1,38 @@
 /*
- * kernel/private/drivers/ambarella/vin/sensors/sony_imx224/imx224_pri.h
+ * imx224.h
  *
  * History:
  *    2014/08/05 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
-#ifndef __IMX224_PRI_H__
-#define __IMX224_PRI_H__
+
+#ifndef __IMX224_H__
+#define __IMX224_H__
 
 #define IMX224_STANDBY			0x3000
 #define IMX224_REGHOLD			0x3001
@@ -87,5 +105,5 @@
 #define IMX224_960P_3X_RHS1		(0x208)
 #define IMX224_960P_3X_RHS2		(0x25A)
 
-#endif /* __IMX224_PRI_H__ */
+#endif /* __IMX224_H__ */
 
diff --git a/drivers/vin/sensors/sony_imx224_mipi/imx224_table.c b/drivers/vin/sensors/sony_imx224_mipi/imx224_table.c
index 705dcd2..515b613 100644
--- a/drivers/vin/sensors/sony_imx224_mipi/imx224_table.c
+++ b/drivers/vin/sensors/sony_imx224_mipi/imx224_table.c
@@ -1,17 +1,35 @@
 /*
- * kernel/private/drivers/ambarella/vin/sensors/sony_imx224/imx224_table.c
+ * imx224_table.c
  *
  * History:
  *    2014/08/05 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_video_pll imx224_plls[] = {
 	{0, 37125000, 148500000},
 };
@@ -25,7 +43,7 @@ static struct vin_reg_16_8 imx224_pll_regs[][4] = {
 	},
 };
 
-static struct vin_reg_16_8 imx224_mode_regs[][41] = {
+static struct vin_reg_16_8 imx224_mode_regs[][44] = {
 	{	/* Quad VGAp30 12bits */
 		{0x3005, 0x01}, /* ADBIT */
 		{0x3006, 0x00}, /* MODE */
@@ -55,6 +73,11 @@ static struct vin_reg_16_8 imx224_mode_regs[][41] = {
 		{0x3388, 0x37}, /* TCLKZERO */
 		{0x3389, 0x1F}, /* TLPX */
 
+		{0x3380, 0x20}, /* INCK_FREQ1_LSB */
+		{0x3381, 0x25}, /* INCK_FREQ1_MSB */
+		{0x338D, 0xB4}, /* INCK_FREQ2_LSB */
+		{0x338E, 0x01}, /* INCK_FREQ2_MSB */
+
 		/* DOL related */
 		{0x300C, 0x00}, /* IMX224_WDMODE */
 		{0x3020, 0x00}, /* IMX224_SHS1_LSB */
@@ -70,7 +93,6 @@ static struct vin_reg_16_8 imx224_mode_regs[][41] = {
 		{0x3357, 0xD1}, /* IMX224_PIC_SIZE_LSB */
 		{0x3358, 0x03}, /* IMX224_PIC_SIZE_MSB */
 		{0x3043, 0x01}, /* IMX224_DOL_PAT1 */
-		{0x310A, 0x00}, /* IMX224_DOL_PAT2 */
 		{0x3109, 0x00}, /* IMX224_XVSCNT_INT */
 	},
 	{	/* HD720p30 12bits */
@@ -102,6 +124,11 @@ static struct vin_reg_16_8 imx224_mode_regs[][41] = {
 		{0x3388, 0x37}, /* TCLKZERO */
 		{0x3389, 0x1F}, /* TLPX */
 
+		{0x3380, 0x20}, /* INCK_FREQ1_LSB */
+		{0x3381, 0x25}, /* INCK_FREQ1_MSB */
+		{0x338D, 0xB4}, /* INCK_FREQ2_LSB */
+		{0x338E, 0x01}, /* INCK_FREQ2_MSB */
+
 		/* DOL related */
 		{0x300C, 0x00}, /* IMX224_WDMODE */
 		{0x3020, 0x00}, /* IMX224_SHS1_LSB */
@@ -117,7 +144,6 @@ static struct vin_reg_16_8 imx224_mode_regs[][41] = {
 		{0x3357, 0xD9}, /* IMX224_PIC_SIZE_LSB */
 		{0x3358, 0x02}, /* IMX224_PIC_SIZE_MSB */
 		{0x3043, 0x01}, /* IMX224_DOL_PAT1 */
-		{0x310A, 0x00}, /* IMX224_DOL_PAT2 */
 		{0x3109, 0x00}, /* IMX224_XVSCNT_INT */
 	},
 	{	/* 2x DOL Quad VGAp30 12bits */
@@ -129,7 +155,7 @@ static struct vin_reg_16_8 imx224_mode_regs[][41] = {
 		{0x3019, 0x04}, /* VMAX_MSB */
 		{0x301B, 0xCA}, /* HMAX_LSB */
 		{0x301C, 0x08}, /* HMAX_MSB */
-		{0x3044, 0xD1}, /* ODBIT_OPORTSEL */
+		{0x3044, 0xE1}, /* ODBIT_OPORTSEL */
 		{0x300A, 0xF0}, /* BLKLEVEL_LSB */
 		{0x300B, 0x00}, /* BLKLEVEL_MSB */
 
@@ -140,7 +166,7 @@ static struct vin_reg_16_8 imx224_mode_regs[][41] = {
 		{0x336C, 0x1F}, /* TCLKPRE */
 		{0x337F, 0x03}, /* LANE_MODE */
 
-		{0x3382, 0x57}, /* TCLKPOST */
+		{0x3382, 0x5F}, /* TCLKPOST */
 		{0x3383, 0x17}, /* THSPREPARE */
 		{0x3384, 0x37}, /* THSZERO */
 		{0x3385, 0x17}, /* THSTRAIL */
@@ -149,6 +175,11 @@ static struct vin_reg_16_8 imx224_mode_regs[][41] = {
 		{0x3388, 0x4F}, /* TCLKZERO */
 		{0x3389, 0x27}, /* TLPX */
 
+		{0x3380, 0x20}, /* INCK_FREQ1_LSB */
+		{0x3381, 0x25}, /* INCK_FREQ1_MSB */
+		{0x338D, 0xB4}, /* INCK_FREQ2_LSB */
+		{0x338E, 0x01}, /* INCK_FREQ2_MSB */
+
 		/* DOL related */
 		{0x300C, 0x11}, /* IMX224_WDMODE */
 		{0x3020, 0x04}, /* IMX224_SHS1_LSB */
@@ -161,19 +192,93 @@ static struct vin_reg_16_8 imx224_mode_regs[][41] = {
 		{0x3027, 0x00}, /* IMX224_SHS3_MSB */
 		{0x3028, 0x00}, /* IMX224_SHS3_HSB */
 		{0x3354, 0x00}, /* IMX224_NULL0_SIZE */
-		{0x3357, 0x64}, /* IMX224_PIC_SIZE_LSB */
+		{0x3357, 0x6C}, /* IMX224_PIC_SIZE_LSB */
 		{0x3358, 0x08}, /* IMX224_PIC_SIZE_MSB */
 		{0x3043, 0x05}, /* IMX224_DOL_PAT1 */
-		{0x310A, 0x00}, /* IMX224_DOL_PAT2 */
 		{0x3109, 0x01}, /* IMX224_XVSCNT_INT */
 	},
 };
 
+static struct vin_reg_16_8 imx224_2lane_mode_regs[][31] = {
+	{	/* Quad VGAp30 12bits */
+		{0x3005, 0x01}, /* ADBIT */
+		{0x3006, 0x00}, /* MODE */
+		{0x3007, 0x00}, /* WINMODE */
+		{0x3009, 0x02}, /* FRSEL */
+		{0x3018, 0x4C}, /* VMAX_LSB */
+		{0x3019, 0x04}, /* VMAX_MSB */
+		{0x301B, 0x94}, /* HMAX_LSB */
+		{0x301C, 0x11}, /* HMAX_MSB */
+		{0x3044, 0x01}, /* ODBIT_OPORTSEL */
+		{0x300A, 0xF0}, /* BLKLEVEL_LSB */
+		{0x300B, 0x00}, /* BLKLEVEL_MSB */
+
+		{0x3344, 0x10}, /* REPETITION */
+		{0x3346, 0x01}, /* LANE_NUM */
+		{0x3353, 0x0E}, /* OB_SIZE_V */
+		{0x3357, 0xD1}, /* IMX224_PIC_SIZE_LSB */
+		{0x3358, 0x03}, /* IMX224_PIC_SIZE_MSB */
+		{0x336B, 0x37}, /* THSEXIT */
+		{0x336C, 0x1F}, /* TCLKPRE */
+		{0x337F, 0x01}, /* LANE_MODE */
+
+		{0x3382, 0x5F}, /* TCLKPOST */
+		{0x3383, 0x17}, /* THSPREPARE */
+		{0x3384, 0x37}, /* THSZERO */
+		{0x3385, 0x17}, /* THSTRAIL */
+		{0x3386, 0x17}, /* TCLKTRAIL */
+		{0x3387, 0x17}, /* TCLKPREPARE */
+		{0x3388, 0x4F}, /* TCLKZERO */
+		{0x3389, 0x27}, /* TLPX */
+
+		{0x3380, 0x20}, /* INCK_FREQ1_LSB */
+		{0x3381, 0x25}, /* INCK_FREQ1_MSB */
+		{0x338D, 0xB4}, /* INCK_FREQ2_LSB */
+		{0x338E, 0x01}, /* INCK_FREQ2_MSB */
+	},
+	{	/* HD720p30 12bits */
+		{0x3005, 0x01}, /* ADBIT */
+		{0x3006, 0x00}, /* MODE */
+		{0x3007, 0x10}, /* WINMODE */
+		{0x3009, 0x02}, /* FRSEL */
+		{0x3018, 0xEE}, /* VMAX_LSB */
+		{0x3019, 0x02}, /* VMAX_MSB */
+		{0x301B, 0xC8}, /* HMAX_LSB */
+		{0x301C, 0x19}, /* HMAX_MSB */
+		{0x3044, 0x01}, /* ODBIT_OPORTSEL */
+		{0x3357, 0xD9}, /* IMX224_PIC_SIZE_LSB */
+		{0x3358, 0x02}, /* IMX224_PIC_SIZE_MSB */
+		{0x300A, 0xF0}, /* BLKLEVEL_LSB */
+		{0x300B, 0x00}, /* BLKLEVEL_MSB */
+
+		{0x3344, 0x10}, /* REPETITION */
+		{0x3346, 0x01}, /* LANE_NUM */
+		{0x3353, 0x04}, /* OB_SIZE_V */
+		{0x336B, 0x37}, /* THSEXIT */
+		{0x336C, 0x1F}, /* TCLKPRE */
+		{0x337F, 0x01}, /* LANE_MODE */
+
+		{0x3382, 0x5F}, /* TCLKPOST */
+		{0x3383, 0x17}, /* THSPREPARE */
+		{0x3384, 0x37}, /* THSZERO */
+		{0x3385, 0x17}, /* THSTRAIL */
+		{0x3386, 0x17}, /* TCLKTRAIL */
+		{0x3387, 0x17}, /* TCLKPREPARE */
+		{0x3388, 0x4F}, /* TCLKZERO */
+		{0x3389, 0x27}, /* TLPX */
+
+		{0x3380, 0x20}, /* INCK_FREQ1_LSB */
+		{0x3381, 0x25}, /* INCK_FREQ1_MSB */
+		{0x338D, 0xB4}, /* INCK_FREQ2_LSB */
+		{0x338E, 0x01}, /* INCK_FREQ2_MSB */
+	},
+};
+
 static struct vin_video_format imx224_formats[] = {
 	{
 		.video_mode	= AMBA_VIDEO_MODE_1280_960,
 		.def_start_x	= 4+4+8,
-		.def_start_y	= 1+1+14+8,
+		.def_start_y	= 8,
 		.def_width	= 1280,
 		.def_height	= 960,
 		/* sensor mode */
@@ -195,7 +300,7 @@ static struct vin_video_format imx224_formats[] = {
 	{
 		.video_mode	= AMBA_VIDEO_MODE_720P,
 		.def_start_x	= 4+4+8,
-		.def_start_y	= 1+1+4+4,
+		.def_start_y	= 4,
 		.def_width	= 1280,
 		.def_height	= 720,
 		/* sensor mode */
@@ -217,15 +322,13 @@ static struct vin_video_format imx224_formats[] = {
 	{
 		.video_mode	= AMBA_VIDEO_MODE_1280_960,
 		.def_start_x	= 4+4+8,
-		.def_start_y	= 1+(1+1+14+8) * 2, /* skip 1 embedded data line */
+		.def_start_y	= (9+8)*2, /* FIXME: there are 9 OB lines for long-expo frame */
 		.def_width	= 1280,
 		.def_height	= 960 * 2 + (IMX224_960P_2X_RHS1 - 1), /* (960 + VBP1)*2 */
 		.act_start_x	= 0,
 		.act_start_y	= 0,
 		.act_width	= 1280,
 		.act_height	= 960,
-		.max_act_width = 1280,
-		.max_act_height = IMX224_QVGA_BRL,
 		/* sensor mode */
 		.hdr_mode = AMBA_VIDEO_2X_HDR_MODE,
 		.device_mode	= 2,
@@ -246,6 +349,53 @@ static struct vin_video_format imx224_formats[] = {
 	},
 };
 
+static struct vin_video_format imx224_2lane_formats[] = {
+	{
+		.video_mode	= AMBA_VIDEO_MODE_1280_960,
+		.def_start_x	= 4+4+8,
+		.def_start_y	= 8,
+		.def_width	= 1280,
+		.def_height	= 960,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_LINEAR_MODE,
+		.device_mode	= 0,
+		.pll_idx	= 0,
+		.width		= 1280,
+		.height		= 960,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_4_3,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_30,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_720P,
+		.def_start_x	= 4+4+8,
+		.def_start_y	= 4,
+		.def_width	= 1280,
+		.def_height	= 720,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_LINEAR_MODE,
+		.device_mode	= 1,
+		.pll_idx	= 0,
+		.width		= 1280,
+		.height		= 720,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_30,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+	},
+};
+
 static struct vin_reg_16_8 imx224_share_regs[] = {
 	/* chip ID = 02h, do not change */
 	{0x300F, 0x00},
@@ -301,6 +451,6 @@ static struct vin_reg_16_8 imx224_share_regs[] = {
 };
 
 /* Gain table */
-/*0.0 dB - 48.0 dB /0.1 dB step */
-#define IMX224_GAIN_MAX_DB  480
+/*0.0 dB - 72.0 dB /0.1 dB step */
+#define IMX224_GAIN_MAX_DB  720
 
diff --git a/drivers/vin/sensors/sony_imx224_mipi/make.inc b/drivers/vin/sensors/sony_imx224_mipi/make.inc
index a6b849c..88aff87 100644
--- a/drivers/vin/sensors/sony_imx224_mipi/make.inc
+++ b/drivers/vin/sensors/sony_imx224_mipi/make.inc
@@ -1,15 +1,32 @@
 ##
-## kernel/private/drivers/vin/sensors/sony_imx224_mipi/make.inc
+## make.inc
 ##
 ## History:
 ##    2012/06/04 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_IMX224_MIPI), y)
diff --git a/drivers/vin/sensors/sony_imx290/Kbuild b/drivers/vin/sensors/sony_imx290/Kbuild
index 92fb4f5..f734a44 100644
--- a/drivers/vin/sensors/sony_imx290/Kbuild
+++ b/drivers/vin/sensors/sony_imx290/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/12/05 - [Long Zhao] Create
 ##
-## Copyright (C) 2004-2014, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/sony_imx290/imx290.c b/drivers/vin/sensors/sony_imx290/imx290.c
index 5cf925c..1866712 100644
--- a/drivers/vin/sensors/sony_imx290/imx290.c
+++ b/drivers/vin/sensors/sony_imx290/imx290.c
@@ -1,17 +1,35 @@
 /*
- * kernel/private/drivers/ambarella/vin/sensors/sony_imx290/imx290.c
+ * imx290.c
  *
  * History:
  *    2015/03/23 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2015, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
@@ -21,6 +39,7 @@
 #include <iav_utils.h>
 #include <vin_api.h>
 #include "imx290.h"
+#include "imx290_table.c"
 
 static int bus_addr = (0 << 16) | (0x34 >> 1);
 module_param(bus_addr, int, 0644);
@@ -34,10 +53,10 @@ struct imx290_priv {
 	u32 frame_length_lines;
 	u32 line_length;
 	u32 fsc, rhs1, rhs2;
+	u32 ll_mode;
+	u8 frsel;
 };
 
-#include "imx290_table.c"
-
 static int imx290_write_reg(struct vin_device *vdev, u32 subaddr, u32 data)
 {
 	int rval;
@@ -82,7 +101,7 @@ static int imx290_read_reg(struct vin_device *vdev, u32 subaddr, u32 *data)
 	imx290 = (struct imx290_priv *)vdev->priv;
 	client = imx290->control_data;
 
-	pbuf0[0] = (subaddr &0xff00) >> 8;
+	pbuf0[0] = (subaddr & 0xff00) >> 8;
 	pbuf0[1] = subaddr & 0xff;
 
 	msgs[0].len = 2;
@@ -96,7 +115,7 @@ static int imx290_read_reg(struct vin_device *vdev, u32 subaddr, u32 *data)
 	msgs[1].len = 1;
 
 	rval = i2c_transfer(client->adapter, msgs, 2);
-	if (rval < 0){
+	if (rval < 0) {
 		vin_error("failed(%d): [0x%x]\n", rval, subaddr);
 		return rval;
 	}
@@ -116,12 +135,14 @@ static int imx290_set_vin_mode(struct vin_device *vdev, struct vin_video_format
 {
 	struct vin_device_config imx290_config;
 
-	memset(&imx290_config, 0, sizeof (imx290_config));
+	memset(&imx290_config, 0, sizeof(imx290_config));
 
 	imx290_config.interface_type = SENSOR_SERIAL_LVDS;
 	imx290_config.sync_mode = SENSOR_SYNC_MODE_MASTER;
 
-	if (format->device_mode == 1 || format->device_mode == 4) {/* 720p120 and 1080p30 12 bits */
+	if (format->video_mode == AMBA_VIDEO_MODE_720P ||
+		format->device_mode == 4 ||
+		format->device_mode == 7) {/* 1080p 12bits and 720p */
 		imx290_config.slvds_cfg.lane_number = SENSOR_4_LANE;
 	} else {
 		imx290_config.slvds_cfg.lane_number = SENSOR_8_LANE;
@@ -132,7 +153,13 @@ static int imx290_set_vin_mode(struct vin_device *vdev, struct vin_video_format
 	} else {
 		imx290_config.slvds_cfg.sync_code_style = SENSOR_SYNC_STYLE_SONY_DOL;
 		/* use split width to make VIN divide the long expo lines */
-		imx290_config.hdr_cfg.split_width = (format->bits == AMBA_VIDEO_BITS_10)? IMX290_1080P_H_PERIOD : IMX290_1080P_12B_H_PERIOD;
+
+		if (format->video_mode == AMBA_VIDEO_MODE_1080P) {
+			imx290_config.hdr_cfg.split_width = (format->bits == AMBA_VIDEO_BITS_10)? IMX290_1080P_H_PERIOD : IMX290_1080P_12B_H_PERIOD;
+		} else {
+			imx290_config.hdr_cfg.split_width = IMX290_720P_H_PERIOD;
+		}
+		imx290_config.hdr_cfg.num_splits = format->hdr_mode;
 	}
 
 	imx290_config.cap_win.x = format->def_start_x;
@@ -145,8 +172,6 @@ static int imx290_set_vin_mode(struct vin_device *vdev, struct vin_video_format
 	imx290_config.hdr_cfg.act_win.y = format->act_start_y;
 	imx290_config.hdr_cfg.act_win.width = format->act_width;
 	imx290_config.hdr_cfg.act_win.height = format->act_height;
-	imx290_config.hdr_cfg.act_win.max_width = format->max_act_width;
-	imx290_config.hdr_cfg.act_win.max_height = format->max_act_height;
 
 	imx290_config.sensor_id	= GENERIC_SENSOR;
 	imx290_config.input_format = AMBA_VIN_INPUT_FORMAT_RGB_RAW;
@@ -173,17 +198,7 @@ static void imx290_start_streaming(struct vin_device *vdev)
 
 static int imx290_init_device(struct vin_device *vdev)
 {
-	struct vin_reg_16_8 *regs;
-	int i, regs_num;
-
 	imx290_sw_reset(vdev);
-
-	regs = imx290_share_regs;
-	regs_num = ARRAY_SIZE(imx290_share_regs);
-
-	for (i = 0; i < regs_num; i++)
-		imx290_write_reg(vdev, regs[i].addr, regs[i].data);
-
 	return 0;
 }
 
@@ -208,7 +223,7 @@ static int imx290_update_hv_info(struct vin_device *vdev)
 	imx290_read_reg(vdev, IMX290_HMAX_MSB, &val_high);
 	imx290_read_reg(vdev, IMX290_HMAX_LSB, &val_low);
 	pinfo->line_length = (val_high << 8) + val_low;
-	if(unlikely(!pinfo->line_length)) {
+	if (unlikely(!pinfo->line_length)) {
 		vin_error("line length is 0!\n");
 		return -EIO;
 	}
@@ -240,37 +255,51 @@ static int imx290_set_format(struct vin_device *vdev, struct vin_video_format *f
 	struct vin_reg_16_8 *regs;
 	int i, regs_num, rval;
 
+	regs = imx290_share_regs;
+	regs_num = ARRAY_SIZE(imx290_share_regs);
+	for (i = 0; i < regs_num; i++)
+		imx290_write_reg(vdev, regs[i].addr, regs[i].data);
+
 	regs = imx290_mode_regs[format->device_mode];
 	regs_num = ARRAY_SIZE(imx290_mode_regs[format->device_mode]);
-
-	for (i = 0; i < regs_num; i++)
+	for (i = 0; i < regs_num; i++) {
 		imx290_write_reg(vdev, regs[i].addr, regs[i].data);
+		if (unlikely(regs[i].addr == IMX290_FRSEL))
+			pinfo->frsel = regs[i].data;
+	}
 
 	/* for DOL mode, set RHS registers */
 	if (format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {
-		u32 rhs1;
-
-		rhs1 = (format->bits == AMBA_VIDEO_BITS_10)?IMX290_1080P_2X_RHS1 : IMX290_1080P_2X_12B_RHS1;
-
-		imx290_write_reg(vdev, IMX290_RHS1_HSB, rhs1 >> 16);
-		imx290_write_reg(vdev, IMX290_RHS1_MSB, rhs1 >> 8);
-		imx290_write_reg(vdev, IMX290_RHS1_LSB, rhs1 & 0xff);
-
-		pinfo->rhs1 = rhs1;
-	} else if (format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE){
-		imx290_write_reg(vdev, IMX290_RHS1_HSB, IMX290_1080P_3X_RHS1 >> 16);
-		imx290_write_reg(vdev, IMX290_RHS1_MSB, IMX290_1080P_3X_RHS1 >> 8);
-		imx290_write_reg(vdev, IMX290_RHS1_LSB, IMX290_1080P_3X_RHS1 & 0xff);
-
-		imx290_write_reg(vdev, IMX290_RHS2_HSB, IMX290_1080P_3X_RHS2 >> 16);
-		imx290_write_reg(vdev, IMX290_RHS2_MSB, IMX290_1080P_3X_RHS2 >> 8);
-		imx290_write_reg(vdev, IMX290_RHS2_LSB, IMX290_1080P_3X_RHS2 & 0xff);
+		if (format->video_mode == AMBA_VIDEO_MODE_1080P) {
+			pinfo->rhs1 = (format->bits == AMBA_VIDEO_BITS_10) ?
+				IMX290_1080P_2X_RHS1 : IMX290_1080P_2X_12B_RHS1;
+		} else {
+			pinfo->rhs1 = IMX290_720P_2X_RHS1;
+		}
+		pinfo->rhs2 = 0;
+
+		imx290_write_reg(vdev, IMX290_RHS1_HSB, pinfo->rhs1 >> 16);
+		imx290_write_reg(vdev, IMX290_RHS1_MSB, pinfo->rhs1 >> 8);
+		imx290_write_reg(vdev, IMX290_RHS1_LSB, pinfo->rhs1 & 0xff);
+	} else if (format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE) {
+		if (format->video_mode == AMBA_VIDEO_MODE_1080P) {
+			pinfo->rhs1 = IMX290_1080P_3X_RHS1;
+			pinfo->rhs2 = IMX290_1080P_3X_RHS2;
+		} else {
+			pinfo->rhs1 = IMX290_720P_3X_RHS1;
+			pinfo->rhs2 = IMX290_720P_3X_RHS2;
+		}
+		imx290_write_reg(vdev, IMX290_RHS1_HSB, pinfo->rhs1 >> 16);
+		imx290_write_reg(vdev, IMX290_RHS1_MSB, pinfo->rhs1 >> 8);
+		imx290_write_reg(vdev, IMX290_RHS1_LSB, pinfo->rhs1 & 0xff);
 
-		pinfo->rhs1 = IMX290_1080P_3X_RHS1;
-		pinfo->rhs2 = IMX290_1080P_3X_RHS2;
+		imx290_write_reg(vdev, IMX290_RHS2_HSB, pinfo->rhs2 >> 16);
+		imx290_write_reg(vdev, IMX290_RHS2_MSB, pinfo->rhs2 >> 8);
+		imx290_write_reg(vdev, IMX290_RHS2_LSB, pinfo->rhs2 & 0xff);
 	}
-
-	imx290_set_pll(vdev, vdev->cur_format->pll_idx);
+	vdev->cur_format->hdr_short1_offset = pinfo->rhs1;
+	vdev->cur_format->hdr_short2_offset = pinfo->rhs2;
+	pinfo->ll_mode = 0;
 
 	rval = imx290_update_hv_info(vdev);
 	if (rval < 0)
@@ -281,7 +310,7 @@ static int imx290_set_format(struct vin_device *vdev, struct vin_video_format *f
 	/* TG reset release ( Enable Streaming ) */
 	imx290_start_streaming(vdev);
 
-	/* communiate with IAV */
+	/* communicate with IAV */
 	rval = imx290_set_vin_mode(vdev, format);
 	if (rval < 0)
 		return rval;
@@ -304,7 +333,7 @@ static int imx290_set_shutter_row(struct vin_device *vdev, u32 row)
 	num_line = clamp(num_line, min_line, max_line);
 
 	/* get the shutter sweep time */
-	blank_lines = pinfo->frame_length_lines - num_line;
+	blank_lines = pinfo->frame_length_lines - num_line - 1;
 	imx290_write_reg(vdev, IMX290_SHS1_HSB, blank_lines >> 16);
 	imx290_write_reg(vdev, IMX290_SHS1_MSB, blank_lines >> 8);
 	imx290_write_reg(vdev, IMX290_SHS1_LSB, blank_lines & 0xff);
@@ -319,14 +348,14 @@ static int imx290_set_shutter_row(struct vin_device *vdev, u32 row)
 	return 0;
 }
 
-static int imx290_shutter2row(struct vin_device *vdev, u32* shutter_time)
+static int imx290_shutter2row(struct vin_device *vdev, u32 *shutter_time)
 {
 	u64 exposure_lines;
 	int rval = 0;
 	struct imx290_priv *pinfo = (struct imx290_priv *)vdev->priv;
 
 	/* for fast boot, it may call set shutter time directly, so we must read line length/frame line */
-	if(unlikely(!pinfo->line_length)) {
+	if (unlikely(!pinfo->line_length)) {
 		rval = imx290_update_hv_info(vdev);
 		if (rval < 0)
 			return rval;
@@ -352,9 +381,11 @@ static int imx290_set_fps(struct vin_device *vdev, int fps)
 
 	pinfo->fsc = v_lines;
 
-	if(vdev->cur_format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {
+	if (vdev->cur_format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {
+		pinfo->fsc &= (~0x1);
 		v_lines = pinfo->fsc >> 1; /* FSC = VMAX * 2 */
 	} else if (vdev->cur_format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE) {
+		pinfo->fsc &= (~0x3);
 		v_lines = pinfo->fsc >> 2; /* FSC = VMAX * 4 */
 	}
 
@@ -373,22 +404,15 @@ static int imx290_set_fps(struct vin_device *vdev, int fps)
 
 static int imx290_set_agc_index(struct vin_device *vdev, int agc_idx)
 {
-	struct imx290_priv *pinfo;
-	u32 tmp;
-
-	pinfo = (struct imx290_priv *)vdev->priv;
+	struct imx290_priv *pinfo = (struct imx290_priv *)vdev->priv;
 
 	/* if gain >= 30db, enable HCG, HCG is 6db */
 	if (agc_idx > 100) {
-		imx290_read_reg(vdev, IMX290_FRSEL, &tmp);
-		tmp |= IMX290_HI_GAIN_MODE;
-		imx290_write_reg(vdev, IMX290_FRSEL, tmp);
+		pinfo->frsel |= IMX290_HI_GAIN_MODE;
 		vin_debug("high gain mode\n");
 		agc_idx -= 20;
 	} else {
-		imx290_read_reg(vdev, IMX290_FRSEL, &tmp);
-		tmp &= ~IMX290_HI_GAIN_MODE;
-		imx290_write_reg(vdev, IMX290_FRSEL, tmp);
+		pinfo->frsel &= ~IMX290_HI_GAIN_MODE;
 		vin_debug("low gain mode\n");
 	}
 
@@ -397,6 +421,7 @@ static int imx290_set_agc_index(struct vin_device *vdev, int agc_idx)
 		agc_idx = IMX290_GAIN_MAX_DB;
 	}
 
+	imx290_write_reg(vdev, IMX290_FRSEL, pinfo->frsel);
 	imx290_write_reg(vdev, IMX290_GAIN, (u8)agc_idx);
 
 	return 0;
@@ -453,11 +478,21 @@ static int imx290_set_wdr_shutter_row_group(struct vin_device *vdev,
 	struct imx290_priv *pinfo = (struct imx290_priv *)vdev->priv;
 	u32 fsc, rhs1, rhs2;
 	int shutter_long, shutter_short1, shutter_short2;
-	int errCode = 0;
+	int rval = 0;
 
-	rhs1 = pinfo->rhs1;
-	rhs2 = pinfo->rhs2;
 	fsc = pinfo->fsc;
+	if (!pinfo->ll_mode) {
+		rhs1 = pinfo->rhs1;
+		rhs2 = pinfo->rhs2;
+	} else {
+		if (vdev->cur_format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {
+			rhs1 = IMX290_LL_MODE_2X_RHS1;
+			rhs2 = 0;
+		} else {
+			rhs1 = IMX290_LL_MODE_3X_RHS1;
+			rhs2 = IMX290_LL_MODE_3X_RHS2;
+		}
+	}
 
 	/* long shutter */
 	shutter_long = p_shutter_gp->l;
@@ -467,14 +502,14 @@ static int imx290_set_wdr_shutter_row_group(struct vin_device *vdev,
 	shutter_short2 = p_shutter_gp->s2;
 
 	/* shutter limitation check */
-	if(vdev->cur_format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {
-		if(fsc < shutter_long) {
+	if (vdev->cur_format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {
+		if (fsc < shutter_long) {
 			vin_error("long shutter row(%d) must be less than fsc(%d)!\n", shutter_long, fsc);
 			return -EPERM;
 		} else {
 			shutter_long = fsc - shutter_long - 1;
 		}
-		if(rhs1 < shutter_short1) {
+		if (rhs1 < shutter_short1) {
 			vin_error("short shutter row(%d) must be less than rhs(%d)!\n", shutter_short1, rhs1);
 			return -EPERM;
 		} else {
@@ -484,7 +519,7 @@ static int imx290_set_wdr_shutter_row_group(struct vin_device *vdev,
 			fsc, shutter_short1, shutter_long, rhs1);
 
 		/* short shutter check */
-		if((shutter_short1 >= 2) && (shutter_short1 <= rhs1 - 2)){
+		if ((shutter_short1 >= 2) && (shutter_short1 <= rhs1 - 2)) {
 			imx290_write_reg(vdev, IMX290_SHS1_LSB, (u8)(shutter_short1 & 0xFF));
 			imx290_write_reg(vdev, IMX290_SHS1_MSB, (u8)(shutter_short1 >> 8));
 			imx290_write_reg(vdev, IMX290_SHS1_HSB, (u8)((shutter_short1 >> 16) & 0xF));
@@ -494,7 +529,7 @@ static int imx290_set_wdr_shutter_row_group(struct vin_device *vdev,
 			return -EPERM;
 		}
 		/* long shutter check */
-		if((shutter_long >= rhs1 + 2) && (shutter_long <= fsc - 2)) {
+		if ((shutter_long >= rhs1 + 2) && (shutter_long <= fsc - 2)) {
 			imx290_write_reg(vdev, IMX290_SHS2_LSB, (u8)(shutter_long & 0xFF));
 			imx290_write_reg(vdev, IMX290_SHS2_MSB, (u8)(shutter_long >> 8));
 			imx290_write_reg(vdev, IMX290_SHS2_HSB, (u8)((shutter_long >> 16) & 0xF));
@@ -504,30 +539,30 @@ static int imx290_set_wdr_shutter_row_group(struct vin_device *vdev,
 			return -EPERM;
 		}
 
-	} else if(vdev->cur_format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE) {
-		if(fsc < shutter_long) {
+	} else if (vdev->cur_format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE) {
+		if (fsc < shutter_long) {
 			vin_error("long shutter row(%d) must be less than fsc(%d)!\n", shutter_long, fsc);
 			return -EPERM;
 		} else {
 			shutter_long = fsc - shutter_long - 1;
 		}
-		if(rhs1 < shutter_short1) {
+		if (rhs1 < shutter_short1) {
 			vin_error("short shutter 1 row(%d) must be less than rhs1(%d)!\n", shutter_short1, rhs1);
 			return -EPERM;
 		} else {
 			shutter_short1 = rhs1 - shutter_short1 - 1;
 		}
-		if(rhs2 < shutter_short2) {
+		if (rhs2 < shutter_short2) {
 			vin_error("short shutter 2 row(%d) must be less than rhs2(%d)!\n", shutter_short2, rhs2);
 			return -EPERM;
 		} else {
-			shutter_short2 = rhs2 - shutter_short2;
+			shutter_short2 = rhs2 - shutter_short2 - 1;
 		}
 		vin_debug("fsc:%d, shs1:%d, shs2:%d, shs3:%d, rhs1:%d, rhs2:%d\n",
 			fsc, shutter_short1, shutter_short2, shutter_long, rhs1, rhs2);
 
 		/* short shutter 1 check */
-		if((shutter_short1 >= 3) && (shutter_short1 <= rhs1 - 2)) {
+		if ((shutter_short1 >= 3) && (shutter_short1 <= rhs1 - 2)) {
 			imx290_write_reg(vdev, IMX290_SHS1_LSB, (u8)(shutter_short1 & 0xFF));
 			imx290_write_reg(vdev, IMX290_SHS1_MSB, (u8)(shutter_short1 >> 8));
 			imx290_write_reg(vdev, IMX290_SHS1_HSB, (u8)((shutter_short1 >> 16) & 0xF));
@@ -537,7 +572,7 @@ static int imx290_set_wdr_shutter_row_group(struct vin_device *vdev,
 			return -EPERM;
 		}
 		/* short shutter 2 check */
-		if((shutter_short2 >= rhs1 + 3) && (shutter_short2 <= rhs2 - 2)) {
+		if ((shutter_short2 >= rhs1 + 3) && (shutter_short2 <= rhs2 - 2)) {
 			imx290_write_reg(vdev, IMX290_SHS2_LSB, (u8)(shutter_short2 & 0xFF));
 			imx290_write_reg(vdev, IMX290_SHS2_MSB, (u8)(shutter_short2 >> 8));
 			imx290_write_reg(vdev, IMX290_SHS2_HSB, (u8)((shutter_short2 >> 16) & 0xF));
@@ -547,7 +582,7 @@ static int imx290_set_wdr_shutter_row_group(struct vin_device *vdev,
 			return -EPERM;
 		}
 		/* long shutter check */
-		if((shutter_long >= rhs2 + 3) && (shutter_long <= fsc - 2)) {
+		if ((shutter_long >= rhs2 + 3) && (shutter_long <= fsc - 2)) {
 			imx290_write_reg(vdev, IMX290_SHS3_LSB, (u8)(shutter_long & 0xFF));
 			imx290_write_reg(vdev, IMX290_SHS3_MSB, (u8)(shutter_long >> 8));
 			imx290_write_reg(vdev, IMX290_SHS3_HSB, (u8)((shutter_long >> 16) & 0xF));
@@ -562,7 +597,7 @@ static int imx290_set_wdr_shutter_row_group(struct vin_device *vdev,
 
 	memcpy(&(pinfo->wdr_shutter_gp),  p_shutter_gp, sizeof(struct vindev_wdr_gp_s));
 
-	return errCode;
+	return rval;
 }
 
 static int imx290_get_wdr_shutter_row_group(struct vin_device *vdev,
@@ -578,7 +613,7 @@ static int imx290_wdr_shutter2row(struct vin_device *vdev,
 	struct vindev_wdr_gp_s *p_shutter2row)
 {
 	u64 exposure_time_q9;
-	int errCode = 0;
+	int rval = 0;
 	struct imx290_priv *pinfo = (struct imx290_priv *)vdev->priv;
 
 	/* long shutter */
@@ -602,7 +637,7 @@ static int imx290_wdr_shutter2row(struct vin_device *vdev,
 	exposure_time_q9 = DIV64_CLOSEST(exposure_time_q9, 512000000);
 	p_shutter2row->s2 = (u32)exposure_time_q9;
 
-	return errCode;
+	return rval;
 }
 
 static int imx290_set_mirror_mode(struct vin_device *vdev,
@@ -650,6 +685,117 @@ static int imx290_set_mirror_mode(struct vin_device *vdev,
 	return 0;
 }
 
+static int imx290_get_aaa_info(struct vin_device *vdev,
+		struct vindev_aaa_info *aaa_info)
+{
+	struct imx290_priv *pinfo = (struct imx290_priv *)vdev->priv;
+
+	switch (vdev->cur_format->hdr_mode) {
+	case AMBA_VIDEO_LINEAR_MODE:
+		aaa_info->sht0_max = pinfo->fsc - 2;
+		aaa_info->sht1_max = 0;
+		aaa_info->sht2_max = 0;
+		break;
+	case AMBA_VIDEO_2X_HDR_MODE:
+		aaa_info->sht0_max = pinfo->fsc - 3 * 2;
+		if (!pinfo->ll_mode)
+			aaa_info->sht1_max = pinfo->rhs1 - 3;
+		else
+			aaa_info->sht1_max = IMX290_LL_MODE_2X_RHS1 - 3;
+		aaa_info->sht2_max = 0;
+		break;
+	case AMBA_VIDEO_3X_HDR_MODE:
+		aaa_info->sht0_max = pinfo->fsc - 4 * 3;
+		if (!pinfo->ll_mode) {
+			aaa_info->sht1_max = pinfo->rhs1 - 4;
+			aaa_info->sht2_max = pinfo->rhs2 - pinfo->rhs1 - 4;
+		} else {
+			aaa_info->sht1_max = IMX290_LL_MODE_3X_RHS1 - 4;
+			aaa_info->sht2_max = IMX290_LL_MODE_3X_RHS2 - IMX290_LL_MODE_3X_RHS1 - 4;
+		}
+		break;
+	default:
+		vin_error("Unsupported hdr mode: %d\n", vdev->cur_format->hdr_mode);
+		return -EPERM;
+	}
+	aaa_info->ll_mode = pinfo->ll_mode;
+
+	return 0;
+}
+
+static int imx290_set_low_light_mode(struct vin_device *vdev,
+	u32 ll_mode)
+{
+	struct imx290_priv *pinfo = (struct imx290_priv *)vdev->priv;
+
+	if (vdev->cur_format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {
+		if (ll_mode) {
+			pinfo->ll_mode = 1;
+			vdev->cur_format->hdr_short1_offset = IMX290_LL_MODE_2X_RHS1;
+			imx290_write_reg(vdev, IMX290_SHS1_HSB, (IMX290_LL_MODE_2X_RHS1 - 2) >> 16);
+			imx290_write_reg(vdev, IMX290_SHS1_MSB, (IMX290_LL_MODE_2X_RHS1 - 2) >> 8);
+			imx290_write_reg(vdev, IMX290_SHS1_LSB, (IMX290_LL_MODE_2X_RHS1 - 2) & 0xFF);
+			imx290_write_reg(vdev, IMX290_RHS1_HSB, IMX290_LL_MODE_2X_RHS1 >> 16);
+			imx290_write_reg(vdev, IMX290_RHS1_MSB, IMX290_LL_MODE_2X_RHS1 >> 8);
+			imx290_write_reg(vdev, IMX290_RHS1_LSB, IMX290_LL_MODE_2X_RHS1 & 0xFF);
+		} else {
+			pinfo->ll_mode = 0;
+			vdev->cur_format->hdr_short1_offset = pinfo->rhs1;
+			imx290_write_reg(vdev, IMX290_RHS1_HSB, pinfo->rhs1 >> 16);
+			imx290_write_reg(vdev, IMX290_RHS1_MSB, pinfo->rhs1 >> 8);
+			imx290_write_reg(vdev, IMX290_RHS1_LSB, pinfo->rhs1 & 0xFF);
+		}
+	} else if (vdev->cur_format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE) {
+		if (ll_mode) {
+			pinfo->ll_mode = 1;
+			vdev->cur_format->hdr_short1_offset = IMX290_LL_MODE_3X_RHS1;
+			vdev->cur_format->hdr_short2_offset = IMX290_LL_MODE_3X_RHS2;
+			imx290_write_reg(vdev, IMX290_SHS1_HSB, (IMX290_LL_MODE_3X_RHS1 - 2) >> 16);
+			imx290_write_reg(vdev, IMX290_SHS1_MSB, (IMX290_LL_MODE_3X_RHS1 - 2) >> 8);
+			imx290_write_reg(vdev, IMX290_SHS1_LSB, (IMX290_LL_MODE_3X_RHS1 - 2) & 0xFF);
+			imx290_write_reg(vdev, IMX290_RHS1_HSB, IMX290_LL_MODE_3X_RHS1 >> 16);
+			imx290_write_reg(vdev, IMX290_RHS1_MSB, IMX290_LL_MODE_3X_RHS1 >> 8);
+			imx290_write_reg(vdev, IMX290_RHS1_LSB, IMX290_LL_MODE_3X_RHS1 & 0xFF);
+			imx290_write_reg(vdev, IMX290_SHS2_HSB, (IMX290_LL_MODE_3X_RHS2 - 2) >> 16);
+			imx290_write_reg(vdev, IMX290_SHS2_MSB, (IMX290_LL_MODE_3X_RHS2 - 2) >> 8);
+			imx290_write_reg(vdev, IMX290_SHS2_LSB, (IMX290_LL_MODE_3X_RHS2 - 2) & 0xFF);
+			imx290_write_reg(vdev, IMX290_RHS2_HSB, IMX290_LL_MODE_3X_RHS2 >> 16);
+			imx290_write_reg(vdev, IMX290_RHS2_MSB, IMX290_LL_MODE_3X_RHS2 >> 8);
+			imx290_write_reg(vdev, IMX290_RHS2_LSB, IMX290_LL_MODE_3X_RHS2 & 0xff);
+		} else {
+			pinfo->ll_mode = 0;
+			vdev->cur_format->hdr_short1_offset = pinfo->rhs1;
+			vdev->cur_format->hdr_short2_offset = pinfo->rhs2;
+			imx290_write_reg(vdev, IMX290_RHS2_HSB, pinfo->rhs2 >> 16);
+			imx290_write_reg(vdev, IMX290_RHS2_MSB, pinfo->rhs2 >> 8);
+			imx290_write_reg(vdev, IMX290_RHS2_LSB, pinfo->rhs2 & 0xff);
+			imx290_write_reg(vdev, IMX290_SHS2_HSB, (pinfo->rhs2 - 2) >> 16);
+			imx290_write_reg(vdev, IMX290_SHS2_MSB, (pinfo->rhs2 - 2) >> 8);
+			imx290_write_reg(vdev, IMX290_SHS2_LSB, (pinfo->rhs2 - 2) & 0xFF);
+			imx290_write_reg(vdev, IMX290_RHS1_HSB, pinfo->rhs1 >> 16);
+			imx290_write_reg(vdev, IMX290_RHS1_MSB, pinfo->rhs1 >> 8);
+			imx290_write_reg(vdev, IMX290_RHS1_LSB, pinfo->rhs1 & 0xFF);
+		}
+	} else {
+		vin_error("Non HDR mode can't support this API: %s!\n", __func__);
+		return -EPERM;
+	}
+
+	return 0;
+}
+
+static int imx290_get_eis_info(struct vin_device *vdev,
+	struct vindev_eisinfo *eis_info)
+{
+	eis_info->sensor_cell_width = 290;/* 2.90 um */
+	eis_info->sensor_cell_height = 290;/* 2.90 um */
+	eis_info->column_bin = 1;
+	eis_info->row_bin = 1;
+	eis_info->vb_time = vdev->cur_format->vb_time;
+
+	return 0;
+}
+
 #ifdef CONFIG_PM
 static int imx290_suspend(struct vin_device *vdev)
 {
@@ -657,17 +803,18 @@ static int imx290_suspend(struct vin_device *vdev)
 
 	for (i = 0; i < ARRAY_SIZE(pm_regs); i++) {
 		imx290_read_reg(vdev, pm_regs[i].addr, &tmp);
-		pm_regs[i].data = (u16) tmp;
+		pm_regs[i].data = (u8)tmp;
 	}
 
 	return 0;
 }
+
 static int imx290_resume(struct vin_device *vdev)
 {
 	int i;
 
 	for (i = 0; i < ARRAY_SIZE(pm_regs); i++) {
-		imx290_write_reg(vdev, pm_regs[i].addr, (u32)pm_regs[i].data);
+		imx290_write_reg(vdev, pm_regs[i].addr, pm_regs[i].data);
 	}
 
 	return 0;
@@ -678,17 +825,20 @@ static struct vin_ops imx290_ops = {
 	.init_device		= imx290_init_device,
 	.set_format		= imx290_set_format,
 	.set_pll			= imx290_set_pll,
-	.set_shutter_row 	= imx290_set_shutter_row,
-	.shutter2row 		= imx290_shutter2row,
+	.set_shutter_row	= imx290_set_shutter_row,
+	.shutter2row		= imx290_shutter2row,
 	.set_frame_rate	= imx290_set_fps,
 	.set_agc_index		= imx290_set_agc_index,
 	.set_hold_mode		= imx290_set_hold_mode,
 	.set_mirror_mode	= imx290_set_mirror_mode,
 	.read_reg			= imx290_read_reg,
 	.write_reg		= imx290_write_reg,
+	.get_aaa_info		= imx290_get_aaa_info,
+	.get_eis_info		= imx290_get_eis_info,
+	.set_low_light_mode	= imx290_set_low_light_mode,
 #ifdef CONFIG_PM
-	.suspend 			= imx290_suspend,
-	.resume 			= imx290_resume,
+	.suspend		= imx290_suspend,
+	.resume			= imx290_resume,
 #endif
 
 	/* for wdr sensor */
@@ -726,6 +876,9 @@ static int imx290_probe(struct i2c_client *client,
 	vdev->wdr_again_idx_min = 0;
 	vdev->wdr_again_idx_max = IMX290_GAIN_MAX_DB;
 
+	/* mode switch needs hw reset */
+	vdev->reset_for_mode_switch = true;
+
 	i2c_set_clientdata(client, vdev);
 
 	imx290 = (struct imx290_priv *)vdev->priv;
@@ -804,4 +957,3 @@ module_exit(imx290_exit);
 MODULE_DESCRIPTION("IMX290 1/2.8 -Inch, 1945x1097, 2.13-Megapixel CMOS Digital Image Sensor");
 MODULE_AUTHOR("Long Zhao, <longzhao@ambarella.com>");
 MODULE_LICENSE("Proprietary");
-
diff --git a/drivers/vin/sensors/sony_imx290/imx290.h b/drivers/vin/sensors/sony_imx290/imx290.h
index 082ff4a..1c70429 100644
--- a/drivers/vin/sensors/sony_imx290/imx290.h
+++ b/drivers/vin/sensors/sony_imx290/imx290.h
@@ -1,20 +1,38 @@
 /*
- * kernel/private/drivers/ambarella/vin/sensors/sony_imx290/imx290_pri.h
+ * imx290.h
  *
  * History:
  *    2015/03/23 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2015, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
-#ifndef __IMX290_PRI_H__
-#define __IMX290_PRI_H__
+
+#ifndef __IMX290_H__
+#define __IMX290_H__
 
 #define USE_1080P_2X_30FPS
 
@@ -68,6 +86,7 @@
 #define IMX290_INCKSEL4			0x305F
 #define IMX290_INCKSEL5			0x315E
 #define IMX290_INCKSEL6			0x3164
+#define IMX290_INCKSEL7			0x3480
 
 #define IMX290_XVSCNT_INT		0x3106
 
@@ -84,12 +103,16 @@
 #define IMX290_HI_GAIN_MODE	(1<<4)
 
 #define IMX290_1080P_BRL		(1109)
-#define IMX290_720P_BRL		(735)
-#define IMX290_1080P_H_PIXEL	(1945)
-#define IMX290_1080P_HBLANK	(695)
+#define IMX290_1080P_H_PIXEL	(1948)
+#define IMX290_1080P_HBLANK	(692)
 #define IMX290_1080P_H_PERIOD	(2640)
 #define IMX290_1080P_12B_H_PERIOD	(2200)
 
+#define IMX290_720P_BRL		(735)
+#define IMX290_720P_H_PIXEL	(1308)
+#define IMX290_720P_HBLANK	(1332)
+#define IMX290_720P_H_PERIOD	(2640)
+
 #ifdef USE_1080P_2X_30FPS
 #define IMX290_1080P_2X_RHS1		(0x1B3)/* for 1080p30 2x, the max value of RHS1 is 2259 */
 #else
@@ -101,5 +124,20 @@
 #define IMX290_1080P_3X_RHS1		(0x208)
 #define IMX290_1080P_3X_RHS2		(0x25A)/* for 1080p30 3x, the max value of RHS2 is 1148 */
 
-#endif /* __IMX290_PRI_H__ */
+#define USE_720P_2X_30FPS	1
+
+#if USE_720P_2X_30FPS
+#define IMX290_720P_2X_RHS1		(0x1B3)
+#else
+#define IMX290_720P_2X_RHS1		(9)
+#endif
+
+#define IMX290_720P_3X_RHS1		(0x208)
+#define IMX290_720P_3X_RHS2		(0x25A)
+
+#define IMX290_LL_MODE_2X_RHS1	(5)
+#define IMX290_LL_MODE_3X_RHS1	(7)
+#define IMX290_LL_MODE_3X_RHS2	(14)
+
+#endif /* __IMX290_H__ */
 
diff --git a/drivers/vin/sensors/sony_imx290/imx290_table.c b/drivers/vin/sensors/sony_imx290/imx290_table.c
index f533a71..1b1ed67 100644
--- a/drivers/vin/sensors/sony_imx290/imx290_table.c
+++ b/drivers/vin/sensors/sony_imx290/imx290_table.c
@@ -1,23 +1,41 @@
 /*
- * kernel/private/drivers/ambarella/vin/sensors/sony_imx290/imx290_table.c
+ * imx290_table.c
  *
  * History:
  *    2015/03/23 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2015, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_video_pll imx290_plls[] = {
 	{0, 37125000, 148500000}, /* for 1080p */
 	{0, 37125000, 148500000}, /* for 720p */
 };
 
-static struct vin_reg_16_8 imx290_pll_regs[][6] = {
+static struct vin_reg_16_8 imx290_pll_regs[][7] = {
 	{	/* for 1080p */
 		{IMX290_INCKSEL1, 0x18},
 		{IMX290_INCKSEL2, 0x00},
@@ -25,6 +43,7 @@ static struct vin_reg_16_8 imx290_pll_regs[][6] = {
 		{IMX290_INCKSEL4, 0x01},
 		{IMX290_INCKSEL5, 0x1A},
 		{IMX290_INCKSEL6, 0x1A},
+		{IMX290_INCKSEL7, 0x49},
 	},
 	{	/* for 720p */
 		{IMX290_INCKSEL1, 0x20},
@@ -33,6 +52,7 @@ static struct vin_reg_16_8 imx290_pll_regs[][6] = {
 		{IMX290_INCKSEL4, 0x01},
 		{IMX290_INCKSEL5, 0x1A},
 		{IMX290_INCKSEL6, 0x1A},
+		{IMX290_INCKSEL7, 0x49},
 	},
 };
 
@@ -207,6 +227,108 @@ static struct vin_reg_16_8 imx290_mode_regs[][31] = {
 		{IMX290_HBLANK_LSB,		0xFC},
 		{IMX290_HBLANK_MSB,		0x00},
 	},
+	{	/* 2x DOL: 720p60 10bits */
+		{IMX290_ADBIT0,			0x00},
+		{IMX290_ADBIT1,			0x1D},
+		{IMX290_ADBIT2,			0x12},
+		{IMX290_ADBIT3,			0x37},
+		{IMX290_WINMODE,		0x10},
+		{IMX290_FRSEL,			0x00},
+		{IMX290_VMAX_LSB,		0xEE},
+		{IMX290_VMAX_MSB,		0x02},
+		{IMX290_VMAX_HSB,		0x00},
+		{IMX290_HMAX_LSB,		0x72},
+		{IMX290_HMAX_MSB,		0x06},
+		{IMX290_ODBIT,			0xE0},
+		{IMX290_BLKLEVEL_LSB,	0x3C},
+		{IMX290_BLKLEVEL_MSB,	0x00},
+		/* DOL related */
+		{IMX290_WDMODE,		0x11},
+		{IMX290_SHS1_LSB,		0x02},
+		{IMX290_SHS1_MSB,		0x00},
+		{IMX290_SHS1_HSB,		0x00},
+		{IMX290_SHS2_LSB,		0x5B},
+		{IMX290_SHS2_MSB,		0x04},
+		{IMX290_SHS2_HSB,		0x00},
+		{IMX290_SHS3_LSB,		0x00},
+		{IMX290_SHS3_MSB,		0x00},
+		{IMX290_SHS3_HSB,		0x00},
+		{IMX290_PATTERN,		0x00},
+		{IMX290_XVSCNT_INT,		0x90},
+		{IMX290_NULL0SIZE,		0x00},
+		{IMX290_YOUTSIZE_LSB,	0xBA},
+		{IMX290_YOUTSIZE_MSB,	0x05},
+		{IMX290_HBLANK_LSB,		0x34},
+		{IMX290_HBLANK_MSB,		0x05},
+	},
+	{	/* 3x DOL: 720p30 10bits */
+		{IMX290_ADBIT0,			0x00},
+		{IMX290_ADBIT1,			0x1D},
+		{IMX290_ADBIT2,			0x12},
+		{IMX290_ADBIT3,			0x37},
+		{IMX290_WINMODE,		0x10},
+		{IMX290_FRSEL,			0x00},
+		{IMX290_VMAX_LSB,		0xEE},
+		{IMX290_VMAX_MSB,		0x02},
+		{IMX290_VMAX_HSB,		0x00},
+		{IMX290_HMAX_LSB,		0x72},
+		{IMX290_HMAX_MSB,		0x06},
+		{IMX290_ODBIT,			0xE0},
+		{IMX290_BLKLEVEL_LSB,	0x3C},
+		{IMX290_BLKLEVEL_MSB,	0x00},
+		/* DOL related */
+		{IMX290_WDMODE,		0x21},
+		{IMX290_SHS1_LSB,		0x05},
+		{IMX290_SHS1_MSB,		0x00},
+		{IMX290_SHS1_HSB,		0x00},
+		{IMX290_SHS2_LSB,		0x1B},
+		{IMX290_SHS2_MSB,		0x02},
+		{IMX290_SHS2_HSB,		0x00},
+		{IMX290_SHS3_LSB,		0xB7},
+		{IMX290_SHS3_MSB,		0x02},
+		{IMX290_SHS3_HSB,		0x00},
+		{IMX290_PATTERN,		0x00},
+		{IMX290_XVSCNT_INT,		0xB0},
+		{IMX290_NULL0SIZE,		0x00},
+		{IMX290_YOUTSIZE_LSB,	0x8B},
+		{IMX290_YOUTSIZE_MSB,	0x0B},
+		{IMX290_HBLANK_LSB,		0x34},
+		{IMX290_HBLANK_MSB,		0x05},
+	},
+	{	/* linear: 1080p60 12bits */
+		{IMX290_ADBIT0,			0x01},
+		{IMX290_ADBIT1,			0x00},
+		{IMX290_ADBIT2,			0x00},
+		{IMX290_ADBIT3,			0x0E},
+		{IMX290_WINMODE,		0x00},
+		{IMX290_FRSEL,			0x01},
+		{IMX290_VMAX_LSB,		0x65},
+		{IMX290_VMAX_MSB,		0x04},
+		{IMX290_VMAX_HSB,		0x00},
+		{IMX290_HMAX_LSB,		0x98},
+		{IMX290_HMAX_MSB,		0x08},
+		{IMX290_ODBIT,			0xE1},
+		{IMX290_BLKLEVEL_LSB,	0xF0},
+		{IMX290_BLKLEVEL_MSB,	0x00},
+		/* DOL related */
+		{IMX290_WDMODE,		0x00},
+		{IMX290_SHS1_LSB,		0x00},
+		{IMX290_SHS1_MSB,		0x00},
+		{IMX290_SHS1_HSB,		0x00},
+		{IMX290_SHS2_LSB,		0x00},
+		{IMX290_SHS2_MSB,		0x00},
+		{IMX290_SHS2_HSB,		0x00},
+		{IMX290_SHS3_LSB,		0x00},
+		{IMX290_SHS3_MSB,		0x00},
+		{IMX290_SHS3_HSB,		0x00},
+		{IMX290_PATTERN,		0x01},
+		{IMX290_XVSCNT_INT,		0x00},
+		{IMX290_NULL0SIZE,		0x01},
+		{IMX290_YOUTSIZE_LSB,	0x49},
+		{IMX290_YOUTSIZE_MSB,	0x04},
+		{IMX290_HBLANK_LSB,		0xFC},
+		{IMX290_HBLANK_MSB,		0x00},
+	},
 };
 
 static struct vin_reg_16_8 imx290_share_regs[] = {
@@ -262,9 +384,6 @@ static struct vin_reg_16_8 imx290_share_regs[] = {
 
 #ifdef CONFIG_PM
 static struct vin_reg_16_8 pm_regs[] = {
-	{IMX290_VMAX_HSB, 0x00},
-	{IMX290_VMAX_MSB, 0x00},
-	{IMX290_VMAX_LSB, 0x00},
 	{IMX290_SHS1_HSB, 0x00},
 	{IMX290_SHS1_MSB, 0x00},
 	{IMX290_SHS1_LSB, 0x00},
@@ -275,6 +394,7 @@ static struct vin_reg_16_8 pm_regs[] = {
 	{IMX290_SHS3_MSB, 0x00},
 	{IMX290_SHS3_LSB, 0x00},
 	{IMX290_GAIN, 0x00},
+	{IMX290_FRSEL, 0x00},
 };
 #endif
 
@@ -331,8 +451,6 @@ static struct vin_video_format imx290_formats[] = {
 		.act_start_y	= 0,
 		.act_width	= 1920,
 		.act_height	= 1080,
-		.max_act_width = 1920,
-		.max_act_height = IMX290_1080P_BRL,
 		/* sensor mode */
 		.hdr_mode = AMBA_VIDEO_2X_HDR_MODE,
 		.device_mode	= 2,
@@ -365,8 +483,6 @@ static struct vin_video_format imx290_formats[] = {
 		.act_start_y	= 0,
 		.act_width	= 1920,
 		.act_height	= 1080,
-		.max_act_width = 1920,
-		.max_act_height = IMX290_1080P_BRL,
 		/* sensor mode */
 		.hdr_mode = AMBA_VIDEO_3X_HDR_MODE,
 		.device_mode	= 3,
@@ -396,8 +512,6 @@ static struct vin_video_format imx290_formats[] = {
 		.act_start_y	= 0,
 		.act_width	= 1920,
 		.act_height	= 1080,
-		.max_act_width = 1920,
-		.max_act_height = IMX290_1080P_BRL,
 		/* sensor mode */
 		.hdr_mode = AMBA_VIDEO_2X_HDR_MODE,
 		.device_mode	= 4,
@@ -416,6 +530,88 @@ static struct vin_video_format imx290_formats[] = {
 		.hdr_long_offset = 0,
 		.hdr_short1_offset = (IMX290_1080P_2X_12B_RHS1 - 1) + 1, /* hdr_long_offset + 2 x VBP1 + 1 */
 	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_720P,
+		.def_start_x	= 4+8,
+		.def_start_y	= (1+2+4+4)*2,
+		.def_width	= 1280,
+		.def_height	= 720 * 2 + (IMX290_720P_2X_RHS1 - 1), /* (720 + VBP1)*2 */
+		.act_start_x	= 0,
+		.act_start_y	= 0,
+		.act_width	= 1280,
+		.act_height	= 720,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_2X_HDR_MODE,
+		.device_mode	= 5,
+		.pll_idx	= 1,
+		.width		= IMX290_720P_H_PIXEL*2+IMX290_720P_HBLANK,
+		.height		= 720,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_10,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+#if USE_720P_2X_30FPS
+		.max_fps	= AMBA_VIDEO_FPS_30,
+#else
+		.max_fps	= AMBA_VIDEO_FPS_60,
+#endif
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+		.hdr_long_offset = 0,
+		.hdr_short1_offset = (IMX290_720P_2X_RHS1 - 1) + 1, /* hdr_long_offset + 2 x VBP1 + 1 */
+	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_720P,
+		.def_start_x	= 4+8,
+		.def_start_y	= (1+2+4+4)*3,
+		.def_width	= 1280,
+		.def_height	= 720 * 3 + (IMX290_720P_3X_RHS2 - 2), /* (720 + VBP2)*3 */
+		.act_start_x	= 0,
+		.act_start_y	= 0,
+		.act_width	= 1280,
+		.act_height	= 720,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_3X_HDR_MODE,
+		.device_mode	= 6,
+		.pll_idx	= 1,
+		.width		= IMX290_720P_H_PIXEL*3+IMX290_720P_HBLANK*2,
+		.height		= 720,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_10,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+		.hdr_long_offset = 0,
+		.hdr_short1_offset = (IMX290_720P_3X_RHS1 - 1) + 1, /* hdr_long_offset + 3 x VBP1 + 1 */
+		.hdr_short2_offset = (IMX290_720P_3X_RHS2 - 2) + 2, /* hdr_long_offset + 3 x VBP2 + 2 */
+	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_1080P,
+		.def_start_x	= 4+8,
+		.def_start_y	= 1+2+10+8,
+		.def_width	= 1920,
+		.def_height	= 1080,
+		/* sensor mode */
+		.device_mode	= 7,
+		.pll_idx	= 0,
+		.width		= 1920,
+		.height		= 1080,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_60,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+	},
 };
 
 #define IMX290_GAIN_MAX_DB  	240 /* 72dB */
diff --git a/drivers/vin/sensors/sony_imx290/make.inc b/drivers/vin/sensors/sony_imx290/make.inc
index 9fe6e8e..c3f6b94 100644
--- a/drivers/vin/sensors/sony_imx290/make.inc
+++ b/drivers/vin/sensors/sony_imx290/make.inc
@@ -1,15 +1,32 @@
 ##
-## kernel/private/drivers/vin/sensors/sony_imx290/make.inc
+## make.inc
 ##
 ## History:
 ##    2014/12/05 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_IMX290), y)
diff --git a/drivers/vin/sensors/sony_imx291/Kbuild b/drivers/vin/sensors/sony_imx291/Kbuild
index 0de6e30..6569498 100644
--- a/drivers/vin/sensors/sony_imx291/Kbuild
+++ b/drivers/vin/sensors/sony_imx291/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/12/05 - [Long Zhao] Create
 ##
-## Copyright (C) 2004-2014, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/sony_imx291/imx291.c b/drivers/vin/sensors/sony_imx291/imx291.c
index 5f42ee3..4cc60e4 100644
--- a/drivers/vin/sensors/sony_imx291/imx291.c
+++ b/drivers/vin/sensors/sony_imx291/imx291.c
@@ -1,17 +1,35 @@
 /*
- * kernel/private/drivers/ambarella/vin/sensors/sony_imx291/imx291.c
+ * imx291.c
  *
  * History:
  *    2014/12/05 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
@@ -31,6 +49,7 @@ struct imx291_priv {
 	void *control_data;
 	u32 frame_length_lines;
 	u32 line_length;
+	u8 frsel;
 };
 
 #include "imx291_table.c"
@@ -118,7 +137,8 @@ static int imx291_set_vin_mode(struct vin_device *vdev, struct vin_video_format
 	imx291_config.interface_type = SENSOR_SERIAL_LVDS;
 	imx291_config.sync_mode = SENSOR_SYNC_MODE_MASTER;
 
-	if (format->device_mode == 1) {/* 720p120 */
+	if (format->device_mode == 1 ||
+		format->device_mode == 2) {/* 720p120 and 1080p60 12bits */
 		imx291_config.slvds_cfg.lane_number = SENSOR_4_LANE;
 	} else {
 		imx291_config.slvds_cfg.lane_number = SENSOR_8_LANE;
@@ -155,17 +175,7 @@ static void imx291_start_streaming(struct vin_device *vdev)
 
 static int imx291_init_device(struct vin_device *vdev)
 {
-	struct vin_reg_16_8 *regs;
-	int i, regs_num;
-
 	imx291_sw_reset(vdev);
-
-	regs = imx291_share_regs;
-	regs_num = ARRAY_SIZE(imx291_share_regs);
-
-	for (i = 0; i < regs_num; i++)
-		imx291_write_reg(vdev, regs[i].addr, regs[i].data);
-
 	return 0;
 }
 
@@ -218,16 +228,22 @@ static int imx291_get_line_time(struct vin_device *vdev)
 
 static int imx291_set_format(struct vin_device *vdev, struct vin_video_format *format)
 {
+	struct imx291_priv *pinfo = (struct imx291_priv *)vdev->priv;
 	struct vin_reg_16_8 *regs;
 	int i, regs_num, rval;
 
-	regs = imx291_mode_regs[format->device_mode];
-	regs_num = ARRAY_SIZE(imx291_mode_regs[format->device_mode]);
-
+	regs = imx291_share_regs;
+	regs_num = ARRAY_SIZE(imx291_share_regs);
 	for (i = 0; i < regs_num; i++)
 		imx291_write_reg(vdev, regs[i].addr, regs[i].data);
 
-	imx291_set_pll(vdev, vdev->cur_format->pll_idx);
+	regs = imx291_mode_regs[format->device_mode];
+	regs_num = ARRAY_SIZE(imx291_mode_regs[format->device_mode]);
+	for (i = 0; i < regs_num; i++) {
+		imx291_write_reg(vdev, regs[i].addr, regs[i].data);
+		if (unlikely(regs[i].addr == IMX291_FRSEL))
+			pinfo->frsel = regs[i].data;
+	}
 
 	rval = imx291_update_hv_info(vdev);
 	if (rval < 0)
@@ -238,7 +254,7 @@ static int imx291_set_format(struct vin_device *vdev, struct vin_video_format *f
 	/* TG reset release ( Enable Streaming ) */
 	imx291_start_streaming(vdev);
 
-	/* communiate with IAV */
+	/* communicate with IAV */
 	rval = imx291_set_vin_mode(vdev, format);
 	if (rval < 0)
 		return rval;
@@ -261,7 +277,7 @@ static int imx291_set_shutter_row(struct vin_device *vdev, u32 row)
 	num_line = clamp(num_line, min_line, max_line);
 
 	/* get the shutter sweep time */
-	blank_lines = pinfo->frame_length_lines - num_line;
+	blank_lines = pinfo->frame_length_lines - num_line - 1;
 	imx291_write_reg(vdev, IMX291_SHS1_HSB, blank_lines >> 16);
 	imx291_write_reg(vdev, IMX291_SHS1_MSB, blank_lines >> 8);
 	imx291_write_reg(vdev, IMX291_SHS1_LSB, blank_lines & 0xff);
@@ -322,22 +338,15 @@ static int imx291_set_fps(struct vin_device *vdev, int fps)
 
 static int imx291_set_agc_index(struct vin_device *vdev, int agc_idx)
 {
-	struct imx291_priv *pinfo;
-	u32 tmp;
-
-	pinfo = (struct imx291_priv *)vdev->priv;
+	struct imx291_priv *pinfo = (struct imx291_priv *)vdev->priv;
 
 	/* if gain >= 30db, enable HCG, HCG is 6db */
 	if (agc_idx > 100) {
-		imx291_read_reg(vdev, IMX291_FRSEL, &tmp);
-		tmp |= IMX291_HI_GAIN_MODE;
-		imx291_write_reg(vdev, IMX291_FRSEL, tmp);
+		pinfo->frsel |= IMX291_HI_GAIN_MODE;
 		vin_debug("high gain mode\n");
 		agc_idx -= 20;
 	} else {
-		imx291_read_reg(vdev, IMX291_FRSEL, &tmp);
-		tmp &= ~IMX291_HI_GAIN_MODE;
-		imx291_write_reg(vdev, IMX291_FRSEL, tmp);
+		pinfo->frsel &= ~IMX291_HI_GAIN_MODE;
 		vin_debug("low gain mode\n");
 	}
 
@@ -346,6 +355,7 @@ static int imx291_set_agc_index(struct vin_device *vdev, int agc_idx)
 		agc_idx = IMX291_GAIN_MAX_DB;
 	}
 
+	imx291_write_reg(vdev, IMX291_FRSEL, pinfo->frsel);
 	imx291_write_reg(vdev, IMX291_GAIN, (u8)agc_idx);
 
 	return 0;
@@ -403,7 +413,7 @@ static int imx291_suspend(struct vin_device *vdev)
 
 	for (i = 0; i < ARRAY_SIZE(pm_regs); i++) {
 		imx291_read_reg(vdev, pm_regs[i].addr, &tmp);
-		pm_regs[i].data = (u16) tmp;
+		pm_regs[i].data = (u8)tmp;
 	}
 
 	return 0;
@@ -413,7 +423,7 @@ static int imx291_resume(struct vin_device *vdev)
 	int i;
 
 	for (i = 0; i < ARRAY_SIZE(pm_regs); i++) {
-		imx291_write_reg(vdev, pm_regs[i].addr, (u32)pm_regs[i].data);
+		imx291_write_reg(vdev, pm_regs[i].addr, pm_regs[i].data);
 	}
 
 	return 0;
@@ -462,6 +472,9 @@ static int imx291_probe(struct i2c_client *client,
 	vdev->agc_db_min = 0x00000000;	/* 0dB */
 	vdev->agc_db_step = 0x004CCCCC;	/* 0.3dB */
 
+	/* mode switch needs hw reset */
+	vdev->reset_for_mode_switch = true;
+
 	i2c_set_clientdata(client, vdev);
 
 	imx291 = (struct imx291_priv *)vdev->priv;
diff --git a/drivers/vin/sensors/sony_imx291/imx291.h b/drivers/vin/sensors/sony_imx291/imx291.h
index b8021b4..e01ce3f 100644
--- a/drivers/vin/sensors/sony_imx291/imx291.h
+++ b/drivers/vin/sensors/sony_imx291/imx291.h
@@ -1,20 +1,38 @@
 /*
- * kernel/private/drivers/ambarella/vin/sensors/sony_imx291/imx291_pri.h
+ * imx291.h
  *
  * History:
  *    2014/12/05 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
-#ifndef __IMX291_PRI_H__
-#define __IMX291_PRI_H__
+
+#ifndef __IMX291_H__
+#define __IMX291_H__
 
 #define IMX291_STANDBY    		0x3000
 #define IMX291_REGHOLD			0x3001
@@ -22,6 +40,9 @@
 #define IMX291_SWRESET    		0x3003
 
 #define IMX291_ADBIT    			0x3005
+#define IMX291_ADBIT1			0x3129
+#define IMX291_ADBIT2			0x317C
+#define IMX291_ADBIT3			0x31EC
 #define IMX291_WINMODE    		0x3007
 #define IMX291_FRSEL			0x3009
 #define IMX291_BLKLEVEL_LSB	0x300A
@@ -48,11 +69,12 @@
 #define IMX291_INCKSEL4			0x305F
 #define IMX291_INCKSEL5			0x315E
 #define IMX291_INCKSEL6			0x3164
+#define IMX291_INCKSEL7			0x3480
 
 #define IMX291_V_FLIP	(1<<0)
 #define IMX291_H_MIRROR	(1<<1)
 
 #define IMX291_HI_GAIN_MODE	(1<<4)
 
-#endif /* __IMX291_PRI_H__ */
+#endif /* __IMX291_H__ */
 
diff --git a/drivers/vin/sensors/sony_imx291/imx291_table.c b/drivers/vin/sensors/sony_imx291/imx291_table.c
index e0f2a5e..53411aa 100644
--- a/drivers/vin/sensors/sony_imx291/imx291_table.c
+++ b/drivers/vin/sensors/sony_imx291/imx291_table.c
@@ -1,23 +1,41 @@
 /*
- * kernel/private/drivers/ambarella/vin/sensors/sony_imx291/imx291_table.c
+ * imx291_table.c
  *
  * History:
  *    2014/12/05 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_video_pll imx291_plls[] = {
 	{0, 37125000, 148500000}, /* for 1080p */
 	{0, 37125000, 148500000}, /* for 720p */
 };
 
-static struct vin_reg_16_8 imx291_pll_regs[][6] = {
+static struct vin_reg_16_8 imx291_pll_regs[][7] = {
 	{	/* for 1080p */
 		{IMX291_INCKSEL1, 0x18},
 		{IMX291_INCKSEL2, 0x00},
@@ -25,6 +43,7 @@ static struct vin_reg_16_8 imx291_pll_regs[][6] = {
 		{IMX291_INCKSEL4, 0x01},
 		{IMX291_INCKSEL5, 0x1A},
 		{IMX291_INCKSEL6, 0x1A},
+		{IMX291_INCKSEL7, 0x49},
 	},
 	{	/* for 720p */
 		{IMX291_INCKSEL1, 0x20},
@@ -33,12 +52,16 @@ static struct vin_reg_16_8 imx291_pll_regs[][6] = {
 		{IMX291_INCKSEL4, 0x01},
 		{IMX291_INCKSEL5, 0x1A},
 		{IMX291_INCKSEL6, 0x1A},
+		{IMX291_INCKSEL7, 0x49},
 	},
 };
 
-static struct vin_reg_16_8 imx291_mode_regs[][11] = {
+static struct vin_reg_16_8 imx291_mode_regs[][14] = {
 	{	/* 1080p120 10bits */
 		{IMX291_ADBIT,			0x00},
+		{IMX291_ADBIT1,			0x1D},
+		{IMX291_ADBIT2,			0x12},
+		{IMX291_ADBIT3,			0x37},
 		{IMX291_WINMODE,		0x00},
 		{IMX291_FRSEL,			0x00},
 		{IMX291_VMAX_LSB,		0x65},
@@ -52,6 +75,9 @@ static struct vin_reg_16_8 imx291_mode_regs[][11] = {
 	},
 	{	/* 720p120 10bits */
 		{IMX291_ADBIT,			0x00},
+		{IMX291_ADBIT1,			0x1D},
+		{IMX291_ADBIT2,			0x12},
+		{IMX291_ADBIT3,			0x37},
 		{IMX291_WINMODE,		0x10},
 		{IMX291_FRSEL,			0x00},
 		{IMX291_VMAX_LSB,		0xEE},
@@ -62,7 +88,23 @@ static struct vin_reg_16_8 imx291_mode_regs[][11] = {
 		{IMX291_ODBIT,			0xE0},
 		{IMX291_BLKLEVEL_LSB,	0x3C},
 		{IMX291_BLKLEVEL_MSB,	0x00},
-	}
+	},
+	{	/* 1080p60 12bits */
+		{IMX291_ADBIT,			0x01},
+		{IMX291_ADBIT1,			0x00},
+		{IMX291_ADBIT2,			0x00},
+		{IMX291_ADBIT3,			0x0E},
+		{IMX291_WINMODE,		0x00},
+		{IMX291_FRSEL,			0x01},
+		{IMX291_VMAX_LSB,		0x65},
+		{IMX291_VMAX_MSB,		0x04},
+		{IMX291_VMAX_HSB,		0x00},
+		{IMX291_HMAX_LSB,		0x98},
+		{IMX291_HMAX_MSB,		0x08},
+		{IMX291_ODBIT,			0xE1},
+		{IMX291_BLKLEVEL_LSB,	0xF0},
+		{IMX291_BLKLEVEL_MSB,	0x00},
+	},
 };
 
 static struct vin_reg_16_8 imx291_share_regs[] = {
@@ -109,20 +151,18 @@ static struct vin_reg_16_8 imx291_share_regs[] = {
 	{0x3360, 0x1E},
 	{0x3361, 0x61},
 	{0x3362, 0x10},
-	{0x33B0, 0x08},
-	{0x33B1, 0x30},
+	{0x33B0, 0x50},
+	{0x33B2, 0x1A},
 	{0x33B3, 0x04},
 };
 
 #ifdef CONFIG_PM
 static struct vin_reg_16_8 pm_regs[] = {
-	{IMX291_VMAX_HSB, 0x00},
-	{IMX291_VMAX_MSB, 0x00},
-	{IMX291_VMAX_LSB, 0x00},
 	{IMX291_SHS1_HSB, 0x00},
 	{IMX291_SHS1_MSB, 0x00},
 	{IMX291_SHS1_LSB, 0x00},
 	{IMX291_GAIN, 0x00},
+	{IMX291_FRSEL, 0x00},
 };
 #endif
 
@@ -169,6 +209,27 @@ static struct vin_video_format imx291_formats[] = {
 		.default_shutter_time	= AMBA_VIDEO_FPS_60,
 		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
 	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_1080P,
+		.def_start_x	= 4+8,
+		.def_start_y	= 1+2+10+8,
+		.def_width	= 1920,
+		.def_height	= 1080,
+		/* sensor mode */
+		.device_mode	= 2,
+		.pll_idx	= 0,
+		.width		= 1920,
+		.height		= 1080,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_60,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+	},
 };
 
 #define IMX291_GAIN_MAX_DB  210 /* 63dB */
diff --git a/drivers/vin/sensors/sony_imx291/make.inc b/drivers/vin/sensors/sony_imx291/make.inc
index 6b2754d..dd868fa 100644
--- a/drivers/vin/sensors/sony_imx291/make.inc
+++ b/drivers/vin/sensors/sony_imx291/make.inc
@@ -1,15 +1,32 @@
 ##
-## kernel/private/drivers/vin/sensors/sony_imx291/make.inc
+## make.inc
 ##
 ## History:
 ##    2014/12/05 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_IMX291), y)
diff --git a/drivers/vin/sensors/sony_imx291_mipi/Kbuild b/drivers/vin/sensors/sony_imx291_mipi/Kbuild
new file mode 100644
index 0000000..84fc489
--- /dev/null
+++ b/drivers/vin/sensors/sony_imx291_mipi/Kbuild
@@ -0,0 +1,38 @@
+##
+## Kbuild
+##
+## History:
+##    2016/08/23 - [Hao Zeng] created file
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
+EXTRA_AFLAGS		+= $(AMBARELLA_DRV_AFLAGS)
+EXTRA_LDFLAGS		+= $(AMBARELLA_DRV_LDFLAGS)
+
+obj-m := imx291_mipi.o
+imx291_mipi-y := imx291.o
+
diff --git a/drivers/vin/sensors/sony_imx291_mipi/imx291.c b/drivers/vin/sensors/sony_imx291_mipi/imx291.c
new file mode 100644
index 0000000..04199af
--- /dev/null
+++ b/drivers/vin/sensors/sony_imx291_mipi/imx291.c
@@ -0,0 +1,547 @@
+/*
+ * imx291.c
+ *
+ * History:
+ *    2016/08/23 - [Hao Zeng] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/ambpriv_device.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/pm.h>
+#include <iav_utils.h>
+#include <vin_api.h>
+#include "imx291.h"
+#include "imx291_table.c"
+
+static int bus_addr = (0 << 16) | (0x34 >> 1);
+module_param(bus_addr, int, 0644);
+MODULE_PARM_DESC(bus_addr, " bus and addr: bit16~bit31: bus, bit0~bit15: addr");
+
+struct imx291_priv {
+	void *control_data;
+	u32 frame_length_lines;
+	u32 line_length;
+	u8 frsel;
+};
+
+static int imx291_write_reg(struct vin_device *vdev, u32 subaddr, u32 data)
+{
+	int rval;
+	struct imx291_priv *imx291;
+	struct i2c_client *client;
+	struct i2c_msg msgs[1];
+	u8 pbuf[3];
+
+	imx291 = (struct imx291_priv *)vdev->priv;
+	client = imx291->control_data;
+
+	pbuf[0] = (subaddr & 0xff00) >> 8;
+	pbuf[1] = subaddr & 0xff;
+	pbuf[2] = data;
+
+	msgs[0].len = 3;
+	msgs[0].addr = client->addr;
+	if (unlikely(subaddr == IMX291_SWRESET))
+		msgs[0].flags = client->flags | I2C_M_IGNORE_NAK;
+	else
+		msgs[0].flags = client->flags;
+	msgs[0].buf = pbuf;
+
+	rval = i2c_transfer(client->adapter, msgs, 1);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x:0x%x]\n", rval, subaddr, data);
+		return rval;
+	}
+
+	return 0;
+}
+
+static int imx291_read_reg(struct vin_device *vdev, u32 subaddr, u32 *data)
+{
+	int rval = 0;
+	struct imx291_priv *imx291;
+	struct i2c_client *client;
+	struct i2c_msg msgs[2];
+	u8 pbuf0[2];
+	u8 pbuf[1];
+
+	imx291 = (struct imx291_priv *)vdev->priv;
+	client = imx291->control_data;
+
+	pbuf0[0] = (subaddr &0xff00) >> 8;
+	pbuf0[1] = subaddr & 0xff;
+
+	msgs[0].len = 2;
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].buf = pbuf0;
+
+	msgs[1].addr = client->addr;
+	msgs[1].flags = client->flags | I2C_M_RD;
+	msgs[1].buf = pbuf;
+	msgs[1].len = 1;
+
+	rval = i2c_transfer(client->adapter, msgs, 2);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x]\n", rval, subaddr);
+		return rval;
+	}
+
+	*data = pbuf[0];
+
+	return 0;
+}
+
+static int imx291_set_hold_mode(struct vin_device *vdev, u32 hold_mode)
+{
+	imx291_write_reg(vdev, IMX291_REGHOLD, hold_mode);
+	return 0;
+}
+
+static int imx291_set_vin_mode(struct vin_device *vdev, struct vin_video_format *format)
+{
+	struct vin_device_config imx291_config;
+
+	memset(&imx291_config, 0, sizeof(imx291_config));
+
+	imx291_config.interface_type = SENSOR_MIPI;
+	imx291_config.sync_mode = SENSOR_SYNC_MODE_MASTER;
+
+	imx291_config.slvds_cfg.lane_number = SENSOR_2_LANE;
+
+	imx291_config.cap_win.x = format->def_start_x;
+	imx291_config.cap_win.y = format->def_start_y;
+	imx291_config.cap_win.width = format->def_width;
+	imx291_config.cap_win.height = format->def_height;
+
+	imx291_config.sensor_id	= GENERIC_SENSOR;
+	imx291_config.input_format = AMBA_VIN_INPUT_FORMAT_RGB_RAW;
+	imx291_config.bayer_pattern = format->bayer_pattern;
+	imx291_config.video_format = format->format;
+	imx291_config.bit_resolution = format->bits;
+
+	return ambarella_set_vin_config(vdev, &imx291_config);
+}
+
+static void imx291_sw_reset(struct vin_device *vdev)
+{
+	imx291_write_reg(vdev, IMX291_STANDBY, 0x1);/* STANDBY */
+	imx291_write_reg(vdev, IMX291_SWRESET, 0x1);
+	msleep(10);
+}
+
+static void imx291_start_streaming(struct vin_device *vdev)
+{
+	imx291_write_reg(vdev, IMX291_XMSTA, 0x0); /* master mode start */
+	imx291_write_reg(vdev, IMX291_STANDBY, 0x0); /* cancel standby */
+	msleep(30);
+}
+
+static int imx291_init_device(struct vin_device *vdev)
+{
+	imx291_sw_reset(vdev);
+	return 0;
+}
+
+static int imx291_set_pll(struct vin_device *vdev, int pll_idx)
+{
+	struct vin_reg_16_8 *regs;
+	int i, regs_num;
+
+	regs = imx291_pll_regs[pll_idx];
+	regs_num = ARRAY_SIZE(imx291_pll_regs[pll_idx]);
+	for (i = 0; i < regs_num; i++)
+		imx291_write_reg(vdev, regs[i].addr, regs[i].data);
+
+	return 0;
+}
+
+static int imx291_update_hv_info(struct vin_device *vdev)
+{
+	u32 val_high, val_mid, val_low;
+	struct imx291_priv *pinfo = (struct imx291_priv *)vdev->priv;
+
+	imx291_read_reg(vdev, IMX291_HMAX_MSB, &val_high);
+	imx291_read_reg(vdev, IMX291_HMAX_LSB, &val_low);
+	pinfo->line_length = (val_high << 8) + val_low;
+	if(unlikely(!pinfo->line_length)) {
+		vin_error("line length is 0!\n");
+		return -EIO;
+	}
+
+	imx291_read_reg(vdev, IMX291_VMAX_HSB, &val_high);
+	imx291_read_reg(vdev, IMX291_VMAX_MSB, &val_mid);
+	imx291_read_reg(vdev, IMX291_VMAX_LSB, &val_low);
+	pinfo->frame_length_lines = ((val_high & 0x01) << 16) + (val_mid << 8) + val_low;
+
+	return 0;
+}
+
+static int imx291_get_line_time(struct vin_device *vdev)
+{
+	u64 h_clks;
+	struct imx291_priv *pinfo = (struct imx291_priv *)vdev->priv;
+
+	h_clks = (u64)pinfo->line_length * 512000000;
+	h_clks = DIV64_CLOSEST(h_clks, vdev->cur_pll->pixelclk);
+
+	vdev->cur_format->line_time = (u32)h_clks;
+
+	return 0;
+}
+
+static int imx291_set_format(struct vin_device *vdev, struct vin_video_format *format)
+{
+	struct imx291_priv *pinfo = (struct imx291_priv *)vdev->priv;
+	struct vin_reg_16_8 *regs;
+	int i, regs_num, rval;
+
+	regs = imx291_share_regs;
+	regs_num = ARRAY_SIZE(imx291_share_regs);
+	for (i = 0; i < regs_num; i++)
+		imx291_write_reg(vdev, regs[i].addr, regs[i].data);
+
+	regs = imx291_mode_regs[format->device_mode];
+	regs_num = ARRAY_SIZE(imx291_mode_regs[format->device_mode]);
+	for (i = 0; i < regs_num; i++) {
+		imx291_write_reg(vdev, regs[i].addr, regs[i].data);
+		if (unlikely(regs[i].addr == IMX291_FRSEL))
+			pinfo->frsel = regs[i].data;
+	}
+
+	rval = imx291_update_hv_info(vdev);
+	if (rval < 0)
+		return rval;
+
+	imx291_get_line_time(vdev);
+
+	/* TG reset release ( Enable Streaming ) */
+	imx291_start_streaming(vdev);
+
+	/* communicate with IAV */
+	rval = imx291_set_vin_mode(vdev, format);
+	if (rval < 0)
+		return rval;
+
+	return 0;
+}
+
+static int imx291_set_shutter_row(struct vin_device *vdev, u32 row)
+{
+	u32 blank_lines;
+	u64 exposure_lines;
+	u32 num_line, max_line, min_line;
+	struct imx291_priv *pinfo = (struct imx291_priv *)vdev->priv;
+
+	num_line = row;
+
+	/* FIXME: shutter width: 1 ~ (Frame format(V) - 2) */
+	min_line = 1;
+	max_line = pinfo->frame_length_lines - 2;
+	num_line = clamp(num_line, min_line, max_line);
+
+	/* get the shutter sweep time */
+	blank_lines = pinfo->frame_length_lines - num_line - 1;
+	imx291_write_reg(vdev, IMX291_SHS1_HSB, blank_lines >> 16);
+	imx291_write_reg(vdev, IMX291_SHS1_MSB, blank_lines >> 8);
+	imx291_write_reg(vdev, IMX291_SHS1_LSB, blank_lines & 0xff);
+
+	exposure_lines = num_line;
+	exposure_lines = exposure_lines * (u64)pinfo->line_length * 512000000;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, vdev->cur_pll->pixelclk);
+
+	vdev->shutter_time = (u32)exposure_lines;
+	vin_debug("shutter_time:%d, row:%d\n", vdev->shutter_time, num_line);
+
+	return 0;
+}
+
+static int imx291_shutter2row(struct vin_device *vdev, u32 *shutter_time)
+{
+	u64 exposure_lines;
+	int rval = 0;
+	struct imx291_priv *pinfo = (struct imx291_priv *)vdev->priv;
+
+	/* for fast boot, it may call set shutter time directly, so we must read line length/frame line */
+	if(unlikely(!pinfo->line_length)) {
+		rval = imx291_update_hv_info(vdev);
+		if (rval < 0)
+			return rval;
+	}
+
+	exposure_lines = (*shutter_time) * (u64)vdev->cur_pll->pixelclk;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, pinfo->line_length);
+	exposure_lines = DIV64_CLOSEST(exposure_lines, 512000000);
+
+	*shutter_time = exposure_lines;
+
+	return rval;
+}
+
+static int imx291_set_fps(struct vin_device *vdev, int fps)
+{
+	u64 v_lines, vb_time;
+	struct imx291_priv *pinfo = (struct imx291_priv *)vdev->priv;
+
+	v_lines = fps * (u64)vdev->cur_pll->pixelclk;
+	v_lines = DIV64_CLOSEST(v_lines, pinfo->line_length);
+	v_lines = DIV64_CLOSEST(v_lines, 512000000);
+
+	imx291_write_reg(vdev, IMX291_VMAX_HSB, (v_lines & 0x030000) >> 16);
+	imx291_write_reg(vdev, IMX291_VMAX_MSB, (v_lines & 0x00FF00) >> 8);
+	imx291_write_reg(vdev, IMX291_VMAX_LSB, v_lines & 0x0000FF);
+
+	pinfo->frame_length_lines = (u32)v_lines;
+
+	vb_time = pinfo->line_length * (u64)(v_lines - vdev->cur_format->height) * 1000000000;
+	vb_time = DIV64_CLOSEST(vb_time, vdev->cur_pll->pixelclk);
+	vdev->cur_format->vb_time = vb_time;
+
+	return 0;
+}
+
+static int imx291_set_agc_index(struct vin_device *vdev, int agc_idx)
+{
+	struct imx291_priv *pinfo = (struct imx291_priv *)vdev->priv;
+
+	/* if gain >= 30db, enable HCG, HCG is 6db */
+	if (agc_idx > 100) {
+		pinfo->frsel |= IMX291_HI_GAIN_MODE;
+		vin_debug("high gain mode\n");
+		agc_idx -= 20;
+	} else {
+		pinfo->frsel &= ~IMX291_HI_GAIN_MODE;
+		vin_debug("low gain mode\n");
+	}
+
+	if (agc_idx > IMX291_GAIN_MAX_DB) {
+		vin_warn("agc index %d exceeds maximum %d\n", agc_idx, IMX291_GAIN_MAX_DB);
+		agc_idx = IMX291_GAIN_MAX_DB;
+	}
+
+	imx291_write_reg(vdev, IMX291_FRSEL, pinfo->frsel);
+	imx291_write_reg(vdev, IMX291_GAIN, (u8)agc_idx);
+
+	return 0;
+}
+
+static int imx291_set_mirror_mode(struct vin_device *vdev,
+	struct vindev_mirror *mirror_mode)
+{
+	u32 tmp_reg, readmode, bayer_pattern;
+
+	switch (mirror_mode->pattern) {
+	case VINDEV_MIRROR_AUTO:
+		return 0;
+
+	case VINDEV_MIRROR_HORRIZONTALLY_VERTICALLY:
+		readmode = IMX291_H_MIRROR | IMX291_V_FLIP;
+		bayer_pattern = VINDEV_BAYER_PATTERN_RG;
+		break;
+
+	case VINDEV_MIRROR_HORRIZONTALLY:
+		readmode = IMX291_H_MIRROR;
+		bayer_pattern = VINDEV_BAYER_PATTERN_RG;
+		break;
+
+	case VINDEV_MIRROR_VERTICALLY:
+		readmode = IMX291_V_FLIP;
+		bayer_pattern = VINDEV_BAYER_PATTERN_RG;
+		break;
+
+	case VINDEV_MIRROR_NONE:
+		readmode = 0;
+		bayer_pattern = VINDEV_BAYER_PATTERN_RG;
+		break;
+
+	default:
+		vin_error("do not support cmd mirror mode\n");
+		return -EINVAL;
+	}
+
+	imx291_read_reg(vdev, IMX291_WINMODE, &tmp_reg);
+	tmp_reg &= ~(IMX291_H_MIRROR | IMX291_V_FLIP);
+	tmp_reg |= readmode;
+	imx291_write_reg(vdev, IMX291_WINMODE, tmp_reg);
+
+	if (mirror_mode->bayer_pattern == VINDEV_BAYER_PATTERN_AUTO)
+		mirror_mode->bayer_pattern = bayer_pattern;
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int imx291_suspend(struct vin_device *vdev)
+{
+	u32 i, tmp;
+
+	for (i = 0; i < ARRAY_SIZE(pm_regs); i++) {
+		imx291_read_reg(vdev, pm_regs[i].addr, &tmp);
+		pm_regs[i].data = (u8)tmp;
+	}
+
+	return 0;
+}
+static int imx291_resume(struct vin_device *vdev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(pm_regs); i++) {
+		imx291_write_reg(vdev, pm_regs[i].addr, pm_regs[i].data);
+	}
+
+	return 0;
+}
+#endif
+
+static struct vin_ops imx291_ops = {
+	.init_device		= imx291_init_device,
+	.set_format		= imx291_set_format,
+	.set_pll			= imx291_set_pll,
+	.set_shutter_row 	= imx291_set_shutter_row,
+	.shutter2row 		= imx291_shutter2row,
+	.set_frame_rate	= imx291_set_fps,
+	.set_agc_index		= imx291_set_agc_index,
+	.set_mirror_mode	= imx291_set_mirror_mode,
+	.set_hold_mode		= imx291_set_hold_mode,
+	.read_reg			= imx291_read_reg,
+	.write_reg		= imx291_write_reg,
+#ifdef CONFIG_PM
+	.suspend 			= imx291_suspend,
+	.resume 			= imx291_resume,
+#endif
+};
+
+/* ========================================================================== */
+static int imx291_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	int rval = 0;
+	struct vin_device *vdev;
+	struct imx291_priv *imx291;
+
+	vdev = ambarella_vin_create_device(client->name,
+		SENSOR_IMX291, sizeof(struct imx291_priv));
+
+	if (!vdev)
+		return -ENOMEM;
+
+	vdev->intf_id = 0;
+	vdev->dev_type = VINDEV_TYPE_SENSOR;
+	vdev->sub_type = VINDEV_SUBTYPE_CMOS;
+	vdev->default_mode = AMBA_VIDEO_MODE_1080P;
+	vdev->frame_rate = AMBA_VIDEO_FPS_29_97;
+	vdev->agc_db_max = 0x3F000000;  /* 63dB */
+	vdev->agc_db_min = 0x00000000;  /* 0dB */
+	vdev->agc_db_step = 0x004CCCCC; /* 0.3dB */
+
+	/* mode switch needs hw reset */
+	vdev->reset_for_mode_switch = true;
+
+	i2c_set_clientdata(client, vdev);
+
+	imx291 = (struct imx291_priv *)vdev->priv;
+	imx291->control_data = client;
+
+	rval = ambarella_vin_register_device(vdev, &imx291_ops,
+		imx291_formats, ARRAY_SIZE(imx291_formats),
+		imx291_plls, ARRAY_SIZE(imx291_plls));
+
+	if (rval < 0)
+		goto imx291_probe_err;
+
+	vin_info("IMX291 init(2-lane mipi)\n");
+
+	return 0;
+
+imx291_probe_err:
+	ambarella_vin_free_device(vdev);
+	return rval;
+}
+
+static int imx291_remove(struct i2c_client *client)
+{
+	struct vin_device *vdev;
+
+	vdev = (struct vin_device *)i2c_get_clientdata(client);
+	ambarella_vin_unregister_device(vdev);
+	ambarella_vin_free_device(vdev);
+
+	return 0;
+}
+
+static const struct i2c_device_id imx291_idtable[] = {
+	{ "imx291", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, imx291_idtable);
+
+static struct i2c_driver i2c_driver_imx291 = {
+	.driver = {
+		.name	= "imx291",
+	},
+
+	.id_table	= imx291_idtable,
+	.probe		= imx291_probe,
+	.remove		= imx291_remove,
+};
+
+static int __init imx291_init(void)
+{
+	int bus, addr, rval;
+
+	bus = bus_addr >> 16;
+	addr = bus_addr & 0xffff;
+
+	rval = ambpriv_i2c_update_addr("imx291", bus, addr);
+	if (rval < 0)
+		return rval;
+
+	rval = i2c_add_driver(&i2c_driver_imx291);
+	if (rval < 0)
+		return rval;
+
+	return 0;
+}
+
+static void __exit imx291_exit(void)
+{
+	i2c_del_driver(&i2c_driver_imx291);
+}
+
+module_init(imx291_init);
+module_exit(imx291_exit);
+
+MODULE_DESCRIPTION("IMX291 1/2.8-Inch, 1945x1097, 2.13-Megapixel CMOS Digital Image Sensor");
+MODULE_AUTHOR("Hao Zeng, <haozeng@ambarella.com>");
+MODULE_LICENSE("Proprietary");
+
diff --git a/drivers/vin/sensors/sony_imx291_mipi/imx291.h b/drivers/vin/sensors/sony_imx291_mipi/imx291.h
new file mode 100644
index 0000000..f845609
--- /dev/null
+++ b/drivers/vin/sensors/sony_imx291_mipi/imx291.h
@@ -0,0 +1,112 @@
+/*
+ * imx291.h
+ *
+ * History:
+ *    2016/08/23 - [Hao Zeng] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __IMX291_H__
+#define __IMX291_H__
+
+#define IMX291_STANDBY			0x3000
+#define IMX291_REGHOLD			0x3001
+#define IMX291_XMSTA				0x3002
+#define IMX291_SWRESET			0x3003
+
+#define IMX291_ADBIT			0x3005
+#define IMX291_ADBIT1			0x3129
+#define IMX291_ADBIT2			0x317C
+#define IMX291_ADBIT3			0x31EC
+#define IMX291_WINMODE			0x3007
+#define IMX291_FRSEL			0x3009
+#define IMX291_BLKLEVEL_LSB	0x300A
+#define IMX291_BLKLEVEL_MSB	0x300B
+
+#define IMX291_GAIN			0x3014
+
+#define IMX291_VMAX_LSB			0x3018
+#define IMX291_VMAX_MSB			0x3019
+#define IMX291_VMAX_HSB			0x301A
+
+#define IMX291_HMAX_LSB			0x301C
+#define IMX291_HMAX_MSB			0x301D
+
+#define IMX291_SHS1_LSB			0x3020
+#define IMX291_SHS1_MSB			0x3021
+#define IMX291_SHS1_HSB			0x3022
+
+#define IMX291_ODBIT			0x3046
+
+#define IMX291_INCKSEL1			0x305C
+#define IMX291_INCKSEL2			0x305D
+#define IMX291_INCKSEL3			0x305E
+#define IMX291_INCKSEL4			0x305F
+#define IMX291_INCKSEL5			0x315E
+#define IMX291_INCKSEL6			0x3164
+#define IMX291_INCKSEL7			0x3480
+
+#define IMX291_REPETITION		0x3405
+#define IMX291_PHY_LANE_NUM		0x3407
+#define IMX291_OPB_SIZE_V		0x3414
+#define IMX291_Y_OUT_SIZE_LSB	0x3418
+#define IMX291_Y_OUT_SIZE_MSB	0x3419
+#define IMX291_THSEXIT_LSB		0x342C
+#define IMX291_THSEXIT_MSB		0x342D
+#define IMX291_TCLKPRE_LSB		0x3430
+#define IMX291_TCLKPRE_MSB		0x3431
+#define IMX291_CSI_DT_FMT_LSB	0x3441
+#define IMX291_CSI_DT_FMT_MSB	0x3442
+#define IMX291_CSI_LANE_MODE		0x3443
+#define IMX291_EXTCK_FREQ_LSB	0x3444
+#define IMX291_EXTCK_FREQ_MSB	0x3445
+#define IMX291_TCLKPOST_LSB		0x3446
+#define IMX291_TCLKPOST_MSB		0x3447
+#define IMX291_THSZERO_LSB		0x3448
+#define IMX291_THSZERO_MSB		0x3449
+#define IMX291_THSPREPARE_LSB	0x344A
+#define IMX291_THSPREPARE_MSB	0x344B
+#define IMX291_TCLKTRAIL_LSB		0x344C
+#define IMX291_TCLKTRAIL_MSB		0x344D
+#define IMX291_THSTRAIL_LSB		0x344E
+#define IMX291_THSTRAIL_MSB		0x344F
+#define IMX291_TCLKZERO_LSB		0x3450
+#define IMX291_TCLKZERO_MSB		0x3451
+#define IMX291_TCLKPREPARE_LSB	0x3452
+#define IMX291_TCLKPREPARE_MSB	0x3453
+#define IMX291_TLPX_LSB			0x3454
+#define IMX291_TLPX_MSB			0x3455
+#define IMX291_X_OUT_SIZE_LSB	0x3472
+#define IMX291_X_OUT_SIZE_MSB	0x3473
+
+#define IMX291_V_FLIP	(1<<0)
+#define IMX291_H_MIRROR	(1<<1)
+
+#define IMX291_HI_GAIN_MODE	(1<<4)
+
+#endif /* __IMX291_H__ */
+
diff --git a/drivers/vin/sensors/sony_imx291_mipi/imx291_table.c b/drivers/vin/sensors/sony_imx291_mipi/imx291_table.c
new file mode 100644
index 0000000..f1598bb
--- /dev/null
+++ b/drivers/vin/sensors/sony_imx291_mipi/imx291_table.c
@@ -0,0 +1,344 @@
+/*
+ * imx291_table.c
+ *
+ * History:
+ *    2016/08/23 - [Hao Zeng] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+static struct vin_video_pll imx291_plls[] = {
+	{0, 37125000, 148500000}, /* for 1080p */
+	{0, 37125000, 148500000}, /* for 720p */
+};
+
+static struct vin_reg_16_8 imx291_pll_regs[][7] = {
+	{	/* for 1080p */
+		{IMX291_INCKSEL1, 0x18},
+		{IMX291_INCKSEL2, 0x03},
+		{IMX291_INCKSEL3, 0x20},
+		{IMX291_INCKSEL4, 0x01},
+		{IMX291_INCKSEL5, 0x1A},
+		{IMX291_INCKSEL6, 0x1A},
+		{IMX291_INCKSEL7, 0x49},
+	},
+	{	/* for 720p */
+		{IMX291_INCKSEL1, 0x20},
+		{IMX291_INCKSEL2, 0x00},
+		{IMX291_INCKSEL3, 0x20},
+		{IMX291_INCKSEL4, 0x01},
+		{IMX291_INCKSEL5, 0x1A},
+		{IMX291_INCKSEL6, 0x1A},
+		{IMX291_INCKSEL7, 0x49},
+	},
+};
+
+static struct vin_reg_16_8 imx291_mode_regs[][29] = {
+	{	/* 1080p30 12bits */
+		{IMX291_ADBIT,			0x01},
+		{IMX291_ADBIT1,			0x00},
+		{IMX291_ADBIT2,			0x00},
+		{IMX291_ADBIT3,			0x0E},
+		{IMX291_WINMODE,		0x00},
+		{IMX291_FRSEL,			0x02},
+		{IMX291_VMAX_LSB,		0x65},
+		{IMX291_VMAX_MSB,		0x04},
+		{IMX291_VMAX_HSB,		0x00},
+		{IMX291_HMAX_LSB,		0x30},
+		{IMX291_HMAX_MSB,		0x11},
+		{IMX291_ODBIT,			0x01},
+		{IMX291_BLKLEVEL_LSB,	0xF0},
+		{IMX291_BLKLEVEL_MSB,	0x00},
+		/* mipi parameters */
+		{IMX291_OPB_SIZE_V,		0x0A},
+		{IMX291_Y_OUT_SIZE_LSB,	0x49},
+		{IMX291_Y_OUT_SIZE_MSB,	0x04},
+		{IMX291_X_OUT_SIZE_LSB,	0x9C},
+		{IMX291_X_OUT_SIZE_MSB,	0x07},
+		{IMX291_CSI_DT_FMT_LSB,	0x0C},
+		{IMX291_CSI_DT_FMT_MSB,	0x0C},
+		{IMX291_TCLKPOST_LSB,	0x57},
+		{IMX291_THSZERO_LSB,	0x37},
+		{IMX291_THSPREPARE_LSB,	0x1F},
+		{IMX291_TCLKTRAIL_LSB,	0x1F},
+		{IMX291_THSTRAIL_LSB,	0x1F},
+		{IMX291_TCLKZERO_LSB,	0x77},
+		{IMX291_TCLKPREPARE_LSB,0x1F},
+		{IMX291_TLPX_LSB,		0x17},
+	},
+	{	/* 1080p30 10bits */
+		{IMX291_ADBIT,			0x00},
+		{IMX291_ADBIT1,			0x1D},
+		{IMX291_ADBIT2,			0x12},
+		{IMX291_ADBIT3,			0x37},
+		{IMX291_WINMODE,		0x00},
+		{IMX291_FRSEL,			0x02},
+		{IMX291_VMAX_LSB,		0x65},
+		{IMX291_VMAX_MSB,		0x04},
+		{IMX291_VMAX_HSB,		0x00},
+		{IMX291_HMAX_LSB,		0x30},
+		{IMX291_HMAX_MSB,		0x11},
+		{IMX291_ODBIT,			0x00},
+		{IMX291_BLKLEVEL_LSB,	0x3C},
+		{IMX291_BLKLEVEL_MSB,	0x00},
+		/* mipi parameters */
+		{IMX291_OPB_SIZE_V,		0x0A},
+		{IMX291_Y_OUT_SIZE_LSB,	0x49},
+		{IMX291_Y_OUT_SIZE_MSB,	0x04},
+		{IMX291_X_OUT_SIZE_LSB,	0x9C},
+		{IMX291_X_OUT_SIZE_MSB,	0x07},
+		{IMX291_CSI_DT_FMT_LSB,	0x0A},
+		{IMX291_CSI_DT_FMT_MSB,	0x0A},
+		{IMX291_TCLKPOST_LSB,	0x57},
+		{IMX291_THSZERO_LSB,	0x37},
+		{IMX291_THSPREPARE_LSB,	0x1F},
+		{IMX291_TCLKTRAIL_LSB,	0x1F},
+		{IMX291_THSTRAIL_LSB,	0x1F},
+		{IMX291_TCLKZERO_LSB,	0x77},
+		{IMX291_TCLKPREPARE_LSB,0x1F},
+		{IMX291_TLPX_LSB,		0x17},
+	},
+	{	/* 720p30 12bits */
+		{IMX291_ADBIT,			0x01},
+		{IMX291_ADBIT1,			0x00},
+		{IMX291_ADBIT2,			0x00},
+		{IMX291_ADBIT3,			0x0E},
+		{IMX291_WINMODE,		0x10},
+		{IMX291_FRSEL,			0x02},
+		{IMX291_VMAX_LSB,		0xEE},
+		{IMX291_VMAX_MSB,		0x02},
+		{IMX291_VMAX_HSB,		0x00},
+		{IMX291_HMAX_LSB,		0xC8},
+		{IMX291_HMAX_MSB,		0x19},
+		{IMX291_ODBIT,			0x01},
+		{IMX291_BLKLEVEL_LSB,	0xF0},
+		{IMX291_BLKLEVEL_MSB,	0x00},
+		/* mipi parameters */
+		{IMX291_OPB_SIZE_V,		0x04},
+		{IMX291_Y_OUT_SIZE_LSB,	0xD9},
+		{IMX291_Y_OUT_SIZE_MSB,	0x02},
+		{IMX291_X_OUT_SIZE_LSB,	0x1C},
+		{IMX291_X_OUT_SIZE_MSB,	0x05},
+		{IMX291_CSI_DT_FMT_LSB,	0x0C},
+		{IMX291_CSI_DT_FMT_MSB,	0x0C},
+		{IMX291_TCLKPOST_LSB,	0x4F},
+		{IMX291_THSZERO_LSB,	0x2F},
+		{IMX291_THSPREPARE_LSB,	0x17},
+		{IMX291_TCLKTRAIL_LSB,	0x17},
+		{IMX291_THSTRAIL_LSB,	0x17},
+		{IMX291_TCLKZERO_LSB,	0x57},
+		{IMX291_TCLKPREPARE_LSB,0x17},
+		{IMX291_TLPX_LSB,		0x17},
+	},
+	{	/* 720p30 10bits */
+		{IMX291_ADBIT,			0x00},
+		{IMX291_ADBIT1,			0x1D},
+		{IMX291_ADBIT2,			0x12},
+		{IMX291_ADBIT3,			0x37},
+		{IMX291_WINMODE,		0x10},
+		{IMX291_FRSEL,			0x02},
+		{IMX291_VMAX_LSB,		0xEE},
+		{IMX291_VMAX_MSB,		0x02},
+		{IMX291_VMAX_HSB,		0x00},
+		{IMX291_HMAX_LSB,		0xC8},
+		{IMX291_HMAX_MSB,		0x19},
+		{IMX291_ODBIT,			0x00},
+		{IMX291_BLKLEVEL_LSB,	0x3C},
+		{IMX291_BLKLEVEL_MSB,	0x00},
+		/* mipi parameters */
+		{IMX291_OPB_SIZE_V,		0x04},
+		{IMX291_Y_OUT_SIZE_LSB,	0xD9},
+		{IMX291_Y_OUT_SIZE_MSB,	0x02},
+		{IMX291_X_OUT_SIZE_LSB,	0x1C},
+		{IMX291_X_OUT_SIZE_MSB,	0x05},
+		{IMX291_CSI_DT_FMT_LSB,	0x0A},
+		{IMX291_CSI_DT_FMT_MSB,	0x0A},
+		{IMX291_TCLKPOST_LSB,	0x4F},
+		{IMX291_THSZERO_LSB,	0x2F},
+		{IMX291_THSPREPARE_LSB,	0x17},
+		{IMX291_TCLKTRAIL_LSB,	0x17},
+		{IMX291_THSTRAIL_LSB,	0x17},
+		{IMX291_TCLKZERO_LSB,	0x57},
+		{IMX291_TCLKPREPARE_LSB,0x17},
+		{IMX291_TLPX_LSB,		0x17},
+	},
+};
+
+static struct vin_reg_16_8 imx291_share_regs[] = {
+	/* chip ID: 02h */
+	{0x300F, 0x00},
+	{0x3010, 0x21},
+	{0x3012, 0x64},
+	{0x3016, 0x08}, /* set to 0x08 to fix flare issue for switching HCG/LCG mode */
+	{0x3070, 0x02},
+	{0x3071, 0x11},
+	{0x30A6, 0x20},
+	{0x30A8, 0x20},
+	{0x30AA, 0x20},
+	{0x30AC, 0x20},
+
+	/* chip ID: 03h */
+	{0x310B, 0x01}, /* according to sony fae's suggestion, set to 1 to fix lowlight issue for 1080p */
+	{0x3119, 0x9E},
+	{0x311E, 0x08},
+	{0x3128, 0x05},
+	{0x3134, 0x0F},
+	{0x313B, 0x50},
+	{0x313D, 0x83},
+	{0x317C, 0x00},
+	{0x317F, 0x00},
+
+	/* chip ID: 04h */
+	{0x32B8, 0x50},
+	{0x32B9, 0x10},
+	{0x32BA, 0x00},
+	{0x32BB, 0x04},
+	{0x32C8, 0x50},
+	{0x32C9, 0x10},
+	{0x32CA, 0x00},
+	{0x32CB, 0x04},
+
+	/* chip ID: 05h */
+	{0x332C, 0xD3},
+	{0x332D, 0x10},
+	{0x332E, 0x0D},
+	{0x3358, 0x06},
+	{0x3359, 0xE1},
+	{0x335A, 0x11},
+	{0x3360, 0x1E},
+	{0x3361, 0x61},
+	{0x3362, 0x10},
+	{0x33B0, 0x50},
+	{0x33B2, 0x1A},
+	{0x33B3, 0x04},
+
+	/* chip ID: 06h */
+	{0x3405, 0x10}, /* REPETITION */
+	{0x3407, 0x01}, /* PHY_LANE_NUM */
+	{0x3443, 0x01}, /* CSI_LANE_MODE */
+	{0x3444, 0x20}, /* EXTCK_FREQ_LSB */
+	{0x3445, 0x25}, /* EXTCK_FREQ_MSB */
+};
+
+#ifdef CONFIG_PM
+static struct vin_reg_16_8 pm_regs[] = {
+	{IMX291_SHS1_HSB, 0x00},
+	{IMX291_SHS1_MSB, 0x00},
+	{IMX291_SHS1_LSB, 0x00},
+	{IMX291_GAIN, 0x00},
+	{IMX291_FRSEL, 0x00},
+};
+#endif
+
+static struct vin_video_format imx291_formats[] = {
+	{
+		.video_mode	= AMBA_VIDEO_MODE_1080P,
+		.def_start_x	= 4+8,
+		.def_start_y	= 8,
+		.def_width	= 1920,
+		.def_height	= 1080,
+		/* sensor mode */
+		.device_mode	= 0,
+		.pll_idx	= 0,
+		.width		= 1920,
+		.height		= 1080,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_1080P,
+		.def_start_x	= 4+8,
+		.def_start_y	= 8,
+		.def_width	= 1920,
+		.def_height	= 1080,
+		/* sensor mode */
+		.device_mode	= 1,
+		.pll_idx	= 0,
+		.width		= 1920,
+		.height		= 1080,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_10,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_720P,
+		.def_start_x	= 4+8,
+		.def_start_y	= 4,
+		.def_width	= 1280,
+		.def_height	= 720,
+		/* sensor mode */
+		.device_mode	= 2,
+		.pll_idx	= 1,
+		.width		= 1280,
+		.height		= 720,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_720P,
+		.def_start_x	= 4+8,
+		.def_start_y	= 4,
+		.def_width	= 1280,
+		.def_height	= 720,
+		/* sensor mode */
+		.device_mode	= 3,
+		.pll_idx	= 1,
+		.width		= 1280,
+		.height		= 720,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_10,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+	},
+};
+
+#define IMX291_GAIN_MAX_DB  210 /* 63dB */
+
diff --git a/drivers/vin/sensors/sony_imx291_mipi/make.inc b/drivers/vin/sensors/sony_imx291_mipi/make.inc
new file mode 100644
index 0000000..778eebe
--- /dev/null
+++ b/drivers/vin/sensors/sony_imx291_mipi/make.inc
@@ -0,0 +1,45 @@
+##
+## make.inc
+##
+## History:
+##    2016/08/23 - [Hao Zeng] created file
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+ifeq ($(CONFIG_SENSOR_IMX291_MIPI), y)
+
+LOCAL_PATH	:= $(call my-dir)
+
+###
+include $(CLEAR_VARS)
+
+LOCAL_SRCS	:= $(wildcard $(LOCAL_PATH)/*.c) $(wildcard $(LOCAL_PATH)/*.h)
+LOCAL_SRCS	+= $(LOCAL_PATH)/Kbuild
+
+include $(BUILD_DRIVER)
+
+endif
+
diff --git a/drivers/vin/sensors/sony_imx322/AmbaConfig b/drivers/vin/sensors/sony_imx322/AmbaConfig
index 6c51655..41f8773 100644
--- a/drivers/vin/sensors/sony_imx322/AmbaConfig
+++ b/drivers/vin/sensors/sony_imx322/AmbaConfig
@@ -4,15 +4,30 @@
 ## History:
 ##    2015/01/30 - [Long Zhao] Create
 ##
-## Copyright (C) 2004-2015, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
-## This file is produced by perl.
-##/
 
 choice
 	prompt "Interface"
diff --git a/drivers/vin/sensors/sony_imx322/Kbuild b/drivers/vin/sensors/sony_imx322/Kbuild
index c8ff269..5a4b63b 100644
--- a/drivers/vin/sensors/sony_imx322/Kbuild
+++ b/drivers/vin/sensors/sony_imx322/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/08/15 - [Long Zhao] Create
 ##
-## Copyright (C) 2004-2014, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
diff --git a/drivers/vin/sensors/sony_imx322/imx322.c b/drivers/vin/sensors/sony_imx322/imx322.c
index f5fbb46..5d429da 100644
--- a/drivers/vin/sensors/sony_imx322/imx322.c
+++ b/drivers/vin/sensors/sony_imx322/imx322.c
@@ -4,14 +4,33 @@
  * History:
  *    2014/08/15 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <linux/module.h>
 #include <linux/ambpriv_device.h>
 #include <linux/interrupt.h>
@@ -45,7 +64,7 @@ struct imx322_priv {
 
 #include "imx322_table.c"
 
-static int imx322_write_reg( struct vin_device *vdev, u32 subaddr, u32 data)
+static int imx322_write_reg(struct vin_device *vdev, u32 subaddr, u32 data)
 {
 	struct imx322_priv *imx322;
 	u8 pbuf[3];
@@ -98,7 +117,7 @@ static int imx322_write_reg( struct vin_device *vdev, u32 subaddr, u32 data)
 	return 0;
 }
 
-static int imx322_read_reg( struct vin_device *vdev, u32 subaddr, u32 *data)
+static int imx322_read_reg(struct vin_device *vdev, u32 subaddr, u32 *data)
 {
 	struct imx322_priv *imx322;
 	u8 pbuf[2];
@@ -110,7 +129,7 @@ static int imx322_read_reg( struct vin_device *vdev, u32 subaddr, u32 *data)
 
 	imx322 = (struct imx322_priv *)vdev->priv;
 
-	pbuf[0] = ((subaddr & 0xff00) >> 8) | 0x80;;
+	pbuf[0] = ((subaddr & 0xff00) >> 8) | 0x80;
 	pbuf[1] = subaddr & 0xff;
 
 	config.cfs_dfs = 8;
@@ -138,7 +157,7 @@ static int imx322_read_reg( struct vin_device *vdev, u32 subaddr, u32 *data)
 	imx322 = (struct imx322_priv *)vdev->priv;
 	client = imx322->control_data;
 
-	pbuf0[0] = (subaddr &0xff00) >> 8;
+	pbuf0[0] = (subaddr & 0xff00) >> 8;
 	pbuf0[1] = subaddr & 0xff;
 
 	msgs[0].len = 2;
@@ -152,7 +171,7 @@ static int imx322_read_reg( struct vin_device *vdev, u32 subaddr, u32 *data)
 	msgs[1].len = 1;
 
 	rval = i2c_transfer(client->adapter, msgs, 2);
-	if (rval < 0){
+	if (rval < 0) {
 		vin_error("failed(%d): [0x%x]\n", rval, subaddr);
 		return rval;
 	}
@@ -167,7 +186,7 @@ static int imx322_set_vin_mode(struct vin_device *vdev, struct vin_video_format
 {
 	struct vin_device_config imx322_config;
 
-	memset(&imx322_config, 0, sizeof (imx322_config));
+	memset(&imx322_config, 0, sizeof(imx322_config));
 
 	imx322_config.interface_type = SENSOR_PARALLEL_LVCMOS;
 	imx322_config.sync_mode = SENSOR_SYNC_MODE_MASTER;
@@ -221,7 +240,7 @@ static int imx322_update_hv_info(struct vin_device *vdev)
 	imx322_read_reg(vdev, IMX322_HMAX_MSB, &val_high);
 	imx322_read_reg(vdev, IMX322_HMAX_LSB, &val_low);
 	pinfo->line_length = ((val_high & 0x3F) << 8) + val_low;
-	if(unlikely(!pinfo->line_length)) {
+	if (unlikely(!pinfo->line_length)) {
 		vin_error("line length is 0!\n");
 		return -EIO;
 	}
@@ -253,9 +272,11 @@ static int imx322_set_format(struct vin_device *vdev, struct vin_video_format *f
 
 	regs = imx322_mode_regs[format->device_mode];
 	regs_num = ARRAY_SIZE(imx322_mode_regs[format->device_mode]);
-
-	for (i = 0; i < regs_num; i++)
+	for (i = 0; i < regs_num; i++) {
+		if (regs[i].addr == 0xffff)
+			break;
 		imx322_write_reg(vdev, regs[i].addr, regs[i].data);
+	}
 
 	rval = imx322_update_hv_info(vdev);
 	if (rval < 0)
@@ -301,14 +322,14 @@ static int imx322_set_shutter_row(struct vin_device *vdev, u32 row)
 	return 0;
 }
 
-static int imx322_shutter2row(struct vin_device *vdev, u32* shutter_time)
+static int imx322_shutter2row(struct vin_device *vdev, u32 *shutter_time)
 {
 	struct imx322_priv *pinfo = (struct imx322_priv *)vdev->priv;
 	u64 exposure_lines;
 	int rval = 0;
 
 	/* for fast boot, it may call set shutter time directly, so we must read line length/frame line */
-	if(unlikely(!pinfo->line_length)) {
+	if (unlikely(!pinfo->line_length)) {
 		rval = imx322_update_hv_info(vdev);
 		if (rval < 0)
 			return rval;
@@ -325,7 +346,7 @@ static int imx322_shutter2row(struct vin_device *vdev, u32* shutter_time)
 	return rval;
 }
 
-static int imx322_set_fps( struct vin_device *vdev, int fps)
+static int imx322_set_fps(struct vin_device *vdev, int fps)
 {
 	struct imx322_priv *pinfo = (struct imx322_priv *)vdev->priv;
 	u64 v_lines, vb_time;
@@ -334,8 +355,8 @@ static int imx322_set_fps( struct vin_device *vdev, int fps)
 	v_lines = DIV64_CLOSEST(v_lines, pinfo->line_length);
 	v_lines = DIV64_CLOSEST(v_lines, 512000000);
 
-	imx322_write_reg(vdev, IMX322_VMAX_MSB, (v_lines & 0x00FF00) >> 8);
-	imx322_write_reg(vdev, IMX322_VMAX_LSB, v_lines & 0x0000FF);
+	imx322_write_reg(vdev, IMX322_VMAX_MSB, (v_lines >> 8) & 0xFF);
+	imx322_write_reg(vdev, IMX322_VMAX_LSB, v_lines & 0xFF);
 
 	pinfo->frame_length_lines = v_lines;
 
@@ -346,7 +367,7 @@ static int imx322_set_fps( struct vin_device *vdev, int fps)
 	return 0;
 }
 
-static int imx322_set_agc_index( struct vin_device *vdev, int agc_idx)
+static int imx322_set_agc_index(struct vin_device *vdev, int agc_idx)
 {
 	if (agc_idx > IMX322_GAIN_MAX_DB) {
 		vin_warn("agc index %d exceeds maximum %d\n", agc_idx, IMX322_GAIN_MAX_DB);
@@ -358,7 +379,7 @@ static int imx322_set_agc_index( struct vin_device *vdev, int agc_idx)
 }
 
 static int imx322_set_mirror_mode(struct vin_device *vdev,
-		struct vindev_mirror *mirror_mode)
+	struct vindev_mirror *mirror_mode)
 {
 	u32 tmp_reg, readmode, bayer_pattern;
 
@@ -366,6 +387,16 @@ static int imx322_set_mirror_mode(struct vin_device *vdev,
 	case VINDEV_MIRROR_AUTO:
 		return 0;
 
+	case VINDEV_MIRROR_HORRIZONTALLY_VERTICALLY:
+		readmode = IMX322_H_MIRROR | IMX322_V_FLIP;
+		bayer_pattern = VINDEV_BAYER_PATTERN_GB;
+		break;
+
+	case VINDEV_MIRROR_HORRIZONTALLY:
+		readmode = IMX322_H_MIRROR;
+		bayer_pattern = VINDEV_BAYER_PATTERN_GB;
+		break;
+
 	case VINDEV_MIRROR_VERTICALLY:
 		readmode = IMX322_V_FLIP;
 		bayer_pattern = VINDEV_BAYER_PATTERN_GB;
@@ -376,17 +407,15 @@ static int imx322_set_mirror_mode(struct vin_device *vdev,
 		bayer_pattern = VINDEV_BAYER_PATTERN_GB;
 		break;
 
-	case VINDEV_MIRROR_HORRIZONTALLY_VERTICALLY:
-	case VINDEV_MIRROR_HORRIZONTALLY:
 	default:
 		vin_error("do not support cmd mirror mode\n");
 		return -EINVAL;
 	}
 
-	imx322_read_reg(vdev, IMX322_VREVERSE, &tmp_reg);
-	tmp_reg &= ~IMX322_V_FLIP;
+	imx322_read_reg(vdev, IMX322_HVREVERSE, &tmp_reg);
+	tmp_reg &= ~(IMX322_V_FLIP | IMX322_H_MIRROR);
 	tmp_reg |= readmode;
-	imx322_write_reg(vdev, IMX322_VREVERSE, tmp_reg);
+	imx322_write_reg(vdev, IMX322_HVREVERSE, tmp_reg);
 
 	if (mirror_mode->bayer_pattern == VINDEV_BAYER_PATTERN_AUTO)
 		mirror_mode->bayer_pattern = bayer_pattern;
@@ -394,6 +423,30 @@ static int imx322_set_mirror_mode(struct vin_device *vdev,
 	return 0;
 }
 
+#ifdef CONFIG_PM
+static int imx322_suspend(struct vin_device *vdev)
+{
+	u32 i, tmp;
+
+	for (i = 0; i < ARRAY_SIZE(pm_regs); i++) {
+		imx322_read_reg(vdev, pm_regs[i].addr, &tmp);
+		pm_regs[i].data = (u8)tmp;
+	}
+
+	return 0;
+}
+
+static int imx322_resume(struct vin_device *vdev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(pm_regs); i++)
+		imx322_write_reg(vdev, pm_regs[i].addr, pm_regs[i].data);
+
+	return 0;
+}
+#endif
+
 static struct vin_ops imx322_ops = {
 	.init_device		= imx322_init_device,
 	.set_format		= imx322_set_format,
@@ -404,6 +457,10 @@ static struct vin_ops imx322_ops = {
 	.set_mirror_mode	= imx322_set_mirror_mode,
 	.read_reg		= imx322_read_reg,
 	.write_reg		= imx322_write_reg,
+#ifdef CONFIG_PM
+	.suspend		= imx322_suspend,
+	.resume			= imx322_resume,
+#endif
 };
 
 #ifdef CONFIG_SENSOR_IMX322_SPI
@@ -416,7 +473,7 @@ static int imx322_drv_probe(struct ambpriv_device *ambdev)
 	struct imx322_priv *imx322;
 
 	vdev = ambarella_vin_create_device(ambdev->name,
-			SENSOR_IMX322, 	sizeof(struct imx322_priv));
+		SENSOR_IMX322, sizeof(struct imx322_priv));
 	if (!vdev)
 		return -ENOMEM;
 
@@ -490,7 +547,7 @@ static int imx322_probe(struct i2c_client *client,
 	struct imx322_priv *imx322;
 
 	vdev = ambarella_vin_create_device(client->name,
-			SENSOR_IMX322, sizeof(struct imx322_priv));
+		SENSOR_IMX322, sizeof(struct imx322_priv));
 	if (!vdev)
 		return -ENOMEM;
 
diff --git a/drivers/vin/sensors/sony_imx322/imx322.h b/drivers/vin/sensors/sony_imx322/imx322.h
index faa7c81..c92ca5c 100644
--- a/drivers/vin/sensors/sony_imx322/imx322.h
+++ b/drivers/vin/sensors/sony_imx322/imx322.h
@@ -4,21 +4,40 @@
  * History:
  *    2014/08/15 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #ifndef __IMX322_PRI_H__
 #define __IMX322_PRI_H__
 		/* for SPI */
 #ifdef CONFIG_SENSOR_IMX322_SPI
 #define IMX322_STANDBY		0x0200
-#define IMX322_VREVERSE		0x0201
+#define IMX322_HVREVERSE		0x0201
 
 #define IMX322_REG_GAIN		0x021E
 
@@ -33,10 +52,11 @@
 #define IMX322_SHS1_MSB		0x0209
 
 #define IMX322_STREAMING		0x00
+#define IMX322_H_MIRROR		(1<<1)
 #define IMX322_V_FLIP			(1<<0)
 #else	/* for I2C */
 #define IMX322_STANDBY		0x0100
-#define IMX322_VREVERSE		0x0101
+#define IMX322_HVREVERSE		0x0101
 
 #define IMX322_REG_GAIN		0x301E
 
@@ -51,6 +71,7 @@
 #define IMX322_SHS1_LSB		0x0203
 
 #define IMX322_STREAMING		0x01
+#define IMX322_H_MIRROR		(1<<0)
 #define IMX322_V_FLIP			(1<<1)
 #endif
 
diff --git a/drivers/vin/sensors/sony_imx322/imx322_table.c b/drivers/vin/sensors/sony_imx322/imx322_table.c
index 89e9fda..63e672e 100644
--- a/drivers/vin/sensors/sony_imx322/imx322_table.c
+++ b/drivers/vin/sensors/sony_imx322/imx322_table.c
@@ -4,14 +4,33 @@
  * History:
  *    2014/08/15 - [Long Zhao] Create
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 static struct vin_video_pll imx322_plls[] = {
 	{0, 37125000, 37125000},
 };
@@ -19,7 +38,7 @@ static struct vin_video_pll imx322_plls[] = {
 static struct vin_reg_16_8 imx322_mode_regs[][18] = {
 	{	/* 1080P 12bits 30fps */
 #ifdef CONFIG_SENSOR_IMX322_SPI
-		{0x0211, 0x00}, /* FRSEL/OPORTSEL/M12BEN */
+		{0x0211, 0x00}, /* FRSEL */
 		{0x0202, 0x0f}, /* HD1080p mode */
 		{0x0216, 0x3c}, /* WINPV_LSB */
 		{0x0222, 0x40}, /* 720PMODE */
@@ -35,8 +54,9 @@ static struct vin_reg_16_8 imx322_mode_regs[][18] = {
 		{0x0205, 0x65}, /* VMAX_LSB */
 		{0x0206, 0x04}, /* VMAX_MSB */
 		{0x0212, 0x82}, /* ADRES */
+		{0xffff, 0xff},
 #else
-		{0x3011, 0x00}, /* FRSEL/OPORTSEL/M12BEN */
+		{0x3011, 0x00}, /* FRSEL */
 		{0x3012, 0x82}, /* ADRES */
 		{0x3002, 0x0f}, /* HD1080p mode */
 		{0x3016, 0x3c}, /* WINPV_LSB */
@@ -58,7 +78,7 @@ static struct vin_reg_16_8 imx322_mode_regs[][18] = {
 	},
 	{	/* 720P 10bits 60fps */
 #ifdef CONFIG_SENSOR_IMX322_SPI
-		{0x0211, 0x00}, /* FRSEL/OPORTSEL/M12BEN */
+		{0x0211, 0x00}, /* FRSEL */
 		{0x0202, 0x01}, /* HD720p mode */
 		{0x0216, 0xf0}, /* WINPV_LSB */
 		{0x0222, 0xc0}, /* 720PMODE */
@@ -74,8 +94,9 @@ static struct vin_reg_16_8 imx322_mode_regs[][18] = {
 		{0x0205, 0xee}, /* VMAX_LSB */
 		{0x0206, 0x02}, /* VMAX_MSB */
 		{0x0212, 0x80}, /* ADRES */
+		{0xffff, 0xff},
 #else
-		{0x3011, 0x00}, /* FRSEL/OPORTSEL/M12BEN */
+		{0x3011, 0x00}, /* FRSEL */
 		{0x3012, 0x80}, /* ADRES */
 		{0x3002, 0x01}, /* HD720p mode */
 		{0x3016, 0xf0}, /* WINPV_LSB */
@@ -95,6 +116,46 @@ static struct vin_reg_16_8 imx322_mode_regs[][18] = {
 		{0x0343, 0x39}, /* HMAX_LSB */
 #endif
 	},
+	{	/* 720P 12bits 30fps */
+#ifdef CONFIG_SENSOR_IMX322_SPI
+		{0x0211, 0x01}, /* FRSEL */
+		{0x0202, 0x01}, /* HD720p mode */
+		{0x0216, 0xf0}, /* WINPV_LSB */
+		{0x0222, 0xc0}, /* 720PMODE */
+		{0x022D, 0x40}, /* DCKDLY_BITSEL */
+		{0x029a, 0x4c}, /* 12B1080P_LSB */
+		{0x029b, 0x04}, /* 12B1080P_MSB */
+		{0x02ce, 0x40}, /* PRES */
+		{0x02cf, 0x81}, /* DRES_LSB */
+		{0x02d0, 0x01}, /* DRES_MSB */
+		{0x0220, 0xf0}, /* BLKLEVEL */
+		{0x0203, 0x72}, /* HMAX_LSB */
+		{0x0204, 0x06}, /* HMAX_MSB */
+		{0x0205, 0xee}, /* VMAX_LSB */
+		{0x0206, 0x02}, /* VMAX_MSB */
+		{0x0212, 0x82}, /* ADRES */
+		{0xffff, 0xff},
+#else
+		{0x3011, 0x01}, /* FRSEL */
+		{0x3012, 0x82}, /* ADRES */
+		{0x3002, 0x01}, /* HD720p mode */
+		{0x3016, 0xf0}, /* WINPV_LSB */
+		{0x3022, 0xc0}, /* 720PMODE */
+		{0x302D, 0x40}, /* DCKDLY_BITSEL */
+		{0x309a, 0x4c}, /* 12B1080P_LSB */
+		{0x309b, 0x04}, /* 12B1080P_MSB */
+		{0x30ce, 0x40}, /* PRES */
+		{0x30cf, 0x81}, /* DRES_LSB */
+		{0x30d0, 0x01}, /* DRES_MSB */
+		{0x0009, 0xf0}, /* I2C BLKLEVEL */
+		{0x0112, 0x0c}, /* I2C ADRES1 */
+		{0x0113, 0x0c}, /* I2C ADRES2 */
+		{0x0340, 0x02}, /* VMAX_MSB */
+		{0x0341, 0xee}, /* VMAX_LSB */
+		{0x0342, 0x06}, /* HMAX_MSB */
+		{0x0343, 0x72}, /* HMAX_LSB */
+#endif
+	},
 };
 
 static struct vin_video_format imx322_formats[] = {
@@ -140,6 +201,27 @@ static struct vin_video_format imx322_formats[] = {
 		.default_shutter_time	= AMBA_VIDEO_FPS_60,
 		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_GB,
 	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_720P,
+		.def_start_x	= 16+24+8,
+		.def_start_y	= 1+4+6+2+4,
+		.def_width	= 1280,
+		.def_height	= 720,
+		/* sensor mode */
+		.device_mode	= 2,
+		.pll_idx	= 0,
+		.width		= 1280,
+		.height		= 720,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_GB,
+	},
 };
 
 static struct vin_reg_16_8 imx322_share_regs[] = {
@@ -156,8 +238,15 @@ static struct vin_reg_16_8 imx322_share_regs[] = {
 	{0x304f, 0x47}, /* SYNC2_EN */
 	{0x3054, 0x13}, /* SYNCSEL */
 #endif
+};
 
+#ifdef CONFIG_PM
+static struct vin_reg_16_8 pm_regs[] = {
+	{IMX322_SHS1_MSB, 0x00},
+	{IMX322_SHS1_LSB, 0x00},
+	{IMX322_REG_GAIN, 0x00},
 };
+#endif
 
 #define IMX322_GAIN_MAX_DB	0x8C
-#define IMX322_GAIN_ROWS		0x8D
+
diff --git a/drivers/vin/sensors/sony_imx322/make.inc b/drivers/vin/sensors/sony_imx322/make.inc
index 371e0d5..74c2689 100644
--- a/drivers/vin/sensors/sony_imx322/make.inc
+++ b/drivers/vin/sensors/sony_imx322/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/04 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_SENSOR_IMX322), y)
diff --git a/drivers/vin/sensors/sony_imx326/Kbuild b/drivers/vin/sensors/sony_imx326/Kbuild
new file mode 100644
index 0000000..8ddb482
--- /dev/null
+++ b/drivers/vin/sensors/sony_imx326/Kbuild
@@ -0,0 +1,37 @@
+##
+## Kbuild
+##
+## History:
+##    2016/10/17 - [Hao Zeng] created file
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
+EXTRA_AFLAGS		+= $(AMBARELLA_DRV_AFLAGS)
+EXTRA_LDFLAGS		+= $(AMBARELLA_DRV_LDFLAGS)
+
+obj-m := imx326.o
+
diff --git a/drivers/vin/sensors/sony_imx326/imx326.c b/drivers/vin/sensors/sony_imx326/imx326.c
new file mode 100644
index 0000000..5be440b
--- /dev/null
+++ b/drivers/vin/sensors/sony_imx326/imx326.c
@@ -0,0 +1,887 @@
+/*
+ * kernel/private/drivers/vin/sensors/sony_imx326/imx326.c
+ *
+ * History:
+ *    2016/10/17 - [Hao Zeng] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/ambpriv_device.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <plat/spi.h>
+#include <iav_utils.h>
+#include <vin_api.h>
+#include "imx326.h"
+#include "imx326_table.c"
+
+#define IMX326_WRITE_ADDR 0x81
+#define IMX326_READ_ADDR  0x82
+
+static int bus_addr = 0;
+module_param(bus_addr, int, 0644);
+MODULE_PARM_DESC(bus_addr, " bus and cs: bit16~bit31: bus, bit0~bit15: cs");
+
+static int lane = 8;
+module_param(lane, int, 0644);
+MODULE_PARM_DESC(lane, "Set lvds lane number, 8: 8 lane, 10: 10 lane");
+
+struct imx326_priv {
+	struct vindev_wdr_gp_s wdr_again_gp;
+	struct vindev_wdr_gp_s wdr_dgain_gp;
+	struct vindev_wdr_gp_s wdr_shutter_gp;
+	u32 spi_bus;
+	u32 spi_cs;
+	u32 v_lines;
+	u32 h_clks;
+	u32 ori_h_clks;
+	u32 rhs1;
+	u8 lane_num;
+};
+
+static int imx326_write_reg(struct vin_device *vdev, u32 subaddr, u32 data)
+{
+	u8 pbuf[4];
+	amba_spi_cfg_t config;
+	amba_spi_write_t write;
+	struct imx326_priv *imx326;
+
+	imx326 = (struct imx326_priv *)vdev->priv;
+
+	pbuf[0] = IMX326_WRITE_ADDR;
+	pbuf[1] = (subaddr & 0xff00) >> 8;
+	pbuf[2] = subaddr & 0xff;
+	pbuf[3] = data;
+
+	config.cfs_dfs = 8;
+	config.baud_rate = 1000000;
+	config.cs_change = 0;
+	config.spi_mode = SPI_MODE_3 | SPI_LSB_FIRST;
+
+	write.buffer = pbuf;
+	write.n_size = 4;
+	write.cs_id = imx326->spi_cs;
+	write.bus_id = imx326->spi_bus;
+
+	ambarella_spi_write(&config, &write);
+
+	return 0;
+}
+
+static int imx326_write_reg2(struct vin_device *vdev, u16 subaddr, u16 data)
+{
+	u8 pbuf[5];
+	amba_spi_cfg_t config;
+	amba_spi_write_t write;
+	struct imx326_priv *imx326;
+
+	imx326 = (struct imx326_priv *)vdev->priv;
+
+	pbuf[0] = IMX326_WRITE_ADDR;
+	pbuf[1] = (subaddr & 0xff00) >> 8;
+	pbuf[2] = subaddr & 0xff;
+	pbuf[3] = data & 0xff;
+	pbuf[4] = data >> 8;
+
+	config.cfs_dfs = 8;
+	config.baud_rate = 1000000;
+	config.cs_change = 0;
+	config.spi_mode = SPI_MODE_3 | SPI_LSB_FIRST;
+
+	write.buffer = pbuf;
+	write.n_size = 5;
+	write.cs_id = imx326->spi_cs;
+	write.bus_id = imx326->spi_bus;
+
+	ambarella_spi_write(&config, &write);
+
+	return 0;
+}
+
+static int imx326_read_reg(struct vin_device *vdev, u32 subaddr, u32 *pdata)
+{
+	u8 pbuf[4], tmp;
+	amba_spi_cfg_t config;
+	amba_spi_write_then_read_t write;
+	struct imx326_priv *imx326;
+
+	imx326 = (struct imx326_priv *)vdev->priv;
+
+	pbuf[0] = IMX326_READ_ADDR;
+	pbuf[1] = (subaddr & 0xff00) >> 8;
+	pbuf[2] = subaddr&0xFF;
+
+	config.cfs_dfs = 8;
+	config.baud_rate = 1000000;
+	config.cs_change = 0;
+	config.spi_mode = SPI_MODE_3 | SPI_LSB_FIRST;
+
+	write.w_buffer = pbuf;
+	write.w_size = 3;
+	write.r_buffer = &tmp;
+	write.r_size = 1;
+	write.cs_id = imx326->spi_cs;
+	write.bus_id = imx326->spi_bus;
+
+	ambarella_spi_write_then_read(&config, &write);
+
+	*pdata = tmp;
+
+	return 0;
+}
+
+static int imx326_set_vin_mode(struct vin_device *vdev, struct vin_video_format *format)
+{
+	struct imx326_priv *imx326 = (struct imx326_priv *)vdev->priv;
+	struct vin_device_config imx326_config;
+
+	memset(&imx326_config, 0, sizeof(imx326_config));
+
+	imx326_config.interface_type = SENSOR_SERIAL_LVDS;
+	imx326_config.sync_mode = SENSOR_SYNC_MODE_SLAVE;
+
+	if (format->hdr_mode == AMBA_VIDEO_LINEAR_MODE) {
+		imx326_config.slvds_cfg.sync_code_style = SENSOR_SYNC_STYLE_SONY;
+	} else {
+		imx326_config.slvds_cfg.sync_code_style = SENSOR_SYNC_STYLE_SONY_DOL2;
+		/* use split width to make VIN divide the long expo lines */
+		imx326_config.hdr_cfg.split_width =
+			(lane == SENSOR_8_LANE) ? IMX326_H_PERIOD_8LANE : IMX326_H_PERIOD_10LANE;
+		imx326_config.hdr_cfg.num_splits = format->hdr_mode;
+	}
+
+	imx326_config.slvds_cfg.lane_number = imx326->lane_num;
+	switch (imx326->lane_num) {
+	case SENSOR_10_LANE:
+		imx326_config.slvds_cfg.lane_mux_0 = 0x8046;
+		imx326_config.slvds_cfg.lane_mux_1 = 0x3921;
+		imx326_config.slvds_cfg.lane_mux_2 = 0xba75;
+		break;
+	case SENSOR_8_LANE:
+		imx326_config.slvds_cfg.lane_mux_0 = 0x1046;
+		imx326_config.slvds_cfg.lane_mux_1 = 0x7532;
+		imx326_config.slvds_cfg.lane_mux_2 = 0xba98;
+		break;
+	case SENSOR_6_LANE:
+		imx326_config.slvds_cfg.lane_mux_0 = 0x2104;
+		imx326_config.slvds_cfg.lane_mux_1 = 0x7653;
+		imx326_config.slvds_cfg.lane_mux_2 = 0xba98;
+		break;
+	case SENSOR_4_LANE:
+		imx326_config.slvds_cfg.lane_mux_0 = 0x3210;
+		imx326_config.slvds_cfg.lane_mux_1 = 0x7654;
+		imx326_config.slvds_cfg.lane_mux_2 = 0xba98;
+		break;
+	default:
+		vin_error("unsupported lane number %d\n", imx326->lane_num);
+		return -EINVAL;
+	}
+
+	imx326_config.cap_win.x = format->def_start_x;
+	imx326_config.cap_win.y = format->def_start_y;
+	imx326_config.cap_win.width = format->def_width;
+	imx326_config.cap_win.height = format->def_height;
+
+	/* for hdr sensor */
+	imx326_config.hdr_cfg.act_win.x = format->act_start_x;
+	imx326_config.hdr_cfg.act_win.y = format->act_start_y;
+	imx326_config.hdr_cfg.act_win.width = format->act_width;
+	imx326_config.hdr_cfg.act_win.height = format->act_height;
+
+	imx326_config.sensor_id = GENERIC_SENSOR;
+	imx326_config.input_format = AMBA_VIN_INPUT_FORMAT_RGB_RAW;
+	imx326_config.bayer_pattern = format->bayer_pattern;
+	imx326_config.video_format = format->format;
+	imx326_config.bit_resolution = format->bits;
+
+	return ambarella_set_vin_config(vdev, &imx326_config);
+}
+
+static void imx326_sw_reset(struct vin_device *vdev)
+{
+	imx326_write_reg(vdev, IMX326_REG_00, 0x1A);/* STANDBY:0, STBLOGIC:1, STBMIPI:1, STBDV:1 */
+	msleep(10);
+}
+
+static void imx326_start_streaming(struct vin_device *vdev)
+{
+	imx326_write_reg(vdev, IMX326_PLL_CKEN, 0x01);
+	imx326_write_reg(vdev, IMX326_PACKEN, 0x01);
+	imx326_write_reg(vdev, IMX326_REG_00, 0x18);/* STANDBY:0, STBLOGIC:0, STBMIPI:1, STBDV:1 */
+	msleep(10);
+	imx326_write_reg(vdev, IMX326_CLPSQRST, 0x10);
+	imx326_write_reg(vdev, IMX326_DCKRST, 0x01);
+	msleep(10);
+}
+
+static int imx326_set_pll(struct vin_device *vdev, int pll_idx)
+{
+	struct vin_reg_16_8 *regs;
+	int i, regs_num;
+
+	regs = imx326_pll_regs[pll_idx];
+	regs_num = ARRAY_SIZE(imx326_pll_regs[pll_idx]);
+	for (i = 0; i < regs_num; i++)
+		imx326_write_reg(vdev, regs[i].addr, regs[i].data);
+
+	return 0;
+}
+
+static int imx326_init_device(struct vin_device *vdev)
+{
+	imx326_sw_reset(vdev);
+	return 0;
+}
+
+static int imx326_get_line_time(struct vin_device *vdev)
+{
+	u64 h_clks;
+	struct imx326_priv *imx326 = (struct imx326_priv *)vdev->priv;
+
+	h_clks = (u64)imx326->h_clks * 512000000;
+	h_clks = DIV64_CLOSEST(h_clks, vdev->cur_pll->pixelclk);
+
+	vdev->cur_format->line_time = (u32)h_clks;
+
+	return 0;
+}
+
+static int imx326_set_format(struct vin_device *vdev, struct vin_video_format *format)
+{
+	struct imx326_priv *imx326 = (struct imx326_priv *)vdev->priv;
+	struct vin_master_sync master_cfg;
+	struct vin_reg_16_8 *regs;
+	int i, regs_num, rval;
+
+	regs = imx326_share_regs;
+	regs_num = ARRAY_SIZE(imx326_share_regs);
+	for (i = 0; i < regs_num; i++)
+		imx326_write_reg(vdev, regs[i].addr, regs[i].data);
+
+	switch (format->hdr_mode) {
+	case AMBA_VIDEO_LINEAR_MODE:
+		regs = imx326_linear_mode_regs[format->device_mode];
+		regs_num = ARRAY_SIZE(imx326_linear_mode_regs[format->device_mode]);
+
+		switch (format->device_mode) {
+		case 0:
+		case 2:
+		case 4:
+		case 6:
+		case 8:
+			imx326->h_clks = 500;
+			imx326->lane_num = SENSOR_6_LANE;
+			break;
+		case 1:
+		case 3:
+		case 7:
+		case 9:
+			imx326->h_clks = 269;
+			imx326->lane_num = lane;
+			break;
+		case 5:
+			imx326->h_clks = 320;
+			imx326->lane_num = lane;
+			break;
+		default:
+			vin_error("Unsupported device_mode %d\n", format->device_mode);
+			return -EINVAL;
+		}
+		break;
+	case AMBA_VIDEO_2X_HDR_MODE:
+		regs = imx326_hdr_mode_regs[format->device_mode];
+		regs_num = ARRAY_SIZE(imx326_hdr_mode_regs[format->device_mode]);
+
+		/* for DOL mode, set RHS registers */
+		if (format->video_mode == AMBA_VIDEO_MODE_3072_2048) {
+			imx326->rhs1 = IMX326_6M_2X_RHS1;
+		} else if (format->video_mode == AMBA_VIDEO_MODE_QSXGA) {
+			imx326->rhs1 = IMX326_5M_2X_RHS1;
+		} else if (format->video_mode == AMBA_VIDEO_MODE_3072_1728) {
+			imx326->rhs1 = IMX326_5_3M_2X_RHS1;
+		} else if (format->video_mode == AMBA_VIDEO_MODE_2048_2048) {
+			imx326->rhs1 = IMX326_4_2M_2X_RHS1;
+		} else if (format->video_mode == AMBA_VIDEO_MODE_2688_1520) {
+			imx326->rhs1 = IMX326_4M_2X_RHS1;
+		} else {
+			vin_error("Unknown mode\n");
+			return -EINVAL;
+		}
+		imx326->h_clks = 1042;
+		imx326->lane_num = lane;
+		imx326_write_reg2(vdev, IMX326_RHS1_LSB, imx326->rhs1);
+		break;
+	default:
+		regs = NULL;
+		regs_num = 0;
+		vin_error("Unknown mode\n");
+		return -EINVAL;
+	}
+	for (i = 0; i < regs_num; i++)
+		imx326_write_reg(vdev, regs[i].addr, regs[i].data);
+
+	imx326->ori_h_clks = imx326->h_clks;
+	if (imx326->lane_num == SENSOR_8_LANE)
+		imx326_write_reg(vdev, IMX326_REG_03, 0x11);
+	else if (imx326->lane_num == SENSOR_10_LANE)
+		imx326_write_reg(vdev, IMX326_REG_03, 0x00);
+
+	/* we must enable master sync first before sensor cancels standby */
+	master_cfg.hsync_width = 8;
+	master_cfg.vsync_width = 8;
+	master_cfg.hsync_period = imx326->h_clks;
+	master_cfg.vsync_period = 4000;
+	ambarella_set_vin_master_sync(vdev, &master_cfg, true);
+
+	/* TG reset release (Enable Streaming) */
+	imx326_start_streaming(vdev);
+
+	/* communicate with IAV */
+	rval = imx326_set_vin_mode(vdev, format);
+	if (rval < 0)
+		return rval;
+
+	imx326_get_line_time(vdev);
+
+	return 0;
+}
+
+static int imx326_set_shutter_row(struct vin_device *vdev, u32 row)
+{
+	u32 blank_lines;
+	u64 exposure_lines;
+	u32 num_line, max_line, min_line;
+	struct imx326_priv *imx326 = (struct imx326_priv *)vdev->priv;
+	struct vin_video_format *format;
+
+	num_line = row;
+
+	format = vdev->cur_format;
+
+	/* FIXME: shutter width: 4 ~ (Frame format(V) - 12) */
+	min_line = 4;
+	max_line = imx326->v_lines - 12;
+	num_line = clamp(num_line, min_line, max_line);
+
+	/* get the shutter sweep time */
+	blank_lines = imx326->v_lines - num_line;
+	imx326_write_reg2(vdev, IMX326_SHR_LSB, blank_lines);
+
+	exposure_lines = num_line;
+	exposure_lines = exposure_lines * (u64)imx326->h_clks * 512000000;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, vdev->cur_pll->pixelclk);
+
+	vdev->shutter_time = (u32)exposure_lines;
+	vin_debug("shutter_time:%d, row:%d\n", vdev->shutter_time, num_line);
+
+	return 0;
+}
+
+static int imx326_shutter2row(struct vin_device *vdev, u32 *shutter_time)
+{
+	u64 exposure_lines;
+	int rval = 0;
+	struct imx326_priv *imx326 = (struct imx326_priv *)vdev->priv;
+
+	exposure_lines = (*shutter_time) * (u64)vdev->cur_pll->pixelclk;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, imx326->h_clks);
+	exposure_lines = DIV64_CLOSEST(exposure_lines, 512000000);
+
+	*shutter_time = exposure_lines;
+
+	return rval;
+}
+
+static int imx326_set_fps(struct vin_device *vdev, int fps)
+{
+	struct imx326_priv *imx326 = (struct imx326_priv *)vdev->priv;
+	struct vin_master_sync master_cfg;
+	u64 v_lines, vb_time;
+	u32 factor;
+
+	v_lines = fps * (u64)vdev->cur_pll->pixelclk;
+	v_lines = DIV64_CLOSEST(v_lines, imx326->ori_h_clks);
+	v_lines = DIV64_CLOSEST(v_lines, 512000000);
+
+	if (v_lines > 0xFFFF) {
+		vin_debug("h_clks:%d, v_lines:%lld\n", imx326->ori_h_clks, v_lines);
+
+		factor = ((u32)v_lines) / 0xFFFF;
+		v_lines = DIV64_CLOSEST(v_lines, factor + 1);
+		imx326->h_clks = imx326->ori_h_clks * (factor + 1);
+	} else if (imx326->h_clks != imx326->ori_h_clks) {
+		imx326->h_clks = imx326->ori_h_clks;
+	}
+	imx326->v_lines = v_lines;
+
+	imx326_write_reg2(vdev, IMX326_PSLVDS1_LSB, (u16)(v_lines - 0x32));
+	imx326_write_reg2(vdev, IMX326_PSLVDS2_LSB, (u16)(v_lines - 0x32));
+	imx326_write_reg2(vdev, IMX326_PSLVDS3_LSB, (u16)(v_lines - 0x32));
+	imx326_write_reg2(vdev, IMX326_PSLVDS4_LSB, (u16)(v_lines - 0x32));
+
+	vb_time = imx326->h_clks * (u64)(v_lines - vdev->cur_format->height) * 1000000000;
+	vb_time = DIV64_CLOSEST(vb_time, vdev->cur_pll->pixelclk);
+	vdev->cur_format->vb_time = vb_time;
+
+	/* for slave sensor, we must set master sync to set the frame rate */
+	master_cfg.hsync_width = 8;
+	master_cfg.vsync_width = 8;
+	master_cfg.hsync_period = imx326->h_clks;
+	master_cfg.vsync_period = imx326->v_lines;
+	return ambarella_set_vin_master_sync(vdev, &master_cfg, false);
+}
+
+static int imx326_set_agc_index(struct vin_device *vdev, int agc_idx)
+{
+	if (agc_idx > IMX326_GAIN_MAXDB) {
+		vin_error("agc index %d exceeds maximum %d\n", agc_idx, IMX326_GAIN_MAXDB);
+		return -EINVAL;
+	}
+
+	imx326_write_reg2(vdev, IMX326_PGC_LSB, IMX326_GAIN_TABLE[agc_idx][IMX326_GAIN_COL_AGAIN]);
+	imx326_write_reg(vdev, IMX326_DGAIN, IMX326_GAIN_TABLE[agc_idx][IMX326_GAIN_COL_DGAIN]);
+
+	return 0;
+}
+
+static int imx326_set_wdr_again_idx_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_again_gp)
+{
+	struct imx326_priv *imx326 = (struct imx326_priv *)vdev->priv;
+	u32 again_index;
+
+	/* long frame */
+	again_index = p_again_gp->l;
+	imx326_set_agc_index(vdev, again_index);
+
+	memcpy(&(imx326->wdr_again_gp), p_again_gp, sizeof(struct vindev_wdr_gp_s));
+
+	vin_debug("long again index:%d, short1 again index:%d\n",
+		p_again_gp->l, p_again_gp->s1);
+
+	return 0;
+}
+
+static int imx326_get_wdr_again_idx_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_again_gp)
+{
+	struct imx326_priv *imx326 = (struct imx326_priv *)vdev->priv;
+
+	memcpy(p_again_gp, &(imx326->wdr_again_gp), sizeof(struct vindev_wdr_gp_s));
+	return 0;
+}
+
+static int imx326_set_wdr_dgain_idx_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_dgain_gp)
+{
+	struct imx326_priv *imx326 = (struct imx326_priv *)vdev->priv;
+
+	memcpy(&(imx326->wdr_dgain_gp), p_dgain_gp, sizeof(struct vindev_wdr_gp_s));
+	return 0;
+}
+
+static int imx326_get_wdr_dgain_idx_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_dgain_gp)
+{
+	struct imx326_priv *imx326 = (struct imx326_priv *)vdev->priv;
+
+	memcpy(p_dgain_gp, &(imx326->wdr_dgain_gp), sizeof(struct vindev_wdr_gp_s));
+	return 0;
+}
+
+static int imx326_set_wdr_shutter_row_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_shutter_gp)
+{
+	struct imx326_priv *imx326 = (struct imx326_priv *)vdev->priv;
+	u32 fsc, rhs1;
+	u32 shutter_long, shutter_short1;
+	int rval = 0;
+	u64 ratio, fixed_sht_long;
+
+	rhs1 = imx326->rhs1;
+	fsc = imx326->v_lines;
+
+	/* shutter limitation check */
+	if (vdev->cur_format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {
+		if (unlikely(!imx326->h_clks))
+			return -EINVAL;
+
+		/* long shutter */
+		shutter_long = p_shutter_gp->l;
+		/* short shutter 1 */
+		shutter_short1 = p_shutter_gp->s1;
+
+		/* short shutter check */
+		if ((shutter_short1 < 2) || (shutter_short1 > rhs1 - 6)) {
+			vin_error("short shutter:%d exceeds limitation:[2 ~ %d]!\n",
+				shutter_short1, rhs1 - 6);
+			return -EPERM;
+		}
+		/* long shutter check */
+		if ((shutter_long < 4) || (shutter_long > fsc - (rhs1 + 6))) {
+			vin_error("long shutter:%d exceeds limitation:[4 ~ %d]!\n",
+				shutter_long, fsc - (rhs1 + 6));
+			return -EPERM;
+		}
+
+		/* calculate fixed long shutter for expected shutter ratio */
+		#define PRECISE_UNIT 1024
+		ratio = DIV64_CLOSEST((u64)shutter_long * PRECISE_UNIT, shutter_short1);
+		fixed_sht_long = shutter_short1 * PRECISE_UNIT - (PRECISE_UNIT >> 2);
+		fixed_sht_long = (fixed_sht_long * imx326->h_clks + 112 * PRECISE_UNIT) * ratio - 112 * PRECISE_UNIT * PRECISE_UNIT;
+		fixed_sht_long = DIV64_CLOSEST(fixed_sht_long, imx326->h_clks) + PRECISE_UNIT * (PRECISE_UNIT >> 2);
+		fixed_sht_long = DIV64_CLOSEST(fixed_sht_long, PRECISE_UNIT * PRECISE_UNIT);
+
+		shutter_short1 = rhs1 - shutter_short1;
+		imx326_write_reg2(vdev, IMX326_SHR_DOL1_LSB, shutter_short1);
+
+		shutter_long = fsc - (u32)fixed_sht_long;
+		imx326_write_reg2(vdev, IMX326_SHR_DOL2_LSB, shutter_long);
+
+		vin_debug("fsc:%d, shs1:%d, shs2:%d, rhs1:%d, ratio:%llu\n",
+			fsc, shutter_short1, shutter_long, rhs1, ratio);
+	} else {
+		vin_error("Non WDR mode can't support this API: %s!\n", __func__);
+		return -EPERM;
+	}
+
+	memcpy(&(imx326->wdr_shutter_gp),  p_shutter_gp, sizeof(struct vindev_wdr_gp_s));
+
+	return rval;
+}
+
+static int imx326_get_wdr_shutter_row_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_shutter_gp)
+{
+	struct imx326_priv *imx326 = (struct imx326_priv *)vdev->priv;
+	memcpy(p_shutter_gp, &(imx326->wdr_shutter_gp), sizeof(struct vindev_wdr_gp_s));
+
+	return 0;
+}
+
+static int imx326_wdr_shutter2row(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_shutter2row)
+{
+	u64 exposure_time_q9;
+	int rval = 0;
+	struct imx326_priv *imx326 = (struct imx326_priv *)vdev->priv;
+
+	/* long shutter */
+	exposure_time_q9 = p_shutter2row->l;
+	exposure_time_q9 = exposure_time_q9 * (u64)vdev->cur_pll->pixelclk;
+	exposure_time_q9 = DIV64_CLOSEST(exposure_time_q9, imx326->h_clks);
+	exposure_time_q9 = DIV64_CLOSEST(exposure_time_q9, 512000000);
+	p_shutter2row->l = (u32)exposure_time_q9;
+
+	/* short shutter 1 */
+	exposure_time_q9 = p_shutter2row->s1;
+	exposure_time_q9 = exposure_time_q9 * (u64)vdev->cur_pll->pixelclk;
+	exposure_time_q9 = DIV64_CLOSEST(exposure_time_q9, imx326->h_clks);
+	exposure_time_q9 = DIV64_CLOSEST(exposure_time_q9, 512000000);
+	p_shutter2row->s1 = (u32)exposure_time_q9;
+
+	return rval;
+}
+
+static int imx326_set_mirror_mode(struct vin_device *vdev,
+	struct vindev_mirror *mirror_mode)
+{
+	u32 tmp_reg, readmode, bayer_pattern;
+	u32 data_h, data_l;
+
+	switch (mirror_mode->pattern) {
+	case VINDEV_MIRROR_AUTO:
+		return 0;
+
+	case VINDEV_MIRROR_NONE:
+		readmode = 0;
+		bayer_pattern = VINDEV_BAYER_PATTERN_RG;
+		break;
+
+	case VINDEV_MIRROR_VERTICALLY:
+		readmode = IMX326_V_FLIP;
+		bayer_pattern = VINDEV_BAYER_PATTERN_RG;
+		if (vdev->cur_format->mirror_pattern != VINDEV_MIRROR_VERTICALLY) {
+			imx326_read_reg(vdev, IMX326_VWINPOS_LSB, &data_l);
+			imx326_read_reg(vdev, IMX326_VWINPOS_MSB, &data_h);
+			imx326_write_reg2(vdev, IMX326_VWINPOS_LSB, 4096 - (data_l + (data_h << 8)));
+		}
+		break;
+
+	case VINDEV_MIRROR_HORRIZONTALLY:
+	case VINDEV_MIRROR_HORRIZONTALLY_VERTICALLY:
+	default:
+		vin_error("do not support cmd mirror mode\n");
+		return -EINVAL;
+	}
+
+	imx326_read_reg(vdev, IMX326_MDVREV, &tmp_reg);
+	tmp_reg &= ~IMX326_V_FLIP;
+	tmp_reg |= readmode;
+	imx326_write_reg(vdev, IMX326_MDVREV, tmp_reg);
+
+	if (mirror_mode->bayer_pattern == VINDEV_BAYER_PATTERN_AUTO)
+		mirror_mode->bayer_pattern = bayer_pattern;
+
+	return 0;
+}
+
+static int imx326_get_eis_info(struct vin_device *vdev,
+	struct vindev_eisinfo *eis_info)
+{
+	eis_info->sensor_cell_width = 162;/* 1.62 um */
+	eis_info->sensor_cell_height = 162;/* 1.62 um */
+	eis_info->column_bin = 1;
+	eis_info->row_bin = 1;
+	eis_info->vb_time = vdev->cur_format->vb_time;
+
+	return 0;
+}
+
+static int imx326_get_aaa_info(struct vin_device *vdev,
+	struct vindev_aaa_info *aaa_info)
+{
+	struct imx326_priv *pinfo = (struct imx326_priv *)vdev->priv;
+
+	aaa_info->sht0_max = pinfo->v_lines - 2 * 6;
+	aaa_info->sht1_max = pinfo->rhs1 - 6;
+	aaa_info->sht2_max = 0;
+
+	return 0;
+}
+
+static int imx326_aaa_compensation(struct vin_device *vdev,
+	struct vindev_wdr_gp_info *compensation_info)
+{
+	struct imx326_priv *imx326 = (struct imx326_priv *)vdev->priv;
+	u32 fsc, rhs1;
+	u32 shutter_long, shutter_short1;
+	int rval = 0;
+	u64 ratio, fixed_sht_long;
+
+	rhs1 = imx326->rhs1;
+	fsc = imx326->v_lines;
+
+	/* shutter limitation check */
+	if (vdev->cur_format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {
+		if (unlikely(!imx326->h_clks))
+			return -EINVAL;
+
+		/* long shutter */
+		shutter_long = compensation_info->shutter_gp.l;
+		/* short shutter 1 */
+		shutter_short1 = compensation_info->shutter_gp.s1;
+
+		/* short shutter check */
+		if ((shutter_short1 < 2) || (shutter_short1 > rhs1 - 6)) {
+			vin_error("short shutter:%d exceeds limitation:[2 ~ %d]!\n",
+				shutter_short1, rhs1 - 6);
+			return -EPERM;
+		}
+		/* long shutter check */
+		if ((shutter_long < 4) || (shutter_long > fsc - (rhs1 + 6))) {
+			vin_error("long shutter:%d exceeds limitation:[4 ~ %d]!\n",
+				shutter_long, fsc - (rhs1 + 6));
+			return -EPERM;
+		}
+
+		/* calculate fixed long shutter for expected shutter ratio */
+		#define PRECISE_UNIT 1024
+		ratio = DIV64_CLOSEST((u64)shutter_long * PRECISE_UNIT, shutter_short1);
+		fixed_sht_long = shutter_short1 * PRECISE_UNIT - (PRECISE_UNIT >> 2);
+		fixed_sht_long = (fixed_sht_long * imx326->h_clks + 112 * PRECISE_UNIT) * ratio - 112 * PRECISE_UNIT * PRECISE_UNIT;
+		fixed_sht_long = DIV64_CLOSEST(fixed_sht_long, imx326->h_clks) + PRECISE_UNIT * (PRECISE_UNIT >> 2);
+		fixed_sht_long = DIV64_CLOSEST(fixed_sht_long, PRECISE_UNIT * PRECISE_UNIT);
+
+		fixed_sht_long = (fixed_sht_long * PRECISE_UNIT - (PRECISE_UNIT >> 2)) * imx326->h_clks + 112 * PRECISE_UNIT;
+		shutter_short1 = (shutter_short1 * PRECISE_UNIT - (PRECISE_UNIT >> 2)) * imx326->h_clks + 112 * PRECISE_UNIT;
+
+		vin_debug("original shutter long:%d, short:%d, fixed shutter long:%d, short:%d",
+			compensation_info->shutter_gp.l, compensation_info->shutter_gp.s1,
+			(u32)fixed_sht_long, shutter_short1);
+
+		compensation_info->shutter_gp.l = (u32)fixed_sht_long;
+		compensation_info->shutter_gp.s1 = shutter_short1;
+	} else {
+		vin_error("Non WDR mode can't support this API: %s!\n", __func__);
+		return -EPERM;
+	}
+
+	return rval;
+}
+
+#ifdef CONFIG_PM
+static int imx326_suspend(struct vin_device *vdev)
+{
+	u32 i, tmp;
+
+	for (i = 0; i < ARRAY_SIZE(pm_regs); i++) {
+		imx326_read_reg(vdev, pm_regs[i].addr, &tmp);
+		pm_regs[i].data = (u8)tmp;
+	}
+
+	return 0;
+}
+
+static int imx326_resume(struct vin_device *vdev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(pm_regs); i++) {
+		imx326_write_reg(vdev, pm_regs[i].addr, pm_regs[i].data);
+	}
+
+	return 0;
+}
+#endif
+
+static struct vin_ops imx326_ops = {
+	.init_device		= imx326_init_device,
+	.set_pll			= imx326_set_pll,
+	.set_format		= imx326_set_format,
+	.set_shutter_row	= imx326_set_shutter_row,
+	.shutter2row		= imx326_shutter2row,
+	.set_frame_rate	= imx326_set_fps,
+	.set_agc_index		= imx326_set_agc_index,
+	.set_mirror_mode	= imx326_set_mirror_mode,
+	.get_eis_info		= imx326_get_eis_info,
+	.get_aaa_info		= imx326_get_aaa_info,
+	.aaa_compensation	= imx326_aaa_compensation,
+	.read_reg			= imx326_read_reg,
+	.write_reg		= imx326_write_reg,
+#ifdef CONFIG_PM
+	.suspend		= imx326_suspend,
+	.resume			= imx326_resume,
+#endif
+
+	/* for wdr sensor */
+	.set_wdr_again_idx_gp = imx326_set_wdr_again_idx_group,
+	.get_wdr_again_idx_gp = imx326_get_wdr_again_idx_group,
+	.set_wdr_dgain_idx_gp = imx326_set_wdr_dgain_idx_group,
+	.get_wdr_dgain_idx_gp = imx326_get_wdr_dgain_idx_group,
+	.set_wdr_shutter_row_gp = imx326_set_wdr_shutter_row_group,
+	.get_wdr_shutter_row_gp = imx326_get_wdr_shutter_row_group,
+	.wdr_shutter2row = imx326_wdr_shutter2row,
+};
+
+/* ========================================================================== */
+static int imx326_drv_probe(struct ambpriv_device *ambdev)
+{
+	int rval = 0;
+	struct vin_device *vdev;
+	struct imx326_priv *imx326;
+
+	vdev = ambarella_vin_create_device(ambdev->name,
+		SENSOR_IMX326, sizeof(struct imx326_priv));
+
+	if (!vdev)
+		return -ENOMEM;
+
+	vdev->intf_id = 0;
+	vdev->dev_type = VINDEV_TYPE_SENSOR;
+	vdev->sub_type = VINDEV_SUBTYPE_CMOS;
+	vdev->default_mode = AMBA_VIDEO_MODE_3072_2048;
+	vdev->frame_rate = AMBA_VIDEO_FPS_29_97;
+	vdev->agc_db_max = 0x3F000000;  /* 63dB << 24 */
+	vdev->agc_db_min = 0x00000000;  /* 0dB << 24 */
+	vdev->agc_db_step = 0x00180000; /* 0.09375dB */
+	vdev->wdr_again_idx_min = 0;
+	vdev->wdr_again_idx_max = IMX326_GAIN_MAXDB;
+
+	imx326 = (struct imx326_priv *)vdev->priv;
+	imx326->spi_bus = bus_addr >> 16;
+	imx326->spi_cs = bus_addr & 0xffff;
+
+	if ((lane != SENSOR_8_LANE) && (lane != SENSOR_10_LANE)) {
+		vin_error("This driver can only support maximum 8 or 10 lanes serial lvds!\n");
+		rval = -EINVAL;
+		goto imx326_probe_err;
+	}
+
+	rval = ambarella_vin_register_device(vdev, &imx326_ops,
+		imx326_formats, ARRAY_SIZE(imx326_formats),
+		imx326_plls, ARRAY_SIZE(imx326_plls));
+	if (rval < 0)
+		goto imx326_probe_err;
+
+	ambpriv_set_drvdata(ambdev, vdev);
+
+	vin_info("IMX326 init(%d-lane lvds)\n", lane);
+
+	return 0;
+
+imx326_probe_err:
+	ambarella_vin_free_device(vdev);
+	return rval;
+}
+
+static int imx326_drv_remove(struct ambpriv_device *ambdev)
+{
+	struct vin_device *vdev = ambpriv_get_drvdata(ambdev);
+
+	ambarella_vin_unregister_device(vdev);
+	ambarella_vin_free_device(vdev);
+
+	return 0;
+}
+
+static struct ambpriv_driver imx326_driver = {
+	.probe = imx326_drv_probe,
+	.remove = imx326_drv_remove,
+	.driver = {
+		.name = "imx326",
+		.owner = THIS_MODULE,
+	}
+};
+
+static struct ambpriv_device *imx326_device;
+static int __init imx326_init(void)
+{
+	int rval = 0;
+
+	imx326_device = ambpriv_create_bundle(&imx326_driver, NULL, -1, NULL, -1);
+	if (IS_ERR(imx326_device))
+		rval = PTR_ERR(imx326_device);
+
+	return rval;
+}
+
+static void __exit imx326_exit(void)
+{
+	ambpriv_device_unregister(imx326_device);
+	ambpriv_driver_unregister(&imx326_driver);
+}
+
+module_init(imx326_init);
+module_exit(imx326_exit);
+
+MODULE_DESCRIPTION("IMX326 1/2.9-Inch, 3096x2196, 6.80-Megapixel CMOS Digital Image Sensor");
+MODULE_AUTHOR("Hao Zeng, <haozeng@ambarella.com>");
+MODULE_LICENSE("Proprietary");
+
diff --git a/drivers/vin/sensors/sony_imx326/imx326.h b/drivers/vin/sensors/sony_imx326/imx326.h
new file mode 100644
index 0000000..a33f928
--- /dev/null
+++ b/drivers/vin/sensors/sony_imx326/imx326.h
@@ -0,0 +1,168 @@
+/*
+ * kernel/private/drivers/vin/sensors/sony_imx326/imx326.h
+ *
+ * History:
+ *    2016/10/17 - [Hao Zeng] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+
+#ifndef __IMX326_H__
+#define __IMX326_H__
+
+#define IMX326_REG_00		0x0000
+#define IMX326_CLPSQRST	0x0001
+#define IMX326_SSBRK		0x0002
+#define IMX326_REG_03		0x0003
+#define IMX326_MDSEL1		0x0004
+#define IMX326_MDSEL2		0x0005
+#define IMX326_MDSEL3		0x0006
+#define IMX326_MDSEL4		0x0007
+#define IMX326_DCKRST		0x0009
+#define IMX326_PGC_LSB	0x000A
+#define IMX326_PGC_MSB	0x000B
+#define IMX326_SHR_LSB	0x000C
+#define IMX326_SHR_MSB	0x000D
+#define IMX326_SVR_LSB	0x000E
+#define IMX326_SVR_MSB	0x000F
+#define IMX326_DGAIN		0x0012
+#define IMX326_CLPMDCHG	0x0014
+#define IMX326_CLPMODE 	0x0015
+#define IMX326_MDVREV		0x001A
+#define IMX326_SYS_MODE	0x003E
+#define IMX326_BLKLEVEL	0x0045
+#define IMX326_REG_010B	0x010B
+#define IMX326_PLRD1_LSB	0x0120
+#define IMX326_PLRD1_MSB	0x0121
+#define IMX326_PLRD2		0x0122
+#define IMX326_PLRD3		0x0129
+#define IMX326_PLRD4		0x012A
+#define IMX326_PLRD5		0x012D
+
+#define IMX326_PLSTMG01	0x004c
+#define IMX326_PLSTMG02	0x004D
+#define IMX326_PLSTMG03_LSB	0x031C
+#define IMX326_PLSTMG03_MSB	0x031D
+#define IMX326_PLSTMG04	0x0502
+#define IMX326_PLSTMG05	0x0529
+#define IMX326_PLSTMG06	0x052A
+#define IMX326_PLSTMG07	0x052B
+#define IMX326_PLSTMG08	0x0538
+#define IMX326_PLSTMG09	0x0539
+#define IMX326_PLSTMG10	0x0553
+#define IMX326_PLSTMG11	0x057D
+#define IMX326_PLSTMG12	0x057F
+#define IMX326_PLSTMG13	0x0581
+#define IMX326_PLSTMG14	0x0583
+#define IMX326_PLSTMG15	0x0587
+#define IMX326_PLSTMG16	0x05BB
+#define IMX326_PLSTMG17	0x05BC
+#define IMX326_PLSTMG18	0x05BD
+#define IMX326_PLSTMG19	0x05BE
+#define IMX326_PLSTMG20	0x05BF
+#define IMX326_PLSTMG21	0x066E
+#define IMX326_PLSTMG22	0x066F
+#define IMX326_PLSTMG23	0x0670
+#define IMX326_PLSTMG24	0x0671
+
+#define IMX326_MDPLS01_LSB	0x0342
+#define IMX326_MDPLS01_MSB	0x0343
+#define IMX326_MDPLS02_LSB	0x0344
+#define IMX326_MDPLS02_MSB	0x0345
+#define IMX326_MDPLS03	0x0528
+#define IMX326_MDPLS04	0x0554
+#define IMX326_MDPLS05	0x0555
+#define IMX326_MDPLS06	0x0556
+#define IMX326_MDPLS07	0x0557
+#define IMX326_MDPLS08	0x0558
+#define IMX326_MDPLS09	0x0559
+#define IMX326_MDPLS10	0x055A
+#define IMX326_MDPLS11	0x05BA
+#define IMX326_MDPLS12	0x066A
+#define IMX326_MDPLS13	0x066B
+#define IMX326_MDPLS14	0x066C
+#define IMX326_MDPLS15	0x066D
+#define IMX326_MDPLS16	0x03A6
+#define IMX326_MDPLS17	0x006B
+
+#define IMX326_HTRIMMING_EN	0X0037
+#define IMX326_HTRIMMING_START_LSB	0X0038
+#define IMX326_HTRIMMING_START_MSB	0X0039
+#define IMX326_HTRIMMING_END_LSB	0X003A
+#define IMX326_HTRIMMING_END_MSB	0X003B
+#define IMX326_VWIDCUTEN	0x00DD
+#define IMX326_VWIDCUT_LSB	0x00DE
+#define IMX326_VWIDCUT_MSB	0x00DF
+#define IMX326_VWINPOS_LSB	0x00E0
+#define IMX326_VWINPOS_MSB	0x00E1
+#define IMX326_VCUTMODE	0x00E2
+#define IMX326_PLL_CKEN	0x00E6
+#define IMX326_PACKEN	0x00E8
+#define IMX326_PSMOVEN	0x00EE
+#define IMX326_PSLVDS1_LSB	0x032C
+#define IMX326_PSLVDS1_MSB	0x032D
+#define IMX326_PSLVDS2_LSB	0x034A
+#define IMX326_PSLVDS2_MSB	0x034B
+#define IMX326_PSLVDS3_LSB	0x05B6
+#define IMX326_PSLVDS3_MSB	0x05B7
+#define IMX326_PSLVDS4_LSB	0x05B8
+#define IMX326_PSLVDS4_MSB	0x05B9
+
+#define IMX326_DOLMODE	0x0019
+#define IMX326_SHR_DOL1_LSB	0x002E
+#define IMX326_SHR_DOL1_MSB	0x002F
+#define IMX326_SHR_DOL2_LSB	0x0030
+#define IMX326_SHR_DOL2_MSB	0x0031
+#define IMX326_RHS1_LSB	0x0032
+#define IMX326_RHS1_MSB	0x0033
+#define IMX326_DOLSET1	0x0041
+#define IMX326_DOLSET2	0x00E9
+#define IMX326_HCYCLE_LSB	0x0042
+#define IMX326_HCYCLE_MSB	0x0043
+
+#define IMX326_6M_H_PIXEL	(3072+24)
+#define IMX326_5M_H_PIXEL	(2592+24)
+#define IMX326_4M_H_PIXEL	(2688+24)
+#define IMX326_5_3M_H_PIXEL	(3072+24)
+#define IMX326_4_2M_H_PIXEL	(2048+24)
+
+#define IMX326_HCYCLE			260
+
+/* H_PERIOD = HCYCLE x 16 / bit x lane */
+#define IMX326_H_PERIOD_8LANE	(IMX326_HCYCLE * 16 * 8 / 10)
+#define IMX326_H_PERIOD_10LANE	(IMX326_HCYCLE * 16 * 10 / 10)
+
+#define IMX326_6M_2X_RHS1	(140) /* 16:1 shutter ratio */
+#define IMX326_5M_2X_RHS1	(260) /* 8:1 shutter ratio */
+#define IMX326_4M_2X_RHS1	(260) /* 8:1 shutter ratio */
+#define IMX326_5_3M_2X_RHS1	(260) /* 8:1 shutter ratio */
+#define IMX326_4_2M_2X_RHS1	(140) /* 16:1 shutter ratio */
+
+#define IMX326_V_FLIP				(1<<0)
+
+#endif /* __IMX326_H__ */
+
diff --git a/drivers/vin/sensors/sony_imx326/imx326_table.c b/drivers/vin/sensors/sony_imx326/imx326_table.c
new file mode 100644
index 0000000..6c4b54b
--- /dev/null
+++ b/drivers/vin/sensors/sony_imx326/imx326_table.c
@@ -0,0 +1,1806 @@
+/*
+ * kernel/private/drivers/vin/sensors/sony_imx326/imx326_table.c
+ *
+ * History:
+ *    2016/10/17 - [Hao Zeng] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+static struct vin_video_pll imx326_plls[] = {
+	{0, 72000000, 72000000},
+};
+
+static struct vin_reg_16_8 imx326_pll_regs[][6] = {
+	{
+		{IMX326_PLRD1_LSB, 0x80},
+		{IMX326_PLRD1_MSB, 0x00},
+		{IMX326_PLRD2, 0x03},
+		{IMX326_PLRD3, 0x68},
+		{IMX326_PLRD4, 0x03},
+		{IMX326_PLRD5, 0x02},
+	},
+};
+
+static struct vin_reg_16_8 imx326_linear_mode_regs[][39] = {
+	{	/* mode 0: 3072x2048 6ch 12bits 30fps */
+		{IMX326_REG_03, 0x22},
+		{IMX326_MDSEL1, 0x00},
+		{IMX326_MDSEL2, 0x07},
+		{IMX326_MDSEL3, 0x00},
+		{IMX326_MDSEL4, 0xA2},/* arbitrary cropping[7:5] 5h */
+		{IMX326_HTRIMMING_EN, 0x01},
+		{IMX326_HTRIMMING_START_LSB, 0x80},
+		{IMX326_HTRIMMING_START_MSB, 0x01},
+		{IMX326_HTRIMMING_END_LSB, 0x98},
+		{IMX326_HTRIMMING_END_MSB, 0x0D},
+		{IMX326_VWIDCUTEN, 0x01},
+		{IMX326_VWIDCUT_LSB, 0x38},
+		{IMX326_VWIDCUT_MSB, 0x00},
+		{IMX326_VWINPOS_LSB, 0x1C},
+		{IMX326_VWINPOS_MSB, 0x00},
+		{IMX326_VCUTMODE, 0x00},
+		{IMX326_PSMOVEN, 0x01},
+		{IMX326_MDPLS01_LSB, 0xFF},
+		{IMX326_MDPLS01_MSB, 0x01},
+		{IMX326_MDPLS02_LSB, 0xFF},
+		{IMX326_MDPLS02_MSB, 0x01},
+		{IMX326_MDPLS03, 0x0F},
+		{IMX326_MDPLS04, 0x00},
+		{IMX326_MDPLS05, 0x00},
+		{IMX326_MDPLS06, 0x00},
+		{IMX326_MDPLS07, 0x00},
+		{IMX326_MDPLS08, 0x00},
+		{IMX326_MDPLS09, 0x1F},
+		{IMX326_MDPLS10, 0x1F},
+		{IMX326_MDPLS11, 0x0F},
+		{IMX326_MDPLS12, 0x00},
+		{IMX326_MDPLS13, 0x00},
+		{IMX326_MDPLS14, 0x00},
+		{IMX326_MDPLS15, 0x00},
+		{IMX326_MDPLS16, 0x01},
+		{IMX326_MDPLS17, 0x07},
+		/* DOL related */
+		{IMX326_DOLMODE, 0x00},
+		{IMX326_DOLSET1, 0x30},
+		{IMX326_DOLSET2, 0x00},
+	},
+	{	/* mode 1: 3072x2048 8ch 10bits 60fps */
+		{IMX326_REG_03, 0x11},
+		{IMX326_MDSEL1, 0x00},
+		{IMX326_MDSEL2, 0x01},
+		{IMX326_MDSEL3, 0x00},
+		{IMX326_MDSEL4, 0xA2},/* arbitrary cropping[7:5] 5h */
+		{IMX326_HTRIMMING_EN, 0x01},
+		{IMX326_HTRIMMING_START_LSB, 0x80},
+		{IMX326_HTRIMMING_START_MSB, 0x01},
+		{IMX326_HTRIMMING_END_LSB, 0x98},
+		{IMX326_HTRIMMING_END_MSB, 0x0D},
+		{IMX326_VWIDCUTEN, 0x01},
+		{IMX326_VWIDCUT_LSB, 0x38},
+		{IMX326_VWIDCUT_MSB, 0x00},
+		{IMX326_VWINPOS_LSB, 0x1C},
+		{IMX326_VWINPOS_MSB, 0x00},
+		{IMX326_VCUTMODE, 0x00},
+		{IMX326_PSMOVEN, 0x01},
+		{IMX326_MDPLS01_LSB, 0x0A},
+		{IMX326_MDPLS01_MSB, 0x00},
+		{IMX326_MDPLS02_LSB, 0x16},
+		{IMX326_MDPLS02_MSB, 0x00},
+		{IMX326_MDPLS03, 0x0E},
+		{IMX326_MDPLS04, 0x1F},
+		{IMX326_MDPLS05, 0x01},
+		{IMX326_MDPLS06, 0x01},
+		{IMX326_MDPLS07, 0x01},
+		{IMX326_MDPLS08, 0x01},
+		{IMX326_MDPLS09, 0x00},
+		{IMX326_MDPLS10, 0x00},
+		{IMX326_MDPLS11, 0x0E},
+		{IMX326_MDPLS12, 0x1B},
+		{IMX326_MDPLS13, 0x1A},
+		{IMX326_MDPLS14, 0x19},
+		{IMX326_MDPLS15, 0x17},
+		{IMX326_MDPLS16, 0x01},
+		{IMX326_MDPLS17, 0x05},
+		/* DOL related */
+		{IMX326_DOLMODE, 0x00},
+		{IMX326_DOLSET1, 0x30},
+		{IMX326_DOLSET2, 0x00},
+	},
+	{	/* mode 2: 2592x1944 6ch 12bits 30fps */
+		{IMX326_REG_03, 0x22},
+		{IMX326_MDSEL1, 0x00},
+		{IMX326_MDSEL2, 0x07},
+		{IMX326_MDSEL3, 0x00},
+		{IMX326_MDSEL4, 0xA2},
+		{IMX326_HTRIMMING_EN, 0x01},
+		{IMX326_HTRIMMING_START_LSB, 0x70},
+		{IMX326_HTRIMMING_START_MSB, 0x02},
+		{IMX326_HTRIMMING_END_LSB, 0xA8},
+		{IMX326_HTRIMMING_END_MSB, 0x0C},
+		{IMX326_VWIDCUTEN, 0x01},
+		{IMX326_VWIDCUT_LSB, 0x6C},
+		{IMX326_VWIDCUT_MSB, 0x00},
+		{IMX326_VWINPOS_LSB, 0x36},
+		{IMX326_VWINPOS_MSB, 0x00},
+		{IMX326_VCUTMODE, 0x00},
+		{IMX326_PSMOVEN, 0x01},
+		{IMX326_MDPLS01_LSB, 0xFF},
+		{IMX326_MDPLS01_MSB, 0x01},
+		{IMX326_MDPLS02_LSB, 0xFF},
+		{IMX326_MDPLS02_MSB, 0x01},
+		{IMX326_MDPLS03, 0x0F},
+		{IMX326_MDPLS04, 0x00},
+		{IMX326_MDPLS05, 0x00},
+		{IMX326_MDPLS06, 0x00},
+		{IMX326_MDPLS07, 0x00},
+		{IMX326_MDPLS08, 0x00},
+		{IMX326_MDPLS09, 0x1F},
+		{IMX326_MDPLS10, 0x1F},
+		{IMX326_MDPLS11, 0x0F},
+		{IMX326_MDPLS12, 0x00},
+		{IMX326_MDPLS13, 0x00},
+		{IMX326_MDPLS14, 0x00},
+		{IMX326_MDPLS15, 0x00},
+		{IMX326_MDPLS16, 0x01},
+		{IMX326_MDPLS17, 0x07},
+		/* DOL related */
+		{IMX326_DOLMODE, 0x00},
+		{IMX326_DOLSET1, 0x30},
+		{IMX326_DOLSET2, 0x00},
+	},
+	{	/* mode 3: 2592x1944 8ch 10bits 60fps */
+		{IMX326_REG_03, 0x11},
+		{IMX326_MDSEL1, 0x00},
+		{IMX326_MDSEL2, 0x01},
+		{IMX326_MDSEL3, 0x00},
+		{IMX326_MDSEL4, 0xA2},
+		{IMX326_HTRIMMING_EN, 0x01},
+		{IMX326_HTRIMMING_START_LSB, 0x70},
+		{IMX326_HTRIMMING_START_MSB, 0x02},
+		{IMX326_HTRIMMING_END_LSB, 0xA8},
+		{IMX326_HTRIMMING_END_MSB, 0x0C},
+		{IMX326_VWIDCUTEN, 0x01},
+		{IMX326_VWIDCUT_LSB, 0x6C},
+		{IMX326_VWIDCUT_MSB, 0x00},
+		{IMX326_VWINPOS_LSB, 0x36},
+		{IMX326_VWINPOS_MSB, 0x00},
+		{IMX326_VCUTMODE, 0x00},
+		{IMX326_PSMOVEN, 0x01},
+		{IMX326_MDPLS01_LSB, 0x0A},
+		{IMX326_MDPLS01_MSB, 0x00},
+		{IMX326_MDPLS02_LSB, 0x16},
+		{IMX326_MDPLS02_MSB, 0x00},
+		{IMX326_MDPLS03, 0x0E},
+		{IMX326_MDPLS04, 0x1F},
+		{IMX326_MDPLS05, 0x01},
+		{IMX326_MDPLS06, 0x01},
+		{IMX326_MDPLS07, 0x01},
+		{IMX326_MDPLS08, 0x01},
+		{IMX326_MDPLS09, 0x00},
+		{IMX326_MDPLS10, 0x00},
+		{IMX326_MDPLS11, 0x0E},
+		{IMX326_MDPLS12, 0x1B},
+		{IMX326_MDPLS13, 0x1A},
+		{IMX326_MDPLS14, 0x19},
+		{IMX326_MDPLS15, 0x17},
+		{IMX326_MDPLS16, 0x01},
+		{IMX326_MDPLS17, 0x05},
+		/* DOL related */
+		{IMX326_DOLMODE, 0x00},
+		{IMX326_DOLSET1, 0x30},
+		{IMX326_DOLSET2, 0x00},
+	},
+	{	/* mode 4: 3072x1728 6ch 12bits 30fps */
+		{IMX326_REG_03, 0x22},
+		{IMX326_MDSEL1, 0x00},
+		{IMX326_MDSEL2, 0x07},
+		{IMX326_MDSEL3, 0x00},
+		{IMX326_MDSEL4, 0xA2},
+		{IMX326_HTRIMMING_EN, 0x01},
+		{IMX326_HTRIMMING_START_LSB, 0x80},
+		{IMX326_HTRIMMING_START_MSB, 0x01},
+		{IMX326_HTRIMMING_END_LSB, 0x98},
+		{IMX326_HTRIMMING_END_MSB, 0x0D},
+		{IMX326_VWIDCUTEN, 0x01},
+		{IMX326_VWIDCUT_LSB, 0xD8},
+		{IMX326_VWIDCUT_MSB, 0x00},
+		{IMX326_VWINPOS_LSB, 0x6C},
+		{IMX326_VWINPOS_MSB, 0x00},
+		{IMX326_VCUTMODE, 0x00},
+		{IMX326_PSMOVEN, 0x01},
+		{IMX326_MDPLS01_LSB, 0xFF},
+		{IMX326_MDPLS01_MSB, 0x01},
+		{IMX326_MDPLS02_LSB, 0xFF},
+		{IMX326_MDPLS02_MSB, 0x01},
+		{IMX326_MDPLS03, 0x0F},
+		{IMX326_MDPLS04, 0x00},
+		{IMX326_MDPLS05, 0x00},
+		{IMX326_MDPLS06, 0x00},
+		{IMX326_MDPLS07, 0x00},
+		{IMX326_MDPLS08, 0x00},
+		{IMX326_MDPLS09, 0x1F},
+		{IMX326_MDPLS10, 0x1F},
+		{IMX326_MDPLS11, 0x0F},
+		{IMX326_MDPLS12, 0x00},
+		{IMX326_MDPLS13, 0x00},
+		{IMX326_MDPLS14, 0x00},
+		{IMX326_MDPLS15, 0x00},
+		{IMX326_MDPLS16, 0x01},
+		{IMX326_MDPLS17, 0x07},
+		/* DOL related */
+		{IMX326_DOLMODE, 0x00},
+		{IMX326_DOLSET1, 0x30},
+		{IMX326_DOLSET2, 0x00},
+	},
+	{	/* mode 5: 3072x1728 8ch 10bits 60fps */
+		{IMX326_REG_03, 0x11},
+		{IMX326_MDSEL1, 0x00},
+		{IMX326_MDSEL2, 0x01},
+		{IMX326_MDSEL3, 0x00},
+		{IMX326_MDSEL4, 0xA2},
+		{IMX326_HTRIMMING_EN, 0x01},
+		{IMX326_HTRIMMING_START_LSB, 0x80},
+		{IMX326_HTRIMMING_START_MSB, 0x01},
+		{IMX326_HTRIMMING_END_LSB, 0x98},
+		{IMX326_HTRIMMING_END_MSB, 0x0D},
+		{IMX326_VWIDCUTEN, 0x01},
+		{IMX326_VWIDCUT_LSB, 0xD8},
+		{IMX326_VWIDCUT_MSB, 0x00},
+		{IMX326_VWINPOS_LSB, 0x6C},
+		{IMX326_VWINPOS_MSB, 0x00},
+		{IMX326_VCUTMODE, 0x00},
+		{IMX326_PSMOVEN, 0x01},
+		{IMX326_MDPLS01_LSB, 0x0A},
+		{IMX326_MDPLS01_MSB, 0x00},
+		{IMX326_MDPLS02_LSB, 0x16},
+		{IMX326_MDPLS02_MSB, 0x00},
+		{IMX326_MDPLS03, 0x0E},
+		{IMX326_MDPLS04, 0x1F},
+		{IMX326_MDPLS05, 0x01},
+		{IMX326_MDPLS06, 0x01},
+		{IMX326_MDPLS07, 0x01},
+		{IMX326_MDPLS08, 0x01},
+		{IMX326_MDPLS09, 0x00},
+		{IMX326_MDPLS10, 0x00},
+		{IMX326_MDPLS11, 0x0E},
+		{IMX326_MDPLS12, 0x1B},
+		{IMX326_MDPLS13, 0x1A},
+		{IMX326_MDPLS14, 0x19},
+		{IMX326_MDPLS15, 0x17},
+		{IMX326_MDPLS16, 0x01},
+		{IMX326_MDPLS17, 0x05},
+		/* DOL related */
+		{IMX326_DOLMODE, 0x00},
+		{IMX326_DOLSET1, 0x30},
+		{IMX326_DOLSET2, 0x00},
+	},
+	{	/* mode 6: 2048x2048 6ch 12bits 30fps */
+		{IMX326_REG_03, 0x22},
+		{IMX326_MDSEL1, 0x00},
+		{IMX326_MDSEL2, 0x07},
+		{IMX326_MDSEL3, 0x00},
+		{IMX326_MDSEL4, 0xA2},/* arbitrary cropping[7:5] 5h */
+		{IMX326_HTRIMMING_EN, 0x01},
+		{IMX326_HTRIMMING_START_LSB, 0x80},
+		{IMX326_HTRIMMING_START_MSB, 0x03},
+		{IMX326_HTRIMMING_END_LSB, 0x98},
+		{IMX326_HTRIMMING_END_MSB, 0x0B},
+		{IMX326_VWIDCUTEN, 0x01},
+		{IMX326_VWIDCUT_LSB, 0x38},
+		{IMX326_VWIDCUT_MSB, 0x00},
+		{IMX326_VWINPOS_LSB, 0x1C},
+		{IMX326_VWINPOS_MSB, 0x00},
+		{IMX326_VCUTMODE, 0x00},
+		{IMX326_PSMOVEN, 0x01},
+		{IMX326_MDPLS01_LSB, 0xFF},
+		{IMX326_MDPLS01_MSB, 0x01},
+		{IMX326_MDPLS02_LSB, 0xFF},
+		{IMX326_MDPLS02_MSB, 0x01},
+		{IMX326_MDPLS03, 0x0F},
+		{IMX326_MDPLS04, 0x00},
+		{IMX326_MDPLS05, 0x00},
+		{IMX326_MDPLS06, 0x00},
+		{IMX326_MDPLS07, 0x00},
+		{IMX326_MDPLS08, 0x00},
+		{IMX326_MDPLS09, 0x1F},
+		{IMX326_MDPLS10, 0x1F},
+		{IMX326_MDPLS11, 0x0F},
+		{IMX326_MDPLS12, 0x00},
+		{IMX326_MDPLS13, 0x00},
+		{IMX326_MDPLS14, 0x00},
+		{IMX326_MDPLS15, 0x00},
+		{IMX326_MDPLS16, 0x01},
+		{IMX326_MDPLS17, 0x07},
+		/* DOL related */
+		{IMX326_DOLMODE, 0x00},
+		{IMX326_DOLSET1, 0x30},
+		{IMX326_DOLSET2, 0x00},
+	},
+	{	/* mode 7: 2048x2048 8ch 10bits 60fps */
+		{IMX326_REG_03, 0x11},
+		{IMX326_MDSEL1, 0x00},
+		{IMX326_MDSEL2, 0x01},
+		{IMX326_MDSEL3, 0x00},
+		{IMX326_MDSEL4, 0xA2},/* arbitrary cropping[7:5] 5h */
+		{IMX326_HTRIMMING_EN, 0x01},
+		{IMX326_HTRIMMING_START_LSB, 0x80},
+		{IMX326_HTRIMMING_START_MSB, 0x03},
+		{IMX326_HTRIMMING_END_LSB, 0x98},
+		{IMX326_HTRIMMING_END_MSB, 0x0B},
+		{IMX326_VWIDCUTEN, 0x01},
+		{IMX326_VWIDCUT_LSB, 0x38},
+		{IMX326_VWIDCUT_MSB, 0x00},
+		{IMX326_VWINPOS_LSB, 0x1C},
+		{IMX326_VWINPOS_MSB, 0x00},
+		{IMX326_VCUTMODE, 0x00},
+		{IMX326_PSMOVEN, 0x01},
+		{IMX326_MDPLS01_LSB, 0x0A},
+		{IMX326_MDPLS01_MSB, 0x00},
+		{IMX326_MDPLS02_LSB, 0x16},
+		{IMX326_MDPLS02_MSB, 0x00},
+		{IMX326_MDPLS03, 0x0E},
+		{IMX326_MDPLS04, 0x1F},
+		{IMX326_MDPLS05, 0x01},
+		{IMX326_MDPLS06, 0x01},
+		{IMX326_MDPLS07, 0x01},
+		{IMX326_MDPLS08, 0x01},
+		{IMX326_MDPLS09, 0x00},
+		{IMX326_MDPLS10, 0x00},
+		{IMX326_MDPLS11, 0x0E},
+		{IMX326_MDPLS12, 0x1B},
+		{IMX326_MDPLS13, 0x1A},
+		{IMX326_MDPLS14, 0x19},
+		{IMX326_MDPLS15, 0x17},
+		{IMX326_MDPLS16, 0x01},
+		{IMX326_MDPLS17, 0x05},
+		/* DOL related */
+		{IMX326_DOLMODE, 0x00},
+		{IMX326_DOLSET1, 0x30},
+		{IMX326_DOLSET2, 0x00},
+	},
+	{	/* mode 8: 2688x1520 6ch 12bits 30fps */
+		{IMX326_REG_03, 0x22},
+		{IMX326_MDSEL1, 0x00},
+		{IMX326_MDSEL2, 0x07},
+		{IMX326_MDSEL3, 0x00},
+		{IMX326_MDSEL4, 0xA2},
+		{IMX326_HTRIMMING_EN, 0x01},
+		{IMX326_HTRIMMING_START_LSB, 0x40},
+		{IMX326_HTRIMMING_START_MSB, 0x02},
+		{IMX326_HTRIMMING_END_LSB, 0xD8},
+		{IMX326_HTRIMMING_END_MSB, 0x0C},
+		{IMX326_VWIDCUTEN, 0x01},
+		{IMX326_VWIDCUT_LSB, 0x40},
+		{IMX326_VWIDCUT_MSB, 0x01},
+		{IMX326_VWINPOS_LSB, 0xA0},
+		{IMX326_VWINPOS_MSB, 0x00},
+		{IMX326_VCUTMODE, 0x00},
+		{IMX326_PSMOVEN, 0x01},
+		{IMX326_MDPLS01_LSB, 0xFF},
+		{IMX326_MDPLS01_MSB, 0x01},
+		{IMX326_MDPLS02_LSB, 0xFF},
+		{IMX326_MDPLS02_MSB, 0x01},
+		{IMX326_MDPLS03, 0x0F},
+		{IMX326_MDPLS04, 0x00},
+		{IMX326_MDPLS05, 0x00},
+		{IMX326_MDPLS06, 0x00},
+		{IMX326_MDPLS07, 0x00},
+		{IMX326_MDPLS08, 0x00},
+		{IMX326_MDPLS09, 0x1F},
+		{IMX326_MDPLS10, 0x1F},
+		{IMX326_MDPLS11, 0x0F},
+		{IMX326_MDPLS12, 0x00},
+		{IMX326_MDPLS13, 0x00},
+		{IMX326_MDPLS14, 0x00},
+		{IMX326_MDPLS15, 0x00},
+		{IMX326_MDPLS16, 0x01},
+		{IMX326_MDPLS17, 0x07},
+		/* DOL related */
+		{IMX326_DOLMODE, 0x00},
+		{IMX326_DOLSET1, 0x30},
+		{IMX326_DOLSET2, 0x00},
+	},
+	{	/* mode 9: 2688x1520 8ch 10bits 60fps */
+		{IMX326_REG_03, 0x11},
+		{IMX326_MDSEL1, 0x00},
+		{IMX326_MDSEL2, 0x01},
+		{IMX326_MDSEL3, 0x00},
+		{IMX326_MDSEL4, 0xA2},
+		{IMX326_HTRIMMING_EN, 0x01},
+		{IMX326_HTRIMMING_START_LSB, 0x40},
+		{IMX326_HTRIMMING_START_MSB, 0x02},
+		{IMX326_HTRIMMING_END_LSB, 0xD8},
+		{IMX326_HTRIMMING_END_MSB, 0x0C},
+		{IMX326_VWIDCUTEN, 0x01},
+		{IMX326_VWIDCUT_LSB, 0x40},
+		{IMX326_VWIDCUT_MSB, 0x01},
+		{IMX326_VWINPOS_LSB, 0xA0},
+		{IMX326_VWINPOS_MSB, 0x00},
+		{IMX326_VCUTMODE, 0x00},
+		{IMX326_PSMOVEN, 0x01},
+		{IMX326_MDPLS01_LSB, 0x0A},
+		{IMX326_MDPLS01_MSB, 0x00},
+		{IMX326_MDPLS02_LSB, 0x16},
+		{IMX326_MDPLS02_MSB, 0x00},
+		{IMX326_MDPLS03, 0x0E},
+		{IMX326_MDPLS04, 0x1F},
+		{IMX326_MDPLS05, 0x01},
+		{IMX326_MDPLS06, 0x01},
+		{IMX326_MDPLS07, 0x01},
+		{IMX326_MDPLS08, 0x01},
+		{IMX326_MDPLS09, 0x00},
+		{IMX326_MDPLS10, 0x00},
+		{IMX326_MDPLS11, 0x0E},
+		{IMX326_MDPLS12, 0x1B},
+		{IMX326_MDPLS13, 0x1A},
+		{IMX326_MDPLS14, 0x19},
+		{IMX326_MDPLS15, 0x17},
+		{IMX326_MDPLS16, 0x01},
+		{IMX326_MDPLS17, 0x05},
+		/* DOL related */
+		{IMX326_DOLMODE, 0x00},
+		{IMX326_DOLSET1, 0x30},
+		{IMX326_DOLSET2, 0x00},
+	},
+};
+
+static struct vin_reg_16_8 imx326_hdr_mode_regs[][45] = {
+	{	/* DOL mode 0: 3072x2048 8ch 10bits 30fps */
+		{IMX326_REG_03, 0x11},
+		{IMX326_MDSEL1, 0x05},
+		{IMX326_MDSEL2, 0x01},
+		{IMX326_MDSEL3, 0x00},
+		{IMX326_MDSEL4, 0xA2},/* for VCUT offset, {IMX326_MDSEL4, 0x02}, */
+		{IMX326_HTRIMMING_EN, 0x01},
+		{IMX326_HTRIMMING_START_LSB, 0x80},
+		{IMX326_HTRIMMING_START_MSB, 0x01},
+		{IMX326_HTRIMMING_END_LSB, 0x98},
+		{IMX326_HTRIMMING_END_MSB, 0x0D},
+		{IMX326_VWIDCUTEN, 0x01},
+		{IMX326_VWIDCUT_LSB, 0x38},
+		{IMX326_VWIDCUT_MSB, 0x00},
+		{IMX326_VWINPOS_LSB, 0x1C},
+		{IMX326_VWINPOS_MSB, 0x00},
+		{IMX326_VCUTMODE, 0x00},
+		{IMX326_PSMOVEN, 0x01},
+		{IMX326_MDPLS01_LSB, 0x0A},
+		{IMX326_MDPLS01_MSB, 0x00},
+		{IMX326_MDPLS02_LSB, 0x16},
+		{IMX326_MDPLS02_MSB, 0x00},
+		{IMX326_MDPLS03, 0x0E},
+		{IMX326_MDPLS04, 0x1F},
+		{IMX326_MDPLS05, 0x01},
+		{IMX326_MDPLS06, 0x01},
+		{IMX326_MDPLS07, 0x01},
+		{IMX326_MDPLS08, 0x01},
+		{IMX326_MDPLS09, 0x00},
+		{IMX326_MDPLS10, 0x00},
+		{IMX326_MDPLS11, 0x0E},
+		{IMX326_MDPLS12, 0x1B},
+		{IMX326_MDPLS13, 0x1A},
+		{IMX326_MDPLS14, 0x19},
+		{IMX326_MDPLS15, 0x17},
+		{IMX326_MDPLS16, 0x01},
+		{IMX326_MDPLS17, 0x05},
+		/* DOL related */
+		{IMX326_DOLMODE, 0x01},
+		{IMX326_DOLSET1, 0x31},
+		{IMX326_DOLSET2, 0x01},
+		{IMX326_HCYCLE_LSB, IMX326_HCYCLE & 0xFF},
+		{IMX326_HCYCLE_MSB, IMX326_HCYCLE >> 8},
+		{IMX326_SHR_DOL1_LSB, 0x06},
+		{IMX326_SHR_DOL1_MSB, 0x00},
+		{IMX326_SHR_DOL2_LSB, 0xEE},
+		{IMX326_SHR_DOL2_MSB, 0x02},
+	},
+	{	/* DOL mode 1: 2592x1944 8ch 10bits 30fps */
+		{IMX326_REG_03, 0x11},
+		{IMX326_MDSEL1, 0x05},
+		{IMX326_MDSEL2, 0x01},
+		{IMX326_MDSEL3, 0x00},
+		{IMX326_MDSEL4, 0xA2},/* for VCUT offset, {IMX326_MDSEL4, 0x02}, */
+		{IMX326_HTRIMMING_EN, 0x01},
+		{IMX326_HTRIMMING_START_LSB, 0x70},
+		{IMX326_HTRIMMING_START_MSB, 0x02},
+		{IMX326_HTRIMMING_END_LSB, 0xA8},
+		{IMX326_HTRIMMING_END_MSB, 0x0C},
+		{IMX326_VWIDCUTEN, 0x01},
+		{IMX326_VWIDCUT_LSB, 0x6C},
+		{IMX326_VWIDCUT_MSB, 0x00},
+		{IMX326_VWINPOS_LSB, 0x36},
+		{IMX326_VWINPOS_MSB, 0x00},
+		{IMX326_VCUTMODE, 0x00},
+		{IMX326_PSMOVEN, 0x01},
+		{IMX326_MDPLS01_LSB, 0x0A},
+		{IMX326_MDPLS01_MSB, 0x00},
+		{IMX326_MDPLS02_LSB, 0x16},
+		{IMX326_MDPLS02_MSB, 0x00},
+		{IMX326_MDPLS03, 0x0E},
+		{IMX326_MDPLS04, 0x1F},
+		{IMX326_MDPLS05, 0x01},
+		{IMX326_MDPLS06, 0x01},
+		{IMX326_MDPLS07, 0x01},
+		{IMX326_MDPLS08, 0x01},
+		{IMX326_MDPLS09, 0x00},
+		{IMX326_MDPLS10, 0x00},
+		{IMX326_MDPLS11, 0x0E},
+		{IMX326_MDPLS12, 0x1B},
+		{IMX326_MDPLS13, 0x1A},
+		{IMX326_MDPLS14, 0x19},
+		{IMX326_MDPLS15, 0x17},
+		{IMX326_MDPLS16, 0x01},
+		{IMX326_MDPLS17, 0x05},
+		/* DOL related */
+		{IMX326_DOLMODE, 0x01},
+		{IMX326_DOLSET1, 0x31},
+		{IMX326_DOLSET2, 0x01},
+		{IMX326_HCYCLE_LSB, IMX326_HCYCLE & 0xFF},
+		{IMX326_HCYCLE_MSB, IMX326_HCYCLE >> 8},
+		{IMX326_SHR_DOL1_LSB, 0x06},
+		{IMX326_SHR_DOL1_MSB, 0x00},
+		{IMX326_SHR_DOL2_LSB, 0xEE},
+		{IMX326_SHR_DOL2_MSB, 0x02},
+	},
+	{	/* DOL mode 2: 3072x1728 8ch 10bits 30fps */
+		{IMX326_REG_03, 0x11},
+		{IMX326_MDSEL1, 0x05},
+		{IMX326_MDSEL2, 0x01},
+		{IMX326_MDSEL3, 0x00},
+		{IMX326_MDSEL4, 0xA2},/* for VCUT offset, {IMX326_MDSEL4, 0x02}, */
+		{IMX326_HTRIMMING_EN, 0x01},
+		{IMX326_HTRIMMING_START_LSB, 0x80},
+		{IMX326_HTRIMMING_START_MSB, 0x01},
+		{IMX326_HTRIMMING_END_LSB, 0x98},
+		{IMX326_HTRIMMING_END_MSB, 0x0D},
+		{IMX326_VWIDCUTEN, 0x01},
+		{IMX326_VWIDCUT_LSB, 0xD8},
+		{IMX326_VWIDCUT_MSB, 0x00},
+		{IMX326_VWINPOS_LSB, 0x6C},
+		{IMX326_VWINPOS_MSB, 0x00},
+		{IMX326_VCUTMODE, 0x00},
+		{IMX326_PSMOVEN, 0x01},
+		{IMX326_MDPLS01_LSB, 0x0A},
+		{IMX326_MDPLS01_MSB, 0x00},
+		{IMX326_MDPLS02_LSB, 0x16},
+		{IMX326_MDPLS02_MSB, 0x00},
+		{IMX326_MDPLS03, 0x0E},
+		{IMX326_MDPLS04, 0x1F},
+		{IMX326_MDPLS05, 0x01},
+		{IMX326_MDPLS06, 0x01},
+		{IMX326_MDPLS07, 0x01},
+		{IMX326_MDPLS08, 0x01},
+		{IMX326_MDPLS09, 0x00},
+		{IMX326_MDPLS10, 0x00},
+		{IMX326_MDPLS11, 0x0E},
+		{IMX326_MDPLS12, 0x1B},
+		{IMX326_MDPLS13, 0x1A},
+		{IMX326_MDPLS14, 0x19},
+		{IMX326_MDPLS15, 0x17},
+		{IMX326_MDPLS16, 0x01},
+		{IMX326_MDPLS17, 0x05},
+		/* DOL related */
+		{IMX326_DOLMODE, 0x01},
+		{IMX326_DOLSET1, 0x31},
+		{IMX326_DOLSET2, 0x01},
+		{IMX326_HCYCLE_LSB, IMX326_HCYCLE & 0xFF},
+		{IMX326_HCYCLE_MSB, IMX326_HCYCLE >> 8},
+		{IMX326_SHR_DOL1_LSB, 0x06},
+		{IMX326_SHR_DOL1_MSB, 0x00},
+		{IMX326_SHR_DOL2_LSB, 0xEE},
+		{IMX326_SHR_DOL2_MSB, 0x02},
+	},
+	{	/* DOL mode 3: 2048x2048 8ch 10bits 30fps */
+		{IMX326_REG_03, 0x11},
+		{IMX326_MDSEL1, 0x05},
+		{IMX326_MDSEL2, 0x01},
+		{IMX326_MDSEL3, 0x00},
+		{IMX326_MDSEL4, 0xA2},/* for VCUT offset, {IMX326_MDSEL4, 0x02}, */
+		{IMX326_HTRIMMING_EN, 0x01},
+		{IMX326_HTRIMMING_START_LSB, 0x80},
+		{IMX326_HTRIMMING_START_MSB, 0x03},
+		{IMX326_HTRIMMING_END_LSB, 0x98},
+		{IMX326_HTRIMMING_END_MSB, 0x0B},
+		{IMX326_VWIDCUTEN, 0x01},
+		{IMX326_VWIDCUT_LSB, 0x38},
+		{IMX326_VWIDCUT_MSB, 0x00},
+		{IMX326_VWINPOS_LSB, 0x1C},
+		{IMX326_VWINPOS_MSB, 0x00},
+		{IMX326_VCUTMODE, 0x00},
+		{IMX326_PSMOVEN, 0x01},
+		{IMX326_MDPLS01_LSB, 0x0A},
+		{IMX326_MDPLS01_MSB, 0x00},
+		{IMX326_MDPLS02_LSB, 0x16},
+		{IMX326_MDPLS02_MSB, 0x00},
+		{IMX326_MDPLS03, 0x0E},
+		{IMX326_MDPLS04, 0x1F},
+		{IMX326_MDPLS05, 0x01},
+		{IMX326_MDPLS06, 0x01},
+		{IMX326_MDPLS07, 0x01},
+		{IMX326_MDPLS08, 0x01},
+		{IMX326_MDPLS09, 0x00},
+		{IMX326_MDPLS10, 0x00},
+		{IMX326_MDPLS11, 0x0E},
+		{IMX326_MDPLS12, 0x1B},
+		{IMX326_MDPLS13, 0x1A},
+		{IMX326_MDPLS14, 0x19},
+		{IMX326_MDPLS15, 0x17},
+		{IMX326_MDPLS16, 0x01},
+		{IMX326_MDPLS17, 0x05},
+		/* DOL related */
+		{IMX326_DOLMODE, 0x01},
+		{IMX326_DOLSET1, 0x31},
+		{IMX326_DOLSET2, 0x01},
+		{IMX326_HCYCLE_LSB, IMX326_HCYCLE & 0xFF},
+		{IMX326_HCYCLE_MSB, IMX326_HCYCLE >> 8},
+		{IMX326_SHR_DOL1_LSB, 0x06},
+		{IMX326_SHR_DOL1_MSB, 0x00},
+		{IMX326_SHR_DOL2_LSB, 0xEE},
+		{IMX326_SHR_DOL2_MSB, 0x02},
+	},
+	{	/* DOL mode 4: 2688x1520 8ch 10bits 30fps */
+		{IMX326_REG_03, 0x11},
+		{IMX326_MDSEL1, 0x05},
+		{IMX326_MDSEL2, 0x01},
+		{IMX326_MDSEL3, 0x00},
+		{IMX326_MDSEL4, 0xA2},/* for VCUT offset, {IMX326_MDSEL4, 0x02}, */
+		{IMX326_HTRIMMING_EN, 0x01},
+		{IMX326_HTRIMMING_START_LSB, 0x40},
+		{IMX326_HTRIMMING_START_MSB, 0x02},
+		{IMX326_HTRIMMING_END_LSB, 0xD8},
+		{IMX326_HTRIMMING_END_MSB, 0x0C},
+		{IMX326_VWIDCUTEN, 0x01},
+		{IMX326_VWIDCUT_LSB, 0x40},
+		{IMX326_VWIDCUT_MSB, 0x01},
+		{IMX326_VWINPOS_LSB, 0xA0},
+		{IMX326_VWINPOS_MSB, 0x00},
+		{IMX326_VCUTMODE, 0x00},
+		{IMX326_PSMOVEN, 0x01},
+		{IMX326_MDPLS01_LSB, 0x0A},
+		{IMX326_MDPLS01_MSB, 0x00},
+		{IMX326_MDPLS02_LSB, 0x16},
+		{IMX326_MDPLS02_MSB, 0x00},
+		{IMX326_MDPLS03, 0x0E},
+		{IMX326_MDPLS04, 0x1F},
+		{IMX326_MDPLS05, 0x01},
+		{IMX326_MDPLS06, 0x01},
+		{IMX326_MDPLS07, 0x01},
+		{IMX326_MDPLS08, 0x01},
+		{IMX326_MDPLS09, 0x00},
+		{IMX326_MDPLS10, 0x00},
+		{IMX326_MDPLS11, 0x0E},
+		{IMX326_MDPLS12, 0x1B},
+		{IMX326_MDPLS13, 0x1A},
+		{IMX326_MDPLS14, 0x19},
+		{IMX326_MDPLS15, 0x17},
+		{IMX326_MDPLS16, 0x01},
+		{IMX326_MDPLS17, 0x05},
+		/* DOL related */
+		{IMX326_DOLMODE, 0x01},
+		{IMX326_DOLSET1, 0x31},
+		{IMX326_DOLSET2, 0x01},
+		{IMX326_HCYCLE_LSB, IMX326_HCYCLE & 0xFF},
+		{IMX326_HCYCLE_MSB, IMX326_HCYCLE >> 8},
+		{IMX326_SHR_DOL1_LSB, 0x06},
+		{IMX326_SHR_DOL1_MSB, 0x00},
+		{IMX326_SHR_DOL2_LSB, 0xEE},
+		{IMX326_SHR_DOL2_MSB, 0x02},
+	},
+};
+
+static struct vin_video_format imx326_formats[] = {
+	{
+		.video_mode	= AMBA_VIDEO_MODE_3072_2048,
+		.def_start_x	= 12,
+		.def_start_y	= 16 + 6 + 18,
+		.def_width	= 3072,
+		.def_height	= 2048,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_LINEAR_MODE,
+		.device_mode	= 0,
+		.pll_idx	= 0,
+		.width		= 3072,
+		.height		= 2048,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_3072_2048,
+		.def_start_x	= 12,
+		.def_start_y	= 16 + 6 + 18,
+		.def_width	= 3072,
+		.def_height	= 2048,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_LINEAR_MODE,
+		.device_mode	= 1,
+		.pll_idx	= 0,
+		.width		= 3072,
+		.height		= 2048,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_10,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_60,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_QSXGA,
+		.def_start_x	= 12,
+		.def_start_y	= 16 + 6 + 18,
+		.def_width	= 2592,
+		.def_height	= 1944,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_LINEAR_MODE,
+		.device_mode	= 2,
+		.pll_idx	= 0,
+		.width		= 2592,
+		.height		= 1944,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_4_3,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_QSXGA,
+		.def_start_x	= 12,
+		.def_start_y	= 16 + 6 + 18,
+		.def_width	= 2592,
+		.def_height	= 1944,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_LINEAR_MODE,
+		.device_mode	= 3,
+		.pll_idx	= 0,
+		.width		= 2592,
+		.height		= 1944,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_10,
+		.ratio		= AMBA_VIDEO_RATIO_4_3,
+		.max_fps	= AMBA_VIDEO_FPS_60,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_3072_1728,
+		.def_start_x	= 12,
+		.def_start_y	= 16 + 6 + 18,
+		.def_width	= 3072,
+		.def_height	= 1728,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_LINEAR_MODE,
+		.device_mode	= 4,
+		.pll_idx	= 0,
+		.width		= 3072,
+		.height		= 1728,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_3072_1728,
+		.def_start_x	= 12,
+		.def_start_y	= 16 + 6 + 18,
+		.def_width	= 3072,
+		.def_height	= 1728,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_LINEAR_MODE,
+		.device_mode	= 5,
+		.pll_idx	= 0,
+		.width		= 3072,
+		.height		= 1728,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_10,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_60,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_2048_2048,
+		.def_start_x	= 12,
+		.def_start_y	= 16 + 6 + 18,
+		.def_width	= 2048,
+		.def_height	= 2048,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_LINEAR_MODE,
+		.device_mode	= 6,
+		.pll_idx	= 0,
+		.width		= 2048,
+		.height		= 2048,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_1_1,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_2048_2048,
+		.def_start_x	= 12,
+		.def_start_y	= 16 + 6 + 18,
+		.def_width	= 2048,
+		.def_height	= 2048,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_LINEAR_MODE,
+		.device_mode	= 7,
+		.pll_idx	= 0,
+		.width		= 2048,
+		.height		= 2048,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_10,
+		.ratio		= AMBA_VIDEO_RATIO_1_1,
+		.max_fps	= AMBA_VIDEO_FPS_60,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_2688_1520,
+		.def_start_x	= 12,
+		.def_start_y	= 16 + 6 + 18,
+		.def_width	= 2688,
+		.def_height	= 1520,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_LINEAR_MODE,
+		.device_mode	= 8,
+		.pll_idx	= 0,
+		.width		= 2688,
+		.height		= 1520,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_2688_1520,
+		.def_start_x	= 12,
+		.def_start_y	= 16 + 6 + 18,
+		.def_width	= 2688,
+		.def_height	= 1520,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_LINEAR_MODE,
+		.device_mode	= 9,
+		.pll_idx	= 0,
+		.width		= 2688,
+		.height		= 1520,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_10,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_60,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+	},
+	/* 2X DOL HDR MODE */
+	{
+		.video_mode	= AMBA_VIDEO_MODE_3072_2048,
+		.def_start_x	= 12,
+		.def_start_y	= (16 + 6 + 18) * 2,
+		.def_width	= 3072,
+		.def_height	= (2048 + IMX326_6M_2X_RHS1) * 2, /* (2048 + VBP1)*2 */
+		.act_start_x	= 0,
+		.act_start_y	= 0,
+		.act_width	= 3072,
+		.act_height	= 2048,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_2X_HDR_MODE,
+		.device_mode	= 0,
+		.pll_idx	= 0,
+		.width		= 3072 * 2,
+		.height		= 2048,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_10,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+		.hdr_long_offset = 0,
+		.hdr_short1_offset = IMX326_6M_2X_RHS1 * 2 + 1,/* 2 x VBP1 + 1 */
+	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_QSXGA,
+		.def_start_x	= 12,
+		.def_start_y	= (16 + 6 + 18) * 2,
+		.def_width	= 2592,
+		.def_height	= (1944 + IMX326_5M_2X_RHS1) * 2, /* (1944 + VBP1)*2 */
+		.act_start_x	= 0,
+		.act_start_y	= 0,
+		.act_width	= 2592,
+		.act_height	= 1944,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_2X_HDR_MODE,
+		.device_mode	= 1,
+		.pll_idx	= 0,
+		.width		= 2592 * 2,
+		.height		= 1944,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_10,
+		.ratio		= AMBA_VIDEO_RATIO_4_3,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+		.hdr_long_offset = 0,
+		.hdr_short1_offset = IMX326_5M_2X_RHS1 * 2 + 1,/* 2 x VBP1 + 1 */
+	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_3072_1728,
+		.def_start_x	= 12,
+		.def_start_y	= (16 + 6 + 18) * 2,
+		.def_width	= 3072,
+		.def_height	= (1728 + IMX326_5_3M_2X_RHS1) * 2, /* (1728 + VBP1)*2 */
+		.act_start_x	= 0,
+		.act_start_y	= 0,
+		.act_width	= 3072,
+		.act_height	= 1728,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_2X_HDR_MODE,
+		.device_mode	= 2,
+		.pll_idx	= 0,
+		.width		= 3072 * 2,
+		.height		= 1728,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_10,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+		.hdr_long_offset = 0,
+		.hdr_short1_offset = IMX326_5_3M_2X_RHS1 * 2 + 1,/* 2 x VBP1 + 1 */
+	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_2048_2048,
+		.def_start_x	= 12,
+		.def_start_y	= (16 + 6 + 18) * 2,
+		.def_width	= 2048,
+		.def_height	= (2048 + IMX326_4_2M_2X_RHS1) * 2, /* (2048 + VBP1)*2 */
+		.act_start_x	= 0,
+		.act_start_y	= 0,
+		.act_width	= 2048,
+		.act_height	= 2048,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_2X_HDR_MODE,
+		.device_mode	= 3,
+		.pll_idx	= 0,
+		.width		= 2048 * 2,
+		.height		= 2048,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_10,
+		.ratio		= AMBA_VIDEO_RATIO_1_1,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+		.hdr_long_offset = 0,
+		.hdr_short1_offset = IMX326_4_2M_2X_RHS1 * 2 + 1,/* 2 x VBP1 + 1 */
+	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_2688_1520,
+		.def_start_x	= 12,
+		.def_start_y	= (16 + 6 + 18) * 2,
+		.def_width	= 2688,
+		.def_height	= (1520 + IMX326_4M_2X_RHS1) * 2, /* (1520 + VBP1)*2 */
+		.act_start_x	= 0,
+		.act_start_y	= 0,
+		.act_width	= 2688,
+		.act_height	= 1520,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_2X_HDR_MODE,
+		.device_mode	= 4,
+		.pll_idx	= 0,
+		.width		= 2688 * 2,
+		.height		= 1520,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_10,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+		.hdr_long_offset = 0,
+		.hdr_short1_offset = IMX326_4M_2X_RHS1 * 2 + 1,/* 2 x VBP1 + 1 */
+	},
+};
+
+static struct vin_reg_16_8 imx326_share_regs[] = {
+	{IMX326_SYS_MODE, 0x00},/* Sub-LVDS */
+	{IMX326_REG_010B, 0x00},
+	{IMX326_PLSTMG01, 0x00},
+	{IMX326_PLSTMG02, 0x03},
+	{IMX326_PLSTMG03_LSB, 0x1A},
+	{IMX326_PLSTMG03_MSB, 0x00},
+	{IMX326_PLSTMG04, 0x02},
+	{IMX326_PLSTMG05, 0x0E},
+	{IMX326_PLSTMG06, 0x0E},
+	{IMX326_PLSTMG07, 0x0E},
+	{IMX326_PLSTMG08, 0x0E},
+	{IMX326_PLSTMG09, 0x0E},
+	{IMX326_PLSTMG10, 0x00},
+	{IMX326_PLSTMG11, 0x05},
+	{IMX326_PLSTMG12, 0x05},
+	{IMX326_PLSTMG13, 0x04},
+	{IMX326_PLSTMG14, 0x76},
+	{IMX326_PLSTMG15, 0x01},
+	{IMX326_PLSTMG16, 0x0E},
+	{IMX326_PLSTMG17, 0x0E},
+	{IMX326_PLSTMG18, 0x0E},
+	{IMX326_PLSTMG19, 0x0E},
+	{IMX326_PLSTMG20, 0x0E},
+	{IMX326_PLSTMG21, 0x00},
+	{IMX326_PLSTMG22, 0x00},
+	{IMX326_PLSTMG23, 0x00},
+	{IMX326_PLSTMG24, 0x00},
+	{IMX326_MDVREV, 0x00},
+};
+
+#ifdef CONFIG_PM
+static struct vin_reg_16_8 pm_regs[] = {
+	{IMX326_DGAIN, 0x00},
+	{IMX326_PGC_LSB, 0x00},
+	{IMX326_PGC_MSB, 0x00},
+	{IMX326_SHR_LSB, 0x00},
+	{IMX326_SHR_MSB, 0x00},
+	{IMX326_SHR_DOL1_LSB, 0x00},
+	{IMX326_SHR_DOL1_MSB, 0x00},
+	{IMX326_SHR_DOL2_LSB, 0x00},
+	{IMX326_SHR_DOL2_MSB, 0x00},
+};
+#endif
+
+#define IMX326_GAIN_ROWS	673
+#define IMX326_GAIN_COLS	2
+#define IMX326_GAIN_MAXDB	672
+
+#define IMX326_GAIN_COL_AGAIN	0
+#define IMX326_GAIN_COL_DGAIN	1
+
+/* For digital gain, the step is 6dB, Max = 36dB */
+static const u16 IMX326_GAIN_TABLE[IMX326_GAIN_ROWS][IMX326_GAIN_COLS] = {
+	{0x0000, 0x00}, /* index:0, gain:0.00000db, again:0.00000db, dgain:0db */
+	{0x0016, 0x00}, /* index:1, gain:0.09375db, again:0.09375db, dgain:0db */
+	{0x002c, 0x00}, /* index:2, gain:0.18750db, again:0.18750db, dgain:0db */
+	{0x0041, 0x00}, /* index:3, gain:0.28125db, again:0.28125db, dgain:0db */
+	{0x0057, 0x00}, /* index:4, gain:0.37500db, again:0.37500db, dgain:0db */
+	{0x006c, 0x00}, /* index:5, gain:0.46875db, again:0.46875db, dgain:0db */
+	{0x0080, 0x00}, /* index:6, gain:0.56250db, again:0.56250db, dgain:0db */
+	{0x0095, 0x00}, /* index:7, gain:0.65625db, again:0.65625db, dgain:0db */
+	{0x00a9, 0x00}, /* index:8, gain:0.75000db, again:0.75000db, dgain:0db */
+	{0x00be, 0x00}, /* index:9, gain:0.84375db, again:0.84375db, dgain:0db */
+	{0x00d2, 0x00}, /* index:10, gain:0.93750db, again:0.93750db, dgain:0db */
+	{0x00e5, 0x00}, /* index:11, gain:1.03125db, again:1.03125db, dgain:0db */
+	{0x00f9, 0x00}, /* index:12, gain:1.12500db, again:1.12500db, dgain:0db */
+	{0x010c, 0x00}, /* index:13, gain:1.21875db, again:1.21875db, dgain:0db */
+	{0x011f, 0x00}, /* index:14, gain:1.31250db, again:1.31250db, dgain:0db */
+	{0x0132, 0x00}, /* index:15, gain:1.40625db, again:1.40625db, dgain:0db */
+	{0x0145, 0x00}, /* index:16, gain:1.50000db, again:1.50000db, dgain:0db */
+	{0x0157, 0x00}, /* index:17, gain:1.59375db, again:1.59375db, dgain:0db */
+	{0x016a, 0x00}, /* index:18, gain:1.68750db, again:1.68750db, dgain:0db */
+	{0x017c, 0x00}, /* index:19, gain:1.78125db, again:1.78125db, dgain:0db */
+	{0x018e, 0x00}, /* index:20, gain:1.87500db, again:1.87500db, dgain:0db */
+	{0x019f, 0x00}, /* index:21, gain:1.96875db, again:1.96875db, dgain:0db */
+	{0x01b1, 0x00}, /* index:22, gain:2.06250db, again:2.06250db, dgain:0db */
+	{0x01c2, 0x00}, /* index:23, gain:2.15625db, again:2.15625db, dgain:0db */
+	{0x01d3, 0x00}, /* index:24, gain:2.25000db, again:2.25000db, dgain:0db */
+	{0x01e4, 0x00}, /* index:25, gain:2.34375db, again:2.34375db, dgain:0db */
+	{0x01f5, 0x00}, /* index:26, gain:2.43750db, again:2.43750db, dgain:0db */
+	{0x0206, 0x00}, /* index:27, gain:2.53125db, again:2.53125db, dgain:0db */
+	{0x0216, 0x00}, /* index:28, gain:2.62500db, again:2.62500db, dgain:0db */
+	{0x0226, 0x00}, /* index:29, gain:2.71875db, again:2.71875db, dgain:0db */
+	{0x0236, 0x00}, /* index:30, gain:2.81250db, again:2.81250db, dgain:0db */
+	{0x0246, 0x00}, /* index:31, gain:2.90625db, again:2.90625db, dgain:0db */
+	{0x0256, 0x00}, /* index:32, gain:3.00000db, again:3.00000db, dgain:0db */
+	{0x0266, 0x00}, /* index:33, gain:3.09375db, again:3.09375db, dgain:0db */
+	{0x0275, 0x00}, /* index:34, gain:3.18750db, again:3.18750db, dgain:0db */
+	{0x0284, 0x00}, /* index:35, gain:3.28125db, again:3.28125db, dgain:0db */
+	{0x0293, 0x00}, /* index:36, gain:3.37500db, again:3.37500db, dgain:0db */
+	{0x02a2, 0x00}, /* index:37, gain:3.46875db, again:3.46875db, dgain:0db */
+	{0x02b1, 0x00}, /* index:38, gain:3.56250db, again:3.56250db, dgain:0db */
+	{0x02c0, 0x00}, /* index:39, gain:3.65625db, again:3.65625db, dgain:0db */
+	{0x02ce, 0x00}, /* index:40, gain:3.75000db, again:3.75000db, dgain:0db */
+	{0x02dc, 0x00}, /* index:41, gain:3.84375db, again:3.84375db, dgain:0db */
+	{0x02ea, 0x00}, /* index:42, gain:3.93750db, again:3.93750db, dgain:0db */
+	{0x02f8, 0x00}, /* index:43, gain:4.03125db, again:4.03125db, dgain:0db */
+	{0x0306, 0x00}, /* index:44, gain:4.12500db, again:4.12500db, dgain:0db */
+	{0x0314, 0x00}, /* index:45, gain:4.21875db, again:4.21875db, dgain:0db */
+	{0x0321, 0x00}, /* index:46, gain:4.31250db, again:4.31250db, dgain:0db */
+	{0x032f, 0x00}, /* index:47, gain:4.40625db, again:4.40625db, dgain:0db */
+	{0x033c, 0x00}, /* index:48, gain:4.50000db, again:4.50000db, dgain:0db */
+	{0x0349, 0x00}, /* index:49, gain:4.59375db, again:4.59375db, dgain:0db */
+	{0x0356, 0x00}, /* index:50, gain:4.68750db, again:4.68750db, dgain:0db */
+	{0x0363, 0x00}, /* index:51, gain:4.78125db, again:4.78125db, dgain:0db */
+	{0x0370, 0x00}, /* index:52, gain:4.87500db, again:4.87500db, dgain:0db */
+	{0x037c, 0x00}, /* index:53, gain:4.96875db, again:4.96875db, dgain:0db */
+	{0x0389, 0x00}, /* index:54, gain:5.06250db, again:5.06250db, dgain:0db */
+	{0x0395, 0x00}, /* index:55, gain:5.15625db, again:5.15625db, dgain:0db */
+	{0x03a1, 0x00}, /* index:56, gain:5.25000db, again:5.25000db, dgain:0db */
+	{0x03ad, 0x00}, /* index:57, gain:5.34375db, again:5.34375db, dgain:0db */
+	{0x03b9, 0x00}, /* index:58, gain:5.43750db, again:5.43750db, dgain:0db */
+	{0x03c5, 0x00}, /* index:59, gain:5.53125db, again:5.53125db, dgain:0db */
+	{0x03d0, 0x00}, /* index:60, gain:5.62500db, again:5.62500db, dgain:0db */
+	{0x03dc, 0x00}, /* index:61, gain:5.71875db, again:5.71875db, dgain:0db */
+	{0x03e7, 0x00}, /* index:62, gain:5.81250db, again:5.81250db, dgain:0db */
+	{0x03f2, 0x00}, /* index:63, gain:5.90625db, again:5.90625db, dgain:0db */
+	{0x03fe, 0x00}, /* index:64, gain:6.00000db, again:6.00000db, dgain:0db */
+	{0x0409, 0x00}, /* index:65, gain:6.09375db, again:6.09375db, dgain:0db */
+	{0x0413, 0x00}, /* index:66, gain:6.18750db, again:6.18750db, dgain:0db */
+	{0x041e, 0x00}, /* index:67, gain:6.28125db, again:6.28125db, dgain:0db */
+	{0x0429, 0x00}, /* index:68, gain:6.37500db, again:6.37500db, dgain:0db */
+	{0x0433, 0x00}, /* index:69, gain:6.46875db, again:6.46875db, dgain:0db */
+	{0x043e, 0x00}, /* index:70, gain:6.56250db, again:6.56250db, dgain:0db */
+	{0x0448, 0x00}, /* index:71, gain:6.65625db, again:6.65625db, dgain:0db */
+	{0x0452, 0x00}, /* index:72, gain:6.75000db, again:6.75000db, dgain:0db */
+	{0x045d, 0x00}, /* index:73, gain:6.84375db, again:6.84375db, dgain:0db */
+	{0x0467, 0x00}, /* index:74, gain:6.93750db, again:6.93750db, dgain:0db */
+	{0x0470, 0x00}, /* index:75, gain:7.03125db, again:7.03125db, dgain:0db */
+	{0x047a, 0x00}, /* index:76, gain:7.12500db, again:7.12500db, dgain:0db */
+	{0x0484, 0x00}, /* index:77, gain:7.21875db, again:7.21875db, dgain:0db */
+	{0x048e, 0x00}, /* index:78, gain:7.31250db, again:7.31250db, dgain:0db */
+	{0x0497, 0x00}, /* index:79, gain:7.40625db, again:7.40625db, dgain:0db */
+	{0x04a0, 0x00}, /* index:80, gain:7.50000db, again:7.50000db, dgain:0db */
+	{0x04aa, 0x00}, /* index:81, gain:7.59375db, again:7.59375db, dgain:0db */
+	{0x04b3, 0x00}, /* index:82, gain:7.68750db, again:7.68750db, dgain:0db */
+	{0x04bc, 0x00}, /* index:83, gain:7.78125db, again:7.78125db, dgain:0db */
+	{0x04c5, 0x00}, /* index:84, gain:7.87500db, again:7.87500db, dgain:0db */
+	{0x04ce, 0x00}, /* index:85, gain:7.96875db, again:7.96875db, dgain:0db */
+	{0x04d7, 0x00}, /* index:86, gain:8.06250db, again:8.06250db, dgain:0db */
+	{0x04df, 0x00}, /* index:87, gain:8.15625db, again:8.15625db, dgain:0db */
+	{0x04e8, 0x00}, /* index:88, gain:8.25000db, again:8.25000db, dgain:0db */
+	{0x04f0, 0x00}, /* index:89, gain:8.34375db, again:8.34375db, dgain:0db */
+	{0x04f9, 0x00}, /* index:90, gain:8.43750db, again:8.43750db, dgain:0db */
+	{0x0501, 0x00}, /* index:91, gain:8.53125db, again:8.53125db, dgain:0db */
+	{0x0509, 0x00}, /* index:92, gain:8.62500db, again:8.62500db, dgain:0db */
+	{0x0511, 0x00}, /* index:93, gain:8.71875db, again:8.71875db, dgain:0db */
+	{0x0519, 0x00}, /* index:94, gain:8.81250db, again:8.81250db, dgain:0db */
+	{0x0521, 0x00}, /* index:95, gain:8.90625db, again:8.90625db, dgain:0db */
+	{0x0529, 0x00}, /* index:96, gain:9.00000db, again:9.00000db, dgain:0db */
+	{0x0531, 0x00}, /* index:97, gain:9.09375db, again:9.09375db, dgain:0db */
+	{0x0539, 0x00}, /* index:98, gain:9.18750db, again:9.18750db, dgain:0db */
+	{0x0540, 0x00}, /* index:99, gain:9.28125db, again:9.28125db, dgain:0db */
+	{0x0548, 0x00}, /* index:100, gain:9.37500db, again:9.37500db, dgain:0db */
+	{0x0550, 0x00}, /* index:101, gain:9.46875db, again:9.46875db, dgain:0db */
+	{0x0557, 0x00}, /* index:102, gain:9.56250db, again:9.56250db, dgain:0db */
+	{0x055e, 0x00}, /* index:103, gain:9.65625db, again:9.65625db, dgain:0db */
+	{0x0565, 0x00}, /* index:104, gain:9.75000db, again:9.75000db, dgain:0db */
+	{0x056d, 0x00}, /* index:105, gain:9.84375db, again:9.84375db, dgain:0db */
+	{0x0574, 0x00}, /* index:106, gain:9.93750db, again:9.93750db, dgain:0db */
+	{0x057b, 0x00}, /* index:107, gain:10.03125db, again:10.03125db, dgain:0db */
+	{0x0582, 0x00}, /* index:108, gain:10.12500db, again:10.12500db, dgain:0db */
+	{0x0588, 0x00}, /* index:109, gain:10.21875db, again:10.21875db, dgain:0db */
+	{0x058f, 0x00}, /* index:110, gain:10.31250db, again:10.31250db, dgain:0db */
+	{0x0596, 0x00}, /* index:111, gain:10.40625db, again:10.40625db, dgain:0db */
+	{0x059d, 0x00}, /* index:112, gain:10.50000db, again:10.50000db, dgain:0db */
+	{0x05a3, 0x00}, /* index:113, gain:10.59375db, again:10.59375db, dgain:0db */
+	{0x05aa, 0x00}, /* index:114, gain:10.68750db, again:10.68750db, dgain:0db */
+	{0x05b0, 0x00}, /* index:115, gain:10.78125db, again:10.78125db, dgain:0db */
+	{0x05b6, 0x00}, /* index:116, gain:10.87500db, again:10.87500db, dgain:0db */
+	{0x05bd, 0x00}, /* index:117, gain:10.96875db, again:10.96875db, dgain:0db */
+	{0x05c3, 0x00}, /* index:118, gain:11.06250db, again:11.06250db, dgain:0db */
+	{0x05c9, 0x00}, /* index:119, gain:11.15625db, again:11.15625db, dgain:0db */
+	{0x05cf, 0x00}, /* index:120, gain:11.25000db, again:11.25000db, dgain:0db */
+	{0x05d5, 0x00}, /* index:121, gain:11.34375db, again:11.34375db, dgain:0db */
+	{0x05db, 0x00}, /* index:122, gain:11.43750db, again:11.43750db, dgain:0db */
+	{0x05e1, 0x00}, /* index:123, gain:11.53125db, again:11.53125db, dgain:0db */
+	{0x05e7, 0x00}, /* index:124, gain:11.62500db, again:11.62500db, dgain:0db */
+	{0x05ed, 0x00}, /* index:125, gain:11.71875db, again:11.71875db, dgain:0db */
+	{0x05f2, 0x00}, /* index:126, gain:11.81250db, again:11.81250db, dgain:0db */
+	{0x05f8, 0x00}, /* index:127, gain:11.90625db, again:11.90625db, dgain:0db */
+	{0x05fe, 0x00}, /* index:128, gain:12.00000db, again:12.00000db, dgain:0db */
+	{0x0603, 0x00}, /* index:129, gain:12.09375db, again:12.09375db, dgain:0db */
+	{0x0609, 0x00}, /* index:130, gain:12.18750db, again:12.18750db, dgain:0db */
+	{0x060e, 0x00}, /* index:131, gain:12.28125db, again:12.28125db, dgain:0db */
+	{0x0613, 0x00}, /* index:132, gain:12.37500db, again:12.37500db, dgain:0db */
+	{0x0619, 0x00}, /* index:133, gain:12.46875db, again:12.46875db, dgain:0db */
+	{0x061e, 0x00}, /* index:134, gain:12.56250db, again:12.56250db, dgain:0db */
+	{0x0623, 0x00}, /* index:135, gain:12.65625db, again:12.65625db, dgain:0db */
+	{0x0628, 0x00}, /* index:136, gain:12.75000db, again:12.75000db, dgain:0db */
+	{0x062d, 0x00}, /* index:137, gain:12.84375db, again:12.84375db, dgain:0db */
+	{0x0632, 0x00}, /* index:138, gain:12.93750db, again:12.93750db, dgain:0db */
+	{0x0637, 0x00}, /* index:139, gain:13.03125db, again:13.03125db, dgain:0db */
+	{0x063c, 0x00}, /* index:140, gain:13.12500db, again:13.12500db, dgain:0db */
+	{0x0641, 0x00}, /* index:141, gain:13.21875db, again:13.21875db, dgain:0db */
+	{0x0646, 0x00}, /* index:142, gain:13.31250db, again:13.31250db, dgain:0db */
+	{0x064a, 0x00}, /* index:143, gain:13.40625db, again:13.40625db, dgain:0db */
+	{0x064f, 0x00}, /* index:144, gain:13.50000db, again:13.50000db, dgain:0db */
+	{0x0654, 0x00}, /* index:145, gain:13.59375db, again:13.59375db, dgain:0db */
+	{0x0658, 0x00}, /* index:146, gain:13.68750db, again:13.68750db, dgain:0db */
+	{0x065d, 0x00}, /* index:147, gain:13.78125db, again:13.78125db, dgain:0db */
+	{0x0661, 0x00}, /* index:148, gain:13.87500db, again:13.87500db, dgain:0db */
+	{0x0666, 0x00}, /* index:149, gain:13.96875db, again:13.96875db, dgain:0db */
+	{0x066a, 0x00}, /* index:150, gain:14.06250db, again:14.06250db, dgain:0db */
+	{0x066f, 0x00}, /* index:151, gain:14.15625db, again:14.15625db, dgain:0db */
+	{0x0673, 0x00}, /* index:152, gain:14.25000db, again:14.25000db, dgain:0db */
+	{0x0677, 0x00}, /* index:153, gain:14.34375db, again:14.34375db, dgain:0db */
+	{0x067b, 0x00}, /* index:154, gain:14.43750db, again:14.43750db, dgain:0db */
+	{0x0680, 0x00}, /* index:155, gain:14.53125db, again:14.53125db, dgain:0db */
+	{0x0684, 0x00}, /* index:156, gain:14.62500db, again:14.62500db, dgain:0db */
+	{0x0688, 0x00}, /* index:157, gain:14.71875db, again:14.71875db, dgain:0db */
+	{0x068c, 0x00}, /* index:158, gain:14.81250db, again:14.81250db, dgain:0db */
+	{0x0690, 0x00}, /* index:159, gain:14.90625db, again:14.90625db, dgain:0db */
+	{0x0694, 0x00}, /* index:160, gain:15.00000db, again:15.00000db, dgain:0db */
+	{0x0698, 0x00}, /* index:161, gain:15.09375db, again:15.09375db, dgain:0db */
+	{0x069c, 0x00}, /* index:162, gain:15.18750db, again:15.18750db, dgain:0db */
+	{0x069f, 0x00}, /* index:163, gain:15.28125db, again:15.28125db, dgain:0db */
+	{0x06a3, 0x00}, /* index:164, gain:15.37500db, again:15.37500db, dgain:0db */
+	{0x06a7, 0x00}, /* index:165, gain:15.46875db, again:15.46875db, dgain:0db */
+	{0x06ab, 0x00}, /* index:166, gain:15.56250db, again:15.56250db, dgain:0db */
+	{0x06ae, 0x00}, /* index:167, gain:15.65625db, again:15.65625db, dgain:0db */
+	{0x06b2, 0x00}, /* index:168, gain:15.75000db, again:15.75000db, dgain:0db */
+	{0x06b6, 0x00}, /* index:169, gain:15.84375db, again:15.84375db, dgain:0db */
+	{0x06b9, 0x00}, /* index:170, gain:15.93750db, again:15.93750db, dgain:0db */
+	{0x06bd, 0x00}, /* index:171, gain:16.03125db, again:16.03125db, dgain:0db */
+	{0x06c0, 0x00}, /* index:172, gain:16.12500db, again:16.12500db, dgain:0db */
+	{0x06c3, 0x00}, /* index:173, gain:16.21875db, again:16.21875db, dgain:0db */
+	{0x06c7, 0x00}, /* index:174, gain:16.31250db, again:16.31250db, dgain:0db */
+	{0x06ca, 0x00}, /* index:175, gain:16.40625db, again:16.40625db, dgain:0db */
+	{0x06ce, 0x00}, /* index:176, gain:16.50000db, again:16.50000db, dgain:0db */
+	{0x06d1, 0x00}, /* index:177, gain:16.59375db, again:16.59375db, dgain:0db */
+	{0x06d4, 0x00}, /* index:178, gain:16.68750db, again:16.68750db, dgain:0db */
+	{0x06d7, 0x00}, /* index:179, gain:16.78125db, again:16.78125db, dgain:0db */
+	{0x06db, 0x00}, /* index:180, gain:16.87500db, again:16.87500db, dgain:0db */
+	{0x06de, 0x00}, /* index:181, gain:16.96875db, again:16.96875db, dgain:0db */
+	{0x06e1, 0x00}, /* index:182, gain:17.06250db, again:17.06250db, dgain:0db */
+	{0x06e4, 0x00}, /* index:183, gain:17.15625db, again:17.15625db, dgain:0db */
+	{0x06e7, 0x00}, /* index:184, gain:17.25000db, again:17.25000db, dgain:0db */
+	{0x06ea, 0x00}, /* index:185, gain:17.34375db, again:17.34375db, dgain:0db */
+	{0x06ed, 0x00}, /* index:186, gain:17.43750db, again:17.43750db, dgain:0db */
+	{0x06f0, 0x00}, /* index:187, gain:17.53125db, again:17.53125db, dgain:0db */
+	{0x06f3, 0x00}, /* index:188, gain:17.62500db, again:17.62500db, dgain:0db */
+	{0x06f6, 0x00}, /* index:189, gain:17.71875db, again:17.71875db, dgain:0db */
+	{0x06f9, 0x00}, /* index:190, gain:17.81250db, again:17.81250db, dgain:0db */
+	{0x06fb, 0x00}, /* index:191, gain:17.90625db, again:17.90625db, dgain:0db */
+	{0x06fe, 0x00}, /* index:192, gain:18.00000db, again:18.00000db, dgain:0db */
+	{0x0701, 0x00}, /* index:193, gain:18.09375db, again:18.09375db, dgain:0db */
+	{0x0704, 0x00}, /* index:194, gain:18.18750db, again:18.18750db, dgain:0db */
+	{0x0706, 0x00}, /* index:195, gain:18.28125db, again:18.28125db, dgain:0db */
+	{0x0709, 0x00}, /* index:196, gain:18.37500db, again:18.37500db, dgain:0db */
+	{0x070c, 0x00}, /* index:197, gain:18.46875db, again:18.46875db, dgain:0db */
+	{0x070e, 0x00}, /* index:198, gain:18.56250db, again:18.56250db, dgain:0db */
+	{0x0711, 0x00}, /* index:199, gain:18.65625db, again:18.65625db, dgain:0db */
+	{0x0714, 0x00}, /* index:200, gain:18.75000db, again:18.75000db, dgain:0db */
+	{0x0716, 0x00}, /* index:201, gain:18.84375db, again:18.84375db, dgain:0db */
+	{0x0719, 0x00}, /* index:202, gain:18.93750db, again:18.93750db, dgain:0db */
+	{0x071b, 0x00}, /* index:203, gain:19.03125db, again:19.03125db, dgain:0db */
+	{0x071d, 0x00}, /* index:204, gain:19.12500db, again:19.12500db, dgain:0db */
+	{0x0720, 0x00}, /* index:205, gain:19.21875db, again:19.21875db, dgain:0db */
+	{0x0722, 0x00}, /* index:206, gain:19.31250db, again:19.31250db, dgain:0db */
+	{0x0725, 0x00}, /* index:207, gain:19.40625db, again:19.40625db, dgain:0db */
+	{0x0727, 0x00}, /* index:208, gain:19.50000db, again:19.50000db, dgain:0db */
+	{0x0729, 0x00}, /* index:209, gain:19.59375db, again:19.59375db, dgain:0db */
+	{0x072c, 0x00}, /* index:210, gain:19.68750db, again:19.68750db, dgain:0db */
+	{0x072e, 0x00}, /* index:211, gain:19.78125db, again:19.78125db, dgain:0db */
+	{0x0730, 0x00}, /* index:212, gain:19.87500db, again:19.87500db, dgain:0db */
+	{0x0732, 0x00}, /* index:213, gain:19.96875db, again:19.96875db, dgain:0db */
+	{0x0735, 0x00}, /* index:214, gain:20.06250db, again:20.06250db, dgain:0db */
+	{0x0737, 0x00}, /* index:215, gain:20.15625db, again:20.15625db, dgain:0db */
+	{0x0739, 0x00}, /* index:216, gain:20.25000db, again:20.25000db, dgain:0db */
+	{0x073b, 0x00}, /* index:217, gain:20.34375db, again:20.34375db, dgain:0db */
+	{0x073d, 0x00}, /* index:218, gain:20.43750db, again:20.43750db, dgain:0db */
+	{0x073f, 0x00}, /* index:219, gain:20.53125db, again:20.53125db, dgain:0db */
+	{0x0741, 0x00}, /* index:220, gain:20.62500db, again:20.62500db, dgain:0db */
+	{0x0743, 0x00}, /* index:221, gain:20.71875db, again:20.71875db, dgain:0db */
+	{0x0745, 0x00}, /* index:222, gain:20.81250db, again:20.81250db, dgain:0db */
+	{0x0747, 0x00}, /* index:223, gain:20.90625db, again:20.90625db, dgain:0db */
+	{0x0749, 0x00}, /* index:224, gain:21.00000db, again:21.00000db, dgain:0db */
+	{0x074b, 0x00}, /* index:225, gain:21.09375db, again:21.09375db, dgain:0db */
+	{0x074d, 0x00}, /* index:226, gain:21.18750db, again:21.18750db, dgain:0db */
+	{0x074f, 0x00}, /* index:227, gain:21.28125db, again:21.28125db, dgain:0db */
+	{0x0751, 0x00}, /* index:228, gain:21.37500db, again:21.37500db, dgain:0db */
+	{0x0753, 0x00}, /* index:229, gain:21.46875db, again:21.46875db, dgain:0db */
+	{0x0755, 0x00}, /* index:230, gain:21.56250db, again:21.56250db, dgain:0db */
+	{0x0757, 0x00}, /* index:231, gain:21.65625db, again:21.65625db, dgain:0db */
+	{0x0759, 0x00}, /* index:232, gain:21.75000db, again:21.75000db, dgain:0db */
+	{0x075a, 0x00}, /* index:233, gain:21.84375db, again:21.84375db, dgain:0db */
+	{0x075c, 0x00}, /* index:234, gain:21.93750db, again:21.93750db, dgain:0db */
+	{0x075e, 0x00}, /* index:235, gain:22.03125db, again:22.03125db, dgain:0db */
+	{0x0760, 0x00}, /* index:236, gain:22.12500db, again:22.12500db, dgain:0db */
+	{0x0761, 0x00}, /* index:237, gain:22.21875db, again:22.21875db, dgain:0db */
+	{0x0763, 0x00}, /* index:238, gain:22.31250db, again:22.31250db, dgain:0db */
+	{0x0765, 0x00}, /* index:239, gain:22.40625db, again:22.40625db, dgain:0db */
+	{0x0766, 0x00}, /* index:240, gain:22.50000db, again:22.50000db, dgain:0db */
+	{0x0768, 0x00}, /* index:241, gain:22.59375db, again:22.59375db, dgain:0db */
+	{0x076a, 0x00}, /* index:242, gain:22.68750db, again:22.68750db, dgain:0db */
+	{0x076b, 0x00}, /* index:243, gain:22.78125db, again:22.78125db, dgain:0db */
+	{0x076d, 0x00}, /* index:244, gain:22.87500db, again:22.87500db, dgain:0db */
+	{0x076e, 0x00}, /* index:245, gain:22.96875db, again:22.96875db, dgain:0db */
+	{0x0770, 0x00}, /* index:246, gain:23.06250db, again:23.06250db, dgain:0db */
+	{0x0772, 0x00}, /* index:247, gain:23.15625db, again:23.15625db, dgain:0db */
+	{0x0773, 0x00}, /* index:248, gain:23.25000db, again:23.25000db, dgain:0db */
+	{0x0775, 0x00}, /* index:249, gain:23.34375db, again:23.34375db, dgain:0db */
+	{0x0776, 0x00}, /* index:250, gain:23.43750db, again:23.43750db, dgain:0db */
+	{0x0778, 0x00}, /* index:251, gain:23.53125db, again:23.53125db, dgain:0db */
+	{0x0779, 0x00}, /* index:252, gain:23.62500db, again:23.62500db, dgain:0db */
+	{0x077b, 0x00}, /* index:253, gain:23.71875db, again:23.71875db, dgain:0db */
+	{0x077c, 0x00}, /* index:254, gain:23.81250db, again:23.81250db, dgain:0db */
+	{0x077d, 0x00}, /* index:255, gain:23.90625db, again:23.90625db, dgain:0db */
+	{0x077f, 0x00}, /* index:256, gain:24.00000db, again:24.00000db, dgain:0db */
+	{0x0780, 0x00}, /* index:257, gain:24.09375db, again:24.09375db, dgain:0db */
+	{0x0782, 0x00}, /* index:258, gain:24.18750db, again:24.18750db, dgain:0db */
+	{0x0783, 0x00}, /* index:259, gain:24.28125db, again:24.28125db, dgain:0db */
+	{0x0784, 0x00}, /* index:260, gain:24.37500db, again:24.37500db, dgain:0db */
+	{0x0786, 0x00}, /* index:261, gain:24.46875db, again:24.46875db, dgain:0db */
+	{0x0787, 0x00}, /* index:262, gain:24.56250db, again:24.56250db, dgain:0db */
+	{0x0788, 0x00}, /* index:263, gain:24.65625db, again:24.65625db, dgain:0db */
+	{0x0789, 0x00}, /* index:264, gain:24.75000db, again:24.75000db, dgain:0db */
+	{0x078b, 0x00}, /* index:265, gain:24.84375db, again:24.84375db, dgain:0db */
+	{0x078c, 0x00}, /* index:266, gain:24.93750db, again:24.93750db, dgain:0db */
+	{0x078d, 0x00}, /* index:267, gain:25.03125db, again:25.03125db, dgain:0db */
+	{0x078e, 0x00}, /* index:268, gain:25.12500db, again:25.12500db, dgain:0db */
+	{0x0790, 0x00}, /* index:269, gain:25.21875db, again:25.21875db, dgain:0db */
+	{0x0791, 0x00}, /* index:270, gain:25.31250db, again:25.31250db, dgain:0db */
+	{0x0792, 0x00}, /* index:271, gain:25.40625db, again:25.40625db, dgain:0db */
+	{0x0793, 0x00}, /* index:272, gain:25.50000db, again:25.50000db, dgain:0db */
+	{0x0794, 0x00}, /* index:273, gain:25.59375db, again:25.59375db, dgain:0db */
+	{0x0796, 0x00}, /* index:274, gain:25.68750db, again:25.68750db, dgain:0db */
+	{0x0797, 0x00}, /* index:275, gain:25.78125db, again:25.78125db, dgain:0db */
+	{0x0798, 0x00}, /* index:276, gain:25.87500db, again:25.87500db, dgain:0db */
+	{0x0799, 0x00}, /* index:277, gain:25.96875db, again:25.96875db, dgain:0db */
+	{0x079a, 0x00}, /* index:278, gain:26.06250db, again:26.06250db, dgain:0db */
+	{0x079b, 0x00}, /* index:279, gain:26.15625db, again:26.15625db, dgain:0db */
+	{0x079c, 0x00}, /* index:280, gain:26.25000db, again:26.25000db, dgain:0db */
+	{0x079d, 0x00}, /* index:281, gain:26.34375db, again:26.34375db, dgain:0db */
+	{0x079e, 0x00}, /* index:282, gain:26.43750db, again:26.43750db, dgain:0db */
+	{0x079f, 0x00}, /* index:283, gain:26.53125db, again:26.53125db, dgain:0db */
+	{0x07a0, 0x00}, /* index:284, gain:26.62500db, again:26.62500db, dgain:0db */
+	{0x07a2, 0x00}, /* index:285, gain:26.71875db, again:26.71875db, dgain:0db */
+	{0x07a3, 0x00}, /* index:286, gain:26.81250db, again:26.81250db, dgain:0db */
+	{0x07a4, 0x00}, /* index:287, gain:26.90625db, again:26.90625db, dgain:0db */
+	{0x07a5, 0x00}, /* index:288, gain:27.00000db, again:27.00000db, dgain:0db */
+	{0x074b, 0x01}, /* index:289, gain:27.09375db, again:21.09375db, dgain:6db */
+	{0x074d, 0x01}, /* index:290, gain:27.18750db, again:21.18750db, dgain:6db */
+	{0x074f, 0x01}, /* index:291, gain:27.28125db, again:21.28125db, dgain:6db */
+	{0x0751, 0x01}, /* index:292, gain:27.37500db, again:21.37500db, dgain:6db */
+	{0x0753, 0x01}, /* index:293, gain:27.46875db, again:21.46875db, dgain:6db */
+	{0x0755, 0x01}, /* index:294, gain:27.56250db, again:21.56250db, dgain:6db */
+	{0x0757, 0x01}, /* index:295, gain:27.65625db, again:21.65625db, dgain:6db */
+	{0x0759, 0x01}, /* index:296, gain:27.75000db, again:21.75000db, dgain:6db */
+	{0x075a, 0x01}, /* index:297, gain:27.84375db, again:21.84375db, dgain:6db */
+	{0x075c, 0x01}, /* index:298, gain:27.93750db, again:21.93750db, dgain:6db */
+	{0x075e, 0x01}, /* index:299, gain:28.03125db, again:22.03125db, dgain:6db */
+	{0x0760, 0x01}, /* index:300, gain:28.12500db, again:22.12500db, dgain:6db */
+	{0x0761, 0x01}, /* index:301, gain:28.21875db, again:22.21875db, dgain:6db */
+	{0x0763, 0x01}, /* index:302, gain:28.31250db, again:22.31250db, dgain:6db */
+	{0x0765, 0x01}, /* index:303, gain:28.40625db, again:22.40625db, dgain:6db */
+	{0x0766, 0x01}, /* index:304, gain:28.50000db, again:22.50000db, dgain:6db */
+	{0x0768, 0x01}, /* index:305, gain:28.59375db, again:22.59375db, dgain:6db */
+	{0x076a, 0x01}, /* index:306, gain:28.68750db, again:22.68750db, dgain:6db */
+	{0x076b, 0x01}, /* index:307, gain:28.78125db, again:22.78125db, dgain:6db */
+	{0x076d, 0x01}, /* index:308, gain:28.87500db, again:22.87500db, dgain:6db */
+	{0x076e, 0x01}, /* index:309, gain:28.96875db, again:22.96875db, dgain:6db */
+	{0x0770, 0x01}, /* index:310, gain:29.06250db, again:23.06250db, dgain:6db */
+	{0x0772, 0x01}, /* index:311, gain:29.15625db, again:23.15625db, dgain:6db */
+	{0x0773, 0x01}, /* index:312, gain:29.25000db, again:23.25000db, dgain:6db */
+	{0x0775, 0x01}, /* index:313, gain:29.34375db, again:23.34375db, dgain:6db */
+	{0x0776, 0x01}, /* index:314, gain:29.43750db, again:23.43750db, dgain:6db */
+	{0x0778, 0x01}, /* index:315, gain:29.53125db, again:23.53125db, dgain:6db */
+	{0x0779, 0x01}, /* index:316, gain:29.62500db, again:23.62500db, dgain:6db */
+	{0x077b, 0x01}, /* index:317, gain:29.71875db, again:23.71875db, dgain:6db */
+	{0x077c, 0x01}, /* index:318, gain:29.81250db, again:23.81250db, dgain:6db */
+	{0x077d, 0x01}, /* index:319, gain:29.90625db, again:23.90625db, dgain:6db */
+	{0x077f, 0x01}, /* index:320, gain:30.00000db, again:24.00000db, dgain:6db */
+	{0x0780, 0x01}, /* index:321, gain:30.09375db, again:24.09375db, dgain:6db */
+	{0x0782, 0x01}, /* index:322, gain:30.18750db, again:24.18750db, dgain:6db */
+	{0x0783, 0x01}, /* index:323, gain:30.28125db, again:24.28125db, dgain:6db */
+	{0x0784, 0x01}, /* index:324, gain:30.37500db, again:24.37500db, dgain:6db */
+	{0x0786, 0x01}, /* index:325, gain:30.46875db, again:24.46875db, dgain:6db */
+	{0x0787, 0x01}, /* index:326, gain:30.56250db, again:24.56250db, dgain:6db */
+	{0x0788, 0x01}, /* index:327, gain:30.65625db, again:24.65625db, dgain:6db */
+	{0x0789, 0x01}, /* index:328, gain:30.75000db, again:24.75000db, dgain:6db */
+	{0x078b, 0x01}, /* index:329, gain:30.84375db, again:24.84375db, dgain:6db */
+	{0x078c, 0x01}, /* index:330, gain:30.93750db, again:24.93750db, dgain:6db */
+	{0x078d, 0x01}, /* index:331, gain:31.03125db, again:25.03125db, dgain:6db */
+	{0x078e, 0x01}, /* index:332, gain:31.12500db, again:25.12500db, dgain:6db */
+	{0x0790, 0x01}, /* index:333, gain:31.21875db, again:25.21875db, dgain:6db */
+	{0x0791, 0x01}, /* index:334, gain:31.31250db, again:25.31250db, dgain:6db */
+	{0x0792, 0x01}, /* index:335, gain:31.40625db, again:25.40625db, dgain:6db */
+	{0x0793, 0x01}, /* index:336, gain:31.50000db, again:25.50000db, dgain:6db */
+	{0x0794, 0x01}, /* index:337, gain:31.59375db, again:25.59375db, dgain:6db */
+	{0x0796, 0x01}, /* index:338, gain:31.68750db, again:25.68750db, dgain:6db */
+	{0x0797, 0x01}, /* index:339, gain:31.78125db, again:25.78125db, dgain:6db */
+	{0x0798, 0x01}, /* index:340, gain:31.87500db, again:25.87500db, dgain:6db */
+	{0x0799, 0x01}, /* index:341, gain:31.96875db, again:25.96875db, dgain:6db */
+	{0x079a, 0x01}, /* index:342, gain:32.06250db, again:26.06250db, dgain:6db */
+	{0x079b, 0x01}, /* index:343, gain:32.15625db, again:26.15625db, dgain:6db */
+	{0x079c, 0x01}, /* index:344, gain:32.25000db, again:26.25000db, dgain:6db */
+	{0x079d, 0x01}, /* index:345, gain:32.34375db, again:26.34375db, dgain:6db */
+	{0x079e, 0x01}, /* index:346, gain:32.43750db, again:26.43750db, dgain:6db */
+	{0x079f, 0x01}, /* index:347, gain:32.53125db, again:26.53125db, dgain:6db */
+	{0x07a0, 0x01}, /* index:348, gain:32.62500db, again:26.62500db, dgain:6db */
+	{0x07a2, 0x01}, /* index:349, gain:32.71875db, again:26.71875db, dgain:6db */
+	{0x07a3, 0x01}, /* index:350, gain:32.81250db, again:26.81250db, dgain:6db */
+	{0x07a4, 0x01}, /* index:351, gain:32.90625db, again:26.90625db, dgain:6db */
+	{0x07a5, 0x01}, /* index:352, gain:33.00000db, again:27.00000db, dgain:6db */
+	{0x074b, 0x02}, /* index:353, gain:33.09375db, again:21.09375db, dgain:12db */
+	{0x074d, 0x02}, /* index:354, gain:33.18750db, again:21.18750db, dgain:12db */
+	{0x074f, 0x02}, /* index:355, gain:33.28125db, again:21.28125db, dgain:12db */
+	{0x0751, 0x02}, /* index:356, gain:33.37500db, again:21.37500db, dgain:12db */
+	{0x0753, 0x02}, /* index:357, gain:33.46875db, again:21.46875db, dgain:12db */
+	{0x0755, 0x02}, /* index:358, gain:33.56250db, again:21.56250db, dgain:12db */
+	{0x0757, 0x02}, /* index:359, gain:33.65625db, again:21.65625db, dgain:12db */
+	{0x0759, 0x02}, /* index:360, gain:33.75000db, again:21.75000db, dgain:12db */
+	{0x075a, 0x02}, /* index:361, gain:33.84375db, again:21.84375db, dgain:12db */
+	{0x075c, 0x02}, /* index:362, gain:33.93750db, again:21.93750db, dgain:12db */
+	{0x075e, 0x02}, /* index:363, gain:34.03125db, again:22.03125db, dgain:12db */
+	{0x0760, 0x02}, /* index:364, gain:34.12500db, again:22.12500db, dgain:12db */
+	{0x0761, 0x02}, /* index:365, gain:34.21875db, again:22.21875db, dgain:12db */
+	{0x0763, 0x02}, /* index:366, gain:34.31250db, again:22.31250db, dgain:12db */
+	{0x0765, 0x02}, /* index:367, gain:34.40625db, again:22.40625db, dgain:12db */
+	{0x0766, 0x02}, /* index:368, gain:34.50000db, again:22.50000db, dgain:12db */
+	{0x0768, 0x02}, /* index:369, gain:34.59375db, again:22.59375db, dgain:12db */
+	{0x076a, 0x02}, /* index:370, gain:34.68750db, again:22.68750db, dgain:12db */
+	{0x076b, 0x02}, /* index:371, gain:34.78125db, again:22.78125db, dgain:12db */
+	{0x076d, 0x02}, /* index:372, gain:34.87500db, again:22.87500db, dgain:12db */
+	{0x076e, 0x02}, /* index:373, gain:34.96875db, again:22.96875db, dgain:12db */
+	{0x0770, 0x02}, /* index:374, gain:35.06250db, again:23.06250db, dgain:12db */
+	{0x0772, 0x02}, /* index:375, gain:35.15625db, again:23.15625db, dgain:12db */
+	{0x0773, 0x02}, /* index:376, gain:35.25000db, again:23.25000db, dgain:12db */
+	{0x0775, 0x02}, /* index:377, gain:35.34375db, again:23.34375db, dgain:12db */
+	{0x0776, 0x02}, /* index:378, gain:35.43750db, again:23.43750db, dgain:12db */
+	{0x0778, 0x02}, /* index:379, gain:35.53125db, again:23.53125db, dgain:12db */
+	{0x0779, 0x02}, /* index:380, gain:35.62500db, again:23.62500db, dgain:12db */
+	{0x077b, 0x02}, /* index:381, gain:35.71875db, again:23.71875db, dgain:12db */
+	{0x077c, 0x02}, /* index:382, gain:35.81250db, again:23.81250db, dgain:12db */
+	{0x077d, 0x02}, /* index:383, gain:35.90625db, again:23.90625db, dgain:12db */
+	{0x077f, 0x02}, /* index:384, gain:36.00000db, again:24.00000db, dgain:12db */
+	{0x0780, 0x02}, /* index:385, gain:36.09375db, again:24.09375db, dgain:12db */
+	{0x0782, 0x02}, /* index:386, gain:36.18750db, again:24.18750db, dgain:12db */
+	{0x0783, 0x02}, /* index:387, gain:36.28125db, again:24.28125db, dgain:12db */
+	{0x0784, 0x02}, /* index:388, gain:36.37500db, again:24.37500db, dgain:12db */
+	{0x0786, 0x02}, /* index:389, gain:36.46875db, again:24.46875db, dgain:12db */
+	{0x0787, 0x02}, /* index:390, gain:36.56250db, again:24.56250db, dgain:12db */
+	{0x0788, 0x02}, /* index:391, gain:36.65625db, again:24.65625db, dgain:12db */
+	{0x0789, 0x02}, /* index:392, gain:36.75000db, again:24.75000db, dgain:12db */
+	{0x078b, 0x02}, /* index:393, gain:36.84375db, again:24.84375db, dgain:12db */
+	{0x078c, 0x02}, /* index:394, gain:36.93750db, again:24.93750db, dgain:12db */
+	{0x078d, 0x02}, /* index:395, gain:37.03125db, again:25.03125db, dgain:12db */
+	{0x078e, 0x02}, /* index:396, gain:37.12500db, again:25.12500db, dgain:12db */
+	{0x0790, 0x02}, /* index:397, gain:37.21875db, again:25.21875db, dgain:12db */
+	{0x0791, 0x02}, /* index:398, gain:37.31250db, again:25.31250db, dgain:12db */
+	{0x0792, 0x02}, /* index:399, gain:37.40625db, again:25.40625db, dgain:12db */
+	{0x0793, 0x02}, /* index:400, gain:37.50000db, again:25.50000db, dgain:12db */
+	{0x0794, 0x02}, /* index:401, gain:37.59375db, again:25.59375db, dgain:12db */
+	{0x0796, 0x02}, /* index:402, gain:37.68750db, again:25.68750db, dgain:12db */
+	{0x0797, 0x02}, /* index:403, gain:37.78125db, again:25.78125db, dgain:12db */
+	{0x0798, 0x02}, /* index:404, gain:37.87500db, again:25.87500db, dgain:12db */
+	{0x0799, 0x02}, /* index:405, gain:37.96875db, again:25.96875db, dgain:12db */
+	{0x079a, 0x02}, /* index:406, gain:38.06250db, again:26.06250db, dgain:12db */
+	{0x079b, 0x02}, /* index:407, gain:38.15625db, again:26.15625db, dgain:12db */
+	{0x079c, 0x02}, /* index:408, gain:38.25000db, again:26.25000db, dgain:12db */
+	{0x079d, 0x02}, /* index:409, gain:38.34375db, again:26.34375db, dgain:12db */
+	{0x079e, 0x02}, /* index:410, gain:38.43750db, again:26.43750db, dgain:12db */
+	{0x079f, 0x02}, /* index:411, gain:38.53125db, again:26.53125db, dgain:12db */
+	{0x07a0, 0x02}, /* index:412, gain:38.62500db, again:26.62500db, dgain:12db */
+	{0x07a2, 0x02}, /* index:413, gain:38.71875db, again:26.71875db, dgain:12db */
+	{0x07a3, 0x02}, /* index:414, gain:38.81250db, again:26.81250db, dgain:12db */
+	{0x07a4, 0x02}, /* index:415, gain:38.90625db, again:26.90625db, dgain:12db */
+	{0x07a5, 0x02}, /* index:416, gain:39.00000db, again:27.00000db, dgain:12db */
+	{0x074b, 0x03}, /* index:417, gain:39.09375db, again:21.09375db, dgain:18db */
+	{0x074d, 0x03}, /* index:418, gain:39.18750db, again:21.18750db, dgain:18db */
+	{0x074f, 0x03}, /* index:419, gain:39.28125db, again:21.28125db, dgain:18db */
+	{0x0751, 0x03}, /* index:420, gain:39.37500db, again:21.37500db, dgain:18db */
+	{0x0753, 0x03}, /* index:421, gain:39.46875db, again:21.46875db, dgain:18db */
+	{0x0755, 0x03}, /* index:422, gain:39.56250db, again:21.56250db, dgain:18db */
+	{0x0757, 0x03}, /* index:423, gain:39.65625db, again:21.65625db, dgain:18db */
+	{0x0759, 0x03}, /* index:424, gain:39.75000db, again:21.75000db, dgain:18db */
+	{0x075a, 0x03}, /* index:425, gain:39.84375db, again:21.84375db, dgain:18db */
+	{0x075c, 0x03}, /* index:426, gain:39.93750db, again:21.93750db, dgain:18db */
+	{0x075e, 0x03}, /* index:427, gain:40.03125db, again:22.03125db, dgain:18db */
+	{0x0760, 0x03}, /* index:428, gain:40.12500db, again:22.12500db, dgain:18db */
+	{0x0761, 0x03}, /* index:429, gain:40.21875db, again:22.21875db, dgain:18db */
+	{0x0763, 0x03}, /* index:430, gain:40.31250db, again:22.31250db, dgain:18db */
+	{0x0765, 0x03}, /* index:431, gain:40.40625db, again:22.40625db, dgain:18db */
+	{0x0766, 0x03}, /* index:432, gain:40.50000db, again:22.50000db, dgain:18db */
+	{0x0768, 0x03}, /* index:433, gain:40.59375db, again:22.59375db, dgain:18db */
+	{0x076a, 0x03}, /* index:434, gain:40.68750db, again:22.68750db, dgain:18db */
+	{0x076b, 0x03}, /* index:435, gain:40.78125db, again:22.78125db, dgain:18db */
+	{0x076d, 0x03}, /* index:436, gain:40.87500db, again:22.87500db, dgain:18db */
+	{0x076e, 0x03}, /* index:437, gain:40.96875db, again:22.96875db, dgain:18db */
+	{0x0770, 0x03}, /* index:438, gain:41.06250db, again:23.06250db, dgain:18db */
+	{0x0772, 0x03}, /* index:439, gain:41.15625db, again:23.15625db, dgain:18db */
+	{0x0773, 0x03}, /* index:440, gain:41.25000db, again:23.25000db, dgain:18db */
+	{0x0775, 0x03}, /* index:441, gain:41.34375db, again:23.34375db, dgain:18db */
+	{0x0776, 0x03}, /* index:442, gain:41.43750db, again:23.43750db, dgain:18db */
+	{0x0778, 0x03}, /* index:443, gain:41.53125db, again:23.53125db, dgain:18db */
+	{0x0779, 0x03}, /* index:444, gain:41.62500db, again:23.62500db, dgain:18db */
+	{0x077b, 0x03}, /* index:445, gain:41.71875db, again:23.71875db, dgain:18db */
+	{0x077c, 0x03}, /* index:446, gain:41.81250db, again:23.81250db, dgain:18db */
+	{0x077d, 0x03}, /* index:447, gain:41.90625db, again:23.90625db, dgain:18db */
+	{0x077f, 0x03}, /* index:448, gain:42.00000db, again:24.00000db, dgain:18db */
+	{0x0780, 0x03}, /* index:449, gain:42.09375db, again:24.09375db, dgain:18db */
+	{0x0782, 0x03}, /* index:450, gain:42.18750db, again:24.18750db, dgain:18db */
+	{0x0783, 0x03}, /* index:451, gain:42.28125db, again:24.28125db, dgain:18db */
+	{0x0784, 0x03}, /* index:452, gain:42.37500db, again:24.37500db, dgain:18db */
+	{0x0786, 0x03}, /* index:453, gain:42.46875db, again:24.46875db, dgain:18db */
+	{0x0787, 0x03}, /* index:454, gain:42.56250db, again:24.56250db, dgain:18db */
+	{0x0788, 0x03}, /* index:455, gain:42.65625db, again:24.65625db, dgain:18db */
+	{0x0789, 0x03}, /* index:456, gain:42.75000db, again:24.75000db, dgain:18db */
+	{0x078b, 0x03}, /* index:457, gain:42.84375db, again:24.84375db, dgain:18db */
+	{0x078c, 0x03}, /* index:458, gain:42.93750db, again:24.93750db, dgain:18db */
+	{0x078d, 0x03}, /* index:459, gain:43.03125db, again:25.03125db, dgain:18db */
+	{0x078e, 0x03}, /* index:460, gain:43.12500db, again:25.12500db, dgain:18db */
+	{0x0790, 0x03}, /* index:461, gain:43.21875db, again:25.21875db, dgain:18db */
+	{0x0791, 0x03}, /* index:462, gain:43.31250db, again:25.31250db, dgain:18db */
+	{0x0792, 0x03}, /* index:463, gain:43.40625db, again:25.40625db, dgain:18db */
+	{0x0793, 0x03}, /* index:464, gain:43.50000db, again:25.50000db, dgain:18db */
+	{0x0794, 0x03}, /* index:465, gain:43.59375db, again:25.59375db, dgain:18db */
+	{0x0796, 0x03}, /* index:466, gain:43.68750db, again:25.68750db, dgain:18db */
+	{0x0797, 0x03}, /* index:467, gain:43.78125db, again:25.78125db, dgain:18db */
+	{0x0798, 0x03}, /* index:468, gain:43.87500db, again:25.87500db, dgain:18db */
+	{0x0799, 0x03}, /* index:469, gain:43.96875db, again:25.96875db, dgain:18db */
+	{0x079a, 0x03}, /* index:470, gain:44.06250db, again:26.06250db, dgain:18db */
+	{0x079b, 0x03}, /* index:471, gain:44.15625db, again:26.15625db, dgain:18db */
+	{0x079c, 0x03}, /* index:472, gain:44.25000db, again:26.25000db, dgain:18db */
+	{0x079d, 0x03}, /* index:473, gain:44.34375db, again:26.34375db, dgain:18db */
+	{0x079e, 0x03}, /* index:474, gain:44.43750db, again:26.43750db, dgain:18db */
+	{0x079f, 0x03}, /* index:475, gain:44.53125db, again:26.53125db, dgain:18db */
+	{0x07a0, 0x03}, /* index:476, gain:44.62500db, again:26.62500db, dgain:18db */
+	{0x07a2, 0x03}, /* index:477, gain:44.71875db, again:26.71875db, dgain:18db */
+	{0x07a3, 0x03}, /* index:478, gain:44.81250db, again:26.81250db, dgain:18db */
+	{0x07a4, 0x03}, /* index:479, gain:44.90625db, again:26.90625db, dgain:18db */
+	{0x07a5, 0x03}, /* index:480, gain:45.00000db, again:27.00000db, dgain:18db */
+	{0x074b, 0x04}, /* index:481, gain:45.09375db, again:21.09375db, dgain:24db */
+	{0x074d, 0x04}, /* index:482, gain:45.18750db, again:21.18750db, dgain:24db */
+	{0x074f, 0x04}, /* index:483, gain:45.28125db, again:21.28125db, dgain:24db */
+	{0x0751, 0x04}, /* index:484, gain:45.37500db, again:21.37500db, dgain:24db */
+	{0x0753, 0x04}, /* index:485, gain:45.46875db, again:21.46875db, dgain:24db */
+	{0x0755, 0x04}, /* index:486, gain:45.56250db, again:21.56250db, dgain:24db */
+	{0x0757, 0x04}, /* index:487, gain:45.65625db, again:21.65625db, dgain:24db */
+	{0x0759, 0x04}, /* index:488, gain:45.75000db, again:21.75000db, dgain:24db */
+	{0x075a, 0x04}, /* index:489, gain:45.84375db, again:21.84375db, dgain:24db */
+	{0x075c, 0x04}, /* index:490, gain:45.93750db, again:21.93750db, dgain:24db */
+	{0x075e, 0x04}, /* index:491, gain:46.03125db, again:22.03125db, dgain:24db */
+	{0x0760, 0x04}, /* index:492, gain:46.12500db, again:22.12500db, dgain:24db */
+	{0x0761, 0x04}, /* index:493, gain:46.21875db, again:22.21875db, dgain:24db */
+	{0x0763, 0x04}, /* index:494, gain:46.31250db, again:22.31250db, dgain:24db */
+	{0x0765, 0x04}, /* index:495, gain:46.40625db, again:22.40625db, dgain:24db */
+	{0x0766, 0x04}, /* index:496, gain:46.50000db, again:22.50000db, dgain:24db */
+	{0x0768, 0x04}, /* index:497, gain:46.59375db, again:22.59375db, dgain:24db */
+	{0x076a, 0x04}, /* index:498, gain:46.68750db, again:22.68750db, dgain:24db */
+	{0x076b, 0x04}, /* index:499, gain:46.78125db, again:22.78125db, dgain:24db */
+	{0x076d, 0x04}, /* index:500, gain:46.87500db, again:22.87500db, dgain:24db */
+	{0x076e, 0x04}, /* index:501, gain:46.96875db, again:22.96875db, dgain:24db */
+	{0x0770, 0x04}, /* index:502, gain:47.06250db, again:23.06250db, dgain:24db */
+	{0x0772, 0x04}, /* index:503, gain:47.15625db, again:23.15625db, dgain:24db */
+	{0x0773, 0x04}, /* index:504, gain:47.25000db, again:23.25000db, dgain:24db */
+	{0x0775, 0x04}, /* index:505, gain:47.34375db, again:23.34375db, dgain:24db */
+	{0x0776, 0x04}, /* index:506, gain:47.43750db, again:23.43750db, dgain:24db */
+	{0x0778, 0x04}, /* index:507, gain:47.53125db, again:23.53125db, dgain:24db */
+	{0x0779, 0x04}, /* index:508, gain:47.62500db, again:23.62500db, dgain:24db */
+	{0x077b, 0x04}, /* index:509, gain:47.71875db, again:23.71875db, dgain:24db */
+	{0x077c, 0x04}, /* index:510, gain:47.81250db, again:23.81250db, dgain:24db */
+	{0x077d, 0x04}, /* index:511, gain:47.90625db, again:23.90625db, dgain:24db */
+	{0x077f, 0x04}, /* index:512, gain:48.00000db, again:24.00000db, dgain:24db */
+	{0x0780, 0x04}, /* index:513, gain:48.09375db, again:24.09375db, dgain:24db */
+	{0x0782, 0x04}, /* index:514, gain:48.18750db, again:24.18750db, dgain:24db */
+	{0x0783, 0x04}, /* index:515, gain:48.28125db, again:24.28125db, dgain:24db */
+	{0x0784, 0x04}, /* index:516, gain:48.37500db, again:24.37500db, dgain:24db */
+	{0x0786, 0x04}, /* index:517, gain:48.46875db, again:24.46875db, dgain:24db */
+	{0x0787, 0x04}, /* index:518, gain:48.56250db, again:24.56250db, dgain:24db */
+	{0x0788, 0x04}, /* index:519, gain:48.65625db, again:24.65625db, dgain:24db */
+	{0x0789, 0x04}, /* index:520, gain:48.75000db, again:24.75000db, dgain:24db */
+	{0x078b, 0x04}, /* index:521, gain:48.84375db, again:24.84375db, dgain:24db */
+	{0x078c, 0x04}, /* index:522, gain:48.93750db, again:24.93750db, dgain:24db */
+	{0x078d, 0x04}, /* index:523, gain:49.03125db, again:25.03125db, dgain:24db */
+	{0x078e, 0x04}, /* index:524, gain:49.12500db, again:25.12500db, dgain:24db */
+	{0x0790, 0x04}, /* index:525, gain:49.21875db, again:25.21875db, dgain:24db */
+	{0x0791, 0x04}, /* index:526, gain:49.31250db, again:25.31250db, dgain:24db */
+	{0x0792, 0x04}, /* index:527, gain:49.40625db, again:25.40625db, dgain:24db */
+	{0x0793, 0x04}, /* index:528, gain:49.50000db, again:25.50000db, dgain:24db */
+	{0x0794, 0x04}, /* index:529, gain:49.59375db, again:25.59375db, dgain:24db */
+	{0x0796, 0x04}, /* index:530, gain:49.68750db, again:25.68750db, dgain:24db */
+	{0x0797, 0x04}, /* index:531, gain:49.78125db, again:25.78125db, dgain:24db */
+	{0x0798, 0x04}, /* index:532, gain:49.87500db, again:25.87500db, dgain:24db */
+	{0x0799, 0x04}, /* index:533, gain:49.96875db, again:25.96875db, dgain:24db */
+	{0x079a, 0x04}, /* index:534, gain:50.06250db, again:26.06250db, dgain:24db */
+	{0x079b, 0x04}, /* index:535, gain:50.15625db, again:26.15625db, dgain:24db */
+	{0x079c, 0x04}, /* index:536, gain:50.25000db, again:26.25000db, dgain:24db */
+	{0x079d, 0x04}, /* index:537, gain:50.34375db, again:26.34375db, dgain:24db */
+	{0x079e, 0x04}, /* index:538, gain:50.43750db, again:26.43750db, dgain:24db */
+	{0x079f, 0x04}, /* index:539, gain:50.53125db, again:26.53125db, dgain:24db */
+	{0x07a0, 0x04}, /* index:540, gain:50.62500db, again:26.62500db, dgain:24db */
+	{0x07a2, 0x04}, /* index:541, gain:50.71875db, again:26.71875db, dgain:24db */
+	{0x07a3, 0x04}, /* index:542, gain:50.81250db, again:26.81250db, dgain:24db */
+	{0x07a4, 0x04}, /* index:543, gain:50.90625db, again:26.90625db, dgain:24db */
+	{0x07a5, 0x04}, /* index:544, gain:51.00000db, again:27.00000db, dgain:24db */
+	{0x074b, 0x05}, /* index:545, gain:51.09375db, again:21.09375db, dgain:30db */
+	{0x074d, 0x05}, /* index:546, gain:51.18750db, again:21.18750db, dgain:30db */
+	{0x074f, 0x05}, /* index:547, gain:51.28125db, again:21.28125db, dgain:30db */
+	{0x0751, 0x05}, /* index:548, gain:51.37500db, again:21.37500db, dgain:30db */
+	{0x0753, 0x05}, /* index:549, gain:51.46875db, again:21.46875db, dgain:30db */
+	{0x0755, 0x05}, /* index:550, gain:51.56250db, again:21.56250db, dgain:30db */
+	{0x0757, 0x05}, /* index:551, gain:51.65625db, again:21.65625db, dgain:30db */
+	{0x0759, 0x05}, /* index:552, gain:51.75000db, again:21.75000db, dgain:30db */
+	{0x075a, 0x05}, /* index:553, gain:51.84375db, again:21.84375db, dgain:30db */
+	{0x075c, 0x05}, /* index:554, gain:51.93750db, again:21.93750db, dgain:30db */
+	{0x075e, 0x05}, /* index:555, gain:52.03125db, again:22.03125db, dgain:30db */
+	{0x0760, 0x05}, /* index:556, gain:52.12500db, again:22.12500db, dgain:30db */
+	{0x0761, 0x05}, /* index:557, gain:52.21875db, again:22.21875db, dgain:30db */
+	{0x0763, 0x05}, /* index:558, gain:52.31250db, again:22.31250db, dgain:30db */
+	{0x0765, 0x05}, /* index:559, gain:52.40625db, again:22.40625db, dgain:30db */
+	{0x0766, 0x05}, /* index:560, gain:52.50000db, again:22.50000db, dgain:30db */
+	{0x0768, 0x05}, /* index:561, gain:52.59375db, again:22.59375db, dgain:30db */
+	{0x076a, 0x05}, /* index:562, gain:52.68750db, again:22.68750db, dgain:30db */
+	{0x076b, 0x05}, /* index:563, gain:52.78125db, again:22.78125db, dgain:30db */
+	{0x076d, 0x05}, /* index:564, gain:52.87500db, again:22.87500db, dgain:30db */
+	{0x076e, 0x05}, /* index:565, gain:52.96875db, again:22.96875db, dgain:30db */
+	{0x0770, 0x05}, /* index:566, gain:53.06250db, again:23.06250db, dgain:30db */
+	{0x0772, 0x05}, /* index:567, gain:53.15625db, again:23.15625db, dgain:30db */
+	{0x0773, 0x05}, /* index:568, gain:53.25000db, again:23.25000db, dgain:30db */
+	{0x0775, 0x05}, /* index:569, gain:53.34375db, again:23.34375db, dgain:30db */
+	{0x0776, 0x05}, /* index:570, gain:53.43750db, again:23.43750db, dgain:30db */
+	{0x0778, 0x05}, /* index:571, gain:53.53125db, again:23.53125db, dgain:30db */
+	{0x0779, 0x05}, /* index:572, gain:53.62500db, again:23.62500db, dgain:30db */
+	{0x077b, 0x05}, /* index:573, gain:53.71875db, again:23.71875db, dgain:30db */
+	{0x077c, 0x05}, /* index:574, gain:53.81250db, again:23.81250db, dgain:30db */
+	{0x077d, 0x05}, /* index:575, gain:53.90625db, again:23.90625db, dgain:30db */
+	{0x077f, 0x05}, /* index:576, gain:54.00000db, again:24.00000db, dgain:30db */
+	{0x0780, 0x05}, /* index:577, gain:54.09375db, again:24.09375db, dgain:30db */
+	{0x0782, 0x05}, /* index:578, gain:54.18750db, again:24.18750db, dgain:30db */
+	{0x0783, 0x05}, /* index:579, gain:54.28125db, again:24.28125db, dgain:30db */
+	{0x0784, 0x05}, /* index:580, gain:54.37500db, again:24.37500db, dgain:30db */
+	{0x0786, 0x05}, /* index:581, gain:54.46875db, again:24.46875db, dgain:30db */
+	{0x0787, 0x05}, /* index:582, gain:54.56250db, again:24.56250db, dgain:30db */
+	{0x0788, 0x05}, /* index:583, gain:54.65625db, again:24.65625db, dgain:30db */
+	{0x0789, 0x05}, /* index:584, gain:54.75000db, again:24.75000db, dgain:30db */
+	{0x078b, 0x05}, /* index:585, gain:54.84375db, again:24.84375db, dgain:30db */
+	{0x078c, 0x05}, /* index:586, gain:54.93750db, again:24.93750db, dgain:30db */
+	{0x078d, 0x05}, /* index:587, gain:55.03125db, again:25.03125db, dgain:30db */
+	{0x078e, 0x05}, /* index:588, gain:55.12500db, again:25.12500db, dgain:30db */
+	{0x0790, 0x05}, /* index:589, gain:55.21875db, again:25.21875db, dgain:30db */
+	{0x0791, 0x05}, /* index:590, gain:55.31250db, again:25.31250db, dgain:30db */
+	{0x0792, 0x05}, /* index:591, gain:55.40625db, again:25.40625db, dgain:30db */
+	{0x0793, 0x05}, /* index:592, gain:55.50000db, again:25.50000db, dgain:30db */
+	{0x0794, 0x05}, /* index:593, gain:55.59375db, again:25.59375db, dgain:30db */
+	{0x0796, 0x05}, /* index:594, gain:55.68750db, again:25.68750db, dgain:30db */
+	{0x0797, 0x05}, /* index:595, gain:55.78125db, again:25.78125db, dgain:30db */
+	{0x0798, 0x05}, /* index:596, gain:55.87500db, again:25.87500db, dgain:30db */
+	{0x0799, 0x05}, /* index:597, gain:55.96875db, again:25.96875db, dgain:30db */
+	{0x079a, 0x05}, /* index:598, gain:56.06250db, again:26.06250db, dgain:30db */
+	{0x079b, 0x05}, /* index:599, gain:56.15625db, again:26.15625db, dgain:30db */
+	{0x079c, 0x05}, /* index:600, gain:56.25000db, again:26.25000db, dgain:30db */
+	{0x079d, 0x05}, /* index:601, gain:56.34375db, again:26.34375db, dgain:30db */
+	{0x079e, 0x05}, /* index:602, gain:56.43750db, again:26.43750db, dgain:30db */
+	{0x079f, 0x05}, /* index:603, gain:56.53125db, again:26.53125db, dgain:30db */
+	{0x07a0, 0x05}, /* index:604, gain:56.62500db, again:26.62500db, dgain:30db */
+	{0x07a2, 0x05}, /* index:605, gain:56.71875db, again:26.71875db, dgain:30db */
+	{0x07a3, 0x05}, /* index:606, gain:56.81250db, again:26.81250db, dgain:30db */
+	{0x07a4, 0x05}, /* index:607, gain:56.90625db, again:26.90625db, dgain:30db */
+	{0x07a5, 0x05}, /* index:608, gain:57.00000db, again:27.00000db, dgain:30db */
+	{0x074b, 0x06}, /* index:609, gain:57.09375db, again:21.09375db, dgain:36db */
+	{0x074d, 0x06}, /* index:610, gain:57.18750db, again:21.18750db, dgain:36db */
+	{0x074f, 0x06}, /* index:611, gain:57.28125db, again:21.28125db, dgain:36db */
+	{0x0751, 0x06}, /* index:612, gain:57.37500db, again:21.37500db, dgain:36db */
+	{0x0753, 0x06}, /* index:613, gain:57.46875db, again:21.46875db, dgain:36db */
+	{0x0755, 0x06}, /* index:614, gain:57.56250db, again:21.56250db, dgain:36db */
+	{0x0757, 0x06}, /* index:615, gain:57.65625db, again:21.65625db, dgain:36db */
+	{0x0759, 0x06}, /* index:616, gain:57.75000db, again:21.75000db, dgain:36db */
+	{0x075a, 0x06}, /* index:617, gain:57.84375db, again:21.84375db, dgain:36db */
+	{0x075c, 0x06}, /* index:618, gain:57.93750db, again:21.93750db, dgain:36db */
+	{0x075e, 0x06}, /* index:619, gain:58.03125db, again:22.03125db, dgain:36db */
+	{0x0760, 0x06}, /* index:620, gain:58.12500db, again:22.12500db, dgain:36db */
+	{0x0761, 0x06}, /* index:621, gain:58.21875db, again:22.21875db, dgain:36db */
+	{0x0763, 0x06}, /* index:622, gain:58.31250db, again:22.31250db, dgain:36db */
+	{0x0765, 0x06}, /* index:623, gain:58.40625db, again:22.40625db, dgain:36db */
+	{0x0766, 0x06}, /* index:624, gain:58.50000db, again:22.50000db, dgain:36db */
+	{0x0768, 0x06}, /* index:625, gain:58.59375db, again:22.59375db, dgain:36db */
+	{0x076a, 0x06}, /* index:626, gain:58.68750db, again:22.68750db, dgain:36db */
+	{0x076b, 0x06}, /* index:627, gain:58.78125db, again:22.78125db, dgain:36db */
+	{0x076d, 0x06}, /* index:628, gain:58.87500db, again:22.87500db, dgain:36db */
+	{0x076e, 0x06}, /* index:629, gain:58.96875db, again:22.96875db, dgain:36db */
+	{0x0770, 0x06}, /* index:630, gain:59.06250db, again:23.06250db, dgain:36db */
+	{0x0772, 0x06}, /* index:631, gain:59.15625db, again:23.15625db, dgain:36db */
+	{0x0773, 0x06}, /* index:632, gain:59.25000db, again:23.25000db, dgain:36db */
+	{0x0775, 0x06}, /* index:633, gain:59.34375db, again:23.34375db, dgain:36db */
+	{0x0776, 0x06}, /* index:634, gain:59.43750db, again:23.43750db, dgain:36db */
+	{0x0778, 0x06}, /* index:635, gain:59.53125db, again:23.53125db, dgain:36db */
+	{0x0779, 0x06}, /* index:636, gain:59.62500db, again:23.62500db, dgain:36db */
+	{0x077b, 0x06}, /* index:637, gain:59.71875db, again:23.71875db, dgain:36db */
+	{0x077c, 0x06}, /* index:638, gain:59.81250db, again:23.81250db, dgain:36db */
+	{0x077d, 0x06}, /* index:639, gain:59.90625db, again:23.90625db, dgain:36db */
+	{0x077f, 0x06}, /* index:640, gain:60.00000db, again:24.00000db, dgain:36db */
+	{0x0780, 0x06}, /* index:641, gain:60.09375db, again:24.09375db, dgain:36db */
+	{0x0782, 0x06}, /* index:642, gain:60.18750db, again:24.18750db, dgain:36db */
+	{0x0783, 0x06}, /* index:643, gain:60.28125db, again:24.28125db, dgain:36db */
+	{0x0784, 0x06}, /* index:644, gain:60.37500db, again:24.37500db, dgain:36db */
+	{0x0786, 0x06}, /* index:645, gain:60.46875db, again:24.46875db, dgain:36db */
+	{0x0787, 0x06}, /* index:646, gain:60.56250db, again:24.56250db, dgain:36db */
+	{0x0788, 0x06}, /* index:647, gain:60.65625db, again:24.65625db, dgain:36db */
+	{0x0789, 0x06}, /* index:648, gain:60.75000db, again:24.75000db, dgain:36db */
+	{0x078b, 0x06}, /* index:649, gain:60.84375db, again:24.84375db, dgain:36db */
+	{0x078c, 0x06}, /* index:650, gain:60.93750db, again:24.93750db, dgain:36db */
+	{0x078d, 0x06}, /* index:651, gain:61.03125db, again:25.03125db, dgain:36db */
+	{0x078e, 0x06}, /* index:652, gain:61.12500db, again:25.12500db, dgain:36db */
+	{0x0790, 0x06}, /* index:653, gain:61.21875db, again:25.21875db, dgain:36db */
+	{0x0791, 0x06}, /* index:654, gain:61.31250db, again:25.31250db, dgain:36db */
+	{0x0792, 0x06}, /* index:655, gain:61.40625db, again:25.40625db, dgain:36db */
+	{0x0793, 0x06}, /* index:656, gain:61.50000db, again:25.50000db, dgain:36db */
+	{0x0794, 0x06}, /* index:657, gain:61.59375db, again:25.59375db, dgain:36db */
+	{0x0796, 0x06}, /* index:658, gain:61.68750db, again:25.68750db, dgain:36db */
+	{0x0797, 0x06}, /* index:659, gain:61.78125db, again:25.78125db, dgain:36db */
+	{0x0798, 0x06}, /* index:660, gain:61.87500db, again:25.87500db, dgain:36db */
+	{0x0799, 0x06}, /* index:661, gain:61.96875db, again:25.96875db, dgain:36db */
+	{0x079a, 0x06}, /* index:662, gain:62.06250db, again:26.06250db, dgain:36db */
+	{0x079b, 0x06}, /* index:663, gain:62.15625db, again:26.15625db, dgain:36db */
+	{0x079c, 0x06}, /* index:664, gain:62.25000db, again:26.25000db, dgain:36db */
+	{0x079d, 0x06}, /* index:665, gain:62.34375db, again:26.34375db, dgain:36db */
+	{0x079e, 0x06}, /* index:666, gain:62.43750db, again:26.43750db, dgain:36db */
+	{0x079f, 0x06}, /* index:667, gain:62.53125db, again:26.53125db, dgain:36db */
+	{0x07a0, 0x06}, /* index:668, gain:62.62500db, again:26.62500db, dgain:36db */
+	{0x07a2, 0x06}, /* index:669, gain:62.71875db, again:26.71875db, dgain:36db */
+	{0x07a3, 0x06}, /* index:670, gain:62.81250db, again:26.81250db, dgain:36db */
+	{0x07a4, 0x06}, /* index:671, gain:62.90625db, again:26.90625db, dgain:36db */
+	{0x07a5, 0x06}, /* index:672, gain:63.00000db, again:27.00000db, dgain:36db */
+};
+
diff --git a/drivers/vin/sensors/sony_imx326/make.inc b/drivers/vin/sensors/sony_imx326/make.inc
new file mode 100644
index 0000000..b34524c
--- /dev/null
+++ b/drivers/vin/sensors/sony_imx326/make.inc
@@ -0,0 +1,45 @@
+##
+## kernel/private/drivers/vin/sensors/sony_imx326/make.inc
+##
+## History:
+##    2016/10/17 - [Hao Zeng] created file
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+ifeq ($(CONFIG_SENSOR_IMX326), y)
+
+LOCAL_PATH	:= $(call my-dir)
+
+###
+include $(CLEAR_VARS)
+
+LOCAL_SRCS	:= $(wildcard $(LOCAL_PATH)/*.c) $(wildcard $(LOCAL_PATH)/*.h)
+LOCAL_SRCS	+= $(LOCAL_PATH)/Kbuild
+
+include $(BUILD_DRIVER)
+
+endif
+
diff --git a/drivers/vout/AmbaConfig b/drivers/vout/AmbaConfig
index 070ae69..afa05d1 100644
--- a/drivers/vout/AmbaConfig
+++ b/drivers/vout/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2009/05/14 - [Anthony Ginger] Create
 ##
-## Copyright (C) 2004-2008, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 menuconfig BUILD_AMBARELLA_VOUT
diff --git a/drivers/vout/ambosd.c b/drivers/vout/ambosd.c
index 95d3bcc..d086903 100644
--- a/drivers/vout/ambosd.c
+++ b/drivers/vout/ambosd.c
@@ -4,20 +4,38 @@
  * History:
  *    2009/11/03 - [Zhenwu Xue] Initial revision
  *
- * Copyright (C) 2004-2009, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/fb.h>
 #include <plat/fb.h>
-#include <plat/ambcache.h>
 #include <iav_utils.h>
 #include "vout_pri.h"
 
@@ -1482,6 +1500,10 @@ int amba_osd_on_vout_change(int vout_id, struct amba_video_sink_mode *sink_mode)
 			piav_info->pan_display = amba_direct_pan_display;
 			break;
 
+                case AMBFB_COLOR_AGBR8888:
+			piav_info->pan_display = amba_direct_pan_display;
+			break;
+
 		case AMBFB_COLOR_VYU565:
 			piav_info->pan_display = amba_direct_pan_display;
 			break;
diff --git a/drivers/vout/arch_s2l/Kbuild b/drivers/vout/arch_s2l/Kbuild
index 0ab3d25..409d6f7 100644
--- a/drivers/vout/arch_s2l/Kbuild
+++ b/drivers/vout/arch_s2l/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2009/07/09 - [Anthony Ginger] Create
 ##
-## Copyright (C) 2004-2008, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS) -I$(AMB_TOPDIR)/kernel/private/drivers/vout
diff --git a/drivers/vout/arch_s2l/ambosd_arch.c b/drivers/vout/arch_s2l/ambosd_arch.c
index 9e71eda..4a441d4 100644
--- a/drivers/vout/arch_s2l/ambosd_arch.c
+++ b/drivers/vout/arch_s2l/ambosd_arch.c
@@ -4,14 +4,33 @@
  * History:
  *    2009/11/02 - [Zhenwu Xue] Initial revision
  *
- * Copyright (C) 2004-2009, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <mach/init.h>
 #include "dsp_cmd_msg.h"
 
@@ -22,304 +41,313 @@ extern int dma_memcpy(u8 *dest_addr, u8 *src_addr, u32 size);
 static int fb_memcpy(u8 *dest_addr, u8 *src_addr, u32 size)
 {
 #if 0
-	return dma_memcpy((u8 *)ambarella_virt_to_phys((u32)dest_addr),
-		(u8 *)ambarella_virt_to_phys((u32)src_addr),
-		size);
+        return dma_memcpy((u8 *)ambarella_virt_to_phys((u32)dest_addr),
+                          (u8 *)ambarella_virt_to_phys((u32)src_addr),
+                          size);
 #else
-	memcpy(dest_addr, src_addr, size);
-	return 0;
+        memcpy(dest_addr, src_addr, size);
+        return 0;
 #endif
 }
 
 static int amba_direct_pan_display_arch(struct fb_info *info,
-	ambosd_info_t *posd_info, u8 *pDstOSDBuffer)
+                                        ambosd_info_t *posd_info, u8 *pDstOSDBuffer)
 {
-	int			i, vout_id;
-	vout_osd_buf_setup_t	osd_buf_setup;
-
-       if(posd_info->conversion_buf.available){
-              osd_buf_setup.osd_buf_dram_addr =
-                     posd_info->conversion_buf.base_buf_phy;
-       }else{
-              osd_buf_setup.osd_buf_dram_addr =
-                     ambarella_virt_to_phys((u32)pDstOSDBuffer);
-       }
-
-	osd_buf_setup.osd_buf_pitch = info->fix.line_length;
-
-	for (i = 0; i < 2; i++) {
-		vout_id = posd_info->vout_id[i];
-		if (vout_id == 0 || vout_id == 1) {
-			amba_vout_video_source_cmd(vout_id,
-				AMBA_VIDEO_SOURCE_SET_OSD_BUFFER,
-				&osd_buf_setup);
-		}
-	}
-
-	return 0;
+        int			i, vout_id;
+        vout_osd_buf_setup_t	osd_buf_setup;
+
+        if(posd_info->conversion_buf.available) {
+                osd_buf_setup.osd_buf_dram_addr =
+                        posd_info->conversion_buf.base_buf_phy;
+        } else {
+                osd_buf_setup.osd_buf_dram_addr =
+                        ambarella_virt_to_phys((u32)pDstOSDBuffer);
+        }
+
+        osd_buf_setup.osd_buf_pitch = info->fix.line_length;
+
+        for (i = 0; i < 2; i++) {
+                vout_id = posd_info->vout_id[i];
+                if (vout_id == 0 || vout_id == 1) {
+                        amba_vout_video_source_cmd(vout_id,
+                                                   AMBA_VIDEO_SOURCE_SET_OSD_BUFFER,
+                                                   &osd_buf_setup);
+                }
+        }
+
+        return 0;
 }
 
 static int amba_rgb2clut_pan_display_arch(struct fb_info *info,
-	ambosd_info_t *posd_info, u8 *pDstOSDBuffer)
+                                          ambosd_info_t *posd_info, u8 *pDstOSDBuffer)
 {
-	int			i, vout_id;
-	vout_osd_buf_setup_t	osd_buf_setup;
-
-       if(posd_info->conversion_buf.available){
-              if(pDstOSDBuffer == (u8 *)posd_info->conversion_buf.ping_buf)
-                     osd_buf_setup.osd_buf_dram_addr =
-                            posd_info->conversion_buf.ping_buf_phy;
-              if(pDstOSDBuffer == (u8 *)posd_info->conversion_buf.pong_buf)
-                     osd_buf_setup.osd_buf_dram_addr =
-                            posd_info->conversion_buf.pong_buf_phy;
-       }else{
-              osd_buf_setup.osd_buf_dram_addr =
-                     ambarella_virt_to_phys((u32)pDstOSDBuffer);
-       }
-
-	osd_buf_setup.osd_buf_pitch = info->fix.line_length >> 1;
-
-	for (i = 0; i < 2; i++) {
-		vout_id = posd_info->vout_id[i];
-		if (vout_id == 0 || vout_id == 1) {
-			amba_vout_video_source_cmd(vout_id,
-				AMBA_VIDEO_SOURCE_SET_OSD_BUFFER,
-				&osd_buf_setup);
-		}
-	}
-
-	return 0;
+        int			i, vout_id;
+        vout_osd_buf_setup_t	osd_buf_setup;
+
+        if(posd_info->conversion_buf.available) {
+                if(pDstOSDBuffer == (u8 *)posd_info->conversion_buf.ping_buf)
+                        osd_buf_setup.osd_buf_dram_addr =
+                                posd_info->conversion_buf.ping_buf_phy;
+                if(pDstOSDBuffer == (u8 *)posd_info->conversion_buf.pong_buf)
+                        osd_buf_setup.osd_buf_dram_addr =
+                                posd_info->conversion_buf.pong_buf_phy;
+        } else {
+                osd_buf_setup.osd_buf_dram_addr =
+                        ambarella_virt_to_phys((u32)pDstOSDBuffer);
+        }
+
+        osd_buf_setup.osd_buf_pitch = info->fix.line_length >> 1;
+
+        for (i = 0; i < 2; i++) {
+                vout_id = posd_info->vout_id[i];
+                if (vout_id == 0 || vout_id == 1) {
+                        amba_vout_video_source_cmd(vout_id,
+                                                   AMBA_VIDEO_SOURCE_SET_OSD_BUFFER,
+                                                   &osd_buf_setup);
+                }
+        }
+
+        return 0;
 }
 
 static int amba_rgb2yuv_pan_display_arch(struct fb_info *info,
-	ambosd_info_t *posd_info, u16 *pDstOSDBuffer)
+                                         ambosd_info_t *posd_info, u16 *pDstOSDBuffer)
 {
-	int			i, vout_id;
-	vout_osd_buf_setup_t	osd_buf_setup;
-
-       if(posd_info->conversion_buf.available){
-              if(pDstOSDBuffer == (u16 *)posd_info->conversion_buf.ping_buf)
-                     osd_buf_setup.osd_buf_dram_addr =
-                            posd_info->conversion_buf.ping_buf_phy;
-              if(pDstOSDBuffer == (u16 *)posd_info->conversion_buf.pong_buf)
-                     osd_buf_setup.osd_buf_dram_addr =
-                            posd_info->conversion_buf.pong_buf_phy;
-       }else{
-              osd_buf_setup.osd_buf_dram_addr =
-                     ambarella_virt_to_phys((u32)pDstOSDBuffer);
-       }
-
-	osd_buf_setup.osd_buf_pitch = info->fix.line_length;
-	if (posd_info->color_format == AMBFB_COLOR_RGBA8888 ||
-		posd_info->color_format == AMBFB_COLOR_ABGR8888) {
-		osd_buf_setup.osd_buf_pitch >>= 1;
-	}
-
-	for (i = 0; i < 2; i++) {
-		vout_id = posd_info->vout_id[i];
-		if (vout_id == 0 || vout_id == 1) {
-			amba_vout_video_source_cmd(vout_id,
-				AMBA_VIDEO_SOURCE_SET_OSD_BUFFER,
-				&osd_buf_setup);
-		}
-	}
-
-	return 0;
+        int			i, vout_id;
+        vout_osd_buf_setup_t	osd_buf_setup;
+
+        if(posd_info->conversion_buf.available) {
+                if(pDstOSDBuffer == (u16 *)posd_info->conversion_buf.ping_buf)
+                        osd_buf_setup.osd_buf_dram_addr =
+                                posd_info->conversion_buf.ping_buf_phy;
+                if(pDstOSDBuffer == (u16 *)posd_info->conversion_buf.pong_buf)
+                        osd_buf_setup.osd_buf_dram_addr =
+                                posd_info->conversion_buf.pong_buf_phy;
+        } else {
+                osd_buf_setup.osd_buf_dram_addr =
+                        ambarella_virt_to_phys((u32)pDstOSDBuffer);
+        }
+
+        osd_buf_setup.osd_buf_pitch = info->fix.line_length;
+        if (posd_info->color_format == AMBFB_COLOR_RGBA8888 ||
+            posd_info->color_format == AMBFB_COLOR_ABGR8888) {
+                osd_buf_setup.osd_buf_pitch >>= 1;
+        }
+
+        for (i = 0; i < 2; i++) {
+                vout_id = posd_info->vout_id[i];
+                if (vout_id == 0 || vout_id == 1) {
+                        amba_vout_video_source_cmd(vout_id,
+                                                   AMBA_VIDEO_SOURCE_SET_OSD_BUFFER,
+                                                   &osd_buf_setup);
+                }
+        }
+
+        return 0;
 }
 
 static int amba_osd_on_vout_change_pre_arch(ambosd_info_t *posd_info)
 {
-	if (posd_info) {
-		posd_info->support_direct_mode	= 1;
-		posd_info->support_mixer_csc	= 1;
-	}
+        if (posd_info) {
+                posd_info->support_direct_mode	= 1;
+                posd_info->support_mixer_csc	= 1;
+        }
 
-	return 0;
+        return 0;
 }
 
 static int amba_osd_on_vout_change_arch(int vout_id,
-	struct amba_video_sink_mode *sink_mode,
-	ambosd_info_t *posd_info,
-	struct ambarella_platform_fb *pplatform_info)
+                                        struct amba_video_sink_mode *sink_mode,
+                                        ambosd_info_t *posd_info,
+                                        struct ambarella_platform_fb *pplatform_info)
 {
-	int 					ret = 0;
-	struct amba_vout_window_info		active_window;
-	int					width, height;
-	vout_osd_setup_t			def_osd_setup;
+        int 					ret = 0;
+        struct amba_vout_window_info		active_window;
+        int					width, height;
+        vout_osd_setup_t			def_osd_setup;
         struct amba_video_source_osd_clut_info  osd_clut_info;
-	int					blank_x, blank_y;
+        int					blank_x, blank_y;
 
-	/* Disable OSD */
-	if (!posd_info) {
-		memset(&def_osd_setup, 0, sizeof(vout_osd_setup_t));
-		amba_vout_video_source_cmd(vout_id,
-			AMBA_VIDEO_SOURCE_SET_OSD, &def_osd_setup);
-		goto amba_osd_on_vout_change_arch_exit;
-	}
+        /* Disable OSD */
+        if (!posd_info) {
+                memset(&def_osd_setup, 0, sizeof(vout_osd_setup_t));
+                amba_vout_video_source_cmd(vout_id,
+                                           AMBA_VIDEO_SOURCE_SET_OSD, &def_osd_setup);
+                goto amba_osd_on_vout_change_arch_exit;
+        }
 
         ret = amba_vout_video_source_cmd(vout_id,
-		AMBA_VIDEO_SOURCE_GET_ACTIVE_WIN, &active_window);
+                                         AMBA_VIDEO_SOURCE_GET_ACTIVE_WIN, &active_window);
         if (ret) {
                 vout_err("%s: AMBA_VIDEO_SOURCE_GET_ACTIVE_WIN %d\n",
-                        __func__, ret);
+                         __func__, ret);
                 goto amba_osd_on_vout_change_arch_exit;
         } else {
-		width	= active_window.width;
-		height	= active_window.end_y - active_window.start_y + 1;
-		if (posd_info->interlace[vout_id]) {
-			height <<= 1;
-		}
+                width	= active_window.width;
+                height	= active_window.end_y - active_window.start_y + 1;
+                if (posd_info->interlace[vout_id]) {
+                        height <<= 1;
+                }
+        }
+
+        def_osd_setup.en		= 1;
+        def_osd_setup.flip		= sink_mode->osd_flip;
+        def_osd_setup.rescaler_en	= sink_mode->osd_rescale.enable;
+        def_osd_setup.premultiplied	= 0;
+        def_osd_setup.global_blend	= 0xFF;
+        if (!def_osd_setup.rescaler_en) {
+                def_osd_setup.win_width		= MIN(width, pplatform_info->screen_var.xres);
+                def_osd_setup.win_height	= MIN(height, pplatform_info->screen_var.yres);
+        } else {
+                def_osd_setup.win_width		= sink_mode->osd_rescale.width;
+                def_osd_setup.win_height	= sink_mode->osd_rescale.height;
+        }
+        blank_x	= width  - def_osd_setup.win_width;
+        blank_y	= height - def_osd_setup.win_height;
+        if (sink_mode->osd_offset.specified) {
+                def_osd_setup.win_offset_x = MIN(sink_mode->osd_offset.offset_x, blank_x);
+                def_osd_setup.win_offset_y = MIN(sink_mode->osd_offset.offset_y, blank_y);
+        } else {
+                def_osd_setup.win_offset_x = blank_x >> 1;
+                def_osd_setup.win_offset_y = blank_y >> 1;
+        }
+        if (!def_osd_setup.rescaler_en) {
+                def_osd_setup.rescaler_input_width  = 0;
+                def_osd_setup.rescaler_input_height = 0;
+        } else {
+                def_osd_setup.rescaler_input_width  = MIN(width, pplatform_info->screen_var.xres);
+                def_osd_setup.rescaler_input_height = MIN(height, pplatform_info->screen_var.yres);
+        }
+        def_osd_setup.osd_buf_repeat_field	= 0;
+        def_osd_setup.osd_buf_dram_addr		= pplatform_info->screen_fix.smem_start
+                                                  + pplatform_info->screen_fix.line_length * pplatform_info->screen_var.yoffset;
+        def_osd_setup.osd_buf_pitch		=
+                pplatform_info->screen_fix.line_length;
+
+        if (posd_info->interlace[vout_id]) {
+                def_osd_setup.win_height		>>= 1;
+                def_osd_setup.win_offset_y		>>= 1;
+                def_osd_setup.rescaler_input_height	>>= 1;
         }
 
-	def_osd_setup.en		= 1;
-	def_osd_setup.flip		= sink_mode->osd_flip;
-	def_osd_setup.rescaler_en	= sink_mode->osd_rescale.enable;
-	def_osd_setup.premultiplied	= 0;
-	def_osd_setup.global_blend	= 0xFF;
-	if (!def_osd_setup.rescaler_en) {
-		def_osd_setup.win_width		= MIN(width, pplatform_info->screen_var.xres);
-		def_osd_setup.win_height	= MIN(height, pplatform_info->screen_var.yres);
-	} else {
-		def_osd_setup.win_width		= sink_mode->osd_rescale.width;
-		def_osd_setup.win_height	= sink_mode->osd_rescale.height;
-	}
-	blank_x	= width  - def_osd_setup.win_width;
-	blank_y	= height - def_osd_setup.win_height;
-	if (sink_mode->osd_offset.specified) {
-		def_osd_setup.win_offset_x = MIN(sink_mode->osd_offset.offset_x, blank_x);
-		def_osd_setup.win_offset_y = MIN(sink_mode->osd_offset.offset_y, blank_y);
-	} else {
-		def_osd_setup.win_offset_x = blank_x >> 1;
-		def_osd_setup.win_offset_y = blank_y >> 1;
-	}
-	if (!def_osd_setup.rescaler_en) {
-		def_osd_setup.rescaler_input_width  = 0;
-		def_osd_setup.rescaler_input_height = 0;
-	} else {
-		def_osd_setup.rescaler_input_width  = MIN(width, pplatform_info->screen_var.xres);
-		def_osd_setup.rescaler_input_height = MIN(height, pplatform_info->screen_var.yres);
-	}
-	def_osd_setup.osd_buf_repeat_field	= 0;
-	def_osd_setup.osd_buf_dram_addr		= pplatform_info->screen_fix.smem_start
-		+ pplatform_info->screen_fix.line_length * pplatform_info->screen_var.yoffset;
-	def_osd_setup.osd_buf_pitch		=
-		pplatform_info->screen_fix.line_length;
-
-	if (posd_info->interlace[vout_id]) {
-		def_osd_setup.win_height		>>= 1;
-		def_osd_setup.win_offset_y		>>= 1;
-		def_osd_setup.rescaler_input_height	>>= 1;
-	}
-
-	switch (pplatform_info->color_format) {
-	case AMBFB_COLOR_CLUT_8BPP:
-		def_osd_setup.src			= OSD_SRC_MAPPED_IN;
-		def_osd_setup.osd_direct_mode		= 0;
-		def_osd_setup.osd_transparent_color_en	= 0;
-		amba_vout_video_source_cmd(vout_id, AMBA_VIDEO_SOURCE_SET_OSD, &def_osd_setup);
-
-		osd_clut_info.pclut_table		= pplatform_info->clut_table;
-		osd_clut_info.pblend_table		= pplatform_info->blend_table;
-		amba_vout_video_source_cmd(vout_id, AMBA_VIDEO_SOURCE_SET_OSD_CLUT, &osd_clut_info);
-
-		break;
-
-	case AMBFB_COLOR_AUTO:
-	case AMBFB_COLOR_RGB565:
-		def_osd_setup.src			= OSD_SRC_DIRECT_IN_16;
-		def_osd_setup.osd_direct_mode		= 0;
-		def_osd_setup.osd_transparent_color	= 0x0000;
-		def_osd_setup.osd_transparent_color_en	= 1;
-		amba_vout_video_source_cmd(vout_id, AMBA_VIDEO_SOURCE_SET_OSD, &def_osd_setup);
-
-		break;
-
-	case AMBFB_COLOR_VYU565:
-		def_osd_setup.src			= OSD_SRC_DIRECT_IN_16;
-		def_osd_setup.osd_direct_mode		= 0;
-		def_osd_setup.osd_transparent_color	= 0x0000;
-		def_osd_setup.osd_transparent_color_en	= 1;
-		amba_vout_video_source_cmd(vout_id, AMBA_VIDEO_SOURCE_SET_OSD, &def_osd_setup);
-
-		break;
-
-	default:
-		break;
-	}
+        switch (pplatform_info->color_format) {
+        case AMBFB_COLOR_CLUT_8BPP:
+                def_osd_setup.src			= OSD_SRC_MAPPED_IN;
+                def_osd_setup.osd_direct_mode		= 0;
+                def_osd_setup.osd_transparent_color_en	= 0;
+                amba_vout_video_source_cmd(vout_id, AMBA_VIDEO_SOURCE_SET_OSD, &def_osd_setup);
+
+                osd_clut_info.pclut_table		= pplatform_info->clut_table;
+                osd_clut_info.pblend_table		= pplatform_info->blend_table;
+                amba_vout_video_source_cmd(vout_id, AMBA_VIDEO_SOURCE_SET_OSD_CLUT, &osd_clut_info);
+
+                break;
+
+        case AMBFB_COLOR_AUTO:
+        case AMBFB_COLOR_RGB565:
+                def_osd_setup.src			= OSD_SRC_DIRECT_IN_16;
+                def_osd_setup.osd_direct_mode		= 0;
+                def_osd_setup.osd_transparent_color	= 0x0000;
+                def_osd_setup.osd_transparent_color_en	= 1;
+                amba_vout_video_source_cmd(vout_id, AMBA_VIDEO_SOURCE_SET_OSD, &def_osd_setup);
+
+                break;
+
+        case AMBFB_COLOR_VYU565:
+                def_osd_setup.src			= OSD_SRC_DIRECT_IN_16;
+                def_osd_setup.osd_direct_mode		= 0;
+                def_osd_setup.osd_transparent_color	= 0x0000;
+                def_osd_setup.osd_transparent_color_en	= 1;
+                amba_vout_video_source_cmd(vout_id, AMBA_VIDEO_SOURCE_SET_OSD, &def_osd_setup);
+
+                break;
+
+        case AMBFB_COLOR_AYUV8888:
+        case AMBFB_COLOR_AGBR8888:
+                def_osd_setup.src			= 2;
+                def_osd_setup.osd_direct_mode		= 27;
+                def_osd_setup.osd_transparent_color	= 0x0000;
+                def_osd_setup.osd_transparent_color_en	= 1;
+                amba_vout_video_source_cmd(vout_id, AMBA_VIDEO_SOURCE_SET_OSD, &def_osd_setup);
+
+                break;
+        default:
+                break;
+        }
 
 amba_osd_on_vout_change_arch_exit:
-	return ret;
+        return ret;
 }
 
 int amba_osd_on_csc_change_arch(int vout_id, int csc_en)
 {
-	int					errorCode = 0;
-	struct amba_video_sink_mode		sink_mode;
-	ambosd_sink_cfg_t			*psink_cfg;
-	struct amba_video_source_csc_info	csc_info;
-
-	psink_cfg = &ambosd_sink_cfg[vout_id];
-	if (!psink_cfg->mtx_init) {
-		mutex_init(&psink_cfg->mtx);
-		psink_cfg->mtx_init = 1;
-	}
-
-	mutex_lock(&psink_cfg->mtx);
-	if (!psink_cfg->data_valid) {
-		vout_warn("%s: Please init vout first!\n", __func__);
-		errorCode = -EACCES;
-		mutex_unlock(&psink_cfg->mtx);
-		goto amba_osd_on_csc_change_arch_exit;
-	} else {
-		memcpy(&sink_mode, &psink_cfg->sink_mode,
-			sizeof(struct amba_video_sink_mode));
-
-		csc_info.path = sink_mode.sink_type;
-		switch (sink_mode.sink_type) {
-		case AMBA_VOUT_SINK_TYPE_DIGITAL:
-			csc_info.path = AMBA_VIDEO_SOURCE_CSC_DIGITAL;
-			if (csc_en)
-				csc_info.mode = AMBA_VIDEO_SOURCE_CSC_YUVSD2RGB;
-			else
-				csc_info.mode = AMBA_VIDEO_SOURCE_CSC_RGB2RGB;
-			csc_info.clamp =
-				AMBA_VIDEO_SOURCE_CSC_DATARANGE_DIGITAL_SD_FULL;
-			break;
-
-		case AMBA_VOUT_SINK_TYPE_CVBS:
-			csc_info.path = AMBA_VIDEO_SOURCE_CSC_ANALOG;
-			if (csc_en)
-				csc_info.mode = AMBA_VIDEO_SOURCE_CSC_ANALOG_SD;
-			else
-				csc_info.mode = AMBA_VIDEO_SOURCE_CSC_RGB2RGB;
-			csc_info.clamp = AMBA_VIDEO_SOURCE_CSC_ANALOG_CLAMP_SD;
-			break;
-
-		case AMBA_VOUT_SINK_TYPE_HDMI:
-			csc_info.path = AMBA_VIDEO_SOURCE_CSC_HDMI;
-			if (csc_en)
-				csc_info.mode = AMBA_VIDEO_SOURCE_CSC_YUVSD2RGB;
-			else
-				csc_info.mode = AMBA_VIDEO_SOURCE_CSC_RGB2RGB;
-			csc_info.clamp =
-				AMBA_VIDEO_SOURCE_CSC_DATARANGE_DIGITAL_SD_FULL;
-			break;
-
-		default:
-			break;
-		}
-		errorCode = amba_vout_video_source_cmd(vout_id,
-			AMBA_VIDEO_SOURCE_SET_CSC_DYNAMICALLY, &csc_info);
-		if (errorCode)
-			goto amba_osd_on_csc_change_arch_exit;
-
-		sink_mode.csc_en = csc_en;
-
-	}
-	mutex_unlock(&psink_cfg->mtx);
-
-	errorCode = amba_osd_on_vout_change(vout_id, &sink_mode);
+        int					errorCode = 0;
+        struct amba_video_sink_mode		sink_mode;
+        ambosd_sink_cfg_t			*psink_cfg;
+        struct amba_video_source_csc_info	csc_info;
+
+        psink_cfg = &ambosd_sink_cfg[vout_id];
+        if (!psink_cfg->mtx_init) {
+                mutex_init(&psink_cfg->mtx);
+                psink_cfg->mtx_init = 1;
+        }
+
+        mutex_lock(&psink_cfg->mtx);
+        if (!psink_cfg->data_valid) {
+                vout_warn("%s: Please init vout first!\n", __func__);
+                errorCode = -EACCES;
+                mutex_unlock(&psink_cfg->mtx);
+                goto amba_osd_on_csc_change_arch_exit;
+        } else {
+                memcpy(&sink_mode, &psink_cfg->sink_mode,
+                       sizeof(struct amba_video_sink_mode));
+
+                csc_info.path = sink_mode.sink_type;
+                switch (sink_mode.sink_type) {
+                case AMBA_VOUT_SINK_TYPE_DIGITAL:
+                        csc_info.path = AMBA_VIDEO_SOURCE_CSC_DIGITAL;
+                        if (csc_en)
+                                csc_info.mode = AMBA_VIDEO_SOURCE_CSC_YUVSD2RGB;
+                        else
+                                csc_info.mode = AMBA_VIDEO_SOURCE_CSC_RGB2RGB;
+                        csc_info.clamp =
+                                AMBA_VIDEO_SOURCE_CSC_DATARANGE_DIGITAL_SD_FULL;
+                        break;
+
+                case AMBA_VOUT_SINK_TYPE_CVBS:
+                        csc_info.path = AMBA_VIDEO_SOURCE_CSC_ANALOG;
+                        if (csc_en)
+                                csc_info.mode = AMBA_VIDEO_SOURCE_CSC_ANALOG_SD;
+                        else
+                                csc_info.mode = AMBA_VIDEO_SOURCE_CSC_RGB2RGB;
+                        csc_info.clamp = AMBA_VIDEO_SOURCE_CSC_ANALOG_CLAMP_SD;
+                        break;
+
+                case AMBA_VOUT_SINK_TYPE_HDMI:
+                        csc_info.path = AMBA_VIDEO_SOURCE_CSC_HDMI;
+                        if (csc_en)
+                                csc_info.mode = AMBA_VIDEO_SOURCE_CSC_YUVSD2RGB;
+                        else
+                                csc_info.mode = AMBA_VIDEO_SOURCE_CSC_RGB2RGB;
+                        csc_info.clamp =
+                                AMBA_VIDEO_SOURCE_CSC_DATARANGE_DIGITAL_SD_FULL;
+                        break;
+
+                default:
+                        break;
+                }
+                errorCode = amba_vout_video_source_cmd(vout_id,
+                                                       AMBA_VIDEO_SOURCE_SET_CSC_DYNAMICALLY, &csc_info);
+                if (errorCode)
+                        goto amba_osd_on_csc_change_arch_exit;
+
+                sink_mode.csc_en = csc_en;
+
+        }
+        mutex_unlock(&psink_cfg->mtx);
+
+        errorCode = amba_osd_on_vout_change(vout_id, &sink_mode);
 
 amba_osd_on_csc_change_arch_exit:
-	return errorCode;
+        return errorCode;
 }
diff --git a/drivers/vout/arch_s2l/vout_analog.c b/drivers/vout/arch_s2l/vout_analog.c
index 630c3b3..ff1a208 100644
--- a/drivers/vout/arch_s2l/vout_analog.c
+++ b/drivers/vout/arch_s2l/vout_analog.c
@@ -4,14 +4,33 @@
  * History:
  *    2009/07/23 - [Zhenwu Xue] Create
  *
- * Copyright (C) 2004-2008, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <linux/i2c.h>
 #include <linux/clk.h>
 #include <plat/clk.h>
@@ -87,8 +106,8 @@ static int ambtve_dve_ntsc_config(struct __amba_vout_video_source *psrc,
 		dve.dve_46.s.t_sel_ylpf = 0;
 		dve.dve_46.s.t_ygain_val = 0;
 	} else {
-		dve.dve_46.s.t_sel_ylpf = 0;
-		dve.dve_46.s.t_ygain_val = 0;
+		dve.dve_46.s.t_sel_ylpf = 1;
+		dve.dve_46.s.t_ygain_val = 1;
 	}
 
 	if (sink_mode->sink_type == AMBA_VOUT_SINK_TYPE_YPBPR)
@@ -214,7 +233,7 @@ static int ambtve_dve_ntsc_config(struct __amba_vout_video_source *psrc,
 		dve.dve_97.s.ygain_off = 1;
 	} else {
 		/* turn on the luma lpf */
-		dve.dve_97.s.sel_y_lpf = 0;
+		dve.dve_97.s.sel_y_lpf = 1;
 		dve.dve_97.s.ygain_off = 0;
 	}
 
@@ -282,16 +301,16 @@ static int ambtve_dve_pal_config(struct __amba_vout_video_source *psrc,
 		dve.blank_lvl = 0x0000007e;
 	} else {
 		/* black level 126 in DVE42 */
-		dve.black_lvl = 0x00000069;
+		dve.black_lvl = 0x0000007e;
 		/* blank level:126 in DVE43 */
 		dve.blank_lvl = 0x0000007e;
 	}
 
 	/* clamp level of 16 in DVE44 */
-	dve.clamp_lvl = 0x00000000;
+	dve.clamp_lvl = 0x00000013;
 
 	/* sync level of 8 in DVE45 */
-	dve.sync_lvl = 0x00000004;
+	dve.sync_lvl = 0x00000010;
 
 	//do not use interpolation in DVE46
 	dve.dve_46.s.y_interp = 0;
@@ -301,12 +320,12 @@ static int ambtve_dve_pal_config(struct __amba_vout_video_source *psrc,
 	else
 		dve.dve_46.s.y_colorbar_en = 0;
 	/* zero delay in Y*/
-	dve.dve_46.s.t_ydel_adj = 4;
+	dve.dve_46.s.t_ydel_adj = 0;
 	if (sink_mode->sink_type == AMBA_VOUT_SINK_TYPE_YPBPR) {
 		dve.dve_46.s.t_sel_ylpf = 0;
 		dve.dve_46.s.t_ygain_val = 0;
 	} else {
-		dve.dve_46.s.t_sel_ylpf = 0;
+		dve.dve_46.s.t_sel_ylpf = 1;
 		dve.dve_46.s.t_ygain_val = 1;
 	}
 
@@ -331,7 +350,7 @@ static int ambtve_dve_pal_config(struct __amba_vout_video_source *psrc,
 	}
 
 	/* DVE52 */
-	dve.dve_52.s.pal_c_lpf = 0;
+	dve.dve_52.s.pal_c_lpf = 1;
 	if (sink_mode->sink_type == AMBA_VOUT_SINK_TYPE_YPBPR)
 		dve.dve_52.s.sel_c_gain = 0;
 	else
@@ -433,7 +452,7 @@ static int ambtve_dve_pal_config(struct __amba_vout_video_source *psrc,
 		dve.dve_97.s.ygain_off = 1;
 	} else {
 		/* turn on the luma lpf */
-		dve.dve_97.s.sel_y_lpf = 0;
+		dve.dve_97.s.sel_y_lpf = 1;
 		dve.dve_97.s.ygain_off = 0;
 	}
 
@@ -530,14 +549,17 @@ static int ambtve_init_480i_s2l(struct __amba_vout_video_source *psrc,
                 return rval;
 
         // set config
-	rval = amba_s2l_vout_get_config(psrc, &sink_cfg);
-	if (rval)
+        rval = amba_s2l_vout_get_config(psrc, &sink_cfg);
+        if (rval)
                 return rval;
-	sink_cfg.d_control.s.analog_out = 1;
-	sink_cfg.d_control.s.interlace = VD_INTERLACE;
-	sink_cfg.d_control.s.vid_format = VD_480I60;
-	sink_cfg.d_analog_output_mode.s.hspol = ANALOG_ACT_HIGH;
-	sink_cfg.d_analog_output_mode.s.vspol = ANALOG_ACT_HIGH;
+
+        sink_cfg.d_control.s.hdmi_out = 0;
+        sink_cfg.d_control.s.digital_out = 0;
+        sink_cfg.d_control.s.analog_out = 1;
+        sink_cfg.d_control.s.interlace = VD_INTERLACE;
+        sink_cfg.d_control.s.vid_format = VD_480I60;
+        sink_cfg.d_analog_output_mode.s.hspol = ANALOG_ACT_HIGH;
+        sink_cfg.d_analog_output_mode.s.vspol = ANALOG_ACT_HIGH;
         rval = amba_s2l_vout_set_config(psrc, &sink_cfg);
         if(rval)
                 return rval;
@@ -625,14 +647,17 @@ static int ambtve_init_576i_s2l(struct __amba_vout_video_source *psrc,
                 return rval;
 
         // set config
-	rval = amba_s2l_vout_get_config(psrc, &sink_cfg);
-	if (rval)
+        rval = amba_s2l_vout_get_config(psrc, &sink_cfg);
+        if (rval)
                 return rval;
-	sink_cfg.d_control.s.analog_out = 1;
-	sink_cfg.d_control.s.interlace = VD_INTERLACE;
-	sink_cfg.d_control.s.vid_format = VD_576I50;
-	sink_cfg.d_analog_output_mode.s.hspol = ANALOG_ACT_HIGH;
-	sink_cfg.d_analog_output_mode.s.vspol = ANALOG_ACT_HIGH;
+
+        sink_cfg.d_control.s.hdmi_out = 0;
+        sink_cfg.d_control.s.digital_out = 0;
+        sink_cfg.d_control.s.analog_out = 1;
+        sink_cfg.d_control.s.interlace = VD_INTERLACE;
+        sink_cfg.d_control.s.vid_format = VD_576I50;
+        sink_cfg.d_analog_output_mode.s.hspol = ANALOG_ACT_HIGH;
+        sink_cfg.d_analog_output_mode.s.vspol = ANALOG_ACT_HIGH;
         rval = amba_s2l_vout_set_config(psrc, &sink_cfg);
         if(rval)
                 return rval;
@@ -643,13 +668,13 @@ static int ambtve_init_576i_s2l(struct __amba_vout_video_source *psrc,
 		sink_csc.mode = AMBA_VIDEO_SOURCE_CSC_ANALOG_SD;
 	else
 		sink_csc.mode = AMBA_VIDEO_SOURCE_CSC_RGB2RGB;
-	sink_csc.clamp = AMBA_VIDEO_SOURCE_CSC_ANALOG_CLAMP_SD_PAL;
+	sink_csc.clamp = AMBA_VIDEO_SOURCE_CSC_ANALOG_CLAMP_SD;
 	rval = amba_s2l_vout_set_csc(psrc, &sink_csc);
 	if (rval)
                 return rval;
 
         // pal config
-	rval = ambtve_dve_pal_config(psrc, sink_mode);	\
+	rval = ambtve_dve_pal_config(psrc, sink_mode);
 	if (rval)
                 return rval;
 
diff --git a/drivers/vout/arch_s2l/vout_arch.c b/drivers/vout/arch_s2l/vout_arch.c
index 7e3dc24..7d08014 100644
--- a/drivers/vout/arch_s2l/vout_arch.c
+++ b/drivers/vout/arch_s2l/vout_arch.c
@@ -4,14 +4,33 @@
  * History:
  *    2009/07/23 - [Zhenwu Xue] Create
  *
- * Copyright (C) 2004-2008, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/interrupt.h>
@@ -123,7 +142,7 @@ static struct amba_vout_system_instance_info vout1_instance = {
 
 /* ========================================================================== */
 #define CACHE_LINE_SIZE		32
-inline void clean_cache_aligned(u8 *start, unsigned long size)
+static inline void clean_cache_aligned(u8 *start, unsigned long size)
 {
 	unsigned long offset = (unsigned long)start & (CACHE_LINE_SIZE - 1);
 
@@ -637,14 +656,16 @@ int amba_s2l_vout_set_video_info(struct __amba_vout_video_source *psrc,
 {
 	int					errorCode = 0;
 	struct amba_vout_dev_info		*pinfo;
+	u8					is_interlaced = 0;
 
 	pinfo = psrc->pinfo;
 
 	if (pinfo->status == AMBA_VIDEO_SOURCE_STATUS_IDLE) {
 		pinfo->video_info = *args;
 
-		pinfo->mixer_setup.interlaced =
-			amba_iav_format_to_format(args->format);
+		is_interlaced = amba_iav_format_to_format(args->format);
+		pinfo->mixer_setup.interlaced = is_interlaced;
+		pinfo->video_setup.interlaced = is_interlaced;
 		pinfo->mixer_setup.frm_rate = amba_iav_fps_to_fps(args->fps);
 	} else {
 		errorCode = -EINVAL;
@@ -748,9 +769,9 @@ static int amba_s2l_vout_set_osd_clut(struct __amba_vout_video_source *psrc,
 
 	for (i = 0; i < AMBA_VOUT_CLUT_SIZE; i++) {
 		pinfo->dram_clut[i] = ((args->pblend_table[i] & 0xff) << 24) +
-		        ((pclut_table[0] & 0xff) << 16) +
-			((pclut_table[1] & 0xff) << 8) +
-			 (pclut_table[2] & 0xff);
+		        ((pclut_table[1] & 0xff) << 16) +
+			((pclut_table[2] & 0xff) << 8) +
+			 (pclut_table[0] & 0xff);
 
 		vout_dbg("%s: dram_clut[%d] = 0x%08x!\n",
 			__func__, i, pinfo->dram_clut[i]);
@@ -805,9 +826,22 @@ int amba_s2l_vout_set_setup(struct __amba_vout_video_source *psrc,
 void amba_s2l_vout_set_clock_setup(struct __amba_vout_video_source *psrc,
 	struct amba_video_source_clock_setup *args)
 {
+	struct amba_vout_dev_info *pinfo = psrc->pinfo;
 	if (!psrc->id) {
-		rct_set_vout2_clk_src(args->src);
-		rct_set_vout2_freq_hz(args->freq_hz);
+                // S2L digital656 color switch workaround
+		//1:reset vout0
+		__amba_s2l_vout_reset(pinfo);
+                mdelay(100);
+                //2:set digital vout0 clock to 24MHz
+                rct_set_vout2_freq_hz(24000000);
+                mdelay(100);
+		//3:reset vout0
+		__amba_s2l_vout_reset(pinfo);
+                mdelay(100);
+                psrc->freq_hz = args->freq_hz;
+		//rct_set_vout2_clk_src(args->src);
+		//rct_set_vout2_freq_hz(args->freq_hz);
+		// workaround end
 	} else {
 		rct_set_vout_clk_src(args->src);
 		rct_set_vout_freq_hz(args->freq_hz);
@@ -935,7 +969,12 @@ static int amba_s2l_vout_update_setup(struct __amba_vout_video_source *psrc,
 			pinfo->osd_clut_setup_flag &= ~AMBA_VOUT_SETUP_CHANGED;
 		}
 	}
-
+        // S2L digital656 color switch workaround
+	if(psrc->id == 0){
+	    mdelay(200);
+	    rct_set_vout2_freq_hz(psrc->freq_hz);
+	}
+        // workaround end
 amba_s2l_vout_update_setup_exit:
 	return errorCode;
 }
@@ -1630,7 +1669,7 @@ int amba_s2l_vout_set_dve(struct __amba_vout_video_source *psrc,
 	return errorCode;
 }
 
-static int amba_s2_vout_set_mixer_csc(struct __amba_vout_video_source *psrc,
+static int amba_s2l_vout_set_mixer_csc(struct __amba_vout_video_source *psrc,
 	enum amba_vout_mixer_csc *mixer_csc)
 {
 	int					errorCode = 0;
@@ -1705,10 +1744,17 @@ static int amba_s2l_vout_resume(struct __amba_vout_video_source *psrc,
 		pinfo->status = pinfo->pstatus;
                 clk_setup.freq_hz = psrc->freq_hz;
                 clk_setup.src = VO_CLK_ONCHIP_PLL_27MHZ;
-                amba_s2l_vout_set_clock_setup(psrc, &clk_setup);
-	} else {
+                //set clock without color switch workaround
+                if (!psrc->id) {
+		        rct_set_vout2_clk_src(clk_setup.src);
+		        rct_set_vout2_freq_hz(clk_setup.freq_hz);
+                } else {
+                        rct_set_vout_clk_src(clk_setup.src);
+                        rct_set_vout_freq_hz(clk_setup.freq_hz);
+                }
+        } else  {
 		errorCode = 1;
-	}
+        }
 
 	return errorCode;
 }
@@ -1913,7 +1959,7 @@ static int amba_s2l_vout_docmd(struct __amba_vout_video_source *psrc,
 		break;
 
 	case AMBA_VIDEO_SOURCE_SET_MIXER_CSC:
-		errorCode = amba_s2_vout_set_mixer_csc(psrc,
+		errorCode = amba_s2l_vout_set_mixer_csc(psrc,
 			(enum amba_vout_mixer_csc *)args);
 		break;
 
@@ -2120,6 +2166,11 @@ static int __init amba_s2l_vout_probe(
 	strlcpy(psrc->name, pvi->name, sizeof(psrc->name));
 	psrc->owner = THIS_MODULE;
 	psrc->pinfo = vout_dev_info;
+	if (!psrc->id) {
+		psrc->freq_hz = rct_get_vout2_freq_hz();
+	} else {
+		psrc->freq_hz = rct_get_vout_freq_hz();
+	}
 	psrc->docmd = amba_s2l_vout_docmd;
 	errorCode = amba_vout_add_video_source(psrc);
 	if (errorCode) {
@@ -2128,7 +2179,7 @@ static int __init amba_s2l_vout_probe(
 	}
 
 	errorCode = request_irq(vout_dev_info->irq, amba_s2l_vout_irq,
-		IRQF_TRIGGER_RISING | IRQF_DISABLED, psrc->name, vout_dev_info);
+		IRQF_TRIGGER_RISING, psrc->name, vout_dev_info);
 	if (errorCode) {
 		vout_err("Request IRQ%d failed!\n", vout_dev_info->irq);
 		goto amba_s2l_vout_probe_free_vout;
diff --git a/drivers/vout/arch_s2l/vout_arch.h b/drivers/vout/arch_s2l/vout_arch.h
index 3de2e3c..f22f673 100644
--- a/drivers/vout/arch_s2l/vout_arch.h
+++ b/drivers/vout/arch_s2l/vout_arch.h
@@ -4,15 +4,34 @@
  * History:
  *    2009/07/23 - [Zhenwu Xue] Create
  *
- * Copyright (C) 2004-2008, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #ifndef __VOUT_ARCH_H
 #define __VOUT_ARCH_H
 
diff --git a/drivers/vout/arch_s2l/vout_digital.c b/drivers/vout/arch_s2l/vout_digital.c
index 79b9f9a..0adf218 100644
--- a/drivers/vout/arch_s2l/vout_digital.c
+++ b/drivers/vout/arch_s2l/vout_digital.c
@@ -4,15 +4,34 @@
  * History:
  *    2015/08/10 - [Anthony Ginger] Create
  *
- * Copyright (C) 2004-2008, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #include <linux/i2c.h>
 #include <linux/clk.h>
 #include <plat/clk.h>
@@ -65,23 +84,32 @@ const static vout_digital_mode_list Vout_digital_mode[] = {
         {AMBA_VIDEO_MODE_D1_NTSC,       AMBA_VIDEO_TYPE_YUV_601,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_27MHZ,          VD_480P60,      AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_601_16BITS,    AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      858,            525,            525,            0,              62,             0,              6 * 858,        429,            6 * 858 + 429,          0,                      0,                      6,              1,              0,                      429,                    6,              429,            122,            122 + 720 - 1,  36,             36 + 480 - 1,   AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      YUV480P_DEFAULT_FRAME_RATE},
         {AMBA_VIDEO_MODE_D1_PAL,        AMBA_VIDEO_TYPE_YUV_656,        AMBA_VIDEO_SYSTEM_PAL,  PLL_CLK_27MHZ,          VD_576P50,      AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_656,           AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      864,            625,            625,            0,              1,              0,              1,              0,              1,                      0,                      0,                      0,              1,              0,                      0,                      0,              1,              144,            863,            44,             619,            AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      YUV576P_DEFAULT_FRAME_RATE},
         {AMBA_VIDEO_MODE_D1_PAL,        AMBA_VIDEO_TYPE_YUV_601,        AMBA_VIDEO_SYSTEM_PAL,  PLL_CLK_27MHZ,          VD_576P50,      AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_601_16BITS,    AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      864,            625,            625,            0,              64,             0,              5 * 564,        432,            5 * 864 + 432,          0,                      0,                      5,              0,              0,                      432,                    5,              432,            132,            132 + 720 - 1,  44,             44 + 576 - 1,   AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      YUV576P_DEFAULT_FRAME_RATE},
-        {AMBA_VIDEO_MODE_720P,          AMBA_VIDEO_TYPE_YUV_656,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_74_25D1001MHZ,  VD_720P60,      AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_656,           AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      1650,           750,            750,            0,              1,              0,              1,              0,              1,                      0,                      0,                      0,              1,              0,                      0,                      0,              1,              370,            1649,           25,             744,            AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      YUV720P_DEFAULT_FRAME_RATE},
-        {AMBA_VIDEO_MODE_720P,          AMBA_VIDEO_TYPE_YUV_601,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_74_25D1001MHZ,  VD_720P60,      AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_601_16BITS,    AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      1650,           750,            750,            0,              40,             0,              5 * 1650,       825,            5 * 1650 + 825,         0,                      0,                      5,              0,              0,                      825,                    5,              825,            260,            260 + 1280 - 1, 25,             25 + 720 - 1,   AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      YUV720P_DEFAULT_FRAME_RATE},
+        {AMBA_VIDEO_MODE_720P,          AMBA_VIDEO_TYPE_YUV_656,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_74_25MHZ,       VD_720P60,      AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_656,           AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      1650,           750,            750,            0,              1,              0,              1,              0,              1,                      0,                      0,                      0,              1,              0,                      0,                      0,              1,              370,            1649,           25,             744,            AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      YUV720P_DEFAULT_FRAME_RATE},
+        {AMBA_VIDEO_MODE_720P,          AMBA_VIDEO_TYPE_YUV_601,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_74_25MHZ,       VD_720P60,      AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_601_16BITS,    AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      1650,           750,            750,            0,              40,             0,              5 * 1650,       825,            5 * 1650 + 825,         0,                      0,                      5,              0,              0,                      825,                    5,              825,            260,            260 + 1280 - 1, 25,             25 + 720 - 1,   AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      YUV720P_DEFAULT_FRAME_RATE},
+        {AMBA_VIDEO_MODE_720P25,        AMBA_VIDEO_TYPE_YUV_656,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_74_25MHZ,       VD_NON_FIXED,   AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_656,           AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      3960,           750,            750,            0,              1,              0,              1,              0,              1,                      0,                      0,                      0,              1,              0,                      0,                      0,              1,              2680,           3959,           25,             744,            AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      AMBA_VIDEO_FPS_25},
+        {AMBA_VIDEO_MODE_720P25,        AMBA_VIDEO_TYPE_YUV_601,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_74_25MHZ,       VD_NON_FIXED,   AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_601_16BITS,    AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      3960,           750,            750,            0,              40,             0,              5 * 3960,       1980,           5 * 3960 + 1980,        0,                      0,                      5,              0,              0,                      1980,                   5,              1980,           260,            260 + 1280 - 1, 25,             25 + 720 - 1,   AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      AMBA_VIDEO_FPS_25},
+        {AMBA_VIDEO_MODE_720P30,        AMBA_VIDEO_TYPE_YUV_656,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_74_25MHZ,       VD_NON_FIXED,   AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_656,           AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      3300,           750,            750,            0,              1,              0,              1,              0,              1,                      0,                      0,                      0,              1,              0,                      0,                      0,              1,              2020,           3299,           25,             744,            AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      AMBA_VIDEO_FPS_30},
+        {AMBA_VIDEO_MODE_720P30,        AMBA_VIDEO_TYPE_YUV_601,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_74_25MHZ,       VD_NON_FIXED,   AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_601_16BITS,    AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      3300,           750,            750,            0,              40,             0,              5 * 3300,       1650,           5 * 3300 + 1650,        0,                      0,                      5,              0,              0,                      1650,                   5,              1650,           260,            260 + 1280 - 1, 25,             25 + 720 - 1,   AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      AMBA_VIDEO_FPS_30},
         {AMBA_VIDEO_MODE_720P50,        AMBA_VIDEO_TYPE_YUV_656,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_74_25MHZ,       VD_720P50,      AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_656,           AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      1980,           750,            750,            0,              1,              0,              1,              0,              1,                      0,                      0,                      0,              1,              0,                      0,                      0,              1,              700,            1979,           25,             744,            AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      YUV720P50_DEFAULT_FRAME_RATE},
         {AMBA_VIDEO_MODE_720P50,        AMBA_VIDEO_TYPE_YUV_601,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_74_25MHZ,       VD_720P50,      AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_601_16BITS,    AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      1980,           750,            750,            0,              40,             0,              5 * 1980,       990,            5 * 1980 + 990,         0,                      0,                      5,              0,              0,                      990,                    5,              990,            260,            260 + 1280 - 1, 25,             25 + 720 - 1,   AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      YUV720P50_DEFAULT_FRAME_RATE},
-        {AMBA_VIDEO_MODE_1080I,         AMBA_VIDEO_TYPE_YUV_656,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_74_25D1001MHZ,  VD_1080I60,     AMBA_VIDEO_FORMAT_INTERLACE,    LCD_MODE_656,           AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      2200,           562,            563,            0,              1,              0,              1,              0,              1,                      0,                      0,                      0,              1,              0,                      0,                      0,              1,              280,            2199,           20,             559,            AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      YUV1080I_DEFAULT_FRAME_RATE},
-        {AMBA_VIDEO_MODE_1080I,         AMBA_VIDEO_TYPE_YUV_601,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_74_25D1001MHZ,  VD_1080I60,     AMBA_VIDEO_FORMAT_INTERLACE,    LCD_MODE_601_16BITS,    AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      2200,           562,            563,            0,              44,             0,              5 * 2200,       1100,           5 * 2200 + 1100,        0,                      0,                      5,              0,              0,                      1100,                   5,              1100,           192,            192 + 1920 - 1, 20,             20 + 540 - 1,   AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      YUV1080I_DEFAULT_FRAME_RATE},
+        {AMBA_VIDEO_MODE_1080I,         AMBA_VIDEO_TYPE_YUV_656,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_74_25MHZ,       VD_1080I60,     AMBA_VIDEO_FORMAT_INTERLACE,    LCD_MODE_656,           AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      2200,           562,            563,            0,              1,              0,              1,              0,              1,                      0,                      0,                      0,              1,              0,                      0,                      0,              1,              280,            2199,           20,             559,            AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      YUV1080I_DEFAULT_FRAME_RATE},
+        {AMBA_VIDEO_MODE_1080I,         AMBA_VIDEO_TYPE_YUV_601,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_74_25MHZ,       VD_1080I60,     AMBA_VIDEO_FORMAT_INTERLACE,    LCD_MODE_601_16BITS,    AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      2200,           562,            563,            0,              44,             0,              5 * 2200,       1100,           5 * 2200 + 1100,        0,                      0,                      5,              0,              0,                      1100,                   5,              1100,           192,            192 + 1920 - 1, 20,             20 + 540 - 1,   AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      YUV1080I_DEFAULT_FRAME_RATE},
         {AMBA_VIDEO_MODE_1080I50,       AMBA_VIDEO_TYPE_YUV_656,        AMBA_VIDEO_SYSTEM_PAL,  PLL_CLK_74_25MHZ,       VD_1080I50,     AMBA_VIDEO_FORMAT_INTERLACE,    LCD_MODE_656,           AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      2640,           562,            563,            0,              1,              0,              1,              0,              1,                      0,                      0,                      0,              1,              0,                      0,                      0,              1,              720,            2639,           20,             559,            AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      YUV1080I50_DEFAULT_FRAME_RATE},
         {AMBA_VIDEO_MODE_1080I50,       AMBA_VIDEO_TYPE_YUV_601,        AMBA_VIDEO_SYSTEM_PAL,  PLL_CLK_74_25MHZ,       VD_1080I50,     AMBA_VIDEO_FORMAT_INTERLACE,    LCD_MODE_601_16BITS,    AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      2640,           562,            563,            0,              44,             0,              5 * 2640,       1320,           5 * 2640 + 1320,        0,                      0,                      5,              0,              0,                      1320,                   5,              1320,           192,            192 + 1920 - 1, 20,             20 + 540 - 1,   AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      YUV1080I50_DEFAULT_FRAME_RATE},
-        {AMBA_VIDEO_MODE_1080P,         AMBA_VIDEO_TYPE_YUV_656,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_148_5D1001MHZ,  VD_1080P60,     AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_656,           AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      2200,           1125,           1125,           0,              1,              0,              1,              0,              1,                      0,                      0,                      0,              1,              0,                      0,                      0,              1,              280,            2199,           41,             1120,           AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      YUV1080P_DEFAULT_FRAME_RATE},
-        {AMBA_VIDEO_MODE_1080P,         AMBA_VIDEO_TYPE_YUV_601,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_148_5D1001MHZ,  VD_1080P60,     AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_601_16BITS,    AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      2200,           1125,           1125,           0,              44,             0,              5 * 2200,       1100,           5 * 2200 + 1100,        0,                      0,                      5,              0,              0,                      1100,                   5,              1100,           192,            192 + 1920 - 1, 41,             41 + 1080 - 1,  AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      YUV1080P_DEFAULT_FRAME_RATE},
+//        {AMBA_VIDEO_MODE_960_576,       AMBA_VIDEO_TYPE_YUV_656,        AMBA_VIDEO_SYSTEM_PAL,  PLL_CLK_36MHZ,       VD_NON_FIXED,     AMBA_VIDEO_FORMAT_INTERLACE,    LCD_MODE_656,           AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      4608,           312,            313,            0,              1,              0,              1,              0,              1,                      0,                      0,                      0,              1,              0,                      0,                      0,              1,              3647,            4607,           23,             310,            AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      YUV625I_DEFAULT_FRAME_RATE},
+//        {AMBA_VIDEO_MODE_960_480,       AMBA_VIDEO_TYPE_YUV_656,        AMBA_VIDEO_SYSTEM_NTSC,  PLL_CLK_36MHZ,       VD_NON_FIXED,     AMBA_VIDEO_FORMAT_INTERLACE,    LCD_MODE_656,           AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      4576,           262,            263,            0,              1,              0,              1,              0,              1,                      0,                      0,                      0,              1,              0,                      0,                      0,              1,              3615,            4575,           20,             259,            AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      YUV1080P_DEFAULT_FRAME_RATE},
+        {AMBA_VIDEO_MODE_1080P,         AMBA_VIDEO_TYPE_YUV_656,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_148_5MHZ,       VD_1080P60,     AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_656,           AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      2200,           1125,           1125,           0,              1,              0,              1,              0,              1,                      0,                      0,                      0,              1,              0,                      0,                      0,              1,              280,            2199,           41,             1120,           AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      YUV1080P_DEFAULT_FRAME_RATE},
+        {AMBA_VIDEO_MODE_1080P,         AMBA_VIDEO_TYPE_YUV_601,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_148_5MHZ,       VD_1080P60,     AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_601_16BITS,    AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      2200,           1125,           1125,           0,              44,             0,              5 * 2200,       1100,           5 * 2200 + 1100,        0,                      0,                      5,              0,              0,                      1100,                   5,              1100,           192,            192 + 1920 - 1, 41,             41 + 1080 - 1,  AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      YUV1080P_DEFAULT_FRAME_RATE},
         {AMBA_VIDEO_MODE_1080P50,       AMBA_VIDEO_TYPE_YUV_656,        AMBA_VIDEO_SYSTEM_PAL,  PLL_CLK_148_5MHZ,       VD_1080P60,     AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_656,           AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      2640,           1125,           1125,           0,              1,              0,              1,              0,              1,                      0,                      0,                      0,              1,              0,                      0,                      0,              1,              720,            2639,           41,             1120,           AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      YUV1080P50_DEFAULT_FRAME_RATE},
         {AMBA_VIDEO_MODE_1080P50,       AMBA_VIDEO_TYPE_YUV_601,        AMBA_VIDEO_SYSTEM_PAL,  PLL_CLK_148_5MHZ,       VD_1080P60,     AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_601_16BITS,    AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      2640,           1125,           1125,           0,              44,             0,              5 * 2640,       1320,           5 * 2640 + 1320,        0,                      0,                      5,              0,              0,                      1320,                   5,              1320,           192,            192 + 1920 - 1, 41,             41 + 1080 - 1,  AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      YUV1080P50_DEFAULT_FRAME_RATE},
-        {AMBA_VIDEO_MODE_1080P30,       AMBA_VIDEO_TYPE_YUV_656,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_74_25D1001MHZ,  VD_1080P60,     AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_656,           AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      2200,           1125,           1125,           0,              1,              0,              1,              0,              1,                      0,                      0,                      0,              1,              0,                      0,                      0,              1,              280,            2199,           41,             1120,           AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      YUV1080P_DEFAULT_FRAME_RATE},
-        {AMBA_VIDEO_MODE_1080P30,       AMBA_VIDEO_TYPE_YUV_601,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_74_25D1001MHZ,  VD_1080P60,     AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_601_16BITS,    AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      2200,           1125,           1125,           0,              44,             0,              5 * 2200,       1100,           5 * 2200 + 1100,        0,                      0,                      5,              0,              0,                      1100,                   5,              1100,           192,            192 + 1920 - 1, 41,             41 + 1080 - 1,  AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      YUV1080P_DEFAULT_FRAME_RATE},
-        {AMBA_VIDEO_MODE_1080P25,       AMBA_VIDEO_TYPE_YUV_656,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_74_25D1001MHZ,  VD_1080P60,     AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_656,           AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      2200,           1125,           1125,           0,              1,              0,              1,              0,              1,                      0,                      0,                      0,              1,              0,                      0,                      0,              1,              280,            2199,           41,             1120,           AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      YUV1080P_DEFAULT_FRAME_RATE},
-        {AMBA_VIDEO_MODE_1080P25,       AMBA_VIDEO_TYPE_YUV_601,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_74_25D1001MHZ,  VD_1080P60,     AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_601_16BITS,    AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      2640,           1125,           1125,           0,              44,             0,              5 * 2640,       1320,           5 * 2640 + 1320,        0,                      0,                      5,              0,              0,                      1320,                   5,              1320,           192,            192 + 1920 - 1, 41,             41 + 1080 - 1,  AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      YUV1080P_DEFAULT_FRAME_RATE},
-        {AMBA_VIDEO_MODE_WVGA,          AMBA_VIDEO_TYPE_RGB_601,        AMBA_VIDEO_SYSTEM_AUTO, 28397174,               VD_NON_FIXED,   AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_601_24BITS,    AMBA_VIDEO_SOURCE_CSC_YUVSD2RGB,        940,            504,            504,            0,              2,              0,              1879,           0,              1879,                   0,                      0,                      2,              0,              0,                      0,                      2,              0,              120,            959,            20,             499,            AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_16,     AMBA_VIDEO_FPS_60},
+        {AMBA_VIDEO_MODE_1080P30,       AMBA_VIDEO_TYPE_YUV_656,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_74_25MHZ,       VD_1080P60,     AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_656,           AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      2200,           1125,           1125,           0,              1,              0,              1,              0,              1,                      0,                      0,                      0,              1,              0,                      0,                      0,              1,              280,            2199,           41,             1120,           AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      AMBA_VIDEO_FPS_30},
+        {AMBA_VIDEO_MODE_1080P30,       AMBA_VIDEO_TYPE_YUV_601,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_74_25MHZ,       VD_1080P60,     AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_601_16BITS,    AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      2200,           1125,           1125,           0,              44,             0,              5 * 2200,       1100,           5 * 2200 + 1100,        0,                      0,                      5,              0,              0,                      1100,                   5,              1100,           192,            192 + 1920 - 1, 41,             41 + 1080 - 1,  AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      AMBA_VIDEO_FPS_30},
+        {AMBA_VIDEO_MODE_1080P25,       AMBA_VIDEO_TYPE_YUV_656,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_74_25MHZ,       VD_1080P50,     AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_656,           AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      2640,           1125,           1125,           0,              1,              0,              1,              0,              1,                      0,                      0,                      0,              1,              0,                      0,                      0,              1,              720,            2639,           41,             1120,           AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      AMBA_VIDEO_FPS_25},
+        {AMBA_VIDEO_MODE_1080P25,       AMBA_VIDEO_TYPE_YUV_601,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_74_25MHZ,       VD_1080P60,     AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_601_16BITS,    AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      2640,           1125,           1125,           0,              44,             0,              5 * 2640,       1320,           5 * 2640 + 1320,        0,                      0,                      5,              0,              0,                      1320,                   5,              1320,           192,            192 + 1920 - 1, 41,             41 + 1080 - 1,  AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      AMBA_VIDEO_FPS_25},
+        {AMBA_VIDEO_MODE_2560X1440P25,  AMBA_VIDEO_TYPE_YUV_656,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_148_5MHZ,       VD_NON_FIXED,   AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_656,           AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      3960,           1500,           1500,           0,              1,              0,              1,              0,              1,                      0,                      0,                      0,              1,              0,                      0,                      0,              1,              1400,           3959,           51/*60*/,       1490/*1499*/,   AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      AMBA_VIDEO_FPS_25},
+        {AMBA_VIDEO_MODE_2560X1440P30,  AMBA_VIDEO_TYPE_YUV_656,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_148_5MHZ,       VD_NON_FIXED,   AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_656,           AMBA_VIDEO_SOURCE_CSC_YUVSD2YUVSD,      3300,           1500,           1500,           0,              1,              0,              1,              0,              1,                      0,                      0,                      0,              1,              0,                      0,                      0,              1,              740,            3299,           51/*60*/,       1490/*1499*/,   AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_8,      AMBA_VIDEO_FPS_30},
+        {AMBA_VIDEO_MODE_WVGA,          AMBA_VIDEO_TYPE_RGB_601,        AMBA_VIDEO_SYSTEM_AUTO, 28397174,               VD_NON_FIXED,   AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_601_24BITS,    AMBA_VIDEO_SOURCE_CSC_YUVSD2RGB,        940,            504,            504,            0,              2,              0,              1879,           0,              1879,                   0,                      0,                      2,              0,              0,                      0,                      2,              0,              120,            919,            20,             499,            AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_16,     AMBA_VIDEO_FPS_60},
+        {AMBA_VIDEO_MODE_240_320,       AMBA_VIDEO_TYPE_RGB_601,        AMBA_VIDEO_SYSTEM_AUTO, 7000000,                VD_NON_FIXED,   AMBA_VIDEO_FORMAT_PROGRESSIVE,  LCD_MODE_601_16BITS,    AMBA_VIDEO_SOURCE_CSC_YUVSD2RGB,        298,            330,            0,              0,              10,             0,              0,              0,              0,                      0,                      0,                      4,              0,              0,                      0,                      4,              0,              30,             270,            8,              328,            AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_16,     AMBA_VIDEO_FPS_60},
         {AMBA_VIDEO_MODE_960_240,       AMBA_VIDEO_TYPE_RGB_601,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_27MHZ,          VD_NON_FIXED,   AMBA_VIDEO_FORMAT_INTERLACE,    LCD_MODE_601_24BITS,    AMBA_VIDEO_SOURCE_CSC_YUVSD2RGB,        1716,           263,            263,            0,              1,              0,              1,              0,              1,                      0,                      0,                      0,              1,              0,                      0,                      0,              1,              241,            1200,           21,             260,            AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_16,     YUV525I_DEFAULT_FRAME_RATE},
         {AMBA_VIDEO_MODE_320_240,       AMBA_VIDEO_TYPE_RGB_601,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_27MHZ,          VD_NON_FIXED,   AMBA_VIDEO_FORMAT_INTERLACE,    LCD_MODE_601_24BITS,    AMBA_VIDEO_SOURCE_CSC_YUVSD2RGB,        1716,           263,            263,            0,              1,              0,              1,              0,              1,                      0,                      0,                      0,              1,              0,                      0,                      0,              1,              241,            560,            21,             260,            AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_16,     YUV525I_DEFAULT_FRAME_RATE},
         {AMBA_VIDEO_MODE_320_288,       AMBA_VIDEO_TYPE_RGB_601,        AMBA_VIDEO_SYSTEM_NTSC, PLL_CLK_27MHZ,          VD_NON_FIXED,   AMBA_VIDEO_FORMAT_INTERLACE,    LCD_MODE_601_24BITS,    AMBA_VIDEO_SOURCE_CSC_YUVSD2RGB,        1728,           313,            313,            0,              1,              0,              1,              0,              1,                      0,                      0,                      0,              1,              0,                      0,                      0,              1,              241,            560,            21,             308,            AMBA_VIDEO_RATIO_4_3,   AMBA_VIDEO_BITS_16,     YUV625I_DEFAULT_FRAME_RATE},
@@ -152,14 +180,16 @@ static int ambdbus_init_rgb_mode(struct __amba_vout_video_source *psrc,
         rval = amba_s2l_vout_get_config(psrc, &sink_cfg);
         if (rval)
                 return rval;
+        sink_cfg.d_control.s.analog_out = 0;
+        sink_cfg.d_control.s.hdmi_out = 0;
         sink_cfg.d_control.s.digital_out = 1;
         if (sink_mode->format == AMBA_VIDEO_FORMAT_PROGRESSIVE)
                 sink_cfg.d_control.s.interlace = VD_PROGRESSIVE;
         else
                 sink_cfg.d_control.s.interlace = VD_INTERLACE;
         sink_cfg.d_control.s.vid_format = Vout_digital_mode[mod_index].vid_format;
-        sink_cfg.d_analog_output_mode.s.hspol = LCD_ACT_LOW;
-        sink_cfg.d_analog_output_mode.s.vspol = LCD_ACT_LOW;
+        sink_cfg.d_digital_output_mode.s.hspol = LCD_ACT_LOW;
+        sink_cfg.d_digital_output_mode.s.vspol = LCD_ACT_LOW;
         sink_cfg.d_digital_output_mode.s.mode = sink_cfg.d_digital_output_mode.s.mode;
         rval = amba_s2l_vout_set_config(psrc, &sink_cfg);
         if(rval)
@@ -205,10 +235,10 @@ static int ambdbus_init_rgb_mode(struct __amba_vout_video_source *psrc,
         //set hvsync
         sink_sync.hsync_start = Vout_digital_mode[mod_index].hsync_start;
         sink_sync.hsync_end = Vout_digital_mode[mod_index].hsync_end;
-        sink_sync.vtsync_start = Vout_digital_mode[mod_index].vtsync_start;
-        sink_sync.vtsync_end = Vout_digital_mode[mod_index].vtsync_end;
-        sink_sync.vbsync_start = Vout_digital_mode[mod_index].vbsync_start;
-        sink_sync.vbsync_end = Vout_digital_mode[mod_index].vbsync_end;
+        //sink_sync.vtsync_start = Vout_digital_mode[mod_index].vtsync_start;
+        //sink_sync.vtsync_end = Vout_digital_mode[mod_index].vtsync_end;
+        //sink_sync.vbsync_start = Vout_digital_mode[mod_index].vbsync_start;
+        //sink_sync.vbsync_end = Vout_digital_mode[mod_index].vbsync_end;
         sink_sync.vtsync_start_row = Vout_digital_mode[mod_index].vtsync_start_row;
         sink_sync.vtsync_start_col = Vout_digital_mode[mod_index].vtsync_start_col;
         sink_sync.vtsync_end_row = Vout_digital_mode[mod_index].vtsync_end_row;
@@ -224,7 +254,7 @@ static int ambdbus_init_rgb_mode(struct __amba_vout_video_source *psrc,
 
         //set active window
         sink_window.start_x = Vout_digital_mode[mod_index].active_start_x;
-        sink_window.end_x = sink_window.start_x + sink_mode->video_size.video_width * colors_per_dot - 1;
+        sink_window.end_x = Vout_digital_mode[mod_index].active_end_x;
         sink_window.start_y = Vout_digital_mode[mod_index].active_start_y;
         sink_window.end_y = Vout_digital_mode[mod_index].active_end_y;
         sink_window.width = sink_window.end_x - sink_window.start_x + 1;
@@ -354,14 +384,17 @@ static int ambdbus_init_yuv_mode(struct __amba_vout_video_source *psrc,
         rval = amba_s2l_vout_get_config(psrc, &sink_cfg);
         if (rval)
                 return rval;
+
+        sink_cfg.d_control.s.analog_out = 0;
+        sink_cfg.d_control.s.hdmi_out = 0;
         sink_cfg.d_control.s.digital_out = 1;
         if (Vout_digital_mode[mod_index].format == AMBA_VIDEO_FORMAT_PROGRESSIVE)
                 sink_cfg.d_control.s.interlace = VD_PROGRESSIVE;
         else
                 sink_cfg.d_control.s.interlace = VD_INTERLACE;
         sink_cfg.d_control.s.vid_format = Vout_digital_mode[mod_index].vid_format;
-        sink_cfg.d_analog_output_mode.s.hspol = LCD_ACT_LOW;
-        sink_cfg.d_analog_output_mode.s.vspol = LCD_ACT_LOW;
+        sink_cfg.d_digital_output_mode.s.hspol = LCD_ACT_LOW;
+        sink_cfg.d_digital_output_mode.s.vspol = LCD_ACT_LOW;
         sink_cfg.d_digital_output_mode.s.mode = Vout_digital_mode[mod_index].digital_output_mode;
         rval = amba_s2l_vout_set_config(psrc, &sink_cfg);
         if(rval)
@@ -412,8 +445,11 @@ static int ambdbus_init_yuv_mode(struct __amba_vout_video_source *psrc,
         sink_window.start_y = Vout_digital_mode[mod_index].active_start_y;
         sink_window.end_y = Vout_digital_mode[mod_index].active_end_y;
         sink_window.width = sink_window.end_x - sink_window.start_x + 1;
-        if(Vout_digital_mode[mod_index].format == AMBA_VIDEO_FORMAT_INTERLACE)
-                sink_window.width = sink_window.width >> 1;
+	if((Vout_digital_mode[mod_index].format == AMBA_VIDEO_FORMAT_INTERLACE) &&
+		((sink_mode->mode == AMBA_VIDEO_MODE_480I) ||
+		(sink_mode->mode == AMBA_VIDEO_MODE_576I))){
+			sink_window.width = sink_window.width >> 1;
+	}
         sink_window.field_reverse = 0;
         rval = amba_s2l_vout_set_active_win(psrc, &sink_window);
         if(rval)
@@ -498,12 +534,11 @@ int amba_s2l_vout_digital_init(struct __amba_vout_video_source *psrc,
         int     i, mod_index, rval = 0;
 
         psrc->active_sink_type = AMBA_VOUT_SINK_TYPE_DIGITAL;
-
         for(i = 0; i < VDMODE_NUM; i++) {
                 if((sink_mode->mode == Vout_digital_mode[i].vmode) &&
                     (sink_mode->type == Vout_digital_mode[i].type))
                         break;
-                if(i >= VDMODE_NUM) {
+                if(i >= (VDMODE_NUM - 1)) {
                         vout_err("vout_digital don't support mode %d \n", sink_mode->mode);
                         return -EINVAL;
                 }
diff --git a/drivers/vout/arch_s2l/vout_hdmi.c b/drivers/vout/arch_s2l/vout_hdmi.c
index da49a2c..073d3d7 100644
--- a/drivers/vout/arch_s2l/vout_hdmi.c
+++ b/drivers/vout/arch_s2l/vout_hdmi.c
@@ -4,14 +4,33 @@
  * History:
  *    2009/07/23 - [Zhenwu Xue] Create
  *
- * Copyright (C) 2004-2008, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <linux/i2c.h>
 #include <linux/clk.h>
 #include <plat/clk.h>
@@ -62,7 +81,7 @@ void amba_s2l_vout_hdmi_get_native_mode(amba_hdmi_video_timing_t *pvtiming)
         tmp[1]  =  (pvtiming->h_active + pvtiming->h_blanking);
         tmp[1]  *= (pvtiming->v_active + pvtiming->v_blanking);
         fps     =  tmp[0] / tmp[1];
-        
+
         for (i = 0; i < ARRAY_SIZE(Vout_Hdmi_mode); i++) {
                 if (pvtiming->h_active != Vout_Hdmi_mode[i].h_active)
                         continue;
@@ -279,6 +298,8 @@ int amba_s2l_vout_hdmi_init(struct __amba_vout_video_source *psrc,
         rval = amba_s2l_vout_get_config(psrc, &sink_cfg);
         if(rval)
                 return rval;
+        sink_cfg.d_control.s.analog_out = 0;
+        sink_cfg.d_control.s.digital_out = 0;
         sink_cfg.d_control.s.hdmi_out = 1;
         sink_cfg.d_control.s.interlace = hvt->interlace;
         sink_cfg.d_control.s.vid_format = Vout_Hdmi_mode[mode_index].vid_format;
diff --git a/drivers/vout/arch_s2l/vout_pll.c b/drivers/vout/arch_s2l/vout_pll.c
index 6e5b54f..2790f3e 100644
--- a/drivers/vout/arch_s2l/vout_pll.c
+++ b/drivers/vout/arch_s2l/vout_pll.c
@@ -3,15 +3,34 @@
  *
  * Author: Anthony Ginger <hfjiang@ambarella.com>
  *
- * Copyright (C) 2004-2013, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #include <linux/io.h>
 #include <linux/i2c.h>
 #include <linux/clk.h>
@@ -20,6 +39,25 @@
 #include "vout_pri.h"
 
 /* ==========================================================================*/
+typedef struct {
+        u32     rate;
+        u32     intp;
+        u32     frac;
+        u32     sdiv;
+        u32     sout;
+        u32     pre_scaler;
+        u32     post_scaler;
+        u32     pll_ctrl2;
+        u32     pll_ctrl3;
+} vout_pll_s;
+
+const static vout_pll_s ambarella_digital_vout_pll_table[] = {
+        //rate                  intp    frac    sdiv+1  sdout+1 pre     post    ctrl2           ctrl3
+        {PLL_CLK_148_5MHZ,      0x63,   0,      1,      1,      4,      4,      0x3f770000,     0x68300},
+        {PLL_CLK_74_25MHZ,      0x63,   0,      1,      4,      4,      2,      0x3f770000,     0x68300},
+};
+#define	VOUT_DIGITAL_PLL_NUM	ARRAY_SIZE(ambarella_digital_vout_pll_table)
+
 static struct clk gclk_vo = {
 	.parent		= NULL,
 	.name		= "gclk_vo",
@@ -96,6 +134,50 @@ static struct clk *rct_register_clk_vout2(void)
 }
 
 /* ========================================================================== */
+static int find_clock_in_table(u32 rate, const vout_pll_s *pll_table, u32 table_size){
+        int     i = 0;
+        for(i = 0; i < table_size; i++){
+                if(rate == pll_table[i].rate)
+                        return (i+1);
+        }
+        return 0;
+}
+
+
+int ambarella_vout_set_rate(struct clk *c, u32 table_index)
+{
+	union ctrl_reg_u ctrl_reg;
+
+        vout_pll_s clk_pll = ambarella_digital_vout_pll_table[table_index-1];
+
+	if (table_index <= 0)
+		return -1;
+
+        amba_rct_writel_en(c->pres_reg, (clk_pll.pre_scaler - 1) << 4);
+
+	ctrl_reg.w = amba_rct_readl(c->ctrl_reg);
+	ctrl_reg.s.intp = clk_pll.intp - 1;
+	ctrl_reg.s.sdiv = clk_pll.sdiv - 1;
+	ctrl_reg.s.sout = clk_pll.sout - 1;
+	ctrl_reg.s.bypass = 0;
+	ctrl_reg.s.frac_mode = 0;
+	ctrl_reg.s.force_reset = 0;
+	ctrl_reg.s.power_down = 0;
+	ctrl_reg.s.halt_vco = 0;
+	ctrl_reg.s.tristate = 0;
+	ctrl_reg.s.force_lock = 1;
+	ctrl_reg.s.force_bypass = 0;
+	ctrl_reg.s.write_enable = 0;
+	amba_rct_writel_en(c->ctrl_reg, ctrl_reg.w);
+
+        amba_rct_writel_en(c->post_reg, (clk_pll.post_scaler - 1) << 4);
+
+	amba_rct_writel(c->ctrl2_reg, clk_pll.pll_ctrl2);
+	amba_rct_writel(c->ctrl3_reg, clk_pll.pll_ctrl3);
+	return 0;
+}
+
+
 void rct_set_vout_clk_src(u32 mode)
 {
 }
@@ -116,7 +198,14 @@ void rct_set_vout2_clk_src(u32 mode)
 
 void rct_set_vout2_freq_hz(u32 freq_hz)
 {
-	clk_set_rate(rct_register_clk_vout2(), freq_hz);
+        int table_index = find_clock_in_table(freq_hz,
+                                        ambarella_digital_vout_pll_table,
+                                        VOUT_DIGITAL_PLL_NUM);
+        if(table_index){
+                ambarella_vout_set_rate(rct_register_clk_vout2(), table_index);
+        }else{
+	        clk_set_rate(rct_register_clk_vout2(), freq_hz);
+        }
 }
 
 u32 rct_get_vout2_freq_hz(void)
diff --git a/drivers/vout/digital/AmbaConfig b/drivers/vout/digital/AmbaConfig
index 70882e6..a14f9ee 100644
--- a/drivers/vout/digital/AmbaConfig
+++ b/drivers/vout/digital/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2009/05/21 - [Anthony Ginger] Create
 ##
-## Copyright (C) 2004-2009, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 choice
diff --git a/drivers/vout/digital/amb_dbus/Kbuild b/drivers/vout/digital/amb_dbus/Kbuild
index 45571e1..834ba9a 100644
--- a/drivers/vout/digital/amb_dbus/Kbuild
+++ b/drivers/vout/digital/amb_dbus/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2009/07/09 - [Anthony Ginger] Create
 ##
-## Copyright (C) 2004-2008, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS) -I$(AMB_TOPDIR)/kernel/private/drivers/vout
diff --git a/drivers/vout/digital/amb_dbus/ambdbus.c b/drivers/vout/digital/amb_dbus/ambdbus.c
index 8f3b763..0273f76 100644
--- a/drivers/vout/digital/amb_dbus/ambdbus.c
+++ b/drivers/vout/digital/amb_dbus/ambdbus.c
@@ -4,14 +4,33 @@
  * History:
  *    2009/05/21 - [Anthony Ginger] Create
  *
- * Copyright (C) 2004-2009, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/ambbus.h>
diff --git a/drivers/vout/digital/amb_dbus/make.inc b/drivers/vout/digital/amb_dbus/make.inc
index d4dfe73..35270bf 100644
--- a/drivers/vout/digital/amb_dbus/make.inc
+++ b/drivers/vout/digital/amb_dbus/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/05 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_DIGITAL_AMBDBUS), y)
diff --git a/drivers/vout/dve/AmbaConfig b/drivers/vout/dve/AmbaConfig
index e110597..6dac181 100644
--- a/drivers/vout/dve/AmbaConfig
+++ b/drivers/vout/dve/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2009/05/14 - [Anthony Ginger] Create
 ##
-## Copyright (C) 2004-2008, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 choice
diff --git a/drivers/vout/dve/amb_tve/Kbuild b/drivers/vout/dve/amb_tve/Kbuild
index d97b02d..c0a3023 100644
--- a/drivers/vout/dve/amb_tve/Kbuild
+++ b/drivers/vout/dve/amb_tve/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2009/07/09 - [Anthony Ginger] Create
 ##
-## Copyright (C) 2004-2008, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS) -I$(AMB_TOPDIR)/kernel/private/drivers/vout
diff --git a/drivers/vout/dve/amb_tve/ambtve.c b/drivers/vout/dve/amb_tve/ambtve.c
index beb034f..78baa29 100644
--- a/drivers/vout/dve/amb_tve/ambtve.c
+++ b/drivers/vout/dve/amb_tve/ambtve.c
@@ -4,15 +4,34 @@
  * History:
  *    2009/05/14 - [Anthony Ginger] Create
  *
- * Copyright (C) 2004-2008, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/ambbus.h>
diff --git a/drivers/vout/dve/amb_tve/make.inc b/drivers/vout/dve/amb_tve/make.inc
index 61d85ea..fbd6069 100644
--- a/drivers/vout/dve/amb_tve/make.inc
+++ b/drivers/vout/dve/amb_tve/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/05 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(CONFIG_DVE_AMBTVE), y)
diff --git a/drivers/vout/hdmi/AmbaConfig b/drivers/vout/hdmi/AmbaConfig
index 25994fa..853ad77 100644
--- a/drivers/vout/hdmi/AmbaConfig
+++ b/drivers/vout/hdmi/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2009/06/02 - [Zhenwu Xue] Initial revision
 ##
-## Copyright (C) 2004-2009, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 choice
@@ -26,7 +43,6 @@ config CONFIG_HDMI_NULL
 
 config CONFIG_HDMI_AMBHDMI
 	bool "HDMI Video Output"
-	depends on (CONFIG_ARCH_S2 || CONFIG_ARCH_A7L || CONFIG_ARCH_S2L)
 	help
 		HDMI Video Output.
 
diff --git a/drivers/vout/hdmi/amb_hdmi/Kbuild b/drivers/vout/hdmi/amb_hdmi/Kbuild
index d3cf4ce..085070c 100644
--- a/drivers/vout/hdmi/amb_hdmi/Kbuild
+++ b/drivers/vout/hdmi/amb_hdmi/Kbuild
@@ -4,12 +4,29 @@
 ## History:
 ##    2009/07/09 - [Anthony Ginger] Create
 ##
-## Copyright (C) 2004-2008, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS) -I$(AMB_TOPDIR)/kernel/private/drivers/vout
diff --git a/drivers/vout/hdmi/amb_hdmi/ambhdmi.c b/drivers/vout/hdmi/amb_hdmi/ambhdmi.c
index 660a7ee..cbadd70 100644
--- a/drivers/vout/hdmi/amb_hdmi/ambhdmi.c
+++ b/drivers/vout/hdmi/amb_hdmi/ambhdmi.c
@@ -4,15 +4,34 @@
  * History:
  *    2009/06/02 - [Zhenwu Xue] Initial revision
  *
- * Copyright (C) 2004-2009, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/ambbus.h>
@@ -27,7 +46,7 @@
 #include <plat/clk.h>
 #include <plat/ambevent.h>
 #include <plat/audio.h>
-#include <plat/service.h>
+#include <plat/iav_helper.h>
 
 #include "vout_pri.h"
 #include "ambhdmi.h"
@@ -38,7 +57,7 @@
 
 struct ambhdmi_sink {
         struct device			*dev;
-        u32		                regbase;
+        void __iomem	                *regbase;
         u32				irq;
         wait_queue_head_t		irq_waitqueue;
         u32				irq_pending;
@@ -61,42 +80,23 @@ struct ambhdmi_instance_info {
 };
 
 /* ========================================================================== */
-
-static struct ambhdmi_instance_info hdmi_instance = {
-        .name		= "HDMI",
-        .source_id	= AMBA_VOUT_SOURCE_STARTING_ID + 1,
-        .sink_type	= AMBA_VOUT_SINK_TYPE_HDMI,
-        .io_mem		= {
-                .start	= HDMI_BASE,
-                .end	= HDMI_BASE + 0x1000 - 1,
-                .flags	= IORESOURCE_MEM,
-        },
-        .irq		= {
-                .start	= HDMI_IRQ,
-                .end	= HDMI_IRQ,
-                .flags	= IORESOURCE_IRQ,
-        }
-};
-/* ========================================================================== */
 #include "ambhdmi_edid.c"
 #include "ambhdmi_hdmise.c"
 
 /* ========================================================================== */
 static void ambhdmi_unplug(struct __amba_vout_video_sink *pvideo_sink)
 {
-        int                     i;
-        u32                     regbase;
         struct  ambhdmi_sink    *phdmi_sink;
+        int                     i;
 
         phdmi_sink = (struct ambhdmi_sink *)pvideo_sink->pinfo;
-        regbase = phdmi_sink->regbase;
         pvideo_sink->hdmi_plug = AMBA_VOUT_SINK_REMOVED;
 
         for (i = 0; i < AMBA_HDMI_MODE_MAX; i++) {
                 pvideo_sink->hdmi_modes[i] = AMBA_VIDEO_MODE_MAX;
         }
         pvideo_sink->hdmi_native_mode = AMBA_VIDEO_MODE_MAX;
-        amba_writel(regbase + HDMI_CLOCK_GATED_OFFSET, 0);
+        writel_relaxed(0, phdmi_sink->regbase + HDMI_CLOCK_GATED_OFFSET);
 
         amba_vout_video_source_cmd(pvideo_sink->source_id,
                                    AMBA_VIDEO_SOURCE_REPORT_SINK_EVENT,
@@ -106,27 +106,27 @@ static void ambhdmi_unplug(struct __amba_vout_video_sink *pvideo_sink)
 
 static void ambhdmi_plug(struct __amba_vout_video_sink *pvideo_sink)
 {
+	 void __iomem		*reg;
         int                     i, j, rval;
-        u32                     regbase, reg, val;
+        u32                     val;
         struct ambhdmi_sink     *phdmi_sink;
         amba_hdmi_edid_t        *pedid;
 
         phdmi_sink      = (struct ambhdmi_sink *)pvideo_sink->pinfo;
         pedid           = &phdmi_sink->edid;
-        regbase         = phdmi_sink->regbase;
 
         /* Enable CEC Clock */
-        reg     = regbase + HDMI_CLOCK_GATED_OFFSET;
-        val     = amba_readl(reg);
+        reg     = phdmi_sink->regbase + HDMI_CLOCK_GATED_OFFSET;
+        val     = readl_relaxed(reg);
         val     |= (HDMI_CLOCK_GATED_CEC_CLOCK_EN |
                     HDMI_CLOCK_GATED_HDCP_CLOCK_EN);
-        amba_writel(reg, val);
+        writel_relaxed(val, reg);
 
         /* Read and Parse EDID */
         rval = ambhdmi_edid_read_and_parse(phdmi_sink);
         if(rval) {
                 vout_notice("No EDID found!\n");
-                amba_writel(regbase + HDMI_CLOCK_GATED_OFFSET, 0);
+                writel_relaxed(0, phdmi_sink->regbase + HDMI_CLOCK_GATED_OFFSET);
                 return;
         }
 
@@ -145,11 +145,6 @@ static void ambhdmi_plug(struct __amba_vout_video_sink *pvideo_sink)
                         CEA_Timings[pedid->cea_timings.supported_cea_timings[i]].vmode;
         }
 
-        /* hdmi_native_mode */
-        if (pedid->native_timings.number) {
-                pedid->native_timings.supported_native_timings[0].vmode =
-                        AMBA_VIDEO_MODE_HDMI_NATIVE;
-        }
         pvideo_sink->hdmi_native_mode =
                 pedid->native_timings.supported_native_timings[0].vmode;
         pvideo_sink->hdmi_native_width =
@@ -165,42 +160,42 @@ static void ambhdmi_plug(struct __amba_vout_video_sink *pvideo_sink)
         ambhdmi_edid_print(pedid);
 
         /* Enable CEC Rx Interrupt */
-        reg = regbase + HDMI_INT_ENABLE_OFFSET;
-        val = amba_readl(reg);
+        reg = phdmi_sink->regbase + HDMI_INT_ENABLE_OFFSET;
+        val = readl_relaxed(reg);
         val |= HDMI_INT_ENABLE_CEC_RX_INT_EN;
-        amba_writel(reg, val);
+        writel_relaxed(val, reg);
 
         /* If working previously, reenable hdmise clock */
-        reg = regbase + HDMI_OP_MODE_OFFSET;
-        val = amba_readl(reg);
+        reg = phdmi_sink->regbase + HDMI_OP_MODE_OFFSET;
+        val = readl_relaxed(reg);
         if (val & HDMI_OP_MODE_OP_EN) {
-                reg = regbase + HDMI_CLOCK_GATED_OFFSET;
-                val = amba_readl(reg);
+                reg = phdmi_sink->regbase + HDMI_CLOCK_GATED_OFFSET;
+                val = readl_relaxed(reg);
                 val |= HDMI_CLOCK_GATED_HDMISE_CLOCK_EN;
-                amba_writel(reg, val);
+                writel_relaxed(val, reg);
         }
 
         /* Switch between HDMI and DVI Mode */
-        reg = regbase + HDMI_OP_MODE_OFFSET;
-        val = amba_readl(reg);
+        reg = phdmi_sink->regbase + HDMI_OP_MODE_OFFSET;
+        val = readl_relaxed(reg);
         if (HDMI_OP_MODE_OP_MODE(val) == HDMI_OP_MODE_OP_MODE_HDMI &&
             phdmi_sink->edid.interface == DVI) {
                 val &= 0xfffffffe;
                 val |= HDMI_OP_MODE_OP_MODE_DVI;
-                amba_writel(reg, val);
+                writel_relaxed(val, reg);
         }
         if (HDMI_OP_MODE_OP_MODE(val) == HDMI_OP_MODE_OP_MODE_DVI &&
             phdmi_sink->edid.interface == HDMI) {
                 val &= 0xfffffffe;
                 val |= HDMI_OP_MODE_OP_MODE_HDMI;
-                amba_writel(reg, val);
+                writel_relaxed(val, reg);
         }
 }
 
 static int ambhdmi_task(void *arg)
 {
-        u32				regbase, reg, val;
-        u32				irq, status;
+	void __iomem			*regbase, *reg;
+        u32				val, irq, status;
         amba_hdmi_edid_t 		*pedid;
         char *				envp[2];
         struct __amba_vout_video_sink	*pvideo_sink;
@@ -221,7 +216,7 @@ static int ambhdmi_task(void *arg)
                 phdmi_sink->irq_pending = 0;
 
                 msleep(200);
-                status = amba_readl(regbase + HDMI_STS_OFFSET);
+                status = readl_relaxed(regbase + HDMI_STS_OFFSET);
 
                 /* Rx Sense Remove or HPD Low */
                 if ((status & AMBHDMI_PLUG_IN) != AMBHDMI_PLUG_IN) {
@@ -253,13 +248,13 @@ static int ambhdmi_task(void *arg)
                 /* CEC Rx */
                 if (status & HDMI_INT_STS_CEC_RX_INTERRUPT) {
                         reg = regbase + HDMI_INT_ENABLE_OFFSET;
-                        val = amba_readl(reg);
+                        val = readl_relaxed(reg);
                         if (val & HDMI_INT_ENABLE_CEC_RX_INT_EN) {
                                 ambhdmi_cec_receive_message(phdmi_sink);
                         }
                 }
 
-                amba_writel(regbase + HDMI_INT_STS_OFFSET, 0);
+                writel_relaxed(0, regbase + HDMI_INT_STS_OFFSET);
                 enable_irq(irq);
         }
 
@@ -269,7 +264,7 @@ static int ambhdmi_task(void *arg)
 #ifdef CONFIG_PROC_FS
 static int ambarella_hdmi_edid_proc_show(struct seq_file *m, void *v)
 {
-        int                     i, j, rval = 0;
+        int                     i, j;
         struct ambhdmi_sink     *phdmi_sink = m->private;
 
         /* Check HDMI sink */
@@ -279,12 +274,12 @@ static int ambarella_hdmi_edid_proc_show(struct seq_file *m, void *v)
         }
 
         if (phdmi_sink->video_sink.hdmi_plug == AMBA_VOUT_SINK_REMOVED) {
-                rval = seq_printf(m, "No HDMI Plugged In!\n");
-                return rval;
+                seq_printf(m, "No HDMI Plugged In!\n");
+                return 0;
         }
         if (!phdmi_sink->raw_edid.buf) {
-                rval = seq_printf(m, "No EDID Contained !\n");
-                return rval;
+                seq_printf(m, "No EDID Contained !\n");
+                return 0;
         }
 
         /* Base EDID */
@@ -316,7 +311,7 @@ static int ambarella_hdmi_edid_proc_show(struct seq_file *m, void *v)
                 }
         }
 
-        return rval;
+        return 0;
 }
 
 static int ambarella_hdmi_edid_proc_open(struct inode *inode,
@@ -375,30 +370,26 @@ static irqreturn_t ambhdmi_isr(int irq, void *dev_id)
 static int ambhdmi_hw_init(struct ambhdmi_sink *phdmi_sink)
 {
         int     rval = 0;
-        u32     regbase;
-
-        regbase = phdmi_sink->regbase;
 
         /* Power on HDMI 5V */
         /* Soft Reset HDMISE */
-        amba_writel(regbase + HDMI_HDMISE_SOFT_RESET_OFFSET,
-                    HDMI_HDMISE_SOFT_RESET);
-        amba_writel(regbase + HDMI_HDMISE_SOFT_RESET_OFFSET,
-                    ~HDMI_HDMISE_SOFT_RESET);
+        writel_relaxed(HDMI_HDMISE_SOFT_RESET,
+        	phdmi_sink->regbase + HDMI_HDMISE_SOFT_RESET_OFFSET);
+        writel_relaxed(~HDMI_HDMISE_SOFT_RESET,
+		phdmi_sink->regbase + HDMI_HDMISE_SOFT_RESET_OFFSET);
 
         /* Reset CEC */
-        amba_writel(regbase + CEC_CTRL_OFFSET, 0x1 << 31);
+        writel_relaxed(0x1 << 31, phdmi_sink->regbase + CEC_CTRL_OFFSET);
 
         /* Clock Gating */
-        amba_writel(regbase + HDMI_CLOCK_GATED_OFFSET, 0);
+        writel_relaxed(0, phdmi_sink->regbase + HDMI_CLOCK_GATED_OFFSET);
 
         /* Enable Hotplug detect and loss interrupt */
-        amba_writel(regbase + HDMI_INT_ENABLE_OFFSET,
-                    HDMI_INT_ENABLE_PHY_RX_SENSE_REMOVE_EN |
+        writel_relaxed(HDMI_INT_ENABLE_PHY_RX_SENSE_REMOVE_EN |
                     HDMI_INT_ENABLE_PHY_RX_SENSE_EN |
                     HDMI_INT_ENABLE_HOT_PLUG_LOSS_EN |
-                    HDMI_INT_ENABLE_HOT_PLUG_DETECT_EN
-                   );
+                    HDMI_INT_ENABLE_HOT_PLUG_DETECT_EN,
+                    phdmi_sink->regbase + HDMI_INT_ENABLE_OFFSET);
 
         return rval;
 }
@@ -412,7 +403,7 @@ static int ambhdmi_reset(struct __amba_vout_video_sink *psink, u32 *args)
 
         psink->pstate = psink->state;
         psink->state = AMBA_VOUT_SINK_STATE_IDLE;
-        amba_writel(phdmi_sink->regbase + HDMI_CLOCK_GATED_OFFSET, 0);
+        writel_relaxed(0, phdmi_sink->regbase + HDMI_CLOCK_GATED_OFFSET);
 
         return rval;
 }
@@ -526,7 +517,7 @@ static int ambhdmi_suspend(struct __amba_vout_video_sink *psink, u32 *args)
         psink->pstate = psink->state;
         psink->state = AMBA_VOUT_SINK_STATE_SUSPENDED;
         psink->hdmi_plug = AMBA_VOUT_SINK_REMOVED;
-        amba_writel(phdmi_sink->regbase + HDMI_CLOCK_GATED_OFFSET, 0);
+        writel_relaxed(0, phdmi_sink->regbase + HDMI_CLOCK_GATED_OFFSET);
 
         return rval;
 }
@@ -613,6 +604,10 @@ static int ambhdmi_docmd(struct __amba_vout_video_sink *psink,
         return rval;
 }
 
+#ifndef HDMI_IRQ
+#define HDMI_IRQ	-1
+#endif
+
 static int ambhdmi_add_video_sink(struct i2c_adapter *adapter,
                                   struct device *pdev)
 {
@@ -630,8 +625,12 @@ static int ambhdmi_add_video_sink(struct i2c_adapter *adapter,
 
         /* Fill HDMI INFO */
         phdmi_sink->dev = pdev;
-        phdmi_sink->regbase = hdmi_instance.io_mem.start;
-        phdmi_sink->irq = hdmi_instance.irq.start;
+
+	phdmi_sink->regbase = ioremap(HDMI_PHYS, 0x1000);
+	if (!phdmi_sink->regbase)
+		return -ENOMEM;
+
+        phdmi_sink->irq = HDMI_IRQ;
         phdmi_sink->irq_pending	= 0;
         phdmi_sink->killing_kthread = 0;
         phdmi_sink->ddc_adapter = adapter;
@@ -648,10 +647,9 @@ static int ambhdmi_add_video_sink(struct i2c_adapter *adapter,
 
         /* Add Sink and Register Audio Notifier */
         pvideo_sink = &phdmi_sink->video_sink;
-        pvideo_sink->source_id = hdmi_instance.source_id;
-        pvideo_sink->sink_type = hdmi_instance.sink_type;
-        strlcpy(pvideo_sink->name, hdmi_instance.name,
-                sizeof(pvideo_sink->name));
+        pvideo_sink->source_id = AMBA_VOUT_SOURCE_STARTING_ID + 1;
+        pvideo_sink->sink_type = AMBA_VOUT_SINK_TYPE_HDMI;
+        strlcpy(pvideo_sink->name, "HDMI", sizeof(pvideo_sink->name));
         pvideo_sink->state = AMBA_VOUT_SINK_STATE_IDLE;
         pvideo_sink->hdmi_plug = AMBA_VOUT_SINK_REMOVED;
         for (i = 0; i < AMBA_HDMI_MODE_MAX; i++) {
@@ -690,6 +688,7 @@ static int ambhdmi_del_video_sink(struct ambhdmi_sink *phdmi_sink)
                 vfree(phdmi_sink->raw_edid.buf);
         ambarella_audio_unregister_notifier(&phdmi_sink->audio_transition);
         rval = amba_vout_del_video_sink(&phdmi_sink->video_sink);
+	iounmap(phdmi_sink->regbase);
         vout_notice("%s module removed!\n", phdmi_sink->video_sink.name);
         kfree(phdmi_sink);
 
diff --git a/drivers/vout/hdmi/amb_hdmi/ambhdmi.h b/drivers/vout/hdmi/amb_hdmi/ambhdmi.h
index 49e7816..f62d6ce 100644
--- a/drivers/vout/hdmi/amb_hdmi/ambhdmi.h
+++ b/drivers/vout/hdmi/amb_hdmi/ambhdmi.h
@@ -1,7 +1,34 @@
 /*
- * kernel/private/drivers/ambarella/vout/hdmi/amb_hdmi/ambhdmi.h
- *
- */
+  * kernel/private/drivers/ambarella/vout/hdmi/amb_hdmi/ambhdmi.h
+  *
+  * History:
+  *    2009/06/02 - [Zhenwu Xue] Initial revision
+  *
+  * Copyright (c) 2015 Ambarella, Inc.
+  *
+  * This file and its contents ("Software") are protected by intellectual
+  * property rights including, without limitation, U.S. and/or foreign
+  * copyrights. This Software is also the confidential and proprietary
+  * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+  * disclose, distribute, modify, or otherwise prepare derivative works of this
+  * Software or any portion thereof except pursuant to a signed license agreement
+  * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+  * In the absence of such an agreement, you agree to promptly notify and return
+  * this Software to Ambarella, Inc.
+  *
+  * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+  * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+  * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+  * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+  * POSSIBILITY OF SUCH DAMAGE.
+  *
+  */
 
 #ifndef __AMBHW_HDMI_H__
 #define __AMBHW_HDMI_H__
@@ -52,6 +79,7 @@
 /* Controller registers definitions                 */
 /****************************************************/
 #define HDMI_OFFSET			0x13000
+#define HDMI_PHYS			(0xe0000000 + HDMI_OFFSET)
 #define HDMI_BASE			(AHB_BASE + HDMI_OFFSET)
 #define HDMI_REG(x)			(HDMI_BASE + (x))
 
@@ -565,17 +593,14 @@
 #define HDMI_AUNIT_SRC_FLAT_LINE1		(0x01 << 5)
 #define HDMI_AUNIT_SRC_FLAT_LINE0		(0x01 << 4)
 #define HDMI_AUNIT_SRC_I2S3_EN			(0x01 << 3)
-#define HDMI_AUNIT_SRC_I2S2_EN			(0x01 << 2)
-#define HDMI_AUNIT_SRC_I2S1_EN			(0x01 << 1)
-#define HDMI_AUNIT_SRC_I2S0_EN			(0x01)
 #else	/* (VOUT_HDMI_SUPPORT_AUDIO_CHANNELS == 6) */
 #define HDMI_AUNIT_SRC_FLAT_LINE2		(0x01 << 5)
 #define HDMI_AUNIT_SRC_FLAT_LINE1		(0x01 << 4)
 #define HDMI_AUNIT_SRC_FLAT_LINE0		(0x01 << 3)
+#endif
 #define HDMI_AUNIT_SRC_I2S2_EN			(0x01 << 2)
 #define HDMI_AUNIT_SRC_I2S1_EN			(0x01 << 1)
 #define HDMI_AUNIT_SRC_I2S0_EN			(0x01)
-#endif
 
 /* AUNIT_CS0_REG */
 /* AUNIT_CS1_REG */
@@ -1223,6 +1248,7 @@
 #else
 #define HDCP_HDCPCE_CTL_OFFSET		0x400
 #endif
+#define HDMI_EESS_CTL_OFFSET		HDCP_HDCPCE_CTL_OFFSET
 
 #if (VOUT_SUPPORT_ONCHIP_HDCP == 1)
 
@@ -1453,7 +1479,7 @@
 
 #endif
 
-#define HDMI_EESS_CTL_REG			HDMI_REG(HDCP_HDCPCE_CTL_OFFSET)
+#define HDMI_EESS_CTL_REG			HDMI_REG(HDMI_EESS_CTL_OFFSET)
 #define HDMI_HDCPCE_CTL_HDCPCE_EN		(0x1UL << 31)
 #define HDMI_HDCPCE_CTL_HDCP_ENC_EN		(0x1 << 5)
 #define HDMI_HDCPCE_CTL_USE_EESS(x)		(((x) & 0x01) << 4)
diff --git a/drivers/vout/hdmi/amb_hdmi/ambhdmi_cec.c b/drivers/vout/hdmi/amb_hdmi/ambhdmi_cec.c
index d6c74df..1c2ff1c 100644
--- a/drivers/vout/hdmi/amb_hdmi/ambhdmi_cec.c
+++ b/drivers/vout/hdmi/amb_hdmi/ambhdmi_cec.c
@@ -4,15 +4,34 @@
  * History:
  *    2009/06/05 - [Zhenwu Xue] Initial revision
  *
- * Copyright (C) 2004-2009, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 /* ========================================================================== */
 
 amba_hdmi_cec_logical_address_t ambhdmi_cec_allocate_logical_address(
@@ -23,28 +42,28 @@ amba_hdmi_cec_logical_address_t ambhdmi_cec_allocate_logical_address(
                 CEC_DEV_RECORDING2,
                 CEC_DEV_RECORDING3
         };
-        u32     regbase, reg, val;
+	void __iomem  *reg;
+        u32     val;
         int     i, j, timeout;
 
-        regbase = phdmi_sink->regbase;
         for (i = 0; i < ARRAY_SIZE(candidate_addresses); i++) {
                 /* Prepare to Tx */
-                reg = regbase + HDMI_INT_STS_OFFSET;
-                val = amba_readl(reg);
+                reg = phdmi_sink->regbase + HDMI_INT_STS_OFFSET;
+                val = readl_relaxed(reg);
                 val &= ~HDMI_INT_STS_CEC_TX_INTERRUPT_OK;
                 val &= ~HDMI_INT_STS_CEC_TX_INTERRUPT_FAIL;
-                amba_writel(reg, val);
+                writel_relaxed(val, reg);
 
-                reg = regbase + CEC_TX_DATA0_OFFSET;
+                reg = phdmi_sink->regbase + CEC_TX_DATA0_OFFSET;
                 val = (candidate_addresses[i] << 28) |
                       (candidate_addresses[i] << 24);
-                amba_writel(reg, val);
+                writel_relaxed(val, reg);
 
                 /* Wait for Signal Free */
                 timeout = 125;
-                reg = regbase + CEC_STATUS_OFFSET;
+                reg = phdmi_sink->regbase + CEC_STATUS_OFFSET;
                 for (j = 0; j < timeout; j++) {
-                        val = amba_readl(reg);
+                        val = readl_relaxed(reg);
                         if (val & CEC_STATUS_RX_STA_RX_IDLE3)
                                 break;
                         mdelay(4);
@@ -55,17 +74,17 @@ amba_hdmi_cec_logical_address_t ambhdmi_cec_allocate_logical_address(
                         continue;
                 mdelay(2);
 
-                reg = regbase + CEC_CTRL_OFFSET;
-                val = amba_readl(reg);
+                reg = phdmi_sink->regbase + CEC_CTRL_OFFSET;
+                val = readl_relaxed(reg);
                 val &= ~(0xf << 26);
                 val |= ((0x0 << 26) | (0x1 << 30));
-                amba_writel(reg, val);
+                writel_relaxed(val, reg);
 
                 /* Track Tx result */
-                reg = regbase + HDMI_INT_STS_OFFSET;
+                reg = phdmi_sink->regbase + HDMI_INT_STS_OFFSET;
                 timeout = 1000;
                 for (j = 0; j < timeout; j++) {
-                        val = amba_readl(reg);
+                        val = readl_relaxed(reg);
                         if (val & HDMI_INT_STS_CEC_TX_INTERRUPT_OK)
                                 break;
                         if (val & HDMI_INT_STS_CEC_TX_INTERRUPT_FAIL)
@@ -76,10 +95,10 @@ amba_hdmi_cec_logical_address_t ambhdmi_cec_allocate_logical_address(
                 if (val & HDMI_INT_STS_CEC_TX_INTERRUPT_FAIL)
                         break;
 
-                reg = regbase + CEC_CTRL_OFFSET;
-                val = amba_readl(reg);
+                reg = phdmi_sink->regbase + CEC_CTRL_OFFSET;
+                val = readl_relaxed(reg);
                 val &= ~(0x1 << 30);
-                amba_writel(reg, val);
+                writel_relaxed(val, reg);
         }
 
         if (i < ARRAY_SIZE(candidate_addresses))
@@ -90,33 +109,32 @@ amba_hdmi_cec_logical_address_t ambhdmi_cec_allocate_logical_address(
 
 int ambhdmi_cec_report_physical_address(struct ambhdmi_sink *phdmi_sink)
 {
-        u32     regbase, reg, val;
+	void __iomem  *reg;
+        u32     val;
         int     i, timeout;
 
-        regbase = phdmi_sink->regbase;
-
         /* Prepare to Tx */
-        reg = regbase + HDMI_INT_STS_OFFSET;
-        val = amba_readl(reg);
+        reg = phdmi_sink->regbase + HDMI_INT_STS_OFFSET;
+        val = readl_relaxed(reg);
         val &= ~HDMI_INT_STS_CEC_TX_INTERRUPT_OK;
         val &= ~HDMI_INT_STS_CEC_TX_INTERRUPT_FAIL;
-        amba_writel(reg, val);
+        writel_relaxed(val, reg);
 
-        reg = regbase + CEC_TX_DATA0_OFFSET;
+        reg = phdmi_sink->regbase + CEC_TX_DATA0_OFFSET;
         val = (phdmi_sink->edid.cec.logical_address << 28) |
               (CEC_DEV_BROADCAST << 24);
         val |= (0x84 << 16);
         val |= phdmi_sink->edid.cec.physical_address;
-        amba_writel(reg, val);
+        writel_relaxed(val, reg);
 
-        reg = regbase + CEC_TX_DATA1_OFFSET;
+        reg = phdmi_sink->regbase + CEC_TX_DATA1_OFFSET;
         val = (CEC_DEV_RECORDING1 << 24);
 
         /* Wait for Signal Free */
         timeout = 125;
-        reg = regbase + CEC_STATUS_OFFSET;
+        reg = phdmi_sink->regbase + CEC_STATUS_OFFSET;
         for (i = 0; i < timeout; i++) {
-                val = amba_readl(reg);
+                val = readl_relaxed(reg);
                 if (val & CEC_STATUS_RX_STA_RX_IDLE3)
                         break;
                 mdelay(4);
@@ -127,17 +145,17 @@ int ambhdmi_cec_report_physical_address(struct ambhdmi_sink *phdmi_sink)
                 return -1;
         mdelay(2);
 
-        reg = regbase + CEC_CTRL_OFFSET;
-        val = amba_readl(reg);
+        reg = phdmi_sink->regbase + CEC_CTRL_OFFSET;
+        val = readl_relaxed(reg);
         val &= ~(0xf << 26);
         val |= ((0x4 << 26) | (0x1 << 30));
-        amba_writel(reg, val);
+        writel_relaxed(val, reg);
 
         /* Track Tx result */
-        reg = regbase + HDMI_INT_STS_OFFSET;
+        reg = phdmi_sink->regbase + HDMI_INT_STS_OFFSET;
         timeout = 1000;
         for (i = 0; i < timeout; i++) {
-                val = amba_readl(reg);
+                val = readl_relaxed(reg);
                 if (val & HDMI_INT_STS_CEC_TX_INTERRUPT_OK)
                         break;
                 if (val & HDMI_INT_STS_CEC_TX_INTERRUPT_FAIL)
@@ -148,36 +166,36 @@ int ambhdmi_cec_report_physical_address(struct ambhdmi_sink *phdmi_sink)
         if (val & HDMI_INT_STS_CEC_TX_INTERRUPT_OK)
                 return 0;
 
-        reg = regbase + CEC_CTRL_OFFSET;
-        val = amba_readl(reg);
+        reg = phdmi_sink->regbase + CEC_CTRL_OFFSET;
+        val = readl_relaxed(reg);
         val &= ~(0x1 << 30);
-        amba_writel(reg, val);
+        writel_relaxed(val, reg);
 
         return -1;
 }
 
 void ambhdmi_cec_receive_message(struct ambhdmi_sink *phdmi_sink)
 {
-        u32     regbase, reg, val;
+	void __iomem  *reg;
+        u32     val;
         u32     i, j, k, blocks, buf[4];
         u8      buf2[4 * 4];
 
-        regbase = phdmi_sink->regbase;
-        buf[0] = amba_readl(regbase + CEC_RX_DATA0_OFFSET);
+        buf[0] = readl_relaxed(phdmi_sink->regbase + CEC_RX_DATA0_OFFSET);
         val = (buf[0] & 0x0f000000) >> 24;
         if (val != phdmi_sink->edid.cec.logical_address
             && val != CEC_DEV_BROADCAST)
                 return;
 
-        reg = regbase + CEC_CTRL_OFFSET;
-        val = amba_readl(reg);
+        reg = phdmi_sink->regbase + CEC_CTRL_OFFSET;
+        val = readl_relaxed(reg);
         blocks = ((val >> 22) & 0xf) + 1;
         if (blocks == 1)
                 return;
 
-        buf[1] = amba_readl(regbase + CEC_RX_DATA1_OFFSET);
-        buf[2] = amba_readl(regbase + CEC_RX_DATA2_OFFSET);
-        buf[3] = amba_readl(regbase + CEC_RX_DATA3_OFFSET);
+        buf[1] = readl_relaxed(phdmi_sink->regbase + CEC_RX_DATA1_OFFSET);
+        buf[2] = readl_relaxed(phdmi_sink->regbase + CEC_RX_DATA2_OFFSET);
+        buf[3] = readl_relaxed(phdmi_sink->regbase + CEC_RX_DATA3_OFFSET);
 
         for (i = 0; i < blocks; i++) {
                 j = i >> 2;
diff --git a/drivers/vout/hdmi/amb_hdmi/ambhdmi_cec.h b/drivers/vout/hdmi/amb_hdmi/ambhdmi_cec.h
index 6b5e758..2390758 100644
--- a/drivers/vout/hdmi/amb_hdmi/ambhdmi_cec.h
+++ b/drivers/vout/hdmi/amb_hdmi/ambhdmi_cec.h
@@ -4,16 +4,35 @@
  * History:
  *    2009/06/05 - [Zhenwu Xue] Initial revision
  *
- * Copyright (C) 2004-2009, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
 
+
 /* ========================================================================== */
 
 typedef enum {
diff --git a/drivers/vout/hdmi/amb_hdmi/ambhdmi_edid.c b/drivers/vout/hdmi/amb_hdmi/ambhdmi_edid.c
index 80868a5..0063ebf 100644
--- a/drivers/vout/hdmi/amb_hdmi/ambhdmi_edid.c
+++ b/drivers/vout/hdmi/amb_hdmi/ambhdmi_edid.c
@@ -4,15 +4,34 @@
  * History:
  *    2009/06/05 - [Zhenwu Xue] Initial revision
  *
- * Copyright (C) 2004-2009, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #include "ambhdmi_cec.h"
 #include "ambhdmi_cec.c"
 
@@ -562,6 +581,10 @@ static void ambhdmi_edid_parse_extension(struct ambhdmi_sink *phdmi_sink,
         /* Native timings */
         pntiming = &pedid->native_timings;
         for (i = 0; i < (buf[0x03] & 0x0f); i++, offset += 0x12) {
+                if (!buf[offset] && !buf[offset + 1]) {
+                        continue;
+                }
+
                 pvtiming = &pntiming->supported_native_timings[pntiming->number];
 
                 pvtiming->pixel_clock =
@@ -843,7 +866,7 @@ static void ambhdmi_edid_print(const amba_hdmi_edid_t *pedid)
         for (i = 0; i < pntiming->number; i++) {
                 pvtiming = &pntiming->supported_native_timings[i];
                 EDID_PRINT("Native timing #%2d: %s\n", i + 1, pvtiming->name);
-                /*EDID_PRINT("Pixel Clock: %d.%03dMHz\n", pvtiming->pixel_clock / 1000, pvtiming->pixel_clock % 1000);
+                EDID_PRINT("Pixel Clock: %d.%03dMHz\n", pvtiming->pixel_clock / 1000, pvtiming->pixel_clock % 1000);
                 EDID_PRINT("H avtive: %d pixels, V active %d lines\n", pvtiming->h_active, pvtiming->v_active);
                 EDID_PRINT("H blanking: %d pixels, V blanking %d lines\n", pvtiming->h_blanking, pvtiming->v_blanking);
                 EDID_PRINT("H sync offset: %d pixels, width %d pixels\n", pvtiming->hsync_offset, pvtiming->hsync_width);
@@ -860,7 +883,7 @@ static void ambhdmi_edid_print(const amba_hdmi_edid_t *pedid)
                         EDID_PRINT("V sync Positive\n");
                 else
                         EDID_PRINT("V sync Negative\n");
-                EDID_PRINT("\n");*/
+                EDID_PRINT("\n");
         }
 
         /* CEA timings */
@@ -893,6 +916,15 @@ static const amba_hdmi_video_timing_t *ambhdmi_edid_find_video_mode(
         if (!pedid)
                 return vt;
 
+        /* Try to find it in EDID Native Timings */
+        pntiming = &pedid->native_timings;
+        for (i = 0; i < pntiming->number; i++) {
+                if (pntiming->supported_native_timings[i].vmode == vmode) {
+                        vt = &pntiming->supported_native_timings[i];
+                        return vt;
+                }
+        }
+
         /* Try to find it in EDID CEA Timings */
         pctiming = &pedid->cea_timings;
         for (i = 0; i < pctiming->number; i++) {
@@ -903,15 +935,6 @@ static const amba_hdmi_video_timing_t *ambhdmi_edid_find_video_mode(
                 }
         }
 
-        /* Try to find it in EDID Native Timings */
-        pntiming = &pedid->native_timings;
-        for (i = 0; i < pntiming->number; i++) {
-                if (pntiming->supported_native_timings[i].vmode == vmode) {
-                        vt = &pntiming->supported_native_timings[i];
-                        return vt;
-                }
-        }
-
         /* Use Default CEA Timings */
         for (i = 0; i < MAX_TOTAL_CEA_TIMINGS; i++) {
                 if (CEA_Timings[i].vmode == vmode) {
diff --git a/drivers/vout/hdmi/amb_hdmi/ambhdmi_edid.h b/drivers/vout/hdmi/amb_hdmi/ambhdmi_edid.h
index 1722d5b..3874ffb 100644
--- a/drivers/vout/hdmi/amb_hdmi/ambhdmi_edid.h
+++ b/drivers/vout/hdmi/amb_hdmi/ambhdmi_edid.h
@@ -4,21 +4,46 @@
  * History:
  *    2009/06/05 - [Zhenwu Xue] Initial revision
  *
- * Copyright (C) 2004-2009, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+#if (CHIP_REV == S3) || (CHIP_REV == S5)
+#define HDMI_DDC_ID                     2
+#else
+#define HDMI_DDC_ID                     1
+#endif
+
 #define EDID_SEGMENT_POINTER_ADDR	(0x60 >> 1)
 #define EDID_DATA_ACCESS_ADDR		(0xa0 >> 1)
 #define EDID_PER_SEGMENT_SIZE		128
+#define HDMI_SCDC_ACCESS_ADDR         (0xa8 >> 1)
+#define HDMI_SCDC_SIZE                        256
 
-#define MAX_CEA_TIMINGS			63
-#define MAX_EXTENDED_TIMINGS		5
+#define MAX_CEA_TIMINGS			107
+#define MAX_EXTENDED_TIMINGS		9
 #define MAX_TOTAL_CEA_TIMINGS		(MAX_CEA_TIMINGS + MAX_EXTENDED_TIMINGS)
 #define MAX_NATIVE_TIMINGS		25
 
@@ -244,17 +269,66 @@ const static amba_hdmi_video_timing_t CEA_Timings[MAX_TOTAL_CEA_TIMINGS] = {
 	/* Format 62 */
 	{AMBA_VIDEO_MODE_720P30,           "1280x720p30",     74176, 1760,   40, 2020, 1280,    5,    5,   30,  720,    0,    1,   1,	1,	AMBA_VIDEO_RATIO_16_9,	COLORIMETRY_ITU709 },
 
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+
+       /* Format 93 */
+	{AMBA_VIDEO_MODE_2160P24,         "3840x2160p24",    297000,  296,   88, 1660, 3840,   72,   10,   90, 2160,    0,    1,   1,	1,	AMBA_VIDEO_RATIO_16_9,	COLORIMETRY_NO_DATA},
+       /* Format 94 */
+	{AMBA_VIDEO_MODE_2160P25,         "3840x2160p25",    297000,  296,   88, 1440, 3840,   72,   10,   90, 2160,    0,    1,   1,	1,	AMBA_VIDEO_RATIO_16_9,	COLORIMETRY_NO_DATA},
+       /* Format 95 */
+	{AMBA_VIDEO_MODE_2160P30,         "3840x2160p30",    297000,  296,   88,  560, 3840,   72,   10,   90, 2160,    0,    1,   1,	1,	AMBA_VIDEO_RATIO_16_9,	COLORIMETRY_NO_DATA},
+
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+       /* Format 97 */
+	{AMBA_VIDEO_MODE_2160P60,         "3840x2160p60",    594000,  296,   88,  560, 3840,   72,   10,   90, 2160,    0,    1,   1,	1,	AMBA_VIDEO_RATIO_16_9,	COLORIMETRY_NO_DATA},
+       /* Format 98 */
+	{AMBA_VIDEO_MODE_2160P24_SE,      "4096x2160p24",    297000,  296,   88, 1404, 4096,   72,   10,   90, 2160,    0,    1,   1,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
 
-	/* Extended Format 0 */
 	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_MAX,                         "",         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   0,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+
 	/* Extended Format 1 */
-	{AMBA_VIDEO_MODE_2160P30,         "3840x2160p30",    297000,  296,   88,  560, 3840,   72,   10,   90, 2160,    0,    1,   1,	1,	AMBA_VIDEO_RATIO_16_9,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_2160P12,         "3840x2160p12",    297000,  296,   88, 6880, 3840,   72,   10,   90, 2160,    0,    1,   1,	1,	AMBA_VIDEO_RATIO_16_9,	COLORIMETRY_NO_DATA},
 	/* Extended Format 2 */
-	{AMBA_VIDEO_MODE_2160P25,         "3840x2160p25",    297000,  296,   88, 1440, 3840,   72,   10,   90, 2160,    0,    1,   1,	1,	AMBA_VIDEO_RATIO_16_9,	COLORIMETRY_NO_DATA},
-	/* Extended Format 3 */
-	{AMBA_VIDEO_MODE_2160P24,         "3840x2160p24",    297000,  296,   88, 1660, 3840,   72,   10,   90, 2160,    0,    1,   1,	1,	AMBA_VIDEO_RATIO_16_9,	COLORIMETRY_NO_DATA},
-	/* Extended Format 4 */
-	{AMBA_VIDEO_MODE_2160P24_SE,      "4096x2160p24",    297000,  296,   88, 1404, 4096,   72,   10,   90, 2160,    0,    1,   1,	1,	AMBA_VIDEO_RATIO_AUTO,	COLORIMETRY_NO_DATA},
+	{AMBA_VIDEO_MODE_2160P15,         "3840x2160p15",    297000,  296,   88, 5080, 3840,   72,   10,   90, 2160,    0,    1,   1,	1,	AMBA_VIDEO_RATIO_16_9,	COLORIMETRY_NO_DATA},
+        /* Extended Format 7 */
 };
 
 typedef struct {
@@ -263,6 +337,13 @@ typedef struct {
 } amba_hdmi_cec_t;
 
 typedef struct {
+	u8					scdc_present;
+	u8					rr_capable;
+	u8					lte_340m_scramble;
+	u32					max_tmds_rate;
+} amba_hdmi_scramble_support_t;
+
+typedef struct {
 	amba_hdmi_interface_t			interface;
 	amba_hdmi_color_space_t			color_space;
 	amba_hdmi_product_t			product;
@@ -272,6 +353,7 @@ typedef struct {
 	amba_hdmi_native_timing_t		native_timings;
 	amba_hdmi_cea_timing_t			cea_timings;
 	amba_hdmi_ddd_support_t			ddd_structure;
+	amba_hdmi_scramble_support_t		scramble;
 	amba_hdmi_cec_t				cec;
 } amba_hdmi_edid_t;
 
diff --git a/drivers/vout/hdmi/amb_hdmi/ambhdmi_hdmise.c b/drivers/vout/hdmi/amb_hdmi/ambhdmi_hdmise.c
index 2b42dde..179aaf3 100644
--- a/drivers/vout/hdmi/amb_hdmi/ambhdmi_hdmise.c
+++ b/drivers/vout/hdmi/amb_hdmi/ambhdmi_hdmise.c
@@ -4,15 +4,34 @@
  * History:
  *    2009/06/05 - [Zhenwu Xue] Initial revision
  *
- * Copyright (C) 2004-2009, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #include "dsp_cmd_msg.h"
 
 typedef struct {
@@ -29,36 +48,36 @@ static struct {
         hdmi_packet_t		vendor[8];	//A5S
 #endif
 } HDMI_PACKETS = {
-        .avi[0]		= {HDMI_PACKET_AVI0_REG, 0},
-        .avi[1]		= {HDMI_PACKET_AVI1_REG, 0},
-        .avi[2]		= {HDMI_PACKET_AVI2_REG, 0},
-        .avi[3]		= {HDMI_PACKET_AVI3_REG, 0},
-        .avi[4]		= {HDMI_PACKET_AVI4_REG, 0},
-        .avi[5]		= {HDMI_PACKET_AVI5_REG, 0},
-        .avi[6]		= {HDMI_PACKET_AVI6_REG, 0},
-        .avi[7]		= {HDMI_PACKET_AVI7_REG, 0},
-        .avi[8]		= {HDMI_PACKET_AVI8_REG, 0},
-
-        .audio[0]	= {HDMI_PACKET_AUDIO0_REG, 0},
-        .audio[1]	= {HDMI_PACKET_AUDIO1_REG, 0},
-        .audio[2]	= {HDMI_PACKET_AUDIO2_REG, 0},
-        .audio[3]	= {HDMI_PACKET_AUDIO3_REG, 0},
-        .audio[4]	= {HDMI_PACKET_AUDIO4_REG, 0},
-        .audio[5]	= {HDMI_PACKET_AUDIO5_REG, 0},
-        .audio[6]	= {HDMI_PACKET_AUDIO6_REG, 0},
-        .audio[7]	= {HDMI_PACKET_AUDIO7_REG, 0},
-        .audio[8]	= {HDMI_PACKET_AUDIO8_REG, 0},
-
-        .vendor[0]	= {HDMI_PACKET_VS0_REG, 0},
-        .vendor[1]	= {HDMI_PACKET_VS1_REG, 0},
-        .vendor[2]	= {HDMI_PACKET_VS2_REG, 0},
-        .vendor[3]	= {HDMI_PACKET_VS3_REG, 0},
-        .vendor[4]	= {HDMI_PACKET_VS4_REG, 0},
-        .vendor[5]	= {HDMI_PACKET_VS5_REG, 0},
-        .vendor[6]	= {HDMI_PACKET_VS6_REG, 0},
-        .vendor[7]	= {HDMI_PACKET_VS7_REG, 0},
+        .avi[0]		= {HDMI_PACKET_AVI0_OFFSET, 0},
+        .avi[1]		= {HDMI_PACKET_AVI1_OFFSET, 0},
+        .avi[2]		= {HDMI_PACKET_AVI2_OFFSET, 0},
+        .avi[3]		= {HDMI_PACKET_AVI3_OFFSET, 0},
+        .avi[4]		= {HDMI_PACKET_AVI4_OFFSET, 0},
+        .avi[5]		= {HDMI_PACKET_AVI5_OFFSET, 0},
+        .avi[6]		= {HDMI_PACKET_AVI6_OFFSET, 0},
+        .avi[7]		= {HDMI_PACKET_AVI7_OFFSET, 0},
+        .avi[8]		= {HDMI_PACKET_AVI8_OFFSET, 0},
+
+        .audio[0]	= {HDMI_PACKET_AUDIO0_OFFSET, 0},
+        .audio[1]	= {HDMI_PACKET_AUDIO1_OFFSET, 0},
+        .audio[2]	= {HDMI_PACKET_AUDIO2_OFFSET, 0},
+        .audio[3]	= {HDMI_PACKET_AUDIO3_OFFSET, 0},
+        .audio[4]	= {HDMI_PACKET_AUDIO4_OFFSET, 0},
+        .audio[5]	= {HDMI_PACKET_AUDIO5_OFFSET, 0},
+        .audio[6]	= {HDMI_PACKET_AUDIO6_OFFSET, 0},
+        .audio[7]	= {HDMI_PACKET_AUDIO7_OFFSET, 0},
+        .audio[8]	= {HDMI_PACKET_AUDIO8_OFFSET, 0},
+
+        .vendor[0]	= {HDMI_PACKET_VS0_OFFSET, 0},
+        .vendor[1]	= {HDMI_PACKET_VS1_OFFSET, 0},
+        .vendor[2]	= {HDMI_PACKET_VS2_OFFSET, 0},
+        .vendor[3]	= {HDMI_PACKET_VS3_OFFSET, 0},
+        .vendor[4]	= {HDMI_PACKET_VS4_OFFSET, 0},
+        .vendor[5]	= {HDMI_PACKET_VS5_OFFSET, 0},
+        .vendor[6]	= {HDMI_PACKET_VS6_OFFSET, 0},
+        .vendor[7]	= {HDMI_PACKET_VS7_OFFSET, 0},
 #if (VOUT_HDMI_REGS_OFFSET_GROUP == 3)
-        .vendor[8]	= {HDMI_PACKET_VS8_REG},
+        .vendor[8]	= {HDMI_PACKET_VS8_OFFSET},
 #endif
 };
 
@@ -66,130 +85,106 @@ static struct {
 
 static u32 pixel_clock;
 
-static void ambhdmi_hdmise_flush_packets(void)
+static void ambhdmi_hdmise_flush_packets(struct ambhdmi_sink *phdmi_sink)
 {
+	void __iomem  *reg;
+	u32 val;
         int     i, j;
-        u32     reg;
         u8      sum, check_sum;
 
         /* AVI */
         sum = 0;
         HDMI_PACKETS.avi[1].val &= 0xFFFFFF00;
         for (i = 0; i < PACKET_NUM(avi); i++) {
-                reg = HDMI_PACKETS.avi[i].val;
+                val = HDMI_PACKETS.avi[i].val;
                 for (j = 0; j < 4; j++) {
-                        sum += (reg & 0xFF);
-                        reg >>= 8;
+                        sum += (val & 0xFF);
+                        val >>= 8;
                 }
         }
         check_sum = 256 - sum;
         HDMI_PACKETS.avi[1].val |= check_sum;
 
         for (i = 0; i < PACKET_NUM(avi); i++) {
-                amba_writel(HDMI_PACKETS.avi[i].reg, HDMI_PACKETS.avi[i].val);
+		reg = phdmi_sink->regbase + HDMI_PACKETS.avi[i].reg;
+                writel_relaxed(HDMI_PACKETS.avi[i].val, reg);
         }
 
         /* Audio */
         sum = 0;
         HDMI_PACKETS.audio[1].val &= 0xFFFFFF00;
         for (i = 0; i < PACKET_NUM(audio); i++) {
-                reg = HDMI_PACKETS.audio[i].val;
+                val = HDMI_PACKETS.audio[i].val;
                 for (j = 0; j < 4; j++) {
-                        sum += (reg & 0xFF);
-                        reg >>= 8;
+                        sum += (val & 0xFF);
+                        val >>= 8;
                 }
         }
         check_sum = 256 - sum;
         HDMI_PACKETS.audio[1].val |= check_sum;
 
         for (i = 0; i < PACKET_NUM(audio); i++) {
-                amba_writel(HDMI_PACKETS.audio[i].reg, HDMI_PACKETS.audio[i].val);
+		reg = phdmi_sink->regbase + HDMI_PACKETS.audio[i].reg;
+                writel_relaxed(HDMI_PACKETS.audio[i].val, reg);
         }
 
         /* Vendor Specific */
         sum = 0;
         HDMI_PACKETS.vendor[1].val &= 0xFFFFFF00;
         for (i = 0; i < PACKET_NUM(vendor); i++) {
-                reg = HDMI_PACKETS.vendor[i].val;
+                val = HDMI_PACKETS.vendor[i].val;
                 for (j = 0; j < 4; j++) {
-                        sum += (reg & 0xFF);
-                        reg >>= 8;
+                        sum += (val & 0xFF);
+                        val >>= 8;
                 }
         }
         check_sum = 256 - sum;
         HDMI_PACKETS.vendor[1].val |= check_sum;
 
         for (i = 0; i < PACKET_NUM(vendor); i++) {
-                amba_writel(HDMI_PACKETS.vendor[i].reg, HDMI_PACKETS.vendor[i].val);
+		reg = phdmi_sink->regbase + HDMI_PACKETS.vendor[i].reg;
+                writel_relaxed(HDMI_PACKETS.vendor[i].val, reg);
         }
 }
 
-static void ambhdmi_hdmise_config_audio(struct ambarella_i2s_interface *i2s_config)
+static void ambhdmi_hdmise_config_audio(struct ambhdmi_sink *phdmi_sink,
+		struct ambarella_i2s_interface *i2s_config)
 {
-        u32		mclk, n, cts, src, layout, mode, order, len, pos;
-        u8		cc;
-
-        /* MCLK */
-        switch (i2s_config->oversample) {
-        case AudioCodec_128xfs:
-                mclk = HDMI_AUNIT_MCLK_INPUT_FREQ_MODE_128FS;
-                break;
-
-        case AudioCodec_256xfs:
-                mclk = HDMI_AUNIT_MCLK_INPUT_FREQ_MODE_256FS;
-                break;
-
-        case AudioCodec_384xfs:
-                mclk = HDMI_AUNIT_MCLK_INPUT_FREQ_MODE_384FS;
-                break;
-
-        case AudioCodec_512xfs:
-                mclk = HDMI_AUNIT_MCLK_INPUT_FREQ_MODE_512FS;
-                break;
-
-        case AudioCodec_768xfs:
-                mclk = HDMI_AUNIT_MCLK_INPUT_FREQ_MODE_768FS;
-                break;
-
-        default:
-                vout_notice("Incorrect MCLK!\n");
-                mclk = HDMI_AUNIT_MCLK_INPUT_FREQ_MODE_128FS;
-                break;
-        }
+	u32 mclk_conf, oversample = i2s_config->mclk / i2s_config->sfreq;
+        u32 n, cts, src, layout;
+        u8 cc;
+
+	switch (oversample) {
+	case 768:
+		mclk_conf = 4;
+		break;
+	case 192:
+		mclk_conf = 5;
+		break;
+	case 64:
+		mclk_conf = 6;
+		break;
+	case 32:
+		mclk_conf = 7;
+		break;
+	default:
+		mclk_conf = oversample / 128 - 1;
+		break;
+	}
 
         /* n = 128 * fs / 1000, cts = fp / 1000 */
         switch (i2s_config->sfreq) {
-        case AUDIO_SF_8000:
-                n	= 128 * 8000 / 1000;
+        case 8000:
+        case 11025:
+        case 12000:
+        case 16000:
+        case 22050:
+        case 24000:
+                n	= 128 * i2s_config->sfreq / 1000;
                 cts	= pixel_clock;
                 break;
 
-        case AUDIO_SF_11025:
-                n	= 128 * 11025 / 1000;
-                cts	= pixel_clock;
-                break;
-
-        case AUDIO_SF_12000:
-                n	= 128 * 12000 / 1000;
-                cts	= pixel_clock;
-                break;
-
-        case AUDIO_SF_16000:
-                n	= 128 * 16000 / 1000;
-                cts	= pixel_clock;
-                break;
-
-        case AUDIO_SF_22050:
-                n	= 128 * 22050 / 1000;
-                cts	= pixel_clock;
-                break;
-
-        case AUDIO_SF_24000:
-                n	= 128 * 24000 / 1000;
-                cts	= pixel_clock;
-                break;
-
-        case AUDIO_SF_32000:
+        case 32000:
                 switch (pixel_clock) {
                 case 27000:
                         n	= 4096;
@@ -223,7 +218,7 @@ static void ambhdmi_hdmise_config_audio(struct ambarella_i2s_interface *i2s_conf
                 }
                 break;
 
-        case AUDIO_SF_44100:
+        case 44100:
                 switch (pixel_clock) {
                 case 27000:
                         n	= 6272;
@@ -257,7 +252,7 @@ static void ambhdmi_hdmise_config_audio(struct ambarella_i2s_interface *i2s_conf
                 }
                 break;
 
-        case AUDIO_SF_48000:
+        case 48000:
                 switch (pixel_clock) {
                 case 27000:
                         n	= 6144;
@@ -291,7 +286,7 @@ static void ambhdmi_hdmise_config_audio(struct ambarella_i2s_interface *i2s_conf
                 }
                 break;
 
-        case AUDIO_SF_96000:
+        case 96000:
                 switch (pixel_clock) {
                 case 27000:
                         n	= 12288;
@@ -333,7 +328,7 @@ static void ambhdmi_hdmise_config_audio(struct ambarella_i2s_interface *i2s_conf
         }
 
         /* SRC, LAYOUT */
-        switch (i2s_config->ch) {
+        switch (i2s_config->channels) {
         case 2:
                 src	= HDMI_AUNIT_SRC_I2S0_EN;
                 layout	= HDMI_AUNIT_LAYOUT_LAYOUT0;
@@ -360,101 +355,27 @@ static void ambhdmi_hdmise_config_audio(struct ambarella_i2s_interface *i2s_conf
                 break;
         }
 
-        /* MODE */
-        switch (i2s_config->mode) {
-        case DAI_leftJustified_Mode:
-                mode = HDMI_I2S_MODE_DAI_MODE_LEFT_JUSTIFY;
-                break;
-
-        case DAI_rightJustified_Mode:
-                mode = HDMI_I2S_MODE_DAI_MODE_RIGHT_JUSTIFY;
-                break;
-
-        case DAI_MSBExtend_Mode:
-                mode = HDMI_I2S_MODE_DAI_MODE_MSB_EXT;
-                break;
-
-        case DAI_I2S_Mode:
-                mode = HDMI_I2S_MODE_DAI_MODE_I2S;
-                break;
-
-        default:
-                vout_notice("Incorrect I2S mode!\n");
-                mode = HDMI_I2S_MODE_DAI_MODE_I2S;
-                break;
-        }
-
-        /* ORDER */
-        switch (i2s_config->word_order) {
-        case DAI_MSB_FIRST:
-                order = 0;
-                break;
-
-        case DAI_LSB_FIRST:
-                order = 0x1 << 2;
-                break;
-
-        default:
-                vout_notice("Incorrect MSB/LSB order!\n");
-                order = 0;
-                break;
-        }
-
-        /* LEN, POS */
-        switch (i2s_config->word_len) {
-        case DAI_16bits:
-                len = 16 - 1;
-                pos = 16 - 1;
-                break;
-
-        case DAI_18bits:
-                len = 18 - 1;
-                pos = 18 - 1;
-                break;
-
-        case DAI_20bits:
-                len = 20 - 1;
-                pos = 20 - 1;
-                break;
-
-        case DAI_24bits:
-                len = 24 - 1;
-                pos = 24 - 1;
-                break;
-
-        case DAI_32bits:
-                len = 32 - 1;
-                pos = 32 - 1;
-                break;
-
-        default:
-                vout_notice("Incorrect WLEN!\n");
-                len = 16 - 1;
-                pos = 16 - 1;
-                break;
-        }
-
-        amba_writel(HDMI_AUNIT_MCLK_REG, mclk);
-        amba_writel(HDMI_AUNIT_N_REG, HDMI_AUNIT_N(n));
+        writel_relaxed(mclk_conf, phdmi_sink->regbase + HDMI_AUNIT_MCLK_OFFSET);
+        writel_relaxed(HDMI_AUNIT_N(n), phdmi_sink->regbase + HDMI_AUNIT_N_OFFSET);
 #if 0
-        amba_writel(HDMI_AUNIT_NCTS_CTRL_REG, HDMI_AUNIT_NCTS_CTRL_NCTS_EN |
-                    HDMI_AUNIT_NCTS_CTRL_CTS_SEL_SW_MODE);
-        amba_writel(HDMI_AUNIT_CTS_REG, HDMI_AUNIT_CTS(cts));
+        writel_relaxed(HDMI_AUNIT_NCTS_CTRL_NCTS_EN | HDMI_AUNIT_NCTS_CTRL_CTS_SEL_SW_MODE,
+        	phdmi_sink->regbase + HDMI_AUNIT_NCTS_CTRL_OFFSET);
+        writel_relaxed(HDMI_AUNIT_CTS(cts), phdmi_sink->regbase + HDMI_AUNIT_CTS_OFFSET);
 #else
-        amba_writel(HDMI_AUNIT_NCTS_CTRL_REG, HDMI_AUNIT_NCTS_CTRL_NCTS_EN |
-                    HDMI_AUNIT_NCTS_CTRL_CTS_SEL_HW_MODE);
-        amba_writel(HDMI_AUNIT_CTS_REG, HDMI_AUNIT_CTS(cts));
+        writel_relaxed(HDMI_AUNIT_NCTS_CTRL_NCTS_EN | HDMI_AUNIT_NCTS_CTRL_CTS_SEL_HW_MODE,
+	        phdmi_sink->regbase + HDMI_AUNIT_NCTS_CTRL_OFFSET);
+        writel_relaxed(HDMI_AUNIT_CTS(cts), phdmi_sink->regbase + HDMI_AUNIT_CTS_OFFSET);
 #endif
-        amba_writel(HDMI_AUNIT_SRC_REG,	src);
-        amba_writel(HDMI_AUNIT_LAYOUT_REG, layout);
-        amba_writel(HDMI_I2S_MODE_REG, mode);
-        amba_writel(HDMI_I2S_RX_CTRL_REG, order);
-        amba_writel(HDMI_I2S_WLEN_REG, len);
-        amba_writel(HDMI_I2S_WPOS_REG, pos);
-        amba_writel(HDMI_I2S_SLOT_REG, 0);
-        amba_writel(HDMI_I2S_RX_FIFO_GTH_REG, 3);
-        amba_writel(HDMI_I2S_RX_CLOCK_REG, HDMI_I2S_RX_CLOCK_RX_I2S_CLK_POL(0));
-        amba_writel(HDMI_I2S_GATE_OFF_REG, ~HDMI_I2S_GATE_OFF_RX_GATE_OFF_EN);
+        writel_relaxed(src, phdmi_sink->regbase + HDMI_AUNIT_SRC_OFFSET);
+        writel_relaxed(layout, phdmi_sink->regbase + HDMI_AUNIT_LAYOUT_OFFSET);
+        writel_relaxed(i2s_config->mode, phdmi_sink->regbase + HDMI_I2S_MODE_OFFSET);
+        writel_relaxed(0, phdmi_sink->regbase + HDMI_I2S_RX_CTRL_OFFSET);
+        writel_relaxed(i2s_config->word_len, phdmi_sink->regbase + HDMI_I2S_WLEN_OFFSET);
+        writel_relaxed(i2s_config->word_pos, phdmi_sink->regbase + HDMI_I2S_WPOS_OFFSET);
+        writel_relaxed(0, phdmi_sink->regbase + HDMI_I2S_SLOT_OFFSET);
+        writel_relaxed(3, phdmi_sink->regbase + HDMI_I2S_RX_FIFO_GTH_OFFSET);
+        writel_relaxed(HDMI_I2S_RX_CLOCK_RX_I2S_CLK_POL(0), phdmi_sink->regbase + HDMI_I2S_RX_CLOCK_OFFSET);
+        writel_relaxed(~HDMI_I2S_GATE_OFF_RX_GATE_OFF_EN, phdmi_sink->regbase + HDMI_I2S_GATE_OFF_OFFSET);
 
         /* Audio Info Frame */
         HDMI_PACKETS.audio[0].val	=
@@ -474,12 +395,13 @@ static void ambhdmi_hdmise_config_audio(struct ambarella_i2s_interface *i2s_conf
 /* ========================================================================== */
 static void ambhdmi_hdmise_stop(struct ambhdmi_sink *phdmi_sink)
 {
-        amba_writel(HDMI_OP_MODE_REG, ~HDMI_OP_MODE_OP_EN);
+        writel_relaxed(~HDMI_OP_MODE_OP_EN, phdmi_sink->regbase + HDMI_OP_MODE_OFFSET);
 }
 
 static int ambhdmi_hdmise_audio_transition(struct notifier_block *nb,
                                            unsigned long val, void *data)
 {
+	struct ambhdmi_sink *phdmi_sink;
         struct ambarella_i2s_interface *i2s_config = data;
         u32 state;
         u32 _val, _hdmise_en;
@@ -487,45 +409,41 @@ static int ambhdmi_hdmise_audio_transition(struct notifier_block *nb,
         if (val != AUDIO_NOTIFY_SETHWPARAMS)
                 return 0;
 
-        state = amba_readl(HDMI_OP_MODE_REG);
+	phdmi_sink = container_of(nb, struct ambhdmi_sink, audio_transition);
+
+        state = readl_relaxed(phdmi_sink->regbase + HDMI_OP_MODE_OFFSET);
         if (!(state & HDMI_OP_MODE_OP_EN))
                 return 0;
 
         /* Enable HDMISE Clock */
-        _val = amba_readl(HDMI_CLOCK_GATED_REG);
+        _val = readl_relaxed(phdmi_sink->regbase + HDMI_CLOCK_GATED_OFFSET);
         _hdmise_en = _val & HDMI_CLOCK_GATED_HDMISE_CLOCK_EN;
         if (!_hdmise_en) {
                 _val |= HDMI_CLOCK_GATED_HDMISE_CLOCK_EN;
-                amba_writel(HDMI_CLOCK_GATED_REG, _val);
+                writel_relaxed(_val, phdmi_sink->regbase + HDMI_CLOCK_GATED_OFFSET);
         }
 
         mdelay(100);
-        if (!(amba_readl(HDMI_I2S_INIT_REG) & 0x2)) {
-                //amba_writel(HDMI_I2S_INIT_REG, HDMI_I2S_INIT_DAI_RESET(1));
-                amba_writel(HDMI_I2S_INIT_REG, HDMI_I2S_INIT_RX_ENABLE);
+        if (!(readl_relaxed(phdmi_sink->regbase + HDMI_I2S_INIT_OFFSET) & 0x2)) {
+                //writel_relaxed(HDMI_I2S_INIT_DAI_RESET(1), phdmi_sink->regbase + HDMI_I2S_INIT_OFFSET);
+                writel_relaxed(HDMI_I2S_INIT_RX_ENABLE, phdmi_sink->regbase + HDMI_I2S_INIT_OFFSET);
                 mdelay(100);
         }
 
-        ambhdmi_hdmise_config_audio(i2s_config);
-        ambhdmi_hdmise_flush_packets();
-        amba_writel(HDMI_PACKET_TX_CTRL_REG,
-                    HDMI_PACKET_TX_CTRL_BUF_SWITCH_EN |
-                    HDMI_PACKET_TX_CTRL_AUD_RPT |
-                    HDMI_PACKET_TX_CTRL_AUD_EN |
-                    HDMI_PACKET_TX_CTRL_AVI_RPT |
-                    HDMI_PACKET_TX_CTRL_AVI_EN |
-                    HDMI_PACKET_TX_CTRL_GEN_RPT |
-                    HDMI_PACKET_TX_CTRL_GEN_EN |
-                    HDMI_PACKET_TX_CTRL_VS_RPT |
-                    HDMI_PACKET_TX_CTRL_VS_EN
-                   );
-
+        ambhdmi_hdmise_config_audio(phdmi_sink, i2s_config);
+        ambhdmi_hdmise_flush_packets(phdmi_sink);
+        writel_relaxed(HDMI_PACKET_TX_CTRL_BUF_SWITCH_EN | HDMI_PACKET_TX_CTRL_AUD_RPT |
+                    HDMI_PACKET_TX_CTRL_AUD_EN | HDMI_PACKET_TX_CTRL_AVI_RPT |
+                    HDMI_PACKET_TX_CTRL_AVI_EN | HDMI_PACKET_TX_CTRL_GEN_RPT |
+                    HDMI_PACKET_TX_CTRL_GEN_EN | HDMI_PACKET_TX_CTRL_VS_RPT |
+                    HDMI_PACKET_TX_CTRL_VS_EN,
+                    phdmi_sink->regbase + HDMI_PACKET_TX_CTRL_OFFSET);
 
         /* Clock Gating */
         if (!_hdmise_en) {
-                _val = amba_readl(HDMI_CLOCK_GATED_REG);
+                _val = readl_relaxed(phdmi_sink->regbase + HDMI_CLOCK_GATED_OFFSET);
                 _val &= ~HDMI_CLOCK_GATED_HDMISE_CLOCK_EN;
-                amba_writel(HDMI_CLOCK_GATED_REG, _val);
+                writel_relaxed(_val, phdmi_sink->regbase + HDMI_CLOCK_GATED_OFFSET);
         }
 
         return 0;
@@ -541,103 +459,95 @@ static void ambhdmi_hdmise_set(struct ambhdmi_sink *phdmi_sink,
         u8				cs, vic, pr, ar, overscan;// cm;
 
         /* Use HDCP & EESS */
-        amba_writel(HDMI_EESS_CTL_REG, HDMI_HDCPCE_CTL_USE_EESS(1) |
-                    HDMI_HDCPCE_CTL_HDCPCE_EN);
+        writel_relaxed(HDMI_HDCPCE_CTL_USE_EESS(1) | HDMI_HDCPCE_CTL_HDCPCE_EN,
+        	phdmi_sink->regbase + HDMI_EESS_CTL_OFFSET);
 
         /*PHY*/
-        amba_writel(HDMI_PHY_CTRL_REG, 0);
+        writel_relaxed(0, phdmi_sink->regbase + HDMI_PHY_CTRL_OFFSET);
         if (vt->pixel_clock >= 148352 && vt->pixel_clock <= 148500) {
-                amba_writel(HDMI_PHY_CTRL_REG,
-                            HDMI_PHY_CTRL_HDMI_PHY_ACTIVE_MODE |
+                writel_relaxed(HDMI_PHY_CTRL_HDMI_PHY_ACTIVE_MODE |
                             HDMI_PHY_CTRL_NON_RESET_HDMI_PHY |
                             HDMI_PHY_CTRL_10_PRE_EMPHASIS |
-                            HDMI_PHY_CTRL_1P2_MA_SINK_CURRENT
-                           );
+                            HDMI_PHY_CTRL_1P2_MA_SINK_CURRENT,
+                            phdmi_sink->regbase + HDMI_PHY_CTRL_OFFSET);
         } else {
-                amba_writel(HDMI_PHY_CTRL_REG,
-                            HDMI_PHY_CTRL_HDMI_PHY_ACTIVE_MODE |
-                            HDMI_PHY_CTRL_NON_RESET_HDMI_PHY
-                           );
+                writel_relaxed(HDMI_PHY_CTRL_HDMI_PHY_ACTIVE_MODE |
+                            HDMI_PHY_CTRL_NON_RESET_HDMI_PHY,
+                            phdmi_sink->regbase + HDMI_PHY_CTRL_OFFSET);
         }
 
         /*AFIFO*/
-        amba_writel(HDMI_P2P_AFIFO_LEVEL_REG,
-                    HDMI_P2P_AFIFO_LEVEL_UPPER_BOUND(12) |
+        writel_relaxed(HDMI_P2P_AFIFO_LEVEL_UPPER_BOUND(12) |
                     HDMI_P2P_AFIFO_LEVEL_UPPER_BOUND(4) |
                     HDMI_P2P_AFIFO_LEVEL_MAX_USAGE_LEVEL(7)	|
                     HDMI_P2P_AFIFO_LEVEL_MIN_USAGE_LEVEL(7) |
-                    HDMI_P2P_AFIFO_LEVEL_CURRENT_USAGE_LEVEL(7)
-                   );
-        amba_writel(HDMI_P2P_AFIFO_CTRL_REG, HDMI_P2P_AFIFO_CTRL_EN);
+                    HDMI_P2P_AFIFO_LEVEL_CURRENT_USAGE_LEVEL(7),
+                    phdmi_sink->regbase + HDMI_P2P_AFIFO_LEVEL_OFFSET);
+        writel_relaxed(HDMI_P2P_AFIFO_CTRL_EN, phdmi_sink->regbase + HDMI_P2P_AFIFO_CTRL_OFFSET);
 
         /*Video*/
 #if (VOUT_HDMI_REGS_OFFSET_GROUP == 3)
-        amba_writel(HDMI_VUNIT_VBLANK_VFRONT_REG, vt->vsync_offset);
-        amba_writel(HDMI_VUNIT_VBLANK_PULSE_WIDTH_REG, vt->vsync_width);
-        amba_writel(HDMI_VUNIT_VBLANK_VBACK_REG,
-                    vt->v_blanking - vt->vsync_offset - vt->vsync_width);
+        writel_relaxed(vt->vsync_offset, phdmi_sink->regbase + HDMI_VUNIT_VBLANK_VFRONT_OFFSET);
+        writel_relaxed(vt->vsync_width, phdmi_sink->regbase + HDMI_VUNIT_VBLANK_PULSE_WIDTH_OFFSET);
+        writel_relaxed(vt->v_blanking - vt->vsync_offset - vt->vsync_width,
+		phdmi_sink->regbase + HDMI_VUNIT_VBLANK_VBACK_OFFSET);
 
         if (ddd_structure == DDD_SIDE_BY_SIDE_FULL) {
-                amba_writel(HDMI_VUNIT_HBLANK_HFRONT_REG, vt->hsync_offset * 2);
-                amba_writel(HDMI_VUNIT_HBLANK_PULSE_WIDTH_REG, vt->hsync_width * 2);
-                amba_writel(HDMI_VUNIT_HBLANK_HBACK_REG,
-                            vt->h_blanking * 2 - vt->hsync_offset * 2 - vt->hsync_width * 2);
+                writel_relaxed(vt->hsync_offset * 2, phdmi_sink->regbase + HDMI_VUNIT_HBLANK_HFRONT_OFFSET);
+                writel_relaxed(vt->hsync_width * 2, phdmi_sink->regbase + HDMI_VUNIT_HBLANK_PULSE_WIDTH_OFFSET);
+                writel_relaxed(vt->h_blanking * 2 - vt->hsync_offset * 2 - vt->hsync_width * 2,
+			phdmi_sink->regbase + HDMI_VUNIT_HBLANK_HBACK_OFFSET);
         } else {
-                amba_writel(HDMI_VUNIT_HBLANK_HFRONT_REG, vt->hsync_offset);
-                amba_writel(HDMI_VUNIT_HBLANK_PULSE_WIDTH_REG, vt->hsync_width);
-                amba_writel(HDMI_VUNIT_HBLANK_HBACK_REG,
-                            vt->h_blanking - vt->hsync_offset - vt->hsync_width);
+                writel_relaxed(vt->hsync_offset, phdmi_sink->regbase + HDMI_VUNIT_HBLANK_HFRONT_OFFSET);
+                writel_relaxed(vt->hsync_width, phdmi_sink->regbase + HDMI_VUNIT_HBLANK_PULSE_WIDTH_OFFSET);
+                writel_relaxed(vt->h_blanking - vt->hsync_offset - vt->hsync_width,
+			phdmi_sink->regbase + HDMI_VUNIT_HBLANK_HBACK_OFFSET);
         }
 #else
-        amba_writel(HDMI_VUNIT_VBLANK_REG,
-                    HDMI_VUNIT_VBLANK_LEFT_OFFSET(vt->vsync_offset) |
+        writel_relaxed(HDMI_VUNIT_VBLANK_LEFT_OFFSET(vt->vsync_offset) |
                     HDMI_VUNIT_VBLANK_PULSE_WIDTH(vt->vsync_width) |
-                    HDMI_VUNIT_VBLANK_RIGHT_OFFSET(vt->v_blanking -
-                                                   vt->vsync_offset - vt->vsync_width)
-                   );
+                    HDMI_VUNIT_VBLANK_RIGHT_OFFSET(vt->v_blanking - vt->vsync_offset - vt->vsync_width),
+                    phdmi_sink->regbase + HDMI_VUNIT_VBLANK_OFFSET);
 
-        amba_writel(HDMI_VUNIT_HBLANK_REG,
-                    HDMI_VUNIT_HBLANK_LEFT_OFFSET(vt->hsync_offset) |
+        writel_relaxed(HDMI_VUNIT_HBLANK_LEFT_OFFSET(vt->hsync_offset) |
                     HDMI_VUNIT_HBLANK_PULSE_WIDTH(vt->hsync_width) |
-                    HDMI_VUNIT_HBLANK_RIGHT_OFFSET(vt->h_blanking -
-                                                   vt->hsync_offset - vt->hsync_width)
-                   );
+                    HDMI_VUNIT_HBLANK_RIGHT_OFFSET(vt->h_blanking - vt->hsync_offset - vt->hsync_width),
+                    phdmi_sink->regbase + HDMI_VUNIT_HBLANK_OFFSET);
 #endif
 
         if (ddd_structure == DDD_FRAME_PACKING) {
-                amba_writel(HDMI_VUNIT_VACTIVE_REG,
-                            vt->v_active * 2 + vt->v_blanking);
+                writel_relaxed(vt->v_active * 2 + vt->v_blanking,
+			phdmi_sink->regbase + HDMI_VUNIT_VACTIVE_OFFSET);
         } else {
-                amba_writel(HDMI_VUNIT_VACTIVE_REG, vt->v_active);
+                writel_relaxed(vt->v_active, phdmi_sink->regbase + HDMI_VUNIT_VACTIVE_OFFSET);
         }
         if (ddd_structure == DDD_SIDE_BY_SIDE_FULL) {
-                amba_writel(HDMI_VUNIT_HACTIVE_REG, vt->h_active * 2);
+                writel_relaxed(vt->h_active * 2, phdmi_sink->regbase + HDMI_VUNIT_HACTIVE_OFFSET);
         } else {
-                amba_writel(HDMI_VUNIT_HACTIVE_REG, vt->h_active);
+                writel_relaxed(vt->h_active, phdmi_sink->regbase + HDMI_VUNIT_HACTIVE_OFFSET);
         }
-        amba_writel(HDMI_VUNIT_CTRL_REG,
-                    HDMI_VUNIT_CTRL_VIDEO_MODE(vt->interlace) |
+        writel_relaxed(HDMI_VUNIT_CTRL_VIDEO_MODE(vt->interlace) |
                     HDMI_VUNIT_CTRL_HSYNC_POL(~vt->hsync_polarity) |
-                    HDMI_VUNIT_CTRL_VSYNC_POL(~vt->vsync_polarity)
-                   );
-        amba_writel(HDMI_VUNIT_VSYNC_DETECT_REG, HDMI_VUNIT_VSYNC_DETECT_EN);
+                    HDMI_VUNIT_CTRL_VSYNC_POL(~vt->vsync_polarity),
+                    phdmi_sink->regbase + HDMI_VUNIT_CTRL_OFFSET);
+        writel_relaxed(HDMI_VUNIT_VSYNC_DETECT_EN, phdmi_sink->regbase + HDMI_VUNIT_VSYNC_DETECT_OFFSET);
 
         /*Audio*/
         pixel_clock = vt->pixel_clock;
         i2s_config = get_audio_i2s_interface();
-        ambhdmi_hdmise_config_audio(&i2s_config);
+        ambhdmi_hdmise_config_audio(phdmi_sink, &i2s_config);
 
         cts = vt->pixel_clock;
-        amba_writel(HDMI_AUNIT_CTS_REG, HDMI_AUNIT_CTS(cts));
+        writel_relaxed(HDMI_AUNIT_CTS(cts), phdmi_sink->regbase + HDMI_AUNIT_CTS_OFFSET);
 
         if (phdmi_sink->edid.interface != HDMI)
-                amba_writel(HDMI_I2S_GATE_OFF_REG,
-                            HDMI_I2S_GATE_OFF_RX_GATE_OFF_EN);
+                writel_relaxed(HDMI_I2S_GATE_OFF_RX_GATE_OFF_EN,
+                	phdmi_sink->regbase + HDMI_I2S_GATE_OFF_OFFSET);
 
         /*Misc Packet*/
-        amba_writel(HDMI_PACKET_GENERAL_CTRL_REG,
-                    HDMI_PACKET_GENERAL_CTRL_CLR_AVMUTE_EN);
-        amba_writel(HDMI_PACKET_MISC_REG, 0);
+        writel_relaxed(HDMI_PACKET_GENERAL_CTRL_CLR_AVMUTE_EN,
+        	phdmi_sink->regbase + HDMI_PACKET_GENERAL_CTRL_OFFSET);
+        writel_relaxed(0, phdmi_sink->regbase + HDMI_PACKET_MISC_OFFSET);
 
         /* AVI Info Frame */
         switch (_cs) {
@@ -737,11 +647,10 @@ static void ambhdmi_hdmise_set(struct ambhdmi_sink *phdmi_sink,
                         HDMI_PACKET_VS2_VS_PB6(0x00);
         }
 
-        ambhdmi_hdmise_flush_packets();
+        ambhdmi_hdmise_flush_packets(phdmi_sink);
 
         if (phdmi_sink->edid.interface == HDMI) {
-                amba_writel(HDMI_PACKET_TX_CTRL_REG,
-                            HDMI_PACKET_TX_CTRL_BUF_SWITCH_EN |
+                writel_relaxed(HDMI_PACKET_TX_CTRL_BUF_SWITCH_EN |
                             HDMI_PACKET_TX_CTRL_AUD_RPT |
                             HDMI_PACKET_TX_CTRL_AUD_EN |
                             HDMI_PACKET_TX_CTRL_AVI_RPT |
@@ -749,29 +658,28 @@ static void ambhdmi_hdmise_set(struct ambhdmi_sink *phdmi_sink,
                             HDMI_PACKET_TX_CTRL_GEN_RPT |
                             HDMI_PACKET_TX_CTRL_GEN_EN |
                             HDMI_PACKET_TX_CTRL_VS_RPT |
-                            HDMI_PACKET_TX_CTRL_VS_EN
-                           );
+                            HDMI_PACKET_TX_CTRL_VS_EN,
+                            phdmi_sink->regbase + HDMI_PACKET_TX_CTRL_OFFSET);
         } else {
-                amba_writel(HDMI_PACKET_TX_CTRL_REG,
-                            HDMI_PACKET_TX_CTRL_BUF_SWITCH_EN |
+                writel_relaxed(HDMI_PACKET_TX_CTRL_BUF_SWITCH_EN |
                             HDMI_PACKET_TX_CTRL_AVI_RPT |
                             HDMI_PACKET_TX_CTRL_AVI_EN |
                             HDMI_PACKET_TX_CTRL_GEN_RPT |
                             HDMI_PACKET_TX_CTRL_GEN_EN |
                             HDMI_PACKET_TX_CTRL_VS_RPT |
-                            HDMI_PACKET_TX_CTRL_VS_EN
-                           );
+                            HDMI_PACKET_TX_CTRL_VS_EN,
+                            phdmi_sink->regbase + HDMI_PACKET_TX_CTRL_OFFSET);
         }
 
         /*Test*/
-        amba_writel(HDMI_HDMISE_TM_REG, 0);
+        writel_relaxed(0, phdmi_sink->regbase + HDMI_HDMISE_TM_OFFSET);
 }
 
 static void ambhdmi_hdmise_run(struct ambhdmi_sink *phdmi_sink)
 {
         u32			mode;
 
-        vout_notice("%s: %d @ 0x%x!\n", __func__,
+        vout_notice("%s: %d @ 0x%p!\n", __func__,
                     phdmi_sink->edid.interface, phdmi_sink->regbase);
 
         if (phdmi_sink->edid.interface == HDMI) {
@@ -780,7 +688,7 @@ static void ambhdmi_hdmise_run(struct ambhdmi_sink *phdmi_sink)
                 mode = HDMI_OP_MODE_OP_MODE_DVI | HDMI_OP_MODE_OP_EN;
         }
 
-        amba_writel(HDMI_OP_MODE_REG, mode);
+        writel_relaxed(mode, phdmi_sink->regbase + HDMI_OP_MODE_OFFSET);
 }
 
 static void ambhdmi_hdmise_init(struct ambhdmi_sink *phdmi_sink,
@@ -791,31 +699,30 @@ static void ambhdmi_hdmise_init(struct ambhdmi_sink *phdmi_sink,
         u32 val;
 
         /* Soft Reset HDMISE */
-        amba_writel(HDMI_HDMISE_SOFT_RESET_REG,	HDMI_HDMISE_SOFT_RESET);
-        amba_writel(HDMI_HDMISE_SOFT_RESET_REG,	~HDMI_HDMISE_SOFT_RESET);
+        writel_relaxed(HDMI_HDMISE_SOFT_RESET, phdmi_sink->regbase + HDMI_HDMISE_SOFT_RESET_OFFSET);
+        writel_relaxed(~HDMI_HDMISE_SOFT_RESET, phdmi_sink->regbase + HDMI_HDMISE_SOFT_RESET_OFFSET);
 
         /* Reset CEC */
-        amba_writel(CEC_CTRL_REG, 0x1 << 31);
+        writel_relaxed(0x1 << 31, phdmi_sink->regbase + CEC_CTRL_OFFSET);
 
         /* Clock Gating */
-        amba_writel(HDMI_CLOCK_GATED_REG, 0);
+        writel_relaxed(0, phdmi_sink->regbase + HDMI_CLOCK_GATED_OFFSET);
 
         /* Enable Hotplug detect and loss interrupt */
-        amba_writel(HDMI_INT_ENABLE_REG,
-                    HDMI_INT_ENABLE_PHY_RX_SENSE_REMOVE_EN |
+        writel_relaxed(HDMI_INT_ENABLE_PHY_RX_SENSE_REMOVE_EN |
                     HDMI_INT_ENABLE_PHY_RX_SENSE_EN |
                     HDMI_INT_ENABLE_HOT_PLUG_LOSS_EN |
-                    HDMI_INT_ENABLE_HOT_PLUG_DETECT_EN
-                   );
+                    HDMI_INT_ENABLE_HOT_PLUG_DETECT_EN,
+                    phdmi_sink->regbase + HDMI_INT_ENABLE_OFFSET  );
 
         msleep(10);
 
         disable_irq(phdmi_sink->irq);
 
         /* Enable HDMISE Clock */
-        val = amba_readl(HDMI_CLOCK_GATED_REG);
+        val = readl_relaxed(phdmi_sink->regbase + HDMI_CLOCK_GATED_OFFSET);
         val |= HDMI_CLOCK_GATED_HDMISE_CLOCK_EN;
-        amba_writel(HDMI_CLOCK_GATED_REG, val);
+        writel_relaxed(val, phdmi_sink->regbase + HDMI_CLOCK_GATED_OFFSET);
 
         ambhdmi_hdmise_stop(phdmi_sink);
         ambhdmi_hdmise_set(phdmi_sink, cs, ddd_structure, overscan, vt);
@@ -823,9 +730,9 @@ static void ambhdmi_hdmise_init(struct ambhdmi_sink *phdmi_sink,
 
         /* Clock Gating */
         if (phdmi_sink->video_sink.hdmi_plug == AMBA_VOUT_SINK_REMOVED) {
-                val = amba_readl(HDMI_CLOCK_GATED_REG);
+                val = readl_relaxed(phdmi_sink->regbase + HDMI_CLOCK_GATED_OFFSET);
                 val &= ~HDMI_CLOCK_GATED_HDMISE_CLOCK_EN;
-                amba_writel(HDMI_CLOCK_GATED_REG, val);
+                writel_relaxed(val, phdmi_sink->regbase + HDMI_CLOCK_GATED_OFFSET);
         }
 
         enable_irq(phdmi_sink->irq);
diff --git a/drivers/vout/hdmi/amb_hdmi/make.inc b/drivers/vout/hdmi/amb_hdmi/make.inc
index 377a64c..c5f3884 100644
--- a/drivers/vout/hdmi/amb_hdmi/make.inc
+++ b/drivers/vout/hdmi/amb_hdmi/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/05 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifneq ($(CONFIG_HDMI_NULL), y)
diff --git a/drivers/vout/it66121/AmbaConfig b/drivers/vout/it66121/AmbaConfig
index 8a7255b..560dc91 100644
--- a/drivers/vout/it66121/AmbaConfig
+++ b/drivers/vout/it66121/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/01/8 - [Johnson Diao] Create
 ##
-## Copyright (C) 2013-2020, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 config BUILD_AMBARELLA_IT66121_HDMI
diff --git a/drivers/vout/it66121/it66121/Kbuild b/drivers/vout/it66121/it66121/Kbuild
index 752e65f..c0e374a 100644
--- a/drivers/vout/it66121/it66121/Kbuild
+++ b/drivers/vout/it66121/it66121/Kbuild
@@ -3,12 +3,29 @@
 ##
 ## Author: Anthony Ginger <hfjiang@ambarella.com>
 ##
-## Copyright (C) 2004-2010, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS) -I$(AMB_TOPDIR)/kernel/private/drivers/vout
diff --git a/drivers/vout/it66121/it66121/it66121.c b/drivers/vout/it66121/it66121/it66121.c
index ff7078e..24bcf0b 100644
--- a/drivers/vout/it66121/it66121/it66121.c
+++ b/drivers/vout/it66121/it66121/it66121.c
@@ -4,14 +4,33 @@
  * History:
  *	2013/01/08 - [Johnson Diao]
  *
- * Copyright (C) 2013-2020, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
+
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
diff --git a/drivers/vout/it66121/it66121/it66121.h b/drivers/vout/it66121/it66121/it66121.h
index 8f0003d..f9bb324 100644
--- a/drivers/vout/it66121/it66121/it66121.h
+++ b/drivers/vout/it66121/it66121/it66121.h
@@ -1,3 +1,34 @@
+/*
+ * kernel/private/drivers/vout/it66121/it66121.h
+ *
+ * History:
+ *      2013/01/08 - [Johnson Diao]
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 //#define HDMITX_DEBUG_PRINTF(x) printk x
 #define HDMITX_DEBUG_PRINTF(x)
diff --git a/drivers/vout/it66121/it66121/make.inc b/drivers/vout/it66121/it66121/make.inc
index 9938463..2cf6d89 100644
--- a/drivers/vout/it66121/it66121/make.inc
+++ b/drivers/vout/it66121/it66121/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/05 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_IT66121_HDMI), y)
diff --git a/drivers/vout/make.inc b/drivers/vout/make.inc
index 0a30951..abd3f74 100644
--- a/drivers/vout/make.inc
+++ b/drivers/vout/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/05 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_VOUT), y)
diff --git a/drivers/vout/vout_core.c b/drivers/vout/vout_core.c
index 27947bd..afe9f17 100644
--- a/drivers/vout/vout_core.c
+++ b/drivers/vout/vout_core.c
@@ -4,15 +4,34 @@
  * History:
  *    2008/01/18 - [Anthony Ginger] Create
  *
- * Copyright (C) 2004-2008, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #include <linux/idr.h>
 #include <linux/i2c.h>
 #include <plat/event.h>
diff --git a/drivers/vout/vout_pri.h b/drivers/vout/vout_pri.h
index 4a4fb12..9fc589c 100644
--- a/drivers/vout/vout_pri.h
+++ b/drivers/vout/vout_pri.h
@@ -4,15 +4,34 @@
  * History:
  *    2008/01/18 - [Anthony Ginger] Create
  *
- * Copyright (C) 2004-2008, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #ifndef __VOUT_PRI_H
 #define __VOUT_PRI_H
 
@@ -122,14 +141,6 @@
                 vout_printk(KERN_DEBUG , "Vout debug: " format , ## arg)
 #endif
 
-#if 1
-#define vout_dbgv(format, arg...)
-#else
-#define vout_dbgv(format, arg...)		\
-	if (ambarella_debug_level & AMBA_DEBUG_VOUT)	\
-		vout_printk(KERN_DEBUG , "Vout debug: " format , ## arg)
-#endif
-
 #if defined(CONFIG_AMBARELLA_VOUT_DEBUG)
 #define vout_dump_buffer(buffer_ptr, buffer_size)	\
 	do { \
diff --git a/include/ambas_stream_texture.h b/include/ambas_stream_texture.h
index 23c5ed9..01f7c4c 100644
--- a/include/ambas_stream_texture.h
+++ b/include/ambas_stream_texture.h
@@ -4,15 +4,34 @@
  * History:
  *    2011/01/05 - [Zhenwu Xue] Create
  *
- * Copyright (C) 2004-2012, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #ifndef __AMBAS_STREAM_TEXTURE_H
 #define __AMBAS_STREAM_TEXTURE_H
 
diff --git a/include/arch_s2l/amba_arch_mem.h b/include/arch_s2l/amba_arch_mem.h
index 266bf73..4eb3e03 100644
--- a/include/arch_s2l/amba_arch_mem.h
+++ b/include/arch_s2l/amba_arch_mem.h
@@ -4,15 +4,34 @@
  * History:
  *	2014/08/21 - [Jian Tang] created file
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #ifndef __AMBA_ARCH_MEM_H__
 #define __AMBA_ARCH_MEM_H__
 
@@ -65,12 +84,26 @@
  * Normally below condition should be satisfied.
  * IAV_MARGIN_SIZE + IAV_DRAM_IMG + IAV_DRAM_BSB >= IAV_DRAM_MAX
  */
-#ifdef CONFIG_AMBARELLA_IAV_QP_OFFSET_IPB
-#define IAV_MARGIN_SIZE		((18 << 20) + IAV_MEM_USR_SIZE)
+#ifdef CONFIG_AMBARELLA_IAV_DRAM_DECODE_ONLY
+
+#define IAV_MARGIN_SIZE		0
+
+#elif defined CONFIG_AMBARELLA_IAV_DRAM_VOUT_ONLY
+
+#define IAV_MARGIN_SIZE		((6 << 20) + IAV_MEM_USR_SIZE)
+
 #else
-#define IAV_MARGIN_SIZE		((11 << 20) + IAV_MEM_USR_SIZE)
+
+#ifdef CONFIG_AMBARELLA_IAV_ROI_IPB
+#define IAV_MARGIN_SIZE		((18 << 20) + IAV_MEM_USR_SIZE + IAV_MEM_MV_SIZE + IAV_MEM_VCA_SIZE)
+#else
+#define IAV_MARGIN_SIZE		((11 << 20) + IAV_MEM_USR_SIZE + IAV_MEM_MV_SIZE + IAV_MEM_VCA_SIZE)
+#endif
+
 #endif
 
+#ifndef CONFIG_AMBARELLA_IAV_DRAM_DECODE_ONLY
+
 #ifdef CONFIG_IMGPROC_MEM_LARGE
 
 #define DSP_IMGRSVD_SIZE		(64 << 20)
@@ -91,12 +124,30 @@
 
 #endif	// CONFIG_IMGPROC_MEM_LARGE
 
+#else
+
+#define DSP_IMGRSVD_SIZE		0
+#undef DSP_IAVRSVD_SIZE
+#define DSP_IAVRSVD_SIZE		0
+
+#endif
+
 
 #define DSP_UCODE_SIZE			(4 << 20)
+
+#ifdef CONFIG_AMBARELLA_DSP_LOG_SIZE
+#define DSP_LOG_SIZE 	CONFIG_AMBARELLA_DSP_LOG_SIZE
+#else
 #define DSP_LOG_SIZE			(128 << 10)
-#define DSP_BSH_SIZE			(16 << 10)
+#endif
+
+#define DSP_BS_UNIT_SIZE		(64)
+#define DSP_BS_NUM				(256)	/* User can modify this */
+#define DSP_BSH_SIZE			(DSP_BS_UNIT_SIZE * DSP_BS_NUM)
+
 #define DSP_MSG_BUF_SIZE		(4 << 10)	/* MSG size is 256 bytes, total is 16 MSG. */
 #define DSP_CMD_BUF_SIZE		(4 << 10)	/* CMD size is 128 bytes, total is 31 CMD + header. */
+#define DSP_DEF_CMD_BUF_SIZE	(4 << 10)	/* Default CMD size is 128 bytes, total is 31 CMD + header. */
 
 #ifndef DSP_FASTDATA_SIZE
 #define DSP_FASTDATA_SIZE	0
@@ -106,12 +157,17 @@
 #define DSP_FASTAUDIO_SIZE	0
 #endif
 
+#ifndef DSP_BSB_SIZE
+#define DSP_BSB_SIZE	0
+#endif
+
 #define DSP_DRAM_SIZE		(get_ambarella_iavmem_size() - \
 						DSP_UCODE_SIZE - \
 						DSP_LOG_SIZE - \
 						DSP_BSH_SIZE - \
 						DSP_MSG_BUF_SIZE - \
 						DSP_CMD_BUF_SIZE - \
+						DSP_DEF_CMD_BUF_SIZE - \
 						DSP_FASTDATA_SIZE - \
 						DSP_FASTAUDIO_SIZE - \
 						DSP_IAVRSVD_SIZE - \
@@ -122,7 +178,8 @@
 #define DSP_FASTDATA_START		(DSP_IAVRSVD_START + DSP_IAVRSVD_SIZE)
 #define DSP_FASTAUDIO_START		(DSP_FASTDATA_START + DSP_FASTDATA_SIZE)
 #define DSP_DRAM_START			(DSP_FASTAUDIO_START + DSP_FASTAUDIO_SIZE)
-#define DSP_CMD_BUF_START		(DSP_DRAM_START + DSP_DRAM_SIZE)
+#define DSP_DEF_CMD_BUF_START		(DSP_DRAM_START + DSP_DRAM_SIZE)
+#define DSP_CMD_BUF_START		(DSP_DEF_CMD_BUF_START + DSP_DEF_CMD_BUF_SIZE)
 #define DSP_MSG_BUF_START		(DSP_CMD_BUF_START + DSP_CMD_BUF_SIZE)
 #define DSP_BSH_START			(DSP_MSG_BUF_START + DSP_MSG_BUF_SIZE)
 #define DSP_LOG_START			(DSP_BSH_START + DSP_BSH_SIZE)
@@ -145,8 +202,11 @@
  * layout for ucode in memory:
  *
  *       +----------------------+ <--- DSP_UCODE_START
- *       | ORCCODE       (3 MB) |
- *       +----------------------+
+ *       | ORCCODE    (2816 KB) |
+ *       +----------------------+ <--- Use RAM for fast boot 3A which
+ *       | AAA STATS   (256 KB) |	   is not used in ORCCODE
+ *       | (For Pandora 3A)     |
+ *       +----------------------+ <--- DSP_MEMD_MEMORY_OFFSET (3 MB)
  *       | ORCME       (640 KB) |
  *       +----------------------+
  *       | DEFAULT BIN (320 KB) |
@@ -156,22 +216,31 @@
  *       | CHIP ID        (4 B) |
  *       +----------------------+ <--- vdsp_info structure
  *       | VDSP_INFO BIN (1 KB) |
+ *       +----------------------+ <--- dsp init data
+ *       | DSP INIT DATA (128 B)|
+ *       +----------------------+
+ *       | RESERVED      (4 B)  |
  *       +----------------------+
  */
 #define DSP_CODE_MEMORY_OFFSET		(0)
 #define DSP_MEMD_MEMORY_OFFSET		(3 * MB)
 #define DSP_BINARY_DATA_MEMORY_OFFSET	(DSP_MEMD_MEMORY_OFFSET + 640 * KB)
 #define DSP_CHIP_ID_OFFSET			(DSP_BINARY_DATA_MEMORY_OFFSET + (320 + 16) * KB)
+#define DSP_INIT_DATA_OFFSET		(DSP_CHIP_ID_OFFSET + 1 * KB + 4)
 #define DSP_DRAM_CODE_START		(DSP_UCODE_START + DSP_CODE_MEMORY_OFFSET)
+#define UCODE_DSP_INIT_DATA_PTR		(DSP_DRAM_CODE_START + 0x30)
 #define DSP_DRAM_MEMD_START		(DSP_UCODE_START + DSP_MEMD_MEMORY_OFFSET)
 #define DSP_BINARY_DATA_START		(DSP_UCODE_START + DSP_BINARY_DATA_MEMORY_OFFSET)
 #define DSP_CHIP_ID_START			(DSP_UCODE_START + DSP_CHIP_ID_OFFSET)
+#define DSP_INIT_DATA_START			(DSP_UCODE_START + DSP_INIT_DATA_OFFSET)
+
+/* Belong to DSP_MEMD_MEMORY_OFFSET, used in Pandora 3A */
+#define DSP_AAA_STATS_OFFSET		(DSP_MEMD_MEMORY_OFFSET - 256 * KB)
+#define DSP_AAA_STATS_START 		(DSP_UCODE_START + DSP_AAA_STATS_OFFSET)
 
 #define DSP_IDSP_BASE			(get_ambarella_apb_virt() + 0x11801C)
 #define DSP_ORC_BASE			(get_ambarella_apb_virt() + 0x11FF00)
 
-#define DSP_INIT_DATA_BASE		(get_ambarella_ppm_virt() + 0x000F0000)
-
 /*
  * layout for DSP_FASTDATA in memory:
  *
@@ -182,6 +251,10 @@
  *       +-------------------------+ <--- vin_dsp_config structure
  *       | VIN_DSP_CONFIG  (128 B) |
  *       +-------------------------+
+ *       | RESERVED  (1 KB - 260 B)|
+ *       +-------------------------+ <--- FASTBOOT_USER_DATA_OFFSET
+ *       | USER DATA        (3 KB) |
+ *       +-------------------------+
  */
 
 /* store DSP_FASTDATA in amboot, restore it after enter Linux IAV */
diff --git a/include/arch_s2l/amba_arch_vout.h b/include/arch_s2l/amba_arch_vout.h
index 378c3ff..d06bd16 100644
--- a/include/arch_s2l/amba_arch_vout.h
+++ b/include/arch_s2l/amba_arch_vout.h
@@ -4,15 +4,34 @@
  * History:
  *    2009/07/23 - [Zhenwu Xue] Create
  *
- * Copyright (C) 2004-2008, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #ifndef __AMBA_ARCH_VOUT_H
 #define __AMBA_ARCH_VOUT_H
 
diff --git a/include/arch_s2l/amba_imgproc.h b/include/arch_s2l/amba_imgproc.h
index 73e3d47..97fea6f 100644
--- a/include/arch_s2l/amba_imgproc.h
+++ b/include/arch_s2l/amba_imgproc.h
@@ -4,15 +4,34 @@
  * History:
  *    2014/02/17 - [Jian Tang] Create
  *
- * Copyright (C) 2014 -2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #ifndef __AMBA_IMGPROC_H__
 #define __AMBA_IMGPROC_H__
 
@@ -35,7 +54,13 @@ struct iav_imgproc_info {
 
 int amba_imgproc_msg(encode_msg_t *msg, u64 mono_pts);
 int amba_imgproc_cmd(struct iav_imgproc_info *info, unsigned int cmd, unsigned long arg);
-int amba_imgproc_suspend(void);
-int amba_imgproc_resume(int enc_mode, int expo_num);
+
+#ifdef CONFIG_PM
+int amba_imgproc_suspend(int enc_mode);
+int amba_imgproc_resume(int enc_mode, int fast_resume);
+int amba_imgproc_freeze(void);
+int amba_imgproc_thaw(void);
+#endif
+
 #endif	// __AMBA_IMGPROC_H__
 
diff --git a/include/dsp_api.h b/include/dsp_api.h
index ae24d9e..92892c1 100644
--- a/include/dsp_api.h
+++ b/include/dsp_api.h
@@ -4,15 +4,34 @@
  * History:
  *	2015/07/12 - [Jian Tang] created file
  *
- * Copyright (C) 2015-2018, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #ifndef _DSP_API_H
 #define _DSP_API_H
 
@@ -47,12 +66,23 @@ enum {
 	DSP_CMD_TYPE_LAST = DSP_CMD_TYPE_NUM,
 };
 
+enum {
+	DSP_CLK_TYPE_IDSP = 0,
+	DSP_CLK_TYPE_HEVC = 1,
+
+	DSP_CLK_TYPE_NUM,
+	DSP_CLK_TYPE_FIRST = 0,
+	DSP_CLK_TYPE_LAST = DSP_CLK_TYPE_NUM,
+};
+
 struct amb_dsp_cmd {
 	DSP_CMD dsp_cmd;
 	struct list_head head;
 	struct list_head node;
 	u32 cmd_type;
 	u32 flag;
+	u32 keep_latest :1;
+	u32 reserved :31;
 };
 
 struct dsp_device *ambarella_request_dsp(void);
@@ -69,30 +99,36 @@ struct dsp_device {
 	u32 bsb_start;
 	u32 buffer_start;
 	u32 buffer_size;
+	u32 reserved;
 
 	void (*msg_callback[NUM_MSG_CAT])(void *data, DSP_MSG *msg);
 	void *msg_data[NUM_MSG_CAT];
 	void (*enc_callback)(void *data, DSP_MSG *msg);
 	void *enc_data;
 
-	int (*set_op_mode)(struct dsp_device *dsp_dev,
-			u32 op_mode, struct amb_dsp_cmd *cmd);
-	int (*set_enc_sub_mode)(struct dsp_device *dsp_dev,
-			u32 enc_mode, struct amb_dsp_cmd *cmd, u8 force);
+	int (*set_op_mode)(struct dsp_device *dsp_dev, u32 op_mode,
+		struct amb_dsp_cmd *cmd, u32 no_wait);
+	int (*set_enc_sub_mode)(struct dsp_device *dsp_dev, u32 enc_mode,
+		struct amb_dsp_cmd *cmd, u32 no_wait, u8 force);
 
 	struct amb_dsp_cmd *(*get_cmd)(struct dsp_device *dsp_dev, u32 flag);
 	struct amb_dsp_cmd *(*get_multi_cmds)(struct dsp_device *dsp_dev,
 			int num, u32 flag);
 	void (*put_cmd)(struct dsp_device *dsp_dev, struct amb_dsp_cmd *cmd, u32 delay);
+	void (*print_cmd)(void *cmd);
 	void (*release_cmd)(struct dsp_device *dsp_dev, struct amb_dsp_cmd *cmd);
 	void (*set_vcap_port)(struct dsp_device *dsp_dev, u8 enable);
 	int (*get_chip_id)(struct dsp_device *dsp_dev, u32 *dsp_chip_id, u32 *chip);
 	int (*wait_vcap)(struct dsp_device *dsp_dev, u32 count);
 	dsp_init_data_t *(*get_dsp_init_data)(struct dsp_device *dsp_dev);
-	int (*set_audit)(struct dsp_device *dsp_dev, u32 cmd, u32 audit_addr);
-	int (*get_audit)(struct dsp_device *dsp_dev, u32 cmd, u32 audit_addr);
+	int (*set_audit)(struct dsp_device *dsp_dev, u32 cmd, unsigned long audit_addr);
+	int (*get_audit)(struct dsp_device *dsp_dev, u32 cmd, unsigned long audit_addr);
 	int (*suspend)(struct dsp_device *dsp_dev);
 	int (*resume)(struct dsp_device *dsp_dev);
+	int (*freeze)(struct dsp_device *dsp_dev);
+	int (*thaw)(struct dsp_device *dsp_dev);
+	int (*set_clock_state)(u32 clk_type, u32 enable);
+	void (*reset_vin)(void);
  };
 
 #endif	// _DSP_API_H
diff --git a/include/dsp_format.h b/include/dsp_format.h
index 2f6ed63..7640a63 100644
--- a/include/dsp_format.h
+++ b/include/dsp_format.h
@@ -4,15 +4,34 @@
  * History:
  *    2008/08/03 - [Anthony Ginger] Create
  *
- * Copyright (C) 2008-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #ifndef __AMBA_DSP_H
 #define __AMBA_DSP_H
 
diff --git a/include/dsplog_api.h b/include/dsplog_api.h
new file mode 100644
index 0000000..e71f59a
--- /dev/null
+++ b/include/dsplog_api.h
@@ -0,0 +1,43 @@
+/*
+ * kernel/private/include/dsplog_api.h
+ *
+ * History:
+ *    2016/09/23 - [Ming Wen] Create
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+
+#ifndef __DSPLOG_API_H__
+#define __DSPLOG_API_H__
+
+#ifdef CONFIG_PM
+int amba_dsplog_suspend(void);
+int amba_dsplog_resume(void);
+#endif
+
+#endif	// __DSPLOG_API_H__
+
diff --git a/include/iav_devnum.h b/include/iav_devnum.h
index 4158270..04c1b7c 100644
--- a/include/iav_devnum.h
+++ b/include/iav_devnum.h
@@ -4,18 +4,40 @@
  * History:
  *    2012/10/25 - [Cao Rongrong] Create
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
  */
 
+
 #ifndef __IAV_DEV_NUM_H__
 #define __IAV_DEV_NUM_H__
 
-#include <mach/hardware.h>
+#define	AMBA_DEV_MAJOR			(248)
+#define	AMBA_DEV_MINOR_PUBLIC_START	(128)
+#define	AMBA_DEV_MINOR_PUBLIC_END	(240)
 
 #define IAV_DEV_MAJOR		AMBA_DEV_MAJOR
 #define IAV_DEV_MINOR		0
diff --git a/include/iav_utils.h b/include/iav_utils.h
index c9c4556..7763a19 100644
--- a/include/iav_utils.h
+++ b/include/iav_utils.h
@@ -4,9 +4,34 @@
  * History:
  *	2008/1/25 - [Oliver Li] created file
  *
- * Copyright (C) 2007-2012, Ambarella, Inc.
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
  */
 
+
 #ifndef __IAV_UTILS_H__
 #define __IAV_UTILS_H__
 
@@ -17,26 +42,18 @@
 #define KB_ALIGN(addr)		ALIGN(addr, KB)
 #define MB_ALIGN(addr)		ALIGN(addr, MB)
 
+#include <plat/iav_helper.h>
 #define clean_d_cache		ambcache_clean_range
 #define invalidate_d_cache	ambcache_inv_range
 
 /* ARM physical address to DSP address */
-#if defined(CONFIG_PLAT_AMBARELLA_MEM_START_LOW)
-#define PHYS_TO_DSP(addr)	(u32)(addr)
-#else
-#define PHYS_TO_DSP(addr)	(u32)((u32)(addr) & 0x3FFFFFFF)
-#endif
+#define PHYS_TO_DSP(addr)	(unsigned long)(addr)
 #define VIRT_TO_DSP(addr)	PHYS_TO_DSP(virt_to_phys(addr))			// kernel virtual address to DSP address
-#define AMBVIRT_TO_DSP(addr)	PHYS_TO_DSP(ambarella_virt_to_phys((u32)addr))	// ambarella virtual address to DSP address
 
 /* DSP address to ARM physical address */
-#if defined(CONFIG_PLAT_AMBARELLA_MEM_START_LOW)
-#define DSP_TO_PHYS(addr)	(u32)(addr)
-#else
-#define DSP_TO_PHYS(addr)	(u32)((u32)(addr) | 0xC0000000)
-#endif
+
+#define DSP_TO_PHYS(addr)	(unsigned long)(addr)
 #define DSP_TO_VIRT(addr)	phys_to_virt(DSP_TO_PHYS(addr))			// DSP address to kernel virtual address
-#define DSP_TO_AMBVIRT(addr)	ambarella_phys_to_virt(DSP_TO_PHYS((u32)addr))	// DSP address to ambarella virtual address
 
 #ifndef DRV_PRINT
 #ifdef BUILD_AMBARELLA_PRIVATE_DRV_MSG
@@ -55,15 +72,24 @@
 #ifndef CONFIG_AMBARELLA_VIN_DEBUG
 #define vin_debug(format, arg...)
 #else
-#define vin_debug(format, arg...)		\
-	if (ambarella_debug_level & AMBA_DEBUG_VIN)	\
-		DRV_PRINT(KERN_DEBUG "%s(%d): "str, __func__, __LINE__, ##arg)
+#define vin_debug(str, arg...)	iav_debug("VIN: "str, ##arg)
 #endif
 #define vin_printk(str, arg...)	iav_printk(str, ##arg)
 #define vin_error(str, arg...)	iav_error("VIN: "str, ##arg)
 #define vin_warn(str, arg...)	iav_warn("VIN: "str, ##arg)
 #define vin_info(str, arg...)	iav_info("VIN: "str, ##arg)
 
+#include <plat/iav_helper.h>
+static inline u32 ambarella_clk_get_rate(char *name)
+{
+	struct ambsvc_pll pll_svc;
+
+	pll_svc.svc_id = AMBSVC_PLL_GET_RATE;
+	pll_svc.name = name;
+	ambarella_request_service(AMBARELLA_SERVICE_PLL, &pll_svc, NULL);
+
+	return pll_svc.rate;
+}
 
 #endif	// UTIL_H
 
diff --git a/include/msg_print.h b/include/msg_print.h
index ea12c9d..f217409 100644
--- a/include/msg_print.h
+++ b/include/msg_print.h
@@ -1,3 +1,35 @@
+/*
+ * kernel/private/include/msg_print.h
+ *
+ * History:
+ *    2012/05/13 - [Rongrong Cao] Create
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #ifndef __PRINT_PRIVATE_DRV__
 #define __PRINT_PRIVATE_DRV__
 #include <linux/compiler.h>
diff --git a/include/vin_api.h b/include/vin_api.h
index 2c68c19..e98fcfc 100644
--- a/include/vin_api.h
+++ b/include/vin_api.h
@@ -4,15 +4,34 @@
  * History:
  *    2008/01/18 - [Anthony Ginger] Create
  *
- * Copyright (C) 2004-2008, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #ifndef __VIN_PRI_H
 #define __VIN_PRI_H
 
@@ -67,20 +86,12 @@ struct vin_device_config {
 		/* for mipi */
 		struct {
 			u32 lane_number : 8;
-			u32 reserved : 8;
-			u32 lane_mux_0 : 16;
-			u32 lane_mux_1 : 16;
-			u32 lane_mux_2 : 16;
+			u32 bit_rate : 8;
+			u32 data_type : 8;
+			u32 reserved0 : 8;
+			u32 reserved1;
 		} mipi_cfg;
 	};
-	/* for slave sensor */
-	struct {
-		u32 hsync_period;
-		u32 hsync_width : 16;
-		u32 vsync_period : 16;
-		u32 vsync_width : 16;
-		u32 reserved0 : 16;
-	} slave_cfg;
 	/* for hdr sensor */
 	struct {
 		struct {
@@ -92,7 +103,8 @@ struct vin_device_config {
 			u32 max_height : 16;
 		} act_win;
 
-		u32 split_width;
+		u32 split_width : 16;
+		u32 num_splits : 16;
 	} hdr_cfg;
 	/* for capture window */
 	struct {
@@ -155,6 +167,11 @@ struct vin_device {
 	unsigned long priv[0];
 };
 
+struct vin_reg_8_8 {
+	u8 addr;
+	u8 data;
+};
+
 struct vin_reg_16_8 {
 	u16 addr;
 	u8 data;
@@ -177,6 +194,15 @@ struct vin_precise_fps {
 	int pll_idx;
 };
 
+/* for slave sensor */
+struct vin_master_sync {
+	u32 hsync_period;
+	u32 hsync_width : 16;
+	u32 vsync_period : 16;
+	u32 vsync_width : 16;
+	u32 reserved0 : 16;
+};
+
 /* Sync to amboot/include/dsp/s2l_cmd_msg.h */
 struct vin_video_format {
 	u32 video_mode;
@@ -193,6 +219,7 @@ struct vin_video_format {
 	u8 type;
 	u8 bits;
 	u8 ratio;
+	u8 mirror_pattern;
 	u8 bayer_pattern;
 	u8 hdr_mode;
 	u8 readout_mode;
@@ -217,6 +244,8 @@ struct vin_video_format {
 	u16 hdr_short2_offset;
 	u16 hdr_short3_offset;
 	u16 dual_gain_mode;
+	u8 gp_ctrl_used;
+	u8 reserved;
 };
 
 struct vin_ops {
@@ -238,6 +267,8 @@ struct vin_ops {
 	int (*get_dgain_ratio)(struct vin_device *vdev, struct vindev_dgain_ratio *args);
 	int (*set_hold_mode)(struct vin_device *vdev, u32 hold_mode);
 	int (*get_chip_status)(struct vin_device *vdev, struct vindev_chip_status *args);
+	int (*get_aaa_info)(struct vin_device *vdev, struct vindev_aaa_info *args);
+	int (*set_low_light_mode)(struct vin_device *vdev, u32 ll_mode);
 
 	/* WDR control */
 	int (*set_wdr_again_idx_gp)(struct vin_device *vdev, struct vindev_wdr_gp_s *args);
@@ -251,6 +282,8 @@ struct vin_ops {
 
 	int (*wdr_shutter2row)(struct vin_device *vdev, struct vindev_wdr_gp_s *args);
 
+	int (*aaa_compensation)(struct vin_device *vdev, struct vindev_wdr_gp_info *args);
+
 	/* For decoder, run-time report video mode */
 	int (*get_format)(struct vin_device *vdev);
 };
@@ -259,6 +292,8 @@ struct vin_ops {
 void ambarella_vin_mipi_phy_reset(void);
 void ambarella_vin_mipi_phy_enable(u8 lanes);
 int ambarella_set_vin_config(struct vin_device *vdev, struct vin_device_config *cfg);
+int ambarella_set_vin_master_sync(struct vin_device *vdev,
+		struct vin_master_sync *master_cfg, bool by_dbg_bus);
 int ambarella_vin_vsync_delay(struct vin_device *vdev, u32 vsync_delay);
 void ambarella_vin_add_precise_fps(struct vin_device *vdev,
 		struct vin_precise_fps *p_fps, u32 num_p_fps);
diff --git a/include/vin_sensors.h b/include/vin_sensors.h
index 4b55566..84f5b78 100644
--- a/include/vin_sensors.h
+++ b/include/vin_sensors.h
@@ -1,3 +1,35 @@
+/*
+ * kernel/private/include/vin_sensors.h
+ *
+ * History:
+ *    2012/05/13 - [Rongrong Cao] Create
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #ifndef __VIN_SENSORS_H__
 #define __VIN_SENSORS_H__
 
@@ -41,6 +73,8 @@
 #define SENSOR_SYNC_STYLE_SONY_DOL	(4)
 #define SENSOR_SYNC_STYLE_HISPI_PSP	(5)
 #define SENSOR_SYNC_STYLE_INTERLACE	(6)
+#define SENSOR_SYNC_STYLE_FPGA		(7)
+#define SENSOR_SYNC_STYLE_SONY_DOL2	(8)
 
 /* vsync/hsync polarity */
 #define SENSOR_VS_HIGH			(0x1 << 1)
@@ -60,5 +94,34 @@
 #define SENSOR_PARALLEL_SYNC_656	(0)
 #define SENSOR_PARALLEL_SYNC_601	(1)
 
+/* mipi clock bit rate */
+#define SENSOR_MIPI_BIT_RATE_L	(0)
+#define SENSOR_MIPI_BIT_RATE_H	(1)
+
+/* mipi data type */
+#define SENSOR_MIPI_DATA_TYPE_RAW	(0)
+#define SENSOR_MIPI_DATA_TYPE_ALL	(1)
+
+/* shutter and gain setting timing */
+#define SENSOR_SYNC_BIND_SOF	(0)
+#define SENSOR_SYNC_BIND_EOF	(1)
+
+/* parallel embedded sync location */
+#define SENSOR_PARALLEL_SYNC_LOWER_PIX        (0)
+#define SENSOR_PARALLEL_SYNC_UPPER_PIX        (1)
+#define SENSOR_PARALLEL_SYNC_ACROSS_BOTH      (2)
+
+/* parallel data rate */
+#define SENSOR_PARALLEL_DATA_RATE_SDR         (0)
+#define SENSOR_PARALLEL_DATA_RATE_DDR         (1)
+
+/* parallel embedded sync location */
+#define SENSOR_PARALLEL_NONE_A8_MODE          (0)
+#define SENSOR_PARALLEL_A8_MODE               (1)
+
+/* parallel hw specific setting */
+#define SENSOR_PARALLEL_HW_BUB                (0)
+#define SENSOR_PARALLEL_HW_CUSTOM             (1)
+
 #endif
 
diff --git a/include/vout_api.h b/include/vout_api.h
index d9ea033..0bb8ab2 100644
--- a/include/vout_api.h
+++ b/include/vout_api.h
@@ -4,15 +4,34 @@
  * History:
  *    2009/05/13 - [Anthony Ginger] Create
  *
- * Copyright (C) 2004-2008, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #ifndef __VOUT_API_H__
 #define __VOUT_API_H__
 
diff --git a/lib/AmbaConfig b/lib/AmbaConfig
index d11d48a..34714e2 100644
--- a/lib/AmbaConfig
+++ b/lib/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2008/01/16 - [Anthony Ginger] Create
 ##
-## Copyright (C) 2004-2008, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 choice
diff --git a/lib/firmware_s2l/dsp_cmd_msg.h b/lib/firmware_s2l/dsp_cmd_msg.h
index cad4517..c780b23 100644
--- a/lib/firmware_s2l/dsp_cmd_msg.h
+++ b/lib/firmware_s2l/dsp_cmd_msg.h
@@ -5,20 +5,39 @@
  * History:
  *	2012/07/05 - [Jian Tang] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
+
 #ifndef	__CMD__MSG_H__
 #define	__CMD__MSG_H__
 
-#define API_REVISION	"$Rev: 245408 $"
-#define API_REVISION_U32		(245408)
-#define IDSP_REVISION_U32		(244992)
+#define API_REVISION	"$Rev: 275733 $"
+#define API_REVISION_U32		(275733)
+#define IDSP_REVISION_U32		(273030)
 
 #define DSP_IN_LINUX_ENV
 
@@ -58,23 +77,6 @@ typedef enum {
 	DSP_UNKNOWN_MODE	= 0x03
 } dsp_op_mode_t;
 
-typedef struct {
-	u32	frame_num;
-	u32	PTS;
-	u32	start_addr;
-	u32	pic_type	: 3;
-	u32	level_idc	: 3;
-	u32	ref_idc		: 1;
-	u32	pic_struct	: 1;
-	u32	pic_size	: 24;
-	u32	stream_id	: 8;
-	u32 session_id	: 4;
-	u32	res_1		: 20;
-	u32 pjpeg_start_addr;
-	u32 pjpeg_size;
-	u32 hw_pts;
-} BIT_STREAM_HDR;
-
 ///////////////
 
 /* General definitions */
@@ -95,6 +97,7 @@ typedef enum {
 	CAT_VCAP = 0,
 	CAT_ENC = 1,
 	CAT_DEC = 2,
+	CAT_VOUT = 7,
 	CAT_AMB_EXP = 254,
 	CAT_INVALID = 255,
 } DSP_CMD_CAT;
@@ -149,7 +152,8 @@ typedef unsigned long   u_long;
 #define DSP_DEBUG_LEVEL_SETUP		0x0000100D
 #define SYSTEM_PARAMETERS_SETUP		0x0000100E
 #define SYSTEM_IDSP_FREQ_SETUP		0x0000100F
-#define HASH_VERIFICATION               0x00001010
+#define HASH_VERIFICATION		0x00001010
+#define HASH_VERIFICATION_EX		0x00001011
 
 #define MCTF_MV_STAB_SETUP		0x0000200D
 #define SET_SLOW_SHUT_UP_SAMPL_RT   	0x0000200E
@@ -401,6 +405,9 @@ typedef enum{
 	AMBA_CHIP_ID_S2L_88 = 6,
 	AMBA_CHIP_ID_S2L_99 = 7,
 	AMBA_CHIP_ID_S2L_TEST = 8,
+	AMBA_CHIP_ID_S2L_22 = 9,
+	AMBA_CHIP_ID_S2L_33MEX = 10,
+	AMBA_CHIP_ID_S2L_33EX = 11,
 } amba_chip_id_t;
 
 /* DSP CMD/MSG protocol version */
@@ -409,6 +416,13 @@ typedef enum {
 	MPV_FIXED_BUFFER = 1,
 } DSP_MSG_PROTOCOL_VERSION;
 
+/* DSP vout profile field */
+typedef enum {
+	DEFAULT_VOUT_PROFILE = 0,
+	DEFAULT_VOUT0_4M_ROTATE_PROFILE = 1,
+	DEFAULT_VOUT_DISABLE_PROFILE = 2,
+} DSP_VOUT_PROFILE;
+
 /**
  *  DSP_INIT_DATA contains initialization related parameters
  *  passed from ARM to DSP. The location is used to store a
@@ -436,7 +450,9 @@ typedef struct dsp_init_data
 	u32 dsp_log_buf_ptr;
 	u32 prev_cmd_seq_num;
 	u32 cmdmsg_protocol_version;
-	u32 reserved_2[11];
+	u32 vout_profile : 3;
+	u32 dsp_log_size : 29;
+	u32 reserved_3[10];
 }dsp_init_data_t;
 
 // Structure that indicate the vdsp interrupt status
@@ -643,6 +659,10 @@ typedef struct h264_encode_setup_s
 	u32 chroma_format : 1 ;
 	u32 reserved : 7 ;
 	u32 custom_encoder_frame_rate ;
+	u32 mvdump_daddr;
+	u32 mvdump_fifo_limit;
+	u32 mvdump_fifo_unit_sz;
+	u32 mvdump_dpitch;
 }h264_encode_setup_t;
 
 typedef h264_encode_setup_t vid_encode_setup_t;
@@ -822,6 +842,11 @@ typedef	enum {
 	MAX_PREVIEW_TYPE = 4,
 } preview_type_t;
 
+typedef enum {
+    NORMAL_BOOT = 0, /* Normal boot case */
+    FAST_BOOT = 1, /* Fast boot case */
+} boot_mode_t;
+
 typedef struct system_setup_info_s
 {
 	u32 cmd_code;
@@ -841,10 +866,14 @@ typedef struct system_setup_info_s
 	u32 adv_iso_disabled : 1;  /* if set, aliso (mode 4) supports 1-pass + temporal adjust */
 	u32 me0_scale_factor : 2; /* 0 - disabled; 1 - 8x; 2 - 16x */
 	u32 vout_swap : 1; /* 0: prev A uses VOUT0, prev B uses VOUT1 ; 1: prev A uses VOUT1, prev B uses VOUT0 */
-	u32 padding : 5;
+	u32 vin_overflow_protection : 1; /* 0: disabled ; 1: enabled */
+	u32 padding : 4;
 
 	applicaton_mode_t  sub_mode_sel; //0: Camcorder mode (single-stream encoder) 1: DVR mode (multiple-stream encoder)
-	u8  reserved1;     // number of input YUV sources muxed together.
+	boot_mode_t boot_mode : 2; /* boot_mode_t */
+	u8  force_dram_preview : 1; /* mode_flags=5 only. If set, mode 5 IDSP pipeline extends one more frame.  Trade DRAM bandwidth for smem. */
+	u8  force_blend_tile : 1; /* mode_flags=5 only. If set, tile size in blend stage is the same as in c2y + LPF. */
+	u8  reserved1 : 4;
 	u8  lcd_3d;                      // need to support LCD 3D rotation
 	u8  iv_360;       // need to support 360 degree image/video playback.
 	u8  mode_flags; /* determines the IDSP pipeline to run */
@@ -869,6 +898,11 @@ typedef struct dsp_debug_level_setup_s{
 	u8 debug_level;
 	u8 coding_thread_printf_disable_mask;
 	u8 padding;
+	u32 num_dsplog_delay_stop_plus1;  // value of (num_dsplog_delay_stop + 1)
+										// num_dsplog_delay_stop:
+										// -1 - ucode do nothing;
+										//  0 - ucode always write dsplog;
+										//  1 - number of dsplog ucode will write before stop print
 }dsp_debug_level_setup_t;
 
 /**
@@ -2773,7 +2807,8 @@ typedef struct h264_encode_s
 	u8 log2_max_pic_order_cnt_lsb_minus4;
 	u8 sony_avc : 1;
 	u8 gaps_in_frame_num_value_allowed_flag : 1;
-	u8 reserved : 6;
+	u8 custom_bitstream_restriction_cfg : 1; //the SPS bitstreamRestriction syntax will be 0 -- calculated by DSP; 1 -- set by IAV
+	u8 reserved : 5;
 	u16 height_mjpeg_h264_simultaneous;
 
 	u16 width_mjpeg_h264_simultaneous;
@@ -2968,13 +3003,28 @@ typedef struct hash_verfication_s
 	u8 hash_input[8];
 } hash_verification_t;
 
+typedef struct hash_verfication_ex_s
+{
+	u32 cmd_code;
+	u32 reserved; //reserved for future extension like "hash_check_version"
+	u8 hash_input[32];
+} hash_verification_ex_t;
+
 /* use for returning results for command HASH_VERIFICATION */
 typedef struct hash_verification_msg_s
 {
-	u32 msg_code ;
+	u32 msg_code;
 	u8 hash_output[4];
 }hash_verification_msg_t;
 
+/* use for returning results for command HASH_VERIFICATION_EX */
+typedef struct hash_verification_msg_ex_s
+{
+	u32 msg_code;
+	u32 reserved; //reserved for future extension like "hash_check_version"
+	u8 hash_output[4] ;
+}hash_verification_msg_ex_t;
+
 /**
  * Still capture
  */
@@ -4076,6 +4126,7 @@ typedef enum {
 	DSP_STATUS_MSG_EFM_REQ_FB = 0x00000004,
 	DSP_STATUS_MSG_EFM_HANDSHAKE = 0x00000005,
 	DSP_STATUS_MSG_HASH_VERIFICATION  = 0x00000006,
+	DSP_STATUS_MSG_HASH_VERIFICATION_EX  = 0x00000007,
 } DSP_STATUS_MSG_CODE;
 
 typedef struct encode_msg_s
@@ -4088,7 +4139,8 @@ typedef struct encode_msg_s
 	u16 encode_state    :4;
 	u16 capture_state   :4;
 	u16 enc_sync_cmd_update_fail :1;
-	u16 reserved1    :3;
+	u16 vin_capture_state : 2;
+	u16 reserved1    :1;
 	u16 raw_pic_pitch;
 	u16 main_y_pitch;
 	u16 main_me1_pitch;
@@ -4133,6 +4185,8 @@ typedef struct encode_msg_s
 	u32 main_me0_addr;
 	u32 flexible_dram_used;
 	u32 flexible_dram_free;
+	u32 preview_A_y_addr_early;
+	u32 preview_A_uv_addr_early;
 } encode_msg_t;
 
 /*
@@ -4497,14 +4551,34 @@ typedef enum {
 
 typedef enum {
 	OSD_SRC_MAPPED_IN    = 0,
-       OSD_SRC_DIRECT_IN_16 = 1,
+	OSD_SRC_DIRECT_IN_16 = 1,
+	OSD_SRC_DIRECT_IN_32 = 2,
 } osd_src_t;
 
 typedef enum {
-	OSD_MODE_UYV565    = 0,
-	OSD_MODE_AYUV4444  = 1,
-	OSD_MODE_AYUV1555  = 2,
-	OSD_MODE_YUV1555   = 3,
+	/* 16-bit mode */
+	OSD_MODE_VYU565     = 0, /* 5:6:5 (VYU) or (RGB) */
+	OSD_MODE_RGB565     = 0,
+	OSD_MODE_UYV565     = 1, /* 5:6:5 (UYV) or (BGR) */
+	OSD_MODE_BGR565     = 1,
+	OSD_MODE_AYUV4444   = 2, /* 4:4:4:4 (AYUV) */
+	OSD_MODE_RGBA4444   = 3, /* 4:4:4:4 (RGBA) */
+	OSD_MODE_BGRA4444   = 4, /* 4:4:4:4 (BGRA) */
+	OSD_MODE_ABGR4444   = 5, /* 4:4:4:4 (ABGR) */
+	OSD_MODE_ARGB4444   = 6, /* 4:4:4:4 (ARGB) */
+	OSD_MODE_AYUV1555   = 7, /* 1:5:5:5 (AYUV) */
+	OSD_MODE_YUV1555    = 8, /* 1:5:5:5 (MSB ignored, YUV) */
+	OSD_MODE_RGBA5551   = 9, /* 5:5:5:1 (RGBA) */
+	OSD_MODE_BGRA5551   = 10, /* 5:5:5:1 (BGRA) */
+	OSD_MODE_ABGR1555   = 11, /* 1:5:5:5 (ABGR) */
+	OSD_MODE_ARGB1555   = 12, /* 1:5:5:5 (ARGB) */
+
+	/* 32-bit mode */
+	OSD_MODE_AYUV8888   = 27, /* 8:8:8:8 (AYUV) */
+	OSD_MODE_RGBA8888   = 28, /* 8:8:8:8 (RGBA) */
+	OSD_MODE_BGRA8888   = 29, /* 8:8:8:8 (BGRA) */
+	OSD_MODE_ABGR8888   = 30, /* 8:8:8:8 (ABGR) */
+	OSD_MODE_ARGB8888   = 31, /* 8:8:8:8 (ARGB) */
 } osd_dir_mode_t;
 
 typedef enum {
@@ -4546,7 +4620,7 @@ typedef struct vout_video_setup_s {
   u8  flip;
   u8  rotate;
   u8  data_src;
-  u8  reserved;
+  u8  interlaced;
   u16 win_offset_x;
   u16 win_offset_y;
   u16 win_width;
@@ -4555,7 +4629,7 @@ typedef struct vout_video_setup_s {
   u32 default_img_uv_addr;
   u16 default_img_pitch;
   u8  default_img_repeat_field;
-  u8  reserved2;
+  u8  num_stat_lines_at_top;
 } vout_video_setup_t;
 
 // (cmd code 0x00007003)
@@ -4706,17 +4780,18 @@ typedef struct real_time_cbr_modify_s
 typedef struct ipcam_capture_preview_size_setup_s
 {
 	u32 cmd_code;
-    u32 preview_id : 2 ;
-    u32 output_scan_format : 1 ;
-    u32 deinterlace_mode : 2 ;
-    u32 disabled : 1 ;
-    u32 Reserved1 : 26 ;
-    u16 cap_width ;
-    u16 cap_height ;
-    u16 input_win_offset_x ;
-    u16 input_win_offset_y ;
-    u16 input_win_width ;
-    u16 input_win_height ;
+	u32 preview_id : 2 ;
+	u32 output_scan_format : 1 ;
+	u32 deinterlace_mode : 2 ;
+	u32 disabled : 1 ;
+	u32 skip_interval : 8; /* 0-N. Capture one frame every N+1 frame */
+	u32 Reserved1 : 18 ;
+	u16 cap_width ;
+	u16 cap_height ;
+	u16 input_win_offset_x ;
+	u16 input_win_offset_y ;
+	u16 input_win_width ;
+	u16 input_win_height ;
 } ipcam_capture_preview_size_setup_t ;
 
 /* for capture_source in ipcam_video_encode_size_setup_t */
@@ -4791,11 +4866,48 @@ typedef struct ipcam_video_system_setup_s
 	u16 stream_1_LT_enable : 1;
 	u16 stream_2_LT_enable : 1;
 	u16 stream_3_LT_enable : 1;
-	u16 reserved1 : 4;
-	u16 max_warp_region_input_height;
-	u16 reserved2;
+	u16 B_frame_enable_in_LT_gop : 1;
+	u16 prev_A_extra_line_at_top : 1;
+	u16 vca_preview_id : 2 ;
+	u16 max_warp_region_input_height ;
+	u16 vca_frame_num;
+	u32 vca_daddr_base;
+	u32 vca_daddr_size;
+	u32 enc_buf_extra_MB_row_at_top : 1;
+	u32 reserved : 31;
 }ipcam_video_system_setup_t ;
 
+/* For enable_flags in cmd 0x6004 */
+enum {
+	REALTIME_PARAM_CBR_MODIFY_BIT = (1 << 0),
+	REALTIME_PARAM_CUSTOM_FRAME_RATE_BIT = (1 << 1),
+	REALTIME_PARAM_QP_LIMIT_BIT = (1 << 2),
+	REALTIME_PARAM_GOP_BIT = (1 << 3),
+	REALTIME_PARAM_CUSTOM_VIN_FPS_BIT = (1 << 4),
+	REALTIME_PARAM_INTRA_MB_ROWS_BIT = (1 << 5),
+	REALTIME_PARAM_PREVIEW_A_FRAME_RATE_BIT = (1 << 6),
+	REALTIME_PARAM_QP_ROI_MATRIX_BIT = (1 << 7),
+	REALTIME_PARAM_PANIC_MODE_BIT = (1 << 8),
+	REALTIME_PARAM_QUANT_MATRIX_BIT = (1 << 9),
+	REALTIME_PARAM_MONOCHROME_BIT = (1 << 10),
+	REALTIME_PARAM_INTRA_BIAS_BIT = (1 << 11),
+	REALTIME_PARAM_SCENE_DETECT_BIT = (1 << 12),
+	REALTIME_PARAM_FORCE_IDR_BIT = (1 << 13),
+	REALTIME_PARAM_ZMV_THRESHOLD_BIT = (1 << 14),
+	REALTIME_PARAM_FLAT_AREA_BIT = (1 << 15),
+	REALTIME_PARAM_FORCE_FAST_SEEK_BIT = (1 << 16),
+	REALTIME_PARAM_FRAME_DROP_BIT = (1 << 17),
+	REALTIME_PARAM_MV_DUMP_BIT = (1 << 18),
+	REALTIME_PARAM_LONG_REF_P_BIT = (1 << 19),
+	REALTIME_PARAM_FORCE_PSKIP_BIT = (1 << 20),
+	REALTIME_PARAM_VIN_CAP_STATE = (1 << 21),
+};
+
+typedef enum {
+    VIN_CAPTURE_NORMAL = 0,
+    VIN_CAPTURE_HALT,
+} vin_capture_state_t;
+
 /* 0x6004 */
 typedef struct ipcam_real_time_encode_param_setup_s
 {
@@ -4828,7 +4940,11 @@ typedef struct ipcam_real_time_encode_param_setup_s
 	u32 scene_change_detect_on : 1;
 	u32 flat_area_improvement_on : 1;
 	u32 drop_frame : 8;
-	u32 reserved0 : 13 ;
+	u32 mvdump_enable : 1;
+	u32 vin_state : 2 ;
+	u32 drop_frame_repeat : 1; /* 0 : drop "drop_frame" frames once, 1 : drop "drop_frame"
+								frames everytime after encode one frame*/
+	u32 reserved : 9 ;
 	u32 pic_size_control;
 	u32 quant_matrix_addr ;
 	u16 P_IntraBiasAdd;
@@ -4845,9 +4961,26 @@ typedef struct ipcam_real_time_encode_param_setup_s
 	u8 user2_direct_bias;
 	u8 user3_intra_bias;
 	u8 user3_direct_bias;
-	u8 reserved1[2];
+	u8 force_pskip_num_plus1; /* 0: force one frame encode as pskip frame;
+								>= 1: (force_pskip_num_plus1-1) frames will encodes
+									as pskip between every two normal P frames */
+	u8 reserved1[1];
+	u32 set_I_size;
+	u8 q_qp_reduce;
+	u8 qp_min_on_Q;
+	u8 qp_max_on_Q;
+	u8 log_q_num_per_gop_plus_1;
 } ipcam_real_time_encode_param_setup_t ;
 
+/* mdSwCat structure for AVC per MB control*/
+typedef struct avc_mdSwCat_s
+{
+	u32 user_class : 8;
+	u32 qp_offset : 8;
+	u32 zmv_threshold_val : 8;
+	u32 reserved : 8;
+} avc_mdSwCat;
+
 /* 0x6007 */
 typedef struct ipcam_osd_insert_s
 {
@@ -4857,7 +4990,8 @@ typedef struct ipcam_osd_insert_s
 	u32 osd_num_regions : 2 ;
 	u32 osd_enable_ex : 1 ; /* if set, osd_enable must be set also */
 	u32 osd_num_regions_ex : 2 ;
-	u32 reserved1 : 25 ;
+	u32 osd_insert_always : 1;
+	u32 reserved1 : 24;
 	u32 osd_clut_dram_address[3] ;
 	u32 osd_buf_dram_address[3] ;
 	u16 osd_buf_pitch[3] ;
@@ -5050,6 +5184,8 @@ typedef struct
 	u32 yuv_fId : 16;
 	u32 me1_fId : 16;
 	u32 pts;
+	u32 next_is_last_frame : 1;
+	u32 reserved : 31;
 } ipcam_efm_handshake_cmd_t;
 
 /* Adding Macros defined in the interface between ARM and VDSP */
@@ -5072,18 +5208,20 @@ typedef struct bit_stream_hdr_s
 	u32    frmNo;
 	u32    pts;
 	u32    start_addr;
-	u32    frameTy     : 3;
-	u32    levelIDC    : 3;
-	u32    refIDC      : 1;
-	u32    picStruct   : 1;
-	u32    length      :24;
-	u32    streamID	: 8;
+	u32    frameTy		: 3;
+	u32    levelIDC		: 3;
+	u32    refIDC		: 1;
+	u32    picStruct	: 1;
+	u32    length		: 24;
+	u32    streamID		: 8;
 	u32    sessionID	: 4;
-	u32    res_1		:20;
-	u32    pjpg_start_addr;
-	u32    pjpg_size;
+	u32    res_1		: 20;
+	u32    reserved;
+	u32    mvdump_curr_daddr;
 	u32    hw_pts;
 } bit_stream_hdr_t ;
 
+typedef bit_stream_hdr_t BIT_STREAM_HDR;
+
 #endif /* __CMD__MSG_H__ */
 
diff --git a/lib/firmware_s2l/encode_only/ucode.list b/lib/firmware_s2l/encode_only/ucode.list
index db97e52..902495b 100644
--- a/lib/firmware_s2l/encode_only/ucode.list
+++ b/lib/firmware_s2l/encode_only/ucode.list
@@ -1,4 +1,12 @@
 [ucode]
-orccode.bin
-orcme.bin
-default_binary.bin
+# format: [filename]  [is_single_post_load]  [pre_load_size]
+# filename (mandatory):
+#    Must be selected from the ucode binary files.
+# is_single_post_load (optional):
+#    0 for partial load (pre-load & post-load), 1 for full post-load.
+# pre_load_size (optional):
+#    It's only useful when "is_single_post_load" is zero.  Non-zero value means the
+#    pre-load size.  Post-load starts from this offset to the file end.
+orccode.bin 0 0xe0640
+orcme.bin 1
+default_binary.bin 0 0x20800
diff --git a/lib/firmware_s2l/iav_config.h b/lib/firmware_s2l/iav_config.h
index b754c93..0a92b83 100644
--- a/lib/firmware_s2l/iav_config.h
+++ b/lib/firmware_s2l/iav_config.h
@@ -5,15 +5,34 @@
  *	2008/10/23 - [Louis Sun] created file
  *	2012/03/06 - [Jian Tang] modified file
  *
- * Copyright (C) 2007-2012, Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
  */
 
+
 #ifndef __IAV_CONFIG_H__
 #define __IAV_CONFIG_H__
 
@@ -46,7 +65,7 @@
  * Bit stream info descriptor total number
  * add padding to avoid cache alignment problem
  */
-#define NUM_BS_DESC				(256)
+#define NUM_BS_DESC				(DSP_BS_NUM)
 
 
 
@@ -83,18 +102,19 @@
 #define MAX_SLICE_FOR_FRAME	(2)
 #define TWO_JIFFIES			(msecs_to_jiffies(2000))
 #define FIVE_JIFFIES		(msecs_to_jiffies(5000))
+#define INVALID_DSP_PTS_32	(0xFFFFFFFF)
 
 #define MIN_CRD_IN_MS		(4)
 #define AUDIO_CLK_KHZ		(12288)
 #define MIN_CRD_IN_CLK		(MIN_CRD_IN_MS * AUDIO_CLK_KHZ)
 
-#define MIN_VIN_UPSAMPLE_FRAME_RATE	(FPS_Q9_BASE / 10)
+#define MIN_VIN_UPSAMPLE_FRAME_RATE	(FPS_Q9_BASE / 8)
 
 #define KByte(x)				((x) << 10)
 #define MByte(x)				((x) << 20)
 
 #define MIN_WARP_INPUT_WIDTH	(320)
-#define MAX_WIDTH_FOR_TWO_REF	(2560)
+#define MAX_WIDTH_FOR_TWO_REF	(2688)
 
 /*
  * GOP and preview configuration for 2Gb and 1Gb
@@ -108,19 +128,22 @@
 #define IAV_MAX_ENCODE_STREAMS_NUM		(4)
 #define STREAM_ID_MASK			((1 << IAV_MAX_ENCODE_STREAMS_NUM) - 1)
 #define PREVIEW_ID_MASK			((1 << CONFIG_MAX_PREVIEW_NUM) - 1)
-#define LONG_TERM_INTVL_MAX 	(63)
+#define FAST_SEEK_INTVL_MAX 	(63)
 #define MAX_REF_FRAME_INTVL		(3)
 #define MAX_ZMV_THRESHOLD		(255)
 #define MIN_INTRABIAS 			(1)
 #define MAX_INTRABIAS			(4000)
 #define MIN_USER_BIAS 			(0)
-#define MAX_USER_BIAS			(128)
+#define MAX_USER_BIAS			(9)
 #define MAX_FRAME_DROP_COUNT	(255)
+#define MAX_PSKIP_REPEAT		(254)
 
 #define QP_QUALITY_MIN	(0)
 #define QP_QUALITY_MAX	(3)
 #define QP_OFFSET_MIN	(-51)
 #define QP_OFFSET_MAX	(51)
+#define ZMV_THRESHOLD_MIN	(0)
+#define ZMV_THRESHOLD_MAX	(255)
 
 
 
@@ -130,6 +153,38 @@ typedef enum {
 	IAV_EXTRA_DRAM_BUF_MAX = 7,
 } IAV_EXTRA_DRAM_BUF;
 
+/*
+ * Vin performance load
+ */
+typedef enum {
+	/* Pixel rate:
+		94371840	= 2048 * 1536 * 30
+		125829120	= 2048 * 2048 * 30
+		151787520	= 2592 * 1952 * 30
+		188743680	= 3072 * 2048 * 30
+		251658240	= 4096 * 2048 * 30
+		377487360	= 3072 * 2048 * 60
+	*/
+
+	VIN_PPS_3MP30 = (2048 * 1536 * 30),
+	VIN_PPS_4MP30 = (2048 * 2048 * 30),
+	VIN_PPS_5MP30 = (2592 * 1952 * 30),
+	VIN_PPS_6MP30 = (3072 * 2048 * 30),
+	VIN_PPS_8MP30 = (4096 * 2048 * 30),
+	VIN_PPS_6MP60 = (3072 * 2048 * 60),
+
+	SYS_VIN_PPS_S2L_22M = VIN_PPS_3MP30,
+	SYS_VIN_PPS_S2L_33M = VIN_PPS_6MP30,
+	SYS_VIN_PPS_S2L_55M = VIN_PPS_6MP30,
+	SYS_VIN_PPS_S2L_99M = VIN_PPS_8MP30,
+	SYS_VIN_PPS_S2L_63 = VIN_PPS_8MP30,
+	SYS_VIN_PPS_S2L_66 = VIN_PPS_6MP60,
+	SYS_VIN_PPS_S2L_88 = VIN_PPS_6MP60,
+	SYS_VIN_PPS_S2L_99 = VIN_PPS_6MP60,
+	SYS_VIN_PPS_S2L_TEST = VIN_PPS_8MP30,
+	SYS_VIN_PPS_S2L_22 = VIN_PPS_6MP30,
+
+} IAV_SYS_VIN_LOAD;
 
 /*
  * Encode performance load
@@ -144,12 +199,13 @@ typedef enum {
 		442044 = (2592/16) * (1952/16) * 21 + (720/16) * (480/16) * 20
 		491520 = (2048/16) * (2048/16) * 30
 		570600 = (1920/16) * (1088/16) * 60 + (720/16) * (480/16) * 60
-		592920 = (2592/16) * (1952/15) * 30
+		592920 = (2592/16) * (1952/16) * 30
 		633420 = (2592/16) * (1952/16) * 30 + (720/16) * (480/16) * 30
-		653184 = (2592/16) * (1952/15) * 31 + (720/16) * (480/16) * 30
+		653184 = (2592/16) * (1952/16) * 31 + (720/16) * (480/16) * 30
 		897600 = (1920/16) * (1088/16) * 110
 	*/
 	LOAD_720P60 = (1280 * 720 / 256 * 60),
+	LOAD_1080P25 = (1920 * 1088 / 256 * 25),
 	LOAD_1080P31_480P30_CIFP30 = (1920 * 1088 / 256 * 31 + 720 * 480 / 256 * 30 + 352 * 288 / 256 * 30),
 	LOAD_5MP15_480P30 = (2592 * 1952 / 256 * 15 + 720 * 480 / 256 * 30),
 	LOAD_3MP30_480P30 = (2048 * 1536 / 256 * 30 + 720 * 480 / 256 * 30),
@@ -170,6 +226,7 @@ typedef enum {
 	SYS_ENC_LOAD_S2L_88 = LOAD_5MP31_480P30,
 	SYS_ENC_LOAD_S2L_99 = LOAD_1080P110,
 	SYS_ENC_LOAD_S2L_TEST = LOAD_5MP20_480P20,
+	SYS_ENC_LOAD_S2L_22 = LOAD_1080P25,
 } IAV_SYS_ENC_LOAD;
 
 
@@ -179,7 +236,7 @@ typedef enum {
 typedef enum {
 	MIN_WIDTH_IN_STREAM = 320,
 	MIN_WIDTH_IN_STREAM_ROTATE = 240,
-	MIN_HEIGHT_IN_STREAM = 240,
+	MIN_HEIGHT_IN_STREAM = 180,
 
 	MAX_WIDTH_IN_BUFFER = 4 * 1024,
 	MAX_HEIGHT_IN_BUFFER = 4 * 1024,
@@ -205,6 +262,9 @@ typedef enum {
 	MIN_WIDTH_IN_HIGH_MP = MIN_WIDTH_IN_STREAM_ROTATE,
 	MIN_HEIGHT_IN_HIGH_MP = MIN_HEIGHT_IN_STREAM,
 
+	MAX_MAIN_BUF_INPUT_WIDTH_IN_HIGH_MP = 3760,
+	MAX_MAIN_BUF_INPUT_HEIGHT_IN_HIGH_MP = 2820,
+
 	/* RAW encode case */
 	MAX_WIDTH_FOR_RAW = MAX_WIDTH_IN_HIGH_MP,
 	MAX_HEIGHT_FOR_RAW = MAX_HEIGHT_IN_HIGH_MP,
@@ -218,6 +278,20 @@ typedef enum {
 	MIN_HEIGHT_FOR_EFM = MIN_HEIGHT_IN_FULL_FPS,
 } RESOLUTION_RESOURCE_LIMIT;
 
+/*
+ * DEBLOCKING filter limitation
+ */
+#define IAV_DEBLOCKING_ALPHA_MIN	(-6)
+#define IAV_DEBLOCKING_ALPHA_MAX	(6)
+#define IAV_DEBLOCKING_BETA_MIN		(-6)
+#define IAV_DEBLOCKING_BETA_MAX		(6)
+
+enum iav_h264_deblocking_filter_type {
+	H264_DEBLOCKING_DISABLE = 0,
+	H264_DEBLOCKING_ENABLE = 1,
+	H264_DEBLOCKING_AUTO = 2,
+	H264_DEBLOCKING_TYPE_NUM = 3,
+};
 
 /*
  * Capture source buffer configuration
@@ -248,9 +322,11 @@ typedef enum {
 	PCBUF_LIMIT_MAX_WIDTH = 720,
 	PCBUF_LIMIT_MAX_HEIGHT = 720,
 	PBBUF_LIMIT_MAX_WIDTH = 1920,
-	PBBUF_LIMIT_MAX_HEIGHT = 1920,
+	PBBUF_LIMIT_MAX_WIDTH_STITCH = 2560,
+	PBBUF_LIMIT_MAX_HEIGHT = 2048,
 	PABUF_LIMIT_MAX_WIDTH = 1280,
-	PABUF_LIMIT_MAX_HEIGHT = 1280,
+	PABUF_LIMIT_MAX_WIDTH_STITCH = 2560,
+	PABUF_LIMIT_MAX_HEIGHT = 2048,
 
 	/*
 	 * Default max resolution for the 4 source buffers
@@ -309,20 +385,25 @@ typedef enum {
 } IAV_CMD_SYNC_PARAMS;
 
 /*
- *
+ * QP matrix memory configuration
  */
 typedef enum {
+#if (!defined CONFIG_AMBARELLA_IAV_DRAM_DECODE_ONLY) && (!defined CONFIG_AMBARELLA_IAV_DRAM_VOUT_ONLY)
 	SINGLE_QP_MATRIX_SIZE = IAV_MEM_QPM_SIZE,
-#ifndef CONFIG_AMBARELLA_IAV_QP_OFFSET_IPB
+#else
+	SINGLE_QP_MATRIX_SIZE = 0,
+#endif
+#ifndef CONFIG_AMBARELLA_IAV_ROI_IPB
 	STREAM_QP_MATRIX_NUM = (1),
 #else
 	STREAM_QP_MATRIX_NUM = (3),
 #endif
 	STREAM_QP_MATRIX_SIZE = (SINGLE_QP_MATRIX_SIZE * STREAM_QP_MATRIX_NUM),
 	QP_MATRIX_SIZE = (STREAM_QP_MATRIX_SIZE * IAV_MAX_ENCODE_STREAMS_NUM),
-	/* 96KB * 4 * (1 + 8) = 3456 KB for 1 qp matrix per stream*/
-	/* 96KB * 3 * 4 * (1 + 8) = 10368 KB for 3 qp matrixes per stream*/
-	QP_MATRIX_TOTAL_SIZE = (QP_MATRIX_SIZE * (1 + ENC_CMD_TOGGLED_NUM)),
+	QP_MATRIX_TOGGLED_NUM = (4),
+	/* 96KB * 4 * (1 + 4) = 1920 KB for 1 qp matrix per stream*/
+	/* 96KB * 3 * 4 * (1 + 4) = 5760 KB for 3 qp matrixes per stream*/
+	QP_MATRIX_TOTAL_SIZE = (QP_MATRIX_SIZE * (1 + QP_MATRIX_TOGGLED_NUM)),
 }IAV_QPMATRIX_PARAMS;
 
 
@@ -398,10 +479,42 @@ typedef enum {
 	IAV_DRAM_SIZE_16Gb = 0x10,
 
 	/* All DRAM size must be aligned to PAGE size (4KB). */
+#ifdef CONFIG_AMBARELLA_IAV_DRAM_DECODE_ONLY
+
 	IAV_DRAM_BSB = DSP_BSB_SIZE,
-	IAV_DRAM_USR = IAV_MEM_USR_SIZE,
+	IAV_DRAM_USR = 0,
 	IAV_DRAM_MV = 0,
-	IAV_DRAM_OVERLAY = IAV_MEM_OVERLAY_SIZE,
+	IAV_DRAM_OVERLAY = 0,
+	IAV_DRAM_QPM = 0,
+	IAV_DRAM_WARP = 0,
+	IAV_DRAM_QUANT = 0,
+	IAV_DRAM_IMG = 0,
+	IAV_DRAM_PM = 0,
+	IAV_DRAM_BPC = 0,
+	IAV_DRAM_CMD_SYNC = 0,
+	IAV_DRAM_VCA = 0,
+
+#elif defined CONFIG_AMBARELLA_IAV_DRAM_VOUT_ONLY
+
+	IAV_DRAM_BSB = 0,
+	IAV_DRAM_USR = PAGE_ALIGN(IAV_MEM_USR_SIZE),
+	IAV_DRAM_MV = 0,
+	IAV_DRAM_OVERLAY = 0,
+	IAV_DRAM_QPM = 0,
+	IAV_DRAM_WARP = 0,
+	IAV_DRAM_QUANT = 0,
+	IAV_DRAM_IMG = PAGE_ALIGN(DSP_IMGRSVD_SIZE),
+	IAV_DRAM_PM = PAGE_ALIGN(IAV_MEM_PM_SIZE_S2L),
+	IAV_DRAM_BPC = PAGE_SIZE + PAGE_ALIGN(PM_BPC_PARTITION_SIZE),
+	IAV_DRAM_CMD_SYNC = 0,
+	IAV_DRAM_VCA = 0,
+
+#else
+
+	IAV_DRAM_BSB = DSP_BSB_SIZE,
+	IAV_DRAM_USR = PAGE_ALIGN(IAV_MEM_USR_SIZE),
+	IAV_DRAM_MV = PAGE_ALIGN(IAV_MEM_MV_SIZE),
+	IAV_DRAM_OVERLAY = PAGE_ALIGN(IAV_MEM_OVERLAY_SIZE),
 	IAV_DRAM_QPM = PAGE_ALIGN(QP_MATRIX_TOTAL_SIZE),
 #ifndef CONFIG_AMBARELLA_IAV_DRAM_WARP_MEM
 	IAV_DRAM_WARP = 0,
@@ -409,7 +522,7 @@ typedef enum {
 	IAV_DRAM_WARP = PAGE_ALIGN(WARP_BUFFER_TOTAL_SIZE),
 #endif
 	IAV_DRAM_QUANT = PAGE_ALIGN(JPEG_QT_TOTAL_SIZE),
-	IAV_DRAM_IMG = DSP_IMGRSVD_SIZE,
+	IAV_DRAM_IMG = PAGE_ALIGN(DSP_IMGRSVD_SIZE),
 
 	/* 768KB * (4 + 1) = 3840 KB */
 	IAV_DRAM_PM = PAGE_ALIGN(IAV_MEM_PM_SIZE_S2L),
@@ -419,14 +532,18 @@ typedef enum {
 	IAV_DRAM_BPC = PAGE_SIZE + PAGE_ALIGN(PM_BPC_PARTITION_SIZE),
 
 	IAV_DRAM_CMD_SYNC = PAGE_ALIGN(CMD_SYNC_TOTAL_SIZE),
+	IAV_DRAM_VCA = PAGE_ALIGN(IAV_MEM_VCA_SIZE),
+
 	/* The end of IAVRSVD */
 
+#endif
+
 	IAV_DRAM_FB_DATA = PAGE_ALIGN(DSP_FASTDATA_SIZE),
 	IAV_DRAM_FB_AUDIO = PAGE_ALIGN(DSP_FASTAUDIO_SIZE),
 
 	IAV_DRAM_MAX = IAV_DRAM_BSB + IAV_DRAM_USR + IAV_DRAM_MV + IAV_DRAM_OVERLAY +
 		IAV_DRAM_QPM + IAV_DRAM_WARP + IAV_DRAM_QUANT + IAV_DRAM_IMG +
-		IAV_DRAM_PM + IAV_DRAM_BPC + IAV_DRAM_CMD_SYNC,
+		IAV_DRAM_PM + IAV_DRAM_BPC + IAV_DRAM_CMD_SYNC + IAV_DRAM_VCA,
 
 	IAV_DRAM_IMG_OFFET = (MByte(4)),
 } IAV_DRAM;
diff --git a/lib/make.inc b/lib/make.inc
index 69cca93..0dd0082 100644
--- a/lib/make.inc
+++ b/lib/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/01 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (c) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_PRIVATE_MODULES), y)
@@ -18,7 +35,9 @@ ifeq ($(BUILD_AMBARELLA_PRIVATE_MODULES), y)
 prebuild_firmware: LOCAL_PATH:=$(call my-dir)
 prebuild_firmware: basic_fs
 	@mkdir -p $(FIRMWARE_INSTALL_PATH)/
+ifeq ($(CONFIG_ARCH_S2L), y)
 	@-cp -dpRf $(LOCAL_PATH)/firmware_$(AMBARELLA_ARCH)/*.bin $(FIRMWARE_INSTALL_PATH)/
+endif
 ifeq ($(CONFIG_DSP_FIRMWARE_ENCODE_ONLY), y)
 	@-cp -dpRf $(LOCAL_PATH)/firmware_$(AMBARELLA_ARCH)/encode_only/*.bin $(FIRMWARE_INSTALL_PATH)/
 else
diff --git a/drivers/fdet/Kbuild b/drivers/fdet/Kbuild
new file mode 100644
index 0000000..8bdbd20
--- /dev/null
+++ b/drivers/fdet/Kbuild
@@ -0,0 +1,38 @@
+##
+## Kbuild
+##
+## History:
+##    2012/06/28 - [Zhenwu Xue] Create
+##
+## Copyright (c) 2015 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
+EXTRA_AFLAGS		+= $(PRIVATE_AFLAGS)
+EXTRA_LDFLAGS		+= $(PRIVATE_LDFLAGS)
+EXTRA_ARFLAGS		+= $(PRIVATE_ARFLAGS)
+
+obj-m := fdet.o
+
diff --git a/drivers/fdet/fdet.c b/drivers/fdet/fdet.c
new file mode 100644
index 0000000..a30eba6
--- /dev/null
+++ b/drivers/fdet/fdet.c
@@ -0,0 +1,1994 @@
+/*
+ * kernel/private/drivers/ambarella/fdet/fdet.c
+ *
+ * History:
+ *    2012/06/28 - [Zhenwu Xue] Create
+ *
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/cdev.h>
+#include <linux/timer.h>
+#include <linux/fb.h>
+#include <linux/seq_file.h>
+#include <plat/ambcache.h>
+#include <ambhw/chip.h>
+#include <asm/uaccess.h>
+#include <iav_utils.h>
+#include <amba_fdet.h>
+#include "fdet.h"
+
+
+#define FDET_DEBUG(format, arg...)	\
+	do {	\
+		if (pfdet_info->config.policy & FDET_POLICY_DEBUG) {	\
+			printk(format , ## arg);	\
+		}	\
+	} while (0)
+
+#define FDET_MAX_FACES			32
+
+#define FDET_MAX_INPUT_WIDTH		1024
+#define FDET_MAX_INPUT_HEIGHT		1024
+#define FDET_TEMPLATE_SIZE		20
+
+#define FDET_MAX_FACE_CLASSIFIERS	24
+#define FDET_MAX_ORIENTATIONS		8
+
+#define FDET_SCALED_PARTITION_SIZE	40
+
+#define FDET_NUM_EVALS			1
+
+#define FDET_MAX_UNMERGED_FACES		2048
+#define FDET_MAX_MERGED_FACES		128
+
+#define FDET_FS_CMD_BUF_SIZE		(8 * 1024)
+#define FDET_FS_RESULT_BUF_SIZE		(8 * 1024)
+#define FDET_TS_CMD_BUF_SIZE		(4 * 1024)
+#define FDET_TS_RESULT_BUF_SIZE		(64 * 1024)
+
+#define FDET_ORIG_TARGET_BUF_SIZE	(FDET_MAX_INPUT_WIDTH * FDET_MAX_INPUT_HEIGHT)
+#define FDET_TMP_TARGET_BUF_SIZE	(FDET_MAX_INPUT_WIDTH * FDET_MAX_INPUT_HEIGHT)
+#define FDET_CLASSIFIER_BINARY_SIZE	(128 * 1024)
+
+#define FDET_VM_DELAY			(300)
+
+#define FDET_NAME			"fdet"
+#define FDET_MAJOR			248
+#define FDET_MINOR			148
+
+/* ========================================================================== */
+const int hitcount_threshold_still[8] = {14, 12, 12, 3, 3, 3, 3, 0};
+const int hitcount_threshold_video[8] = {14,  9,  9, 4, 4, 4, 4, 0};
+
+const int search_radius[32] = {
+	5, 3, 2, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1,
+	1, 1, 1, 1, 1, 1, 1, 1,
+};
+
+struct fdet_adjacent_update_info {
+	unsigned char				eval_id;
+	unsigned char				orientation_bitmask;
+};
+struct fdet_orientation_info {
+	unsigned char				eval_id;
+	unsigned char				orientation_mode;
+	unsigned char				adjacent_num_evals;
+	struct fdet_adjacent_update_info	adjacent_update_info[FDET_MAX_ORIENTATIONS];
+};
+
+struct fdet_orientation_info fdet_orientation_table[FDET_MAX_ORIENTATIONS] = {
+	{0, 0, 3, {{0,0x01}, {1,0x03}, {2,0x03}, {0,0x00}, {0,0x00}, {0,0x00}, {0,0x00}, {0,0x00}} },
+	{1, 0, 2, {{0,0x01}, {1,0x01}, {0,0x00}, {0,0x00}, {0,0x00}, {0,0x00}, {0,0x00}, {0,0x00}} },
+	{1, 1, 2, {{0,0x01}, {1,0x02}, {0,0x00}, {0,0x00}, {0,0x00}, {0,0x00}, {0,0x00}, {0,0x00}} },
+	{2, 0, 2, {{0,0x01}, {2,0x09}, {0,0x00}, {0,0x00}, {0,0x00}, {0,0x00}, {0,0x00}, {0,0x00}} },
+	{2, 1, 2, {{0,0x01}, {2,0x22}, {0,0x00}, {0,0x00}, {0,0x00}, {0,0x00}, {0,0x00}, {0,0x00}} },
+	{2, 3, 1, {{2,0x09}, {0,0x00}, {0,0x00}, {0,0x00}, {0,0x00}, {0,0x00}, {0,0x00}, {0,0x00}} },
+	{2, 5, 1, {{2,0x22}, {0,0x00}, {0,0x00}, {0,0x00}, {0,0x00}, {0,0x00}, {0,0x00}, {0,0x00}} },
+	{0, 0, 0, {{0,0x00}, {0,0x00}, {0,0x00}, {0,0x00}, {0,0x00}, {0,0x00}, {0,0x00}, {0,0x00}} },
+};
+
+enum fdet_vm_state {
+	FDET_VM_STATE_IDLE	= 0x0,
+	FDET_VM_STATE_READY,
+	FDET_VM_STATE_RUNNING,
+};
+
+struct fdet_classifier_info {
+	unsigned short			offset;
+	unsigned short			sz;
+	unsigned short			left_offset;
+	unsigned short			top_offset;
+	unsigned char			orientation_bitmasks;
+	unsigned char			orientation_result[FDET_MAX_ORIENTATIONS];
+};
+
+struct fdet_classifier_binary_info {
+	unsigned int			cls_base;
+
+	unsigned int			num_fs_classifiers;
+	unsigned int			num_ts_classifiers;
+
+	struct fdet_classifier_info	fs_cls_info[FDET_MAX_FACE_CLASSIFIERS];
+	struct fdet_classifier_info	ts_cls_info[FDET_MAX_FACE_CLASSIFIERS];
+};
+
+struct fdet_unmerged_face {
+	unsigned int			x;
+	unsigned int			y;
+	unsigned int			si;
+	unsigned int			sz;
+	int				cluster;
+	int				oi;
+};
+
+struct fdet_merged_face {
+	unsigned int			x;
+	unsigned int			y;
+	unsigned int			sz;
+	unsigned int			num_si[32];
+	unsigned int			hit_count[8];
+	unsigned int			hit_sum;
+	unsigned int			best_oi;
+	unsigned int			best_hitcount;
+	enum fdet_result_type		type;
+};
+
+struct amba_fdet_info {
+	char					fs_cmd_buf[2][FDET_FS_CMD_BUF_SIZE];
+	char					fs_result_buf[2][FDET_FS_RESULT_BUF_SIZE];
+	char					ts_cmd_buf[2][FDET_TS_CMD_BUF_SIZE];
+	char					ts_result_buf[2][FDET_TS_RESULT_BUF_SIZE];
+	int					current_fs_buf_id;
+	int					current_fs_result_id;
+	int					current_ts_buf_id;
+	int					current_ts_result_id;
+	int					current_tmp_target_id;
+	int					current_fs_buf_sz;
+	int					current_ts_buf_sz;
+	int					last_fs_cmd_id;
+	enum fdet_vm_state			vm_state;
+
+	char					*orig_target_buf;
+	char					*tmp_target_buf;
+	char					*classifier_binary;
+	int					orig_len;
+	int					cls_bin_len;
+	enum fdet_mmap_type			mmap_type;
+
+	struct fdet_configuration		config;
+
+	int					num_scales;
+	int					num_sub_scales;
+	int					num_total_scales;
+	unsigned int				scale_factor[32];
+	unsigned int				recip_scale_factor[32];
+	unsigned int				scale_factor_regs[32];
+
+	struct fdet_classifier_binary_info	classifierBinaryInfo;
+	unsigned int				evaluation_id[32];
+	unsigned int				evaluation_num[32];
+
+	struct fdet_unmerged_face		unmerged_faces[FDET_MAX_UNMERGED_FACES];
+	struct fdet_unmerged_face		ts_unmerged_faces[FDET_MAX_UNMERGED_FACES];
+	struct fdet_merged_face			merged_faces[FDET_MAX_MERGED_FACES];
+	struct fdet_merged_face			latest_faces[FDET_MAX_MERGED_FACES];
+	int					num_faces;
+	int					latest_faces_num;
+	unsigned int				fs_found_faces[2];
+
+	int					irq;
+	struct cdev				char_dev;
+
+	struct timer_list			timer;
+	struct completion			result_completion;
+
+	unsigned long				fs_tick;
+	unsigned long				ts_tick;
+};
+
+static struct amba_fdet_info	*pfdet_info = NULL;
+
+/* ========================================================================== */
+int fdet_get_result_still(void);
+int fdet_get_result_video_fs(void);
+int fdet_get_result_video_ts(void);
+void fdet_print_faces(void);
+void fdet_config(void);
+
+static int amba_enable_fdet(void)
+{
+	int		i, ret = -1;
+	u32		val;
+
+	amba_writel(FDET_ENABLE_REG, FDET_ENABLE);
+	amba_writel(FDET_BASE_ADDRESS_REG, FDET_CONFIG_BASE_NORMAL);
+
+	for (i = 0; i < 5; i++) {
+		val = amba_readl(FDET_ENABLE_REG);
+		if (val == FDET_ENABLE) {
+			ret = 0;
+			break;
+		}
+	}
+
+	if (ret) {
+		printk("%s: Fail to enable fdet!\n", __func__);
+	} else {
+		amba_writel(FDET_GO_REG, 0);
+		amba_writel(FDET_CONFIG_DONE_REG, 0);
+		amba_writel(FDET_RESET_REG, 0);
+		amba_writel(FDET_ERROR_STATUS_REG, 0xffff);
+	}
+
+	return ret;
+}
+
+static int amba_disable_fdet(void)
+{
+	amba_writel(FDET_BASE_ADDRESS_REG, FDET_CONFIG_BASE_NORMAL);
+	amba_writel(FDET_RESET_REG, FDET_RESET);
+	amba_writel(FDET_ENABLE_REG, FDET_DISABLE);
+
+	return 0;
+}
+
+static void fdet_timer(unsigned long context)
+{
+	del_timer(&pfdet_info->timer);
+
+	if (pfdet_info->vm_state == FDET_VM_STATE_IDLE) {
+		pfdet_info->vm_state = FDET_VM_STATE_READY;
+		amba_writel(FDET_CONFIG_DONE_REG, FDET_CONFIG_DONE);
+	}
+}
+
+static irqreturn_t amba_fdet_isr(int irq, void *dev_data)
+{
+	int			num = -1;
+	unsigned long		tick;
+
+	if (pfdet_info->config.input_mode == FDET_MODE_STILL) {
+		num = fdet_get_result_still();
+		FDET_DEBUG("Found %d Faces:\n", num);
+	} else {
+		switch (pfdet_info->vm_state) {
+		case FDET_VM_STATE_IDLE:
+			pfdet_info->timer.expires = jiffies + FDET_VM_DELAY * HZ / 1000;
+			add_timer(&pfdet_info->timer);
+			break;
+
+		case FDET_VM_STATE_READY:
+			num = fdet_get_result_video_fs();
+			FDET_DEBUG("Found %d Faces:\n", num);
+			break;
+
+		case FDET_VM_STATE_RUNNING:
+			num = fdet_get_result_video_fs();
+			num = fdet_get_result_video_ts();
+
+			if (pfdet_info->config.policy & FDET_POLICY_MEASURE_TIME) {
+				tick			= jiffies;
+				printk("Ts used time: %lu ms\n", 1000 * (tick - pfdet_info->ts_tick) / HZ);
+				pfdet_info->ts_tick	= tick;
+			}
+			FDET_DEBUG("Found %d Faces:\n", num);
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	if (num < 0) {
+		goto amba_fdet_isr_exit;
+	}
+
+	if (num > 0) {
+		memcpy(pfdet_info->latest_faces, pfdet_info->merged_faces, num * sizeof(struct fdet_merged_face));
+		pfdet_info->latest_faces_num = num;
+		fdet_print_faces();
+	}
+
+	complete(&pfdet_info->result_completion);
+
+amba_fdet_isr_exit:
+	amba_writel(FDET_ERROR_STATUS_REG, 0xffffffff);
+	return IRQ_HANDLED;
+}
+
+
+/* ========================================================================== */
+int fdet_get_sf(int width, int height)
+{
+	int			num_scales, num_sub_scales, num_total_scales;
+	int			si, sr, srr;
+	unsigned int 		swi, csw, csh, csf;
+	unsigned int		crf;
+	long long		csrr;
+	unsigned int		sfMant;
+	int			sfExpn;
+	unsigned short		hwsf_mant;
+	unsigned char		hwsf_expn;
+	unsigned int		rsf_mant;
+	unsigned int		rsf_expn;
+	unsigned short		hwrsf_mant;
+	unsigned char		hwrsf_expn;
+
+	if (width > 320) {
+		swi	= 320;
+	} else {
+		swi	= (width / FDET_TEMPLATE_SIZE) * FDET_TEMPLATE_SIZE;
+	}
+
+	if (pfdet_info->config.input_mode == FDET_MODE_STILL) {
+		sr	= 58514;
+		srr	= 73400;
+	} else {
+		sr	= 56988;
+		srr	= 75366;
+	}
+
+	csw	= swi;
+	csh	= (csw * height + (width >> 2)) / width;
+	csrr	= (long long)sr;
+	for (si = 0; si < 32; si++) {
+		csw	= (swi * (int)csrr + (1 << 15)) >> 16;
+		csh	= (csw * height + (width >> 2)) / width;
+		if (csw < FDET_TEMPLATE_SIZE || csh < FDET_TEMPLATE_SIZE) {
+			break;
+		}
+		csrr = (csrr * sr + (1 << 15)) >> 16;
+	}
+	num_scales = si + 1;
+
+	if (num_scales < 1) {
+		return 0;
+	}
+
+	csrr	= (long long)srr;
+	for (si = num_scales; si < 32; si++) {
+		csw	= (swi * (int)csrr + (1 << 15)) >> 16;
+		csh	= (csw * height + (width >> 2)) / width;
+		if (csw > width || csh > height) {
+			break;
+		}
+		csrr	= (csrr * srr + (1 << 15)) >> 16;
+	}
+	num_total_scales	= si;
+	num_sub_scales		= num_total_scales - num_scales;
+
+	csw	= swi;
+	csh	= (csw * height + (width >> 2)) / width;
+	csrr	= (long long)sr;
+	for (si = num_sub_scales; si < num_total_scales; si++) {
+		csf = ((csw << (16 + 1)) + width) / (2 * width);
+		pfdet_info->scale_factor[si] = csf;
+
+		sfMant	= csf;
+		sfExpn	= 0;
+		while (sfMant < 65536) {
+			sfMant = sfMant << 1;
+			sfExpn--;
+		}
+		hwsf_mant = sfMant >> (16 - 10);
+		hwsf_expn = abs(sfExpn);
+
+		crf = ((width << (16 + 1)) + csw) / (2 * csw);
+		pfdet_info->recip_scale_factor[si] = crf;
+
+		rsf_mant = crf;
+		rsf_expn = 0;
+		while (rsf_mant >= 2 * 65536) {
+			rsf_mant = rsf_mant >> 1;
+			rsf_expn++;
+		}
+		hwrsf_mant = rsf_mant >> (16 - 10);
+		hwrsf_expn = rsf_expn;
+		pfdet_info->scale_factor_regs[si] = (hwrsf_mant << 17) | (hwrsf_expn << 14) | (hwsf_mant << 3) | hwsf_expn;
+
+		if (hwsf_mant == 1024 && hwsf_expn == 0) {
+			pfdet_info->scale_factor[si]		= 65472;
+			hwsf_mant				= 1023;
+			hwsf_expn				= 0;
+			pfdet_info->recip_scale_factor[si]	= 65600;
+			hwrsf_mant				= 1025;
+			hwrsf_expn				= 0;
+			pfdet_info->scale_factor_regs[si]	= (hwrsf_mant << 17) | (hwrsf_expn << 14) | (hwsf_mant << 3) | hwsf_expn;
+		}
+
+		csw	= (swi * (int)csrr + (1 << 15)) >> 16;
+		csh	= (csw * height + (width >> 2 )) / width;
+		csrr	= (csrr * sr + (1 << 15)) >> 16;
+	}
+
+	csrr	= (long long)srr;
+	for (si = num_sub_scales - 1; si >= 0; si--) {
+		csw	= (swi * (int)csrr + (1 << 15)) >> 16;
+		csh	= (csw * height + (width >> 2)) / width;
+		csf	= ((csw << (16 + 1)) + width) / (2 * width);
+		pfdet_info->scale_factor[si] = csf;
+
+		sfMant = csf;
+		sfExpn = 0;
+		while (sfMant < 65536) {
+			sfMant = sfMant << 1;
+			sfExpn--;
+		}
+		hwsf_mant = sfMant >> (16 - 10);
+		hwsf_expn = abs(sfExpn);
+
+		crf = ((width << (16 + 1)) + csw) / (2 * csw);
+		pfdet_info->recip_scale_factor[si] = crf;
+
+		rsf_mant = crf;
+		rsf_expn = 0;
+		while (rsf_mant >= 2 * 65536) {
+			rsf_mant = rsf_mant >> 1;
+			rsf_expn++;
+		}
+		hwrsf_mant = rsf_mant >> (16 - 10);
+		hwrsf_expn = rsf_expn;
+		pfdet_info->scale_factor_regs[si] = (hwrsf_mant << 17) | (hwrsf_expn << 14) | (hwsf_mant << 3) | hwsf_expn;
+
+		if (hwsf_mant == 1024 && hwsf_expn == 0) {
+			pfdet_info->scale_factor[si]		= 65472;
+			hwsf_mant				= 1023;
+			hwsf_expn				= 0;
+			pfdet_info->recip_scale_factor[si]	= 65600;
+			hwrsf_mant				= 1025;
+			hwrsf_expn				= 0;
+			pfdet_info->scale_factor_regs[si]	= (hwrsf_mant << 17) | (hwrsf_expn << 14) | (hwsf_mant << 3) | hwsf_expn;
+
+		}
+
+		csrr = (csrr * srr + (1 << 15)) >> 16;
+	}
+
+	pfdet_info->num_scales		= num_scales;
+	pfdet_info->num_sub_scales	= num_sub_scales;
+	pfdet_info->num_total_scales	= num_total_scales;
+
+	return num_total_scales;
+}
+
+int fdet_get_evaluation_ids(void)
+{
+	char				*currentPtr = pfdet_info->classifier_binary;
+	int				num_fs_classifiers, num_ts_classifiers;
+	int				i, j;
+	unsigned char			*class_stream;
+	unsigned short			num_stages;
+	unsigned int			pointer_word;
+	int				left_stream_ptr, top_stream_ptr;
+	int				cls_cache_addr = 0;
+	struct fdet_classifier_info	*p_classifier_info;
+
+	currentPtr += 34;
+	pfdet_info->classifierBinaryInfo.cls_base = *(unsigned short *)currentPtr;
+	currentPtr += 2;
+
+	num_fs_classifiers = pfdet_info->classifierBinaryInfo.num_fs_classifiers = *(unsigned short *)currentPtr;
+	currentPtr += 2;
+
+	p_classifier_info = pfdet_info->classifierBinaryInfo.fs_cls_info;
+	for (i = 0; i < num_fs_classifiers; i++) {
+		p_classifier_info[i].offset			= *(unsigned short *)(currentPtr);
+		p_classifier_info[i].sz				= *(unsigned short *)(currentPtr + 2);
+		p_classifier_info[i].left_offset		= *(unsigned short *)(currentPtr + 4);
+		p_classifier_info[i].top_offset			= *(unsigned short *)(currentPtr + 6);
+		p_classifier_info[i].orientation_bitmasks	= *(unsigned char *)(currentPtr + 8);
+		for (j = 0; j < 8; j++) {
+			p_classifier_info[i].orientation_result[j]	= *(unsigned char *)(currentPtr + 9 + j);
+		}
+		currentPtr += 18;
+	}
+
+	num_ts_classifiers = pfdet_info->classifierBinaryInfo.num_ts_classifiers = *(unsigned short *)currentPtr;
+	currentPtr += 2;
+	for (i = 0; i < num_ts_classifiers; i++) {
+		pfdet_info->classifierBinaryInfo.ts_cls_info[i].offset		= *(unsigned short *)(currentPtr);
+		pfdet_info->classifierBinaryInfo.ts_cls_info[i].sz		= *(unsigned short *)(currentPtr + 2);
+		pfdet_info->classifierBinaryInfo.ts_cls_info[i].left_offset	= *(unsigned short *)(currentPtr + 4);
+		pfdet_info->classifierBinaryInfo.ts_cls_info[i].top_offset	= *(unsigned short *)(currentPtr + 6);
+		pfdet_info->classifierBinaryInfo.ts_cls_info[i].orientation_bitmasks= *(unsigned char *)(currentPtr + 8);
+		for (j = 0; j < 8; j++) {
+			pfdet_info->classifierBinaryInfo.ts_cls_info[i].orientation_result[j]	= *(unsigned char *)(currentPtr + 9 + j);
+		}
+		currentPtr += 18;
+	}
+
+	for (i = 0; i < num_fs_classifiers; i++) {
+		class_stream	= (unsigned char *)(pfdet_info->classifier_binary + pfdet_info->classifierBinaryInfo.cls_base + (p_classifier_info[i].offset << 3));
+		num_stages	= (class_stream[0] << 8) | class_stream[1];
+		pointer_word	= (class_stream[2] << 24) | (class_stream[3] << 16) | (class_stream[4] << 8) | class_stream[5];
+		left_stream_ptr	= (pointer_word) >> 19;
+		top_stream_ptr	= (pointer_word & 0x0007ffff) >> 6;
+
+		if (i == 0) {
+			cls_cache_addr = 0;
+		} else {
+			cls_cache_addr += p_classifier_info[i - 1].sz;
+		}
+		left_stream_ptr	= cls_cache_addr + p_classifier_info[i].left_offset;
+		top_stream_ptr	= cls_cache_addr + p_classifier_info[i].top_offset;
+		pointer_word	= (left_stream_ptr << 19) | (top_stream_ptr << 6) | (pointer_word & 0x0000003f);
+		class_stream[2]	= pointer_word >> 24;
+		class_stream[3]	= (pointer_word & 0x00ff0000) >> 16;
+		class_stream[4]	= (pointer_word & 0x0000ff00) >> 8;
+		class_stream[5]	= pointer_word & 0x000000ff;
+
+		pfdet_info->evaluation_id[i] = cls_cache_addr;
+		if (pfdet_info->config.input_mode == FDET_MODE_STILL) {
+			pfdet_info->evaluation_num[i] = num_stages << 16;
+		} else {
+			pfdet_info->evaluation_num[i] = num_stages;
+		}
+	}
+
+	return 0;
+}
+
+void fdet_get_cmds_video_fs(void)
+{
+	int				si;
+	int				width, height;
+	int				row, col, rows, cols;
+	unsigned int			center_x, center_y;
+	unsigned int			*pfs_cmd_buf = (unsigned int *)pfdet_info->fs_cmd_buf[pfdet_info->current_fs_buf_id];
+	int				words = 0;
+	int				cmd_id = 0, x, y;
+	int				rx, ry, rf, merge;
+	int				si_start, num_scales;
+	int				num_evals, ei_start, ei;
+	int				cls_cache_addr;
+	int				cls_len;
+	unsigned int			cls_dram_addr;
+	unsigned char			orientation_bitmasks[4];
+	unsigned char			eval_id[4];
+	struct fdet_classifier_info	*p_classifier_info;
+
+	p_classifier_info = pfdet_info->classifierBinaryInfo.fs_cls_info;
+	for (ei = 0; ei < 3; ei++) {
+		eval_id[ei]			= ei;
+		orientation_bitmasks[ei]	= p_classifier_info[ei].orientation_bitmasks;
+	}
+
+	cls_cache_addr		= 0;
+	cls_len			= p_classifier_info[0].sz + p_classifier_info[1].sz + p_classifier_info[2].sz;
+	cls_len			= cls_len >> 1;
+	cls_dram_addr		= (unsigned int)(pfdet_info->classifier_binary) + pfdet_info->classifierBinaryInfo.cls_base + (p_classifier_info[0].offset << 3);
+	pfs_cmd_buf[words++]	= ((cls_len - 1) << (2 + 13 + 2)) | (cls_cache_addr << 2) | (0);
+	pfs_cmd_buf[words++]	= ambarella_virt_to_phys(cls_dram_addr);
+
+	for (si = pfdet_info->num_sub_scales; si < pfdet_info->num_total_scales; si++) {
+		width	= (pfdet_info->config.input_width  * pfdet_info->scale_factor[si] + (1 << 15)) >> 16;
+		height	= (pfdet_info->config.input_height * pfdet_info->scale_factor[si] + (1 << 15)) >> 16;
+		rows	= (height - FDET_TEMPLATE_SIZE / 2 + FDET_SCALED_PARTITION_SIZE - 1) / FDET_SCALED_PARTITION_SIZE;
+		cols	= (width  - FDET_TEMPLATE_SIZE / 2 + FDET_SCALED_PARTITION_SIZE - 1) / FDET_SCALED_PARTITION_SIZE;
+
+		for (row = 0; row < rows; row++) {
+			for (col = 0; col < cols; col++) {
+				center_x	= col * FDET_SCALED_PARTITION_SIZE + FDET_SCALED_PARTITION_SIZE / 2;
+				center_y	= row * FDET_SCALED_PARTITION_SIZE + FDET_SCALED_PARTITION_SIZE / 2;
+				x		= (center_x * pfdet_info->recip_scale_factor[si] + (1 << 15)) >> 16;
+				y		= (center_y * pfdet_info->recip_scale_factor[si] + (1 << 15)) >> 16;
+
+				rx		= (FDET_SCALED_PARTITION_SIZE + FDET_TEMPLATE_SIZE) / 2;
+				ry		= (FDET_SCALED_PARTITION_SIZE + FDET_TEMPLATE_SIZE) / 2;
+				rf		= 1;
+
+				merge		= 0;
+				ei_start	= 0;
+				num_evals	= FDET_NUM_EVALS;
+
+				cmd_id		+= 1;
+				si_start	= si;
+				num_scales	= 1;
+				ei		= ei_start;
+
+				pfs_cmd_buf[words++]	= (0x1 << 0) | (cmd_id << 2) | ((x & 0x3ff) << 12) | ((y & 0x3ff) << 22);
+				pfs_cmd_buf[words++]	= ((num_evals - 1) << 0) | (merge << 2) | (rf << 3) | (si_start << 4) | (((num_scales - 1) & 0x1f) << 9) | ((rx & 0x1ff) << 14) | ((ry & 0x1ff) << 23);
+
+				switch (num_evals) {
+				case 1:
+					pfs_cmd_buf[words++] = (orientation_bitmasks[ei] << 0) | (eval_id[ei] << 8);
+					break;
+
+				case 2:
+					pfs_cmd_buf[words++] = (orientation_bitmasks[ei] << 0) | (eval_id[ei] << 8) | (orientation_bitmasks[ei + 1] << 16) | (eval_id[ei + 1] << 24);
+					break;
+
+				case 3:
+					pfs_cmd_buf[words++] = (orientation_bitmasks[ei] << 0) | (eval_id[ei] << 8) | (orientation_bitmasks[ei + 1] << 16) | (eval_id[ei + 1] << 24);
+					pfs_cmd_buf[words++] = (orientation_bitmasks[ei + 2] << 0) | (eval_id[ei + 2] << 8);
+					break;
+
+				default:
+					pfs_cmd_buf[words++] = (orientation_bitmasks[ei] << 0) | (eval_id[ei] << 8) | (orientation_bitmasks[ei + 1] << 16) | (eval_id[ei + 1] << 24);
+					pfs_cmd_buf[words++] = (orientation_bitmasks[ei + 2] << 0) | (eval_id[ei + 2] << 8) | (orientation_bitmasks[ei + 3] << 16) | (eval_id[ei + 3] << 24);
+					break;
+				}
+			}
+		}
+	}
+
+	pfdet_info->current_fs_buf_sz	= words;
+	pfdet_info->last_fs_cmd_id	= cmd_id;
+}
+
+void fdet_get_cmds_video_ts(void)
+{
+	int					i, cmd_id = 0;
+	int					x, y ,radius_x, radius_y;
+	int					rf, si_start, num_scales;
+	int					num_evals;
+	int					eval_num;
+	int					words = 0;
+	int					best_oi;
+	int					merge = 0;
+	int					size, face_size;
+	unsigned int				*pts_cmd_buf;
+	struct fdet_adjacent_update_info	*padj_info;
+
+	pts_cmd_buf	= (unsigned int *)pfdet_info->ts_cmd_buf[pfdet_info->current_ts_buf_id];
+
+	if (pfdet_info->config.policy & FDET_POLICY_DISABLE_TS) {
+		pfdet_info->num_faces = 0;
+	}
+
+	for (i = 0; i < pfdet_info->num_faces; i++) {
+		x		= pfdet_info->merged_faces[i].x;
+		y		= pfdet_info->merged_faces[i].y;
+		size		= pfdet_info->merged_faces[i].sz;
+		cmd_id		+= 1;
+		radius_x	= 10 + search_radius[pfdet_info->num_faces - 1];
+		radius_y	= 10 + search_radius[pfdet_info->num_faces - 1];
+		rf		= 1;
+
+		for (si_start = pfdet_info->num_sub_scales; ; si_start++) {
+			face_size = pfdet_info->scale_factor[si_start] * size >> 16;
+			if (face_size < FDET_TEMPLATE_SIZE) {
+				break;
+			}
+		}
+		si_start	-= 2;
+		num_scales	= 4;
+		if (si_start < 0) {
+			si_start = 0;
+		}
+		if (si_start >= pfdet_info->num_total_scales) {
+			si_start = pfdet_info->num_total_scales - 1;
+		}
+		if (num_scales > pfdet_info->num_total_scales - si_start) {
+			num_scales = pfdet_info->num_total_scales - si_start;
+		}
+
+		best_oi	= pfdet_info->merged_faces[i].best_oi;
+		num_evals		= FDET_NUM_EVALS;
+		eval_num		= 0;
+		padj_info		= fdet_orientation_table[best_oi].adjacent_update_info;
+
+		pts_cmd_buf[words++]	= (0x1 << 0) | (cmd_id << 2) |  ((x & 0x3ff) << 12) | ((y & 0x3ff) << 22);
+		pts_cmd_buf[words++]	= ((num_evals - 1) << 0 ) | (merge << 2) | (rf << 3) | (si_start << 4) | (((num_scales - 1) & 0x1f) << 9) | ((radius_x & 0x1ff) << 14) | ((radius_y & 0x1ff) << 23);
+
+		switch (num_evals) {
+		case 1:
+			pts_cmd_buf[words++] = (padj_info[eval_num].orientation_bitmask << 0) | ((padj_info[eval_num].eval_id) << 8);
+			break;
+
+		case 2:
+			pts_cmd_buf[words++] = (padj_info[eval_num].orientation_bitmask << 0) | ((padj_info[eval_num].eval_id) << 8) | (padj_info[eval_num + 1].orientation_bitmask << 16) | ((padj_info[eval_num + 1].eval_id) << 24);
+			break;
+
+		case 3:
+			pts_cmd_buf[words++] = (padj_info[eval_num].orientation_bitmask << 0) | ((padj_info[eval_num].eval_id) << 8) | (padj_info[eval_num + 1].orientation_bitmask << 16) | ((padj_info[eval_num + 1].eval_id) << 24);
+			pts_cmd_buf[words++] = (padj_info[eval_num + 2].orientation_bitmask << 0) | ((padj_info[eval_num + 2].eval_id) << 8);
+			break;
+
+		default:
+			pts_cmd_buf[words++] = (padj_info[eval_num].orientation_bitmask << 0) | ((padj_info[eval_num].eval_id) << 8) | (padj_info[eval_num + 1].orientation_bitmask << 16) | ((padj_info[eval_num + 1].eval_id) << 24);
+			pts_cmd_buf[words++] = (padj_info[eval_num + 2].orientation_bitmask << 0) | ((padj_info[eval_num + 2].eval_id) << 8) | (padj_info[eval_num + 3].orientation_bitmask << 16) | ((padj_info[eval_num + 3].eval_id) << 24);
+			break;
+		}
+
+	}
+
+	pfdet_info->current_ts_buf_sz = words;
+}
+
+void fdet_get_cmds_still(void)
+{
+	unsigned int				*pts_cmd_buf = NULL;
+	int					words = 0;
+	int					cmd_id = 0, x, y;
+	int					radius_x, radius_y, rf;
+	int					merge, si_start, num_scales;
+	int					cls_cache_addr;
+	int					cls_len;
+	unsigned int				cls_dram_addr;
+	int					num_evals, ei_start, ei;
+	unsigned char				orientation_bitmasks[4];
+	unsigned char				eval_id[4];
+	struct fdet_classifier_info		*p_classifier_info;
+
+	pts_cmd_buf		= (unsigned int *)pfdet_info->ts_cmd_buf[pfdet_info->current_ts_buf_id];
+	p_classifier_info	= pfdet_info->classifierBinaryInfo.fs_cls_info;
+
+	for (ei = 0; ei <= 2; ei++) {
+		eval_id[ei]			= ei;
+		orientation_bitmasks[ei]	= p_classifier_info[ei].orientation_bitmasks;
+	}
+
+	cls_cache_addr		= 0;
+	cls_len			= p_classifier_info[0].sz + p_classifier_info[1].sz + p_classifier_info[2].sz;
+	cls_len			= cls_len >> 1;
+	cls_dram_addr		= (unsigned int)(pfdet_info->classifier_binary) + pfdet_info->classifierBinaryInfo.cls_base + (p_classifier_info[0].offset << 3);
+	pts_cmd_buf[words++]	= ((cls_len - 1) << (2 + 13 + 2)) | (cls_cache_addr << 2) | (0);
+	pts_cmd_buf[words++]	= ambarella_virt_to_phys(cls_dram_addr);
+	cmd_id			+= 1;
+	x			= pfdet_info->config.input_width / 2;
+	y			= pfdet_info->config.input_height / 2;
+	radius_x		= x - 1;
+	radius_y		= y - 1;
+	rf			= 0;
+	merge			= 0;
+	si_start		= pfdet_info->num_sub_scales;
+	num_scales		= pfdet_info->num_scales;
+	ei_start		= 0;
+	num_evals		= FDET_NUM_EVALS;
+	ei			= ei_start;
+
+	pts_cmd_buf[words++]	= (0x1 << 0) | (cmd_id << 2) |((x & 0x3ff) << 12) | ((y & 0x3ff) << 22);
+	pts_cmd_buf[words++]	= ((num_evals - 1) << 0) | (merge << 2) |	(rf << 3) | (si_start << 4) | (((num_scales - 1) & 0x1f) << 9) | ((radius_x & 0x1ff) << 14) | ((radius_y & 0x1ff) << 23);
+	pts_cmd_buf[words++]	= (orientation_bitmasks[ei] << 0) | (eval_id[ei] << 8) | (orientation_bitmasks[ei + 1] << 16) | (eval_id[ei + 1] << 24);
+	pts_cmd_buf[words++]	= (orientation_bitmasks[ei + 2] << 0) | (eval_id[ei + 2] << 8);
+
+	pfdet_info->current_ts_buf_sz = words;
+}
+
+int fdet_get_orientation_index(short eval_id, unsigned char orientation)
+{
+	if (eval_id == 0) {
+		if (orientation == 0) {
+			return 0;
+		}
+
+		return -1;
+	}
+
+	if (eval_id == 1) {
+		if (orientation == 0) {
+			return 1;
+		}
+
+		if (orientation == 1) {
+			return 2;
+		}
+
+		return -1;
+	}
+
+	if (eval_id == 2) {
+		if (orientation == 0) {
+			return 3;
+		}
+
+		if (orientation == 1) {
+			return 4;
+		}
+
+		if (orientation == 3) {
+			return 5;
+		}
+
+		if (orientation == 5) {
+			return 6;
+		}
+
+		return -1;
+	}
+
+	return -1;
+}
+
+int fdet_is_equivalent_face(int i, int j, int merged)
+{
+	struct fdet_unmerged_face	*pu;
+	struct fdet_merged_face	*pm;
+	int				distance;
+
+	pu		= pfdet_info->unmerged_faces;
+	pm		= pfdet_info->merged_faces;
+
+	if (!merged) {
+		distance	= pu[i].sz >> 2;
+
+		if (	(pu[j].x  < pu[i].x + distance) &&
+			(pu[j].x  > pu[i].x - distance) &&
+			(pu[j].y  < pu[i].y + distance) &&
+			(pu[j].y  > pu[i].y - distance) &&
+			(pu[j].sz < (pu[i].sz * 5) >> 2) &&
+			(pu[i].sz < (pu[j].sz * 5) >> 2) ) {
+			return 1;
+		} else {
+			return 0;
+		}
+	} else {
+		distance	= pm[i].sz >> 2;
+
+		if (	(pm[j].x  < pm[i].x + distance) &&
+			(pm[j].x  > pm[i].x - distance) &&
+			(pm[j].y  < pm[i].y + distance) &&
+			(pm[j].y  > pm[i].y - distance) &&
+			(pm[j].sz < (pm[i].sz * 5) >> 2) &&
+			(pm[i].sz < (pm[j].sz * 5) >> 2) ) {
+			return 1;
+		} else {
+			return 0;
+		}
+	}
+}
+
+int fdet_merge_faces(int unmerged_faces)
+{
+	int				i, j;
+	int				cluster, clusters;
+	int				hs, ths;
+	int				max_hitcount;
+	int				si, max_scales;
+	unsigned short			best_oi;
+	struct fdet_unmerged_face	*pu;
+	struct fdet_merged_face		*pm;
+
+	pu = pfdet_info->unmerged_faces;
+	pm = pfdet_info->merged_faces;
+
+	clusters = 0;
+	for (i = 0; i < unmerged_faces; i++) {
+
+		if (pu[i].cluster < 0) {
+			pu[i].cluster	= clusters;
+
+			pm[clusters].x	= pu[i].x;
+			pm[clusters].y	= pu[i].y;
+			pm[clusters].num_si[pu[i].si]++;
+			pm[clusters].hit_count[pu[i].oi]++;
+			pm[clusters].hit_sum = 1;
+
+			if (++clusters >= FDET_MAX_MERGED_FACES) {
+				break;
+			}
+		}
+
+		for (j = i + 1; j < unmerged_faces; j++) {
+			if (pu[j].cluster < 0) {
+				if (fdet_is_equivalent_face(j, i, 0)) {
+					cluster		= pu[i].cluster;
+					pu[j].cluster	= cluster;
+
+					pm[cluster].x	+= pu[j].x;
+					pm[cluster].y	+= pu[j].y;
+					pm[cluster].num_si[pu[j].si]++;
+					pm[cluster].hit_count[pu[j].oi]++;
+					pm[cluster].hit_sum++;
+				}
+			}
+		}
+	}
+
+	for (i = 0; i < clusters; i++) {
+		hs		= pm[i].hit_sum;
+		ths		= hs << 1;
+		pm[i].x		= (2 * pm[i].x  + hs) / ths;
+		pm[i].y		= (2 * pm[i].y  + hs) / ths;
+
+		si		= 0;
+		max_scales	= 0;
+		for (j = pfdet_info->num_sub_scales; j < pfdet_info->num_total_scales; j++) {
+			if (pm[i].num_si[j] > max_scales) {
+				max_scales	= pm[i].num_si[j];
+				si		= j;
+			}
+		}
+		pm[i].sz	= (FDET_TEMPLATE_SIZE * pfdet_info->recip_scale_factor[si] + (1 << 15)) >> 16;
+		pm[i].x		-= pfdet_info->recip_scale_factor[si] >> 18;
+		pm[i].y		+= pfdet_info->recip_scale_factor[si] >> 18;
+
+		max_hitcount	= 0;
+		best_oi		= 0;
+		for (j = 0; j < 7; j++) {
+			if (pm[i].hit_count[j] > max_hitcount) {
+				max_hitcount	= pm[i].hit_count[j];
+				best_oi		= j;
+			}
+		}
+		pm[i].best_oi		= best_oi;
+		pm[i].best_hitcount	= max_hitcount;
+		pm[i].type		= FDET_RESULT_TYPE_FS;
+	}
+
+	return clusters;
+}
+
+struct fdet_merged_face fdet_merge_ts_faces(int unmerged_faces)
+{
+	int				i, j, k;
+	int				oi;
+	int				x1, x2, y1, y2;
+	int				xl, xr, yl, yh;
+	struct fdet_unmerged_face	*pu;
+	struct fdet_merged_face		merged_faces;
+
+	pu = pfdet_info->ts_unmerged_faces;
+	memset(&merged_faces, 0, sizeof(merged_faces));
+
+	if (unmerged_faces <= 0) {
+		return merged_faces;
+	}
+
+	xl = -10000;
+	xr = +10000;
+	yl = -10000;
+	yh = +10000;
+
+	for (i = 0, j = 0, k = 0; i < unmerged_faces; i++) {
+		if (!k) {
+			x1 = pu[i].x - pu[i].sz / 2;
+			x2 = pu[i].x + pu[i].sz / 2;
+			y1 = pu[i].y - pu[i].sz / 2;
+			y2 = pu[i].y + pu[i].sz / 2;
+
+			x1 = max(xl, x1);
+			x2 = min(xr, x2);
+			y1 = max(yl, y1);
+			y2 = min(yh, y2);
+
+			if (x2 >= x1 && y2 >= y1) {
+				xl = x1;
+				xr = x2;
+				yl = y1;
+				yh = y2;
+				j++;
+			} else {
+				k = 1;
+			}
+		}
+
+		merged_faces.sz	+= pu[i].sz;
+		oi		=  pu[i].oi;
+		merged_faces.hit_count[oi]++;
+		merged_faces.hit_sum++;
+	}
+
+
+	merged_faces.x	= (xl + xr + 1) / 2;
+	merged_faces.y	= (yl + yh + 1) / 2;
+	merged_faces.sz	= (2 * merged_faces.sz + unmerged_faces) / (unmerged_faces << 1);
+
+	for (i = 0; i < 7; i++) {
+		if (merged_faces.hit_count[i] > merged_faces.best_hitcount) {
+			merged_faces.best_hitcount = merged_faces.hit_count[i];
+			merged_faces.best_oi = i;
+		}
+	}
+
+	return merged_faces;
+}
+
+int fdet_is_valid_hitcount(unsigned int *hit_count, const int *pth)
+{
+	int				o;
+	int				hitcount_45;
+
+	for (o = 0; o < 7; o++) {
+		if (hit_count[o] >=  pth[o]) {
+			return 1;
+		}
+	}
+
+	hitcount_45 = hit_count[3] + hit_count[5];
+	if (hitcount_45 >= pth[3]) {
+		return 1;
+	}
+
+	hitcount_45 = hit_count[4] + hit_count[6];
+	if (hitcount_45 >= pth[4]) {
+		return 1;
+	}
+
+	return 0;
+}
+
+int fdet_filter_merged_faces(int merged_faces, const int *pth)
+{
+	int				i, faces, valid;
+	struct fdet_merged_face		*pm;
+
+	pm	= pfdet_info->merged_faces;
+	faces	= 0;
+
+	for (i = 0; i < merged_faces; i++) {
+		valid = fdet_is_valid_hitcount(pm[i].hit_count, pth);
+		if (valid) {
+			pm[faces] = pm[i];
+			faces++;
+		}
+	}
+
+	return faces;
+}
+
+int fdet_eliminate_overlapping_faces(int merged_faces)
+{
+	struct fdet_merged_face		*pm;
+	int				dx, dy;
+	int				distance, threshold;
+	int				i, j;
+
+	pm	= pfdet_info->merged_faces;
+
+	for (i = 0; i < merged_faces; i++) {
+		if (!pm[i].sz) {
+			continue;
+		}
+
+		for (j = i + 1; j < merged_faces; j++) {
+			if (!pm[j].sz) {
+				continue;
+			}
+
+			dx		= abs((int)pm[i].x - (int)pm[j].x);
+			dy		= abs((int)pm[i].y - (int)pm[j].y);
+			threshold	= max(pm[i].sz, pm[j].sz) >> 1;
+
+			if (dx >= dy) {
+				if (dx > (dy << 2)) {
+					distance = (dx * 66047) >> 16;
+				} else if (dx > (dy << 1)) {
+					distance = (dx * 69992) >> 16;
+				} else if (3 * dx > (dy << 2)) {
+					distance = (dx * 77280) >> 16;
+				} else {
+					distance = (dx * 87084) >> 16;
+				}
+			} else {
+				if (dy > (dx << 2)) {
+					distance = (dy * 66047) >> 16;
+				} else if (dy > (dx << 1)) {
+					distance = (dy * 69992) >> 16;
+				} else if (3*dy > (dx << 2)) {
+					distance = (dy * 77280) >> 16;
+				} else {
+					distance = (dy * 87084) >> 16;
+				}
+			}
+
+			if (distance < threshold) {
+				if (pm[j].best_hitcount <= pm[i].best_hitcount) {
+					pm[j].sz = 0;
+				} else {
+					pm[i].sz = 0;
+				}
+			}
+		}
+	}
+
+	for (i = 0, j = 0; i < merged_faces; i++) {
+		if (pm[i].sz) {
+			pm[j++] = pm[i];
+		}
+	}
+
+	return j;
+}
+
+void fdet_print_faces(void)
+{
+	struct fdet_merged_face		*pm;
+	int				i;
+
+	pm = pfdet_info->merged_faces;
+
+	for (i = 0; i < pfdet_info->num_faces; i++) {
+		FDET_DEBUG("\tFace %2d: (%3d, %3d), Size: %3d\n", i, pm[i].x, pm[i].y, pm[i].sz);
+	}
+}
+
+int fdet_get_result_still(void)
+{
+	unsigned int			*result, words;
+	unsigned int			type, cmd_id, x, y, sz, eval_id, si, orientation, oi;
+	unsigned int			i, unmerged_faces, merged_faces;
+	struct fdet_unmerged_face	*pu;
+
+	result	= (unsigned int *)pfdet_info->ts_result_buf[pfdet_info->current_ts_result_id ^ 1];
+	invalidate_d_cache(result, FDET_TS_RESULT_BUF_SIZE);
+	words	= FDET_TS_RESULT_NUM(amba_readl(FDET_RESULT_STATUS_REG));
+
+	if (amba_readl(FDET_ERROR_STATUS_REG) & FDET_ERR_TS_RESULT_OVERFLOW
+		|| words > (FDET_TS_RESULT_BUF_SIZE >> 2)) {
+		printk("%s: Ts Result Overflow!\n", __func__);
+		words = FDET_TS_RESULT_BUF_SIZE >> 2;
+	}
+
+	unmerged_faces = 0;
+	memset(pfdet_info->unmerged_faces, 0, sizeof(pfdet_info->unmerged_faces));
+	memset(pfdet_info->merged_faces, 0, sizeof(pfdet_info->merged_faces));
+	pfdet_info->num_faces = 0;
+	pu = pfdet_info->unmerged_faces;
+	for (i = 0; i < words; i += 2) {
+		type	= (result[i] & 0x00000003) >> 0;
+		cmd_id	= (result[i] & 0x00000fff) >> 2;
+
+		if (type == 0 && cmd_id) {
+			x		= (result[i]     & 0x003ff000) >> 12;
+			y		= (result[i]     & 0xffc00000) >> 22;
+			eval_id		= (result[i + 1] & 0x0000001f) >> 0;
+			si		= (result[i + 1] & 0x00001f00) >> 8;
+			orientation	= (result[i + 1] & 0x0000e000) >> 13;
+			sz		= (FDET_TEMPLATE_SIZE * pfdet_info->recip_scale_factor[si] + (1 << 15)) >> 16;
+			oi		= fdet_get_orientation_index(eval_id, orientation);
+
+ 			if (oi >= 0) {
+				if (unmerged_faces >= FDET_MAX_UNMERGED_FACES) {
+					unmerged_faces = FDET_MAX_UNMERGED_FACES - 1;
+				}
+
+				pu[unmerged_faces].x		= x;
+				pu[unmerged_faces].y		= y;
+				pu[unmerged_faces].si		= si;
+				pu[unmerged_faces].sz		= sz;
+				pu[unmerged_faces].oi		= oi;
+				pu[unmerged_faces].cluster	= -1;
+
+				unmerged_faces++;
+			}
+		}
+	}
+	FDET_DEBUG("Unmerged Faces: %d\n", unmerged_faces);
+
+	merged_faces = fdet_merge_faces(unmerged_faces);
+	pfdet_info->num_faces = merged_faces;
+	FDET_DEBUG("Merged Faces before Hitcount Check: %d\n", merged_faces);
+
+	merged_faces = fdet_filter_merged_faces(merged_faces, hitcount_threshold_still);
+	pfdet_info->num_faces = merged_faces;
+	FDET_DEBUG("Merged Faces after  Hitcount Check: %d\n", merged_faces);
+
+	merged_faces = fdet_eliminate_overlapping_faces(merged_faces);
+	pfdet_info->num_faces = merged_faces;
+	FDET_DEBUG("Merged Faces: %d\n", merged_faces);
+
+	return merged_faces;
+}
+
+int fdet_get_result_video_fs(void)
+{
+	unsigned int			*result, words, pwords;
+	unsigned int			cmd_id, type, x, y, sz, eval_id, si, orientation, oi;
+	unsigned int			i, unmerged_faces, merged_faces = 0;
+	struct fdet_unmerged_face	*pu;
+	int				end = -1;
+	static unsigned int		offset = 0;
+	unsigned long			tick;
+
+	words	= FDET_FS_RESULT_NUM(amba_readl(FDET_RESULT_STATUS_REG));
+	if (amba_readl(FDET_ERROR_STATUS_REG) & FDET_ERR_FS_RESULT_OVERFLOW
+		|| words > (FDET_FS_RESULT_BUF_SIZE >> 2)) {
+		printk("%s: Fs Result Overflow!\n", __func__);
+		words = FDET_FS_RESULT_BUF_SIZE >> 2;
+	}
+	unmerged_faces = offset;
+	memset(pfdet_info->merged_faces, 0, sizeof(pfdet_info->merged_faces));
+	pfdet_info->num_faces = 0;
+	pu = pfdet_info->unmerged_faces;
+
+	result	= (unsigned int *)pfdet_info->fs_result_buf[pfdet_info->current_fs_result_id];
+	pwords	= FDET_FS_RESULT_BUF_SIZE >> 2;
+	invalidate_d_cache(pfdet_info->fs_result_buf[pfdet_info->current_fs_result_id], FDET_FS_RESULT_BUF_SIZE);
+	for (i = 0; i < pwords; i += 2) {
+		type	= (result[i] & 0x00000003) >> 0;
+		cmd_id	= (result[i] & 0x00000fff) >> 2;
+
+		if (type == 0 && cmd_id) {
+			x		= (result[i]     & 0x003ff000) >> 12;
+			y		= (result[i]     & 0xffc00000) >> 22;
+			eval_id		= (result[i + 1] & 0x0000001f) >> 0;
+			si		= (result[i + 1] & 0x00001f00) >> 8;
+			orientation	= (result[i + 1] & 0x0000e000) >> 13;
+			sz		= (FDET_TEMPLATE_SIZE * pfdet_info->recip_scale_factor[si] + (1 << 15)) >> 16;
+			oi		= fdet_get_orientation_index(eval_id, orientation);
+
+ 			if (oi >= 0) {
+				if (unmerged_faces >= FDET_MAX_UNMERGED_FACES) {
+					unmerged_faces = FDET_MAX_UNMERGED_FACES - 1;
+				}
+
+				pu[unmerged_faces].x		= x;
+				pu[unmerged_faces].y		= y;
+				pu[unmerged_faces].si		= si;
+				pu[unmerged_faces].sz		= sz;
+				pu[unmerged_faces].oi		= oi;
+				pu[unmerged_faces].cluster	= -1;
+				unmerged_faces++;
+			}
+		}
+
+		if (type == 2) {
+			if (cmd_id == pfdet_info->last_fs_cmd_id) {
+				end = unmerged_faces;
+			}
+		}
+	}
+	memset((void *)result, 0, pwords << 2);
+	clean_d_cache(pfdet_info->fs_result_buf[pfdet_info->current_fs_result_id], FDET_FS_RESULT_BUF_SIZE);
+
+	result	= (unsigned int *)pfdet_info->fs_result_buf[pfdet_info->current_fs_result_id ^ 1];
+	invalidate_d_cache(result, FDET_FS_RESULT_BUF_SIZE);
+	for (i = 0; i < words; i += 2) {
+		type	= (result[i] & 0x00000003) >> 0;
+		cmd_id	= (result[i] & 0x00000fff) >> 2;
+
+		if (type == 0 && cmd_id) {
+			x		= (result[i]     & 0x003ff000) >> 12;
+			y		= (result[i]     & 0xffc00000) >> 22;
+			eval_id		= (result[i + 1] & 0x0000001f) >> 0;
+			si		= (result[i + 1] & 0x00001f00) >> 8;
+			orientation	= (result[i + 1] & 0x0000e000) >> 13;
+			sz		= (FDET_TEMPLATE_SIZE * pfdet_info->recip_scale_factor[si] + (1 << 15)) >> 16;
+			oi		= fdet_get_orientation_index(eval_id, orientation);
+
+ 			if (oi >= 0) {
+				if (unmerged_faces >= FDET_MAX_UNMERGED_FACES) {
+					unmerged_faces = FDET_MAX_UNMERGED_FACES - 1;
+				}
+
+				pu[unmerged_faces].x		= x;
+				pu[unmerged_faces].y		= y;
+				pu[unmerged_faces].si		= si;
+				pu[unmerged_faces].sz		= sz;
+				pu[unmerged_faces].oi		= oi;
+				pu[unmerged_faces].cluster	= -1;
+				unmerged_faces++;
+			}
+		}
+
+		if (type == 2) {
+			if (cmd_id == pfdet_info->last_fs_cmd_id) {
+				end = unmerged_faces;
+			}
+		}
+	}
+	memset((void *)result, 0, words << 2);
+	clean_d_cache((void *)result, words << 2);
+
+	if (end >= 0) {
+		pfdet_info->fs_found_faces[0] = pfdet_info->fs_found_faces[1];
+		pfdet_info->fs_found_faces[1] = 0;
+	}
+
+	if (end >= 0 && pfdet_info->config.policy & FDET_POLICY_MEASURE_TIME) {
+		tick			= jiffies;
+		printk("Fs used time: %lu ms\n", 1000 * (tick - pfdet_info->fs_tick) / HZ);
+		pfdet_info->fs_tick	= tick;
+	}
+
+	FDET_DEBUG("Unmerged Faces: %d\n", unmerged_faces);
+
+	if ((pfdet_info->config.policy & FDET_POLICY_WAIT_FS_COMPLETE) == 0) {
+		end = unmerged_faces;
+	}
+
+	if (end < 0) {
+		offset = unmerged_faces;
+		goto fdet_get_result_video_fs_exit;
+	}
+
+	merged_faces = fdet_merge_faces(end);
+	pfdet_info->num_faces = merged_faces;
+	FDET_DEBUG("Merged Faces before Hitcount Check: %d\n", merged_faces);
+
+	merged_faces = fdet_filter_merged_faces(merged_faces, hitcount_threshold_video);
+	pfdet_info->num_faces = merged_faces;
+	FDET_DEBUG("Merged Faces after  Hitcount Check: %d\n", merged_faces);
+
+	merged_faces = fdet_eliminate_overlapping_faces(merged_faces);
+	pfdet_info->num_faces = merged_faces;
+	FDET_DEBUG("Merged Faces: %d\n", merged_faces);
+
+	if (merged_faces) {
+		pfdet_info->fs_found_faces[1]++;
+	}
+
+	offset = unmerged_faces - end;
+	memcpy(pu, &pu[end], offset * sizeof(struct fdet_unmerged_face));
+
+fdet_get_result_video_fs_exit:
+	return merged_faces;
+}
+
+int fdet_get_result_video_ts(void)
+{
+	int				words, i, hit;
+	unsigned int			wi, type;
+	unsigned int			x = 0, y = 0;
+	unsigned int			cmd_id, size = 0;
+	unsigned int			eval_id, si, orientation_mode;
+	int				oi, faces = pfdet_info->num_faces;
+	unsigned int			*result;
+	unsigned int			result_status, error_status;
+	int				unmerged_faces = 0;
+	struct fdet_unmerged_face	*pu;
+	struct fdet_merged_face		*pm, *pl;
+
+	result_status	= amba_readl(FDET_RESULT_STATUS_REG);
+	error_status	= amba_readl(FDET_ERROR_STATUS_REG);
+	words		= FDET_TS_RESULT_NUM(result_status);
+	pu		= pfdet_info->ts_unmerged_faces;
+	pm		= pfdet_info->merged_faces;
+	pl		= pfdet_info->latest_faces;
+
+	FDET_DEBUG("%s: result status: 0x%08x, error status: 0x%08x\n", __func__, result_status, error_status);
+
+	if (error_status & FDET_ERR_TS_TOO_LONG || error_status & FDET_ERR_TS_MERGE_OVERFLOW) {
+		goto fdet_get_result_video_ts_exit;
+	}
+
+	if (error_status & FDET_ERR_TS_RESULT_OVERFLOW || words > (FDET_TS_RESULT_BUF_SIZE >> 2)) {
+		words = FDET_TS_RESULT_BUF_SIZE >> 2;
+	}
+
+	result = (unsigned int *)pfdet_info->ts_result_buf[pfdet_info->current_ts_result_id ^ 1];
+	invalidate_d_cache(result, FDET_TS_RESULT_BUF_SIZE);
+	for (wi = 0; wi < words; wi += 2) {
+		type	= (result[wi] & 0x00000003) >> 0;
+		cmd_id	= (result[wi] & 0x00000fff) >> 2;
+
+		if (!cmd_id) {
+			continue;
+		}
+
+		if (type == 0) {
+			x		= (result[wi]     & 0x003ff000) >> 12;
+			y		= (result[wi]     & 0xffc00000) >> 22;
+			eval_id		= (result[wi + 1] & 0x0000001f) >> 0;
+			si		= (result[wi + 1] & 0x00001f00) >> 8;
+			orientation_mode= (result[wi + 1] & 0x0000e000) >> 13;
+			size		= (FDET_TEMPLATE_SIZE * pfdet_info->recip_scale_factor[si] + (1 << 15)) >> 16;
+
+			if (unmerged_faces > FDET_MAX_UNMERGED_FACES - 1) {
+				unmerged_faces = FDET_MAX_UNMERGED_FACES - 1;
+			}
+
+			oi = fdet_get_orientation_index(eval_id, orientation_mode);
+			if (oi >= 0) {
+				pu[unmerged_faces].x		= x;
+				pu[unmerged_faces].y		= y;
+				pu[unmerged_faces].sz		= size;
+				pu[unmerged_faces].cluster	= -1;
+				pu[unmerged_faces].oi		= oi;
+				unmerged_faces++;
+			}
+		}
+
+		if (type == 2) {
+			struct fdet_merged_face merged_faces;
+
+			merged_faces = fdet_merge_ts_faces(unmerged_faces);
+
+			if (merged_faces.hit_sum >= 15 && pfdet_info->fs_found_faces[0]) {
+				if (abs(merged_faces.x - pl[cmd_id - 1].x) < merged_faces.sz / FDET_TEMPLATE_SIZE &&
+					abs(merged_faces.y - pl[cmd_id - 1].y) < merged_faces.sz / FDET_TEMPLATE_SIZE &&
+					5 * merged_faces.sz > 4 * pl[cmd_id - 1].sz &&
+					4 * merged_faces.sz < 5 * pl[cmd_id - 1].sz) {
+					pm[faces].x		= pl[cmd_id - 1].x;
+					pm[faces].y		= pl[cmd_id - 1].y;
+					pm[faces].sz		= pl[cmd_id - 1].sz;
+					pm[faces].best_oi	= merged_faces.best_oi;
+				} else {
+					pm[faces]		= merged_faces;
+				}
+
+				hit = 0;
+				for (i = 0; i < pfdet_info->num_faces; i++) {
+					if (fdet_is_equivalent_face(i, faces, 1)) {
+						hit = 1;
+						break;
+					}
+				}
+
+				if (!hit) {
+					pm[faces].type		= FDET_RESULT_TYPE_TS;
+					faces++;
+				}
+			}
+
+			unmerged_faces = 0;
+			memset(pu, 0, sizeof(pfdet_info->unmerged_faces));
+		}
+	}
+
+	if (faces) {
+		faces = fdet_eliminate_overlapping_faces(faces);
+	}
+
+	pfdet_info->num_faces = faces;
+
+fdet_get_result_video_ts_exit:
+	return faces;
+}
+
+static int fdet_open(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static int fdet_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static int fdet_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	int			ret;
+
+	switch (pfdet_info->mmap_type) {
+	case FDET_MMAP_TYPE_ORIG_BUFFER:
+		vma->vm_pgoff = ambarella_virt_to_phys((u32)pfdet_info->orig_target_buf) >> PAGE_SHIFT;
+		pfdet_info->orig_len = vma->vm_end - vma->vm_start;
+		FDET_DEBUG("%s: Orig Buffer Address: 0x%08x\n", __func__, (unsigned int)(vma->vm_pgoff << PAGE_SHIFT));
+		break;
+
+	case FDET_MMAP_TYPE_TMP_BUFFER:
+		vma->vm_pgoff = ambarella_virt_to_phys((u32)pfdet_info->tmp_target_buf) >> PAGE_SHIFT;
+		FDET_DEBUG("%s: Tmp Buffer Address: 0x%08x\n", __func__, (unsigned int)(vma->vm_pgoff << PAGE_SHIFT));
+		break;
+
+	default:
+		vma->vm_pgoff = ambarella_virt_to_phys((u32)pfdet_info->classifier_binary) >> PAGE_SHIFT;
+		pfdet_info->cls_bin_len = vma->vm_end - vma->vm_start;
+		FDET_DEBUG("%s: Classifier Binary Address: 0x%08x\n", __func__, (unsigned int)(vma->vm_pgoff << PAGE_SHIFT));
+		break;
+	}
+
+	ret = remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff, vma->vm_end - vma->vm_start, vma->vm_page_prot);
+
+	return ret;
+}
+
+void fdet_config(void)
+{
+	char			*pfs_result_buf;
+	char			*pts_cmd_buf, *pts_result_buf;
+	char			*ptmp_target_buf;
+	unsigned int		*p2;
+	u32			p[6];
+	int			i;
+
+	FDET_DEBUG("%s: \n", __func__);
+
+	pfs_result_buf	= pfdet_info->fs_result_buf[pfdet_info->current_fs_result_id];
+	pts_cmd_buf	= pfdet_info->ts_cmd_buf[pfdet_info->current_ts_buf_id];
+	pts_result_buf	= pfdet_info->ts_result_buf[pfdet_info->current_ts_result_id];
+	ptmp_target_buf	= pfdet_info->tmp_target_buf + (FDET_TMP_TARGET_BUF_SIZE / 2) * pfdet_info->current_tmp_target_id;
+	p2		= (unsigned int *)pts_cmd_buf;
+
+	p[1]		= ambarella_virt_to_phys((u32)pfs_result_buf);
+	p[2]		= ambarella_virt_to_phys((u32)pts_cmd_buf);
+	p[3]		= ambarella_virt_to_phys((u32)pts_result_buf);
+	p[4]		= ambarella_virt_to_phys((u32)pfdet_info->orig_target_buf);
+	p[5]		= ambarella_virt_to_phys((u32)ptmp_target_buf);
+
+	FDET_DEBUG("\tTracking Search Command Buffer Size: %d\n", pfdet_info->current_ts_buf_sz);
+	for (i = 0; i < pfdet_info->current_ts_buf_sz; i++) {
+		FDET_DEBUG("\t\tTs Command Word[%02d]: 0x%08x\n", i, p2[i]);
+	}
+	clean_d_cache(pts_cmd_buf, pfdet_info->current_ts_buf_sz << 2);
+
+	amba_writel(FDET_FS_RESULT_BUF_PTR_REG, p[1]);
+	amba_writel(FDET_FS_RESULT_BUF_SIZE_REG, (FDET_FS_RESULT_BUF_SIZE >> 2) - 1);
+	FDET_DEBUG("\t fs result buffer pointer:   0x%08x\n", p[1]);
+
+	amba_writel(FDET_TS_CMD_LIST_PTR_REG, p[2]);
+	if (pfdet_info->current_ts_buf_sz) {
+		amba_writel(FDET_TS_CMD_LIST_SIZE_REG, pfdet_info->current_ts_buf_sz - 1);
+	} else {
+		amba_writel(FDET_TS_CMD_LIST_SIZE_REG, 0);
+	}
+	FDET_DEBUG("\t ts cmd list pointer:        0x%08x\n", p[2]);
+
+	memset(pts_result_buf, 0, FDET_TS_RESULT_BUF_SIZE);
+	clean_d_cache(pts_result_buf, FDET_TS_RESULT_BUF_SIZE);
+	amba_writel(FDET_TS_RESULT_BUF_PTR_REG, p[3]);
+	amba_writel(FDET_TS_RESULT_BUF_SIZE_REG, (FDET_TS_RESULT_BUF_SIZE >> 2) - 1);
+	FDET_DEBUG("\t ts result buffer pointer:   0x%08x\n", p[3]);
+
+	if (pfdet_info->config.input_source) {
+		amba_writel(FDET_ORIG_TARGET_PTR_REG, DSP_DRAM_START + pfdet_info->config.input_offset);
+		amba_writel(FDET_ORIG_TARGET_PITCH_REG, pfdet_info->config.input_pitch);
+		FDET_DEBUG("\t orig buffer pointer:        0x%08x\n", DSP_DRAM_START + pfdet_info->config.input_offset);
+	} else {
+		amba_writel(FDET_ORIG_TARGET_PTR_REG, p[4]);
+		amba_writel(FDET_ORIG_TARGET_PITCH_REG, pfdet_info->config.input_pitch);
+		FDET_DEBUG("\t orig buffer pointer:        0x%08x\n", p[4]);
+		clean_d_cache(pfdet_info->orig_target_buf, pfdet_info->orig_len);
+	}
+
+	memset(ptmp_target_buf, 0, FDET_TMP_TARGET_BUF_SIZE / 2);
+	clean_d_cache(ptmp_target_buf, FDET_TMP_TARGET_BUF_SIZE / 2);
+	amba_writel(FDET_TMP_TARGET_PTR_REG, p[5]);
+	FDET_DEBUG("\t tmp buffer pointer:         0x%08x\n", p[5]);
+
+	pfdet_info->current_fs_result_id	^= 1;
+	pfdet_info->current_ts_buf_id		^= 1;
+	pfdet_info->current_ts_result_id	^= 1;
+	pfdet_info->current_tmp_target_id	^= 1;
+	pfdet_info->current_ts_buf_sz		 = 0;
+
+	amba_writel(FDET_CONFIG_DONE_REG, FDET_CONFIG_DONE);
+}
+
+static int fdet_start_video(unsigned long arg)
+{
+	char			*pfs_cmd_buf;
+	unsigned int		*p2;
+	u32			p;
+	int			i, ret;
+
+	FDET_DEBUG("%s: \n", __func__);
+
+	amba_writel(FDET_BASE_ADDRESS_REG, FDET_CONFIG_BASE_NORMAL);
+	amba_writel(FDET_INPUT_WIDTH_REG, pfdet_info->config.input_width - 1);
+	amba_writel(FDET_INPUT_HEIGHT_REG, pfdet_info->config.input_height - 1);
+	FDET_DEBUG("\t input width: %d, input height: %d\n",
+		pfdet_info->config.input_width, pfdet_info->config.input_height);
+	amba_writel(FDET_DEADLINE_REG, 1);
+	amba_writel(FDET_SKIP_FIRST_INT_REG, FDET_SKIP_FIRST_INTERRUPT);
+
+	/* Scale Factors */
+	ret = fdet_get_sf(pfdet_info->config.input_width, pfdet_info->config.input_height);
+	if (ret <= 0) {
+		return -EINVAL;
+	}
+	FDET_DEBUG("\tFace Scales: %d, Sub Face Scales: %d\n", pfdet_info->num_scales, pfdet_info->num_sub_scales);
+	for (i = 0; i < 32; i++) {
+		amba_writel(FDET_SCALE_FACTOR_REG(i), pfdet_info->scale_factor_regs[i]);
+		FDET_DEBUG("\t\tScale Factor[%02d]: 0x%08x\n", i, pfdet_info->scale_factor_regs[i]);
+	}
+
+	/* Evaluation IDs */
+	ret = fdet_get_evaluation_ids();
+	if (ret < 0) {
+		return -EINVAL;
+	}
+	FDET_DEBUG("\tFace Fs Classifiers: %d, Face Ts Classifiers: %d\n",
+		pfdet_info->classifierBinaryInfo.num_fs_classifiers,
+		pfdet_info->classifierBinaryInfo.num_ts_classifiers);
+	for (i = 0; i < 32; i++) {
+		amba_writel(FDET_EVALUATION_ID_REG(i), pfdet_info->evaluation_id[i]);
+		FDET_DEBUG("\t\tEvaluation  ID[%02d]: 0x%08x\n", i, pfdet_info->evaluation_id[i]);
+	}
+#ifdef FDET_HAVE_EVAL_NUM_REGS
+	for (i = 0; i < 32; i++) {
+		amba_writel(FDET_EVALUATION_NUM_REG(i), pfdet_info->evaluation_num[i]);
+		FDET_DEBUG("\t\tEvaluation NUM[%02d]: 0x%08x\n", i, pfdet_info->evaluation_num[i]);
+	}
+#endif
+
+	/* Full Search Command Buffer */
+	pfs_cmd_buf	= pfdet_info->fs_cmd_buf[pfdet_info->current_fs_buf_id];
+	p2		= (unsigned int *)pfs_cmd_buf;
+	p		= ambarella_virt_to_phys((u32)pfs_cmd_buf);
+	fdet_get_cmds_video_fs();
+	pfdet_info->current_fs_buf_id	^= 1;
+	FDET_DEBUG("\tFull Search Command Buffer Size: %d\n", pfdet_info->current_fs_buf_sz);
+	for (i = 0; i < 32; i++) {
+		FDET_DEBUG("\t\tFs Command Word[%02d]: 0x%08x\n", i, p2[i]);
+	}
+	for (i = pfdet_info->current_fs_buf_sz - 32; i < pfdet_info->current_fs_buf_sz; i++) {
+		FDET_DEBUG("\t\tFs Command Word[%02d]: 0x%08x\n", i, p2[i]);
+	}
+	clean_d_cache(pfs_cmd_buf, pfdet_info->current_fs_buf_sz << 2);
+	clean_d_cache(pfdet_info->classifier_binary, pfdet_info->cls_bin_len);
+
+	amba_writel(FDET_FS_CMD_LIST_PTR_REG, p);
+	amba_writel(FDET_FS_CMD_LIST_SIZE_REG, pfdet_info->current_fs_buf_sz - 1);
+	FDET_DEBUG("\t fs cmd list pointer:        0x%08x\n", p);
+
+	pfdet_info->current_ts_buf_sz = 0;
+	fdet_config();
+
+	pfdet_info->vm_state = FDET_VM_STATE_IDLE;
+	init_completion(&pfdet_info->result_completion);
+	pfdet_info->fs_tick = jiffies;
+
+	amba_writel(FDET_GO_REG, FDET_START);
+
+	return 0;
+}
+
+static int fdet_start_still(unsigned long arg)
+{
+	char			*pfs_cmd_buf;
+	u32			p;
+	int			i, ret;
+
+	FDET_DEBUG("%s: \n", __func__);
+
+	amba_writel(FDET_BASE_ADDRESS_REG, FDET_CONFIG_BASE_NORMAL);
+	amba_writel(FDET_INPUT_WIDTH_REG, pfdet_info->config.input_width - 1);
+	amba_writel(FDET_INPUT_HEIGHT_REG, pfdet_info->config.input_height - 1);
+	FDET_DEBUG("\t input width: %d, input height: %d\n",
+		pfdet_info->config.input_width, pfdet_info->config.input_height);
+	amba_writel(FDET_DEADLINE_REG, 0);
+	amba_writel(FDET_SKIP_FIRST_INT_REG, FDET_SKIP_FIRST_INTERRUPT);
+
+	/* Scale Factors */
+	ret = fdet_get_sf(pfdet_info->config.input_width, pfdet_info->config.input_height);
+	if (ret <= 0) {
+		return -EINVAL;
+	}
+	FDET_DEBUG("\tFace Scales: %d, Sub Face Scales: %d\n", pfdet_info->num_scales, pfdet_info->num_sub_scales);
+	for (i = 0; i < 32; i++) {
+		amba_writel(FDET_SCALE_FACTOR_REG(i), pfdet_info->scale_factor_regs[i]);
+		FDET_DEBUG("\t\tScale Factor[%02d]: 0x%08x\n", i, pfdet_info->scale_factor_regs[i]);
+	}
+
+	/* Evaluation IDs */
+	ret = fdet_get_evaluation_ids();
+	if (ret < 0) {
+		return -EINVAL;
+	}
+	FDET_DEBUG("\tFace Fs Classifiers: %d, Face Ts Classifiers: %d\n",
+		pfdet_info->classifierBinaryInfo.num_fs_classifiers,
+		pfdet_info->classifierBinaryInfo.num_ts_classifiers);
+	for (i = 0; i < 32; i++) {
+		amba_writel(FDET_EVALUATION_ID_REG(i), pfdet_info->evaluation_id[i]);
+		FDET_DEBUG("\t\tEvaluation  ID[%02d]: 0x%08x\n", i, pfdet_info->evaluation_id[i]);
+	}
+#ifdef FDET_HAVE_EVAL_NUM_REGS
+	for (i = 0; i < 32; i++) {
+		amba_writel(FDET_EVALUATION_NUM_REG(i), pfdet_info->evaluation_num[i]);
+		FDET_DEBUG("\t\tEvaluation NUM[%02d]: 0x%08x\n", i, pfdet_info->evaluation_num[i]);
+	}
+#endif
+
+	/* Tracking Search Command Buffer */
+	fdet_get_cmds_still();
+	clean_d_cache(pfdet_info->classifier_binary, pfdet_info->cls_bin_len);
+
+	pfs_cmd_buf	= pfdet_info->fs_cmd_buf[pfdet_info->current_fs_buf_id];
+	p		= ambarella_virt_to_phys((u32)pfs_cmd_buf);
+	pfdet_info->current_fs_buf_id	^= 1;
+	amba_writel(FDET_FS_CMD_LIST_PTR_REG, p);
+	amba_writel(FDET_FS_CMD_LIST_SIZE_REG, 0);
+	FDET_DEBUG("\t fs cmd list pointer:        0x%08x\n", p);
+
+	init_completion(&pfdet_info->result_completion);
+	fdet_config();
+	amba_writel(FDET_GO_REG, FDET_START);
+
+	return 0;
+}
+
+static int fdet_stop(unsigned long arg)
+{
+	amba_writel(FDET_GO_REG, FDET_STOP);
+	complete_all(&pfdet_info->result_completion);
+
+	return 0;
+}
+
+static int fdet_get_result(unsigned long arg)
+{
+	struct fdet_merged_face		*pm;
+	int				i, ret;
+	struct fdet_face		faces[FDET_MAX_FACES];
+
+	wait_for_completion_interruptible(&pfdet_info->result_completion);
+
+	pm = pfdet_info->merged_faces;
+
+	for (i = 0; i < pfdet_info->num_faces; i++) {
+		faces[i].x	= pm[i].x;
+		faces[i].y	= pm[i].y;
+		faces[i].size	= pm[i].sz;
+		faces[i].type	= pm[i].type;
+	}
+
+	ret = copy_to_user((void *)arg, faces, i * sizeof(struct fdet_face));
+	if (ret < 0) {
+		i = -EINVAL;
+	}
+
+	return i;
+}
+
+static int fdet_set_mmap_type(unsigned long arg)
+{
+	switch (arg) {
+	case FDET_MMAP_TYPE_ORIG_BUFFER:
+	case FDET_MMAP_TYPE_TMP_BUFFER:
+	case FDET_MMAP_TYPE_CLASSIFIER_BINARY:
+		pfdet_info->mmap_type = arg;
+		return 0;
+
+	default:
+		printk("%s: Invalid mmap type!\n", __func__);
+		return -EINVAL;
+	}
+}
+
+static int fdet_set_configuration(unsigned long arg)
+{
+	int				ret = 0;
+	struct fdet_configuration	cfg;
+
+	ret = copy_from_user(&cfg, (void *)arg, sizeof(cfg));
+	if (ret < 0) {
+		printk("%s: Error occurred when copying argument from user space!\n", __func__);
+		goto fdet_set_configuration_exit;
+	}
+
+	if (cfg.input_width > FDET_MAX_INPUT_WIDTH || cfg.input_height > FDET_MAX_INPUT_HEIGHT) {
+		printk("%s: Invalid input width or height!\n", __func__);
+		ret = -EINVAL;
+		goto fdet_set_configuration_exit;
+	}
+
+	if (cfg.input_mode != FDET_MODE_VIDEO && cfg.input_mode != FDET_MODE_STILL) {
+		printk("%s: Invalid input mode!\n", __func__);
+		ret = -EINVAL;
+		goto fdet_set_configuration_exit;
+	}
+
+	memcpy(&pfdet_info->config, &cfg, sizeof(cfg));
+
+fdet_set_configuration_exit:
+	return ret;
+}
+
+static int fdet_track_face(unsigned long arg)
+{
+	if (pfdet_info->vm_state == FDET_VM_STATE_IDLE) {
+		return -EINVAL;
+	} else {
+		pfdet_info->vm_state = FDET_VM_STATE_RUNNING;
+	}
+
+	pfdet_info->config.input_offset = arg;
+	fdet_get_cmds_video_ts();
+	pfdet_info->ts_tick = jiffies;
+	fdet_config();
+
+	return 0;
+}
+
+static long fdet_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int		ret = -ENOIOCTLCMD;
+
+	switch (cmd) {
+	case FDET_IOCTL_START:
+		if (pfdet_info->config.input_mode == FDET_MODE_VIDEO) {
+			ret = fdet_start_video(arg);
+		} else {
+			ret = fdet_start_still(arg);
+		}
+		break;
+
+	case FDET_IOCTL_STOP:
+		ret = fdet_stop(arg);
+		break;
+
+	case FDET_IOCTL_GET_RESULT:
+		ret = fdet_get_result(arg);
+		break;
+
+	case FDET_IOCTL_SET_MMAP_TYPE:
+		ret = fdet_set_mmap_type(arg);
+		break;
+
+	case FDET_IOCTL_SET_CONFIGURATION:
+		ret = fdet_set_configuration(arg);
+		break;
+
+	case FDET_IOCTL_TRACK_FACE:
+		ret = fdet_track_face(arg);
+		break;
+
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static struct file_operations fdet_fops = {
+	.owner			= THIS_MODULE,
+	.unlocked_ioctl		= fdet_ioctl,
+	.mmap			= fdet_mmap,
+	.open			= fdet_open,
+	.release		= fdet_release
+};
+
+/* ========================================================================== */
+static int __init amba_fdet_init(void)
+{
+	int		ret = 0;
+//	u32		val;
+	dev_t		dev_id;
+
+	pfdet_info = kzalloc(sizeof(*pfdet_info), GFP_KERNEL);
+	if (!pfdet_info) {
+		printk("%s: Fail to allocate fdet info!\n", __func__);
+		ret = -ENOMEM;
+		goto amba_fdet_init_exit;
+	} else {
+		pfdet_info->mmap_type = FDET_MMAP_TYPE_CLASSIFIER_BINARY;
+	}
+
+	pfdet_info->orig_target_buf = kzalloc(FDET_ORIG_TARGET_BUF_SIZE, GFP_KERNEL);
+	if (!pfdet_info->orig_target_buf) {
+		printk("%s: Fail to allocate orig buffer!\n", __func__);
+		ret = -ENOMEM;
+		goto amba_fdet_init_exit;
+	}
+
+	pfdet_info->tmp_target_buf = kzalloc(FDET_TMP_TARGET_BUF_SIZE, GFP_KERNEL);
+	if (!pfdet_info->tmp_target_buf) {
+		printk("%s: Fail to allocate tmp buffer!\n", __func__);
+		ret = -ENOMEM;
+		goto amba_fdet_init_exit;
+	}
+
+	pfdet_info->classifier_binary = kzalloc(FDET_CLASSIFIER_BINARY_SIZE, GFP_KERNEL);
+	if (!pfdet_info->classifier_binary) {
+		printk("%s: Fail to allocate classifier binary buffer!\n", __func__);
+		ret = -ENOMEM;
+		goto amba_fdet_init_exit;
+	}
+
+
+	pfdet_info->irq = FDET_IRQ;
+	ret = request_irq(pfdet_info->irq, amba_fdet_isr, FDET_IRQF, "fdet", pfdet_info);
+
+	if (ret) {
+		printk("%s: Fail to request fdet irq!\n", __func__);
+		pfdet_info->irq = 0;
+		goto amba_fdet_init_exit;
+	}
+
+	/*val	= amba_readl(RCT_REG(0x54));
+	val	&= 0x00ffffff;
+	val	|= 0x70000000;
+	amba_writel(RCT_REG(0x54), val | 0x1);
+	amba_writel(RCT_REG(0x54), val);
+	amba_writel(RCT_REG(0x234), 0x01);*/
+
+#if defined(CONFIG_PLAT_AMBARELLA_SUPPORT_HAL)
+	printk("%s: Fdet Freq: %d MHz.\n", __func__, amb_get_fdet_clock_frequency(HAL_BASE_VP) / 1000000);
+#else
+#error "Not supported!"
+#endif
+
+	ret = amba_enable_fdet();
+	if (ret) {
+		goto amba_fdet_init_exit;
+	}
+
+	dev_id = MKDEV(FDET_MAJOR, FDET_MINOR);
+	ret = register_chrdev_region(dev_id, 1, FDET_NAME);
+	if (ret) {
+		goto amba_fdet_init_exit;
+	}
+
+	cdev_init(&pfdet_info->char_dev, &fdet_fops);
+	pfdet_info->char_dev.owner = THIS_MODULE;
+	ret = cdev_add(&pfdet_info->char_dev, dev_id, 1);
+	if (ret) {
+		unregister_chrdev_region(dev_id, 1);
+		goto amba_fdet_init_exit;
+	}
+
+	pfdet_info->timer.function	= fdet_timer;
+	pfdet_info->timer.data		= 0;
+	init_timer(&pfdet_info->timer);
+
+	init_completion(&pfdet_info->result_completion);
+
+amba_fdet_init_exit:
+ 	if (ret && pfdet_info) {
+		if (pfdet_info->irq) {
+			free_irq(pfdet_info->irq, pfdet_info);
+		}
+		if (pfdet_info->classifier_binary) {
+			kfree(pfdet_info->classifier_binary);
+			pfdet_info->classifier_binary = NULL;
+		}
+		if (pfdet_info->tmp_target_buf) {
+			kfree(pfdet_info->tmp_target_buf);
+			pfdet_info->tmp_target_buf = NULL;
+		}
+		if (pfdet_info->orig_target_buf) {
+			kfree(pfdet_info->orig_target_buf);
+			pfdet_info->orig_target_buf = NULL;
+		}
+		kfree(pfdet_info);
+		pfdet_info = NULL;
+	}
+	return ret;
+}
+
+static void __exit amba_fdet_exit(void)
+{
+	dev_t		dev_id;
+
+	amba_disable_fdet();
+	if (pfdet_info) {
+		if (pfdet_info->irq) {
+			free_irq(pfdet_info->irq, pfdet_info);
+		}
+
+		cdev_del(&pfdet_info->char_dev);
+
+		dev_id = MKDEV(FDET_MAJOR, FDET_MINOR);
+		unregister_chrdev_region(dev_id, 1);
+
+		if (pfdet_info->classifier_binary) {
+			kfree(pfdet_info->classifier_binary);
+			pfdet_info->classifier_binary = NULL;
+		}
+		if (pfdet_info->tmp_target_buf) {
+			kfree(pfdet_info->tmp_target_buf);
+			pfdet_info->tmp_target_buf = NULL;
+		}
+		if (pfdet_info->orig_target_buf) {
+			kfree(pfdet_info->orig_target_buf);
+			pfdet_info->orig_target_buf = NULL;
+		}
+
+		kfree(pfdet_info);
+		pfdet_info = NULL;
+	}
+}
+
+module_init(amba_fdet_init);
+module_exit(amba_fdet_exit);
+
+MODULE_DESCRIPTION("Ambarella A7 / S2 Fdet driver");
+MODULE_AUTHOR("Zhenwu Xue, <zwxue@ambarella.com>");
+MODULE_LICENSE("Proprietary");
+
diff --git a/drivers/fdet/fdet.h b/drivers/fdet/fdet.h
new file mode 100644
index 0000000..74aaf14
--- /dev/null
+++ b/drivers/fdet/fdet.h
@@ -0,0 +1,190 @@
+/*
+ * ambhw/fdet.h
+ *
+ * History:
+ *	2012/06/28 - [Zhenwu Xue] created file
+ *
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+
+#ifndef __AMBHW__FDET__
+#define __AMBHW__FDET__
+
+#include <ambhw/chip.h>
+#include <ambhw/busaddr.h>
+
+#define FDET_BASE_ADDRESS_OFFSET	0x00
+#define FDET_ENABLE_OFFSET		0x04
+#define FDET_GO_OFFSET			0x08
+#define FDET_CONFIG_DONE_OFFSET		0x0C
+#define FDET_RESET_OFFSET		0x10
+#define FDET_INPUT_WIDTH_OFFSET		0x14
+#define FDET_INPUT_HEIGHT_OFFSET	0x18
+
+#if (CHIP_REV == A7)
+#define FDET_DEADLINE_OFFSET		0x1C
+#define FDET_SKIP_FIRST_INT_OFFSET	0x20
+#define FDET_FS_CMD_LIST_PTR_OFFSET	0x24
+#define FDET_FS_CMD_LIST_SIZE_OFFSET	0x28
+#define FDET_FS_RESULT_BUF_PTR_OFFSET	0x2C
+#define FDET_FS_RESULT_BUF_SIZE_OFFSET	0x30
+#define FDET_TS_CMD_LIST_PTR_OFFSET	0x34
+#define FDET_TS_CMD_LIST_SIZE_OFFSET	0x38
+#define FDET_TS_RESULT_BUF_PTR_OFFSET	0x3C
+#define FDET_TS_RESULT_BUF_SIZE_OFFSET	0x40
+#define FDET_ORIG_TARGET_PTR_OFFSET	0x44
+#define FDET_ORIG_TARGET_PITCH_OFFSET	0x48
+#define FDET_TMP_TARGET_PTR_OFFSET	0x4C
+#define FDET_SEND_DEADLINE_INT_OFFSET	0x50
+#else
+#define FDET_DEADLINE_OFFSET		0x20
+#define FDET_SKIP_FIRST_INT_OFFSET	0x1C
+#define FDET_SEND_DEADLINE_INT_OFFSET	0x24
+#define FDET_FS_CMD_LIST_PTR_OFFSET	0x28
+#define FDET_FS_CMD_LIST_SIZE_OFFSET	0x2C
+#define FDET_FS_RESULT_BUF_PTR_OFFSET	0x30
+#define FDET_FS_RESULT_BUF_SIZE_OFFSET	0x34
+#define FDET_TS_CMD_LIST_PTR_OFFSET	0x38
+#define FDET_TS_CMD_LIST_SIZE_OFFSET	0x3C
+#define FDET_TS_RESULT_BUF_PTR_OFFSET	0x40
+#define FDET_TS_RESULT_BUF_SIZE_OFFSET	0x44
+#define FDET_ORIG_TARGET_PTR_OFFSET	0x50
+#define FDET_ORIG_TARGET_PITCH_OFFSET	0x54
+#define FDET_TMP_TARGET_PTR_OFFSET	0x58
+#endif
+
+#define FDET_RESULT_STATUS_OFFSET	0x100
+#define FDET_ERROR_STATUS_OFFSET	0x104
+#define FDET_FS_CMD_STATUS_OFFSET	0x108
+#define FDET_TS_CMD_STATUS_OFFSET	0x10C
+#define FDET_ACTIVE_OFFSET		0x110
+
+#define FDET_SCALE_FACTOR0_OFFSET	0x400
+#define FDET_SCALE_FACTOR_OFFSET(n)	(FDET_SCALE_FACTOR0_OFFSET + ((n) << 2))
+
+#if (CHIP_REV == A7)
+
+#define FDET_EVALUATION_ID0_OFFSET	0x800
+#define FDET_EVALUATION_ID_OFFSET(n)	(FDET_EVALUATION_ID0_OFFSET + ((n) << 2))
+
+#else
+
+#define FDET_EVALUATION_ID0_OFFSET	0x500
+#define FDET_EVALUATION_ID_OFFSET(n)	(FDET_EVALUATION_ID0_OFFSET + ((n) << 2))
+
+#define FDET_EVALUATION_NUM0_OFFSET	0x600
+#define FDET_EVALUATION_NUM_OFFSET(n)	(FDET_EVALUATION_NUM0_OFFSET + ((n) << 2))
+
+#define FDET_EVALUATION_NUM_REG(n)	FACE_DETECTION_REG(FDET_EVALUATION_NUM_OFFSET(n))
+
+#define FDET_HAVE_EVAL_NUM_REGS
+
+#endif
+
+#if (CHIP_REV == A7)
+#define FDET_IRQF			IRQF_TRIGGER_FALLING
+#else
+#define FDET_IRQF			IRQF_TRIGGER_RISING
+#endif
+
+#ifndef FDET_IRQ
+#define FDET_IRQ			FACE_DET_IRQ
+#endif
+
+#define FDET_BASE_ADDRESS_REG		FACE_DETECTION_REG(FDET_BASE_ADDRESS_OFFSET)
+#define FDET_ENABLE_REG			FACE_DETECTION_REG(FDET_ENABLE_OFFSET)
+#define FDET_GO_REG			FACE_DETECTION_REG(FDET_GO_OFFSET)
+#define FDET_CONFIG_DONE_REG		FACE_DETECTION_REG(FDET_CONFIG_DONE_OFFSET)
+#define FDET_RESET_REG			FACE_DETECTION_REG(FDET_RESET_OFFSET)
+#define FDET_INPUT_WIDTH_REG		FACE_DETECTION_REG(FDET_INPUT_WIDTH_OFFSET)
+#define FDET_INPUT_HEIGHT_REG		FACE_DETECTION_REG(FDET_INPUT_HEIGHT_OFFSET)
+#define FDET_DEADLINE_REG		FACE_DETECTION_REG(FDET_DEADLINE_OFFSET)
+#define FDET_SEND_DEADLINE_INT_REG	FACE_DETECTION_REG(FDET_SEND_DEADLINE_INT_OFFSET)
+#define FDET_SKIP_FIRST_INT_REG		FACE_DETECTION_REG(FDET_SKIP_FIRST_INT_OFFSET)
+#define FDET_FS_CMD_LIST_PTR_REG	FACE_DETECTION_REG(FDET_FS_CMD_LIST_PTR_OFFSET)
+#define FDET_FS_CMD_LIST_SIZE_REG	FACE_DETECTION_REG(FDET_FS_CMD_LIST_SIZE_OFFSET)
+#define FDET_FS_RESULT_BUF_PTR_REG	FACE_DETECTION_REG(FDET_FS_RESULT_BUF_PTR_OFFSET)
+#define FDET_FS_RESULT_BUF_SIZE_REG	FACE_DETECTION_REG(FDET_FS_RESULT_BUF_SIZE_OFFSET)
+#define FDET_TS_CMD_LIST_PTR_REG	FACE_DETECTION_REG(FDET_TS_CMD_LIST_PTR_OFFSET)
+#define FDET_TS_CMD_LIST_SIZE_REG	FACE_DETECTION_REG(FDET_TS_CMD_LIST_SIZE_OFFSET)
+#define FDET_TS_RESULT_BUF_PTR_REG	FACE_DETECTION_REG(FDET_TS_RESULT_BUF_PTR_OFFSET)
+#define FDET_TS_RESULT_BUF_SIZE_REG	FACE_DETECTION_REG(FDET_TS_RESULT_BUF_SIZE_OFFSET)
+#define FDET_ORIG_TARGET_PTR_REG	FACE_DETECTION_REG(FDET_ORIG_TARGET_PTR_OFFSET)
+#define FDET_ORIG_TARGET_PITCH_REG	FACE_DETECTION_REG(FDET_ORIG_TARGET_PITCH_OFFSET)
+#define FDET_TMP_TARGET_PTR_REG		FACE_DETECTION_REG(FDET_TMP_TARGET_PTR_OFFSET)
+
+#define FDET_RESULT_STATUS_REG		FACE_DETECTION_REG(FDET_RESULT_STATUS_OFFSET)
+#define FDET_ERROR_STATUS_REG		FACE_DETECTION_REG(FDET_ERROR_STATUS_OFFSET)
+#define FDET_FS_CMD_STATUS_REG		FACE_DETECTION_REG(FDET_FS_CMD_STATUS_OFFSET)
+#define FDET_TS_CMD_STATUS_REG		FACE_DETECTION_REG(FDET_TS_CMD_STATUS_OFFSET)
+#define FDET_ACTIVE_REG			FACE_DETECTION_REG(FDET_ACTIVE_OFFSET)
+
+#define FDET_SCALE_FACTOR_REG(n)	FACE_DETECTION_REG(FDET_SCALE_FACTOR_OFFSET(n))
+
+#define FDET_EVALUATION_ID_REG(n)	FACE_DETECTION_REG(FDET_EVALUATION_ID_OFFSET(n))
+
+
+
+#define FDET_CONFIG_BASE_NORMAL		0x0C
+
+#define FDET_ENABLE			0x01
+#define FDET_DISABLE			0x00
+
+#define FDET_START			0x01
+#define FDET_STOP			0x00
+
+#define FDET_CONFIG_DONE		0x01
+
+#define FDET_RESET			0x01
+
+#define FDET_SKIP_FIRST_INTERRUPT	0x01
+
+#define FDET_FS_RESULT_NUM(s)		((s) >> 16)
+#define FDET_TS_RESULT_NUM(s)		((s) & 0xFFFF)
+
+#define FDET_ERR_TS_RESULT_OVERFLOW	0x0001
+#define FDET_ERR_TS_MERGE_OVERFLOW	0x0002
+#define FDET_ERR_TS_TOO_LONG		0x0004
+#define FDET_ERR_FS_RESULT_OVERFLOW	0x0100
+#define FDET_ERR_FS_MERGE_OVERFLOW	0x0200
+
+#define FDET_LAST_FS_CMD_ID(s)		((s) & 0x0FFF)
+#define FDET_LAST_TS_CMD_ID(s)		((s) & 0x0FFF)
+
+#define FDET_ACTIVE			0x01
+
+#define	FDET_SCALE_FACTOR_EXPONENT(v)	((v) & 0x0007)
+#define	FDET_SCALE_FACTOR_MANTISSA(v)	(((v) & 0x07FF) << 3)
+#define	FDET_RECIPROCAL_SCALE_FACTOR_EXPONENT(v)	(((v) & 0x0007) << 14)
+#define	FDET_RECIPROCAL_SCALE_FACTOR_MANTISSA(v)	(((v) & 0x07FF) << 17)
+
+#define FDET_CASCADE_CLASSIFIER_PTR(v)	(v & 0x1FFF)
+#define FDET_SPECIAL_CLASSIFIER_PTR(v)	((v & 0x1FFF) << 13)
+#define FDET_SPECIAL_CLASSIFIER_NUM(v)	((v & 0x003F) << 26)
+
+#endif
diff --git a/drivers/fdet/make.inc b/drivers/fdet/make.inc
new file mode 100644
index 0000000..a51bf62
--- /dev/null
+++ b/drivers/fdet/make.inc
@@ -0,0 +1,50 @@
+##
+## kernel/private/drivers/fdet/make.inc
+##
+## History:
+##    2012/06/28 - [Zhenwu Xue] Created file
+##
+## Copyright (c) 2015 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+ifeq ($(BUILD_AMBARELLA_FDET), y)
+
+LOCAL_PATH	:= $(call my-dir)
+
+###
+include $(CLEAR_VARS)
+
+LOCAL_SRCS	:= $(wildcard $(LOCAL_PATH)/*.c) $(wildcard $(LOCAL_PATH)/*.h)
+LOCAL_SRCS	+= $(LOCAL_PATH)/Kbuild
+
+include $(BUILD_DRIVER)
+
+###
+
+include $(call all-makefiles-under, $(LOCAL_PATH)/*)
+include $(call all-makefiles-under, $(LOCAL_PATH)/)
+
+endif
+
diff --git a/drivers/vin/sensors/omnivision_ov2710_parallel/Kbuild b/drivers/vin/sensors/omnivision_ov2710_parallel/Kbuild
new file mode 100644
index 0000000..947acd0
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2710_parallel/Kbuild
@@ -0,0 +1,37 @@
+##
+## Kbuild
+##
+## History:
+##    2009/07/09 - [Anthony Ginger] Create
+##
+## Copyright (c) 2015 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
+EXTRA_AFLAGS		+= $(AMBARELLA_DRV_AFLAGS)
+EXTRA_LDFLAGS		+= $(AMBARELLA_DRV_LDFLAGS)
+
+obj-m := ov2710.o
+
diff --git a/drivers/vin/sensors/omnivision_ov2710_parallel/make.inc b/drivers/vin/sensors/omnivision_ov2710_parallel/make.inc
new file mode 100644
index 0000000..dca6b62
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2710_parallel/make.inc
@@ -0,0 +1,45 @@
+##
+## kernel/private/drivers/vin/sensors/omnivision_ov2710_parallel/make.inc
+##
+## History:
+##    2012/06/04 - [Cao Rongrong] Created file
+##
+## Copyright (c) 2015 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+ifeq ($(CONFIG_SENSOR_OV2710P), y)
+
+LOCAL_PATH	:= $(call my-dir)
+
+###
+include $(CLEAR_VARS)
+
+LOCAL_SRCS	:= $(wildcard $(LOCAL_PATH)/*.c) $(wildcard $(LOCAL_PATH)/*.h)
+LOCAL_SRCS	+= $(LOCAL_PATH)/Kbuild
+
+include $(BUILD_DRIVER)
+
+endif
+
diff --git a/drivers/vin/sensors/omnivision_ov2710_parallel/ov2710.c b/drivers/vin/sensors/omnivision_ov2710_parallel/ov2710.c
new file mode 100644
index 0000000..713de1a
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2710_parallel/ov2710.c
@@ -0,0 +1,524 @@
+/*
+ * Filename : ov2710.c
+ *
+ * History:
+ *    2009/06/19 - [Qiao Wang] Create
+ *
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/ambpriv_device.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <iav_utils.h>
+#include <vin_api.h>
+#include "ov2710.h"
+
+static int bus_addr = (0 << 16) | (0x6C >> 1);
+module_param(bus_addr, int, 0644);
+MODULE_PARM_DESC(bus_addr, " bus and addr: bit16~bit31: bus, bit0~bit15: addr");
+
+static int bayer_pattern = VINDEV_BAYER_PATTERN_AUTO;
+module_param(bayer_pattern, int, 0644);
+MODULE_PARM_DESC(bayer_pattern, "set bayer pattern: 0:RG, 1:BG, 2:GR, 3:GB, 255:default");
+
+struct ov2710_priv {
+	struct i2c_client *client;
+	u32 line_length;
+	u32 frame_length_lines;
+};
+
+#include "ov2710_table.c"
+
+static int ov2710_write_reg( struct vin_device *vdev, u32 subaddr, u32 data)
+{
+	int rval = 0;
+	struct ov2710_priv *ov2710;
+	struct i2c_client *client;
+	struct i2c_msg msgs[1];
+	u8 pbuf[3];
+
+	ov2710 = (struct ov2710_priv *)vdev->priv;
+	client = ov2710->client;
+
+	pbuf[0] = (subaddr & 0xff00) >> 8;
+	pbuf[1] = subaddr & 0xff;
+	pbuf[2] = data & 0xff;
+
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].len = 3;
+	msgs[0].buf = pbuf;
+
+	rval = i2c_transfer(client->adapter, msgs, 1);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x:0x%x]\n", rval, subaddr, data);
+		return rval;
+	}
+
+	return 0;
+}
+
+static int ov2710_read_reg( struct vin_device *vdev, u32 subaddr, u32 *data)
+{
+	int rval = 0;
+	struct ov2710_priv *ov2710;
+	struct i2c_client *client;
+	struct i2c_msg msgs[1];
+	u8 pbuf[1];
+	u8 pbuf0[2];
+
+
+	ov2710 = (struct ov2710_priv *)vdev->priv;
+	client = ov2710->client;
+
+	pbuf0[1] = subaddr & 0xff;
+	pbuf0[0] = (subaddr & 0xff00) >> 8;
+
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].len = 2;
+	msgs[0].buf = pbuf0;
+
+	rval = i2c_transfer(client->adapter, msgs, 1);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x]\n", rval, subaddr);
+		return rval;
+	}
+
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags | I2C_M_RD;
+	msgs[0].len = 1;
+	msgs[0].buf = pbuf;
+
+	rval = i2c_transfer(client->adapter, msgs, 1);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x]\n", rval, subaddr);
+		return rval;
+	}
+
+	*data = pbuf[0];
+
+	return 0;
+}
+
+static int ov2710_set_vin_mode(struct vin_device *vdev, struct vin_video_format *format)
+{
+	struct vin_device_config ov2710_config;
+
+	memset(&ov2710_config, 0, sizeof (ov2710_config));
+
+	ov2710_config.interface_type = SENSOR_PARALLEL_LVCMOS;
+	ov2710_config.sync_mode = SENSOR_SYNC_MODE_MASTER;
+	ov2710_config.input_mode = SENSOR_RGB_1PIX;
+
+	ov2710_config.plvcmos_cfg.vs_hs_polarity = SENSOR_VS_LOW | SENSOR_HS_HIGH;
+	ov2710_config.plvcmos_cfg.data_edge = SENSOR_DATA_FALLING_EDGE;
+	ov2710_config.plvcmos_cfg.paralle_sync_type = SENSOR_PARALLEL_SYNC_601;
+
+	ov2710_config.cap_win.x = format->def_start_x;
+	ov2710_config.cap_win.y = format->def_start_y;
+	ov2710_config.cap_win.width = format->def_width;
+	ov2710_config.cap_win.height = format->def_height;
+
+	ov2710_config.sensor_id = GENERIC_SENSOR;
+	ov2710_config.input_format = AMBA_VIN_INPUT_FORMAT_RGB_RAW;
+	ov2710_config.bayer_pattern = format->bayer_pattern;
+	ov2710_config.video_format = format->format;
+	ov2710_config.bit_resolution = format->bits;
+
+	return ambarella_set_vin_config(vdev, &ov2710_config);
+}
+
+static void ov2710_set_streaming(struct vin_device *vdev)
+{
+	u32 val;
+
+	ov2710_read_reg(vdev, OV2710_SYSTEM_CONTROL00, &val);
+	val &= 0xbf;
+	ov2710_write_reg(vdev, OV2710_SYSTEM_CONTROL00, val);
+}
+
+static void ov2710_sw_reset(struct vin_device *vdev)
+{
+	u32 val;
+
+	ov2710_read_reg(vdev, OV2710_SYSTEM_CONTROL00, &val);
+	val |= 0x80;
+	ov2710_write_reg(vdev, OV2710_SYSTEM_CONTROL00, val);
+}
+
+static int ov2710_init_device(struct vin_device *vdev)
+{
+	int sensor_id, pidh, pidl;
+
+	ov2710_sw_reset(vdev);
+
+	/* query sensor id */
+	ov2710_read_reg(vdev, OV2710_PIDH, &pidh);
+	if (pidh < 0)
+		return -EIO;
+
+	ov2710_read_reg(vdev, OV2710_PIDL, &pidl);
+	if (pidl < 0)
+		return -EIO;
+
+	sensor_id = (pidh << 8)| pidl;
+
+	vin_info("OV2710 sensor ID is 0x%x\n", sensor_id);
+
+	return 0;
+}
+
+static int ov2710_update_hv_info(struct vin_device *vdev)
+{
+	u32 val_high, val_low;
+	struct ov2710_priv *pinfo = (struct ov2710_priv *)vdev->priv;
+
+	ov2710_read_reg(vdev, OV2710_TIMING_CONTROL_HTS_HIGHBYTE, &val_high);
+	ov2710_read_reg(vdev, OV2710_TIMING_CONTROL_HTS_LOWBYTE, &val_low);
+	pinfo->line_length = (val_high << 8) + val_low;
+	if(unlikely(!pinfo->line_length)) {
+		vin_error("line length is 0!\n");
+		return -EIO;
+	}
+
+	ov2710_read_reg(vdev, OV2710_TIMING_CONTROL_VTS_HIGHBYTE, &val_high);
+	ov2710_read_reg(vdev, OV2710_TIMING_CONTROL_VTS_LOWBYTE, &val_low);
+	pinfo->frame_length_lines = (val_high << 8) + val_low;
+
+	return 0;
+}
+
+static int ov2710_get_line_time(struct vin_device *vdev)
+{
+	u64 h_clks;
+	struct ov2710_priv *pinfo = (struct ov2710_priv *)vdev->priv;
+
+	h_clks = (u64)pinfo->line_length * 512000000;
+	h_clks = DIV64_CLOSEST(h_clks, vdev->cur_pll->pixelclk);
+
+	vdev->cur_format->line_time = (u32)h_clks;
+
+	return 0;
+}
+
+static int ov2710_set_format(struct vin_device *vdev, struct vin_video_format *format)
+{
+	struct vin_reg_16_8 *regs;
+	int i, regs_num, rval;
+
+	if (format->device_mode == 0) { /* 720p */
+		regs = ov2710_720p_share_regs;
+		regs_num = ARRAY_SIZE(ov2710_720p_share_regs);
+
+		for (i = 0; i < regs_num; i++)
+			ov2710_write_reg(vdev, regs[i].addr, regs[i].data);
+	} else if (format->device_mode == 1) { /* 1080p */
+		regs = ov2710_1080p_share_regs;
+		regs_num = ARRAY_SIZE(ov2710_1080p_share_regs);
+
+		for (i = 0; i < regs_num; i++)
+			ov2710_write_reg(vdev, regs[i].addr, regs[i].data);
+	}
+
+	rval = ov2710_update_hv_info(vdev);
+	if (rval < 0)
+		return rval;
+
+	ov2710_get_line_time(vdev);
+
+	/* start streaming */
+	ov2710_set_streaming(vdev);
+
+	/* communiate with IAV */
+	rval = ov2710_set_vin_mode(vdev, format);
+	if (rval < 0)
+		return rval;
+
+	return 0;
+}
+
+static int ov2710_set_shutter_row(struct vin_device *vdev, u32 row)
+{
+	u64 exposure_lines;
+	u32 num_line, min_line, max_line;
+	struct ov2710_priv *pinfo = (struct ov2710_priv *)vdev->priv;
+
+	num_line = row;
+
+	/* FIXME: shutter width: 1 ~ (Frame format(V) - 3) */
+	min_line = 1;
+	max_line = pinfo->frame_length_lines - 3;
+	num_line = clamp(num_line, min_line, max_line);
+
+	num_line <<= 4; /* the register value should be exposure time * 16 */
+	ov2710_write_reg(vdev, OV2710_AEC_PK_EXPO_H, (num_line >> 16) & 0x0F);
+	ov2710_write_reg(vdev, OV2710_AEC_PK_EXPO_M, (num_line >> 8) & 0xFF);
+	ov2710_write_reg(vdev, OV2710_AEC_PK_EXPO_L, num_line & 0xFF);
+
+	num_line >>= 4;
+	exposure_lines = num_line;
+	exposure_lines = exposure_lines * (u64)pinfo->line_length * 512000000;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, vdev->cur_pll->pixelclk);
+
+	vdev->shutter_time = (u32)exposure_lines;
+	vin_debug("shutter_time:%d, row:%d\n", vdev->shutter_time, num_line);
+
+	return 0;
+}
+
+static int ov2710_shutter2row(struct vin_device *vdev, u32* shutter_time)
+{
+	u64 exposure_lines;
+	int rval = 0;
+	struct ov2710_priv *pinfo = (struct ov2710_priv *)vdev->priv;
+
+	/* for fast boot, it may call set shutter time directly, so we must read line length/frame line */
+	if(unlikely(!pinfo->line_length)) {
+		rval = ov2710_update_hv_info(vdev);
+		if (rval < 0)
+			return rval;
+	}
+
+	exposure_lines = (*shutter_time) * (u64)vdev->cur_pll->pixelclk;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, pinfo->line_length);
+	exposure_lines = DIV64_CLOSEST(exposure_lines, 512000000);
+
+	*shutter_time = exposure_lines;
+
+	return rval;
+}
+
+static int ov2710_set_fps(struct vin_device *vdev, int fps)
+{
+	u64 v_lines, vb_time;
+	struct ov2710_priv *pinfo = (struct ov2710_priv *)vdev->priv;
+
+	/* calculate line number per frame */
+	v_lines = fps * (u64)vdev->cur_pll->pixelclk;
+	v_lines = DIV64_CLOSEST(v_lines, pinfo->line_length);
+	v_lines = DIV64_CLOSEST(v_lines, 512000000);
+
+	ov2710_write_reg(vdev, OV2710_TIMING_CONTROL_VTS_HIGHBYTE, (v_lines >> 8) & 0xFF);
+	ov2710_write_reg(vdev, OV2710_TIMING_CONTROL_VTS_LOWBYTE, v_lines & 0xFF);
+
+	pinfo->frame_length_lines = (u32)v_lines;
+
+	vb_time = pinfo->line_length * (u64)(v_lines - vdev->cur_format->height) * 1000000000;
+	vb_time = DIV64_CLOSEST(vb_time, vdev->cur_pll->pixelclk);
+	vdev->cur_format->vb_time = vb_time;
+
+	return 0;
+}
+
+static int ov2710_set_agc_index(struct vin_device *vdev, int agc_idx)
+{
+	if (agc_idx > OV2710_GAIN_0DB) {
+		vin_warn("agc index %d exceeds maximum %d\n", agc_idx, OV2710_GAIN_0DB);
+		agc_idx = OV2710_GAIN_0DB;
+	}
+
+	agc_idx = OV2710_GAIN_0DB - agc_idx;
+
+	ov2710_write_reg(vdev, OV2710_GROUP_ACCESS, 0x00);
+
+	ov2710_write_reg(vdev, OV2710_AEC_AGC_ADJ_H,
+		ov2710_gains[agc_idx][OV2710_GAIN_COL_REG300A]);
+	ov2710_write_reg(vdev, OV2710_AEC_AGC_ADJ_L,
+		ov2710_gains[agc_idx][OV2710_GAIN_COL_REG300B]);
+
+	ov2710_write_reg(vdev, OV2710_GROUP_ACCESS, 0x10);
+	ov2710_write_reg(vdev, OV2710_GROUP_ACCESS, 0xA0);
+
+	return 0;
+}
+
+static int ov2710_set_mirror_mode(struct vin_device *vdev,
+		struct vindev_mirror *mirror_mode)
+{
+	u32 readmode, tmp_reg, ana_reg, vstart_reg;
+
+	switch (mirror_mode->pattern) {
+	case VINDEV_MIRROR_HORRIZONTALLY_VERTICALLY:
+		readmode = OV2710_MIRROR_ROW + OV2710_MIRROR_COLUMN;
+		ana_reg = 0x14;
+		vstart_reg = 0x09;
+		break;
+	case VINDEV_MIRROR_HORRIZONTALLY:
+		readmode = OV2710_MIRROR_ROW;
+		ana_reg = 0x14;
+		vstart_reg = 0x0a;
+		break;
+	case VINDEV_MIRROR_VERTICALLY:
+		readmode = OV2710_MIRROR_COLUMN;
+		ana_reg = 0x04;
+		vstart_reg = 0x09;
+		break;
+	case VINDEV_MIRROR_NONE:
+		readmode = 0;
+		ana_reg = 0x04;
+		vstart_reg = 0x0a;
+		break;
+	default:
+		vin_error("do not support cmd mirror mode\n");
+		return -EINVAL;
+	}
+
+	ov2710_read_reg(vdev, OV2710_TIMING_CONTROL18, &tmp_reg);
+	tmp_reg &= (~OV2710_MIRROR_MASK);
+	tmp_reg |= readmode;
+
+	ov2710_write_reg(vdev, OV2710_TIMING_CONTROL18, tmp_reg);
+	ov2710_write_reg(vdev, OV2710_ANA_ARRAY_01, ana_reg);
+	ov2710_write_reg(vdev, OV2710_TIMING_CONTROL_VS_LOWBYTE, vstart_reg);
+
+	return 0;
+}
+
+static struct vin_ops ov2710_ops = {
+	.init_device		= ov2710_init_device,
+	.set_format		= ov2710_set_format,
+	.set_shutter_row	= ov2710_set_shutter_row,
+	.shutter2row		= ov2710_shutter2row,
+	.set_frame_rate		= ov2710_set_fps,
+	.set_agc_index		= ov2710_set_agc_index,
+	.set_mirror_mode	= ov2710_set_mirror_mode,
+	.read_reg		= ov2710_read_reg,
+	.write_reg		= ov2710_write_reg,
+};
+
+/* 	< include init.c here for aptina sensor, which is produce by perl >  */
+/* ========================================================================== */
+static int ov2710_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct vin_device *vdev;
+	struct ov2710_priv *ov2710;
+	int i, rval;
+
+	vdev = ambarella_vin_create_device(client->name,
+			SENSOR_OV2710, 	sizeof(struct ov2710_priv));
+	if (!vdev)
+		return -ENOMEM;
+
+	vdev->intf_id = 0;
+	vdev->dev_type = VINDEV_TYPE_SENSOR;
+	vdev->sub_type = VINDEV_SUBTYPE_CMOS;
+	vdev->default_mode = AMBA_VIDEO_MODE_1080P;
+	vdev->default_hdr_mode = AMBA_VIDEO_LINEAR_MODE;
+	vdev->agc_db_max = 0x24000000;	// 36dB
+	vdev->agc_db_min = 0x00000000;	// 0dB
+	vdev->agc_db_step = 0x00600000;	// 0.375dB
+
+	/* I2c Client */
+	i2c_set_clientdata(client, vdev);
+
+	ov2710 = (struct ov2710_priv *)vdev->priv;
+	ov2710->client = client;
+
+	if (bayer_pattern != VINDEV_BAYER_PATTERN_AUTO) {
+		if (bayer_pattern > VINDEV_BAYER_PATTERN_GB) {
+			vin_error("invalid bayer pattern:%d\n", bayer_pattern);
+			return -EINVAL;
+		} else {
+			for (i = 0; i < ARRAY_SIZE(ov2710_formats); i++)
+				ov2710_formats[i].default_bayer_pattern = bayer_pattern;
+		}
+	}
+
+	rval = ambarella_vin_register_device(vdev, &ov2710_ops,
+			ov2710_formats, ARRAY_SIZE(ov2710_formats),
+			ov2710_plls, ARRAY_SIZE(ov2710_plls));
+	if (rval < 0)
+		goto ov2710_probe_err;
+
+	return 0;
+
+ov2710_probe_err:
+	ambarella_vin_free_device(vdev);
+	return rval;
+}
+
+static int ov2710_remove(struct i2c_client *client)
+{
+	struct vin_device *vdev;
+
+	vdev = (struct vin_device *)i2c_get_clientdata(client);
+	ambarella_vin_unregister_device(vdev);
+	ambarella_vin_free_device(vdev);
+
+	return 0;
+}
+
+static struct i2c_device_id ov2710_idtable[] = {
+	{ "ov2710", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ov2710_idtable);
+
+static struct i2c_driver i2c_driver_ov2710 = {
+	.driver = {
+		   .name = "ov2710",
+		   },
+	.id_table	= ov2710_idtable,
+	.probe		= ov2710_probe,
+	.remove		= ov2710_remove,
+};
+
+static int __init ov2710_init(void)
+{
+	int bus, addr, rval;
+
+	bus = bus_addr >> 16;
+	addr = bus_addr & 0xffff;
+
+	rval = ambpriv_i2c_update_addr("ov2710", bus, addr);
+	if (rval < 0)
+		return rval;
+
+	rval = i2c_add_driver(&i2c_driver_ov2710);
+	if (rval < 0)
+		return rval;
+
+	return 0;
+}
+
+static void __exit ov2710_exit(void)
+{
+	i2c_del_driver(&i2c_driver_ov2710);
+}
+
+module_init(ov2710_init);
+module_exit(ov2710_exit);
+
+MODULE_DESCRIPTION("OV2710 1/3-Inch 2-Megapixel CMOS Digital Image Sensor");
+MODULE_AUTHOR("Qiao Wang, <qwang@ambarella.com>");
+MODULE_LICENSE("Proprietary");
+
diff --git a/drivers/vin/sensors/omnivision_ov2710_parallel/ov2710.h b/drivers/vin/sensors/omnivision_ov2710_parallel/ov2710.h
new file mode 100644
index 0000000..24eec8f
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2710_parallel/ov2710.h
@@ -0,0 +1,543 @@
+/*
+ * Filename : ov2710_pri.h
+ *
+ * History:
+ *    2009/06/19 - [Qiao Wang] Create
+ *
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __OV2710_PRI_H__
+#define __OV2710_PRI_H__
+
+/* 		register name 				address default value	R/W	description  */
+#define OV2710_SYSTEM_CONTROL00		0x3008	/*0x02 RW System Control*/
+											/* Bit[7]:System software reset 0:Normal work mode 1:Software reset mode*/
+											/* Bit[6]:System sleep mode 0:Normal work mode 1:Software sleep power down mode*/
+											/* Bit[4]:MIPI high speed power down control 0:Not used 1:Power down MIPI PHY LP RX module*/
+											/* Bit[2]:MIPI enable 0:DVP enable 1:MIPI enable*/
+											/* Bit[1]:MIPI system suspend control 0:Not used 1:MIPI suspend*/
+											/* Bit[0]:Not used*/
+#define OV2710_PIDH		0x300A	/*0x27 R Product ID High Byte MSBs*/
+#define OV2710_PIDL		0x300B	/*0x10 R Product ID Low Byte LSBs*/
+#define OV2710_MIPI_CTRL00		0x300E	/*0x00 RW*/
+											/* Bit[7:5]: Not used*/
+											/* Bit[4]: MIPI high speed power down control 0: 1: power down mipi phy HS TX module*/
+											/* Bit[3]:MIPI low power, power-down control 0:Enable MIPI PHY HS RX module 1:Power down MIPI PHY LP RX module*/
+											/* Bit[2]:MIPI enable 0:DVP enable 1:MIPI enable*/
+											/* Bit[1]:MIPI system suspend control 0:MIPI power ON 1:MIPI suspend*/
+#define OV2710_PLL_CTRL00		0x300F	/*0x8A RW*/
+											/* Bit[7:6]: Not used*/
+											/* Bit[5:3]: Charge pump control*/
+											/* Bit[2]:Not used*/
+											/* Bit[1:0]: PLL SELD5 divider*/
+											/* 0x: Bypass*/
+											/* 10: Divided by 4 when in 8-bit mode*/
+											/* 11: Divided by 5 when in 10-bit mode*/
+#define OV2710_PLL_CTRL01		0x3010	/*0x00 RW*/
+											/* Bit[7:4]: PLL DIVS divider System divider ratio*/
+											/* Bit[3:0]: PLL DIVM divider MIPI divider ratio*/
+#define OV2710_PLL_CTRL02		0x3011	/*0x0A RW*/
+											/* Bit[7]:PLL bypass*/
+											/* Bit[5:0]: PLL DIVP*/
+#define OV2710_PLL_PREDIVEDER		0x3012	/*0x00 RW*/
+											/* Bit[7:3]: Not used*/
+											/* Bit[2:0]: PLL1 pre-divider ratio 000: 1 001: 1.5 010: 2 011: 2.5 100: 3 101: 4 110: 6 111: 8*/
+#define OV2710_PAD_OUTPUT_ENABLE00		0x3016	/*0x00 RW Input/Output Control (0: input; 1: output)*/
+											/* Bit[7:2]: Not used*/
+											/* Bit[1]:Strobe OEN*/
+											/* Bit[0]:SDA OEN*/
+#define OV2710_PAD_OUTPUT_ENABLE01		0x3017	/*0x00 RW Input/Output Control (0: input; 1: output)*/
+											/* Bit[7]:Not used*/
+											/* Bit[6]:VSYNC OEN*/
+											/* Bit[5]:HREF OEN*/
+											/* Bit[4]:PCLK OEN*/
+											/* Bit[3:0]: D OEN[9:6]*/
+#define OV2710_PAD_OUTPUT_ENABLE02		0x3018	/*0x00 RW Input/Output Control (0: input; 1: output) Bit[7:2] D OEN[5:0]*/
+#define OV2710_PAD_OUTPUT_VALUE00		0x3019	/*0x00  RW GPIO Output Value*/
+											/* Bit[7:2]: Not used*/
+											/* Bit[1]:Strobe*/
+											/* Bit[0]:SDA*/
+#define OV2710_PAD_OUTPUT_VALUE01		0x301A	/*0x00 RW GPIO Output Value*/
+											/* Bit[7]:Not used*/
+											/* Bit[6]:VSYNC*/
+											/* Bit[5]:HREF*/
+											/* Bit[4]:PCLK*/
+											/* Bit[3:0]: D output[9:6]*/
+#define OV2710_PAD_OUTPUT_VALUE02		0x301B	/*0x00 RW GPIO Output Value*/
+											/* Bit[7:2]: D output[5:0]*/
+											/* Bit[1:0]: Not used*/
+#define OV2710_PAD_OUTPUT_SELECT00		0x301C	/*0x00 RW Output Selection for GPIO (0: normal data path, 1: register controlled GPIO)*/
+											/* Bit[7:2]: Not used*/
+											/* Bit[1]:Strobe select*/
+											/* Bit[0]:SDA select*/
+#define OV2710_PAD_OUTPUT_SELECT01		0x301D	/*0x00 RW Output Selection for GPIO (0: normal data path, 1: register controlled GPIO)*/
+											/* Bit[7]:Not used*/
+											/* Bit[6]:VSYNC select*/
+											/* Bit[5]:HREF select*/
+											/* Bit[4]:PCLK select*/
+											/* Bit[3:0]: D select[9:6]*/
+#define OV2710_PAD_OUTPUT_SELECT02		0x301E	/*0x00 RW Output Selection for GPIO (0: normal data path, 1: register controlled GPIO)*/
+											/* Bit[7:2]: D select[5:0]*/
+											/* Bit[1:0]: Not used*/
+#define OV2710_PAD_OUTPUT_DRIVE_CAPABILITY		0x302C	/*0x02 RW Bit[7:6]: Output drive capability 00: 1x 01: 2x 10: 3x 11: 4x*/
+#define OV2710_PAD_INPUT_VALUE00		0x3040	/* R Pad Input Status*/
+											/* Bit[7:6]: Not used*/
+											/* Bit[5]:TM*/
+											/* Bit[4]:Not used*/
+											/* Bit[3]:PWDN*/
+											/* Bit[2]:PWUP*/
+											/* Bit[1]:SCL*/
+											/* Bit[0]:SDA*/
+#define OV2710_PAD_INPUT_VALUE01		0x3041	/* R Pad Input Status*/
+											/* Bit[7]:OTP*/
+											/* Bit[6]:VSYNC*/
+											/* Bit[5]:HREF*/
+											/* BIt[4]:PCLK*/
+											/* Bit[3:0]: D input[9:6]*/
+#define OV2710_PAD_INPUT_VALUE02		0x3042	/* R Pad Input Status*/
+											/* Bit[7:2]: D input[5:0]*/
+											/* Bit[1:0]: Not used*/
+#define OV2710_SCCB_ID		0x3100	/*0x6C RW SCCB Slave ID*/
+#define OV2710_PLL_CLOCK_SELECT		0x3103	/*0x01 RW*/
+											/* Bit[7:2]: Not used*/
+											/* Bit[1]:Select PLL input clock*/
+											/* 0:From pad clock*/
+											/* 1:From pre divider (clock modulator)*/
+#define OV2710_SCCB_PAD_CLOCK_DIVIDER		0x3104	/*0x01 RW Pad Clock Divider for SCCB Clock*/
+#define OV2710_GROUP_ADDR0		0x3200	/*0x40 RW Start Address for Group0 {group_addr0[7:0], 4h0}*/
+#define OV2710_GROUP_ADDR1		0x3201	/*0x4A RW Start Address for Group1 {group_addr1[7:0], 4h0}*/
+#define OV2710_GROUP_ADDR2		0x3202	/*0x54 RW Start Address for Group2 {group_addr2[7:0], 4h0}*/
+#define OV2710_GROUP_ADDR3		0x3203	/*0x5E RW Start Address for Group3 {group_addr3[7:0], 4h0}*/
+#define OV2710_GROUP_ACCESS		0x3212	/*0x00 RW*/
+											/* Bit[7]: group_launch_en*/
+											/* Bit[6]: Debug mode(must be 0)*/
+											/* Bit[5]: group_launch*/
+											/* Bit[4]: group_hold_end*/
+											/* Bit[3:0]: group_id 00~11: ID of the group to hold register*/
+#define OV2710_AWB_GAIN_PK_RED_GAIN_H		0x3400	/*0x04 RW Bit[7:4]: Not used Bit[3:0]: AWB R GAIN[11:8]*/
+#define OV2710_AWB_GAIN_PK_RED_GAIN_L		0x3401	/*0x00 RW Bit[7:0]: AWB R GAIN[7:0]*/
+#define OV2710_AWB_GAIN_PK_GREEN_GAIN_H		0x3402	/*0x04 RW Bit[7:4]: Not used Bit[3:0]: AWB G GAIN[11:8]*/
+#define OV2710_AWB_GAIN_PK_GREEN_GAIN_L		0x3403	/*0x00 RW Bit[7:0]: AWB G GAIN[7:0]*/
+#define OV2710_AWB_GAIN_PK_BLUE_GAIN_H		0x3404	/*0x04 RW Bit[7:4]: Not used Bit[3:0]: AWB B GAIN[11:8] */
+#define OV2710_AWB_GAIN_PK_BLUE_GAIN_L		0x3405	/*0x00 RW Bit[7:0]: AWB B GAIN[7:0]*/
+#define OV2710_AWB_GAIN_PK_AWB_MAN_CTRL		0x3406	/*0x00 RW Bit[0]: AWB manual control 0: automatically 1: manual*/
+#define OV2710_AEC_PK_EXPO_H		0x3500	/*0x00 RW Bit[7:4]: Not used Bit[3:0]: AEC exposure[19:16]*/
+#define OV2710_AEC_PK_EXPO_M		0x3501	/*0x00 RW Bit[7:0]: AEC exposure[15:8]*/
+#define OV2710_AEC_PK_EXPO_L		0x3502	/*0x20 RW Bit[7:0]: AEC exposure[7:0]*/
+#define OV2710_AEC_PK_MANUAL		0x3503	/*0x00 RW*/
+											/* Bit[7:4]: Not used*/
+											/* Bit[2]:VTS manual enable*/
+											/* Bit[1]:AGC manual enable*/
+											/* Bit[0]:AEC manual enable*/
+#define OV2710_AEC_AGC_ADJ_H		0x350A	/*0x00 RW Gain Output to Sensor*/
+											/* Bit[7:1]: Not used*/
+											/* Bit[0]:Gain high bit*/
+											/* Gain = (0x350A[0]+1)  (0x350B[7]+1)  (0x350B[6]+1)(0x350B[5]+1)  (0x350B[4]+1)(0x350B[3:0]/16+1)*/
+#define OV2710_AEC_AGC_ADJ_L		0x350B	/*0x00 RW Gain Output to Sensor*/
+											/* Bit[7:0]: Gain low bits*/
+											/* Gain = (0x350A[0]+1)  (0x350B[7]+1)  (0x350B[6]+1)(0x350B[5]+1)  (0x350B[4]+1)(0x350B[3:0]/16+1)*/
+#define OV2710_AEC_PK_VTS_H		0x350C	/*0x00 RW Bit[7:0]: AEC VTS[15:8]*/
+#define OV2710_AEC_PK_VTS_L		0x350D	/*0x00 RW Bit[7:0]: AEC VTS[7:0]*/
+#define OV2710_ANA_ARRAY_01		0x3621	/*0x10 RW Array Control Bit[7]:Horizontal binning Bit[6]:Horizontal skip*/
+#define OV2710_SENSOR_REG0D		0x370D	/*0x0C RW*/
+											/* Bit[7]:Debug mode*/
+											/* Bit[6]:Vertical binning*/
+											/* Bit[5:0]: Debug mode*/
+#define OV2710_TIMING_CONTROL_HS_HIGHBYTE		0x3800	/*0x01 RW Bit[3:0]: HREF horizontal start point[11:8]*/
+#define OV2710_TIMING_CONTROL_HS_LOWBYTE		0x3801	/*0x08 RW Bit[7:0]: HREF horizontal start point[7:0]*/
+#define OV2710_TIMING_CONTROL_VS_HIGHBYTE		0x3802	/*0x00 RW Bit[3:0]: HREF vertical start point[11:8]*/
+#define OV2710_TIMING_CONTROL_VS_LOWBYTE		0x3803	/*0x0A RW Bit[7:0]: HREF vertical start point[7:0]*/
+#define OV2710_TIMING_CONTROL_HW_HIGH_BYTE		0x3804	/*0x08 RW Bit[3:0]: HREF horizontal width[11:8]*/
+#define OV2710_TIMING_CONTROL_HW_LOW_BYTE		0x3805	/*0x00 RW Bit[7:0]: HREF horizontal width[7:0]*/
+#define OV2710_TIMING_CONTROL_VW_HIGH_BYTE		0x3806	/*0x06 RW Bit[3:0]: HREF vertical height[11:8]*/
+#define OV2710_TIMING_CONTROL_VW_LOW_BYTE		0x3807	/*0x00 RW Bit[7:0]: HREF vertical height[7:0]*/
+#define OV2710_TIMING_CONTROL_DVP_HSIZE_HIGH    0x3808	/*0x08 RW Bit[3:0]: DVP output horizontal*/
+#define OV2710_TIMING_CONTROL_DVP_HSIZE_LOW		0x3809	/*0x00 RW Bit[7:0]: DVP output horizontal*/
+#define OV2710_TIMING_CONTROL_DVP_VSIZE_HIGH		0x380A	/*0x06 RW Bit[3:0]: DVP output vertical height[11:8]*/
+#define OV2710_TIMING_CONTROL_DVP_VSIZE_LOW		0x380B	/*0x00 RW Bit[7:0]: DVP output vertical height[7:0]*/
+#define OV2710_TIMING_CONTROL_HTS_HIGHBYTE		0x380C	/*0x09 RW Bit[3:0]: Total horizontal size[11:8]*/
+#define OV2710_TIMING_CONTROL_HTS_LOWBYTE		0x380D	/*0x48 RW Bit[7:0]: Total horizontal size[7:0]*/
+#define OV2710_TIMING_CONTROL_VTS_HIGHBYTE		0x380E	/*0x06 RW Bit[3:0]: Total vertical size[11:8]*/
+#define OV2710_TIMING_CONTROL_VTS_LOWBYTE		0x380F	/*0x18 RW Bit[7:0]: Total vertical size[7:0]*/
+#define OV2710_TIMING_CONTROL_HV_OFFSET		0x3810	/*0xC2 RW Bit[7:4]: Horizontal offset Bit[3:0]: Vertical offset*/
+#define OV2710_TIMING_CONTROL18		0x3818	/*0x80 RW*/
+											/* Bit[7]:Not used*/
+											/* Bit[6]:Horizontal mirror*/
+											/* Bit[5]:Vertical flip*/
+											/* Bit[4:2]: Not used*/
+											/* Bit[1]:Vertical subsample /4*/
+											/* Bit[0]:Vertical subsample /2*/
+#define OV2710_AEC_CONTROL0		0x3A00	/*0x7C RW*/
+											/* Bit[7]:Not used*/
+											/* Bit[6]:Less 1 line enable 0:Less 1 line function disable 1:Less 1 line function enable*/
+											/* Bit[5]:Band enable 0:Band function disable 1:Band function enable*/
+											/* Bit[4]:Auto band enable 0:Exposure can not be less than 1 band 1:Exposure can be less than 1 band*/
+											/* Bit[3]:Line complete 0:Fractional line enable*/
+											/* Bit[1]:Not used*/
+											/* Bit[0]:Freeze 0:Freeze disable 1:Freeze enable*/
+#define OV2710_AEC_CONTROL1		0x3A01	/*0x04 RW Bit[7:0]: Minimum exposure*/
+#define OV2710_AEC_MAX_EXPO_60_H		0x3A02	/*0x02 RW Bit[3:0]: AEC maximum exposure for 60Hz[19:16]*/
+#define OV2710_AEC_MAX_EXPO_60_M		0x3A03	/*0x28 RW Bit[7:0]: AEC maximum exposure for 60Hz[15:8]*/
+#define OV2710_AEC_MAX_EXPO_60_L		0x3A04	/*0x00 RW Bit[7:0]: AEC maximum exposure for 60Hz[7:0]*/
+#define OV2710_AEC_B50_STEP_H		0x3A08	/*0x11 RW Bit[5:0]: AEC Band50 step[13:8]*/
+#define OV2710_AEC_B50_STEP_L	0x3A09	/*0x40 RW Bit[7:0]: AEC Band50 step[7:0]*/
+#define OV2710_AEC_B60_STEP_H		0x3A0A	/*0x11 RW Bit[5:0]: AEC Band60 step[13:8]*/
+#define OV2710_AEC_B60_STEP_L		0x3A0B	/*0x40 RW Bit[7:0]: AEC Band60 step[7:0]*/
+#define OV2710_AEC_CONTROLD		0x3A0D	/*0x04 RW Bit[5:0]: Band60 max[5:0]*/
+#define OV2710_AEC_CONTROLE		0x3A0E	/*0x03 RW Bit[5:0]: Band50 max[5:0]*/
+#define OV2710_AEC_CONTROLF		0x3A0F	/*0x78 RW Bit[7:0]: Stable range high threshold 1*/
+#define OV2710_AEC_CONTROL10		0x3A10	/*0x68 RW Bit[7:0]: Stable range low threshold 1*/
+#define OV2710_AEC_CONTROL11		0x3A11	/*0xD0 RW Bit[7:0]: Fast zone high threshold*/
+#define OV2710_AEC_CONTROL12		0x3A12	/*0x00 RW Bit[7:0]: Manual average setting*/
+#define OV2710_AEC_CONTROL13		0x3A13	/*0x50 RW Bit[7:6]: Not used Bit[5]:Pre gain enable Bit[4:0]: Pre gain*/
+#define OV2710_AEC_MAX_EXPO_50_H		0x3A14	/*0x02 RW Bit[3:0]: AEC maximum exposure for 50Hz[19:16]*/
+#define OV2710_AEC_MAX_EXPO_50_M		0x3A15	/*0x28 RW Bit[7:0]: AEC maximum exposure for 50Hz[15:8]*/
+#define OV2710_AEC_MAX_EXPO_50_L		0x3A16	/*0x00 RW Bit[7:0]: AEC maximum exposure for 50Hz[7:0]*/
+#define OV2710_AEC_CONTROL17		0x3A17	/*0x89 RW */
+											/* Bit[1:0]: Gain night threshold[1:0]*/
+											/* 00: Night mode gain threshold as 1x*/
+											/* 01: Night mode gain threshold as 2x*/
+											/* 10: Night mode gain threshold as 4x*/
+											/* 11: Not used*/
+#define OV2710_AEC_G_CEIL_H		0x3A18	/*0x03 RW Bit[0]:AEC gain ceiling*/
+#define OV2710_AEC_G_CEIL_L		0x3A19	/*0xE0 RW Bit[7:0]: AEC gain ceiling*/
+#define OV2710_AEC_CONTROL1B		0x3A1B	/*0x78 RW Bit[7:0]: Stable range high threshold 2*/
+#define OV2710_AEC_LED_ADD_ROW_H		0x3A1C	/*0x06 RW Bit[7:0]: Row adding number[15:8] in AEC LED mode*/
+#define OV2710_AEC_LED_ADD_ROW_L		0x3A1D	/*0x18 RW Bit[7:0]: Row adding number[7:0] in AEC LED mode*/
+#define OV2710_AEC_CONTROL1E		0x3A1E	/*0x68 RW Bit[7:0]: Stable range low threshold 2*/
+#define OV2710_AEC_CONTROL1F		0x3A1F	/*0x40 RW Bit[7:0]: Fast zone low threshold*/
+#define OV2710_AEC_CONTROL20		0x3A20	/*0x20 RW*/
+											/* Bit[7:3]: Not used*/
+											/* Bit[2]:Strobe option*/
+											/* Bit[1]:Manual average enable 0:Average data manual set disable 1:Average data manual set enable*/
+											/* Bit[0]:Not used*/
+#define OV2710_OTP_DATA_0		0x3D00	/*0x00 RW OTP Dump/Load Data 0*/
+#define OV2710_OTP_DATA_1		0x3D01	/*0x00 RW OTP Dump/Load Data 1*/
+#define OV2710_OTP_DATA_2		0x3D02	/*0x00 RW OTP Dump/Load Data 2*/
+#define OV2710_OTP_DATA_3		0x3D03	/*0x00 RW OTP Dump/Load Data 3*/
+#define OV2710_OTP_DATA_4		0x3D04	/*0x00 RW OTP Dump/Load Data 4*/
+#define OV2710_OTP_DATA_5		0x3D05	/*0x00 RW OTP Dump/Load Data 5*/
+#define OV2710_OTP_DATA_6		0x3D06	/*0x00 RW OTP Dump/Load Data 6*/
+#define OV2710_OTP_DATA_7		0x3D07	/*0x00 RW OTP Dump/Load Data 7*/
+#define OV2710_OTP_DATA_8		0x3D08	/*0x00 RW OTP Dump/Load Data 8*/
+#define OV2710_OTP_DATA_9		0x3D09	/*0x00 RW OTP Dump/Load Data 9*/
+#define OV2710_OTP_DATA_A		0x3D0A	/*0x00 RW OTP Dump/Load Data A*/
+#define OV2710_OTP_DATA_B		0x3d0b	/*0x00 RW OTP Dump/Load Data B*/
+#define OV2710_OPT_DATA_C		0x3d0D	/*0x00 RW OTP Dump/Load Data C*/
+#define OV2710_OPT_DATA_D		0x3D0D	/*0x00 RW OTP Dump/Load Data D*/
+#define OV2710_OPT_DATA_E		0x3D0E	/*0x00 RW OTP Dump/Load Data E*/
+#define OV2710_OPT_DATA_F		0x3D0F	/*0x00 RW OTP Dump/Load Data F*/
+#define OV2710_OTP_CONTROL		0x3D10	/*0x00 RW Bit[2]:OTP load option 0:Fast 1: Bit[1:0]: OTP mode 00: OTP off 10: Write/program OTP 11: OTP off*/
+#define OV2710_BIST_CTRL07		0x3E07	/*0x20 RW*/
+											/* Bit[7] Specifies BIST start. It should first be high, */
+											/* Bit[5] Specifies BIST test mode 0:Manual mode 1:Auto mode*/
+											/* Bit[4:0]: Not used*/
+#define OV2710_BIST_CTRL12		0x3E0C	/*0x00 RW*/
+											/* Bit[4]:BIST busy Specifies BIST busy status*/
+											/* Bit[2:0]: BIST error byte Specifies BIST error type*/
+#define OV2710_BIST_RESULT		0x3E0F	/*0x00 RW BIST Test Result01 (0: BIST pass; 1: BIST error)*/
+											/* Bit[7:4]: Not used*/
+											/* Bit[2]:ISP DPC*/
+											/* Bit[2]:VFIFO*/
+											/* Bit[1:0]: SRM*/
+#define OV2710_BIST_DONE		0x3E14	/* R BIST Done Signal When Bit[0] is changed to 1, the signal is cleared*/
+#define OV2710_BLC_CONTROL_00		0x4000	/*0x01 RW*/
+											/* Bit[3]:AVG frame enable 0:BLC is the calculating value 1:BLC will be the average of the calculating value and the original BLC*/
+											/* Bit[2]:Not used*/
+											/* Bit[1]:Freeze enable 0:BLC will be updated in some cases 1:BLC will be keep original value*/
+											/* Bit[0]:BLC enable 0:Disable */
+#define OV2710_BLC_CONTROL_01		0x4001	/*0x00 RW Bit[4:0] Start statistic black line Range from 0 to 31*/
+#define OV2710_BLC_CONTROL_02		0x4002	/*0x00 RW Bit[6]:Manual offset enable*/
+#define OV2710_BLC_FRAME_CONTROL		0x401D	/*0x22 RW */
+											/* Bit[5:4]: BLC enable mode 00: Always update 10: Update when gain changes x1: No update*/
+											/* Bit[3:2]: Not used*/
+											/* Bit[1]:Format change enable*/
+											/* Bit[0]:Not used*/
+#define OV2710_FRAME_CTRL00		0x4201	/* 0x00 RW Bit[3:0]: Frame on number. Control passed frame nubmer. When both ON and OFF numbers are set to 0x00.frame control is in bypass mode.*/
+#define OV2710_FRAME_CTRL01		0x4202	/* 0x00 RW Bit[3:0]: Frame off number Control masked frame number When both ON and OFF numbers are set_to 0x00. frame control is in bypass mode.*/
+#define OV2710_DVP_CTRL00		0x4700	/*0x04 RW*/
+											/* Bit[3]:CCIR656 v select*/
+											/* Bit[2]:CCIR656 f value*/
+											/* Bit[1]:CCIR656 mode enable*/
+											/* Bit[0]:HSYNC mode enable*/
+#define OV2710_DVP_CTRL01		0x4704	/*0x00 RW*/
+											/* Bit[7:4]: Not used*/
+											/* Bit[3:2]: VSYNC output mode select*/
+											/* Bit[1]:VSYNC3 mode enable VSYNC generated by EOF, unset by first 1 i, long VSYNC turns to 0x00 when first 1 i set*/
+											/* Bit[0]:VSYNC2 mode enable VSYNC generated by EOF, width controlled by regiser default VYSNC1 mode enable. VSYNC generated by SOF,width controlled by register*/
+#define OV2710_DVP_CTRL02		0x4708	/*0x01 RW*/
+											/* Bit[7]:CLK DDR mode enable*/
+											/* Bit[6]:Not used*/
+											/* Bit[5]:VSYNC gate CLK enable*/
+											/* Bit[4]:HREF gate CLK enable*/
+											/* Bit[3]:Not used*/
+											/* Bit[2]:HREF polarity*/
+											/* Bit[1]:VSYNC polarity*/
+											/* Bit[0]:PCLK gate low enable*/
+#define OV2710_DVP_CTRL03		0x4709	/*0x00 RW*/
+											/* Bit[7]:Video FIFO bypass mode*/
+											/* Bit[6:4]: Data bit swap*/
+											/* 000: Output data is the same order */
+											/* 001: Output data is reversed, [0:9]*/
+											/* 010: Output data is reordered as {[2:9], [1:0]}*/
+											/* 011: Output data is reordered as {[7:0], [9:8]}*/
+											/* 100: Output data is reordered as {[9:8], [0:7]}*/
+											/* 101: Output data is reordered as {[9], [0:8]}*/
+											/* 110: Output data is reordered as {[1:9], [0]}*/
+											/* 111:Output data is reordered as {[8:0], [9]}*/
+#define OV2710_MIPI_CTRL_00		0x4800	/*0x04 RW*/
+											/* Bit[7:6]: Not used*/
+											/* Bit[5]:Clock lane gate enable 0:Enable 1:Disable*/
+											/* Bit[4]:Line sync enable 0:Do not send line short packet for each line 1:Send line short packet for each line*/
+											/* Bit[3]:Lane select 0:Use lane1 as default data lane 1:Use lane2 as default data lane*/
+											/* Bit[2]:Idle status LP11 when no packet is transmitted*/
+											/* Bit[1:0]: Not used*/
+#define OV2710_MIPI_CTRL_01		0x4801	/*0x04 RW*/
+											/* Bit[7]:Long packet data type 0: use mipi data type. 1: use manual data type*/
+											/* Bit[6]:Short packet data type manual enable 0:Use auto value 1:Use manual value as short packet data*/
+											/* Bit[5]:Short packet WORD COUNTER manual enable 0:Use frame counter or line counter 1:Select manual value */
+											/* Bit[4]:PH bit order for ECC 0:{DI[7:0],WC[7:0], WC[15:8]} 1:{DI[0:7],WC[0:7], WC[8:15]}*/
+											/* Bit[3]:PH byte order for ECC 0:{DI,WC_l,WC_h} 1:{DI,WC_h,WC_l}*/
+											/* Bit[2]:PH byte order2 for ECC 0:{DI,WC} 1:{WC,DI}*/
+											/* Bit[1]:MARK1 enable for data lane1 0:Disable MARK1 1:When resume, lane1 should send MARK1*/
+											/* Bit[0]:MARK1 enable for data lane2 0:Disable MARK1 1:When resume, lane2 should send MARK1*/
+#define OV2710_MIPI_CTRL_03		0x4803	/*0x5F RW*/
+											/* Bit[7:4]: Not used*/
+											/* Bit[3]:Enable LP CD when HS TX for lane1 0:Disable 1:Enable*/
+											/* Bit[2]:Enable LP CD when HS TX for lane2 0:Disable 1:Enable*/
+											/* Bit[1]:Enable LP CD when LP TX for lane2 0:Disable 1:Enable*/
+											/* Bit[0]:Enable LP CD when LP TX for lane1 0:Disable 1:Enable*/
+#define OV2710_MIPI_CTRL_04		0x4804	/*0x8C RW*/
+											/* Bit[4]:Enable MIPI LP RX to read/write regitsers 0:Disable, RX LP data will write to VFIFO 1:Enable */
+											/* Bit[3]:Address read/write register will auto add 1 0:Disable 1:Enable*/
+											/* Bit[2]:LP TX lane select 0:Select lane1 to transmit LP data 1:Select lane2 to transmit LP data*/
+											/* Bit[1:0]: Not used*/
+#define OV2710_MIPI_CTRL_05		0x4805	/*0x10 RW*/
+											/* Bit[7]:MIPI lane2 disable 0:enable lane2. 1: disable mipi data lane1,lane1 will be LP00*/
+											/* Bit[6]:MIPI lane1 disable 0:enable lane1. 1:Disable MIPI data lane1, lane1 will be LP00*/
+											/* Bit[5]:LPX Global timing select 0:Auto calculate T LPX in PCLK2X domain, unit CLK2X 1:Use lp_p_min[7:0]*/
+											/* Bit[4:3]: Not used*/
+											/* Bit[2]:MIPI read/write registers disable 0:Enable MIPI access SRB 1:Disable MIPI access SRB*/
+											/* Bit[1:0]: Not used */
+#define OV2710_MAX_FCNT_H		0x4810	/*0xFF RW High Byte of Max Frame Counter of Frame Sync Short PKT*/
+#define OV2710_MAX_FCNT_L		0x4811	/*0xFF RW Low Byte of Max Frame Counter of Frame Sync Short Packet*/
+#define OV2710_MIN_SPKT_WC_REG_H		0x4812	/*0x00 RW High Byte of Manual Short Packet Word Counter*/
+#define OV2710_MIN_SPKT_WC_REG_L		0x4813	/*0x00 RW Low Byte of Manual Short Packet Word Counter*/
+#define OV2710_MIPI_CTRL_14		0x4814	/*0x2A RW Bit[7:6]:Virtual channel of MIPI packet Bit[5:0]:Data type manual*/
+#define OV2710_MIPI_SPKT_DT		0x4815	/*0x00 RW Manual Data type for short packet*/
+#define OV2710_MIN_HS_ZERO_H		0x4818	/*0x00 RW High Byte of Minimum Value of hs_zero, unit ns*/
+#define OV2710_MIN_HS_ZERO_L		0x4819	/*0x96 RW Low Byte of Minimum Value of hs_zero hs_zero_real = hs_zero_min_o + tui ui_hs_zero_min_o*/
+#define OV2710_MIN_MIPI_HS_TRAIL_H		0x481A	/*0x00 RW High Byte of Minimum Value of hs_trail, unit ns*/
+#define OV2710_MIN_MIPI_HS_TRAIL_L		0x481B	/*0x3C RW Low Byte of Minimum Value of hs_trail hs_trail_real = hs_trail_min_o + tui ui_hs_trail_min_o*/
+#define OV2710_MIN_MIPI_CLK_ZERO_H		0x481C	/*0x01 RW High Byte of Minimum Value of clk_zero, unit ns*/
+#define OV2710_MIN_MIPI_CLK_ZERO_L		0x481D	/*0x86 RW Low Byte of Minimum Value of clk_zero clk_zero_real = clk_zero_min_o + tui ui_clk_zero_min_o*/
+#define OV2710_MIN_MIPI_CLK_PREPARE_H		0x481E	/*0x00 RW High Byte of Minimum Value of clk_prepare, unit ns*/
+#define OV2710_MIN_MIPI_CLK_PREPARE_L		0x481F	/*0x3C RW Low Byte of Minimum Value of clk_prepare clk_prepare_real = clk_prepare_min_o + tui ui_clk_prepare_min_o*/
+#define OV2710_MIN_CLK_POST_H		0x4820	/*0x00 RW  High Byte of Minimum Value of clk_post, unit ns*/
+#define OV2710_MIN_CLK_POST_L		0x4821	/*0x56 RW Low Byte of Minimum Value of clk_post clk_post_real = clk_post_min_o + tui ui_clk_post_min_o*/
+#define OV2710_MIN_CLK_TRAIL_H		0x4822	/*0x00 RW High Byte of Minimum Value of clk_trail, unit ns*/
+#define OV2710_MIN_CLK_TRAIL_L		0x4823	/*0x3C RW Low Byte of Minimum Value of clk_trail clk_trail_real = clk_trail_min_o + tui ui_clk_trail_min_o*/
+#define OV2710_MIN_LPX_PCLK_H		0x4824	/*0x00 RW High Byte of Minimum Value of lpx_p, unit ns*/
+#define OV2710_MIN_LPX_PCLK_L		0x4825	/*0x32 RW Low Byte of Minimum Value of lpx_p lpx_p_real = lpx_p_min_o + tui ui_lpx_p_min_o*/
+#define OV2710_MIN_HS_PREPARE_H		0x4826	/*0x00 RW High Byte of Minimum Value of hs_prepare, unit ns*/
+#define OV2710_MIN_HS_PREPARE_L		0x4827	/*0x32 RW Low Byte of Minimum Value of hs_prepare hs_prepare_real = hs_prepare_min_o + tui ui_hs_prepare_min_o*/
+#define OV2710_MIN_HS_EXIT_H		0x4828	/*0x00 RW High Byte of Minimum Value of hs_exit, unit ns*/
+#define OV2710_MIN_HS_EXIT_L		0x4829	/*0x64 RW Low Byte of Minimum Value of hs_exit hs_exit_real = hs_exit_min_o + tui ui_hs_exit_min_o*/
+#define OV2710_MIN_HS_ZERO_UI		0x482A	/*0x05 RW Minimum UI Value of hs_zero, unit UI*/
+#define OV2710_MIN_HS_TRAIL_UI		0x482B	/*0x04 RW Minimum UI Value of hs_trail, unit UI*/
+#define OV2710_MIN_CLK_ZERO_UI		0x482C	/*0x00 RW Minimum UI Value of clk_zero, unit UI*/
+#define OV2710_MIN_CLK_PREPARE_UI		0x482D	/*0x00 RW Minimum UI Value of clk_prepare, unit UI*/
+#define OV2710_MIN_CLK_POST_UI		0x482E	/*0x34 RW Minimum UI Value of clk_post, unit UI*/
+#define OV2710_MIN_CLK_TRAIL_UI		0x482F	/*0x00 RW Minimum UI Value of clk_trail, unit UI*/
+#define OV2710_MIN_LPX_PCLK_UI		0x4830	/*0x00 RW Minimum UI Value of lpx_p (pclk2x domain), unit UI*/
+#define OV2710_MIN_HS_PREPARE_UI		0x4831	/*0x04 RW Minimum UI Value of hs_prepare, unit UI*/
+#define OV2710_MIN_HS_EXIT_UI		0x4832	/*0x00 RW Minimum UI Value of hs_exit, unit UI*/
+#define OV2710_ISP_CONTROL0		0x5000	/*0xDF RW*/
+											/* Bit[7]:LENC enable 0:Disable 1:Enable*/
+											/* Bit[6:3]: Not used*/
+											/* Bit[2]:Black pixel cancellation enable 0:Disable 1:Enable*/
+											/* Bit[1]:White pixel cancellation enable 0:Disable 1:Enable*/
+											/* Bit[0]:Not used*/
+#define OV2710_ISP_CONTROL1		0x5001	/*0x4F RW Bit[0]:AWB enable 0:Disable 1:Enable*/
+#define OV2710_ISP_CONTROL2		0x5002	/*0xE0 RW Bit[2]:VAP enable 0:Disable 1:Enable*/
+#define OV2710_ISP_CONTROL5		0x5005	/*0xDC RW Bit[4]:AWB bias on*/
+#define OV2710_ISP_CONTROL31		0x501F	/*0x03 RW Bit[2:0]: Format select 011: ISP RAW 100: INT CIF RAW*/
+#define OV2710_ISP_TEST		0x503D	/*0x00 RW*/
+											/* Bit[7]: 0: off; 1:Color bar enable*/
+											/* Bit[5:4]: Color bar pattern select 10: Color bar pattern*/
+											/* Bit[2]:Color bar rolling enable*/
+#define OV2710_ISP_SENSOR_BIAS_READOUT		0x503E	/* R ISP Sensor Bias Readout*/
+#define OV2710_ISP_SENSOR_GAIN_READOUT		0x503F	/* R ISP Sensor Gain Readout*/
+#define OV2710_AWB_CONTROL_00		0x5180	/*0x40 RW Bit[6]:fast_awb Bit[5]:freeze_gain_en Bit[4]:freeze_sum_en Bit[2]:start_sel*/
+#define OV2710_AWB_CONTROL_01		0x5181	/*0x02 RW Bit[7:0]: Delta*/
+#define OV2710_AWB_CONTROL_02		0x5182	/*0x04 RW Bit[7:0]: Stable range*/
+#define OV2710_STABLE_RANGE_WIDE		0x5183	/*0x08 RW Bit[7:0]: Stable range to determine whether it is in stable status when it is already in stable status*/
+#define OV2710_RED_GAIN_LIMIT		0x518C	/*0xF0 RW*/
+											/* Bit[7:4]: Red gain up limit Maximum red gain is: red gain up limit *256 + 0xFF*/
+											/* Bit[3:0]: Red gain down limit Minimum red gain is: red gain down limit *256 + 0*/
+#define OV2710_GREEN_GAIN_LIMIT		0x518D	/*0xF0  RW*/
+											/* Bit[7:4]: Green gain up Maximum green gain is: green gain up limit*256 + 0xFF*/
+											/* Bit[3:0]: Green gain down Minimum green gain is: green gain down limit*256 + 0*/
+#define OV2710_BLUE_GAIN_LIMIT		0x518E	/*0xF0 RW*/
+											/* Bit[7:4]: Blue gain up limit Maximum blue gain is: blue gain up limit*256 + 0xFF*/
+											/* Bit[3:0]: Blue gain down limit Minimum blue gain is: blue gain down limit*256 + 0*/
+#define OV2710_AWB_FRAME_COUNTER		0x518F	/*0x04 RW Bit[3:0]: Number of frames to do AWB when AWB is in stable mode*/
+#define OV2710_RED_BEFORE_GAIN_AVERAGE		0x5196	/* R Bit[7:0]: Before AWB gain's red data average*/
+#define OV2710_GREEN_BEFORE_GAIN_AVERAGE		0x5197	/* R Bit[7:0]: Before AWB gain's green data average*/
+#define OV2710_BLUE_BEFORE_GAIN_AVERAGE		0x5198	/* R Bit[7:0]: Before AWB gain's blue data average*/
+#define OV2710_RED_AFTER_GAIN_AVERAGE_H		0x5199	/* R Bit[7:0]: After AWB gain's red data average high byte*/
+#define OV2710_RED_AFTER_GAIN_AVERAGE_L		0x519A	/* R Bit[7:0]: After AWB gain's red data average low byte*/
+#define OV2710_GREEN_AFTER_GAIN_AVERAGE_H		0x519B	/* R Bit[7:0]: After AWB gain's green data average high byte*/
+#define OV2710_GREEN_AFTER_GAIN_AVERAGE_L		0x519C	/* R Bit[7:0]: After AWB gain's green data average low byte*/
+#define OV2710_BLUE_AFTER_GAIN_AVERAGE_H		0x519D	/* R Bit[7:0]: After AWB gain's blue data average high byte*/
+#define OV2710_BLUE_AFTER_GAIN_AVERAGE_L		0x519E	/* R Bit[7:0]: After AWB gain's blue average low byte*/
+#define OV2710_AVG_START_POSITION_AT_HORIZONTAL_H		0x5680	/*0x00 RW Bit[3:0]: AVG start position[11:8] at horizontal*/
+#define OV2710_AVG_START_POSITION_AT_HORIZONTAL_L		0x5681	/*0x00 RW Bit[7:0]: AVG start position[7:0] at horizontal*/
+#define OV2710_AVG_END_POSITION_AT_HORIZONTAL_H		0x5682	/*0x08 RW Bit[3:0]: AVG end position[11:8] at horizontal*/
+#define OV2710_AVG_END_POSITION_AT_HORIZONTAL_L		0x5683	/*0x00 RW Bit[7:0]: AVG end position[7:0] at horizontal*/
+#define OV2710_AVG_START_POSITION_AT_VERTICAL_H		0x5684	/*0x00 RW Bit[2:0]: AVG start position[10:8] at vertical*/
+#define OV2710_AVG_START_POSITION_AT_VERTICAL_L		0x5685	/*0x80 RW Bit[7:0]: AVG start position[7:0] at vertical*/
+#define OV2710_AVG_END_POSITION_AT_VERTICAL_H		0x5686	/*0x00 RW Bit[2:0]: AVG end position[10:8] at vertical*/
+#define OV2710_AVG_END_POSITION_AT_VERTICAL_L		0x5687	/*0x00 RW Bit[7:0]: AVG end position[7:0] at vertical*/
+#define OV2710_AVG_R10		0x5690	/* R Bit[7:0]: Average of raw image[9:2]*/
+#define OV2710_DPC_CTRL00		0x5780	/*0x7F RW*/
+											/* Bit[7]:Not used*/
+											/* Bit[6]: Keep vertical channel 0: 1:*/
+											/* Bit[5]: connected 0:Disable removing the same channel connected defected pixels 1:Enable removing the same channel connected defected pixels*/
+											/* Bit[4]:Enable different channel connected 0:Disable removing the different channel connected defected pixels. 1: Enable removing the different channel connected defected pixels*/
+											/* Bit[3:2]: Matching index selection */
+											/* 00: No matching point check */
+											/* 01: Check the before and after pixels from the third to fourth pixels*/
+											/* 10: Check the before and after pixels from the third to fifth pixels*/
+											/* 11: Check the before and after pixels from the third to sixth pixels*/
+											/* Bit[1:0]: Not used*/
+#define OV2710_WHITE_THRESHOLD_LIST0		0x5781	/*0x20 RW Bit[6:0]: White pixel threshold list 0*/
+#define OV2710_WHITE_THRESHOLD_LIST1		0x5782	/*0x18 RW Bit[6:0]: White pixel threshold list 1*/
+#define OV2710_WHITE_THRESHOLD_LIST2		0x5783	/*0x08 RW Bit[6:0]: White pixel threshold list 2*/
+#define OV2710_WHITE_THRESHOLD_LIST3		0x5784	/*0x04 RW Bit[6:0]: White pixel threshold list 3*/
+#define OV2710_BLACK_THRESHOLD_LIST0		0x5785	/*0x40 RW Bit[7:0]: Black pixel threshold list 0 */
+#define OV2710_BLACK_THRESHOLD_LIST1		0x5786	/*0x18 RW Bit[7:0]: Black pixel threshold list 1*/
+#define OV2710_BLACK_THRESHOLD_LIST2		0x5787	/*0x08 RW Bit[7:0]: Black pixel threshold list 2*/
+#define OV2710_BLACK_THRESHOLD_LIST3		0x5788	/*0x04 RW Bit[7:0]: Black pixel threshold list 3*/
+#define OV2710_GAIN_LIST1		0x5789	/*0x08 RW Bit[6:0]: Gain list 1*/
+#define OV2710_GAIN_LIST2		0x578A	/*0x20 RW Bit[6:0]: Gain list 2*/
+#define OV2710_DPC_CTRL01		0x578B	/*0x07 RW*/
+											/* Bit[3]:Mode 1 enable 0:Disable 1:Enable only remove cluster*/
+											/* Bit[2]:Mode 2 enable 0:Disable 1:Enable*/
+#define OV2710_DPC_SATURATE		0x578C	/*0x00 RW Saturate Value Set for Cross Cluster*/
+#define OV2710_PATTERN_THRESHOLD_LIST0H		0x5790	/*0x00 RW Bit[1:0]: Pattern threshold list 0[9:8]*/
+#define OV2710_PATTERN_THRESHOLD_LIST0L		0x5791	/*0x08 RW Bit[7:0]: Pattern threshold list 0[7:0]*/
+#define OV2710_PATTERN_THRESHOLD_LIST1H		0x5792	/*0x00 RW Bit[1:0]: Pattern threshold list 1[9:8]*/
+#define OV2710_PATTERN_THRESHOLD_LIST1L		0x5793	/*0x18 RW Bit[7:0]: Pattern threshold list 1[7:0]*/
+#define OV2710_PATTERN_THRESHOLD_LIST2H		0x5794	/*0x00 RW Bit[1:0]: Pattern threshold list 2[9:8]*/
+#define OV2710_PATTERN_THRESHOLD_LIST2L		0x5795	/*0x80 RW Bit[7:0]: Pattern threshold list 2[7:0]*/
+#define OV2710_PATTERN_THRESHOLD_H		0x5796	/*0x01 RW Bit[1:0]: Pattern threshold list 3[9:8]*/
+#define OV2710_PATTERN_THRESHOLD_L		0x5797	/*0x00 RW Bit[7:0]: Pattern threshold list 3[7:0]*/
+#define OV2710_LENC_RED_X0_H		0x5800	/*0x00 RW Bit[7:0]: Red center horizontal position (x0) high bits*/
+#define OV2710_LENC_RED_X0_L		0x5801	/*0x0C RW Bit[7:0]: Red center horizontal position*/
+#define OV2710_LENC_RED_Y0_H		0x5802	/*0x00 RW Bit[7:0]: Red center vertical position (y0) high bits*/
+#define OV2710_LENC_RED_Y0_L		0x5803	/*0x06 RW Bit[7:0]: Red center vertical position (y0) low eight bits*/
+#define OV2710_LENC_RED_A1		0x5804	/*0x22 RW Bit[7:0]: Red parameter a1 a1 and a2 are used to generate the a parameter*/
+#define OV2710_LENC_RED_A2		0x5805	/*0x07 RW Bit[7:0]: Red parameter a2 a1 and a2 are used to generate the parameter a*/
+#define OV2710_LENC_RED_B1		0x5806	/*0xC2 RW*/
+											/* Bit[7]: Sign bit 0: b1 is positive 1:b1 is negative*/
+											/* Bit[6:0]: Red parameter b1. b1 and b2 are used to generate the parameter b*/
+#define OV2710_LENC_RED_B2		0x5807	/*0x08 RW Bit[3:0]: Red parameter b2 b1 and b2 are used to generate the parameter b*/
+#define OV2710_LENC_GRN_X0_H		0x5808	/*0x00 RW Bit[7:0]: Green center horizontal position (x0) high bits*/
+#define OV2710_LENC_GRN_X0_L		0x5809	/*0x0C RW Bit[7:0]: Green center horizontal position (x0) low eight bits*/
+#define OV2710_LENC_GRN_Y0_H		0x580A	/*0x00 RW Bit[7:0]: Green center vertical position (y0) high bits*/
+#define OV2710_LENC_GRN_Y0_L		0x580B	/*0x06 RW Bit[7:0]: Green center vertical position (y0) low eight bits*/
+#define OV2710_LENC_GRN_A0_H		0x580C	/*0x22 RW Bit[7:0]: Green parameter a1 a1 and a2 are used to generate the parameter a*/
+#define OV2710_LENC_GRN_A0_L		0x580D	/*0x07 RW Bit[7:0]: Green parameter a2 a1 and a2 are used to generate the parameter a*/
+#define OV2710_LENC_GRN_B1		0x580E	/*0xC2 RW */
+											/* Bit[7]:Sign bit 0:b1 is positive 1:b1 is negative*/
+											/* Bit[6:0]: Green parameter b1 b1 and b2 are used to generate the parameter b*/
+#define OV2710_LENC_GRN_B2		0x580F	/*0x08 RW Bit[3:0]: Green parameter b2 b1 and b2 are used to generate the parameter b*/
+#define OV2710_LENC_BLU_X0_H		0x5810	/*0x00 RW Bit[7:0]: Blue center horizontal position (x0) high bits*/
+#define OV2710_LENC_BLU_X0_L		0x5811	/*0x0C RW Bit[7:0]: Blue center horizontal position (x0) low eight bits*/
+#define OV2710_LENC_BLU_Y0_H		0x5812	/*0x00 RW Bit[7:0]: Blue center vertical position (y0)high eight bits*/
+#define OV2710_LENC_BLU_Y0_L		0x5813	/*0x06 RW Bit[7:0]: Blue center vertical position (y0)low eight bits*/
+#define OV2710_LENC_BLU_A1		0x5814	/*0x22 RW Bit[7:0]: Blue parameter a1.  a1 and a2 are used to generate the parameter a*/
+#define OV2710_LENC_BLU_A2		0x5815	/*0x07 RW Bit[7:0]: Blue parameter a2 a1 and a2 are used to generate the parameter a*/
+#define OV2710_LENC_BLU_B1		0x5816	/*0xC2 RW*/
+											/* Bit[7:0]: Sign bit 0:b1 is positive 1:b1 is negative*/
+											/* Bit[6:0]: blue parameter b1 b1 and b2 are used to generate the parameter b*/
+#define OV2710_LENC_BLU_B2		0x5817	/*0x08 RW Bit[3:0]: Blue parameter b2 b1 and b2 are used to generate the parameter b*/
+#define OV2710_LENC_CTRL00		0x5818	/*0x04 RW*/
+											/* Bit[2]:Round enable*/
+											/* Bit[1]: 0:Disable coefficient manual mode 1:Enable coefficient manual mode, use auto mode to calculate the coefficient*/
+											/* Bit[0]:gain coefficient enable 0:Use the gain = 128 to calculate the coefficient 1:Use the sensor gain to calculate the coefficient*/
+#define OV2710_LENC_COEF_TH		0x5819	/*0x80 RW Bit[7:0]: LENC coefficient threshold*/
+#define OV2710_LENC_GAIN_THRE1		0x581A	/*0x00 RW Bit[7:0]: LENC gain low threshold (t1)*/
+#define OV2710_LENC_GAIN_THRE2		0x581B	/*0x00 RW Bit[7:0]: LENC gain high threshold (t2)*/
+#define OV2710_LENC_COEF_MAN		0x581C	/*0x80 RW Bit[7:0]: Coefficient manual input*/
+#define OV2710_AFC_CTRL00		0x6000	/*0x1F RW*/
+											/* Bit[7:5]: Not used*/
+											/* Bit[4]:Edge filter enable 0:afc_edge module will not update 1:afc_edge module will update*/
+											/* Bit[3]:Edge filter b select 0:DGE selects b2 1:Edge selects b1*/
+											/* Bit[2:0]: Edge filter a select*/
+											/* 000: Edge selects a1*/
+											/* 001: Edge selects a2*/
+											/* 010: Edge selects a3*/
+											/* 100: Edge selects a4*/
+											/* 101: Edge selects a5*/
+#define OV2710_AFC_CTRL01		0x6001	/*0x01 RW Bit[7:0]: Edge window0 left coordinate*/
+#define OV2710_AFC_CTRL02		0x6002	/*0x00 RW Bit[7:0]: Edge window0 top coordinate*/
+#define OV2710_AFC_CTRL03		0x6003	/*0x76 RW Bit[7:0]: Edge window0 right coordinate*/
+#define OV2710_AFC_CTRL04		0x6004	/*0x42 RW Bit[7:0]: Edge window0 bottom coordinate This bottom must be larger than any other*/
+#define OV2710_AFC_CTRL05		0x6005	/*0x01 RW Bit[7:0]: Edge window1 left coordinate*/
+#define OV2710_AFC_CTRL06		0x6006	/*0x00 RW Bit[7:0]: Edge window1 top coordinate*/
+#define OV2710_AFC_CTRL07		0x6007	/*0x76 RW Bit[7:0]: Edge window1 right coordinate*/
+#define OV2710_AFC_CTRL08		0x6008	/*0x42 RW Bit[7:0]: Edge window1 bottom coordinate*/
+#define OV2710_AFC_CTRL09		0x6009	/*0x01 RW Bit[7:0]: Edge window2 left coordinate*/
+#define OV2710_AFC_CTRL10		0x600A	/*0x00 RW*/
+#define OV2710_AFC_CTRL11		0x600B	/*0x76 RW*/
+#define OV2710_AFC_CTRL12		0x600C	/*0x42 RW Bit[7:0]: Edge window2 bottom coordinate*/
+#define OV2710_AFC_CTRL13		0x600D	/*0x01 RW Bit[7:0]: Edge window3 left coordinate*/
+#define OV2710_AFC_CTRL14		0x600E	/*0x00 RW Bit[7:0]: Edge window3 top coordinate*/
+#define OV2710_AFC_CTRL15		0x600F	/*0x76 RW Bit[7:0]: Edge window3 right coordinate*/
+#define OV2710_AFC_CTRL16		0x6010	/*0x42 RW Bit[7:0]: Edge window3 bottom coordinate*/
+#define OV2710_AFC_CTRL17		0x6011	/*0x01 RW Bit[7:0]: Edge window4 left coordinate*/
+#define OV2710_AFC_CTRL18		0x6012	/*0x00 RW Bit[7:0]: Edge window4 top coordinate*/
+#define OV2710_AFC_CTRL19		0x6013	/*0x76 RW Bit[7:0]: Edge window4 right coordinate*/
+#define OV2710_AFC_CTRL20		0x6014	/*0x42 RW Bit[7:0]: Edge window4 bottom coordinate*/
+
+
+#define OV2710_VIDEO_FPS_REG_NUM		(8)
+#define OV2710_VIDEO_FORMAT_REG_NUM		(25)
+#define OV2710_VIDEO_FORMAT_REG_TABLE_SIZE		(3)
+#define OV2710_VIDEO_PLL_REG_TABLE_SIZE		(4)
+
+
+/** OV9710 mirror mode*/
+#define OV2710_MIRROR_ROW		(0x01 << 6)
+#define OV2710_MIRROR_COLUMN 	(0x01 << 5)
+#define OV2710_MIRROR_MASK    (OV2710_MIRROR_ROW + OV2710_MIRROR_COLUMN)
+
+#endif /* __OV2710_PRI_H__ */
+
diff --git a/drivers/vin/sensors/omnivision_ov2710_parallel/ov2710_table.c b/drivers/vin/sensors/omnivision_ov2710_parallel/ov2710_table.c
new file mode 100644
index 0000000..8b10ad4
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2710_parallel/ov2710_table.c
@@ -0,0 +1,445 @@
+/*
+ * Filename : ov2710_reg_tbl.c
+ *
+ * History:
+ *    2009/06/19 - [Qiao Wang] Create
+ *
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+static struct vin_video_pll ov2710_plls[] = {
+	{0, 23998464, 79994880},
+	{0, 24045120, 80150400},
+};
+
+static struct vin_video_format ov2710_formats[] = {
+	{
+		.video_mode	= AMBA_VIDEO_MODE_720P,
+		.def_start_x	= 0,
+		.def_start_y	= 0,
+		.def_width	= 1280,
+		.def_height	= 720,
+		/* sensor mode */
+		.device_mode	= 0,
+		.pll_idx	= 0,
+		.width		= 1280,
+		.height		= 720,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_10,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_60,
+		.default_fps	= AMBA_VIDEO_FPS_59_94,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_GB,
+	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_1080P,
+		.def_start_x	= 0,
+		.def_start_y	= 0,
+		.def_width	= 1920,
+		.def_height	= 1080,
+		/* sensor mode */
+		.device_mode	= 1,
+		.pll_idx	= 1,
+		.width		= 1920,
+		.height		= 1080,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_10,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_GB,
+	},
+};
+
+static struct vin_reg_16_8 ov2710_1080p_share_regs[] = {
+	//R2.2 Updated System Settings (v05)
+	{0x3103, 0x93},
+	{0x3008, 0x82},
+	{0x3017, 0x7f},
+	{0x3018, 0xfc},
+	{0x3706, 0x61},
+	{0x3712, 0x0c},
+	{0x3630, 0x6d},
+	{0x3801, 0xb4},
+	{0x3621, 0x04},
+	{0x3604, 0x60},
+	{0x3603, 0xa7},
+	{0x3631, 0x26},
+	{0x3600, 0x04},
+	{0x3620, 0x37},
+	{0x3623, 0x00},
+	{0x3702, 0x9e},
+	{0x3703, 0x5c},
+	{0x3704, 0x40},
+	{0x370d, 0x0f},
+	{0x3713, 0x9f},
+	{0x3714, 0x4c},
+	{0x3710, 0x9e},
+	{0x3801, 0xc4},
+	{0x3605, 0x05},
+	{0x3606, 0x3f},
+	{0x302d, 0x90},
+	{0x370b, 0x40},
+	{0x3716, 0x31},
+	{0x3707, 0x52},
+	{0x380d, 0x74},
+	{0x5181, 0x20},
+	{0x518f, 0x00},
+	{0x4301, 0xff},
+	{0x4303, 0x00},
+	{0x3a00, 0x78},
+	{0x300f, 0x88},
+	{0x3011, 0x28},
+	{0x3a1a, 0x06},
+	{0x3a18, 0x00},
+	{0x3a19, 0x7a},
+	{0x3a13, 0x54},
+	{0x382e, 0x0f},
+	{0x381a, 0x1a},
+	{0x401d, 0x02},
+	{0x5688, 0x03},
+	{0x5684, 0x07},
+	{0x5685, 0xa0},
+	{0x5686, 0x04},
+	{0x5687, 0x43},
+	{0x3a0f, 0x40},
+	{0x3a10, 0x38},
+	{0x3a1b, 0x48},
+	{0x3a1e, 0x30},
+	{0x3a11, 0x90},
+	{0x3a1f, 0x10},
+
+	{0x3010, 0x00},
+	//1928x1088
+	{0x3820, 0x00},
+	{0x3821, 0x00},
+	{0x381c, 0x00},
+	{0x381d, 0x02},
+	{0x381e, 0x04},
+	{0x381f, 0x44},
+	{0x3800, 0x01},
+	{0x3801, 0xC4},
+	{0x3804, 0x07},
+	{0x3805, 0x88},
+	{0x3802, 0x00},
+	{0x3803, 0x0A},
+	{0x3806, 0x04},
+	{0x3807, 0x40},
+	{0x3808, 0x07},
+	{0x3809, 0x88},
+	{0x380a, 0x04},
+	{0x380b, 0x40},
+	{0x380c, 0x09},
+	{0x380d, 0x74},
+	{0x380e, 0x04},
+	{0x380f, 0x50},
+	{0x3810, 0x08},
+	{0x3811, 0x02},
+
+	{0x370d, 0x0f},//Fix Black Shading issue from 0x7->0xF
+	{0x3621, 0x04},
+	{0x3622, 0x08},
+	{0x3818, 0x80},
+	{0x370d, 0x0f},//Fix Black Shading issue from 0x7->0xF
+
+	//AVG windows
+	{0x5688, 0x03},
+	{0x5684, 0x07},
+	{0x5685, 0x88},
+	{0x5686, 0x04},
+	{0x5687, 0x40},
+
+	{0x3a08, 0x14},
+	{0x3a09, 0xB3},
+	{0x3a0a, 0x11},
+	{0x3a0b, 0x40},
+	{0x3a0e, 0x03},
+	{0x3a0d, 0x04},
+
+	{0x401c, 0x08},
+
+	//off 3A
+	{0x3503, 0x07},//off aec/agc
+	{0x5001, 0x4e},//off awb
+	{0x5000, 0x5f},//off lenc
+
+	//mirror and flip here,for our new board */
+	{ 0x3621, 0x14},
+	{ 0x3803, 0x09},
+	{ 0x3818, 0xE0},
+
+	{ 0x4000, 0x05},//BLC control
+	{ 0x4006, 0x00},//black level target [9:8]
+	{ 0x4007, 0x00},//black level target [7:0]
+
+	//{ 0x4704, 0x02},//VSYNC2 mode enable
+};
+
+static struct vin_reg_16_8 ov2710_720p_share_regs[] = {
+	//R2.2 Updated System Settings (v05)
+	{0x3103, 0x93},
+	{0x3008, 0x82},
+	{0x3017, 0x7f},
+	{0x3018, 0xfc},
+	{0x3706, 0x61},
+	{0x3712, 0x0c},
+	{0x3630, 0x6d},
+	{0x3801, 0xb4},
+	{0x3621, 0x04},
+	{0x3604, 0x60},
+	{0x3603, 0xa7},
+	{0x3631, 0x26},
+	{0x3600, 0x04},
+	{0x3620, 0x37},
+	{0x3623, 0x00},
+	{0x3702, 0x9e},
+	{0x3703, 0x5c},
+	{0x3704, 0x40},
+	{0x370d, 0x0f},
+	{0x3713, 0x9f},
+	{0x3714, 0x4c},
+	{0x3710, 0x9e},
+	{0x3801, 0xc4},
+	{0x3605, 0x05},
+	{0x3606, 0x3f},
+	{0x302d, 0x90},
+	{0x370b, 0x40},
+	{0x3716, 0x31},
+	{0x3707, 0x52},
+	{0x380d, 0x74},
+	{0x5181, 0x20},
+	{0x518f, 0x00},
+	{0x4301, 0xff},
+	{0x4303, 0x00},
+	{0x3a00, 0x78},
+	{0x300f, 0x88},
+	{0x3011, 0x28},
+	{0x3a1a, 0x06},
+	{0x3a18, 0x00},
+	{0x3a19, 0x7a},
+	{0x3a13, 0x54},
+	{0x382e, 0x0f},
+	{0x381a, 0x1a},
+	{0x401d, 0x02},
+	{0x381c, 0x10},
+	{0x381d, 0xb8},
+	{0x381e, 0x02},
+	{0x381f, 0xdc},
+	{0x3820, 0x0a},
+	{0x3821, 0x29},
+	{0x3804, 0x05},
+	{0x3805, 0x00},
+	{0x3806, 0x02},
+	{0x3807, 0xd0},
+	{0x3808, 0x05},
+	{0x3809, 0x00},
+	{0x380a, 0x02},
+	{0x380b, 0xd0},
+	{0x380e, 0x02},
+	{0x380f, 0xe8},
+	{0x380c, 0x07},
+	{0x380d, 0x00},
+	{0x5688, 0x03},
+	{0x5684, 0x05},
+	{0x5685, 0x00},
+	{0x5686, 0x02},
+	{0x5687, 0xd0},
+	{0x3a08, 0x1b},
+	{0x3a09, 0xe6},
+	{0x3a0a, 0x17},
+	{0x3a0b, 0x40},
+	{0x3a0e, 0x01},
+	{0x3a0d, 0x02},
+	{0x3a0f, 0x40},
+	{0x3a10, 0x38},
+	{0x3a1b, 0x48},
+	{0x3a1e, 0x30},
+	{0x3a11, 0x90},
+	{0x3a1f, 0x10},
+
+	{0x3010, 0x00},
+
+	//1288x728
+	{0x3820, 0x09},
+
+	{0x3821, 0x29},
+	{0x381c, 0x10},
+	{0x381d, 0xBE},
+	{0x381e, 0x02},
+	{0x381f, 0xDC},
+	{0x3800, 0x01},
+	{0x3801, 0xC8},
+	{0x3804, 0x05},
+	{0x3805, 0x08},
+	{0x3802, 0x00},
+	{0x3803, 0x0A},
+	{0x3806, 0x02},
+	{0x3807, 0xD8},
+	{0x3808, 0x05},
+	{0x3809, 0x08},
+	{0x380a, 0x02},
+	{0x380b, 0xD8},
+	{0x380c, 0x07},
+	{0x380d, 0x00},
+	{0x380e, 0x02},
+	{0x380f, 0xE8},
+	{0x3810, 0x08},
+	{0x3811, 0x02},
+
+	{0x3503, 0x07},//off aec/agc
+	{0x5001, 0x4e},//off awb
+	{0x5000, 0x5f},//off lenc
+
+	//mirror and flip here,for our new board */
+	{ 0x3621, 0x14},
+	{ 0x3803, 0x09},
+	{ 0x3818, 0xE0},
+
+	{ 0x4000, 0x05},//BLC control
+	{ 0x4006, 0x00},//black level target [9:8]
+	{ 0x4007, 0x00},//black level target [7:0]
+
+	//{ 0x4704, 0x02},//VSYNC2 mode enable
+};
+
+/* OV2710 global gain table row size */
+#define OV2710_GAIN_ROWS		(97)
+#define OV2710_GAIN_COLS		(4)
+
+#define OV2710_GAIN_COL_AGC		(0)
+#define OV2710_GAIN_COL_FAGC		(1)
+#define OV2710_GAIN_COL_REG300A		(2)
+#define OV2710_GAIN_COL_REG300B		(3)
+#define OV2710_GAIN_0DB (OV2710_GAIN_ROWS - 1)
+
+/* This is 32-step gain table, OV2710_GAIN_ROWS = 162, OV2710_GAIN_COLS = 3 */
+const s16 ov2710_gains[OV2710_GAIN_ROWS][OV2710_GAIN_COLS] = {
+	{0x4000, 6144, 0x01, 0xFF},	/* index   0, gain = 36.123599 dB, actual gain = 35.847834 dB */
+	{0x3D49, 6080, 0x01, 0xFE},	/* index   1, gain = 35.747312 dB, actual gain = 35.847834 dB */
+	{0x3AB0, 6016, 0x01, 0xFD},	/* index   2, gain = 35.371024 dB, actual gain = 35.268560 dB */
+	{0x3833, 5952, 0x01, 0xFC},	/* index   3, gain = 34.994737 dB, actual gain = 34.963761 dB */
+	{0x35D1, 5888, 0x01, 0xFB},	/* index   4, gain = 34.618450 dB, actual gain = 34.647875 dB */
+	{0x3389, 5824, 0x01, 0xFA},	/* index   5, gain = 34.242162 dB, actual gain = 34.320067 dB */
+	{0x315A, 5760, 0x01, 0xF9},	/* index   6, gain = 33.865875 dB, actual gain = 33.979400 dB */
+	{0x2F42, 5696, 0x01, 0xF8},	/* index   7, gain = 33.489587 dB, actual gain = 33.624825 dB */
+	{0x2D41, 5632, 0x01, 0xF7},	/* index   8, gain = 33.113300 dB, actual gain = 33.255157 dB */
+	{0x2B56, 5568, 0x01, 0xF6},	/* index   9, gain = 32.737012 dB, actual gain = 32.869054 dB */
+	{0x2980, 5504, 0x01, 0xF5},	/* index  10, gain = 32.360725 dB, actual gain = 32.464986 dB */
+	{0x27BD, 5440, 0x01, 0xF4},	/* index  11, gain = 31.984437 dB, actual gain = 32.041200 dB */
+	{0x260E, 5376, 0x01, 0xF3},	/* index  12, gain = 31.608150 dB, actual gain = 31.595672 dB */
+	{0x2471, 5312, 0x01, 0xF2},	/* index  13, gain = 31.231862 dB, actual gain = 31.126050 dB */
+	{0x22E5, 5248, 0x01, 0xF1},	/* index  14, gain = 30.855575 dB, actual gain = 30.629578 dB */
+	{0x216B, 5184, 0x01, 0xF1},	/* index  15, gain = 30.479287 dB, actual gain = 30.629578 dB */
+	{0x2000, 5120, 0x00, 0xFF},	/* index  16, gain = 30.103000 dB, actual gain = 29.827234 dB */
+	{0x1EA5, 5056, 0x00, 0xFE},	/* index  17, gain = 29.726712 dB, actual gain = 29.827234 dB */
+	{0x1D58, 4992, 0x00, 0xFD},	/* index  18, gain = 29.350425 dB, actual gain = 29.247960 dB */
+	{0x1C1A, 4928, 0x00, 0xFC},	/* index  19, gain = 28.974137 dB, actual gain = 28.943161 dB */
+	{0x1AE9, 4864, 0x00, 0xFB},	/* index  20, gain = 28.597850 dB, actual gain = 28.627275 dB */
+	{0x19C5, 4800, 0x00, 0xFA},	/* index  21, gain = 28.221562 dB, actual gain = 28.299467 dB */
+	{0x18AD, 4736, 0x00, 0xF9},	/* index  22, gain = 27.845275 dB, actual gain = 27.958800 dB */
+	{0x17A1, 4672, 0x00, 0xF8},	/* index  23, gain = 27.468987 dB, actual gain = 27.604225 dB */
+	{0x16A1, 4608, 0x00, 0xF7},	/* index  24, gain = 27.092700 dB, actual gain = 27.234557 dB */
+	{0x15AB, 4544, 0x00, 0xF6},	/* index  25, gain = 26.716412 dB, actual gain = 26.848454 dB */
+	{0x14C0, 4480, 0x00, 0xF5},	/* index  26, gain = 26.340125 dB, actual gain = 26.444386 dB */
+	{0x13DF, 4416, 0x00, 0xF4},	/* index  27, gain = 25.963837 dB, actual gain = 26.020600 dB */
+	{0x1307, 4352, 0x00, 0xF3},	/* index  28, gain = 25.587550 dB, actual gain = 25.575072 dB */
+	{0x1238, 4288, 0x00, 0xF2},	/* index  29, gain = 25.211262 dB, actual gain = 25.105450 dB */
+	{0x1173, 4224, 0x00, 0xF1},	/* index  30, gain = 24.834975 dB, actual gain = 24.608978 dB */
+	{0x10B5, 4160, 0x00, 0xF1},	/* index  31, gain = 24.458687 dB, actual gain = 24.608978 dB */
+	{0x1000, 4096, 0x00, 0x7F},	/* index  32, gain = 24.082400 dB, actual gain = 23.806634 dB */
+	{0x0F52, 4032, 0x00, 0x7E},	/* index  33, gain = 23.706112 dB, actual gain = 23.806634 dB */
+	{0x0EAC, 3968, 0x00, 0x7D},	/* index  34, gain = 23.329825 dB, actual gain = 23.227360 dB */
+	{0x0E0D, 3904, 0x00, 0x7C},	/* index  35, gain = 22.953537 dB, actual gain = 22.922561 dB */
+	{0x0D74, 3840, 0x00, 0x7B},	/* index  36, gain = 22.577250 dB, actual gain = 22.606675 dB */
+	{0x0CE2, 3776, 0x00, 0x7A},	/* index  37, gain = 22.200962 dB, actual gain = 22.278867 dB */
+	{0x0C56, 3712, 0x00, 0x79},	/* index  38, gain = 21.824675 dB, actual gain = 21.938200 dB */
+	{0x0BD1, 3648, 0x00, 0x78},	/* index  39, gain = 21.448387 dB, actual gain = 21.583625 dB */
+	{0x0B50, 3584, 0x00, 0x77},	/* index  40, gain = 21.072100 dB, actual gain = 21.213957 dB */
+	{0x0AD6, 3520, 0x00, 0x76},	/* index  41, gain = 20.695812 dB, actual gain = 20.827854 dB */
+	{0x0A60, 3456, 0x00, 0x75},	/* index  42, gain = 20.319525 dB, actual gain = 20.423786 dB */
+	{0x09EF, 3392, 0x00, 0x74},	/* index  43, gain = 19.943237 dB, actual gain = 20.000000 dB */
+	{0x0983, 3328, 0x00, 0x73},	/* index  44, gain = 19.566950 dB, actual gain = 19.554472 dB */
+	{0x091C, 3264, 0x00, 0x72},	/* index  45, gain = 19.190662 dB, actual gain = 19.084850 dB */
+	{0x08B9, 3200, 0x00, 0x71},	/* index  46, gain = 18.814375 dB, actual gain = 18.588379 dB */
+	{0x085B, 3136, 0x00, 0x71},	/* index  47, gain = 18.438087 dB, actual gain = 18.588379 dB */
+	{0x0800, 3072, 0x00, 0x3F},	/* index  48, gain = 18.061800 dB, actual gain = 17.786034 dB */
+	{0x07A9, 3008, 0x00, 0x3E},	/* index  49, gain = 17.685512 dB, actual gain = 17.786034 dB */
+	{0x0756, 2944, 0x00, 0x3D},	/* index  50, gain = 17.309225 dB, actual gain = 17.206760 dB */
+	{0x0706, 2880, 0x00, 0x3C},	/* index  51, gain = 16.932937 dB, actual gain = 16.901961 dB */
+	{0x06BA, 2816, 0x00, 0x3B},	/* index  52, gain = 16.556650 dB, actual gain = 16.586075 dB */
+	{0x0671, 2752, 0x00, 0x3A},	/* index  53, gain = 16.180362 dB, actual gain = 16.258267 dB */
+	{0x062B, 2688, 0x00, 0x39},	/* index  54, gain = 15.804075 dB, actual gain = 15.917600 dB */
+	{0x05E8, 2624, 0x00, 0x38},	/* index  55, gain = 15.427787 dB, actual gain = 15.563025 dB */
+	{0x05A8, 2560, 0x00, 0x37},	/* index  56, gain = 15.051500 dB, actual gain = 15.193357 dB */
+	{0x056B, 2496, 0x00, 0x36},	/* index  57, gain = 14.675212 dB, actual gain = 14.807254 dB */
+	{0x0530, 2432, 0x00, 0x35},	/* index  58, gain = 14.298925 dB, actual gain = 14.403186 dB */
+	{0x04F8, 2368, 0x00, 0x34},	/* index  59, gain = 13.922637 dB, actual gain = 13.979400 dB */
+	{0x04C2, 2304, 0x00, 0x33},	/* index  60, gain = 13.546350 dB, actual gain = 13.533872 dB */
+	{0x048E, 2240, 0x00, 0x32},	/* index  61, gain = 13.170062 dB, actual gain = 13.064250 dB */
+	{0x045D, 2176, 0x00, 0x31},	/* index  62, gain = 12.793775 dB, actual gain = 12.567779 dB */
+	{0x042D, 2112, 0x00, 0x31},	/* index  63, gain = 12.417487 dB, actual gain = 12.567779 dB */
+	{0x0400, 2048, 0x00, 0x1F},	/* index  64, gain = 12.041200 dB, actual gain = 11.765434 dB */
+	{0x03D5, 1984, 0x00, 0x1E},	/* index  65, gain = 11.664912 dB, actual gain = 11.765434 dB */
+	{0x03AB, 1920, 0x00, 0x1D},	/* index  66, gain = 11.288625 dB, actual gain = 11.186160 dB */
+	{0x0383, 1856, 0x00, 0x1C},	/* index  67, gain = 10.912337 dB, actual gain = 10.881361 dB */
+	{0x035D, 1792, 0x00, 0x1B},	/* index  68, gain = 10.536050 dB, actual gain = 10.565476 dB */
+	{0x0339, 1728, 0x00, 0x1A},	/* index  69, gain = 10.159762 dB, actual gain = 10.237667 dB */
+	{0x0316, 1664, 0x00, 0x19},	/* index  70, gain = 9.783475 dB, actual gain = 9.897000 dB */
+	{0x02F4, 1600, 0x00, 0x18},	/* index  71, gain = 9.407187 dB, actual gain = 9.542425 dB */
+	{0x02D4, 1536, 0x00, 0x17},	/* index  72, gain = 9.030900 dB, actual gain = 9.172757 dB */
+	{0x02B5, 1472, 0x00, 0x16},	/* index  73, gain = 8.654612 dB, actual gain = 8.786654 dB */
+	{0x0298, 1408, 0x00, 0x15},	/* index  74, gain = 8.278325 dB, actual gain = 8.382586 dB */
+	{0x027C, 1344, 0x00, 0x14},	/* index  75, gain = 7.902037 dB, actual gain = 7.958800 dB */
+	{0x0261, 1280, 0x00, 0x13},	/* index  76, gain = 7.525750 dB, actual gain = 7.513272 dB */
+	{0x0247, 1216, 0x00, 0x12},	/* index  77, gain = 7.149462 dB, actual gain = 7.043650 dB */
+	{0x022E, 1152, 0x00, 0x11},	/* index  78, gain = 6.773175 dB, actual gain = 6.547179 dB */
+	{0x0217, 1088, 0x00, 0x11},	/* index  79, gain = 6.396887 dB, actual gain = 6.547179 dB */
+	{0x0200, 1024, 0x00, 0x0F},	/* index  80, gain = 6.020600 dB, actual gain = 5.744834 dB */
+	{0x01EA,  960, 0x00, 0x0E},	/* index  81, gain = 5.644312 dB, actual gain = 5.744834 dB */
+	{0x01D6,  896, 0x00, 0x0D},	/* index  82, gain = 5.268025 dB, actual gain = 5.165560 dB */
+	{0x01C2,  832, 0x00, 0x0C},	/* index  83, gain = 4.891737 dB, actual gain = 4.860761 dB */
+	{0x01AF,  768, 0x00, 0x0B},	/* index  84, gain = 4.515450 dB, actual gain = 4.544876 dB */
+	{0x019C,  704, 0x00, 0x0A},	/* index  85, gain = 4.139162 dB, actual gain = 4.217067 dB */
+	{0x018B,  640, 0x00, 0x09},	/* index  86, gain = 3.762875 dB, actual gain = 3.876401 dB */
+	{0x017A,  576, 0x00, 0x08},	/* index  87, gain = 3.386587 dB, actual gain = 3.521825 dB */
+	{0x016A,  512, 0x00, 0x07},	/* index  88, gain = 3.010300 dB, actual gain = 3.152157 dB */
+	{0x015B,  448, 0x00, 0x06},	/* index  89, gain = 2.634012 dB, actual gain = 2.766054 dB */
+	{0x014C,  384, 0x00, 0x05},	/* index  90, gain = 2.257725 dB, actual gain = 2.361986 dB */
+	{0x013E,  320, 0x00, 0x04},	/* index  91, gain = 1.881437 dB, actual gain = 1.938200 dB */
+	{0x0130,  256, 0x00, 0x03},	/* index  92, gain = 1.505150 dB, actual gain = 1.492672 dB */
+	{0x0124,  192, 0x00, 0x02},	/* index  93, gain = 1.128862 dB, actual gain = 1.023050 dB */
+	{0x0117,  128, 0x00, 0x01},	/* index  94, gain = 0.752575 dB, actual gain = 0.526579 dB */
+	{0x010B,   64, 0x00, 0x01},	/* index  95, gain = 0.376287 dB, actual gain = 0.526579 dB */
+	{0x0100,    0, 0x00, 0x00},	/* index  96, gain = 0.000000 dB, actual gain = 0.000000 dB */
+};
+
diff --git a/drivers/vin/sensors/omnivision_ov2718_mipi/Kbuild b/drivers/vin/sensors/omnivision_ov2718_mipi/Kbuild
new file mode 100644
index 0000000..b3303b3
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2718_mipi/Kbuild
@@ -0,0 +1,39 @@
+##
+## Filename : Kbuild
+##
+## History:
+##    2015/09/07 - [Hao Zeng] Create
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+
+EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
+EXTRA_AFLAGS		+= $(AMBARELLA_DRV_AFLAGS)
+EXTRA_LDFLAGS		+= $(AMBARELLA_DRV_LDFLAGS)
+
+obj-m := ov2718_mipi.o
+ov2718_mipi-y := ov2718.o
+
diff --git a/drivers/vin/sensors/omnivision_ov2718_mipi/make.inc b/drivers/vin/sensors/omnivision_ov2718_mipi/make.inc
new file mode 100644
index 0000000..096bee7
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2718_mipi/make.inc
@@ -0,0 +1,45 @@
+##
+## kernel/private/drivers/vin/sensors/omnivision_ov2718_mipi/make.inc
+##
+## History:
+##    2015/09/07 - [Hao Zeng] Created file
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+ifeq ($(CONFIG_SENSOR_OV2718_MIPI), y)
+
+LOCAL_PATH	:= $(call my-dir)
+
+###
+include $(CLEAR_VARS)
+
+LOCAL_SRCS	:= $(wildcard $(LOCAL_PATH)/*.c) $(wildcard $(LOCAL_PATH)/*.h)
+LOCAL_SRCS	+= $(LOCAL_PATH)/Kbuild
+
+include $(BUILD_DRIVER)
+
+endif
+
diff --git a/drivers/vin/sensors/omnivision_ov2718_mipi/ov2718.c b/drivers/vin/sensors/omnivision_ov2718_mipi/ov2718.c
new file mode 100644
index 0000000..1aae909
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2718_mipi/ov2718.c
@@ -0,0 +1,898 @@
+/*
+ * Filename : ov2718.c
+ *
+ * History:
+ *    2015/09/07 - [Hao Zeng] Create
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/ambpriv_device.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <iav_utils.h>
+#include <vin_api.h>
+#include "ov2718.h"
+#include "ov2718_table.c"
+
+static int bus_addr = (0 << 16) | (0x6C >> 1);
+module_param(bus_addr, int, 0644);
+MODULE_PARM_DESC(bus_addr, " bus and addr: bit16~bit31: bus, bit0~bit15: addr");
+
+static bool dual_gain = 1;
+module_param(dual_gain, bool, 0644);
+MODULE_PARM_DESC(dual_gain, " 2x hdr mode selection, 0:vs mode, 1:dual gain mode");
+
+struct ov2718_priv {
+	void *control_data;
+	struct vindev_wdr_gp_s wdr_again_gp;
+	struct vindev_wdr_gp_s wdr_dgain_gp;
+	struct vindev_wdr_gp_s wdr_shutter_gp;
+	u32 line_length;
+	u32 frame_length_lines;
+	u32 dgain_r_ratio;
+	u32 dgain_gr_ratio;
+	u32 dgain_gb_ratio;
+	u32 dgain_b_ratio;
+	u8 hold_mode;
+	u8 version_r2a;
+};
+
+static int ov2718_write_reg(struct vin_device *vdev, u32 subaddr, u32 data)
+{
+	int rval;
+	struct ov2718_priv *ov2718;
+	struct i2c_client *client;
+	struct i2c_msg msgs[1];
+	u8 pbuf[3];
+
+	ov2718 = (struct ov2718_priv *)vdev->priv;
+	client = ov2718->control_data;
+
+	pbuf[0] = (subaddr >> 8) | (ov2718->hold_mode << 7);
+	pbuf[1] = (subaddr & 0xff);
+	pbuf[2] = data;
+
+	msgs[0].len = 3;
+	msgs[0].addr = client->addr;
+
+	if (unlikely(subaddr == OV2718_SWRESET))
+		msgs[0].flags = client->flags | I2C_M_IGNORE_NAK;
+	else
+		msgs[0].flags = client->flags;
+
+	msgs[0].buf = pbuf;
+	rval = i2c_transfer(client->adapter, msgs, 1);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x:0x%x]\n", rval, subaddr, data);
+		return rval;
+	}
+
+	return 0;
+}
+
+static int ov2718_write_reg2(struct vin_device *vdev, u32 subaddr, u32 data)
+{
+	int rval;
+	struct ov2718_priv *ov2718;
+	struct i2c_client *client;
+	struct i2c_msg msgs[1];
+	u8 pbuf[4];
+
+	ov2718 = (struct ov2718_priv *)vdev->priv;
+	client = ov2718->control_data;
+
+	pbuf[0] = (subaddr >> 8) | (ov2718->hold_mode << 7);
+	pbuf[1] = (subaddr & 0xff);
+	pbuf[2] = data >> 8;
+	pbuf[3] = data & 0xff;
+
+	msgs[0].len = 4;
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].buf = pbuf;
+
+	rval = i2c_transfer(client->adapter, msgs, 1);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x:0x%x]\n", rval, subaddr, data);
+		return rval;
+	}
+
+	return 0;
+}
+
+static int ov2718_read_reg(struct vin_device *vdev, u32 subaddr, u32 *data)
+{
+	int rval = 0;
+	struct ov2718_priv *ov2718;
+	struct i2c_client *client;
+	struct i2c_msg msgs[2];
+	u8 pbuf0[2];
+	u8 pbuf[1];
+
+	ov2718 = (struct ov2718_priv *)vdev->priv;
+	client = ov2718->control_data;
+
+	pbuf0[0] = (subaddr >> 8);
+	pbuf0[1] = (subaddr & 0xff);
+
+	msgs[0].len = 2;
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].buf = pbuf0;
+
+	msgs[1].addr = client->addr;
+	msgs[1].flags = client->flags | I2C_M_RD;
+	msgs[1].buf = pbuf;
+	msgs[1].len = 1;
+
+	rval = i2c_transfer(client->adapter, msgs, 2);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x]\n", rval, subaddr);
+		return rval;
+	}
+
+	*data = pbuf[0];
+
+	return 0;
+}
+
+static int ov2718_set_vin_mode(struct vin_device *vdev, struct vin_video_format *format)
+{
+	struct vin_device_config ov2718_config;
+	struct ov2718_priv *pinfo = (struct ov2718_priv *)vdev->priv;
+
+	memset(&ov2718_config, 0, sizeof(ov2718_config));
+
+	ov2718_config.interface_type = SENSOR_MIPI;
+	ov2718_config.sync_mode = SENSOR_SYNC_MODE_MASTER;
+
+	ov2718_config.mipi_cfg.lane_number = SENSOR_4_LANE;
+	if (pinfo->version_r2a)
+		ov2718_config.mipi_cfg.bit_rate = SENSOR_MIPI_BIT_RATE_H;
+	else
+		ov2718_config.mipi_cfg.bit_rate = SENSOR_MIPI_BIT_RATE_L;
+
+	ov2718_config.cap_win.x = format->def_start_x;
+	ov2718_config.cap_win.y = format->def_start_y;
+	ov2718_config.cap_win.width = format->def_width;
+	ov2718_config.cap_win.height = format->def_height;
+
+	/* for hdr sensor */
+	ov2718_config.hdr_cfg.act_win.x = format->act_start_x;
+	ov2718_config.hdr_cfg.act_win.y = format->act_start_y;
+	ov2718_config.hdr_cfg.act_win.width = format->act_width;
+	ov2718_config.hdr_cfg.act_win.height = format->act_height;
+
+	ov2718_config.sensor_id	= GENERIC_SENSOR;
+	ov2718_config.input_format	= AMBA_VIN_INPUT_FORMAT_RGB_RAW;
+	ov2718_config.bayer_pattern	= format->bayer_pattern;
+	ov2718_config.video_format	= format->format;
+	ov2718_config.bit_resolution	= format->bits;
+
+	return ambarella_set_vin_config(vdev, &ov2718_config);
+}
+
+static void ov2718_sw_reset(struct vin_device *vdev)
+{
+	ov2718_write_reg(vdev, OV2718_SWRESET, 0x01);
+	msleep(10);
+}
+
+static int ov2718_init_device(struct vin_device *vdev)
+{
+	ov2718_sw_reset(vdev);
+	return 0;
+}
+
+static void ov2718_start_streaming(struct vin_device *vdev)
+{
+	ov2718_write_reg(vdev, OV2718_STANDBY, 0x01); /* cancel stanby */
+}
+
+static int ov2718_set_hold_mode(struct vin_device *vdev, u32 hold_mode)
+{
+	struct ov2718_priv *pinfo = (struct ov2718_priv *)vdev->priv;
+
+	if (hold_mode) {/* select group 0 for record */
+		ov2718_write_reg(vdev, OV2718_OPERATION_CTRL, 0x00);
+		ov2718_write_reg(vdev, OV2718_GROUP_CTRL, 0x00);
+		pinfo->hold_mode = 1;
+	} else {	/* single launch group 0 */
+		pinfo->hold_mode = 0;
+		ov2718_write_reg(vdev, OV2718_GROUP_CTRL, 0x10);
+		ov2718_write_reg(vdev, OV2718_OPERATION_CTRL, 0x01);
+	}
+
+	return 0;
+}
+
+static int ov2718_get_line_time(struct vin_device *vdev)
+{
+	u64 h_clks;
+	struct ov2718_priv *pinfo = (struct ov2718_priv *)vdev->priv;
+
+	h_clks = (u64)pinfo->line_length * 512000000;
+	h_clks = DIV64_CLOSEST(h_clks, vdev->cur_pll->pixelclk);
+
+	vdev->cur_format->line_time = (u32)h_clks;
+
+	return 0;
+}
+
+static int ov2718_update_hv_info(struct vin_device *vdev)
+{
+	struct ov2718_priv *pinfo = (struct ov2718_priv *)vdev->priv;
+	u32 data_h, data_l;
+
+	ov2718_read_reg(vdev, OV2718_HTS_H, &data_h);
+	ov2718_read_reg(vdev, OV2718_HTS_L, &data_l);
+	pinfo->line_length = (data_h<<8) + data_l;
+	if (unlikely(!pinfo->line_length)) {
+		vin_error("line length is 0!\n");
+		return -EIO;
+	}
+
+	ov2718_read_reg(vdev, OV2718_VTS_H, &data_h);
+	ov2718_read_reg(vdev, OV2718_VTS_L, &data_l);
+	pinfo->frame_length_lines = (data_h<<8) + data_l;
+
+	pinfo->dgain_r_ratio = 1024; /* 1x */
+	pinfo->dgain_gr_ratio = 1024; /* 1x */
+	pinfo->dgain_gb_ratio = 1024; /* 1x */
+	pinfo->dgain_b_ratio = 1024; /* 1x */
+
+	vin_debug("line_length:%d, frame_length_lines:%d\n",
+		pinfo->line_length, pinfo->frame_length_lines);
+
+	return 0;
+}
+
+static int ov2718_set_format(struct vin_device *vdev, struct vin_video_format *format)
+{
+	int rval;
+	struct vin_reg_16_8 *regs;
+	int i, regs_num;
+	struct ov2718_priv *pinfo = (struct ov2718_priv *)vdev->priv;
+
+	switch (format->hdr_mode) {
+	case AMBA_VIDEO_LINEAR_MODE:
+		if (pinfo->version_r2a) {
+			regs = ov2718_r2a_linear_regs;
+			regs_num = ARRAY_SIZE(ov2718_r2a_linear_regs);
+		} else {
+			regs = ov2718_linear_regs;
+			regs_num = ARRAY_SIZE(ov2718_linear_regs);
+		}
+		break;
+	case AMBA_VIDEO_2X_HDR_MODE:
+		if (dual_gain) {
+			regs = ov2718_dual_gain_hdr_regs;
+			regs_num = ARRAY_SIZE(ov2718_dual_gain_hdr_regs);
+			vin_info("dual gain hdr mode!\n");
+		} else {
+			regs = ov2718_lcg_vs_hdr_regs;
+			regs_num = ARRAY_SIZE(ov2718_lcg_vs_hdr_regs);
+			vin_info("staggered hdr mode!\n");
+		}
+		break;
+	case AMBA_VIDEO_3X_HDR_MODE:
+		regs = ov2718_dcg_vs_hdr_regs;
+		regs_num = ARRAY_SIZE(ov2718_dcg_vs_hdr_regs);
+		break;
+	case AMBA_VIDEO_INT_HDR_MODE:
+		regs = ov2718_12b_combined_hdr_regs;
+		regs_num = ARRAY_SIZE(ov2718_12b_combined_hdr_regs);
+		break;
+	default:
+		regs = NULL;
+		regs_num = 0;
+		vin_error("Unknown mode\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < regs_num; i++) {
+		ov2718_write_reg(vdev, regs[i].addr, regs[i].data);
+	}
+
+	rval = ov2718_update_hv_info(vdev);
+	if (rval < 0)
+		return rval;
+
+	ov2718_get_line_time(vdev);
+
+	/* Enable Streaming */
+	ov2718_start_streaming(vdev);
+
+	/* communicate with IAV */
+	rval = ov2718_set_vin_mode(vdev, format);
+	if (rval < 0)
+		return rval;
+
+	return 0;
+}
+
+static int ov2718_set_shutter_row(struct vin_device *vdev, u32 row)
+{
+	struct ov2718_priv *pinfo = (struct ov2718_priv *)vdev->priv;
+	u64 exposure_lines;
+	u32 num_line, min_line, max_line;
+	int errCode = 0;
+
+	num_line = row;
+
+	/* FIXME: shutter width: 1 ~(Frame format(V) - 5) */
+	min_line = 1;
+	max_line = pinfo->frame_length_lines - 5;
+	num_line = clamp(num_line, min_line, max_line);
+
+	ov2718_write_reg2(vdev, OV2718_CEXP_DCG_H, num_line&0xFFFF);
+
+	exposure_lines = num_line;
+	exposure_lines = exposure_lines * (u64)pinfo->line_length * 512000000;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, vdev->cur_pll->pixelclk);
+
+	vdev->shutter_time = (u32)exposure_lines;
+	vin_debug("shutter_time:%d, row:%d\n", vdev->shutter_time, num_line);
+
+	return errCode;
+}
+
+static int ov2718_shutter2row(struct vin_device *vdev, u32 *shutter_time)
+{
+	struct ov2718_priv *pinfo = (struct ov2718_priv *)vdev->priv;
+	u64 exposure_lines;
+	int rval = 0;
+
+	/* for fast boot, it may call set shutter time directly, so we must read line length/frame line */
+	if (!pinfo->line_length) {
+		rval = ov2718_update_hv_info(vdev);
+		if (rval < 0)
+			return rval;
+
+		ov2718_get_line_time(vdev);
+	}
+
+	exposure_lines = (*shutter_time) * (u64)vdev->cur_pll->pixelclk;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, pinfo->line_length);
+	exposure_lines = DIV64_CLOSEST(exposure_lines, 512000000);
+
+	*shutter_time = exposure_lines;
+
+	return rval;
+}
+
+static int ov2718_set_wdr_shutter_row_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_shutter_gp)
+{
+	struct ov2718_priv *pinfo = (struct ov2718_priv *)vdev->priv;
+	u16 shutter_long, shutter_short;
+
+	/* DCG shutter */
+	shutter_long = p_shutter_gp->l;
+
+	/* VS shutter */
+	if (!dual_gain && vdev->cur_format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {
+		shutter_short = p_shutter_gp->s1;
+	} else {
+		shutter_short = p_shutter_gp->s2;
+	}
+
+	if ((shutter_long + shutter_short > pinfo->frame_length_lines - 5) ||
+		(1080 + shutter_short + 1 > pinfo->frame_length_lines - 22)) {
+		vin_error("shutter exceeds limitation! long:%d, short1:%d, V:%d\n",
+			shutter_long, shutter_short, pinfo->frame_length_lines);
+		return -EPERM;
+	}
+
+	ov2718_write_reg2(vdev, OV2718_CEXP_DCG_H, shutter_long&0xFFFF);
+	ov2718_write_reg2(vdev, OV2718_CEXP_VS_H, shutter_short&0xFFFF);
+
+	memcpy(&(pinfo->wdr_shutter_gp),  p_shutter_gp, sizeof(struct vindev_wdr_gp_s));
+
+	vin_debug("shutter long:%d, short1:%d, short2:%d\n",
+		p_shutter_gp->l, p_shutter_gp->s1,  p_shutter_gp->s2);
+
+	return 0;
+}
+
+static int ov2718_get_wdr_shutter_row_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_shutter_gp)
+{
+	struct ov2718_priv *pinfo = (struct ov2718_priv *)vdev->priv;
+	memcpy(p_shutter_gp, &(pinfo->wdr_shutter_gp), sizeof(struct vindev_wdr_gp_s));
+
+	return 0;
+}
+
+static int ov2718_wdr_shutter2row(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_shutter2row)
+{
+	u32 exposure_lines;
+	int rval = 0;
+
+	/* long shutter */
+	exposure_lines = p_shutter2row->l;
+	ov2718_shutter2row(vdev, &exposure_lines);
+	p_shutter2row->l = exposure_lines;
+
+	exposure_lines = p_shutter2row->s1;
+	ov2718_shutter2row(vdev, &exposure_lines);
+	p_shutter2row->s1 = exposure_lines;
+
+	return rval;
+}
+
+static int ov2718_set_fps(struct vin_device *vdev, int fps)
+{
+	struct ov2718_priv *pinfo = (struct ov2718_priv *)vdev->priv;
+	u64 pixelclk, v_lines, vb_time;
+
+	pixelclk = vdev->cur_pll->pixelclk;
+
+	v_lines = fps * pixelclk;
+	v_lines = DIV64_CLOSEST(v_lines, pinfo->line_length);
+	v_lines = DIV64_CLOSEST(v_lines, 512000000);
+	ov2718_write_reg2(vdev, OV2718_VTS_H, v_lines&0xFFFF);
+
+	pinfo->frame_length_lines = v_lines;
+
+	vb_time = pinfo->line_length * (u64)(v_lines - vdev->cur_format->height) * 1000000000;
+	vb_time = DIV64_CLOSEST(vb_time, pixelclk);
+	vdev->cur_format->vb_time = vb_time;
+
+	return 0;
+}
+
+static int ov2718_convert_dgain_ratio(u32 ratio, u16 *new_dgain)
+{
+	u32 tmp_dgain;
+
+	tmp_dgain = ratio >> 2;/* equals to *256/1024, 256 is dgain base, 1024 is ratio unit */
+
+	if (ratio < 4) {/* dgain value should be no less than 0x01 */
+		ratio = 4;
+		vin_warn("ratio should not be less than 4!\n");
+	}
+	*new_dgain = tmp_dgain;
+
+	vin_debug("ratio=%d, new_dgain=%d\n", ratio, *new_dgain);
+
+	return 0;
+}
+
+static int ov2718_set_dgain_ratio(struct vin_device *vdev, struct vindev_dgain_ratio *p_dgain_ratio)
+{
+	struct ov2718_priv *pinfo = (struct ov2718_priv *)vdev->priv;
+	u16 new_dgain;
+	u32 blc_offset;
+	int errCode = 0;
+
+	/* r */
+	ov2718_convert_dgain_ratio(p_dgain_ratio->r_ratio, &new_dgain);
+	ov2718_write_reg2(vdev, OV2718_R_GAIN_HCG_H, new_dgain);
+	ov2718_write_reg2(vdev, OV2718_R_GAIN_LCG_H, new_dgain);
+	pinfo->dgain_r_ratio = p_dgain_ratio->r_ratio;
+	blc_offset = (new_dgain - 1) << 6;/* FIXME: *blc_taget:0x40 */
+	ov2718_write_reg2(vdev, OV2718_R_OFFSET_HCG_H, (blc_offset>>8)&0xFFFF);
+	ov2718_write_reg(vdev, OV2718_R_OFFSET_HCG_L, blc_offset&0xFF);
+	ov2718_write_reg2(vdev, OV2718_R_OFFSET_LCG_H, (blc_offset>>8)&0xFFFF);
+	ov2718_write_reg(vdev, OV2718_R_OFFSET_LCG_L, blc_offset&0xFF);
+
+	/* gr */
+	ov2718_convert_dgain_ratio(p_dgain_ratio->gr_ratio, &new_dgain);
+	ov2718_write_reg2(vdev, OV2718_GR_GAIN_HCG_H, new_dgain);
+	ov2718_write_reg2(vdev, OV2718_GR_GAIN_LCG_H, new_dgain);
+	pinfo->dgain_gr_ratio = p_dgain_ratio->gr_ratio;
+	blc_offset = (new_dgain - 1) << 6;/* FIXME: *blc_taget:0x40 */
+	ov2718_write_reg2(vdev, OV2718_GR_OFFSET_HCG_H, (blc_offset>>8)&0xFFFF);
+	ov2718_write_reg(vdev, OV2718_GR_OFFSET_HCG_L, blc_offset&0xFF);
+	ov2718_write_reg2(vdev, OV2718_GR_OFFSET_LCG_H, (blc_offset>>8)&0xFFFF);
+	ov2718_write_reg(vdev, OV2718_GR_OFFSET_LCG_L, blc_offset&0xFF);
+
+	/* gb */
+	ov2718_convert_dgain_ratio(p_dgain_ratio->gb_ratio, &new_dgain);
+	ov2718_write_reg2(vdev, OV2718_GB_GAIN_HCG_H, new_dgain);
+	ov2718_write_reg2(vdev, OV2718_GB_GAIN_LCG_H, new_dgain);
+	pinfo->dgain_gb_ratio = p_dgain_ratio->gb_ratio;
+	blc_offset = (new_dgain - 1) << 6;/* FIXME: *blc_taget:0x40 */
+	ov2718_write_reg2(vdev, OV2718_GB_OFFSET_HCG_H, (blc_offset>>8)&0xFFFF);
+	ov2718_write_reg(vdev, OV2718_GB_OFFSET_HCG_L, blc_offset&0xFF);
+	ov2718_write_reg2(vdev, OV2718_GB_OFFSET_LCG_H, (blc_offset>>8)&0xFFFF);
+	ov2718_write_reg(vdev, OV2718_GB_OFFSET_LCG_L, blc_offset&0xFF);
+
+	/* b */
+	ov2718_convert_dgain_ratio(p_dgain_ratio->b_ratio, &new_dgain);
+	ov2718_write_reg2(vdev, OV2718_B_GAIN_HCG_H, new_dgain);
+	ov2718_write_reg2(vdev, OV2718_B_GAIN_LCG_H, new_dgain);
+	pinfo->dgain_b_ratio = p_dgain_ratio->b_ratio;
+	blc_offset = (new_dgain - 1) << 6;/* FIXME: *blc_taget:0x40 */
+	ov2718_write_reg2(vdev, OV2718_B_OFFSET_HCG_H, (blc_offset>>8)&0xFFFF);
+	ov2718_write_reg(vdev, OV2718_B_OFFSET_HCG_L, blc_offset&0xFF);
+	ov2718_write_reg2(vdev, OV2718_B_OFFSET_LCG_H, (blc_offset>>8)&0xFFFF);
+	ov2718_write_reg(vdev, OV2718_B_OFFSET_LCG_L, blc_offset&0xFF);
+
+	return errCode;
+}
+
+static int ov2718_get_dgain_ratio(struct vin_device *vdev, struct vindev_dgain_ratio *p_dgain_ratio)
+{
+	int errCode = 0;
+	struct ov2718_priv *pinfo = (struct ov2718_priv *)vdev->priv;
+
+	p_dgain_ratio->r_ratio = pinfo->dgain_r_ratio;
+	p_dgain_ratio->gr_ratio = pinfo->dgain_gr_ratio;
+	p_dgain_ratio->gb_ratio = pinfo->dgain_gb_ratio;
+	p_dgain_ratio->b_ratio = pinfo->dgain_b_ratio;
+
+	return errCode;
+}
+
+static int ov2718_set_agc_index(struct vin_device *vdev, int agc_idx)
+{
+	if (agc_idx > OV2718_GAIN_MAXDB) {
+		vin_warn("agc index %d exceeds maximum %d\n", agc_idx, OV2718_GAIN_MAXDB);
+		agc_idx = OV2718_GAIN_MAXDB;
+	}
+
+	/* analog gain */
+	ov2718_write_reg(vdev, OV2718_CG_AGAIN, OV2718_GAIN_TABLE[agc_idx][OV2718_GAIN_COL_AGAIN]);
+
+	/* digital gain */
+	ov2718_write_reg2(vdev, OV2718_DIG_GAIN_HCG_H, OV2718_GAIN_TABLE[agc_idx][OV2718_GAIN_COL_DGAIN]);
+
+	return 0;
+}
+
+static int ov2718_set_wdr_again_idx_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_again_gp)
+{
+	struct ov2718_priv *pinfo = (struct ov2718_priv *)vdev->priv;
+	u32 cg_again = 0, gain_index;
+
+	if (!dual_gain && vdev->cur_format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {
+		/* LCG frame */
+		/* digital gain */
+		ov2718_write_reg2(vdev, OV2718_DIG_GAIN_LCG_H,
+			OV2718_HDR_GAIN_TABLE[p_again_gp->l][OV2718_HDR_GAIN_COL_DGAIN]);
+		cg_again |= (OV2718_HDR_GAIN_TABLE[p_again_gp->l][OV2718_HDR_GAIN_COL_AGAIN]<<2);
+
+		/* VS frame */
+		/* digital gain */
+		ov2718_write_reg2(vdev, OV2718_DIG_GAIN_VS_H,
+			OV2718_HDR_GAIN_TABLE[p_again_gp->s1][OV2718_HDR_GAIN_COL_DGAIN]);
+		cg_again |= (OV2718_HDR_GAIN_TABLE[p_again_gp->s1][OV2718_HDR_GAIN_COL_AGAIN]<<4);
+	} else {
+		if (p_again_gp->l >= 222) {
+			gain_index = p_again_gp->l - 222;/* HCG has 11X sensitivity */
+		} else {
+			vin_warn("long gain index should not be less than 222!\n");
+			gain_index = 0;
+		}
+
+		/* HCG frame */
+		/* digital gain */
+		ov2718_write_reg2(vdev, OV2718_DIG_GAIN_HCG_H,
+			OV2718_HDR_GAIN_TABLE[gain_index][OV2718_HDR_GAIN_COL_DGAIN]);
+		cg_again = OV2718_HDR_GAIN_TABLE[gain_index][OV2718_HDR_GAIN_COL_AGAIN];
+
+		/* LCG frame */
+		/* digital gain */
+		ov2718_write_reg2(vdev, OV2718_DIG_GAIN_LCG_H,
+			OV2718_HDR_GAIN_TABLE[p_again_gp->s1][OV2718_HDR_GAIN_COL_DGAIN]);
+		cg_again |= (OV2718_HDR_GAIN_TABLE[p_again_gp->s1][OV2718_HDR_GAIN_COL_AGAIN]<<2);
+
+		if (vdev->cur_format->hdr_mode == AMBA_VIDEO_3X_HDR_MODE) {/* VS frame */
+			/* digital gain */
+			ov2718_write_reg2(vdev, OV2718_DIG_GAIN_VS_H,
+				OV2718_HDR_GAIN_TABLE[p_again_gp->s2][OV2718_HDR_GAIN_COL_DGAIN]);
+			cg_again |= (OV2718_HDR_GAIN_TABLE[p_again_gp->s2][OV2718_HDR_GAIN_COL_AGAIN]<<4);
+		}
+	}
+
+	/* analog gain */
+	ov2718_write_reg(vdev, OV2718_CG_AGAIN, cg_again);
+
+	memcpy(&(pinfo->wdr_again_gp), p_again_gp, sizeof(struct vindev_wdr_gp_s));
+
+	vin_debug("long again index:%d, short1 again index:%d, short2 again index:%d\n",
+		p_again_gp->l, p_again_gp->s1, p_again_gp->s2);
+
+	return 0;
+}
+
+static int ov2718_get_wdr_again_idx_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_again_gp)
+{
+	struct ov2718_priv *pinfo = (struct ov2718_priv *)vdev->priv;
+
+	memcpy(p_again_gp, &(pinfo->wdr_again_gp), sizeof(struct vindev_wdr_gp_s));
+	return 0;
+}
+
+static int ov2718_set_wdr_dgain_idx_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_dgain_gp)
+{
+	struct ov2718_priv *pinfo = (struct ov2718_priv *)vdev->priv;
+
+	memcpy(&(pinfo->wdr_dgain_gp), p_dgain_gp, sizeof(struct vindev_wdr_gp_s));
+
+	vin_debug("long dgain index:%d, short1 dgain index:%d\n",
+		p_dgain_gp->l, p_dgain_gp->s1);
+
+	return 0;
+}
+
+static int ov2718_get_wdr_dgain_idx_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_dgain_gp)
+{
+	struct ov2718_priv *pinfo = (struct ov2718_priv *)vdev->priv;
+
+	memcpy(p_dgain_gp, &(pinfo->wdr_dgain_gp), sizeof(struct vindev_wdr_gp_s));
+	return 0;
+}
+
+static int ov2718_set_mirror_mode(struct vin_device *vdev,
+	struct vindev_mirror *mirror_mode)
+{
+	int errCode = 0;
+	u32 tmp_reg, bayer_pattern, read_mode = 0;
+	u32 h_offs, cfa_pattern;
+
+	switch (mirror_mode->pattern) {
+	case VINDEV_MIRROR_AUTO:
+		return 0;
+
+	case VINDEV_MIRROR_NONE:
+		read_mode = 0;
+		h_offs = 0x05;
+		cfa_pattern = 0x21;
+		bayer_pattern = VINDEV_BAYER_PATTERN_BG;
+		break;
+
+	case VINDEV_MIRROR_VERTICALLY:
+		read_mode = OV2718_V_FLIP;
+		h_offs = 0x05;
+		cfa_pattern = 0x23;
+		bayer_pattern = VINDEV_BAYER_PATTERN_BG;
+		break;
+
+	case VINDEV_MIRROR_HORRIZONTALLY:
+		read_mode = OV2718_H_MIRROR;
+		h_offs = 0x04;
+		cfa_pattern = 0x20;
+		bayer_pattern = VINDEV_BAYER_PATTERN_BG;
+		break;
+
+	case VINDEV_MIRROR_HORRIZONTALLY_VERTICALLY:
+		read_mode = OV2718_H_MIRROR + OV2718_V_FLIP;
+		h_offs = 0x04;
+		cfa_pattern = 0x22;
+		bayer_pattern = VINDEV_BAYER_PATTERN_BG;
+		break;
+
+	default:
+		vin_error("do not support cmd mirror mode\n");
+		return -EINVAL;
+	}
+
+	errCode |= ov2718_read_reg(vdev, OV2718_READ_MODE, &tmp_reg);
+	tmp_reg |= OV2718_H_MIRROR;
+	tmp_reg &= (~OV2718_V_FLIP);
+	tmp_reg ^= read_mode;
+	ov2718_write_reg(vdev, OV2718_READ_MODE, tmp_reg);
+	ov2718_write_reg(vdev, OV2718_ODP_H_OFFS_L, h_offs);
+	ov2718_write_reg(vdev, OV2718_ISP_SETTING, cfa_pattern);
+
+	if (mirror_mode->bayer_pattern == VINDEV_BAYER_PATTERN_AUTO)
+		mirror_mode->bayer_pattern = bayer_pattern;
+
+	return errCode;
+}
+
+static int ov2718_get_aaa_info(struct vin_device *vdev,
+	struct vindev_aaa_info *aaa_info)
+{
+	struct ov2718_priv *pinfo = (struct ov2718_priv *)vdev->priv;
+
+	aaa_info->sht0_max = pinfo->frame_length_lines - 5;
+	aaa_info->sht1_max = pinfo->frame_length_lines - 22 - 1080 - 1;
+	aaa_info->sht2_max = 0;
+
+	return 0;
+}
+
+static int ov2718_check_chip_version(struct vin_device *vdev)
+{
+	struct ov2718_priv *pinfo = (struct ov2718_priv *)vdev->priv;
+	u32 reg_7a0e, reg_7a03, reg_7a04, reg_7a05, reg_7a06, reg_7a07, reg_7a08;
+
+	pinfo->version_r2a = 0;
+	ov2718_read_reg(vdev, 0x7a0e, &reg_7a0e);
+	ov2718_read_reg(vdev, 0x7a03, &reg_7a03);
+	ov2718_read_reg(vdev, 0x7a04, &reg_7a04);
+	ov2718_read_reg(vdev, 0x7a05, &reg_7a05);
+	ov2718_read_reg(vdev, 0x7a06, &reg_7a06);
+	ov2718_read_reg(vdev, 0x7a07, &reg_7a07);
+	ov2718_read_reg(vdev, 0x7a08, &reg_7a08);
+	if (reg_7a0e > 0x23) {
+		pinfo->version_r2a = 1;
+	} else if ((reg_7a0e == 0x23) &&
+			(reg_7a03 == 0x19) && (reg_7a04 == 0x06) &&
+			(reg_7a05 == 0x20) && (reg_7a06 == 0x06) &&
+			(reg_7a07 == 0x02) && (reg_7a08 == 0x01)) {
+		pinfo->version_r2a = 1;
+	}
+
+	return 0;
+}
+
+static struct vin_ops ov2718_ops = {
+	.init_device		= ov2718_init_device,
+	.set_format		= ov2718_set_format,
+	.set_shutter_row	= ov2718_set_shutter_row,
+	.shutter2row		= ov2718_shutter2row,
+	.set_frame_rate	= ov2718_set_fps,
+	.set_agc_index		= ov2718_set_agc_index,
+	.set_mirror_mode	= ov2718_set_mirror_mode,
+	.set_hold_mode		= ov2718_set_hold_mode,
+	.get_aaa_info		= ov2718_get_aaa_info,
+	.read_reg			= ov2718_read_reg,
+	.write_reg		= ov2718_write_reg,
+
+	/* for build-in hdr */
+	.set_dgain_ratio	= ov2718_set_dgain_ratio,
+	.get_dgain_ratio	= ov2718_get_dgain_ratio,
+
+	/* for wdr sensor */
+	.set_wdr_again_idx_gp = ov2718_set_wdr_again_idx_group,
+	.get_wdr_again_idx_gp = ov2718_get_wdr_again_idx_group,
+	.set_wdr_dgain_idx_gp = ov2718_set_wdr_dgain_idx_group,
+	.get_wdr_dgain_idx_gp = ov2718_get_wdr_dgain_idx_group,
+	.set_wdr_shutter_row_gp = ov2718_set_wdr_shutter_row_group,
+	.get_wdr_shutter_row_gp = ov2718_get_wdr_shutter_row_group,
+	.wdr_shutter2row = ov2718_wdr_shutter2row,
+};
+
+/* ========================================================================== */
+static int ov2718_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	int rval = 0;
+	struct vin_device *vdev;
+	struct ov2718_priv *ov2718;
+	u32 cid_l, cid_h;
+
+	vdev = ambarella_vin_create_device(client->name,
+		SENSOR_OV2718, sizeof(struct ov2718_priv));
+	if (!vdev)
+		return -ENOMEM;
+
+	vdev->intf_id = 0;
+	vdev->dev_type = VINDEV_TYPE_SENSOR;
+	vdev->sub_type = VINDEV_SUBTYPE_CMOS;
+	vdev->default_mode = AMBA_VIDEO_MODE_1080P;
+	vdev->default_hdr_mode = AMBA_VIDEO_LINEAR_MODE;
+	vdev->agc_db_max = 0x42F00000; /* 66.93750dB */
+	vdev->agc_db_min = 0x00000000; /* 0dB */
+	vdev->agc_db_step = 0x00180000; /* 0.09375dB */
+	vdev->wdr_again_idx_min = 0;
+	vdev->wdr_again_idx_max = OV2718_HDR_GAIN_MAXDB;
+
+	i2c_set_clientdata(client, vdev);
+
+	ov2718 = (struct ov2718_priv *)vdev->priv;
+	ov2718->control_data = client;
+
+	if (dual_gain)
+		ov2718_formats[1] = ov2718_2x_hdr_formats[0];
+	else
+		ov2718_formats[1] = ov2718_2x_hdr_formats[1];
+
+	rval = ambarella_vin_register_device(vdev, &ov2718_ops,
+		ov2718_formats, ARRAY_SIZE(ov2718_formats),
+		ov2718_plls, ARRAY_SIZE(ov2718_plls));
+	if (rval < 0)
+		goto ov2718_probe_err;
+
+	/* query sensor id */
+	ov2718_read_reg(vdev, OV2718_CHIP_ID_H, &cid_h);
+	ov2718_read_reg(vdev, OV2718_CHIP_ID_L, &cid_l);
+	ov2718_check_chip_version(vdev);
+	if (ov2718->version_r2a) {
+		vdev->plls = ov2718_r2a_plls;
+		vdev->formats = ov2718_r2a_formats;
+		vin_info("OV2718(R2A) init(4-lane mipi), sensor ID: 0x%x\n", (cid_h<<8)+cid_l);
+	} else
+		vin_info("OV2718(R1C) init(4-lane mipi), sensor ID: 0x%x\n", (cid_h<<8)+cid_l);
+
+	return 0;
+
+ov2718_probe_err:
+	ambarella_vin_free_device(vdev);
+	return rval;
+}
+
+static int ov2718_remove(struct i2c_client *client)
+{
+	struct vin_device *vdev;
+
+	vdev = (struct vin_device *)i2c_get_clientdata(client);
+	ambarella_vin_unregister_device(vdev);
+	ambarella_vin_free_device(vdev);
+
+	return 0;
+}
+
+static const struct i2c_device_id ov2718_idtable[] = {
+	{ "ov2718", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ov2718_idtable);
+
+static struct i2c_driver i2c_driver_ov2718 = {
+	.driver = {
+		.name	= "ov2718",
+	},
+
+	.id_table	= ov2718_idtable,
+	.probe		= ov2718_probe,
+	.remove		= ov2718_remove,
+};
+
+static int __init ov2718_init(void)
+{
+	int bus, addr, rval;
+
+	bus = bus_addr >> 16;
+	addr = bus_addr & 0xffff;
+
+	rval = ambpriv_i2c_update_addr("ov2718", bus, addr);
+	if (rval < 0)
+		return rval;
+
+	rval = i2c_add_driver(&i2c_driver_ov2718);
+	if (rval < 0)
+		return rval;
+
+	return 0;
+}
+
+static void __exit ov2718_exit(void)
+{
+	i2c_del_driver(&i2c_driver_ov2718);
+}
+
+module_init(ov2718_init);
+module_exit(ov2718_exit);
+
+MODULE_DESCRIPTION("OV2718 1/3 -Inch, 1936x1096, 2.1-Megapixel CMOS Digital Image Sensor");
+MODULE_AUTHOR("Hao Zeng <haozeng@ambarella.com>");
+MODULE_LICENSE("Proprietary");
+
diff --git a/drivers/vin/sensors/omnivision_ov2718_mipi/ov2718.h b/drivers/vin/sensors/omnivision_ov2718_mipi/ov2718.h
new file mode 100644
index 0000000..a5c54ad
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2718_mipi/ov2718.h
@@ -0,0 +1,151 @@
+/*
+ * Filename : ov2718.h
+ *
+ * History:
+ *    2015/09/07 - [Hao Zeng] Create
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __OV2718_H__
+#define __OV2718_H__
+
+#define OV2718_STANDBY	0x3012
+#define OV2718_SWRESET	0x3013
+
+#define OV2718_CROP_H_ST_H	0x30A0
+#define OV2718_CROP_H_ST_L	0x30A1
+#define OV2718_CROP_V_ST_H	0x30A2
+#define OV2718_CROP_V_ST_L	0x30A3
+#define OV2718_CROP_H_END_H	0x30A4
+#define OV2718_CROP_H_END_L	0x30A5
+#define OV2718_CROP_V_END_H	0x30A6
+#define OV2718_CROP_V_END_L	0x30A7
+#define OV2718_ODP_H_OFFS_H	0x30A8
+#define OV2718_ODP_H_OFFS_L	0x30A9
+#define OV2718_ODP_V_OFFS_H	0x30AA
+#define OV2718_ODP_V_OFFS_L	0x30AB
+#define OV2718_ODP_H_SIZE_H	0x30AC
+#define OV2718_ODP_H_SIZE_L	0x30AD
+#define OV2718_ODP_V_SIZE_H	0x30AE
+#define OV2718_ODP_V_SIZE_L	0x30AF
+#define OV2718_HTS_H			0x30B0
+#define OV2718_HTS_L			0x30B1
+#define OV2718_VTS_H			0x30B2
+#define OV2718_VTS_L			0x30B3
+
+#define OV2718_CEXP_DCG_H	0x30B6
+#define OV2718_CEXP_DCG_L	0x30B7
+#define OV2718_CEXP_VS_H		0x30B8
+#define OV2718_CEXP_VS_L		0x30B9
+#define OV2718_FEXP_VS		0x30BA
+
+#define OV2718_CG_AGAIN		0x30BB
+
+#define OV2718_DIG_GAIN_HCG_H	0x315A
+#define OV2718_DIG_GAIN_HCG_L	0x315B
+#define OV2718_DIG_GAIN_LCG_H	0x315C
+#define OV2718_DIG_GAIN_LCG_L	0x315D
+#define OV2718_DIG_GAIN_VS_H		0x315E
+#define OV2718_DIG_GAIN_VS_L		0x315F
+
+#define OV2718_BLC_TARGET_HCG_H	0x3160
+#define OV2718_BLC_TARGET_HCG_L	0x3161
+#define OV2718_BLC_TARGET_LCG_H	0x3162
+#define OV2718_BLC_TARGET_LCG_L	0x3163
+
+#define OV2718_R_GAIN_HCG_H		0x3360
+#define OV2718_R_GAIN_HCG_L		0x3361
+#define OV2718_GR_GAIN_HCG_H		0x3362
+#define OV2718_GR_GAIN_HCG_L		0x3363
+#define OV2718_GB_GAIN_HCG_H		0x3364
+#define OV2718_GB_GAIN_HCG_L		0x3365
+#define OV2718_B_GAIN_HCG_H		0x3366
+#define OV2718_B_GAIN_HCG_L		0x3367
+
+#define OV2718_R_GAIN_LCG_H		0x3368
+#define OV2718_R_GAIN_LCG_L		0x3369
+#define OV2718_GR_GAIN_LCG_H		0x336A
+#define OV2718_GR_GAIN_LCG_L		0x336B
+#define OV2718_GB_GAIN_LCG_H		0x336C
+#define OV2718_GB_GAIN_LCG_L		0x336D
+#define OV2718_B_GAIN_LCG_H		0x336E
+#define OV2718_B_GAIN_LCG_L		0x336F
+
+#define OV2718_R_GAIN_VS_H		0x3370
+#define OV2718_R_GAIN_VS_L		0x3371
+#define OV2718_GR_GAIN_VS_H		0x3372
+#define OV2718_GR_GAIN_VS_L		0x3373
+#define OV2718_GB_GAIN_VS_H		0x3374
+#define OV2718_GB_GAIN_VS_L		0x3375
+#define OV2718_B_GAIN_VS_H		0x3376
+#define OV2718_B_GAIN_VS_L		0x3377
+
+#define OV2718_R_OFFSET_HCG_H	0x3378
+#define OV2718_R_OFFSET_HCG_M	0x3379
+#define OV2718_R_OFFSET_HCG_L	0x337A
+#define OV2718_GR_OFFSET_HCG_H	0x337B
+#define OV2718_GR_OFFSET_HCG_M	0x337C
+#define OV2718_GR_OFFSET_HCG_L	0x337D
+#define OV2718_GB_OFFSET_HCG_H	0x337E
+#define OV2718_GB_OFFSET_HCG_M	0x337F
+#define OV2718_GB_OFFSET_HCG_L	0x3380
+#define OV2718_B_OFFSET_HCG_H	0x3381
+#define OV2718_B_OFFSET_HCG_M	0x3382
+#define OV2718_B_OFFSET_HCG_L	0x3383
+
+#define OV2718_R_OFFSET_LCG_H	0x3384
+#define OV2718_R_OFFSET_LCG_M	0x3385
+#define OV2718_R_OFFSET_LCG_L	0x3386
+#define OV2718_GR_OFFSET_LCG_H	0x3387
+#define OV2718_GR_OFFSET_LCG_M	0x3388
+#define OV2718_GR_OFFSET_LCG_L	0x3389
+#define OV2718_GB_OFFSET_LCG_H	0x338A
+#define OV2718_GB_OFFSET_LCG_M	0x338B
+#define OV2718_GB_OFFSET_LCG_L	0x338C
+#define OV2718_B_OFFSET_LCG_H	0x338D
+#define OV2718_B_OFFSET_LCG_M	0x338E
+#define OV2718_B_OFFSET_LCG_L	0x338F
+
+#define OV2718_ISP_SETTING		0x3252
+
+#define OV2718_CHIP_ID_H			0x300A
+#define OV2718_CHIP_ID_L			0x300B
+
+#define OV2718_MIPI_LANE_CTRL0	0x315E
+#define OV2718_MIPI_GATE		(1<<5)
+
+#define OV2718_GROUP_CTRL		0x3464
+#define OV2718_OPERATION_CTRL	0x3467
+
+/* OV2718 mirror mode */
+#define OV2718_READ_MODE		0x30C0
+#define OV2718_V_FLIP			(1<<3)
+#define OV2718_H_MIRROR		(1<<2)
+#define OV2718_MIRROR_MASK	(OV2718_H_MIRROR + OV2718_V_FLIP)
+
+#endif /* __OV2718_H__ */
+
diff --git a/drivers/vin/sensors/omnivision_ov2718_mipi/ov2718_table.c b/drivers/vin/sensors/omnivision_ov2718_mipi/ov2718_table.c
new file mode 100644
index 0000000..7e05c92
--- /dev/null
+++ b/drivers/vin/sensors/omnivision_ov2718_mipi/ov2718_table.c
@@ -0,0 +1,3738 @@
+/*
+ * Filename : ov2718_table.c
+ *
+ * History:
+ *    2015/09/07 - [Hao Zeng] Create
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+static struct vin_video_pll ov2718_plls[] = {
+	/* for linear mode */
+	{0, 23992320, 74976000},
+	 /* for 2x HDR */
+	{0, 23992320, 74976000},
+};
+
+static struct vin_video_pll ov2718_r2a_plls[] = {
+	/* for linear mode */
+	{0, 23983800, 119919000},
+	 /* for 2x HDR */
+	{0, 23983800, 119919000},
+};
+
+static struct vin_video_format ov2718_formats[] = {
+	{	/* 1080p@30fps */
+		.video_mode = AMBA_VIDEO_MODE_1080P,
+		.def_start_x = 0,
+		.def_start_y = 0,
+		.def_width = 1920,
+		.def_height = 1080,
+		/* sensor mode */
+		.device_mode = 0,
+		.pll_idx = 0,
+		.width = 1920,
+		.height = 1080,
+		.format = AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type = AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits = AMBA_VIDEO_BITS_12,
+		.ratio = AMBA_VIDEO_RATIO_16_9,
+		.max_fps = AMBA_VIDEO_FPS_30,
+		.default_fps = AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern = VINDEV_BAYER_PATTERN_BG,
+	},
+	{	/* 1080p dual gain hdr */
+		.video_mode	= AMBA_VIDEO_MODE_1080P,
+		.def_start_x	= 0,
+		.def_start_y	= 0,
+		.def_width	= 1920,
+		.def_height	= 1080 * 2,
+		.act_start_x	= 0,
+		.act_start_y	= 0,
+		.act_width	= 1920,
+		.act_height	= 1080,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_2X_HDR_MODE,
+		.device_mode	= 1,
+		.pll_idx	= 1,
+		.width		= 1920,
+		.height		= 1080 * 2,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_BG,
+		.dual_gain_mode = 1,
+		.hdr_long_offset = 0,
+		.hdr_short1_offset = 1,
+	},
+	{	/* 1080p dcg+vs hdr */
+		.video_mode	= AMBA_VIDEO_MODE_1080P,
+		.def_start_x	= 0,
+		.def_start_y	= 0,
+		.def_width	= 1920,
+		.def_height	= (1250 - 2) * 3,
+		.act_start_x	= 0,
+		.act_start_y	= 0,
+		.act_width	= 1920,
+		.act_height	= 1080,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_3X_HDR_MODE,
+		.device_mode	= 2,
+		.pll_idx	= 1,
+		.width		= 1920,
+		.height		= (1250 - 2) * 3,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_25,
+		.default_fps	= AMBA_VIDEO_FPS_25,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_BG,
+		.dual_gain_mode = 1,
+	},
+	{	/* 1080p 12b combined hdr */
+		.video_mode	= AMBA_VIDEO_MODE_1080P,
+		.def_start_x	= 0,
+		.def_start_y	= 0,
+		.def_width	= 1920,
+		.def_height	= 1080,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_INT_HDR_MODE,
+		.device_mode	= 3,
+		.pll_idx	= 1,
+		.width		= 1920,
+		.height		= 1080,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_BG,
+		.dual_gain_mode = 1,
+		.gp_ctrl_used = 1,
+	},
+};
+
+static struct vin_video_format ov2718_2x_hdr_formats[] = {
+	{	/* 1080p dual gain hdr */
+		.video_mode	= AMBA_VIDEO_MODE_1080P,
+		.def_start_x	= 0,
+		.def_start_y	= 0,
+		.def_width	= 1920,
+		.def_height	= 1080 * 2,
+		.act_start_x	= 0,
+		.act_start_y	= 0,
+		.act_width	= 1920,
+		.act_height	= 1080,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_2X_HDR_MODE,
+		.device_mode	= 1,
+		.pll_idx	= 1,
+		.width		= 1920,
+		.height		= 1080 * 2,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_BG,
+		.dual_gain_mode = 1,
+		.hdr_long_offset = 0,
+		.hdr_short1_offset = 1,
+	},
+	{	/* 1080p lcg+vs hdr */
+		.video_mode	= AMBA_VIDEO_MODE_1080P,
+		.def_start_x	= 0,
+		.def_start_y	= 0,
+		.def_width	= 1920,
+		.def_height	= (1203 - 22) * 2,
+		.act_start_x	= 0,
+		.act_start_y	= 0,
+		.act_width	= 1920,
+		.act_height	= 1080,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_2X_HDR_MODE,
+		.device_mode	= 1,
+		.pll_idx	= 1,
+		.width		= 1920,
+		.height		= (1080 + 100 + 1) * 2,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_BG,
+		.dual_gain_mode = 0,
+	},
+};
+
+static struct vin_video_format ov2718_r2a_formats[] = {
+	{	/* 1080p@30fps */
+		.video_mode = AMBA_VIDEO_MODE_1080P,
+		.def_start_x = 0,
+		.def_start_y = 0,
+		.def_width = 1920,
+		.def_height = 1080,
+		/* sensor mode */
+		.device_mode = 0,
+		.pll_idx = 0,
+		.width = 1920,
+		.height = 1080,
+		.format = AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type = AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits = AMBA_VIDEO_BITS_12,
+		.ratio = AMBA_VIDEO_RATIO_16_9,
+		.max_fps = AMBA_VIDEO_FPS_30,
+		.default_fps = AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern = VINDEV_BAYER_PATTERN_BG,
+	},
+};
+
+static struct vin_reg_16_8 ov2718_linear_regs[] = {
+	/* MIPI 1928x1088 HCG 30fps 600Mbps v1.2 12/07/2016 updated to v6932 */
+	{0x3013, 0x01},{0x3000, 0x05},{0x3001, 0x64},{0x3002, 0x07},{0x3003, 0x01},
+	{0x3004, 0x06},{0x3005, 0x49},{0x3006, 0x00},{0x3007, 0x07},{0x3008, 0x01},
+	{0x3009, 0x00},{0x300c, 0x6c},{0x300d, 0xe1},{0x300e, 0x80},{0x300f, 0x00},
+	{0x3012, 0x00},{0x3013, 0x00},{0x3014, 0xc4},{0x3015, 0x00},{0x3017, 0x00},
+	{0x3018, 0x00},{0x3019, 0x00},{0x301a, 0x00},{0x301b, 0x01},{0x301e, 0x10},
+	{0x301f, 0x5f},{0x3030, 0x02},{0x3031, 0x62},{0x3032, 0xf0},{0x3033, 0x30},
+	{0x3034, 0x34},{0x3035, 0x5f},{0x3036, 0x02},{0x3037, 0x9f},{0x3038, 0x04},
+	{0x3039, 0xb7},{0x303a, 0x04},{0x303b, 0x07},{0x303c, 0xf0},{0x303d, 0x00},
+	{0x303e, 0x0b},{0x303f, 0xe3},{0x3040, 0xf3},{0x3041, 0x29},{0x3042, 0xf6},
+	{0x3043, 0x65},{0x3044, 0x06},{0x3045, 0x0f},{0x3046, 0x55},{0x3047, 0xf7},
+	{0x3048, 0x31},{0x3049, 0x0f},{0x304a, 0x10},{0x304b, 0x40},{0x304c, 0x33},
+	{0x304d, 0xa4},{0x304e, 0x0b},{0x304f, 0x3d},{0x3050, 0x10},{0x3060, 0x00},
+	{0x3061, 0x64},{0x3062, 0x00},{0x3063, 0xe4},{0x3064, 0x0b},{0x3065, 0x60},
+	{0x3066, 0x80},{0x3080, 0x00},{0x3081, 0x00},{0x3082, 0x01},{0x3083, 0xe3},
+	{0x3084, 0x06},{0x3085, 0x00},{0x3086, 0x10},{0x3087, 0x10},{0x3089, 0x00},
+	{0x308a, 0x01},{0x3093, 0x00},{0x30a0, 0x00},{0x30a1, 0x00},{0x30a2, 0x00},
+	{0x30a3, 0x00},{0x30a4, 0x07},{0x30a5, 0x8f},{0x30a6, 0x04},{0x30a7, 0x47},
+	{0x30a8, 0x00},{0x30a9, 0x00},{0x30aa, 0x00},{0x30ab, 0x00},{0x30ac, 0x07},
+	{0x30ad, 0x90},{0x30ae, 0x04},{0x30af, 0x48},{0x30b0, 0x04},{0x30b1, 0x7e},
+	{0x30b2, 0x04},{0x30b3, 0x65},{0x30b4, 0x00},{0x30b5, 0x00},{0x30b6, 0x00},
+	{0x30b7, 0x10},{0x30b8, 0x00},{0x30b9, 0x02},{0x30ba, 0x10},{0x30bb, 0x00},
+	{0x30bc, 0x00},{0x30bd, 0x03},{0x30be, 0x5c},{0x30bf, 0x00},{0x30c0, 0x00},
+	{0x30c1, 0x00},{0x30c2, 0x20},{0x30c3, 0x00},{0x30c4, 0x4a},{0x30c5, 0x00},
+	{0x30c7, 0x00},{0x30c8, 0x00},{0x30d1, 0x00},{0x30d2, 0x00},{0x30d3, 0x80},
+	{0x30d4, 0x00},{0x30d9, 0x09},{0x30da, 0x64},{0x30dd, 0x00},{0x30de, 0x16},
+	{0x30df, 0x00},{0x30e0, 0x17},{0x30e1, 0x00},{0x30e2, 0x18},{0x30e3, 0x10},
+	{0x30e4, 0x04},{0x30e5, 0x00},{0x30e6, 0x00},{0x30e7, 0x00},{0x30e8, 0x00},
+	{0x30e9, 0x00},{0x30ea, 0x00},{0x30eb, 0x00},{0x30ec, 0x00},{0x30ed, 0x00},
+	{0x3101, 0x00},{0x3102, 0x00},{0x3103, 0x00},{0x3104, 0x00},{0x3105, 0x79},
+	{0x3106, 0x81},{0x3107, 0x75},{0x3108, 0x80},{0x3109, 0x6c},{0x310a, 0x83},
+	{0x310b, 0x69},{0x310c, 0x43},{0x310d, 0x42},{0x310e, 0x00},{0x3120, 0x00},
+	{0x3121, 0x00},{0x3122, 0x00},{0x3123, 0x00},{0x3124, 0x00},{0x3125, 0xa0},
+	{0x3126, 0x3f},{0x3127, 0x0f},{0x3128, 0x00},{0x3129, 0x3a},{0x312a, 0x02},
+	{0x312b, 0x0f},{0x312c, 0x00},{0x312d, 0x0f},{0x312e, 0x1d},{0x312f, 0x00},
+	{0x3130, 0x00},{0x3131, 0x00},{0x3132, 0x00},{0x3140, 0x02},{0x3141, 0x03},
+	{0x3142, 0x00},{0x3143, 0x00},{0x3144, 0x00},{0x3145, 0x00},{0x3146, 0x00},
+	{0x3147, 0x00},{0x3148, 0x00},{0x3149, 0x00},{0x314a, 0x00},{0x314b, 0x00},
+	{0x314c, 0x00},{0x314d, 0x00},{0x314e, 0x1c},{0x314f, 0x02},{0x3150, 0x02},
+	{0x3151, 0x02},{0x3152, 0x10},{0x3153, 0x10},{0x3154, 0x10},{0x3155, 0x00},
+	{0x3156, 0x03},{0x3157, 0x00},{0x3158, 0x0f},{0x3159, 0xff},{0x315a, 0x01},
+	{0x315b, 0x00},{0x315c, 0x01},{0x315d, 0x00},{0x315e, 0x01},{0x315f, 0x00},
+	{0x3160, 0x00},{0x3161, 0x40},{0x3162, 0x00},{0x3163, 0x40},{0x3164, 0x00},
+	{0x3165, 0x40},{0x3190, 0x08},{0x3191, 0x99},{0x3193, 0x08},{0x3194, 0x13},
+	{0x3195, 0x33},{0x3196, 0x00},{0x3197, 0x10},{0x3198, 0x00},{0x3199, 0x7f},
+	{0x319a, 0x80},{0x319b, 0xff},{0x319c, 0x80},{0x319d, 0xbf},{0x319e, 0xc0},
+	{0x319f, 0xff},{0x31a0, 0x24},{0x31a1, 0x55},{0x31a2, 0x00},{0x31a3, 0x00},
+	{0x31a6, 0x00},{0x31a7, 0x00},{0x31b0, 0x00},{0x31b1, 0x00},{0x31b2, 0x02},
+	{0x31b3, 0x00},{0x31b4, 0x00},{0x31b5, 0x01},{0x31b6, 0x00},{0x31b7, 0x00},
+	{0x31b8, 0x00},{0x31b9, 0x00},{0x31ba, 0x00},{0x31d0, 0x3c},{0x31d1, 0x34},
+	{0x31d2, 0x3c},{0x31d3, 0x00},{0x31d4, 0x2d},{0x31d5, 0x00},{0x31d6, 0x01},
+	{0x31d7, 0x06},{0x31d8, 0x00},{0x31d9, 0x64},{0x31da, 0x00},{0x31db, 0x30},
+	{0x31dc, 0x04},{0x31dd, 0x69},{0x31de, 0x0a},{0x31df, 0x3c},{0x31e0, 0x04},
+	{0x31e1, 0x32},{0x31e2, 0x00},{0x31e3, 0x01},{0x31e4, 0x0d},{0x31e5, 0x80},
+	{0x31e6, 0x00},{0x31e7, 0x2c},{0x31e8, 0x6c},{0x31e9, 0xac},{0x31ea, 0xec},
+	{0x31eb, 0x3f},{0x31ec, 0x0f},{0x31ed, 0x20},{0x31ee, 0x04},{0x31ef, 0x48},
+	{0x31f0, 0x07},{0x31f1, 0x90},{0x31f2, 0x04},{0x31f3, 0x48},{0x31f4, 0x07},
+	{0x31f5, 0x90},{0x31f6, 0x04},{0x31f7, 0x48},{0x31f8, 0x07},{0x31f9, 0x90},
+	{0x31fa, 0x04},{0x31fb, 0x48},{0x31fd, 0xcb},{0x31fe, 0x0f},{0x31ff, 0x03},
+	{0x3200, 0x00},{0x3201, 0xff},{0x3202, 0x00},{0x3203, 0xff},{0x3204, 0xff},
+	{0x3205, 0xff},{0x3206, 0xff},{0x3207, 0xff},{0x3208, 0xff},{0x3209, 0xff},
+	{0x320a, 0xff},{0x320b, 0x1b},{0x320c, 0x1f},{0x320d, 0x1e},{0x320e, 0x30},
+	{0x320f, 0x2d},{0x3210, 0x2c},{0x3211, 0x2b},{0x3212, 0x2a},{0x3213, 0x24},
+	{0x3214, 0x22},{0x3215, 0x00},{0x3216, 0x04},{0x3217, 0x2c},{0x3218, 0x6c},
+	{0x3219, 0xac},{0x321a, 0xec},{0x321b, 0x00},{0x3230, 0x3a},{0x3231, 0x00},
+	{0x3232, 0x80},{0x3233, 0x00},{0x3234, 0x10},{0x3235, 0xaa},{0x3236, 0x55},
+	{0x3237, 0x99},{0x3238, 0x66},{0x3239, 0x08},{0x323a, 0x88},{0x323b, 0x00},
+	{0x323c, 0x00},{0x323d, 0x03},{0x3250, 0x33},{0x3251, 0x00},{0x3252, 0x20},
+	{0x3253, 0x00},{0x3254, 0x00},{0x3255, 0x01},{0x3256, 0x00},{0x3257, 0x00},
+	{0x3258, 0x00},{0x3270, 0x01},{0x3271, 0x60},{0x3272, 0xc0},{0x3273, 0x00},
+	{0x3274, 0x80},{0x3275, 0x40},{0x3276, 0x02},{0x3277, 0x08},{0x3278, 0x10},
+	{0x3279, 0x04},{0x327a, 0x00},{0x327b, 0x03},{0x327c, 0x10},{0x327d, 0x60},
+	{0x327e, 0xc0},{0x327f, 0x06},{0x3288, 0x10},{0x3289, 0x00},{0x328a, 0x08},
+	{0x328b, 0x00},{0x328c, 0x04},{0x328d, 0x00},{0x328e, 0x02},{0x328f, 0x00},
+	{0x3290, 0x20},{0x3291, 0x00},{0x3292, 0x10},{0x3293, 0x00},{0x3294, 0x08},
+	{0x3295, 0x00},{0x3296, 0x04},{0x3297, 0x00},{0x3298, 0x40},{0x3299, 0x00},
+	{0x329a, 0x20},{0x329b, 0x00},{0x329c, 0x10},{0x329d, 0x00},{0x329e, 0x08},
+	{0x329f, 0x00},{0x32a0, 0x7f},{0x32a1, 0xff},{0x32a2, 0x40},{0x32a3, 0x00},
+	{0x32a4, 0x20},{0x32a5, 0x00},{0x32a6, 0x10},{0x32a7, 0x00},{0x32a8, 0x00},
+	{0x32a9, 0x00},{0x32aa, 0x00},{0x32ab, 0x00},{0x32ac, 0x00},{0x32ad, 0x00},
+	{0x32ae, 0x00},{0x32af, 0x00},{0x32b0, 0x00},{0x32b1, 0x00},{0x32b2, 0x00},
+	{0x32b3, 0x00},{0x32b4, 0x00},{0x32b5, 0x00},{0x32b6, 0x00},{0x32b7, 0x00},
+	{0x32b8, 0x00},{0x32b9, 0x00},{0x32ba, 0x00},{0x32bb, 0x00},{0x32bc, 0x00},
+	{0x32bd, 0x00},{0x32be, 0x00},{0x32bf, 0x00},{0x32c0, 0x00},{0x32c1, 0x00},
+	{0x32c2, 0x00},{0x32c3, 0x00},{0x32c4, 0x00},{0x32c5, 0x00},{0x32c6, 0x00},
+	{0x32c7, 0x00},{0x32c8, 0x87},{0x32c9, 0x00},{0x3330, 0x03},{0x3331, 0xc8},
+	{0x3332, 0x02},{0x3333, 0x24},{0x3334, 0x00},{0x3335, 0x00},{0x3336, 0x00},
+	{0x3337, 0x00},{0x3338, 0x03},{0x3339, 0xc8},{0x333a, 0x02},{0x333b, 0x24},
+	{0x333c, 0x00},{0x333d, 0x00},{0x333e, 0x00},{0x333f, 0x00},{0x3340, 0x03},
+	{0x3341, 0xc8},{0x3342, 0x02},{0x3343, 0x24},{0x3344, 0x00},{0x3345, 0x00},
+	{0x3346, 0x00},{0x3347, 0x00},{0x3348, 0x40},{0x3349, 0x00},{0x334a, 0x00},
+	{0x334b, 0x00},{0x334c, 0x00},{0x334d, 0x00},{0x334e, 0x80},{0x3360, 0x01},
+	{0x3361, 0x00},{0x3362, 0x01},{0x3363, 0x00},{0x3364, 0x01},{0x3365, 0x00},
+	{0x3366, 0x01},{0x3367, 0x00},{0x3368, 0x01},{0x3369, 0x00},{0x336a, 0x01},
+	{0x336b, 0x00},{0x336c, 0x01},{0x336d, 0x00},{0x336e, 0x01},{0x336f, 0x00},
+	{0x3370, 0x01},{0x3371, 0x00},{0x3372, 0x01},{0x3373, 0x00},{0x3374, 0x01},
+	{0x3375, 0x00},{0x3376, 0x01},{0x3377, 0x00},{0x3378, 0x00},{0x3379, 0x00},
+	{0x337a, 0x00},{0x337b, 0x00},{0x337c, 0x00},{0x337d, 0x00},{0x337e, 0x00},
+	{0x337f, 0x00},{0x3380, 0x00},{0x3381, 0x00},{0x3382, 0x00},{0x3383, 0x00},
+	{0x3384, 0x00},{0x3385, 0x00},{0x3386, 0x00},{0x3387, 0x00},{0x3388, 0x00},
+	{0x3389, 0x00},{0x338a, 0x00},{0x338b, 0x00},{0x338c, 0x00},{0x338d, 0x00},
+	{0x338e, 0x00},{0x338f, 0x00},{0x3390, 0x00},{0x3391, 0x00},{0x3392, 0x00},
+	{0x3393, 0x00},{0x3394, 0x00},{0x3395, 0x00},{0x3396, 0x00},{0x3397, 0x00},
+	{0x3398, 0x00},{0x3399, 0x00},{0x339a, 0x00},{0x339b, 0x00},{0x33b0, 0x00},
+	{0x33b1, 0x50},{0x33b2, 0x01},{0x33b3, 0xff},{0x33b4, 0xe0},{0x33b5, 0x6b},
+	{0x33b6, 0x00},{0x33b7, 0x00},{0x33b8, 0x00},{0x33b9, 0x00},{0x33ba, 0x00},
+	{0x33bb, 0x1f},{0x33bc, 0x01},{0x33bd, 0x01},{0x33be, 0x01},{0x33bf, 0x01},
+	{0x33c0, 0x00},{0x33c1, 0x00},{0x33c2, 0x00},{0x33c3, 0x00},{0x33e0, 0x14},
+	{0x33e1, 0x0f},{0x33e2, 0x04},{0x33e3, 0x02},{0x33e4, 0x01},{0x33e5, 0x01},
+	{0x33e6, 0x00},{0x33e7, 0x04},{0x33e8, 0x0c},{0x33e9, 0x00},{0x33ea, 0x01},
+	{0x33eb, 0x02},{0x33ec, 0x03},{0x33ed, 0x02},{0x33ee, 0x05},{0x33ef, 0x0a},
+	{0x33f0, 0x08},{0x33f1, 0x04},{0x33f2, 0x04},{0x33f3, 0x00},{0x33f4, 0x03},
+	{0x33f5, 0x14},{0x33f6, 0x0f},{0x33f7, 0x02},{0x33f8, 0x01},{0x33f9, 0x01},
+	{0x33fa, 0x01},{0x33fb, 0x00},{0x33fc, 0x04},{0x33fd, 0x0c},{0x33fe, 0x00},
+	{0x33ff, 0x01},{0x3400, 0x02},{0x3401, 0x03},{0x3402, 0x01},{0x3403, 0x02},
+	{0x3404, 0x08},{0x3405, 0x08},{0x3406, 0x04},{0x3407, 0x04},{0x3408, 0x00},
+	{0x3409, 0x03},{0x340a, 0x14},{0x340b, 0x0f},{0x340c, 0x04},{0x340d, 0x02},
+	{0x340e, 0x01},{0x340f, 0x01},{0x3410, 0x00},{0x3411, 0x04},{0x3412, 0x0c},
+	{0x3413, 0x00},{0x3414, 0x01},{0x3415, 0x02},{0x3416, 0x03},{0x3417, 0x02},
+	{0x3418, 0x05},{0x3419, 0x0a},{0x341a, 0x08},{0x341b, 0x04},{0x341c, 0x04},
+	{0x341d, 0x00},{0x341e, 0x03},{0x3440, 0x00},{0x3441, 0x00},{0x3442, 0x00},
+	{0x3443, 0x00},{0x3444, 0x02},{0x3445, 0xf0},{0x3446, 0x02},{0x3447, 0x08},
+	{0x3448, 0x00},{0x3460, 0x40},{0x3461, 0x40},{0x3462, 0x40},{0x3463, 0x40},
+	{0x3464, 0x03},{0x3465, 0x01},{0x3466, 0x01},{0x3467, 0x02},{0x3468, 0x30},
+	{0x3469, 0x00},{0x346a, 0x33},{0x346b, 0xbf},{0x3480, 0x40},{0x3481, 0x00},
+	{0x3482, 0x00},{0x3483, 0x00},{0x3484, 0x0d},{0x3485, 0x00},{0x3486, 0x00},
+	{0x3487, 0x00},{0x3488, 0x00},{0x3489, 0x00},{0x348a, 0x00},{0x348b, 0x04},
+	{0x348c, 0x00},{0x348d, 0x01},{0x348f, 0x01},{0x3030, 0x0a},{0x3030, 0x02},
+	{0x7000, 0x7a},{0x7001, 0x1a},{0x7002, 0xc1},{0x7003, 0x03},{0x7004, 0xda},
+	{0x7005, 0x00},{0x7006, 0x18},{0x7007, 0xc1},{0x7008, 0x08},{0x7009, 0xbd},
+	{0x700a, 0x03},{0x700b, 0xbd},{0x700c, 0x06},{0x700d, 0xe6},{0x700e, 0xec},
+	{0x700f, 0x00},{0x7010, 0x19},{0x7011, 0xc2},{0x7012, 0x0c},{0x7013, 0xbc},
+	{0x7014, 0xf0},{0x7015, 0xbc},{0x7016, 0xe6},{0x7017, 0x00},{0x7018, 0x1a},
+	{0x7019, 0xc2},{0x701a, 0x10},{0x701b, 0xbc},{0x701c, 0x8c},{0x701d, 0xbc},
+	{0x701e, 0x34},{0x701f, 0x00},{0x7020, 0xda},{0x7021, 0x72},{0x7022, 0x76},
+	{0x7023, 0xb6},{0x7024, 0xee},{0x7025, 0xcf},{0x7026, 0xac},{0x7027, 0xd0},
+	{0x7028, 0xac},{0x7029, 0xd1},{0x702a, 0x50},{0x702b, 0xac},{0x702c, 0xd2},
+	{0x702d, 0xbc},{0x702e, 0x25},{0x702f, 0x18},{0x7030, 0xc2},{0x7031, 0x1c},
+	{0x7032, 0xbd},{0x7033, 0x03},{0x7034, 0xbd},{0x7035, 0x06},{0x7036, 0xe8},
+	{0x7037, 0x00},{0x7038, 0xb4},{0x7039, 0x00},{0x703a, 0xdc},{0x703b, 0xdf},
+	{0x703c, 0xb0},{0x703d, 0x6e},{0x703e, 0xbd},{0x703f, 0x01},{0x7040, 0xd7},
+	{0x7041, 0xed},{0x7042, 0xe1},{0x7043, 0x36},{0x7044, 0x30},{0x7045, 0xd3},
+	{0x7046, 0x2e},{0x7047, 0x54},{0x7048, 0x46},{0x7049, 0xbc},{0x704a, 0x22},
+	{0x704b, 0x66},{0x704c, 0xbc},{0x704d, 0x24},{0x704e, 0x2c},{0x704f, 0x28},
+	{0x7050, 0xbc},{0x7051, 0x3c},{0x7052, 0xa1},{0x7053, 0xac},{0x7054, 0xd8},
+	{0x7055, 0xd6},{0x7056, 0xb4},{0x7057, 0x04},{0x7058, 0x46},{0x7059, 0xb7},
+	{0x705a, 0x00},{0x705b, 0xbe},{0x705c, 0x08},{0x705d, 0xc3},{0x705e, 0xed},
+	{0x705f, 0xad},{0x7060, 0xc3},{0x7061, 0xd0},{0x7062, 0x19},{0x7063, 0xc1},
+	{0x7064, 0x33},{0x7065, 0xe7},{0x7066, 0xb9},{0x7067, 0x64},{0x7068, 0x50},
+	{0x7069, 0x20},{0x706a, 0xb8},{0x706b, 0x02},{0x706c, 0xbc},{0x706d, 0x17},
+	{0x706e, 0xdb},{0x706f, 0xc7},{0x7070, 0xb8},{0x7071, 0x00},{0x7072, 0x28},
+	{0x7073, 0x54},{0x7074, 0xb4},{0x7075, 0x14},{0x7076, 0xab},{0x7077, 0xbe},
+	{0x7078, 0x06},{0x7079, 0xd8},{0x707a, 0xd6},{0x707b, 0x00},{0x707c, 0xee},
+	{0x707d, 0xe6},{0x707e, 0x18},{0x707f, 0xc2},{0x7080, 0x41},{0x7081, 0xec},
+	{0x7082, 0xb4},{0x7083, 0xbe},{0x7084, 0x62},{0x7085, 0x07},{0x7086, 0xb9},
+	{0x7087, 0x05},{0x7088, 0xad},{0x7089, 0xb4},{0x708a, 0x26},{0x708b, 0x19},
+	{0x708c, 0xc1},{0x708d, 0x49},{0x708e, 0xc3},{0x708f, 0xc4},{0x7090, 0xc0},
+	{0x7091, 0x4b},{0x7092, 0xc3},{0x7093, 0xd4},{0x7094, 0xe7},{0x7095, 0x00},
+	{0x7096, 0x15},{0x7097, 0xc2},{0x7098, 0x4f},{0x7099, 0xc3},{0x709a, 0xb9},
+	{0x709b, 0xc0},{0x709c, 0x4b},{0x709d, 0x00},{0x709e, 0x00},{0x709f, 0x00},
+	{0x70a0, 0xb9},{0x70a1, 0x64},{0x70a2, 0x29},{0x70a3, 0x00},{0x70a4, 0xb8},
+	{0x70a5, 0x12},{0x70a6, 0xbe},{0x70a7, 0x01},{0x70a8, 0xd0},{0x70a9, 0xbc},
+	{0x70aa, 0x01},{0x70ab, 0xac},{0x70ac, 0x37},{0x70ad, 0xd2},{0x70ae, 0xac},
+	{0x70af, 0xad},{0x70b0, 0x28},{0x70b1, 0x00},{0x70b2, 0xb8},{0x70b3, 0x00},
+	{0x70b4, 0xbc},{0x70b5, 0x01},{0x70b6, 0x36},{0x70b7, 0xd3},{0x70b8, 0x30},
+	{0x70b9, 0x04},{0x70ba, 0xe0},{0x70bb, 0xd8},{0x70bc, 0xb4},{0x70bd, 0xcf},
+	{0x70be, 0x45},{0x70bf, 0x00},{0x70c0, 0xbe},{0x70c1, 0x05},{0x70c2, 0x62},
+	{0x70c3, 0x07},{0x70c4, 0xb9},{0x70c5, 0x05},{0x70c6, 0xad},{0x70c7, 0xc3},
+	{0x70c8, 0xe3},{0x70c9, 0x00},{0x70ca, 0x15},{0x70cb, 0xc2},{0x70cc, 0x69},
+	{0x70cd, 0xc3},{0x70ce, 0xdf},{0x70cf, 0xc0},{0x70d0, 0x65},{0x70d1, 0x00},
+	{0x70d2, 0x46},{0x70d3, 0x00},{0x70d4, 0x00},{0x70d5, 0xa1},{0x70d6, 0xb9},
+	{0x70d7, 0x64},{0x70d8, 0x29},{0x70d9, 0x00},{0x70da, 0xb8},{0x70db, 0x02},
+	{0x70dc, 0xbe},{0x70dd, 0x02},{0x70de, 0xd0},{0x70df, 0xdc},{0x70e0, 0xac},
+	{0x70e1, 0xbc},{0x70e2, 0x01},{0x70e3, 0x37},{0x70e4, 0xac},{0x70e5, 0xd2},
+	{0x70e6, 0xad},{0x70e7, 0x28},{0x70e8, 0x00},{0x70e9, 0xb8},{0x70ea, 0x00},
+	{0x70eb, 0xbc},{0x70ec, 0x01},{0x70ed, 0x36},{0x70ee, 0x30},{0x70ef, 0xe0},
+	{0x70f0, 0xd8},{0x70f1, 0xb5},{0x70f2, 0x08},{0x70f3, 0x45},{0x70f4, 0xd6},
+	{0x70f5, 0xbe},{0x70f6, 0x07},{0x70f7, 0x00},{0x70f8, 0x62},{0x70f9, 0x07},
+	{0x70fa, 0xb9},{0x70fb, 0x05},{0x70fc, 0xad},{0x70fd, 0xc3},{0x70fe, 0xe3},
+	{0x70ff, 0x46},{0x7100, 0xcd},{0x7101, 0x07},{0x7102, 0xcd},{0x7103, 0x00},
+	{0x7104, 0xe3},{0x7105, 0x18},{0x7106, 0xc2},{0x7107, 0xb1},{0x7108, 0xb9},
+	{0x7109, 0x64},{0x710a, 0xd1},{0x710b, 0x50},{0x710c, 0xdd},{0x710d, 0xac},
+	{0x710e, 0xcf},{0x710f, 0xdf},{0x7110, 0xb6},{0x7111, 0xee},{0x7112, 0xbc},
+	{0x7113, 0x13},{0x7114, 0xe1},{0x7115, 0x36},{0x7116, 0x30},{0x7117, 0xd3},
+	{0x7118, 0x2e},{0x7119, 0x54},{0x711a, 0xbc},{0x711b, 0x32},{0x711c, 0x2c},
+	{0x711d, 0x50},{0x711e, 0x20},{0x711f, 0x04},{0x7120, 0xb8},{0x7121, 0x02},
+	{0x7122, 0xbc},{0x7123, 0x18},{0x7124, 0xc7},{0x7125, 0xb8},{0x7126, 0x00},
+	{0x7127, 0x28},{0x7128, 0x54},{0x7129, 0xb4},{0x712a, 0xc1},{0x712b, 0x46},
+	{0x712c, 0xbe},{0x712d, 0x04},{0x712e, 0xd6},{0x712f, 0xd8},{0x7130, 0xab},
+	{0x7131, 0x00},{0x7132, 0x62},{0x7133, 0x07},{0x7134, 0xb9},{0x7135, 0x05},
+	{0x7136, 0xad},{0x7137, 0xc3},{0x7138, 0xc0},{0x7139, 0xb9},{0x713a, 0x64},
+	{0x713b, 0x29},{0x713c, 0x00},{0x713d, 0xb8},{0x713e, 0x02},{0x713f, 0xbe},
+	{0x7140, 0x00},{0x7141, 0xad},{0x7142, 0xe2},{0x7143, 0x28},{0x7144, 0x00},
+	{0x7145, 0xb8},{0x7146, 0x00},{0x7147, 0xe6},{0x7148, 0xbd},{0x7149, 0x03},
+	{0x714a, 0xec},{0x714b, 0xe0},{0x714c, 0xd8},{0x714d, 0xb4},{0x714e, 0xcf},
+	{0x714f, 0x45},{0x7150, 0xbe},{0x7151, 0x03},{0x7152, 0x00},{0x7153, 0x30},
+	{0x7154, 0x62},{0x7155, 0x07},{0x7156, 0xb9},{0x7157, 0x05},{0x7158, 0xad},
+	{0x7159, 0xc3},{0x715a, 0xe3},{0x715b, 0x42},{0x715c, 0xe4},{0x715d, 0xcd},
+	{0x715e, 0x07},{0x715f, 0xcd},{0x7160, 0x00},{0x7161, 0x00},{0x7162, 0x17},
+	{0x7163, 0xc2},{0x7164, 0xca},{0x7165, 0xde},{0x7166, 0xcf},{0x7167, 0xdf},
+	{0x7168, 0xac},{0x7169, 0xd1},{0x716a, 0x44},{0x716b, 0xac},{0x716c, 0xb9},
+	{0x716d, 0x76},{0x716e, 0xb8},{0x716f, 0x08},{0x7170, 0xb6},{0x7171, 0xfe},
+	{0x7172, 0xb4},{0x7173, 0xc1},{0x7174, 0xd6},{0x7175, 0xd8},{0x7176, 0xab},
+	{0x7177, 0x00},{0x7178, 0xe1},{0x7179, 0x36},{0x717a, 0x30},{0x717b, 0xd3},
+	{0x717c, 0xbc},{0x717d, 0x29},{0x717e, 0xb4},{0x717f, 0x1d},{0x7180, 0xaa},
+	{0x7181, 0xbd},{0x7182, 0x01},{0x7183, 0xb8},{0x7184, 0x0c},{0x7185, 0x45},
+	{0x7186, 0xe6},{0x7187, 0xbd},{0x7188, 0x03},{0x7189, 0xec},{0x718a, 0xbc},
+	{0x718b, 0x3d},{0x718c, 0xc3},{0x718d, 0xe3},{0x718e, 0x42},{0x718f, 0xb8},
+	{0x7190, 0x00},{0x7191, 0xe4},{0x7192, 0xd5},{0x7193, 0x00},{0x7194, 0xb6},
+	{0x7195, 0x00},{0x7196, 0x7a},{0x7197, 0xbd},{0x7198, 0x03},{0x7199, 0xb5},
+	{0x719a, 0x4d},{0x719b, 0x40},{0x719c, 0x58},{0x719d, 0x6a},{0x719e, 0xdd},
+	{0x719f, 0x1a},{0x71a0, 0xc2},{0x71a1, 0xd2},{0x71a2, 0xe8},{0x71a3, 0x00},
+	{0x71a4, 0xbc},{0x71a5, 0x19},{0x71a6, 0xb9},{0x71a7, 0xfa},{0x71a8, 0x14},
+	{0x71a9, 0xc1},{0x71aa, 0xdb},{0x71ab, 0x76},{0x71ac, 0xd1},{0x71ad, 0xac},
+	{0x71ae, 0x37},{0x71af, 0xbc},{0x71b0, 0x35},{0x71b1, 0x36},{0x71b2, 0x30},
+	{0x71b3, 0xe1},{0x71b4, 0xd3},{0x71b5, 0x7a},{0x71b6, 0xb6},{0x71b7, 0x0c},
+	{0x71b8, 0xff},{0x71b9, 0xb4},{0x71ba, 0xbe},{0x71bb, 0xd9},{0x71bc, 0x00},
+	{0x71bd, 0x56},{0x71be, 0xc0},{0x71bf, 0xe4},{0x71c0, 0xb4},{0x71c1, 0x1d},
+	{0x71c2, 0x00},{0x71c3, 0x00},{0x71c4, 0x56},{0x71c5, 0xaa},{0x71c6, 0xbc},
+	{0x71c7, 0x08},{0x71c8, 0x57},{0x71c9, 0xe8},{0x71ca, 0xb5},{0x71cb, 0x4a},
+	{0x71cc, 0x00},{0x71cd, 0x54},{0x71ce, 0xe7},{0x71cf, 0xc8},{0x71d0, 0xb4},
+	{0x71d1, 0x1d},{0x71d2, 0x03},{0x71d3, 0x03},{0x71d4, 0x56},{0x71d5, 0xaa},
+	{0x71d6, 0xbc},{0x71d7, 0x08},{0x71d8, 0x57},{0x71d9, 0x00},{0x71da, 0xb5},
+	{0x71db, 0x4a},{0x71dc, 0x00},{0x71dd, 0x54},{0x71de, 0xc8},{0x71df, 0xb5},
+	{0x71e0, 0x16},{0x71e1, 0xd9},{0x71e2, 0x00},{0x71e3, 0x56},{0x71e4, 0x08},
+	{0x71e5, 0x57},{0x71e6, 0xe8},{0x71e7, 0xb4},{0x71e8, 0x46},{0x71e9, 0x00},
+	{0x71ea, 0x54},{0x71eb, 0xe7},{0x71ec, 0xc8},{0x71ed, 0xab},{0x71ee, 0x00},
+	{0x71ef, 0x66},{0x71f0, 0x62},{0x71f1, 0x06},{0x71f2, 0x74},{0x71f3, 0xb9},
+	{0x71f4, 0x05},{0x71f5, 0xb7},{0x71f6, 0x10},{0x71f7, 0x0e},{0x71f8, 0xb7},
+	{0x71f9, 0x04},{0x71fa, 0xc8},{0x7600, 0x04},{0x7601, 0x80},{0x7602, 0x07},
+	{0x7603, 0x44},{0x7604, 0x05},{0x7605, 0x33},{0x7606, 0x0f},{0x7607, 0x00},
+	{0x7608, 0x07},{0x7609, 0x40},{0x760a, 0x04},{0x760b, 0xe5},{0x760c, 0x06},
+	{0x760d, 0x50},{0x760e, 0x04},{0x760f, 0xe4},{0x7610, 0x00},{0x7611, 0x00},
+	{0x7612, 0x06},{0x7613, 0x5c},{0x7614, 0x00},{0x7615, 0x0f},{0x7616, 0x06},
+	{0x7617, 0x1c},{0x7618, 0x00},{0x7619, 0x02},{0x761a, 0x06},{0x761b, 0xa0},
+	{0x761c, 0x00},{0x761d, 0x01},{0x761e, 0x06},{0x761f, 0xac},{0x7620, 0x00},
+	{0x7621, 0x0f},{0x7622, 0x05},{0x7623, 0x30},{0x7624, 0x07},{0x7625, 0x00},
+	{0x7626, 0x0f},{0x7627, 0x00},{0x7628, 0x04},{0x7629, 0xe5},{0x762a, 0x05},
+	{0x762b, 0x33},{0x762c, 0x06},{0x762d, 0x50},{0x762e, 0x00},{0x762f, 0x01},
+	{0x7630, 0x06},{0x7631, 0x5c},{0x7632, 0x04},{0x7633, 0xe4},{0x7634, 0x00},
+	{0x7635, 0x0e},{0x7636, 0x05},{0x7637, 0x30},{0x7638, 0x0f},{0x7639, 0x00},
+	{0x763a, 0x06},{0x763b, 0xa4},{0x763c, 0x06},{0x763d, 0x24},{0x763e, 0x00},
+	{0x763f, 0x03},{0x7640, 0x05},{0x7641, 0x33},{0x7642, 0x07},{0x7643, 0x02},
+	{0x7644, 0x06},{0x7645, 0x24},{0x7646, 0x00},{0x7647, 0x01},{0x7648, 0x06},
+	{0x7649, 0x20},{0x764a, 0x0f},{0x764b, 0x00},{0x764c, 0x06},{0x764d, 0x54},
+	{0x764e, 0x06},{0x764f, 0x14},{0x7650, 0x00},{0x7651, 0x03},{0x7652, 0x05},
+	{0x7653, 0x33},{0x7654, 0x07},{0x7655, 0x02},{0x7656, 0x06},{0x7657, 0x14},
+	{0x7658, 0x00},{0x7659, 0x01},{0x765a, 0x06},{0x765b, 0x10},{0x765c, 0x0f},
+	{0x765d, 0x00},{0x765e, 0x06},{0x765f, 0x10},{0x7660, 0x0f},{0x7661, 0x00},
+	{0x7662, 0x06},{0x7663, 0x20},{0x7664, 0x0f},{0x7665, 0x00},{0x7666, 0x00},
+	{0x7667, 0x00},{0x7668, 0x00},{0x7669, 0x02},{0x766a, 0x04},{0x766b, 0xe5},
+	{0x766c, 0x04},{0x766d, 0xe4},{0x766e, 0x0f},{0x766f, 0x00},{0x7670, 0x00},
+	{0x7671, 0x00},{0x7672, 0x00},{0x7673, 0x02},{0x7674, 0x04},{0x7675, 0xe5},
+	{0x7676, 0x04},{0x7677, 0xe4},{0x7678, 0x0f},{0x7679, 0x00},{0x767a, 0x00},
+	{0x767b, 0x02},{0x767c, 0x04},{0x767d, 0xe4},{0x767e, 0x00},{0x767f, 0x02},
+	{0x7680, 0x04},{0x7681, 0xc4},{0x7682, 0x00},{0x7683, 0x04},{0x7684, 0x04},
+	{0x7685, 0xc4},{0x7686, 0x05},{0x7687, 0x83},{0x7688, 0x07},{0x7689, 0x02},
+	{0x768a, 0x0f},{0x768b, 0x00},{0x768c, 0x00},{0x768d, 0x02},{0x768e, 0x04},
+	{0x768f, 0xe4},{0x7690, 0x00},{0x7691, 0x02},{0x7692, 0x04},{0x7693, 0xc4},
+	{0x7694, 0x00},{0x7695, 0x04},{0x7696, 0x04},{0x7697, 0xc4},{0x7698, 0x05},
+	{0x7699, 0x83},{0x769a, 0x07},{0x769b, 0x02},{0x769c, 0x03},{0x769d, 0x0b},
+	{0x769e, 0x05},{0x769f, 0x83},{0x76a0, 0x00},{0x76a1, 0x08},{0x76a2, 0x05},
+	{0x76a3, 0x03},{0x76a4, 0x05},{0x76a5, 0x32},{0x76a6, 0x00},{0x76a7, 0x00},
+	{0x76a8, 0x05},{0x76a9, 0x70},{0x76aa, 0x00},{0x76ab, 0x01},{0x76ac, 0x05},
+	{0x76ad, 0x74},{0x76ae, 0x03},{0x76af, 0x9a},{0x76b0, 0x05},{0x76b1, 0x83},
+	{0x76b2, 0x00},{0x76b3, 0x05},{0x76b4, 0x05},{0x76b5, 0x03},{0x76b6, 0x05},
+	{0x76b7, 0x32},{0x76b8, 0x00},{0x76b9, 0x00},{0x76ba, 0x05},{0x76bb, 0x70},
+	{0x76bc, 0x00},{0x76bd, 0x01},{0x76be, 0x05},{0x76bf, 0x74},{0x76c0, 0x03},
+	{0x76c1, 0x99},{0x76c2, 0x05},{0x76c3, 0x83},{0x76c4, 0x00},{0x76c5, 0x03},
+	{0x76c6, 0x05},{0x76c7, 0x03},{0x76c8, 0x05},{0x76c9, 0x32},{0x76ca, 0x00},
+	{0x76cb, 0x00},{0x76cc, 0x05},{0x76cd, 0x70},{0x76ce, 0x00},{0x76cf, 0x01},
+	{0x76d0, 0x05},{0x76d1, 0x74},{0x76d2, 0x03},{0x76d3, 0x98},{0x76d4, 0x05},
+	{0x76d5, 0x83},{0x76d6, 0x00},{0x76d7, 0x01},{0x76d8, 0x05},{0x76d9, 0x03},
+	{0x76da, 0x05},{0x76db, 0x32},{0x76dc, 0x00},{0x76dd, 0x00},{0x76de, 0x05},
+	{0x76df, 0x70},{0x76e0, 0x00},{0x76e1, 0x01},{0x76e2, 0x05},{0x76e3, 0x74},
+	{0x76e4, 0x03},{0x76e5, 0x97},{0x76e6, 0x05},{0x76e7, 0x83},{0x76e8, 0x00},
+	{0x76e9, 0x01},{0x76ea, 0x05},{0x76eb, 0x03},{0x76ec, 0x05},{0x76ed, 0x32},
+	{0x76ee, 0x00},{0x76ef, 0x00},{0x76f0, 0x05},{0x76f1, 0x70},{0x76f2, 0x00},
+	{0x76f3, 0x01},{0x76f4, 0x05},{0x76f5, 0x74},{0x76f6, 0x03},{0x76f7, 0x96},
+	{0x76f8, 0x05},{0x76f9, 0x83},{0x76fa, 0x00},{0x76fb, 0x01},{0x76fc, 0x05},
+	{0x76fd, 0x03},{0x76fe, 0x05},{0x76ff, 0x32},{0x7700, 0x00},{0x7701, 0x00},
+	{0x7702, 0x05},{0x7703, 0x70},{0x7704, 0x00},{0x7705, 0x01},{0x7706, 0x05},
+	{0x7707, 0x74},{0x7708, 0x03},{0x7709, 0x95},{0x770a, 0x05},{0x770b, 0x83},
+	{0x770c, 0x00},{0x770d, 0x01},{0x770e, 0x05},{0x770f, 0x03},{0x7710, 0x05},
+	{0x7711, 0x32},{0x7712, 0x00},{0x7713, 0x00},{0x7714, 0x05},{0x7715, 0x70},
+	{0x7716, 0x00},{0x7717, 0x01},{0x7718, 0x05},{0x7719, 0x74},{0x771a, 0x03},
+	{0x771b, 0x94},{0x771c, 0x05},{0x771d, 0x83},{0x771e, 0x00},{0x771f, 0x03},
+	{0x7720, 0x05},{0x7721, 0x03},{0x7722, 0x05},{0x7723, 0x32},{0x7724, 0x00},
+	{0x7725, 0x00},{0x7726, 0x05},{0x7727, 0x70},{0x7728, 0x00},{0x7729, 0x01},
+	{0x772a, 0x05},{0x772b, 0x74},{0x772c, 0x03},{0x772d, 0x93},{0x772e, 0x05},
+	{0x772f, 0x83},{0x7730, 0x00},{0x7731, 0x02},{0x7732, 0x05},{0x7733, 0x03},
+	{0x7734, 0x05},{0x7735, 0x32},{0x7736, 0x00},{0x7737, 0x00},{0x7738, 0x05},
+	{0x7739, 0x70},{0x773a, 0x00},{0x773b, 0x01},{0x773c, 0x05},{0x773d, 0x74},
+	{0x773e, 0x03},{0x773f, 0x92},{0x7740, 0x05},{0x7741, 0x83},{0x7742, 0x00},
+	{0x7743, 0x01},{0x7744, 0x05},{0x7745, 0x03},{0x7746, 0x05},{0x7747, 0x32},
+	{0x7748, 0x00},{0x7749, 0x00},{0x774a, 0x05},{0x774b, 0x70},{0x774c, 0x00},
+	{0x774d, 0x01},{0x774e, 0x05},{0x774f, 0x74},{0x7750, 0x03},{0x7751, 0x91},
+	{0x7752, 0x05},{0x7753, 0x83},{0x7754, 0x00},{0x7755, 0x01},{0x7756, 0x05},
+	{0x7757, 0x03},{0x7758, 0x05},{0x7759, 0x32},{0x775a, 0x00},{0x775b, 0x00},
+	{0x775c, 0x05},{0x775d, 0x70},{0x775e, 0x00},{0x775f, 0x01},{0x7760, 0x05},
+	{0x7761, 0x74},{0x7762, 0x03},{0x7763, 0x90},{0x7764, 0x05},{0x7765, 0x83},
+	{0x7766, 0x00},{0x7767, 0x01},{0x7768, 0x05},{0x7769, 0x03},{0x776a, 0x05},
+	{0x776b, 0x32},{0x776c, 0x00},{0x776d, 0x00},{0x776e, 0x05},{0x776f, 0x70},
+	{0x7770, 0x00},{0x7771, 0x01},{0x7772, 0x05},{0x7773, 0x74},{0x7774, 0x02},
+	{0x7775, 0x90},{0x7776, 0x05},{0x7777, 0x03},{0x7778, 0x07},{0x7779, 0x00},
+	{0x777a, 0x0f},{0x777b, 0x00},{0x777c, 0x08},{0x777d, 0x33},{0x777e, 0x08},
+	{0x777f, 0xd4},{0x7780, 0x0f},{0x7781, 0x00},{0x7782, 0x04},{0x7783, 0xe5},
+	{0x7784, 0x06},{0x7785, 0x50},{0x7786, 0x04},{0x7787, 0xe4},{0x7788, 0x00},
+	{0x7789, 0x00},{0x778a, 0x06},{0x778b, 0x5c},{0x778c, 0x09},{0x778d, 0x17},
+	{0x778e, 0x06},{0x778f, 0x1c},{0x7790, 0x00},{0x7791, 0x02},{0x7792, 0x06},
+	{0x7793, 0xa0},{0x7794, 0x00},{0x7795, 0x01},{0x7796, 0x06},{0x7797, 0xac},
+	{0x7798, 0x00},{0x7799, 0x0f},{0x779a, 0x05},{0x779b, 0x30},{0x779c, 0x0f},
+	{0x779d, 0x00},{0x779e, 0x00},{0x779f, 0x00},{0x77a0, 0x00},{0x77a1, 0x02},
+	{0x77a2, 0x04},{0x77a3, 0xe5},{0x77a4, 0x04},{0x77a5, 0xe4},{0x77a6, 0x05},
+	{0x77a7, 0x33},{0x77a8, 0x07},{0x77a9, 0x10},{0x77aa, 0x00},{0x77ab, 0x00},
+	{0x77ac, 0x07},{0x77ad, 0x00},{0x77ae, 0x01},{0x77af, 0xbb},{0x77b0, 0x07},
+	{0x77b1, 0x10},{0x77b2, 0x00},{0x77b3, 0x00},{0x77b4, 0x07},{0x77b5, 0x00},
+	{0x77b6, 0x01},{0x77b7, 0xaa},{0x77b8, 0x07},{0x77b9, 0x10},{0x77ba, 0x00},
+	{0x77bb, 0x00},{0x77bc, 0x07},{0x77bd, 0x00},{0x77be, 0x01},{0x77bf, 0x99},
+	{0x77c0, 0x07},{0x77c1, 0x10},{0x77c2, 0x00},{0x77c3, 0x00},{0x77c4, 0x07},
+	{0x77c5, 0x00},{0x77c6, 0x01},{0x77c7, 0x88},{0x77c8, 0x07},{0x77c9, 0x10},
+	{0x77ca, 0x00},{0x77cb, 0x00},{0x77cc, 0x07},{0x77cd, 0x00},{0x77ce, 0x01},
+	{0x77cf, 0x77},{0x77d0, 0x07},{0x77d1, 0x10},{0x77d2, 0x00},{0x77d3, 0x00},
+	{0x77d4, 0x07},{0x77d5, 0x00},{0x77d6, 0x01},{0x77d7, 0x66},{0x77d8, 0x07},
+	{0x77d9, 0x10},{0x77da, 0x00},{0x77db, 0x00},{0x77dc, 0x07},{0x77dd, 0x00},
+	{0x77de, 0x01},{0x77df, 0x55},{0x77e0, 0x07},{0x77e1, 0x10},{0x77e2, 0x00},
+	{0x77e3, 0x00},{0x77e4, 0x07},{0x77e5, 0x00},{0x77e6, 0x01},{0x77e7, 0x44},
+	{0x77e8, 0x07},{0x77e9, 0x10},{0x77ea, 0x00},{0x77eb, 0x00},{0x77ec, 0x07},
+	{0x77ed, 0x00},{0x77ee, 0x01},{0x77ef, 0x33},{0x77f0, 0x07},{0x77f1, 0x10},
+	{0x77f2, 0x00},{0x77f3, 0x00},{0x77f4, 0x07},{0x77f5, 0x00},{0x77f6, 0x01},
+	{0x77f7, 0x22},{0x77f8, 0x07},{0x77f9, 0x10},{0x77fa, 0x00},{0x77fb, 0x00},
+	{0x77fc, 0x07},{0x77fd, 0x00},{0x77fe, 0x01},{0x77ff, 0x11},{0x7800, 0x07},
+	{0x7801, 0x10},{0x7802, 0x00},{0x7803, 0x00},{0x7804, 0x07},{0x7805, 0x00},
+	{0x7806, 0x01},{0x7807, 0x00},{0x7808, 0x01},{0x7809, 0xff},{0x780a, 0x07},
+	{0x780b, 0x00},{0x780c, 0x02},{0x780d, 0xa0},{0x780e, 0x0f},{0x780f, 0x00},
+	{0x7810, 0x08},{0x7811, 0x38},{0x7812, 0x06},{0x7813, 0x50},{0x7814, 0x04},
+	{0x7815, 0xe4},{0x7816, 0x00},{0x7817, 0x00},{0x7818, 0x05},{0x7819, 0x33},
+	{0x781a, 0x06},{0x781b, 0x5c},{0x781c, 0x09},{0x781d, 0x17},{0x781e, 0x06},
+	{0x781f, 0x1c},{0x7820, 0x05},{0x7821, 0x33},{0x7822, 0x00},{0x7823, 0x01},
+	{0x7824, 0x06},{0x7825, 0x24},{0x7826, 0x00},{0x7827, 0x01},{0x7828, 0x06},
+	{0x7829, 0x20},{0x782a, 0x0f},{0x782b, 0x00},{0x782c, 0x08},{0x782d, 0x38},
+	{0x782e, 0x07},{0x782f, 0x10},{0x7830, 0x00},{0x7831, 0x00},{0x7832, 0x07},
+	{0x7833, 0x00},{0x7834, 0x01},{0x7835, 0xbb},{0x7836, 0x07},{0x7837, 0x10},
+	{0x7838, 0x00},{0x7839, 0x00},{0x783a, 0x07},{0x783b, 0x00},{0x783c, 0x01},
+	{0x783d, 0xaa},{0x783e, 0x07},{0x783f, 0x10},{0x7840, 0x00},{0x7841, 0x00},
+	{0x7842, 0x07},{0x7843, 0x00},{0x7844, 0x01},{0x7845, 0x99},{0x7846, 0x07},
+	{0x7847, 0x10},{0x7848, 0x00},{0x7849, 0x00},{0x784a, 0x07},{0x784b, 0x00},
+	{0x784c, 0x01},{0x784d, 0x88},{0x784e, 0x07},{0x784f, 0x10},{0x7850, 0x00},
+	{0x7851, 0x00},{0x7852, 0x07},{0x7853, 0x00},{0x7854, 0x01},{0x7855, 0x77},
+	{0x7856, 0x07},{0x7857, 0x10},{0x7858, 0x00},{0x7859, 0x00},{0x785a, 0x07},
+	{0x785b, 0x00},{0x785c, 0x01},{0x785d, 0x66},{0x785e, 0x07},{0x785f, 0x10},
+	{0x7860, 0x00},{0x7861, 0x00},{0x7862, 0x07},{0x7863, 0x00},{0x7864, 0x01},
+	{0x7865, 0x55},{0x7866, 0x07},{0x7867, 0x10},{0x7868, 0x00},{0x7869, 0x00},
+	{0x786a, 0x07},{0x786b, 0x00},{0x786c, 0x01},{0x786d, 0x44},{0x786e, 0x07},
+	{0x786f, 0x10},{0x7870, 0x00},{0x7871, 0x00},{0x7872, 0x07},{0x7873, 0x00},
+	{0x7874, 0x01},{0x7875, 0x33},{0x7876, 0x07},{0x7877, 0x10},{0x7878, 0x00},
+	{0x7879, 0x00},{0x787a, 0x07},{0x787b, 0x00},{0x787c, 0x01},{0x787d, 0x22},
+	{0x787e, 0x07},{0x787f, 0x10},{0x7880, 0x00},{0x7881, 0x00},{0x7882, 0x07},
+	{0x7883, 0x00},{0x7884, 0x01},{0x7885, 0x11},{0x7886, 0x07},{0x7887, 0x10},
+	{0x7888, 0x00},{0x7889, 0x00},{0x788a, 0x07},{0x788b, 0x00},{0x788c, 0x01},
+	{0x788d, 0x00},{0x788e, 0x01},{0x788f, 0xff},{0x7890, 0x02},{0x7891, 0xa0},
+	{0x7892, 0x0f},{0x7893, 0x00},{0x7894, 0x08},{0x7895, 0x3d},{0x7896, 0x08},
+	{0x7897, 0x60},{0x7898, 0x0f},{0x7899, 0x00},{0x789a, 0x04},{0x789b, 0xc0},
+	{0x789c, 0x09},{0x789d, 0x17},{0x789e, 0x04},{0x789f, 0x99},{0x78a0, 0x07},
+	{0x78a1, 0x14},{0x78a2, 0x04},{0x78a3, 0x80},{0x78a4, 0x04},{0x78a5, 0xa4},
+	{0x78a6, 0x00},{0x78a7, 0x0a},{0x78a8, 0x04},{0x78a9, 0xa6},{0x78aa, 0x00},
+	{0x78ab, 0x00},{0x78ac, 0x04},{0x78ad, 0xa0},{0x78ae, 0x04},{0x78af, 0x80},
+	{0x78b0, 0x04},{0x78b1, 0x00},{0x78b2, 0x05},{0x78b3, 0x03},{0x78b4, 0x06},
+	{0x78b5, 0x00},{0x78b6, 0x0f},{0x78b7, 0x00},{0x78b8, 0x0f},{0x78b9, 0x00},
+	{0x78ba, 0x0f},{0x78bb, 0x00},{0x30a0, 0x00},{0x30a1, 0x00},{0x30a2, 0x00},
+	{0x30a3, 0x00},{0x30a4, 0x07},{0x30a5, 0x8f},{0x30a6, 0x04},{0x30a7, 0x47},
+	{0x30a8, 0x00},{0x30a9, 0x04},{0x30aa, 0x00},{0x30ab, 0x04},{0x30ac, 0x07},
+	{0x30ad, 0x88},{0x30ae, 0x04},{0x30af, 0x40},{0x30b0, 0x08},{0x30b1, 0x98},
+	{0x30b2, 0x04},{0x30b3, 0x70},{0x3196, 0x00},{0x3197, 0x00},{0x3195, 0x27},
+	{0x30bb, 0x40},{0x315a, 0x02},{0x315b, 0x00},{0x33e2, 0x02},{0x33e3, 0x01},
+	{0x33e4, 0x01},{0x33e5, 0x01},{0x33e8, 0x0c},{0x33e9, 0x02},{0x33ea, 0x02},
+	{0x33eb, 0x02},{0x33ec, 0x03},{0x33ed, 0x01},{0x33ee, 0x02},{0x33ef, 0x08},
+	{0x33f7, 0x02},{0x33f8, 0x01},{0x33f9, 0x01},{0x33fa, 0x01},{0x33fd, 0x0c},
+	{0x33fe, 0x02},{0x33ff, 0x02},{0x3400, 0x02},{0x3401, 0x03},{0x3402, 0x01},
+	{0x3403, 0x02},{0x3404, 0x08},{0x3250, 0xf7},
+
+	/* mirror on */
+	{0x30c0, 0x04},{0x30a9, 0x05},{0x3252, 0x21},
+
+	{0x3012, 0x01},{0x3030, 0x02},
+};
+
+static struct vin_reg_16_8 ov2718_r2a_linear_regs[] = {
+	/* MIPI 1920x1080 30fps 960Mbps */
+	{0x3013, 0x01},{0x3000, 0x02},{0x3001, 0x28},{0x3002, 0x03},{0x3003, 0x01},
+	{0x3004, 0x02},{0x3005, 0x26},{0x3006, 0x00},{0x3007, 0x07},{0x3008, 0x01},
+	{0x3009, 0x00},{0x300c, 0x6c},{0x300e, 0x80},{0x300f, 0x00},{0x3012, 0x00},
+	{0x3013, 0x00},{0x3014, 0xc4},{0x3015, 0x00},{0x3017, 0x00},{0x3018, 0x00},
+	{0x3019, 0x00},{0x301a, 0x00},{0x301b, 0x01},{0x301e, 0x17},{0x301f, 0xe1},
+	{0x3030, 0x02},{0x3031, 0x72},{0x3032, 0xf0},{0x3033, 0x30},{0x3034, 0x3f},
+	{0x3035, 0x5f},{0x3036, 0x02},{0x3037, 0x9f},{0x3038, 0x04},{0x3039, 0xb7},
+	{0x303a, 0x04},{0x303b, 0x07},{0x303c, 0xf0},{0x303d, 0x00},{0x303e, 0x0b},
+	{0x303f, 0xe3},{0x3040, 0xf3},{0x3041, 0x29},{0x3042, 0xf6},{0x3043, 0x65},
+	{0x3044, 0x06},{0x3045, 0x0f},{0x3046, 0x59},{0x3047, 0x07},{0x3048, 0x82},
+	{0x3049, 0xcf},{0x304a, 0x12},{0x304b, 0x40},{0x304c, 0x33},{0x304d, 0xa4},
+	{0x304e, 0x0b},{0x304f, 0x3d},{0x3050, 0x10},{0x3060, 0x00},{0x3061, 0x64},
+	{0x3062, 0x00},{0x3063, 0xe4},{0x3064, 0x0b},{0x3065, 0x60},{0x3066, 0x80},
+	{0x3080, 0x00},{0x3081, 0x00},{0x3082, 0x01},{0x3083, 0xe3},{0x3084, 0x06},
+	{0x3085, 0x00},{0x3086, 0x10},{0x3087, 0x10},{0x3089, 0x00},{0x308a, 0x01},
+	{0x3093, 0x00},{0x30a0, 0x00},{0x30a1, 0x00},{0x30a2, 0x00},{0x30a3, 0x00},
+	{0x30a4, 0x07},{0x30a5, 0x8f},{0x30a6, 0x04},{0x30a7, 0x47},{0x30a8, 0x00},
+	{0x30a9, 0x00},{0x30aa, 0x00},{0x30ab, 0x00},{0x30ac, 0x07},{0x30ad, 0x90},
+	{0x30ae, 0x04},{0x30af, 0x48},{0x30b0, 0x04},{0x30b1, 0x7e},{0x30b2, 0x04},
+	{0x30b3, 0x65},{0x30b4, 0x00},{0x30b5, 0x00},{0x30b6, 0x00},{0x30b7, 0x10},
+	{0x30b8, 0x00},{0x30b9, 0x02},{0x30ba, 0x10},{0x30bb, 0x00},{0x30bc, 0x00},
+	{0x30bd, 0x03},{0x30be, 0x5c},{0x30bf, 0x00},{0x30c0, 0x00},{0x30c1, 0x00},
+	{0x30c2, 0x20},{0x30c3, 0x00},{0x30c4, 0x4a},{0x30c5, 0x00},{0x30c7, 0x00},
+	{0x30c8, 0x00},{0x30d1, 0x00},{0x30d2, 0x00},{0x30d3, 0x80},{0x30d4, 0x00},
+	{0x30d9, 0x09},{0x30da, 0x64},{0x30dd, 0x00},{0x30de, 0x16},{0x30df, 0x00},
+	{0x30e0, 0x17},{0x30e1, 0x00},{0x30e2, 0x18},{0x30e3, 0x10},{0x30e4, 0x04},
+	{0x30e5, 0x00},{0x30e6, 0x00},{0x30e7, 0x00},{0x30e8, 0x00},{0x30e9, 0x00},
+	{0x30ea, 0x00},{0x30eb, 0x00},{0x30ec, 0x00},{0x30ed, 0x00},{0x3101, 0x00},
+	{0x3102, 0x00},{0x3103, 0x00},{0x3104, 0x00},{0x3105, 0x8c},{0x3106, 0x87},
+	{0x3107, 0xc0},{0x3108, 0x9d},{0x3109, 0x8d},{0x310a, 0x8d},{0x310b, 0x6a},
+	{0x310c, 0x3a},{0x310d, 0x5a},{0x310e, 0x00},{0x3120, 0x00},{0x3121, 0x00},
+	{0x3122, 0x00},{0x3123, 0xf0},{0x3124, 0x00},{0x3125, 0x70},{0x3126, 0x1f},
+	{0x3127, 0x0f},{0x3128, 0x00},{0x3129, 0x3a},{0x312a, 0x02},{0x312b, 0x0f},
+	{0x312c, 0x00},{0x312d, 0x0f},{0x312e, 0x1d},{0x312f, 0x00},{0x3130, 0x00},
+	{0x3131, 0x00},{0x3132, 0x00},{0x3140, 0x0a},{0x3141, 0x03},{0x3142, 0x00},
+	{0x3143, 0x00},{0x3144, 0x00},{0x3145, 0x00},{0x3146, 0x00},{0x3147, 0x00},
+	{0x3148, 0x00},{0x3149, 0x00},{0x314a, 0x00},{0x314b, 0x00},{0x314c, 0x00},
+	{0x314d, 0x00},{0x314e, 0x1c},{0x314f, 0xff},{0x3150, 0xff},{0x3151, 0xff},
+	{0x3152, 0x10},{0x3153, 0x10},{0x3154, 0x10},{0x3155, 0x00},{0x3156, 0x03},
+	{0x3157, 0x00},{0x3158, 0x0f},{0x3159, 0xff},{0x315a, 0x01},{0x315b, 0x00},
+	{0x315c, 0x01},{0x315d, 0x00},{0x315e, 0x01},{0x315f, 0x00},{0x3160, 0x00},
+	{0x3161, 0x40},{0x3162, 0x00},{0x3163, 0x40},{0x3164, 0x00},{0x3165, 0x40},
+	{0x3190, 0x08},{0x3191, 0x99},{0x3193, 0x08},{0x3194, 0x13},{0x3195, 0x33},
+	{0x3196, 0x00},{0x3197, 0x10},{0x3198, 0x00},{0x3199, 0x7f},{0x319a, 0x80},
+	{0x319b, 0xff},{0x319c, 0x80},{0x319d, 0xbf},{0x319e, 0xc0},{0x319f, 0xff},
+	{0x31a0, 0x24},{0x31a1, 0x55},{0x31a2, 0x00},{0x31a3, 0x00},{0x31a6, 0x00},
+	{0x31a7, 0x00},{0x31b0, 0x00},{0x31b1, 0x00},{0x31b2, 0x02},{0x31b3, 0x00},
+	{0x31b4, 0x00},{0x31b5, 0x01},{0x31b6, 0x00},{0x31b7, 0x00},{0x31b8, 0x00},
+	{0x31b9, 0x00},{0x31ba, 0x00},{0x31d0, 0x3c},{0x31d1, 0x34},{0x31d2, 0x3c},
+	{0x31d3, 0x00},{0x31d4, 0x2d},{0x31d5, 0x00},{0x31d6, 0x01},{0x31d7, 0x06},
+	{0x31d8, 0x00},{0x31d9, 0x64},{0x31da, 0x00},{0x31db, 0x30},{0x31dc, 0x04},
+	{0x31dd, 0x69},{0x31de, 0x0a},{0x31df, 0x3c},{0x31e0, 0x04},{0x31e1, 0x32},
+	{0x31e2, 0x00},{0x31e3, 0x00},{0x31e4, 0x08},{0x31e5, 0x80},{0x31e6, 0x00},
+	{0x31e7, 0x2c},{0x31e8, 0x6c},{0x31e9, 0xac},{0x31ea, 0xec},{0x31eb, 0x3f},
+	{0x31ec, 0x0f},{0x31ed, 0x20},{0x31ee, 0x04},{0x31ef, 0x48},{0x31f0, 0x07},
+	{0x31f1, 0x90},{0x31f2, 0x04},{0x31f3, 0x48},{0x31f4, 0x07},{0x31f5, 0x90},
+	{0x31f6, 0x04},{0x31f7, 0x48},{0x31f8, 0x07},{0x31f9, 0x90},{0x31fa, 0x04},
+	{0x31fb, 0x48},{0x31fd, 0xcb},{0x31fe, 0x0f},{0x31ff, 0x03},{0x3200, 0x00},
+	{0x3201, 0xff},{0x3202, 0x00},{0x3203, 0xff},{0x3204, 0xff},{0x3205, 0xff},
+	{0x3206, 0xff},{0x3207, 0xff},{0x3208, 0xff},{0x3209, 0xff},{0x320a, 0xff},
+	{0x320b, 0x1b},{0x320c, 0x1f},{0x320d, 0x1e},{0x320e, 0x30},{0x320f, 0x2d},
+	{0x3210, 0x2c},{0x3211, 0x2b},{0x3212, 0x2a},{0x3213, 0x24},{0x3214, 0x22},
+	{0x3215, 0x00},{0x3216, 0x04},{0x3217, 0x2c},{0x3218, 0x6c},{0x3219, 0xac},
+	{0x321a, 0xec},{0x321b, 0x00},{0x3230, 0x3a},{0x3231, 0x00},{0x3232, 0x80},
+	{0x3233, 0x00},{0x3234, 0x10},{0x3235, 0xaa},{0x3236, 0x55},{0x3237, 0x99},
+	{0x3238, 0x66},{0x3239, 0x08},{0x323a, 0x88},{0x323b, 0x00},{0x323c, 0x00},
+	{0x323d, 0x03},{0x3250, 0x33},{0x3251, 0x00},{0x3252, 0x20},{0x3253, 0x00},
+	{0x3254, 0x00},{0x3255, 0x01},{0x3256, 0x00},{0x3257, 0x00},{0x3258, 0x00},
+	{0x3270, 0x01},{0x3271, 0x60},{0x3272, 0xc0},{0x3273, 0x00},{0x3274, 0x80},
+	{0x3275, 0x40},{0x3276, 0x02},{0x3277, 0x08},{0x3278, 0x10},{0x3279, 0x04},
+	{0x327a, 0x00},{0x327b, 0x03},{0x327c, 0x10},{0x327d, 0x60},{0x327e, 0xc0},
+	{0x327f, 0x06},{0x3288, 0x10},{0x3289, 0x00},{0x328a, 0x08},{0x328b, 0x00},
+	{0x328c, 0x04},{0x328d, 0x00},{0x328e, 0x02},{0x328f, 0x00},{0x3290, 0x20},
+	{0x3291, 0x00},{0x3292, 0x10},{0x3293, 0x00},{0x3294, 0x08},{0x3295, 0x00},
+	{0x3296, 0x04},{0x3297, 0x00},{0x3298, 0x40},{0x3299, 0x00},{0x329a, 0x20},
+	{0x329b, 0x00},{0x329c, 0x10},{0x329d, 0x00},{0x329e, 0x08},{0x329f, 0x00},
+	{0x32a0, 0x7f},{0x32a1, 0xff},{0x32a2, 0x40},{0x32a3, 0x00},{0x32a4, 0x20},
+	{0x32a5, 0x00},{0x32a6, 0x10},{0x32a7, 0x00},{0x32a8, 0x00},{0x32a9, 0x00},
+	{0x32aa, 0x00},{0x32ab, 0x00},{0x32ac, 0x00},{0x32ad, 0x00},{0x32ae, 0x00},
+	{0x32af, 0x00},{0x32b0, 0x00},{0x32b1, 0x00},{0x32b2, 0x00},{0x32b3, 0x00},
+	{0x32b4, 0x00},{0x32b5, 0x00},{0x32b6, 0x00},{0x32b7, 0x00},{0x32b8, 0x00},
+	{0x32b9, 0x00},{0x32ba, 0x00},{0x32bb, 0x00},{0x32bc, 0x00},{0x32bd, 0x00},
+	{0x32be, 0x00},{0x32bf, 0x00},{0x32c0, 0x00},{0x32c1, 0x00},{0x32c2, 0x00},
+	{0x32c3, 0x00},{0x32c4, 0x00},{0x32c5, 0x00},{0x32c6, 0x00},{0x32c7, 0x00},
+	{0x32c8, 0x87},{0x32c9, 0x00},{0x3330, 0x03},{0x3331, 0xc8},{0x3332, 0x02},
+	{0x3333, 0x24},{0x3334, 0x00},{0x3335, 0x00},{0x3336, 0x00},{0x3337, 0x00},
+	{0x3338, 0x03},{0x3339, 0xc8},{0x333a, 0x02},{0x333b, 0x24},{0x333c, 0x00},
+	{0x333d, 0x00},{0x333e, 0x00},{0x333f, 0x00},{0x3340, 0x03},{0x3341, 0xc8},
+	{0x3342, 0x02},{0x3343, 0x24},{0x3344, 0x00},{0x3345, 0x00},{0x3346, 0x00},
+	{0x3347, 0x00},{0x3348, 0x40},{0x3349, 0x00},{0x334a, 0x00},{0x334b, 0x00},
+	{0x334c, 0x00},{0x334d, 0x00},{0x334e, 0x80},{0x3360, 0x01},{0x3361, 0x00},
+	{0x3362, 0x01},{0x3363, 0x00},{0x3364, 0x01},{0x3365, 0x00},{0x3366, 0x01},
+	{0x3367, 0x00},{0x3368, 0x01},{0x3369, 0x00},{0x336a, 0x01},{0x336b, 0x00},
+	{0x336c, 0x01},{0x336d, 0x00},{0x336e, 0x01},{0x336f, 0x00},{0x3370, 0x01},
+	{0x3371, 0x00},{0x3372, 0x01},{0x3373, 0x00},{0x3374, 0x01},{0x3375, 0x00},
+	{0x3376, 0x01},{0x3377, 0x00},{0x3378, 0x00},{0x3379, 0x00},{0x337a, 0x00},
+	{0x337b, 0x00},{0x337c, 0x00},{0x337d, 0x00},{0x337e, 0x00},{0x337f, 0x00},
+	{0x3380, 0x00},{0x3381, 0x00},{0x3382, 0x00},{0x3383, 0x00},{0x3384, 0x00},
+	{0x3385, 0x00},{0x3386, 0x00},{0x3387, 0x00},{0x3388, 0x00},{0x3389, 0x00},
+	{0x338a, 0x00},{0x338b, 0x00},{0x338c, 0x00},{0x338d, 0x00},{0x338e, 0x00},
+	{0x338f, 0x00},{0x3390, 0x00},{0x3391, 0x00},{0x3392, 0x00},{0x3393, 0x00},
+	{0x3394, 0x00},{0x3395, 0x00},{0x3396, 0x00},{0x3397, 0x00},{0x3398, 0x00},
+	{0x3399, 0x00},{0x339a, 0x00},{0x339b, 0x00},{0x33b0, 0x00},{0x33b1, 0x50},
+	{0x33b2, 0x01},{0x33b3, 0xff},{0x33b4, 0xe0},{0x33b5, 0x6b},{0x33b6, 0x00},
+	{0x33b7, 0x00},{0x33b8, 0x00},{0x33b9, 0x00},{0x33ba, 0x00},{0x33bb, 0x1f},
+	{0x33bc, 0x01},{0x33bd, 0x01},{0x33be, 0x01},{0x33bf, 0x01},{0x33c0, 0x00},
+	{0x33c1, 0x00},{0x33c2, 0x00},{0x33c3, 0x00},{0x33e0, 0x14},{0x33e1, 0x0f},
+	{0x33e2, 0x04},{0x33e3, 0x02},{0x33e4, 0x01},{0x33e5, 0x01},{0x33e6, 0x00},
+	{0x33e7, 0x04},{0x33e8, 0x0c},{0x33e9, 0x00},{0x33ea, 0x01},{0x33eb, 0x02},
+	{0x33ec, 0x03},{0x33ed, 0x02},{0x33ee, 0x05},{0x33ef, 0x0a},{0x33f0, 0x08},
+	{0x33f1, 0x04},{0x33f2, 0x04},{0x33f3, 0x00},{0x33f4, 0x03},{0x33f5, 0x14},
+	{0x33f6, 0x0f},{0x33f7, 0x02},{0x33f8, 0x01},{0x33f9, 0x01},{0x33fa, 0x01},
+	{0x33fb, 0x00},{0x33fc, 0x04},{0x33fd, 0x0c},{0x33fe, 0x00},{0x33ff, 0x01},
+	{0x3400, 0x02},{0x3401, 0x03},{0x3402, 0x01},{0x3403, 0x02},{0x3404, 0x08},
+	{0x3405, 0x08},{0x3406, 0x04},{0x3407, 0x04},{0x3408, 0x00},{0x3409, 0x03},
+	{0x340a, 0x14},{0x340b, 0x0f},{0x340c, 0x04},{0x340d, 0x02},{0x340e, 0x01},
+	{0x340f, 0x01},{0x3410, 0x00},{0x3411, 0x04},{0x3412, 0x0c},{0x3413, 0x00},
+	{0x3414, 0x01},{0x3415, 0x02},{0x3416, 0x03},{0x3417, 0x02},{0x3418, 0x05},
+	{0x3419, 0x0a},{0x341a, 0x08},{0x341b, 0x04},{0x341c, 0x04},{0x341d, 0x00},
+	{0x341e, 0x03},{0x3440, 0x00},{0x3441, 0x00},{0x3442, 0x00},{0x3443, 0x00},
+	{0x3444, 0x02},{0x3445, 0xf0},{0x3446, 0x02},{0x3447, 0x08},{0x3448, 0x00},
+	{0x3460, 0x40},{0x3461, 0x40},{0x3462, 0x40},{0x3463, 0x40},{0x3464, 0x03},
+	{0x3465, 0x01},{0x3466, 0x01},{0x3467, 0x02},{0x3468, 0x30},{0x3469, 0x00},
+	{0x346a, 0x33},{0x346b, 0xbf},{0x3480, 0x40},{0x3481, 0x00},{0x3482, 0x00},
+	{0x3483, 0x00},{0x3484, 0x0d},{0x3485, 0x00},{0x3486, 0x00},{0x3487, 0x00},
+	{0x3488, 0x00},{0x3489, 0x00},{0x348a, 0x00},{0x348b, 0x04},{0x348c, 0x00},
+	{0x348d, 0x01},{0x348f, 0x01},{0x3030, 0x0a},{0x3030, 0x02},{0x7000, 0x58},
+	{0x7001, 0x7a},{0x7002, 0x1a},{0x7003, 0xc1},{0x7004, 0x03},{0x7005, 0xda},
+	{0x7006, 0xbd},{0x7007, 0x03},{0x7008, 0xbd},{0x7009, 0x06},{0x700a, 0xe6},
+	{0x700b, 0xec},{0x700c, 0xbc},{0x700d, 0xff},{0x700e, 0xbc},{0x700f, 0x73},
+	{0x7010, 0xda},{0x7011, 0x72},{0x7012, 0x76},{0x7013, 0xb6},{0x7014, 0xee},
+	{0x7015, 0xcf},{0x7016, 0xac},{0x7017, 0xd0},{0x7018, 0xac},{0x7019, 0xd1},
+	{0x701a, 0x50},{0x701b, 0xac},{0x701c, 0xd2},{0x701d, 0xbc},{0x701e, 0x2e},
+	{0x701f, 0xb4},{0x7020, 0x00},{0x7021, 0xdc},{0x7022, 0xdf},{0x7023, 0xb0},
+	{0x7024, 0x6e},{0x7025, 0xbd},{0x7026, 0x01},{0x7027, 0xd7},{0x7028, 0xed},
+	{0x7029, 0xe1},{0x702a, 0x36},{0x702b, 0x30},{0x702c, 0xd3},{0x702d, 0x2e},
+	{0x702e, 0x54},{0x702f, 0x46},{0x7030, 0xbc},{0x7031, 0x22},{0x7032, 0x66},
+	{0x7033, 0xbc},{0x7034, 0x24},{0x7035, 0x2c},{0x7036, 0x28},{0x7037, 0xbc},
+	{0x7038, 0x3c},{0x7039, 0xa1},{0x703a, 0xac},{0x703b, 0xd8},{0x703c, 0xd6},
+	{0x703d, 0xb4},{0x703e, 0x04},{0x703f, 0x46},{0x7040, 0xb7},{0x7041, 0x04},
+	{0x7042, 0xbe},{0x7043, 0x08},{0x7044, 0xc3},{0x7045, 0xd9},{0x7046, 0xad},
+	{0x7047, 0xc3},{0x7048, 0xbc},{0x7049, 0x19},{0x704a, 0xc1},{0x704b, 0x27},
+	{0x704c, 0xe7},{0x704d, 0x00},{0x704e, 0xb9},{0x704f, 0x64},{0x7050, 0x50},
+	{0x7051, 0x20},{0x7052, 0xb8},{0x7053, 0x02},{0x7054, 0xbc},{0x7055, 0x17},
+	{0x7056, 0xdb},{0x7057, 0xc7},{0x7058, 0xb8},{0x7059, 0x00},{0x705a, 0x28},
+	{0x705b, 0x54},{0x705c, 0xb4},{0x705d, 0x14},{0x705e, 0xab},{0x705f, 0xbe},
+	{0x7060, 0x06},{0x7061, 0xd8},{0x7062, 0xd6},{0x7063, 0x00},{0x7064, 0xb4},
+	{0x7065, 0xc7},{0x7066, 0x62},{0x7067, 0x07},{0x7068, 0xb9},{0x7069, 0x05},
+	{0x706a, 0xee},{0x706b, 0xe6},{0x706c, 0xad},{0x706d, 0xb4},{0x706e, 0x26},
+	{0x706f, 0x19},{0x7070, 0xc1},{0x7071, 0x3b},{0x7072, 0xc3},{0x7073, 0xaf},
+	{0x7074, 0xc0},{0x7075, 0x3d},{0x7076, 0xc3},{0x7077, 0xbe},{0x7078, 0xe7},
+	{0x7079, 0x00},{0x707a, 0x15},{0x707b, 0xc2},{0x707c, 0x41},{0x707d, 0xc3},
+	{0x707e, 0xa4},{0x707f, 0xc0},{0x7080, 0x3d},{0x7081, 0x00},{0x7082, 0xb9},
+	{0x7083, 0x64},{0x7084, 0x29},{0x7085, 0x00},{0x7086, 0xb8},{0x7087, 0x12},
+	{0x7088, 0xbe},{0x7089, 0x01},{0x708a, 0xd0},{0x708b, 0xbc},{0x708c, 0x01},
+	{0x708d, 0xac},{0x708e, 0x37},{0x708f, 0xd2},{0x7090, 0xac},{0x7091, 0x45},
+	{0x7092, 0xad},{0x7093, 0x28},{0x7094, 0x00},{0x7095, 0xb8},{0x7096, 0x00},
+	{0x7097, 0xbc},{0x7098, 0x01},{0x7099, 0x36},{0x709a, 0xd3},{0x709b, 0x30},
+	{0x709c, 0x04},{0x709d, 0xe0},{0x709e, 0xd8},{0x709f, 0xb4},{0x70a0, 0xe9},
+	{0x70a1, 0x00},{0x70a2, 0xbe},{0x70a3, 0x05},{0x70a4, 0x62},{0x70a5, 0x07},
+	{0x70a6, 0xb9},{0x70a7, 0x05},{0x70a8, 0xad},{0x70a9, 0xc3},{0x70aa, 0xcf},
+	{0x70ab, 0x00},{0x70ac, 0x15},{0x70ad, 0xc2},{0x70ae, 0x5a},{0x70af, 0xc3},
+	{0x70b0, 0xc9},{0x70b1, 0xc0},{0x70b2, 0x56},{0x70b3, 0x00},{0x70b4, 0x46},
+	{0x70b5, 0xa1},{0x70b6, 0xb9},{0x70b7, 0x64},{0x70b8, 0x29},{0x70b9, 0x00},
+	{0x70ba, 0xb8},{0x70bb, 0x02},{0x70bc, 0xbe},{0x70bd, 0x02},{0x70be, 0xd0},
+	{0x70bf, 0xdc},{0x70c0, 0xac},{0x70c1, 0xbc},{0x70c2, 0x01},{0x70c3, 0x37},
+	{0x70c4, 0xac},{0x70c5, 0xd2},{0x70c6, 0x45},{0x70c7, 0xad},{0x70c8, 0x28},
+	{0x70c9, 0x00},{0x70ca, 0xb8},{0x70cb, 0x00},{0x70cc, 0xbc},{0x70cd, 0x01},
+	{0x70ce, 0x36},{0x70cf, 0x30},{0x70d0, 0xe0},{0x70d1, 0xd8},{0x70d2, 0xb5},
+	{0x70d3, 0x0b},{0x70d4, 0xd6},{0x70d5, 0xbe},{0x70d6, 0x07},{0x70d7, 0x00},
+	{0x70d8, 0x62},{0x70d9, 0x07},{0x70da, 0xb9},{0x70db, 0x05},{0x70dc, 0xad},
+	{0x70dd, 0xc3},{0x70de, 0xcf},{0x70df, 0x46},{0x70e0, 0xcd},{0x70e1, 0x07},
+	{0x70e2, 0xcd},{0x70e3, 0x00},{0x70e4, 0xe3},{0x70e5, 0x18},{0x70e6, 0xc2},
+	{0x70e7, 0xa2},{0x70e8, 0xb9},{0x70e9, 0x64},{0x70ea, 0xd1},{0x70eb, 0xdd},
+	{0x70ec, 0xac},{0x70ed, 0xcf},{0x70ee, 0xdf},{0x70ef, 0xb5},{0x70f0, 0x19},
+	{0x70f1, 0x46},{0x70f2, 0x50},{0x70f3, 0xb6},{0x70f4, 0xee},{0x70f5, 0xe8},
+	{0x70f6, 0xe6},{0x70f7, 0xbc},{0x70f8, 0x31},{0x70f9, 0xe1},{0x70fa, 0x36},
+	{0x70fb, 0x30},{0x70fc, 0xd3},{0x70fd, 0x2e},{0x70fe, 0x54},{0x70ff, 0xbd},
+	{0x7100, 0x03},{0x7101, 0xec},{0x7102, 0x2c},{0x7103, 0x50},{0x7104, 0x20},
+	{0x7105, 0x04},{0x7106, 0xb8},{0x7107, 0x02},{0x7108, 0xbc},{0x7109, 0x18},
+	{0x710a, 0xc7},{0x710b, 0xb8},{0x710c, 0x00},{0x710d, 0x28},{0x710e, 0x54},
+	{0x710f, 0x02},{0x7110, 0xb4},{0x7111, 0xda},{0x7112, 0xbe},{0x7113, 0x04},
+	{0x7114, 0xd6},{0x7115, 0xd8},{0x7116, 0xab},{0x7117, 0x00},{0x7118, 0x62},
+	{0x7119, 0x07},{0x711a, 0xb9},{0x711b, 0x05},{0x711c, 0xad},{0x711d, 0xc3},
+	{0x711e, 0xbc},{0x711f, 0xe7},{0x7120, 0xb9},{0x7121, 0x64},{0x7122, 0x29},
+	{0x7123, 0x00},{0x7124, 0xb8},{0x7125, 0x02},{0x7126, 0xbe},{0x7127, 0x00},
+	{0x7128, 0x45},{0x7129, 0xad},{0x712a, 0xe2},{0x712b, 0x28},{0x712c, 0x00},
+	{0x712d, 0xb8},{0x712e, 0x00},{0x712f, 0xe0},{0x7130, 0xd8},{0x7131, 0xb4},
+	{0x7132, 0xe9},{0x7133, 0xbe},{0x7134, 0x03},{0x7135, 0x00},{0x7136, 0x30},
+	{0x7137, 0x62},{0x7138, 0x07},{0x7139, 0xb9},{0x713a, 0x05},{0x713b, 0xad},
+	{0x713c, 0xc3},{0x713d, 0xcf},{0x713e, 0x42},{0x713f, 0xe4},{0x7140, 0xcd},
+	{0x7141, 0x07},{0x7142, 0xcd},{0x7143, 0x00},{0x7144, 0x17},{0x7145, 0xc2},
+	{0x7146, 0xbb},{0x7147, 0xde},{0x7148, 0xcf},{0x7149, 0xdf},{0x714a, 0xac},
+	{0x714b, 0xd1},{0x714c, 0x44},{0x714d, 0xac},{0x714e, 0xb9},{0x714f, 0x76},
+	{0x7150, 0xb8},{0x7151, 0x08},{0x7152, 0xb6},{0x7153, 0xfe},{0x7154, 0xb4},
+	{0x7155, 0xca},{0x7156, 0xd6},{0x7157, 0xd8},{0x7158, 0xab},{0x7159, 0x00},
+	{0x715a, 0xe1},{0x715b, 0x36},{0x715c, 0x30},{0x715d, 0xd3},{0x715e, 0xbc},
+	{0x715f, 0x29},{0x7160, 0xb4},{0x7161, 0x1f},{0x7162, 0xaa},{0x7163, 0xbd},
+	{0x7164, 0x01},{0x7165, 0xb8},{0x7166, 0x0c},{0x7167, 0x45},{0x7168, 0xa4},
+	{0x7169, 0xbd},{0x716a, 0x03},{0x716b, 0xec},{0x716c, 0xbc},{0x716d, 0x3d},
+	{0x716e, 0xc3},{0x716f, 0xcf},{0x7170, 0x42},{0x7171, 0xb8},{0x7172, 0x00},
+	{0x7173, 0xe4},{0x7174, 0xd5},{0x7175, 0x00},{0x7176, 0xb6},{0x7177, 0x00},
+	{0x7178, 0x74},{0x7179, 0xbd},{0x717a, 0x03},{0x717b, 0xb5},{0x717c, 0x39},
+	{0x717d, 0x40},{0x717e, 0x58},{0x717f, 0x6a},{0x7180, 0xdd},{0x7181, 0x19},
+	{0x7182, 0xc1},{0x7183, 0xc8},{0x7184, 0xbd},{0x7185, 0x06},{0x7186, 0x17},
+	{0x7187, 0xc1},{0x7188, 0xc6},{0x7189, 0xe8},{0x718a, 0xc0},{0x718b, 0xc8},
+	{0x718c, 0xe6},{0x718d, 0x95},{0x718e, 0x15},{0x718f, 0x00},{0x7190, 0xbc},
+	{0x7191, 0x19},{0x7192, 0xb9},{0x7193, 0xf6},{0x7194, 0x14},{0x7195, 0xc1},
+	{0x7196, 0xd0},{0x7197, 0xd1},{0x7198, 0xac},{0x7199, 0x37},{0x719a, 0xbc},
+	{0x719b, 0x35},{0x719c, 0x36},{0x719d, 0x30},{0x719e, 0xe1},{0x719f, 0xd3},
+	{0x71a0, 0x7a},{0x71a1, 0xb6},{0x71a2, 0x0c},{0x71a3, 0xff},{0x71a4, 0xb4},
+	{0x71a5, 0xc7},{0x71a6, 0xd9},{0x71a7, 0x00},{0x71a8, 0xbd},{0x71a9, 0x01},
+	{0x71aa, 0x56},{0x71ab, 0xc0},{0x71ac, 0xda},{0x71ad, 0xb4},{0x71ae, 0x1f},
+	{0x71af, 0x56},{0x71b0, 0xaa},{0x71b1, 0xbc},{0x71b2, 0x08},{0x71b3, 0x00},
+	{0x71b4, 0x57},{0x71b5, 0xe8},{0x71b6, 0xb5},{0x71b7, 0x36},{0x71b8, 0x00},
+	{0x71b9, 0x54},{0x71ba, 0xe7},{0x71bb, 0xc8},{0x71bc, 0xb4},{0x71bd, 0x1f},
+	{0x71be, 0x56},{0x71bf, 0xaa},{0x71c0, 0xbc},{0x71c1, 0x08},{0x71c2, 0x57},
+	{0x71c3, 0x00},{0x71c4, 0xb5},{0x71c5, 0x36},{0x71c6, 0x00},{0x71c7, 0x54},
+	{0x71c8, 0xc8},{0x71c9, 0xb5},{0x71ca, 0x18},{0x71cb, 0xd9},{0x71cc, 0x00},
+	{0x71cd, 0xbd},{0x71ce, 0x01},{0x71cf, 0x56},{0x71d0, 0x08},{0x71d1, 0x57},
+	{0x71d2, 0xe8},{0x71d3, 0xb4},{0x71d4, 0x42},{0x71d5, 0x00},{0x71d6, 0x54},
+	{0x71d7, 0xe7},{0x71d8, 0xc8},{0x71d9, 0xab},{0x71da, 0x00},{0x71db, 0x66},
+	{0x71dc, 0x62},{0x71dd, 0x06},{0x71de, 0x74},{0x71df, 0xb9},{0x71e0, 0x05},
+	{0x71e1, 0xb7},{0x71e2, 0x14},{0x71e3, 0x0e},{0x71e4, 0xb7},{0x71e5, 0x04},
+	{0x71e6, 0xc8},{0x7600, 0x04},{0x7601, 0x80},{0x7602, 0x07},{0x7603, 0x44},
+	{0x7604, 0x05},{0x7605, 0x33},{0x7606, 0x0f},{0x7607, 0x00},{0x7608, 0x07},
+	{0x7609, 0x40},{0x760a, 0x04},{0x760b, 0xe5},{0x760c, 0x06},{0x760d, 0x50},
+	{0x760e, 0x04},{0x760f, 0xe4},{0x7610, 0x00},{0x7611, 0x00},{0x7612, 0x06},
+	{0x7613, 0x5c},{0x7614, 0x00},{0x7615, 0x0f},{0x7616, 0x06},{0x7617, 0x1c},
+	{0x7618, 0x00},{0x7619, 0x02},{0x761a, 0x06},{0x761b, 0xa2},{0x761c, 0x00},
+	{0x761d, 0x01},{0x761e, 0x06},{0x761f, 0xae},{0x7620, 0x00},{0x7621, 0x0e},
+	{0x7622, 0x05},{0x7623, 0x30},{0x7624, 0x07},{0x7625, 0x00},{0x7626, 0x0f},
+	{0x7627, 0x00},{0x7628, 0x04},{0x7629, 0xe5},{0x762a, 0x05},{0x762b, 0x33},
+	{0x762c, 0x06},{0x762d, 0x12},{0x762e, 0x00},{0x762f, 0x01},{0x7630, 0x06},
+	{0x7631, 0x52},{0x7632, 0x00},{0x7633, 0x01},{0x7634, 0x06},{0x7635, 0x5e},
+	{0x7636, 0x04},{0x7637, 0xe4},{0x7638, 0x00},{0x7639, 0x01},{0x763a, 0x05},
+	{0x763b, 0x30},{0x763c, 0x0f},{0x763d, 0x00},{0x763e, 0x06},{0x763f, 0xa6},
+	{0x7640, 0x00},{0x7641, 0x02},{0x7642, 0x06},{0x7643, 0x26},{0x7644, 0x00},
+	{0x7645, 0x02},{0x7646, 0x05},{0x7647, 0x33},{0x7648, 0x06},{0x7649, 0x20},
+	{0x764a, 0x0f},{0x764b, 0x00},{0x764c, 0x06},{0x764d, 0x56},{0x764e, 0x00},
+	{0x764f, 0x02},{0x7650, 0x06},{0x7651, 0x16},{0x7652, 0x05},{0x7653, 0x33},
+	{0x7654, 0x06},{0x7655, 0x10},{0x7656, 0x0f},{0x7657, 0x00},{0x7658, 0x06},
+	{0x7659, 0x10},{0x765a, 0x0f},{0x765b, 0x00},{0x765c, 0x06},{0x765d, 0x20},
+	{0x765e, 0x0f},{0x765f, 0x00},{0x7660, 0x00},{0x7661, 0x00},{0x7662, 0x00},
+	{0x7663, 0x02},{0x7664, 0x04},{0x7665, 0xe5},{0x7666, 0x04},{0x7667, 0xe4},
+	{0x7668, 0x0f},{0x7669, 0x00},{0x766a, 0x00},{0x766b, 0x00},{0x766c, 0x00},
+	{0x766d, 0x01},{0x766e, 0x04},{0x766f, 0xe5},{0x7670, 0x04},{0x7671, 0xe4},
+	{0x7672, 0x0f},{0x7673, 0x00},{0x7674, 0x00},{0x7675, 0x02},{0x7676, 0x04},
+	{0x7677, 0xe4},{0x7678, 0x00},{0x7679, 0x02},{0x767a, 0x04},{0x767b, 0xc4},
+	{0x767c, 0x00},{0x767d, 0x02},{0x767e, 0x04},{0x767f, 0xc4},{0x7680, 0x05},
+	{0x7681, 0x83},{0x7682, 0x0f},{0x7683, 0x00},{0x7684, 0x00},{0x7685, 0x02},
+	{0x7686, 0x04},{0x7687, 0xe4},{0x7688, 0x00},{0x7689, 0x02},{0x768a, 0x04},
+	{0x768b, 0xc4},{0x768c, 0x00},{0x768d, 0x02},{0x768e, 0x04},{0x768f, 0xc4},
+	{0x7690, 0x05},{0x7691, 0x83},{0x7692, 0x03},{0x7693, 0x0b},{0x7694, 0x05},
+	{0x7695, 0x83},{0x7696, 0x00},{0x7697, 0x07},{0x7698, 0x05},{0x7699, 0x03},
+	{0x769a, 0x00},{0x769b, 0x05},{0x769c, 0x05},{0x769d, 0x32},{0x769e, 0x05},
+	{0x769f, 0x30},{0x76a0, 0x00},{0x76a1, 0x02},{0x76a2, 0x05},{0x76a3, 0x78},
+	{0x76a4, 0x00},{0x76a5, 0x01},{0x76a6, 0x05},{0x76a7, 0x7c},{0x76a8, 0x03},
+	{0x76a9, 0x9a},{0x76aa, 0x05},{0x76ab, 0x83},{0x76ac, 0x00},{0x76ad, 0x04},
+	{0x76ae, 0x05},{0x76af, 0x03},{0x76b0, 0x00},{0x76b1, 0x03},{0x76b2, 0x05},
+	{0x76b3, 0x32},{0x76b4, 0x05},{0x76b5, 0x30},{0x76b6, 0x00},{0x76b7, 0x02},
+	{0x76b8, 0x05},{0x76b9, 0x78},{0x76ba, 0x00},{0x76bb, 0x01},{0x76bc, 0x05},
+	{0x76bd, 0x7c},{0x76be, 0x03},{0x76bf, 0x99},{0x76c0, 0x05},{0x76c1, 0x83},
+	{0x76c2, 0x00},{0x76c3, 0x03},{0x76c4, 0x05},{0x76c5, 0x03},{0x76c6, 0x00},
+	{0x76c7, 0x01},{0x76c8, 0x05},{0x76c9, 0x32},{0x76ca, 0x05},{0x76cb, 0x30},
+	{0x76cc, 0x00},{0x76cd, 0x02},{0x76ce, 0x05},{0x76cf, 0x78},{0x76d0, 0x00},
+	{0x76d1, 0x01},{0x76d2, 0x05},{0x76d3, 0x7c},{0x76d4, 0x03},{0x76d5, 0x98},
+	{0x76d6, 0x05},{0x76d7, 0x83},{0x76d8, 0x00},{0x76d9, 0x00},{0x76da, 0x05},
+	{0x76db, 0x03},{0x76dc, 0x00},{0x76dd, 0x01},{0x76de, 0x05},{0x76df, 0x32},
+	{0x76e0, 0x05},{0x76e1, 0x30},{0x76e2, 0x00},{0x76e3, 0x02},{0x76e4, 0x05},
+	{0x76e5, 0x78},{0x76e6, 0x00},{0x76e7, 0x01},{0x76e8, 0x05},{0x76e9, 0x7c},
+	{0x76ea, 0x03},{0x76eb, 0x97},{0x76ec, 0x05},{0x76ed, 0x83},{0x76ee, 0x00},
+	{0x76ef, 0x00},{0x76f0, 0x05},{0x76f1, 0x03},{0x76f2, 0x05},{0x76f3, 0x32},
+	{0x76f4, 0x05},{0x76f5, 0x30},{0x76f6, 0x00},{0x76f7, 0x02},{0x76f8, 0x05},
+	{0x76f9, 0x78},{0x76fa, 0x00},{0x76fb, 0x01},{0x76fc, 0x05},{0x76fd, 0x7c},
+	{0x76fe, 0x03},{0x76ff, 0x96},{0x7700, 0x05},{0x7701, 0x83},{0x7702, 0x05},
+	{0x7703, 0x03},{0x7704, 0x05},{0x7705, 0x32},{0x7706, 0x05},{0x7707, 0x30},
+	{0x7708, 0x00},{0x7709, 0x02},{0x770a, 0x05},{0x770b, 0x78},{0x770c, 0x00},
+	{0x770d, 0x01},{0x770e, 0x05},{0x770f, 0x7c},{0x7710, 0x03},{0x7711, 0x95},
+	{0x7712, 0x05},{0x7713, 0x83},{0x7714, 0x05},{0x7715, 0x03},{0x7716, 0x05},
+	{0x7717, 0x32},{0x7718, 0x05},{0x7719, 0x30},{0x771a, 0x00},{0x771b, 0x02},
+	{0x771c, 0x05},{0x771d, 0x78},{0x771e, 0x00},{0x771f, 0x01},{0x7720, 0x05},
+	{0x7721, 0x7c},{0x7722, 0x03},{0x7723, 0x94},{0x7724, 0x05},{0x7725, 0x83},
+	{0x7726, 0x00},{0x7727, 0x01},{0x7728, 0x05},{0x7729, 0x03},{0x772a, 0x00},
+	{0x772b, 0x01},{0x772c, 0x05},{0x772d, 0x32},{0x772e, 0x05},{0x772f, 0x30},
+	{0x7730, 0x00},{0x7731, 0x02},{0x7732, 0x05},{0x7733, 0x78},{0x7734, 0x00},
+	{0x7735, 0x01},{0x7736, 0x05},{0x7737, 0x7c},{0x7738, 0x03},{0x7739, 0x93},
+	{0x773a, 0x05},{0x773b, 0x83},{0x773c, 0x00},{0x773d, 0x00},{0x773e, 0x05},
+	{0x773f, 0x03},{0x7740, 0x00},{0x7741, 0x00},{0x7742, 0x05},{0x7743, 0x32},
+	{0x7744, 0x05},{0x7745, 0x30},{0x7746, 0x00},{0x7747, 0x02},{0x7748, 0x05},
+	{0x7749, 0x78},{0x774a, 0x00},{0x774b, 0x01},{0x774c, 0x05},{0x774d, 0x7c},
+	{0x774e, 0x03},{0x774f, 0x92},{0x7750, 0x05},{0x7751, 0x83},{0x7752, 0x05},
+	{0x7753, 0x03},{0x7754, 0x00},{0x7755, 0x00},{0x7756, 0x05},{0x7757, 0x32},
+	{0x7758, 0x05},{0x7759, 0x30},{0x775a, 0x00},{0x775b, 0x02},{0x775c, 0x05},
+	{0x775d, 0x78},{0x775e, 0x00},{0x775f, 0x01},{0x7760, 0x05},{0x7761, 0x7c},
+	{0x7762, 0x03},{0x7763, 0x91},{0x7764, 0x05},{0x7765, 0x83},{0x7766, 0x05},
+	{0x7767, 0x03},{0x7768, 0x05},{0x7769, 0x32},{0x776a, 0x05},{0x776b, 0x30},
+	{0x776c, 0x00},{0x776d, 0x02},{0x776e, 0x05},{0x776f, 0x78},{0x7770, 0x00},
+	{0x7771, 0x01},{0x7772, 0x05},{0x7773, 0x7c},{0x7774, 0x03},{0x7775, 0x90},
+	{0x7776, 0x05},{0x7777, 0x83},{0x7778, 0x05},{0x7779, 0x03},{0x777a, 0x05},
+	{0x777b, 0x32},{0x777c, 0x05},{0x777d, 0x30},{0x777e, 0x00},{0x777f, 0x02},
+	{0x7780, 0x05},{0x7781, 0x78},{0x7782, 0x00},{0x7783, 0x01},{0x7784, 0x05},
+	{0x7785, 0x7c},{0x7786, 0x02},{0x7787, 0x90},{0x7788, 0x05},{0x7789, 0x03},
+	{0x778a, 0x07},{0x778b, 0x00},{0x778c, 0x0f},{0x778d, 0x00},{0x778e, 0x08},
+	{0x778f, 0x30},{0x7790, 0x08},{0x7791, 0xee},{0x7792, 0x0f},{0x7793, 0x00},
+	{0x7794, 0x05},{0x7795, 0x33},{0x7796, 0x04},{0x7797, 0xe5},{0x7798, 0x06},
+	{0x7799, 0x52},{0x779a, 0x04},{0x779b, 0xe4},{0x779c, 0x00},{0x779d, 0x00},
+	{0x779e, 0x06},{0x779f, 0x5e},{0x77a0, 0x00},{0x77a1, 0x0f},{0x77a2, 0x06},
+	{0x77a3, 0x1e},{0x77a4, 0x00},{0x77a5, 0x02},{0x77a6, 0x06},{0x77a7, 0xa2},
+	{0x77a8, 0x00},{0x77a9, 0x01},{0x77aa, 0x06},{0x77ab, 0xae},{0x77ac, 0x00},
+	{0x77ad, 0x03},{0x77ae, 0x05},{0x77af, 0x30},{0x77b0, 0x09},{0x77b1, 0x19},
+	{0x77b2, 0x0f},{0x77b3, 0x00},{0x77b4, 0x05},{0x77b5, 0x33},{0x77b6, 0x04},
+	{0x77b7, 0xe5},{0x77b8, 0x06},{0x77b9, 0x52},{0x77ba, 0x04},{0x77bb, 0xe4},
+	{0x77bc, 0x00},{0x77bd, 0x00},{0x77be, 0x06},{0x77bf, 0x5e},{0x77c0, 0x00},
+	{0x77c1, 0x0f},{0x77c2, 0x06},{0x77c3, 0x1e},{0x77c4, 0x00},{0x77c5, 0x02},
+	{0x77c6, 0x06},{0x77c7, 0xa2},{0x77c8, 0x00},{0x77c9, 0x01},{0x77ca, 0x06},
+	{0x77cb, 0xae},{0x77cc, 0x00},{0x77cd, 0x03},{0x77ce, 0x05},{0x77cf, 0x30},
+	{0x77d0, 0x0f},{0x77d1, 0x00},{0x77d2, 0x00},{0x77d3, 0x00},{0x77d4, 0x00},
+	{0x77d5, 0x02},{0x77d6, 0x04},{0x77d7, 0xe5},{0x77d8, 0x04},{0x77d9, 0xe4},
+	{0x77da, 0x05},{0x77db, 0x33},{0x77dc, 0x07},{0x77dd, 0x10},{0x77de, 0x00},
+	{0x77df, 0x00},{0x77e0, 0x01},{0x77e1, 0xbb},{0x77e2, 0x00},{0x77e3, 0x00},
+	{0x77e4, 0x01},{0x77e5, 0xaa},{0x77e6, 0x00},{0x77e7, 0x00},{0x77e8, 0x01},
+	{0x77e9, 0x99},{0x77ea, 0x00},{0x77eb, 0x00},{0x77ec, 0x01},{0x77ed, 0x88},
+	{0x77ee, 0x00},{0x77ef, 0x00},{0x77f0, 0x01},{0x77f1, 0x77},{0x77f2, 0x00},
+	{0x77f3, 0x00},{0x77f4, 0x01},{0x77f5, 0x66},{0x77f6, 0x00},{0x77f7, 0x00},
+	{0x77f8, 0x01},{0x77f9, 0x55},{0x77fa, 0x00},{0x77fb, 0x00},{0x77fc, 0x01},
+	{0x77fd, 0x44},{0x77fe, 0x00},{0x77ff, 0x00},{0x7800, 0x01},{0x7801, 0x33},
+	{0x7802, 0x00},{0x7803, 0x00},{0x7804, 0x01},{0x7805, 0x22},{0x7806, 0x00},
+	{0x7807, 0x00},{0x7808, 0x01},{0x7809, 0x11},{0x780a, 0x00},{0x780b, 0x00},
+	{0x780c, 0x01},{0x780d, 0x00},{0x780e, 0x01},{0x780f, 0xff},{0x7810, 0x07},
+	{0x7811, 0x00},{0x7812, 0x02},{0x7813, 0xa0},{0x7814, 0x0f},{0x7815, 0x00},
+	{0x7816, 0x08},{0x7817, 0x35},{0x7818, 0x06},{0x7819, 0x52},{0x781a, 0x04},
+	{0x781b, 0xe4},{0x781c, 0x00},{0x781d, 0x00},{0x781e, 0x06},{0x781f, 0x5e},
+	{0x7820, 0x05},{0x7821, 0x33},{0x7822, 0x09},{0x7823, 0x19},{0x7824, 0x06},
+	{0x7825, 0x1e},{0x7826, 0x05},{0x7827, 0x33},{0x7828, 0x00},{0x7829, 0x01},
+	{0x782a, 0x06},{0x782b, 0x24},{0x782c, 0x06},{0x782d, 0x20},{0x782e, 0x0f},
+	{0x782f, 0x00},{0x7830, 0x08},{0x7831, 0x35},{0x7832, 0x07},{0x7833, 0x10},
+	{0x7834, 0x00},{0x7835, 0x00},{0x7836, 0x01},{0x7837, 0xbb},{0x7838, 0x00},
+	{0x7839, 0x00},{0x783a, 0x01},{0x783b, 0xaa},{0x783c, 0x00},{0x783d, 0x00},
+	{0x783e, 0x01},{0x783f, 0x99},{0x7840, 0x00},{0x7841, 0x00},{0x7842, 0x01},
+	{0x7843, 0x88},{0x7844, 0x00},{0x7845, 0x00},{0x7846, 0x01},{0x7847, 0x77},
+	{0x7848, 0x00},{0x7849, 0x00},{0x784a, 0x01},{0x784b, 0x66},{0x784c, 0x00},
+	{0x784d, 0x00},{0x784e, 0x01},{0x784f, 0x55},{0x7850, 0x00},{0x7851, 0x00},
+	{0x7852, 0x01},{0x7853, 0x44},{0x7854, 0x00},{0x7855, 0x00},{0x7856, 0x01},
+	{0x7857, 0x33},{0x7858, 0x00},{0x7859, 0x00},{0x785a, 0x01},{0x785b, 0x22},
+	{0x785c, 0x00},{0x785d, 0x00},{0x785e, 0x01},{0x785f, 0x11},{0x7860, 0x00},
+	{0x7861, 0x00},{0x7862, 0x01},{0x7863, 0x00},{0x7864, 0x07},{0x7865, 0x00},
+	{0x7866, 0x01},{0x7867, 0xff},{0x7868, 0x02},{0x7869, 0xa0},{0x786a, 0x0f},
+	{0x786b, 0x00},{0x786c, 0x08},{0x786d, 0x3a},{0x786e, 0x08},{0x786f, 0x6a},
+	{0x7870, 0x0f},{0x7871, 0x00},{0x7872, 0x04},{0x7873, 0xc0},{0x7874, 0x09},
+	{0x7875, 0x19},{0x7876, 0x04},{0x7877, 0x99},{0x7878, 0x07},{0x7879, 0x14},
+	{0x787a, 0x00},{0x787b, 0x01},{0x787c, 0x04},{0x787d, 0xa4},{0x787e, 0x00},
+	{0x787f, 0x07},{0x7880, 0x04},{0x7881, 0xa6},{0x7882, 0x00},{0x7883, 0x00},
+	{0x7884, 0x04},{0x7885, 0xa0},{0x7886, 0x04},{0x7887, 0x80},{0x7888, 0x04},
+	{0x7889, 0x00},{0x788a, 0x05},{0x788b, 0x03},{0x788c, 0x06},{0x788d, 0x00},
+	{0x788e, 0x0f},{0x788f, 0x00},{0x7890, 0x0f},{0x7891, 0x00},{0x7892, 0x0f},
+	{0x7893, 0x00},{0x30a0, 0x00},{0x30a1, 0x04},{0x30a2, 0x00},{0x30a3, 0x04},
+	{0x30a4, 0x07},{0x30a5, 0x8b},{0x30a6, 0x04},{0x30a7, 0x43},{0x30a8, 0x00},
+	{0x30a9, 0x04},{0x30aa, 0x00},{0x30ab, 0x04},{0x30ac, 0x07},{0x30ad, 0x80},
+	{0x30ae, 0x04},{0x30af, 0x38},{0x30b0, 0x0e},{0x30b1, 0x04},{0x30b2, 0x04},
+	{0x30b3, 0x58},{0x3196, 0x00},{0x3197, 0x0a},{0x3195, 0x29},{0x315a, 0x01},
+	{0x315b, 0x80},{0x30bb, 0x01},{0x33e2, 0x02},{0x33e3, 0x01},{0x33e4, 0x01},
+	{0x33e5, 0x01},{0x33e8, 0x0c},{0x33e9, 0x02},{0x33ea, 0x02},{0x33eb, 0x02},
+	{0x33ec, 0x03},{0x33ed, 0x01},{0x33ee, 0x02},{0x33ef, 0x08},{0x33f7, 0x02},
+	{0x33f8, 0x01},{0x33f9, 0x01},{0x33fa, 0x01},{0x33fd, 0x0c},{0x33fe, 0x02},
+	{0x33ff, 0x02},{0x3400, 0x02},{0x3401, 0x03},{0x3402, 0x01},{0x3403, 0x02},
+	{0x3404, 0x08},{0x3250, 0xf7},
+
+	/* mirror on */
+	{0x30c0, 0x04},{0x30a9, 0x05},{0x3252, 0x21},
+
+	{0x3012, 0x01},
+};
+
+static struct vin_reg_16_8 ov2718_dual_gain_hdr_regs[] = {
+	/* MIPI 1928x1088 2x12bits HCG + LCG 30fps 600Mbps no virtual channel v1.2 */
+	{0x3013, 0x01},{0x3000, 0x05},{0x3001, 0x64},{0x3002, 0x07},{0x3003, 0x01},
+	{0x3004, 0x06},{0x3005, 0x49},{0x3006, 0x00},{0x3007, 0x07},{0x3008, 0x01},
+	{0x3009, 0x00},{0x300c, 0x6c},{0x300d, 0xe1},{0x300e, 0x80},{0x300f, 0x00},
+	{0x3012, 0x00},{0x3013, 0x00},{0x3014, 0x84},{0x3015, 0x00},{0x3017, 0x00},
+	{0x3018, 0x00},{0x3019, 0x00},{0x301a, 0x00},{0x301b, 0x01},{0x301e, 0x10},
+	{0x301f, 0x5f},{0x3030, 0x0a},{0x3031, 0x63},{0x3032, 0xf0},{0x3033, 0x30},
+	{0x3034, 0x34},{0x3035, 0x51},{0x3036, 0x02},{0x3037, 0x9f},{0x3038, 0x04},
+	{0x3039, 0xb7},{0x303a, 0x04},{0x303b, 0x07},{0x303c, 0xf0},{0x303d, 0x00},
+	{0x303e, 0x0b},{0x303f, 0xe3},{0x3040, 0xf3},{0x3041, 0x29},{0x3042, 0xf6},
+	{0x3043, 0x65},{0x3044, 0x06},{0x3045, 0x0f},{0x3046, 0x55},{0x3047, 0xf7},
+	{0x3048, 0x31},{0x3049, 0x0f},{0x304a, 0x10},{0x304b, 0xc0},{0x304c, 0x33},
+	{0x304d, 0x24},{0x304e, 0x0b},{0x304f, 0x3d},{0x3050, 0x10},{0x3060, 0x00},
+	{0x3061, 0x64},{0x3062, 0x01},{0x3063, 0x00},{0x3064, 0x0b},{0x3065, 0xf8},
+	{0x3066, 0x80},{0x3080, 0x00},{0x3081, 0x00},{0x3082, 0x01},{0x3083, 0xe3},
+	{0x3084, 0x05},{0x3085, 0x00},{0x3086, 0x10},{0x3087, 0x10},{0x3089, 0x00},
+	{0x308a, 0x01},{0x3093, 0x00},{0x30a0, 0x00},{0x30a1, 0x00},{0x30a2, 0x00},
+	{0x30a3, 0x00},{0x30a4, 0x07},{0x30a5, 0x8f},{0x30a6, 0x04},{0x30a7, 0x47},
+	{0x30a8, 0x00},{0x30a9, 0x00},{0x30aa, 0x00},{0x30ab, 0x00},{0x30ac, 0x07},
+	{0x30ad, 0x90},{0x30ae, 0x04},{0x30af, 0x48},{0x30b0, 0x08},{0x30b1, 0xae},
+	{0x30b2, 0x04},{0x30b3, 0x65},{0x30b4, 0x00},{0x30b5, 0x00},{0x30b6, 0x00},
+	{0x30b7, 0x10},{0x30b8, 0x00},{0x30b9, 0x02},{0x30ba, 0x10},{0x30bb, 0x00},
+	{0x30bc, 0x00},{0x30bd, 0x03},{0x30be, 0x5c},{0x30bf, 0x00},{0x30c0, 0x00},
+	{0x30c1, 0x00},{0x30c2, 0x20},{0x30c3, 0x00},{0x30c4, 0x4a},{0x30c5, 0x00},
+	{0x30c7, 0x00},{0x30c8, 0x00},{0x30d1, 0x00},{0x30d2, 0x00},{0x30d3, 0x80},
+	{0x30d4, 0x00},{0x30d9, 0x09},{0x30da, 0x64},{0x30dd, 0x00},{0x30de, 0x16},
+	{0x30df, 0x00},{0x30e0, 0x17},{0x30e1, 0x00},{0x30e2, 0x18},{0x30e3, 0x10},
+	{0x30e4, 0x04},{0x30e5, 0x00},{0x30e6, 0x00},{0x30e7, 0x00},{0x30e8, 0x00},
+	{0x30e9, 0x00},{0x30ea, 0x00},{0x30eb, 0x00},{0x30ec, 0x00},{0x30ed, 0x00},
+	{0x3101, 0x00},{0x3102, 0x00},{0x3103, 0x00},{0x3104, 0x00},{0x3105, 0x6c},
+	{0x3106, 0x83},{0x3107, 0x72},{0x3108, 0x70},{0x3109, 0x6c},{0x310a, 0x83},
+	{0x310b, 0x69},{0x310c, 0x43},{0x310d, 0x42},{0x310e, 0x00},{0x3120, 0x00},
+	{0x3121, 0x00},{0x3122, 0x00},{0x3123, 0xf0},{0x3124, 0x00},{0x3125, 0xa0},
+	{0x3126, 0x3f},{0x3127, 0x0f},{0x3128, 0x00},{0x3129, 0x3a},{0x312a, 0x02},
+	{0x312b, 0x0f},{0x312c, 0x00},{0x312d, 0x0f},{0x312e, 0x1d},{0x312f, 0x00},
+	{0x3130, 0x00},{0x3131, 0x00},{0x3132, 0x00},{0x3140, 0x02},{0x3141, 0x07},
+	{0x3142, 0x00},{0x3143, 0x00},{0x3144, 0x00},{0x3145, 0x00},{0x3146, 0x00},
+	{0x3147, 0x00},{0x3148, 0x00},{0x3149, 0x00},{0x314a, 0x00},{0x314b, 0x00},
+	{0x314c, 0x00},{0x314d, 0x00},{0x314e, 0x1c},{0x314f, 0x10},{0x3150, 0x10},
+	{0x3151, 0x10},{0x3152, 0x80},{0x3153, 0x80},{0x3154, 0x80},{0x3155, 0x00},
+	{0x3156, 0x01},{0x3157, 0x00},{0x3158, 0x0f},{0x3159, 0xff},{0x315a, 0x02},
+	{0x315b, 0x00},{0x315c, 0x02},{0x315d, 0x86},{0x315e, 0x01},{0x315f, 0x00},
+	{0x3160, 0x00},{0x3161, 0x40},{0x3162, 0x00},{0x3163, 0x40},{0x3164, 0x00},
+	{0x3165, 0x40},{0x3190, 0x01},{0x3191, 0xc9},{0x3193, 0x08},{0x3194, 0x13},
+	{0x3195, 0x33},{0x3196, 0x00},{0x3197, 0x10},{0x3198, 0x00},{0x3199, 0x3f},
+	{0x319a, 0x40},{0x319b, 0x7f},{0x319c, 0x80},{0x319d, 0xbf},{0x319e, 0xc0},
+	{0x319f, 0xff},{0x31a0, 0x00},{0x31a1, 0x55},{0x31a2, 0x00},{0x31a3, 0x00},
+	{0x31a6, 0x00},{0x31a7, 0x00},{0x31b0, 0x00},{0x31b1, 0x00},{0x31b2, 0x02},
+	{0x31b3, 0x00},{0x31b4, 0x00},{0x31b5, 0x01},{0x31b6, 0x00},{0x31b7, 0x00},
+	{0x31b8, 0x00},{0x31b9, 0x00},{0x31ba, 0x00},{0x31d0, 0x3c},{0x31d1, 0x34},
+	{0x31d2, 0x3c},{0x31d3, 0x00},{0x31d4, 0x2d},{0x31d5, 0x00},{0x31d6, 0x01},
+	{0x31d7, 0x06},{0x31d8, 0x00},{0x31d9, 0x64},{0x31da, 0x00},{0x31db, 0x28},
+	{0x31dc, 0x04},{0x31dd, 0x69},{0x31de, 0x0a},{0x31df, 0x3c},{0x31e0, 0x04},
+	{0x31e1, 0x32},{0x31e2, 0x00},{0x31e3, 0x01},{0x31e4, 0x0d},{0x31e5, 0x80},
+	{0x31e6, 0x00},{0x31e7, 0x2c},{0x31e8, 0x6c},{0x31e9, 0xac},{0x31ea, 0xec},
+	{0x31eb, 0x3f},{0x31ec, 0x0f},{0x31ed, 0x20},{0x31ee, 0x04},{0x31ef, 0x48},
+	{0x31f0, 0x07},{0x31f1, 0x90},{0x31f2, 0x04},{0x31f3, 0x48},{0x31f4, 0x07},
+	{0x31f5, 0x90},{0x31f6, 0x04},{0x31f7, 0x48},{0x31f8, 0x07},{0x31f9, 0x90},
+	{0x31fa, 0x04},{0x31fb, 0x48},{0x31fd, 0xcb},{0x31fe, 0x0f},{0x31ff, 0x03},
+	{0x3200, 0x00},{0x3201, 0xff},{0x3202, 0x00},{0x3203, 0xff},{0x3204, 0xff},
+	{0x3205, 0xff},{0x3206, 0xff},{0x3207, 0xff},{0x3208, 0xff},{0x3209, 0xff},
+	{0x320a, 0xff},{0x320b, 0x1b},{0x320c, 0x1f},{0x320d, 0x1e},{0x320e, 0x30},
+	{0x320f, 0x2d},{0x3210, 0x2c},{0x3211, 0x2b},{0x3212, 0x2a},{0x3213, 0x24},
+	{0x3214, 0x22},{0x3215, 0x00},{0x3216, 0x04},{0x3217, 0x2c},{0x3218, 0x6c},
+	{0x3219, 0xac},{0x321a, 0xec},{0x321b, 0x00},{0x3230, 0x3a},{0x3231, 0x00},
+	{0x3232, 0x80},{0x3233, 0x00},{0x3234, 0x10},{0x3235, 0xaa},{0x3236, 0x55},
+	{0x3237, 0x99},{0x3238, 0x66},{0x3239, 0x08},{0x323a, 0x88},{0x323b, 0x00},
+	{0x323c, 0x00},{0x323d, 0x03},{0x3250, 0x33},{0x3251, 0x00},{0x3252, 0x20},
+	{0x3253, 0x00},{0x3254, 0x11},{0x3255, 0x01},{0x3256, 0x00},{0x3257, 0x00},
+	{0x3258, 0x00},{0x3270, 0x01},{0x3271, 0x60},{0x3272, 0xc0},{0x3273, 0x00},
+	{0x3274, 0x80},{0x3275, 0x40},{0x3276, 0x02},{0x3277, 0x08},{0x3278, 0x10},
+	{0x3279, 0x04},{0x327a, 0x00},{0x327b, 0x03},{0x327c, 0x10},{0x327d, 0x60},
+	{0x327e, 0xc0},{0x327f, 0x06},{0x3288, 0x10},{0x3289, 0x00},{0x328a, 0x08},
+	{0x328b, 0x00},{0x328c, 0x04},{0x328d, 0x00},{0x328e, 0x02},{0x328f, 0x00},
+	{0x3290, 0x20},{0x3291, 0x00},{0x3292, 0x10},{0x3293, 0x00},{0x3294, 0x08},
+	{0x3295, 0x00},{0x3296, 0x04},{0x3297, 0x00},{0x3298, 0x40},{0x3299, 0x00},
+	{0x329a, 0x20},{0x329b, 0x00},{0x329c, 0x10},{0x329d, 0x00},{0x329e, 0x08},
+	{0x329f, 0x00},{0x32a0, 0x7f},{0x32a1, 0xff},{0x32a2, 0x40},{0x32a3, 0x00},
+	{0x32a4, 0x20},{0x32a5, 0x00},{0x32a6, 0x10},{0x32a7, 0x00},{0x32a8, 0x00},
+	{0x32a9, 0x00},{0x32aa, 0x00},{0x32ab, 0x00},{0x32ac, 0x00},{0x32ad, 0x00},
+	{0x32ae, 0x00},{0x32af, 0x00},{0x32b0, 0x00},{0x32b1, 0x00},{0x32b2, 0x00},
+	{0x32b3, 0x00},{0x32b4, 0x00},{0x32b5, 0x00},{0x32b6, 0x00},{0x32b7, 0x00},
+	{0x32b8, 0x00},{0x32b9, 0x00},{0x32ba, 0x00},{0x32bb, 0x00},{0x32bc, 0x00},
+	{0x32bd, 0x00},{0x32be, 0x00},{0x32bf, 0x00},{0x32c0, 0x00},{0x32c1, 0x00},
+	{0x32c2, 0x00},{0x32c3, 0x00},{0x32c4, 0x00},{0x32c5, 0x00},{0x32c6, 0x00},
+	{0x32c7, 0x00},{0x32c8, 0x87},{0x32c9, 0x00},{0x3330, 0x03},{0x3331, 0xc8},
+	{0x3332, 0x02},{0x3333, 0x24},{0x3334, 0x00},{0x3335, 0x00},{0x3336, 0x00},
+	{0x3337, 0x00},{0x3338, 0x03},{0x3339, 0xc8},{0x333a, 0x02},{0x333b, 0x24},
+	{0x333c, 0x00},{0x333d, 0x00},{0x333e, 0x00},{0x333f, 0x00},{0x3340, 0x03},
+	{0x3341, 0xc8},{0x3342, 0x02},{0x3343, 0x24},{0x3344, 0x00},{0x3345, 0x00},
+	{0x3346, 0x00},{0x3347, 0x00},{0x3348, 0x40},{0x3349, 0x00},{0x334a, 0x00},
+	{0x334b, 0x00},{0x334c, 0x00},{0x334d, 0x00},{0x334e, 0x80},{0x3360, 0x01},
+	{0x3361, 0x00},{0x3362, 0x01},{0x3363, 0x00},{0x3364, 0x01},{0x3365, 0x00},
+	{0x3366, 0x01},{0x3367, 0x00},{0x3368, 0x01},{0x3369, 0x00},{0x336a, 0x01},
+	{0x336b, 0x00},{0x336c, 0x01},{0x336d, 0x00},{0x336e, 0x01},{0x336f, 0x00},
+	{0x3370, 0x01},{0x3371, 0x00},{0x3372, 0x01},{0x3373, 0x00},{0x3374, 0x01},
+	{0x3375, 0x00},{0x3376, 0x01},{0x3377, 0x00},{0x3378, 0x00},{0x3379, 0x00},
+	{0x337a, 0x00},{0x337b, 0x00},{0x337c, 0x00},{0x337d, 0x00},{0x337e, 0x00},
+	{0x337f, 0x00},{0x3380, 0x00},{0x3381, 0x00},{0x3382, 0x00},{0x3383, 0x00},
+	{0x3384, 0x00},{0x3385, 0x00},{0x3386, 0x00},{0x3387, 0x00},{0x3388, 0x00},
+	{0x3389, 0x00},{0x338a, 0x00},{0x338b, 0x00},{0x338c, 0x00},{0x338d, 0x00},
+	{0x338e, 0x00},{0x338f, 0x00},{0x3390, 0x00},{0x3391, 0x00},{0x3392, 0x00},
+	{0x3393, 0x00},{0x3394, 0x00},{0x3395, 0x00},{0x3396, 0x00},{0x3397, 0x00},
+	{0x3398, 0x00},{0x3399, 0x00},{0x339a, 0x00},{0x339b, 0x00},{0x33b0, 0x00},
+	{0x33b1, 0x50},{0x33b2, 0x01},{0x33b3, 0xff},{0x33b4, 0xe0},{0x33b5, 0x6b},
+	{0x33b6, 0x00},{0x33b7, 0x00},{0x33b8, 0x00},{0x33b9, 0x00},{0x33ba, 0x00},
+	{0x33bb, 0x1f},{0x33bc, 0x01},{0x33bd, 0x01},{0x33be, 0x01},{0x33bf, 0x01},
+	{0x33c0, 0x00},{0x33c1, 0x00},{0x33c2, 0x00},{0x33c3, 0x00},{0x33e0, 0x14},
+	{0x33e1, 0x0f},{0x33e2, 0x04},{0x33e3, 0x02},{0x33e4, 0x01},{0x33e5, 0x01},
+	{0x33e6, 0x00},{0x33e7, 0x04},{0x33e8, 0x0c},{0x33e9, 0x00},{0x33ea, 0x01},
+	{0x33eb, 0x02},{0x33ec, 0x03},{0x33ed, 0x03},{0x33ee, 0x0f},{0x33ef, 0x3f},
+	{0x33f0, 0x08},{0x33f1, 0x04},{0x33f2, 0x04},{0x33f3, 0x00},{0x33f4, 0x03},
+	{0x33f5, 0x14},{0x33f6, 0x0f},{0x33f7, 0x04},{0x33f8, 0x02},{0x33f9, 0x01},
+	{0x33fa, 0x01},{0x33fb, 0x00},{0x33fc, 0x04},{0x33fd, 0x0c},{0x33fe, 0x00},
+	{0x33ff, 0x01},{0x3400, 0x02},{0x3401, 0x03},{0x3402, 0x03},{0x3403, 0x0f},
+	{0x3404, 0x3f},{0x3405, 0x08},{0x3406, 0x04},{0x3407, 0x04},{0x3408, 0x00},
+	{0x3409, 0x03},{0x340a, 0x14},{0x340b, 0x0f},{0x340c, 0x04},{0x340d, 0x02},
+	{0x340e, 0x01},{0x340f, 0x01},{0x3410, 0x00},{0x3411, 0x04},{0x3412, 0x0c},
+	{0x3413, 0x00},{0x3414, 0x01},{0x3415, 0x02},{0x3416, 0x03},{0x3417, 0x03},
+	{0x3418, 0x0f},{0x3419, 0x3f},{0x341a, 0x08},{0x341b, 0x04},{0x341c, 0x04},
+	{0x341d, 0x00},{0x341e, 0x03},{0x3440, 0x00},{0x3441, 0x00},{0x3442, 0x00},
+	{0x3443, 0x00},{0x3444, 0x02},{0x3445, 0xf0},{0x3446, 0x02},{0x3447, 0x08},
+	{0x3448, 0x00},{0x3460, 0x40},{0x3461, 0x40},{0x3462, 0x40},{0x3463, 0x40},
+	{0x3464, 0x03},{0x3465, 0x01},{0x3466, 0x01},{0x3467, 0x02},{0x3468, 0x30},
+	{0x3469, 0x00},{0x346a, 0x35},{0x346b, 0x00},{0x3480, 0x40},{0x3481, 0x00},
+	{0x3482, 0x00},{0x3483, 0x00},{0x3484, 0x07},{0x3485, 0x00},{0x3486, 0x00},
+	{0x3487, 0x00},{0x3488, 0x00},{0x3489, 0x00},{0x348a, 0x00},{0x348b, 0x04},
+	{0x348c, 0x00},{0x348d, 0x01},{0x348f, 0x01},{0x7000, 0xda},{0x7001, 0xcf},
+	{0x7002, 0xac},{0x7003, 0xd0},{0x7004, 0xac},{0x7005, 0xd1},{0x7006, 0x50},
+	{0x7007, 0xb6},{0x7008, 0xee},{0x7009, 0xac},{0x700a, 0xd2},{0x700b, 0xdc},
+	{0x700c, 0xdf},{0x700d, 0x0f},{0x700e, 0xe1},{0x700f, 0x36},{0x7010, 0x30},
+	{0x7011, 0xd3},{0x7012, 0x2e},{0x7013, 0x54},{0x7014, 0x46},{0x7015, 0xb4},
+	{0x7016, 0x00},{0x7017, 0x1a},{0x7018, 0xc1},{0x7019, 0x0e},{0x701a, 0xe8},
+	{0x701b, 0x00},{0x701c, 0xe6},{0x701d, 0xb0},{0x701e, 0x6e},{0x701f, 0xbd},
+	{0x7020, 0x01},{0x7021, 0xd7},{0x7022, 0xed},{0x7023, 0xbc},{0x7024, 0x22},
+	{0x7025, 0xb9},{0x7026, 0x66},{0x7027, 0x2c},{0x7028, 0x28},{0x7029, 0x19},
+	{0x702a, 0xc1},{0x702b, 0x32},{0x702c, 0xa1},{0x702d, 0xac},{0x702e, 0xd8},
+	{0x702f, 0xd6},{0x7030, 0xb4},{0x7031, 0x04},{0x7032, 0x46},{0x7033, 0xb7},
+	{0x7034, 0x00},{0x7035, 0xbe},{0x7036, 0x08},{0x7037, 0xc3},{0x7038, 0xdb},
+	{0x7039, 0xad},{0x703a, 0xc3},{0x703b, 0xbf},{0x703c, 0x50},{0x703d, 0x20},
+	{0x703e, 0xb8},{0x703f, 0x02},{0x7040, 0xbc},{0x7041, 0x17},{0x7042, 0xdb},
+	{0x7043, 0xa0},{0x7044, 0xb8},{0x7045, 0x00},{0x7046, 0x28},{0x7047, 0x54},
+	{0x7048, 0xb4},{0x7049, 0xbc},{0x704a, 0xbe},{0x704b, 0x06},{0x704c, 0xd8},
+	{0x704d, 0xd6},{0x704e, 0x00},{0x704f, 0xb9},{0x7050, 0x64},{0x7051, 0xee},
+	{0x7052, 0xe8},{0x7053, 0xb4},{0x7054, 0x14},{0x7055, 0xab},{0x7056, 0xbc},
+	{0x7057, 0x17},{0x7058, 0x62},{0x7059, 0x07},{0x705a, 0xb9},{0x705b, 0x05},
+	{0x705c, 0xad},{0x705d, 0xb4},{0x705e, 0x25},{0x705f, 0xc3},{0x7060, 0xc1},
+	{0x7061, 0x00},{0x7062, 0xc0},{0x7063, 0x42},{0x7064, 0x50},{0x7065, 0x20},
+	{0x7066, 0x04},{0x7067, 0xb8},{0x7068, 0x02},{0x7069, 0xdb},{0x706a, 0xd8},
+	{0x706b, 0xac},{0x706c, 0xb7},{0x706d, 0x00},{0x706e, 0xbc},{0x706f, 0x11},
+	{0x7070, 0xd6},{0x7071, 0xc7},{0x7072, 0xb8},{0x7073, 0x00},{0x7074, 0x28},
+	{0x7075, 0x54},{0x7076, 0xb4},{0x7077, 0x04},{0x7078, 0x46},{0x7079, 0xbe},
+	{0x707a, 0x06},{0x707b, 0xc3},{0x707c, 0xdb},{0x707d, 0xbd},{0x707e, 0x03},
+	{0x707f, 0xee},{0x7080, 0xad},{0x7081, 0xc3},{0x7082, 0xbf},{0x7083, 0x00},
+	{0x7084, 0xec},{0x7085, 0x00},{0x7086, 0x15},{0x7087, 0xc2},{0x7088, 0x47},
+	{0x7089, 0xc3},{0x708a, 0xb7},{0x708b, 0xc0},{0x708c, 0x43},{0x708d, 0x00},
+	{0x708e, 0x00},{0x708f, 0x00},{0x7090, 0xb9},{0x7091, 0x64},{0x7092, 0x29},
+	{0x7093, 0x00},{0x7094, 0xb8},{0x7095, 0x12},{0x7096, 0xbe},{0x7097, 0x01},
+	{0x7098, 0xd0},{0x7099, 0xbc},{0x709a, 0x01},{0x709b, 0xac},{0x709c, 0x37},
+	{0x709d, 0xd1},{0x709e, 0xac},{0x709f, 0xd2},{0x70a0, 0xac},{0x70a1, 0xad},
+	{0x70a2, 0x28},{0x70a3, 0x00},{0x70a4, 0xb8},{0x70a5, 0x00},{0x70a6, 0xbc},
+	{0x70a7, 0x01},{0x70a8, 0xe1},{0x70a9, 0x36},{0x70aa, 0xd3},{0x70ab, 0x30},
+	{0x70ac, 0x04},{0x70ad, 0xe0},{0x70ae, 0xd8},{0x70af, 0xb4},{0x70b0, 0xcd},
+	{0x70b1, 0x45},{0x70b2, 0x00},{0x70b3, 0xe8},{0x70b4, 0xbe},{0x70b5, 0x05},
+	{0x70b6, 0xbc},{0x70b7, 0x1e},{0x70b8, 0x62},{0x70b9, 0x07},{0x70ba, 0xb9},
+	{0x70bb, 0x05},{0x70bc, 0xad},{0x70bd, 0xc3},{0x70be, 0xd2},{0x70bf, 0x00},
+	{0x70c0, 0x15},{0x70c1, 0xc2},{0x70c2, 0x64},{0x70c3, 0xc3},{0x70c4, 0xcd},
+	{0x70c5, 0xc0},{0x70c6, 0x60},{0x70c7, 0x00},{0x70c8, 0x46},{0x70c9, 0x00},
+	{0x70ca, 0x00},{0x70cb, 0x19},{0x70cc, 0xc1},{0x70cd, 0x7e},{0x70ce, 0xa1},
+	{0x70cf, 0xb9},{0x70d0, 0x64},{0x70d1, 0x29},{0x70d2, 0x00},{0x70d3, 0xb8},
+	{0x70d4, 0x02},{0x70d5, 0xbe},{0x70d6, 0x02},{0x70d7, 0xd0},{0x70d8, 0xdc},
+	{0x70d9, 0xac},{0x70da, 0xbc},{0x70db, 0x01},{0x70dc, 0x37},{0x70dd, 0xd1},
+	{0x70de, 0xac},{0x70df, 0xd2},{0x70e0, 0xad},{0x70e1, 0x28},{0x70e2, 0x00},
+	{0x70e3, 0xb8},{0x70e4, 0x00},{0x70e5, 0xbc},{0x70e6, 0x01},{0x70e7, 0xe1},
+	{0x70e8, 0x36},{0x70e9, 0x30},{0x70ea, 0xe0},{0x70eb, 0xd8},{0x70ec, 0xb5},
+	{0x70ed, 0x06},{0x70ee, 0x45},{0x70ef, 0xd6},{0x70f0, 0xbe},{0x70f1, 0x07},
+	{0x70f2, 0x00},{0x70f3, 0xe8},{0x70f4, 0x62},{0x70f5, 0x07},{0x70f6, 0xb9},
+	{0x70f7, 0x05},{0x70f8, 0xad},{0x70f9, 0xc3},{0x70fa, 0xd2},{0x70fb, 0x46},
+	{0x70fc, 0xd5},{0x70fd, 0xe3},{0x70fe, 0x18},{0x70ff, 0xc2},{0x7100, 0xae},
+	{0x7101, 0xb9},{0x7102, 0x64},{0x7103, 0xd1},{0x7104, 0x50},{0x7105, 0xdd},
+	{0x7106, 0xac},{0x7107, 0xcf},{0x7108, 0xdf},{0x7109, 0xb6},{0x710a, 0xee},
+	{0x710b, 0xbc},{0x710c, 0x13},{0x710d, 0xe1},{0x710e, 0x36},{0x710f, 0x30},
+	{0x7110, 0xd3},{0x7111, 0x2e},{0x7112, 0x54},{0x7113, 0xbc},{0x7114, 0x32},
+	{0x7115, 0x2c},{0x7116, 0x50},{0x7117, 0x20},{0x7118, 0x04},{0x7119, 0xb8},
+	{0x711a, 0x02},{0x711b, 0xbc},{0x711c, 0x18},{0x711d, 0xc7},{0x711e, 0xb8},
+	{0x711f, 0x00},{0x7120, 0x28},{0x7121, 0x54},{0x7122, 0xb4},{0x7123, 0xbf},
+	{0x7124, 0x46},{0x7125, 0xbe},{0x7126, 0x04},{0x7127, 0xd6},{0x7128, 0xd8},
+	{0x7129, 0xab},{0x712a, 0x00},{0x712b, 0xe8},{0x712c, 0x62},{0x712d, 0x07},
+	{0x712e, 0xb9},{0x712f, 0x05},{0x7130, 0xad},{0x7131, 0xc3},{0x7132, 0xbf},
+	{0x7133, 0xb9},{0x7134, 0x64},{0x7135, 0x29},{0x7136, 0x00},{0x7137, 0xb8},
+	{0x7138, 0x02},{0x7139, 0xbe},{0x713a, 0x00},{0x713b, 0xe6},{0x713c, 0xbd},
+	{0x713d, 0x03},{0x713e, 0xec},{0x713f, 0xad},{0x7140, 0xe2},{0x7141, 0x28},
+	{0x7142, 0x00},{0x7143, 0xb8},{0x7144, 0x00},{0x7145, 0xe0},{0x7146, 0xd8},
+	{0x7147, 0xb4},{0x7148, 0xcd},{0x7149, 0x45},{0x714a, 0xbe},{0x714b, 0x03},
+	{0x714c, 0x00},{0x714d, 0x30},{0x714e, 0xe8},{0x714f, 0xbc},{0x7150, 0x1c},
+	{0x7151, 0x62},{0x7152, 0x07},{0x7153, 0xb9},{0x7154, 0x05},{0x7155, 0xad},
+	{0x7156, 0xc3},{0x7157, 0xd2},{0x7158, 0x46},{0x7159, 0xe4},{0x715a, 0xd5},
+	{0x715b, 0x00},{0x715c, 0x17},{0x715d, 0xc2},{0x715e, 0xc6},{0x715f, 0xde},
+	{0x7160, 0xcf},{0x7161, 0xdf},{0x7162, 0xac},{0x7163, 0xd1},{0x7164, 0x44},
+	{0x7165, 0xac},{0x7166, 0xb9},{0x7167, 0x76},{0x7168, 0xb8},{0x7169, 0x08},
+	{0x716a, 0xb6},{0x716b, 0xfe},{0x716c, 0xb4},{0x716d, 0xbf},{0x716e, 0xd6},
+	{0x716f, 0xd8},{0x7170, 0xab},{0x7171, 0xe8},{0x7172, 0x00},{0x7173, 0xe1},
+	{0x7174, 0x36},{0x7175, 0x30},{0x7176, 0xd3},{0x7177, 0xbc},{0x7178, 0x5e},
+	{0x7179, 0xb4},{0x717a, 0x1d},{0x717b, 0xaa},{0x717c, 0xb8},{0x717d, 0x0c},
+	{0x717e, 0x45},{0x717f, 0xe6},{0x7180, 0xbd},{0x7181, 0x03},{0x7182, 0xec},
+	{0x7183, 0xbc},{0x7184, 0x7d},{0x7185, 0xc3},{0x7186, 0xd2},{0x7187, 0x42},
+	{0x7188, 0xb8},{0x7189, 0x00},{0x718a, 0xe4},{0x718b, 0xd5},{0x718c, 0xb6},
+	{0x718d, 0x00},{0x718e, 0xb9},{0x718f, 0x0a},{0x7190, 0xbd},{0x7191, 0x03},
+	{0x7192, 0xb5},{0x7193, 0x4b},{0x7194, 0x40},{0x7195, 0x58},{0x7196, 0x76},
+	{0x7197, 0x01},{0x7198, 0x6a},{0x7199, 0xdd},{0x719a, 0x1a},{0x719b, 0xc2},
+	{0x719c, 0xd1},{0x719d, 0xe8},{0x719e, 0xbd},{0x719f, 0x03},{0x71a0, 0xe6},
+	{0x71a1, 0xec},{0x71a2, 0xbc},{0x71a3, 0x19},{0x71a4, 0xb9},{0x71a5, 0xf6},
+	{0x71a6, 0x14},{0x71a7, 0xc1},{0x71a8, 0xda},{0x71a9, 0xd1},{0x71aa, 0xac},
+	{0x71ab, 0x37},{0x71ac, 0xbc},{0x71ad, 0x35},{0x71ae, 0x36},{0x71af, 0x30},
+	{0x71b0, 0xe1},{0x71b1, 0xd3},{0x71b2, 0xc0},{0x71b3, 0xd3},{0x71b4, 0xb6},
+	{0x71b5, 0x0c},{0x71b6, 0xff},{0x71b7, 0xb4},{0x71b8, 0xbc},{0x71b9, 0xd9},
+	{0x71ba, 0x00},{0x71bb, 0xe8},{0x71bc, 0x56},{0x71bd, 0xc0},{0x71be, 0xe3},
+	{0x71bf, 0xb4},{0x71c0, 0x1d},{0x71c1, 0x56},{0x71c2, 0xaa},{0x71c3, 0xbc},
+	{0x71c4, 0x1a},{0x71c5, 0x00},{0x71c6, 0xb5},{0x71c7, 0x48},{0x71c8, 0x57},
+	{0x71c9, 0x00},{0x71ca, 0x54},{0x71cb, 0xe7},{0x71cc, 0xc8},{0x71cd, 0xb5},
+	{0x71ce, 0x13},{0x71cf, 0xd9},{0x71d0, 0x00},{0x71d1, 0xe8},{0x71d2, 0x56},
+	{0x71d3, 0x08},{0x71d4, 0xb4},{0x71d5, 0x44},{0x71d6, 0x57},{0x71d7, 0x00},
+	{0x71d8, 0x54},{0x71d9, 0xe7},{0x71da, 0xc8},{0x71db, 0xab},{0x71dc, 0x00},
+	{0x71dd, 0x66},{0x71de, 0x62},{0x71df, 0x06},{0x71e0, 0x74},{0x71e1, 0xb9},
+	{0x71e2, 0x05},{0x71e3, 0xb7},{0x71e4, 0x10},{0x71e5, 0xbc},{0x71e6, 0x26},
+	{0x71e7, 0xb7},{0x71e8, 0x00},{0x71e9, 0xc8},{0x7600, 0x04},{0x7601, 0x80},
+	{0x7602, 0x07},{0x7603, 0x44},{0x7604, 0x05},{0x7605, 0x33},{0x7606, 0x0f},
+	{0x7607, 0x00},{0x7608, 0x07},{0x7609, 0x40},{0x760a, 0x04},{0x760b, 0xe5},
+	{0x760c, 0x06},{0x760d, 0x50},{0x760e, 0x04},{0x760f, 0xe4},{0x7610, 0x00},
+	{0x7611, 0x00},{0x7612, 0x06},{0x7613, 0x5c},{0x7614, 0x00},{0x7615, 0x0f},
+	{0x7616, 0x06},{0x7617, 0x1c},{0x7618, 0x00},{0x7619, 0x02},{0x761a, 0x06},
+	{0x761b, 0xa0},{0x761c, 0x00},{0x761d, 0x01},{0x761e, 0x06},{0x761f, 0xac},
+	{0x7620, 0x00},{0x7621, 0x0f},{0x7622, 0x05},{0x7623, 0x30},{0x7624, 0x07},
+	{0x7625, 0x00},{0x7626, 0x0f},{0x7627, 0x00},{0x7628, 0x04},{0x7629, 0xe5},
+	{0x762a, 0x05},{0x762b, 0x33},{0x762c, 0x06},{0x762d, 0x50},{0x762e, 0x00},
+	{0x762f, 0x01},{0x7630, 0x06},{0x7631, 0x5c},{0x7632, 0x04},{0x7633, 0xe4},
+	{0x7634, 0x00},{0x7635, 0x0e},{0x7636, 0x05},{0x7637, 0x30},{0x7638, 0x0f},
+	{0x7639, 0x00},{0x763a, 0x06},{0x763b, 0x24},{0x763c, 0x00},{0x763d, 0x03},
+	{0x763e, 0x05},{0x763f, 0x33},{0x7640, 0x07},{0x7641, 0x02},{0x7642, 0x06},
+	{0x7643, 0x24},{0x7644, 0x00},{0x7645, 0x01},{0x7646, 0x06},{0x7647, 0x20},
+	{0x7648, 0x0f},{0x7649, 0x00},{0x764a, 0x06},{0x764b, 0x14},{0x764c, 0x00},
+	{0x764d, 0x03},{0x764e, 0x05},{0x764f, 0x33},{0x7650, 0x07},{0x7651, 0x02},
+	{0x7652, 0x06},{0x7653, 0x14},{0x7654, 0x00},{0x7655, 0x01},{0x7656, 0x06},
+	{0x7657, 0x10},{0x7658, 0x0f},{0x7659, 0x00},{0x765a, 0x06},{0x765b, 0x10},
+	{0x765c, 0x0f},{0x765d, 0x00},{0x765e, 0x06},{0x765f, 0x20},{0x7660, 0x0f},
+	{0x7661, 0x00},{0x7662, 0x00},{0x7663, 0x00},{0x7664, 0x00},{0x7665, 0x02},
+	{0x7666, 0x04},{0x7667, 0xe5},{0x7668, 0x04},{0x7669, 0xe4},{0x766a, 0x0f},
+	{0x766b, 0x00},{0x766c, 0x00},{0x766d, 0x00},{0x766e, 0x00},{0x766f, 0x02},
+	{0x7670, 0x04},{0x7671, 0xe5},{0x7672, 0x04},{0x7673, 0xe4},{0x7674, 0x0f},
+	{0x7675, 0x00},{0x7676, 0x00},{0x7677, 0x02},{0x7678, 0x04},{0x7679, 0xe4},
+	{0x767a, 0x00},{0x767b, 0x02},{0x767c, 0x04},{0x767d, 0xc4},{0x767e, 0x00},
+	{0x767f, 0x04},{0x7680, 0x04},{0x7681, 0xc4},{0x7682, 0x05},{0x7683, 0x83},
+	{0x7684, 0x07},{0x7685, 0x02},{0x7686, 0x0f},{0x7687, 0x00},{0x7688, 0x00},
+	{0x7689, 0x02},{0x768a, 0x04},{0x768b, 0xe4},{0x768c, 0x00},{0x768d, 0x02},
+	{0x768e, 0x04},{0x768f, 0xc4},{0x7690, 0x00},{0x7691, 0x04},{0x7692, 0x04},
+	{0x7693, 0xc4},{0x7694, 0x05},{0x7695, 0x83},{0x7696, 0x07},{0x7697, 0x02},
+	{0x7698, 0x03},{0x7699, 0x0b},{0x769a, 0x05},{0x769b, 0x83},{0x769c, 0x00},
+	{0x769d, 0x08},{0x769e, 0x05},{0x769f, 0x03},{0x76a0, 0x05},{0x76a1, 0x32},
+	{0x76a2, 0x00},{0x76a3, 0x00},{0x76a4, 0x05},{0x76a5, 0x70},{0x76a6, 0x00},
+	{0x76a7, 0x01},{0x76a8, 0x05},{0x76a9, 0x74},{0x76aa, 0x03},{0x76ab, 0x9a},
+	{0x76ac, 0x05},{0x76ad, 0x83},{0x76ae, 0x00},{0x76af, 0x05},{0x76b0, 0x05},
+	{0x76b1, 0x03},{0x76b2, 0x05},{0x76b3, 0x32},{0x76b4, 0x00},{0x76b5, 0x00},
+	{0x76b6, 0x05},{0x76b7, 0x70},{0x76b8, 0x00},{0x76b9, 0x01},{0x76ba, 0x05},
+	{0x76bb, 0x74},{0x76bc, 0x03},{0x76bd, 0x99},{0x76be, 0x05},{0x76bf, 0x83},
+	{0x76c0, 0x00},{0x76c1, 0x03},{0x76c2, 0x05},{0x76c3, 0x03},{0x76c4, 0x05},
+	{0x76c5, 0x32},{0x76c6, 0x00},{0x76c7, 0x00},{0x76c8, 0x05},{0x76c9, 0x70},
+	{0x76ca, 0x00},{0x76cb, 0x01},{0x76cc, 0x05},{0x76cd, 0x74},{0x76ce, 0x03},
+	{0x76cf, 0x98},{0x76d0, 0x05},{0x76d1, 0x83},{0x76d2, 0x00},{0x76d3, 0x01},
+	{0x76d4, 0x05},{0x76d5, 0x03},{0x76d6, 0x05},{0x76d7, 0x32},{0x76d8, 0x00},
+	{0x76d9, 0x00},{0x76da, 0x05},{0x76db, 0x70},{0x76dc, 0x00},{0x76dd, 0x01},
+	{0x76de, 0x05},{0x76df, 0x74},{0x76e0, 0x03},{0x76e1, 0x97},{0x76e2, 0x05},
+	{0x76e3, 0x83},{0x76e4, 0x00},{0x76e5, 0x01},{0x76e6, 0x05},{0x76e7, 0x03},
+	{0x76e8, 0x05},{0x76e9, 0x32},{0x76ea, 0x00},{0x76eb, 0x00},{0x76ec, 0x05},
+	{0x76ed, 0x70},{0x76ee, 0x00},{0x76ef, 0x01},{0x76f0, 0x05},{0x76f1, 0x74},
+	{0x76f2, 0x03},{0x76f3, 0x96},{0x76f4, 0x05},{0x76f5, 0x83},{0x76f6, 0x00},
+	{0x76f7, 0x01},{0x76f8, 0x05},{0x76f9, 0x03},{0x76fa, 0x05},{0x76fb, 0x32},
+	{0x76fc, 0x00},{0x76fd, 0x00},{0x76fe, 0x05},{0x76ff, 0x70},{0x7700, 0x00},
+	{0x7701, 0x01},{0x7702, 0x05},{0x7703, 0x74},{0x7704, 0x03},{0x7705, 0x95},
+	{0x7706, 0x05},{0x7707, 0x83},{0x7708, 0x00},{0x7709, 0x01},{0x770a, 0x05},
+	{0x770b, 0x03},{0x770c, 0x05},{0x770d, 0x32},{0x770e, 0x00},{0x770f, 0x00},
+	{0x7710, 0x05},{0x7711, 0x70},{0x7712, 0x00},{0x7713, 0x01},{0x7714, 0x05},
+	{0x7715, 0x74},{0x7716, 0x03},{0x7717, 0x94},{0x7718, 0x05},{0x7719, 0x83},
+	{0x771a, 0x00},{0x771b, 0x03},{0x771c, 0x05},{0x771d, 0x03},{0x771e, 0x05},
+	{0x771f, 0x32},{0x7720, 0x00},{0x7721, 0x00},{0x7722, 0x05},{0x7723, 0x70},
+	{0x7724, 0x00},{0x7725, 0x01},{0x7726, 0x05},{0x7727, 0x74},{0x7728, 0x03},
+	{0x7729, 0x93},{0x772a, 0x05},{0x772b, 0x83},{0x772c, 0x00},{0x772d, 0x02},
+	{0x772e, 0x05},{0x772f, 0x03},{0x7730, 0x05},{0x7731, 0x32},{0x7732, 0x00},
+	{0x7733, 0x00},{0x7734, 0x05},{0x7735, 0x70},{0x7736, 0x00},{0x7737, 0x01},
+	{0x7738, 0x05},{0x7739, 0x74},{0x773a, 0x03},{0x773b, 0x92},{0x773c, 0x05},
+	{0x773d, 0x83},{0x773e, 0x00},{0x773f, 0x01},{0x7740, 0x05},{0x7741, 0x03},
+	{0x7742, 0x05},{0x7743, 0x32},{0x7744, 0x00},{0x7745, 0x00},{0x7746, 0x05},
+	{0x7747, 0x70},{0x7748, 0x00},{0x7749, 0x01},{0x774a, 0x05},{0x774b, 0x74},
+	{0x774c, 0x03},{0x774d, 0x91},{0x774e, 0x05},{0x774f, 0x83},{0x7750, 0x00},
+	{0x7751, 0x01},{0x7752, 0x05},{0x7753, 0x03},{0x7754, 0x05},{0x7755, 0x32},
+	{0x7756, 0x00},{0x7757, 0x00},{0x7758, 0x05},{0x7759, 0x70},{0x775a, 0x00},
+	{0x775b, 0x01},{0x775c, 0x05},{0x775d, 0x74},{0x775e, 0x03},{0x775f, 0x90},
+	{0x7760, 0x05},{0x7761, 0x83},{0x7762, 0x00},{0x7763, 0x01},{0x7764, 0x05},
+	{0x7765, 0x03},{0x7766, 0x05},{0x7767, 0x32},{0x7768, 0x00},{0x7769, 0x00},
+	{0x776a, 0x05},{0x776b, 0x70},{0x776c, 0x00},{0x776d, 0x01},{0x776e, 0x05},
+	{0x776f, 0x74},{0x7770, 0x02},{0x7771, 0x90},{0x7772, 0x05},{0x7773, 0x03},
+	{0x7774, 0x07},{0x7775, 0x00},{0x7776, 0x0f},{0x7777, 0x00},{0x7778, 0x08},
+	{0x7779, 0x31},{0x777a, 0x08},{0x777b, 0xd1},{0x777c, 0x0f},{0x777d, 0x00},
+	{0x777e, 0x04},{0x777f, 0xe5},{0x7780, 0x06},{0x7781, 0x50},{0x7782, 0x04},
+	{0x7783, 0xe4},{0x7784, 0x00},{0x7785, 0x00},{0x7786, 0x06},{0x7787, 0x5c},
+	{0x7788, 0x09},{0x7789, 0x14},{0x778a, 0x06},{0x778b, 0x1c},{0x778c, 0x00},
+	{0x778d, 0x02},{0x778e, 0x06},{0x778f, 0xa0},{0x7790, 0x00},{0x7791, 0x01},
+	{0x7792, 0x06},{0x7793, 0xac},{0x7794, 0x00},{0x7795, 0x0f},{0x7796, 0x05},
+	{0x7797, 0x30},{0x7798, 0x0f},{0x7799, 0x00},{0x779a, 0x00},{0x779b, 0x00},
+	{0x779c, 0x00},{0x779d, 0x02},{0x779e, 0x04},{0x779f, 0xe5},{0x77a0, 0x04},
+	{0x77a1, 0xe4},{0x77a2, 0x07},{0x77a3, 0x10},{0x77a4, 0x00},{0x77a5, 0x00},
+	{0x77a6, 0x07},{0x77a7, 0x00},{0x77a8, 0x01},{0x77a9, 0xbb},{0x77aa, 0x07},
+	{0x77ab, 0x10},{0x77ac, 0x00},{0x77ad, 0x00},{0x77ae, 0x07},{0x77af, 0x00},
+	{0x77b0, 0x01},{0x77b1, 0xaa},{0x77b2, 0x07},{0x77b3, 0x10},{0x77b4, 0x00},
+	{0x77b5, 0x00},{0x77b6, 0x07},{0x77b7, 0x00},{0x77b8, 0x01},{0x77b9, 0x99},
+	{0x77ba, 0x07},{0x77bb, 0x10},{0x77bc, 0x00},{0x77bd, 0x00},{0x77be, 0x07},
+	{0x77bf, 0x00},{0x77c0, 0x01},{0x77c1, 0x88},{0x77c2, 0x07},{0x77c3, 0x10},
+	{0x77c4, 0x00},{0x77c5, 0x00},{0x77c6, 0x07},{0x77c7, 0x00},{0x77c8, 0x01},
+	{0x77c9, 0x77},{0x77ca, 0x07},{0x77cb, 0x10},{0x77cc, 0x00},{0x77cd, 0x00},
+	{0x77ce, 0x07},{0x77cf, 0x00},{0x77d0, 0x01},{0x77d1, 0x66},{0x77d2, 0x07},
+	{0x77d3, 0x10},{0x77d4, 0x00},{0x77d5, 0x00},{0x77d6, 0x07},{0x77d7, 0x00},
+	{0x77d8, 0x01},{0x77d9, 0x55},{0x77da, 0x07},{0x77db, 0x10},{0x77dc, 0x00},
+	{0x77dd, 0x00},{0x77de, 0x07},{0x77df, 0x00},{0x77e0, 0x01},{0x77e1, 0x44},
+	{0x77e2, 0x07},{0x77e3, 0x10},{0x77e4, 0x00},{0x77e5, 0x00},{0x77e6, 0x07},
+	{0x77e7, 0x00},{0x77e8, 0x01},{0x77e9, 0x33},{0x77ea, 0x07},{0x77eb, 0x10},
+	{0x77ec, 0x00},{0x77ed, 0x00},{0x77ee, 0x07},{0x77ef, 0x00},{0x77f0, 0x01},
+	{0x77f1, 0x22},{0x77f2, 0x07},{0x77f3, 0x10},{0x77f4, 0x00},{0x77f5, 0x00},
+	{0x77f6, 0x07},{0x77f7, 0x00},{0x77f8, 0x01},{0x77f9, 0x11},{0x77fa, 0x07},
+	{0x77fb, 0x10},{0x77fc, 0x00},{0x77fd, 0x00},{0x77fe, 0x07},{0x77ff, 0x00},
+	{0x7800, 0x01},{0x7801, 0x00},{0x7802, 0x01},{0x7803, 0xff},{0x7804, 0x07},
+	{0x7805, 0x00},{0x7806, 0x02},{0x7807, 0xa0},{0x7808, 0x05},{0x7809, 0x33},
+	{0x780a, 0x0f},{0x780b, 0x00},{0x780c, 0x08},{0x780d, 0x36},{0x780e, 0x06},
+	{0x780f, 0x50},{0x7810, 0x04},{0x7811, 0xe4},{0x7812, 0x00},{0x7813, 0x00},
+	{0x7814, 0x06},{0x7815, 0x5c},{0x7816, 0x09},{0x7817, 0x14},{0x7818, 0x06},
+	{0x7819, 0x1c},{0x781a, 0x05},{0x781b, 0x33},{0x781c, 0x00},{0x781d, 0x01},
+	{0x781e, 0x06},{0x781f, 0x24},{0x7820, 0x00},{0x7821, 0x01},{0x7822, 0x06},
+	{0x7823, 0x20},{0x7824, 0x0f},{0x7825, 0x00},{0x7826, 0x08},{0x7827, 0x36},
+	{0x7828, 0x07},{0x7829, 0x10},{0x782a, 0x00},{0x782b, 0x00},{0x782c, 0x07},
+	{0x782d, 0x00},{0x782e, 0x01},{0x782f, 0xbb},{0x7830, 0x07},{0x7831, 0x10},
+	{0x7832, 0x00},{0x7833, 0x00},{0x7834, 0x07},{0x7835, 0x00},{0x7836, 0x01},
+	{0x7837, 0xaa},{0x7838, 0x07},{0x7839, 0x10},{0x783a, 0x00},{0x783b, 0x00},
+	{0x783c, 0x07},{0x783d, 0x00},{0x783e, 0x01},{0x783f, 0x99},{0x7840, 0x07},
+	{0x7841, 0x10},{0x7842, 0x00},{0x7843, 0x00},{0x7844, 0x07},{0x7845, 0x00},
+	{0x7846, 0x01},{0x7847, 0x88},{0x7848, 0x07},{0x7849, 0x10},{0x784a, 0x00},
+	{0x784b, 0x00},{0x784c, 0x07},{0x784d, 0x00},{0x784e, 0x01},{0x784f, 0x77},
+	{0x7850, 0x07},{0x7851, 0x10},{0x7852, 0x00},{0x7853, 0x00},{0x7854, 0x07},
+	{0x7855, 0x00},{0x7856, 0x01},{0x7857, 0x66},{0x7858, 0x07},{0x7859, 0x10},
+	{0x785a, 0x00},{0x785b, 0x00},{0x785c, 0x07},{0x785d, 0x00},{0x785e, 0x01},
+	{0x785f, 0x55},{0x7860, 0x07},{0x7861, 0x10},{0x7862, 0x00},{0x7863, 0x00},
+	{0x7864, 0x07},{0x7865, 0x00},{0x7866, 0x01},{0x7867, 0x44},{0x7868, 0x07},
+	{0x7869, 0x10},{0x786a, 0x00},{0x786b, 0x00},{0x786c, 0x07},{0x786d, 0x00},
+	{0x786e, 0x01},{0x786f, 0x33},{0x7870, 0x07},{0x7871, 0x10},{0x7872, 0x00},
+	{0x7873, 0x00},{0x7874, 0x07},{0x7875, 0x00},{0x7876, 0x01},{0x7877, 0x22},
+	{0x7878, 0x07},{0x7879, 0x10},{0x787a, 0x00},{0x787b, 0x00},{0x787c, 0x07},
+	{0x787d, 0x00},{0x787e, 0x01},{0x787f, 0x11},{0x7880, 0x07},{0x7881, 0x10},
+	{0x7882, 0x00},{0x7883, 0x00},{0x7884, 0x07},{0x7885, 0x00},{0x7886, 0x01},
+	{0x7887, 0x00},{0x7888, 0x01},{0x7889, 0xff},{0x788a, 0x02},{0x788b, 0xa0},
+	{0x788c, 0x05},{0x788d, 0x33},{0x788e, 0x0f},{0x788f, 0x00},{0x7890, 0x08},
+	{0x7891, 0x3b},{0x7892, 0x08},{0x7893, 0x5e},{0x7894, 0x0f},{0x7895, 0x00},
+	{0x7896, 0x04},{0x7897, 0xc0},{0x7898, 0x09},{0x7899, 0x14},{0x789a, 0x04},
+	{0x789b, 0x99},{0x789c, 0x07},{0x789d, 0x14},{0x789e, 0x04},{0x789f, 0x80},
+	{0x78a0, 0x04},{0x78a1, 0xa4},{0x78a2, 0x00},{0x78a3, 0x0a},{0x78a4, 0x04},
+	{0x78a5, 0xa6},{0x78a6, 0x00},{0x78a7, 0x00},{0x78a8, 0x04},{0x78a9, 0xa0},
+	{0x78aa, 0x04},{0x78ab, 0x80},{0x78ac, 0x04},{0x78ad, 0x00},{0x78ae, 0x05},
+	{0x78af, 0x03},{0x78b0, 0x06},{0x78b1, 0x00},{0x78b2, 0x0f},{0x78b3, 0x00},
+	{0x78b4, 0x0f},{0x78b5, 0x00},{0x78b6, 0x0f},{0x78b7, 0x00},{0x30a8, 0x00},
+	{0x30a9, 0x04},{0x30aa, 0x00},{0x30ab, 0x04},{0x30ac, 0x07},{0x30ad, 0x88},
+	{0x30ae, 0x04},{0x30af, 0x40},{0x30b0, 0x08},{0x30b1, 0x98},{0x30b2, 0x04},
+	{0x30b3, 0x70},{0x3197, 0x00},{0x3195, 0x28},{0x304b, 0x00},{0x304d, 0xa4},
+	{0x3033, 0x30},
+
+	/* mirror on */
+	{0x30c0, 0x04},{0x30a9, 0x05},{0x3252, 0x21},
+
+	{0x3012, 0x01},{0x3030, 0x02},
+};
+
+static struct vin_reg_16_8 ov2718_lcg_vs_hdr_regs[] = {
+	{0x3013, 0x01},{0x3000, 0x05},{0x3001, 0x64},{0x3002, 0x07},{0x3003, 0x01},
+	{0x3004, 0x06},{0x3005, 0x49},{0x3006, 0x00},{0x3007, 0x07},{0x3008, 0x01},
+	{0x3009, 0x00},{0x300c, 0x6c},{0x300d, 0xe1},{0x300e, 0x80},{0x300f, 0x00},
+	{0x3012, 0x00},{0x3013, 0x00},{0x3014, 0x84},{0x3015, 0x00},{0x3017, 0x00},
+	{0x3018, 0x00},{0x3019, 0x00},{0x301a, 0x00},{0x301b, 0x01},{0x301e, 0x10},
+	{0x301f, 0x5f},{0x3030, 0x0a},{0x3031, 0x63},{0x3032, 0xf0},{0x3033, 0x30},
+	{0x3034, 0x34},{0x3035, 0x51},{0x3036, 0x02},{0x3037, 0x9f},{0x3038, 0x04},
+	{0x3039, 0xb7},{0x303a, 0x04},{0x303b, 0x07},{0x303c, 0xf0},{0x303d, 0x00},
+	{0x303e, 0x0b},{0x303f, 0xe3},{0x3040, 0xf3},{0x3041, 0x29},{0x3042, 0xf6},
+	{0x3043, 0x65},{0x3044, 0x06},{0x3045, 0x0f},{0x3046, 0x55},{0x3047, 0xf7},
+	{0x3048, 0x31},{0x3049, 0x0f},{0x304a, 0x10},{0x304b, 0xc0},{0x304c, 0x33},
+	{0x304d, 0x24},{0x304e, 0x0b},{0x304f, 0x3d},{0x3050, 0x10},{0x3060, 0x00},
+	{0x3061, 0x64},{0x3062, 0x01},{0x3063, 0x00},{0x3064, 0x0b},{0x3065, 0xf8},
+	{0x3066, 0x80},{0x3080, 0x00},{0x3081, 0x00},{0x3082, 0x01},{0x3083, 0xe3},
+	{0x3084, 0x05},{0x3085, 0x00},{0x3086, 0x10},{0x3087, 0x10},{0x3089, 0x00},
+	{0x308a, 0x01},{0x3093, 0x00},{0x30a0, 0x00},{0x30a1, 0x04},{0x30a2, 0x00},
+	{0x30a3, 0x04},{0x30a4, 0x07},{0x30a5, 0x8b},{0x30a6, 0x04},{0x30a7, 0x43},
+	{0x30a8, 0x00},{0x30a9, 0x04},{0x30aa, 0x00},{0x30ab, 0x04},{0x30ac, 0x07},
+	{0x30ad, 0x80},{0x30ae, 0x04},{0x30af, 0x38},{0x30b0, 0x08},{0x30b1, 0x98},
+	{0x30b2, 0x04},{0x30b3, 0x70},{0x30b4, 0x00},{0x30b5, 0x00},{0x30b6, 0x00},
+	{0x30b7, 0x10},{0x30b8, 0x00},{0x30b9, 0x02},{0x30ba, 0x10},{0x30bb, 0x00},
+	{0x30bc, 0x00},{0x30bd, 0x03},{0x30be, 0x5c},{0x30bf, 0x00},{0x30c0, 0x00},
+	{0x30c1, 0x00},{0x30c2, 0x20},{0x30c3, 0x00},{0x30c4, 0x4a},{0x30c5, 0x00},
+	{0x30c7, 0x00},{0x30c8, 0x00},{0x30d1, 0x00},{0x30d2, 0x00},{0x30d3, 0x80},
+	{0x30d4, 0x00},{0x30d9, 0x09},{0x30da, 0x64},{0x30dd, 0x00},{0x30de, 0x16},
+	{0x30df, 0x00},{0x30e0, 0x17},{0x30e1, 0x00},{0x30e2, 0x18},{0x30e3, 0x10},
+	{0x30e4, 0x04},{0x30e5, 0x00},{0x30e6, 0x00},{0x30e7, 0x00},{0x30e8, 0x00},
+	{0x30e9, 0x00},{0x30ea, 0x00},{0x30eb, 0x00},{0x30ec, 0x00},{0x30ed, 0x00},
+	{0x3101, 0x00},{0x3102, 0x00},{0x3103, 0x00},{0x3104, 0x00},{0x3105, 0x6c},
+	{0x3106, 0x83},{0x3107, 0x72},{0x3108, 0x70},{0x3109, 0x6c},{0x310a, 0x83},
+	{0x310b, 0x69},{0x310c, 0x43},{0x310d, 0x42},{0x310e, 0x00},{0x3120, 0x00},
+	{0x3121, 0x00},{0x3122, 0x00},{0x3123, 0x00},{0x3124, 0x00},{0x3125, 0xa0},
+	{0x3126, 0x3f},{0x3127, 0x0f},{0x3128, 0x00},{0x3129, 0x3a},{0x312a, 0x02},
+	{0x312b, 0x0f},{0x312c, 0x00},{0x312d, 0x0f},{0x312e, 0x1d},{0x312f, 0x00},
+	{0x3130, 0x00},{0x3131, 0x00},{0x3132, 0x00},{0x3140, 0x02},{0x3141, 0x03},
+	{0x3142, 0x00},{0x3143, 0x00},{0x3144, 0x00},{0x3145, 0x00},{0x3146, 0x00},
+	{0x3147, 0x00},{0x3148, 0x00},{0x3149, 0x00},{0x314a, 0x00},{0x314b, 0x00},
+	{0x314c, 0x00},{0x314d, 0x00},{0x314e, 0x1c},{0x314f, 0x02},{0x3150, 0x02},
+	{0x3151, 0x10},{0x3152, 0x10},{0x3153, 0x10},{0x3154, 0x80},{0x3155, 0x00},
+	{0x3156, 0x03},{0x3157, 0x00},{0x3158, 0x0f},{0x3159, 0xff},{0x315a, 0x01},
+	{0x315b, 0x00},{0x315c, 0x01},{0x315d, 0x00},{0x315e, 0x01},{0x315f, 0x00},
+	{0x3160, 0x00},{0x3161, 0x40},{0x3162, 0x00},{0x3163, 0x40},{0x3164, 0x00},
+	{0x3165, 0x40},{0x3190, 0x85},{0x3191, 0xc9},{0x3193, 0x08},{0x3194, 0x13},
+	{0x3195, 0x33},{0x3196, 0x00},{0x3197, 0x10},{0x3198, 0x00},{0x3199, 0x3f},
+	{0x319a, 0x40},{0x319b, 0x7f},{0x319c, 0x80},{0x319d, 0xbf},{0x319e, 0xc0},
+	{0x319f, 0xff},{0x31a0, 0x10},{0x31a1, 0x55},{0x31a2, 0x00},{0x31a3, 0x00},
+	{0x31a6, 0x00},{0x31a7, 0x00},{0x31b0, 0x00},{0x31b1, 0x00},{0x31b2, 0x02},
+	{0x31b3, 0x00},{0x31b4, 0x00},{0x31b5, 0x01},{0x31b6, 0x00},{0x31b7, 0x00},
+	{0x31b8, 0x00},{0x31b9, 0x00},{0x31ba, 0x00},{0x31d0, 0x3c},{0x31d1, 0x34},
+	{0x31d2, 0x3c},{0x31d3, 0x00},{0x31d4, 0x2d},{0x31d5, 0x00},{0x31d6, 0x01},
+	{0x31d7, 0x06},{0x31d8, 0x00},{0x31d9, 0x64},{0x31da, 0x00},{0x31db, 0x28},
+	{0x31dc, 0x04},{0x31dd, 0x69},{0x31de, 0x0a},{0x31df, 0x3c},{0x31e0, 0x04},
+	{0x31e1, 0x32},{0x31e2, 0x00},{0x31e3, 0x01},{0x31e4, 0x0d},{0x31e5, 0x80},
+	{0x31e6, 0x00},{0x31e7, 0x2c},{0x31e8, 0x6c},{0x31e9, 0xac},{0x31ea, 0xec},
+	{0x31eb, 0x3f},{0x31ec, 0x0f},{0x31ed, 0x20},{0x31ee, 0x04},{0x31ef, 0x48},
+	{0x31f0, 0x07},{0x31f1, 0x90},{0x31f2, 0x04},{0x31f3, 0x48},{0x31f4, 0x07},
+	{0x31f5, 0x90},{0x31f6, 0x04},{0x31f7, 0x48},{0x31f8, 0x07},{0x31f9, 0x90},
+	{0x31fa, 0x04},{0x31fb, 0x48},{0x31fd, 0xcb},{0x31fe, 0x0f},{0x31ff, 0x03},
+	{0x3200, 0x00},{0x3201, 0xff},{0x3202, 0x00},{0x3203, 0xff},{0x3204, 0xff},
+	{0x3205, 0xff},{0x3206, 0xff},{0x3207, 0xff},{0x3208, 0xff},{0x3209, 0xff},
+	{0x320a, 0xff},{0x320b, 0x1b},{0x320c, 0x1f},{0x320d, 0x1e},{0x320e, 0x30},
+	{0x320f, 0x2d},{0x3210, 0x2c},{0x3211, 0x2b},{0x3212, 0x2a},{0x3213, 0x24},
+	{0x3214, 0x22},{0x3215, 0x00},{0x3216, 0x04},{0x3217, 0x2c},{0x3218, 0x6c},
+	{0x3219, 0xac},{0x321a, 0xec},{0x321b, 0x00},{0x3230, 0x3a},{0x3231, 0x00},
+	{0x3232, 0x80},{0x3233, 0x00},{0x3234, 0x10},{0x3235, 0xaa},{0x3236, 0x55},
+	{0x3237, 0x99},{0x3238, 0x66},{0x3239, 0x08},{0x323a, 0x88},{0x323b, 0x00},
+	{0x323c, 0x00},{0x323d, 0x03},{0x3250, 0x33},{0x3251, 0x00},{0x3252, 0x20},
+	{0x3253, 0x00},{0x3254, 0x11},{0x3255, 0x01},{0x3256, 0x00},{0x3257, 0x00},
+	{0x3258, 0x00},{0x3270, 0x01},{0x3271, 0x60},{0x3272, 0xc0},{0x3273, 0x00},
+	{0x3274, 0x80},{0x3275, 0x40},{0x3276, 0x02},{0x3277, 0x08},{0x3278, 0x10},
+	{0x3279, 0x04},{0x327a, 0x00},{0x327b, 0x03},{0x327c, 0x10},{0x327d, 0x60},
+	{0x327e, 0xc0},{0x327f, 0x06},{0x3288, 0x10},{0x3289, 0x00},{0x328a, 0x08},
+	{0x328b, 0x00},{0x328c, 0x04},{0x328d, 0x00},{0x328e, 0x02},{0x328f, 0x00},
+	{0x3290, 0x20},{0x3291, 0x00},{0x3292, 0x10},{0x3293, 0x00},{0x3294, 0x08},
+	{0x3295, 0x00},{0x3296, 0x04},{0x3297, 0x00},{0x3298, 0x40},{0x3299, 0x00},
+	{0x329a, 0x20},{0x329b, 0x00},{0x329c, 0x10},{0x329d, 0x00},{0x329e, 0x08},
+	{0x329f, 0x00},{0x32a0, 0x7f},{0x32a1, 0xff},{0x32a2, 0x40},{0x32a3, 0x00},
+	{0x32a4, 0x20},{0x32a5, 0x00},{0x32a6, 0x10},{0x32a7, 0x00},{0x32a8, 0x00},
+	{0x32a9, 0x00},{0x32aa, 0x00},{0x32ab, 0x00},{0x32ac, 0x00},{0x32ad, 0x00},
+	{0x32ae, 0x00},{0x32af, 0x00},{0x32b0, 0x00},{0x32b1, 0x00},{0x32b2, 0x00},
+	{0x32b3, 0x00},{0x32b4, 0x00},{0x32b5, 0x00},{0x32b6, 0x00},{0x32b7, 0x00},
+	{0x32b8, 0x00},{0x32b9, 0x00},{0x32ba, 0x00},{0x32bb, 0x00},{0x32bc, 0x00},
+	{0x32bd, 0x00},{0x32be, 0x00},{0x32bf, 0x00},{0x32c0, 0x00},{0x32c1, 0x00},
+	{0x32c2, 0x00},{0x32c3, 0x00},{0x32c4, 0x00},{0x32c5, 0x00},{0x32c6, 0x00},
+	{0x32c7, 0x00},{0x32c8, 0x87},{0x32c9, 0x00},{0x3330, 0x03},{0x3331, 0xc8},
+	{0x3332, 0x02},{0x3333, 0x24},{0x3334, 0x00},{0x3335, 0x00},{0x3336, 0x00},
+	{0x3337, 0x00},{0x3338, 0x03},{0x3339, 0xc8},{0x333a, 0x02},{0x333b, 0x24},
+	{0x333c, 0x00},{0x333d, 0x00},{0x333e, 0x00},{0x333f, 0x00},{0x3340, 0x03},
+	{0x3341, 0xc8},{0x3342, 0x02},{0x3343, 0x24},{0x3344, 0x00},{0x3345, 0x00},
+	{0x3346, 0x00},{0x3347, 0x00},{0x3348, 0x40},{0x3349, 0x00},{0x334a, 0x00},
+	{0x334b, 0x00},{0x334c, 0x00},{0x334d, 0x00},{0x334e, 0x80},{0x3360, 0x01},
+	{0x3361, 0x00},{0x3362, 0x01},{0x3363, 0x00},{0x3364, 0x01},{0x3365, 0x00},
+	{0x3366, 0x01},{0x3367, 0x00},{0x3368, 0x01},{0x3369, 0x00},{0x336a, 0x01},
+	{0x336b, 0x00},{0x336c, 0x01},{0x336d, 0x00},{0x336e, 0x01},{0x336f, 0x00},
+	{0x3370, 0x01},{0x3371, 0x00},{0x3372, 0x01},{0x3373, 0x00},{0x3374, 0x01},
+	{0x3375, 0x00},{0x3376, 0x01},{0x3377, 0x00},{0x3378, 0x00},{0x3379, 0x00},
+	{0x337a, 0x00},{0x337b, 0x00},{0x337c, 0x00},{0x337d, 0x00},{0x337e, 0x00},
+	{0x337f, 0x00},{0x3380, 0x00},{0x3381, 0x00},{0x3382, 0x00},{0x3383, 0x00},
+	{0x3384, 0x00},{0x3385, 0x00},{0x3386, 0x00},{0x3387, 0x00},{0x3388, 0x00},
+	{0x3389, 0x00},{0x338a, 0x00},{0x338b, 0x00},{0x338c, 0x00},{0x338d, 0x00},
+	{0x338e, 0x00},{0x338f, 0x00},{0x3390, 0x00},{0x3391, 0x00},{0x3392, 0x00},
+	{0x3393, 0x00},{0x3394, 0x00},{0x3395, 0x00},{0x3396, 0x00},{0x3397, 0x00},
+	{0x3398, 0x00},{0x3399, 0x00},{0x339a, 0x00},{0x339b, 0x00},{0x33b0, 0x00},
+	{0x33b1, 0x50},{0x33b2, 0x01},{0x33b3, 0xff},{0x33b4, 0xe0},{0x33b5, 0x6b},
+	{0x33b6, 0x00},{0x33b7, 0x00},{0x33b8, 0x00},{0x33b9, 0x00},{0x33ba, 0x00},
+	{0x33bb, 0x1f},{0x33bc, 0x01},{0x33bd, 0x01},{0x33be, 0x01},{0x33bf, 0x01},
+	{0x33c0, 0x00},{0x33c1, 0x00},{0x33c2, 0x00},{0x33c3, 0x00},{0x33e0, 0x14},
+	{0x33e1, 0x0f},{0x33e2, 0x04},{0x33e3, 0x02},{0x33e4, 0x01},{0x33e5, 0x01},
+	{0x33e6, 0x00},{0x33e7, 0x04},{0x33e8, 0x0c},{0x33e9, 0x00},{0x33ea, 0x01},
+	{0x33eb, 0x02},{0x33ec, 0x03},{0x33ed, 0x02},{0x33ee, 0x05},{0x33ef, 0x0a},
+	{0x33f0, 0x08},{0x33f1, 0x04},{0x33f2, 0x04},{0x33f3, 0x00},{0x33f4, 0x03},
+	{0x33f5, 0x14},{0x33f6, 0x0f},{0x33f7, 0x02},{0x33f8, 0x01},{0x33f9, 0x01},
+	{0x33fa, 0x01},{0x33fb, 0x00},{0x33fc, 0x04},{0x33fd, 0x0c},{0x33fe, 0x00},
+	{0x33ff, 0x01},{0x3400, 0x02},{0x3401, 0x03},{0x3402, 0x01},{0x3403, 0x02},
+	{0x3404, 0x08},{0x3405, 0x08},{0x3406, 0x04},{0x3407, 0x04},{0x3408, 0x00},
+	{0x3409, 0x03},{0x340a, 0x14},{0x340b, 0x0f},{0x340c, 0x04},{0x340d, 0x02},
+	{0x340e, 0x01},{0x340f, 0x01},{0x3410, 0x00},{0x3411, 0x04},{0x3412, 0x0c},
+	{0x3413, 0x00},{0x3414, 0x01},{0x3415, 0x02},{0x3416, 0x03},{0x3417, 0x02},
+	{0x3418, 0x05},{0x3419, 0x0a},{0x341a, 0x08},{0x341b, 0x04},{0x341c, 0x04},
+	{0x341d, 0x00},{0x341e, 0x03},{0x3440, 0x00},{0x3441, 0x00},{0x3442, 0x00},
+	{0x3443, 0x00},{0x3444, 0x02},{0x3445, 0xf0},{0x3446, 0x02},{0x3447, 0x08},
+	{0x3448, 0x00},{0x3460, 0x40},{0x3461, 0x40},{0x3462, 0x40},{0x3463, 0x40},
+	{0x3464, 0x03},{0x3465, 0x01},{0x3466, 0x01},{0x3467, 0x02},{0x3468, 0x30},
+	{0x3469, 0x00},{0x346a, 0x35},{0x346b, 0x00},{0x3480, 0x40},{0x3481, 0x00},
+	{0x3482, 0x00},{0x3483, 0x00},{0x3484, 0x07},{0x3485, 0x00},{0x3486, 0x00},
+	{0x3487, 0x00},{0x3488, 0x00},{0x3489, 0x00},{0x348a, 0x00},{0x348b, 0x04},
+	{0x348c, 0x00},{0x348d, 0x01},{0x348f, 0x01},{0x7000, 0xda},{0x7001, 0xcf},
+	{0x7002, 0xac},{0x7003, 0xd0},{0x7004, 0xac},{0x7005, 0xd1},{0x7006, 0x50},
+	{0x7007, 0xb6},{0x7008, 0xee},{0x7009, 0xac},{0x700a, 0xd2},{0x700b, 0xdc},
+	{0x700c, 0xdf},{0x700d, 0x0f},{0x700e, 0xe1},{0x700f, 0x36},{0x7010, 0x30},
+	{0x7011, 0xd3},{0x7012, 0x2e},{0x7013, 0x54},{0x7014, 0x46},{0x7015, 0xb4},
+	{0x7016, 0x00},{0x7017, 0x1a},{0x7018, 0xc1},{0x7019, 0x0e},{0x701a, 0xe8},
+	{0x701b, 0x00},{0x701c, 0xe6},{0x701d, 0xb0},{0x701e, 0x6e},{0x701f, 0xbd},
+	{0x7020, 0x01},{0x7021, 0xd7},{0x7022, 0xed},{0x7023, 0xbc},{0x7024, 0x22},
+	{0x7025, 0xb9},{0x7026, 0x66},{0x7027, 0x2c},{0x7028, 0x28},{0x7029, 0x19},
+	{0x702a, 0xc1},{0x702b, 0x32},{0x702c, 0xa1},{0x702d, 0xac},{0x702e, 0xd8},
+	{0x702f, 0xd6},{0x7030, 0xb4},{0x7031, 0x04},{0x7032, 0x46},{0x7033, 0xb7},
+	{0x7034, 0x00},{0x7035, 0xbe},{0x7036, 0x08},{0x7037, 0xc3},{0x7038, 0xdb},
+	{0x7039, 0xad},{0x703a, 0xc3},{0x703b, 0xbf},{0x703c, 0x50},{0x703d, 0x20},
+	{0x703e, 0xb8},{0x703f, 0x02},{0x7040, 0xbc},{0x7041, 0x17},{0x7042, 0xdb},
+	{0x7043, 0xa0},{0x7044, 0xb8},{0x7045, 0x00},{0x7046, 0x28},{0x7047, 0x54},
+	{0x7048, 0xb4},{0x7049, 0xbc},{0x704a, 0xbe},{0x704b, 0x06},{0x704c, 0xd8},
+	{0x704d, 0xd6},{0x704e, 0x00},{0x704f, 0xb9},{0x7050, 0x64},{0x7051, 0xee},
+	{0x7052, 0xe8},{0x7053, 0xb4},{0x7054, 0x14},{0x7055, 0xab},{0x7056, 0xbc},
+	{0x7057, 0x17},{0x7058, 0x62},{0x7059, 0x07},{0x705a, 0xb9},{0x705b, 0x05},
+	{0x705c, 0xad},{0x705d, 0xb4},{0x705e, 0x25},{0x705f, 0xc3},{0x7060, 0xc1},
+	{0x7061, 0x00},{0x7062, 0xc0},{0x7063, 0x42},{0x7064, 0x50},{0x7065, 0x20},
+	{0x7066, 0x04},{0x7067, 0xb8},{0x7068, 0x02},{0x7069, 0xdb},{0x706a, 0xd8},
+	{0x706b, 0xac},{0x706c, 0xb7},{0x706d, 0x00},{0x706e, 0xbc},{0x706f, 0x11},
+	{0x7070, 0xd6},{0x7071, 0xc7},{0x7072, 0xb8},{0x7073, 0x00},{0x7074, 0x28},
+	{0x7075, 0x54},{0x7076, 0xb4},{0x7077, 0x04},{0x7078, 0x46},{0x7079, 0xbe},
+	{0x707a, 0x06},{0x707b, 0xc3},{0x707c, 0xdb},{0x707d, 0xbd},{0x707e, 0x03},
+	{0x707f, 0xee},{0x7080, 0xad},{0x7081, 0xc3},{0x7082, 0xbf},{0x7083, 0x00},
+	{0x7084, 0xec},{0x7085, 0x00},{0x7086, 0x15},{0x7087, 0xc2},{0x7088, 0x47},
+	{0x7089, 0xc3},{0x708a, 0xb7},{0x708b, 0xc0},{0x708c, 0x43},{0x708d, 0x00},
+	{0x708e, 0x00},{0x708f, 0x00},{0x7090, 0xb9},{0x7091, 0x64},{0x7092, 0x29},
+	{0x7093, 0x00},{0x7094, 0xb8},{0x7095, 0x12},{0x7096, 0xbe},{0x7097, 0x01},
+	{0x7098, 0xd0},{0x7099, 0xbc},{0x709a, 0x01},{0x709b, 0xac},{0x709c, 0x37},
+	{0x709d, 0xd1},{0x709e, 0xac},{0x709f, 0xd2},{0x70a0, 0xac},{0x70a1, 0xad},
+	{0x70a2, 0x28},{0x70a3, 0x00},{0x70a4, 0xb8},{0x70a5, 0x00},{0x70a6, 0xbc},
+	{0x70a7, 0x01},{0x70a8, 0xe1},{0x70a9, 0x36},{0x70aa, 0xd3},{0x70ab, 0x30},
+	{0x70ac, 0x04},{0x70ad, 0xe0},{0x70ae, 0xd8},{0x70af, 0xb4},{0x70b0, 0xcd},
+	{0x70b1, 0x45},{0x70b2, 0x00},{0x70b3, 0xe8},{0x70b4, 0xbe},{0x70b5, 0x05},
+	{0x70b6, 0xbc},{0x70b7, 0x1e},{0x70b8, 0x62},{0x70b9, 0x07},{0x70ba, 0xb9},
+	{0x70bb, 0x05},{0x70bc, 0xad},{0x70bd, 0xc3},{0x70be, 0xd2},{0x70bf, 0x00},
+	{0x70c0, 0x15},{0x70c1, 0xc2},{0x70c2, 0x64},{0x70c3, 0xc3},{0x70c4, 0xcd},
+	{0x70c5, 0xc0},{0x70c6, 0x60},{0x70c7, 0x00},{0x70c8, 0x46},{0x70c9, 0x00},
+	{0x70ca, 0x00},{0x70cb, 0x19},{0x70cc, 0xc1},{0x70cd, 0x7e},{0x70ce, 0xa1},
+	{0x70cf, 0xb9},{0x70d0, 0x64},{0x70d1, 0x29},{0x70d2, 0x00},{0x70d3, 0xb8},
+	{0x70d4, 0x02},{0x70d5, 0xbe},{0x70d6, 0x02},{0x70d7, 0xd0},{0x70d8, 0xdc},
+	{0x70d9, 0xac},{0x70da, 0xbc},{0x70db, 0x01},{0x70dc, 0x37},{0x70dd, 0xd1},
+	{0x70de, 0xac},{0x70df, 0xd2},{0x70e0, 0xad},{0x70e1, 0x28},{0x70e2, 0x00},
+	{0x70e3, 0xb8},{0x70e4, 0x00},{0x70e5, 0xbc},{0x70e6, 0x01},{0x70e7, 0xe1},
+	{0x70e8, 0x36},{0x70e9, 0x30},{0x70ea, 0xe0},{0x70eb, 0xd8},{0x70ec, 0xb5},
+	{0x70ed, 0x06},{0x70ee, 0x45},{0x70ef, 0xd6},{0x70f0, 0xbe},{0x70f1, 0x07},
+	{0x70f2, 0x00},{0x70f3, 0xe8},{0x70f4, 0x62},{0x70f5, 0x07},{0x70f6, 0xb9},
+	{0x70f7, 0x05},{0x70f8, 0xad},{0x70f9, 0xc3},{0x70fa, 0xd2},{0x70fb, 0x46},
+	{0x70fc, 0xd5},{0x70fd, 0xe3},{0x70fe, 0x18},{0x70ff, 0xc2},{0x7100, 0xae},
+	{0x7101, 0xb9},{0x7102, 0x64},{0x7103, 0xd1},{0x7104, 0x50},{0x7105, 0xdd},
+	{0x7106, 0xac},{0x7107, 0xcf},{0x7108, 0xdf},{0x7109, 0xb6},{0x710a, 0xee},
+	{0x710b, 0xbc},{0x710c, 0x13},{0x710d, 0xe1},{0x710e, 0x36},{0x710f, 0x30},
+	{0x7110, 0xd3},{0x7111, 0x2e},{0x7112, 0x54},{0x7113, 0xbc},{0x7114, 0x32},
+	{0x7115, 0x2c},{0x7116, 0x50},{0x7117, 0x20},{0x7118, 0x04},{0x7119, 0xb8},
+	{0x711a, 0x02},{0x711b, 0xbc},{0x711c, 0x18},{0x711d, 0xc7},{0x711e, 0xb8},
+	{0x711f, 0x00},{0x7120, 0x28},{0x7121, 0x54},{0x7122, 0xb4},{0x7123, 0xbf},
+	{0x7124, 0x46},{0x7125, 0xbe},{0x7126, 0x04},{0x7127, 0xd6},{0x7128, 0xd8},
+	{0x7129, 0xab},{0x712a, 0x00},{0x712b, 0xe8},{0x712c, 0x62},{0x712d, 0x07},
+	{0x712e, 0xb9},{0x712f, 0x05},{0x7130, 0xad},{0x7131, 0xc3},{0x7132, 0xbf},
+	{0x7133, 0xb9},{0x7134, 0x64},{0x7135, 0x29},{0x7136, 0x00},{0x7137, 0xb8},
+	{0x7138, 0x02},{0x7139, 0xbe},{0x713a, 0x00},{0x713b, 0xe6},{0x713c, 0xbd},
+	{0x713d, 0x03},{0x713e, 0xec},{0x713f, 0xad},{0x7140, 0xe2},{0x7141, 0x28},
+	{0x7142, 0x00},{0x7143, 0xb8},{0x7144, 0x00},{0x7145, 0xe0},{0x7146, 0xd8},
+	{0x7147, 0xb4},{0x7148, 0xcd},{0x7149, 0x45},{0x714a, 0xbe},{0x714b, 0x03},
+	{0x714c, 0x00},{0x714d, 0x30},{0x714e, 0xe8},{0x714f, 0xbc},{0x7150, 0x1c},
+	{0x7151, 0x62},{0x7152, 0x07},{0x7153, 0xb9},{0x7154, 0x05},{0x7155, 0xad},
+	{0x7156, 0xc3},{0x7157, 0xd2},{0x7158, 0x46},{0x7159, 0xe4},{0x715a, 0xd5},
+	{0x715b, 0x00},{0x715c, 0x17},{0x715d, 0xc2},{0x715e, 0xc6},{0x715f, 0xde},
+	{0x7160, 0xcf},{0x7161, 0xdf},{0x7162, 0xac},{0x7163, 0xd1},{0x7164, 0x44},
+	{0x7165, 0xac},{0x7166, 0xb9},{0x7167, 0x76},{0x7168, 0xb8},{0x7169, 0x08},
+	{0x716a, 0xb6},{0x716b, 0xfe},{0x716c, 0xb4},{0x716d, 0xbf},{0x716e, 0xd6},
+	{0x716f, 0xd8},{0x7170, 0xab},{0x7171, 0xe8},{0x7172, 0x00},{0x7173, 0xe1},
+	{0x7174, 0x36},{0x7175, 0x30},{0x7176, 0xd3},{0x7177, 0xbc},{0x7178, 0x5e},
+	{0x7179, 0xb4},{0x717a, 0x1d},{0x717b, 0xaa},{0x717c, 0xb8},{0x717d, 0x0c},
+	{0x717e, 0x45},{0x717f, 0xe6},{0x7180, 0xbd},{0x7181, 0x03},{0x7182, 0xec},
+	{0x7183, 0xbc},{0x7184, 0x7d},{0x7185, 0xc3},{0x7186, 0xd2},{0x7187, 0x42},
+	{0x7188, 0xb8},{0x7189, 0x00},{0x718a, 0xe4},{0x718b, 0xd5},{0x718c, 0xb6},
+	{0x718d, 0x00},{0x718e, 0xb9},{0x718f, 0x0a},{0x7190, 0xbd},{0x7191, 0x03},
+	{0x7192, 0xb5},{0x7193, 0x4b},{0x7194, 0x40},{0x7195, 0x58},{0x7196, 0x76},
+	{0x7197, 0x01},{0x7198, 0x6a},{0x7199, 0xdd},{0x719a, 0x1a},{0x719b, 0xc2},
+	{0x719c, 0xd1},{0x719d, 0xe8},{0x719e, 0xbd},{0x719f, 0x03},{0x71a0, 0xe6},
+	{0x71a1, 0xec},{0x71a2, 0xbc},{0x71a3, 0x19},{0x71a4, 0xb9},{0x71a5, 0xf6},
+	{0x71a6, 0x14},{0x71a7, 0xc1},{0x71a8, 0xda},{0x71a9, 0xd1},{0x71aa, 0xac},
+	{0x71ab, 0x37},{0x71ac, 0xbc},{0x71ad, 0x35},{0x71ae, 0x36},{0x71af, 0x30},
+	{0x71b0, 0xe1},{0x71b1, 0xd3},{0x71b2, 0xc0},{0x71b3, 0xd3},{0x71b4, 0xb6},
+	{0x71b5, 0x0c},{0x71b6, 0xff},{0x71b7, 0xb4},{0x71b8, 0xbc},{0x71b9, 0xd9},
+	{0x71ba, 0x00},{0x71bb, 0xe8},{0x71bc, 0x56},{0x71bd, 0xc0},{0x71be, 0xe3},
+	{0x71bf, 0xb4},{0x71c0, 0x1d},{0x71c1, 0x56},{0x71c2, 0xaa},{0x71c3, 0xbc},
+	{0x71c4, 0x1a},{0x71c5, 0x00},{0x71c6, 0xb5},{0x71c7, 0x48},{0x71c8, 0x57},
+	{0x71c9, 0x00},{0x71ca, 0x54},{0x71cb, 0xe7},{0x71cc, 0xc8},{0x71cd, 0xb5},
+	{0x71ce, 0x13},{0x71cf, 0xd9},{0x71d0, 0x00},{0x71d1, 0xe8},{0x71d2, 0x56},
+	{0x71d3, 0x08},{0x71d4, 0xb4},{0x71d5, 0x44},{0x71d6, 0x57},{0x71d7, 0x00},
+	{0x71d8, 0x54},{0x71d9, 0xe7},{0x71da, 0xc8},{0x71db, 0xab},{0x71dc, 0x00},
+	{0x71dd, 0x66},{0x71de, 0x62},{0x71df, 0x06},{0x71e0, 0x74},{0x71e1, 0xb9},
+	{0x71e2, 0x05},{0x71e3, 0xb7},{0x71e4, 0x10},{0x71e5, 0xbc},{0x71e6, 0x26},
+	{0x71e7, 0xb7},{0x71e8, 0x00},{0x71e9, 0xc8},{0x7600, 0x04},{0x7601, 0x80},
+	{0x7602, 0x07},{0x7603, 0x44},{0x7604, 0x05},{0x7605, 0x33},{0x7606, 0x0f},
+	{0x7607, 0x00},{0x7608, 0x07},{0x7609, 0x40},{0x760a, 0x04},{0x760b, 0xe5},
+	{0x760c, 0x06},{0x760d, 0x50},{0x760e, 0x04},{0x760f, 0xe4},{0x7610, 0x00},
+	{0x7611, 0x00},{0x7612, 0x06},{0x7613, 0x5c},{0x7614, 0x00},{0x7615, 0x0f},
+	{0x7616, 0x06},{0x7617, 0x1c},{0x7618, 0x00},{0x7619, 0x02},{0x761a, 0x06},
+	{0x761b, 0xa0},{0x761c, 0x00},{0x761d, 0x01},{0x761e, 0x06},{0x761f, 0xac},
+	{0x7620, 0x00},{0x7621, 0x0f},{0x7622, 0x05},{0x7623, 0x30},{0x7624, 0x07},
+	{0x7625, 0x00},{0x7626, 0x0f},{0x7627, 0x00},{0x7628, 0x04},{0x7629, 0xe5},
+	{0x762a, 0x05},{0x762b, 0x33},{0x762c, 0x06},{0x762d, 0x50},{0x762e, 0x00},
+	{0x762f, 0x01},{0x7630, 0x06},{0x7631, 0x5c},{0x7632, 0x04},{0x7633, 0xe4},
+	{0x7634, 0x00},{0x7635, 0x0e},{0x7636, 0x05},{0x7637, 0x30},{0x7638, 0x0f},
+	{0x7639, 0x00},{0x763a, 0x06},{0x763b, 0x24},{0x763c, 0x00},{0x763d, 0x03},
+	{0x763e, 0x05},{0x763f, 0x33},{0x7640, 0x07},{0x7641, 0x02},{0x7642, 0x06},
+	{0x7643, 0x24},{0x7644, 0x00},{0x7645, 0x01},{0x7646, 0x06},{0x7647, 0x20},
+	{0x7648, 0x0f},{0x7649, 0x00},{0x764a, 0x06},{0x764b, 0x14},{0x764c, 0x00},
+	{0x764d, 0x03},{0x764e, 0x05},{0x764f, 0x33},{0x7650, 0x07},{0x7651, 0x02},
+	{0x7652, 0x06},{0x7653, 0x14},{0x7654, 0x00},{0x7655, 0x01},{0x7656, 0x06},
+	{0x7657, 0x10},{0x7658, 0x0f},{0x7659, 0x00},{0x765a, 0x06},{0x765b, 0x10},
+	{0x765c, 0x0f},{0x765d, 0x00},{0x765e, 0x06},{0x765f, 0x20},{0x7660, 0x0f},
+	{0x7661, 0x00},{0x7662, 0x00},{0x7663, 0x00},{0x7664, 0x00},{0x7665, 0x02},
+	{0x7666, 0x04},{0x7667, 0xe5},{0x7668, 0x04},{0x7669, 0xe4},{0x766a, 0x0f},
+	{0x766b, 0x00},{0x766c, 0x00},{0x766d, 0x00},{0x766e, 0x00},{0x766f, 0x02},
+	{0x7670, 0x04},{0x7671, 0xe5},{0x7672, 0x04},{0x7673, 0xe4},{0x7674, 0x0f},
+	{0x7675, 0x00},{0x7676, 0x00},{0x7677, 0x02},{0x7678, 0x04},{0x7679, 0xe4},
+	{0x767a, 0x00},{0x767b, 0x02},{0x767c, 0x04},{0x767d, 0xc4},{0x767e, 0x00},
+	{0x767f, 0x04},{0x7680, 0x04},{0x7681, 0xc4},{0x7682, 0x05},{0x7683, 0x83},
+	{0x7684, 0x07},{0x7685, 0x02},{0x7686, 0x0f},{0x7687, 0x00},{0x7688, 0x00},
+	{0x7689, 0x02},{0x768a, 0x04},{0x768b, 0xe4},{0x768c, 0x00},{0x768d, 0x02},
+	{0x768e, 0x04},{0x768f, 0xc4},{0x7690, 0x00},{0x7691, 0x04},{0x7692, 0x04},
+	{0x7693, 0xc4},{0x7694, 0x05},{0x7695, 0x83},{0x7696, 0x07},{0x7697, 0x02},
+	{0x7698, 0x03},{0x7699, 0x0b},{0x769a, 0x05},{0x769b, 0x83},{0x769c, 0x00},
+	{0x769d, 0x08},{0x769e, 0x05},{0x769f, 0x03},{0x76a0, 0x05},{0x76a1, 0x32},
+	{0x76a2, 0x00},{0x76a3, 0x00},{0x76a4, 0x05},{0x76a5, 0x70},{0x76a6, 0x00},
+	{0x76a7, 0x01},{0x76a8, 0x05},{0x76a9, 0x74},{0x76aa, 0x03},{0x76ab, 0x9a},
+	{0x76ac, 0x05},{0x76ad, 0x83},{0x76ae, 0x00},{0x76af, 0x05},{0x76b0, 0x05},
+	{0x76b1, 0x03},{0x76b2, 0x05},{0x76b3, 0x32},{0x76b4, 0x00},{0x76b5, 0x00},
+	{0x76b6, 0x05},{0x76b7, 0x70},{0x76b8, 0x00},{0x76b9, 0x01},{0x76ba, 0x05},
+	{0x76bb, 0x74},{0x76bc, 0x03},{0x76bd, 0x99},{0x76be, 0x05},{0x76bf, 0x83},
+	{0x76c0, 0x00},{0x76c1, 0x03},{0x76c2, 0x05},{0x76c3, 0x03},{0x76c4, 0x05},
+	{0x76c5, 0x32},{0x76c6, 0x00},{0x76c7, 0x00},{0x76c8, 0x05},{0x76c9, 0x70},
+	{0x76ca, 0x00},{0x76cb, 0x01},{0x76cc, 0x05},{0x76cd, 0x74},{0x76ce, 0x03},
+	{0x76cf, 0x98},{0x76d0, 0x05},{0x76d1, 0x83},{0x76d2, 0x00},{0x76d3, 0x01},
+	{0x76d4, 0x05},{0x76d5, 0x03},{0x76d6, 0x05},{0x76d7, 0x32},{0x76d8, 0x00},
+	{0x76d9, 0x00},{0x76da, 0x05},{0x76db, 0x70},{0x76dc, 0x00},{0x76dd, 0x01},
+	{0x76de, 0x05},{0x76df, 0x74},{0x76e0, 0x03},{0x76e1, 0x97},{0x76e2, 0x05},
+	{0x76e3, 0x83},{0x76e4, 0x00},{0x76e5, 0x01},{0x76e6, 0x05},{0x76e7, 0x03},
+	{0x76e8, 0x05},{0x76e9, 0x32},{0x76ea, 0x00},{0x76eb, 0x00},{0x76ec, 0x05},
+	{0x76ed, 0x70},{0x76ee, 0x00},{0x76ef, 0x01},{0x76f0, 0x05},{0x76f1, 0x74},
+	{0x76f2, 0x03},{0x76f3, 0x96},{0x76f4, 0x05},{0x76f5, 0x83},{0x76f6, 0x00},
+	{0x76f7, 0x01},{0x76f8, 0x05},{0x76f9, 0x03},{0x76fa, 0x05},{0x76fb, 0x32},
+	{0x76fc, 0x00},{0x76fd, 0x00},{0x76fe, 0x05},{0x76ff, 0x70},{0x7700, 0x00},
+	{0x7701, 0x01},{0x7702, 0x05},{0x7703, 0x74},{0x7704, 0x03},{0x7705, 0x95},
+	{0x7706, 0x05},{0x7707, 0x83},{0x7708, 0x00},{0x7709, 0x01},{0x770a, 0x05},
+	{0x770b, 0x03},{0x770c, 0x05},{0x770d, 0x32},{0x770e, 0x00},{0x770f, 0x00},
+	{0x7710, 0x05},{0x7711, 0x70},{0x7712, 0x00},{0x7713, 0x01},{0x7714, 0x05},
+	{0x7715, 0x74},{0x7716, 0x03},{0x7717, 0x94},{0x7718, 0x05},{0x7719, 0x83},
+	{0x771a, 0x00},{0x771b, 0x03},{0x771c, 0x05},{0x771d, 0x03},{0x771e, 0x05},
+	{0x771f, 0x32},{0x7720, 0x00},{0x7721, 0x00},{0x7722, 0x05},{0x7723, 0x70},
+	{0x7724, 0x00},{0x7725, 0x01},{0x7726, 0x05},{0x7727, 0x74},{0x7728, 0x03},
+	{0x7729, 0x93},{0x772a, 0x05},{0x772b, 0x83},{0x772c, 0x00},{0x772d, 0x02},
+	{0x772e, 0x05},{0x772f, 0x03},{0x7730, 0x05},{0x7731, 0x32},{0x7732, 0x00},
+	{0x7733, 0x00},{0x7734, 0x05},{0x7735, 0x70},{0x7736, 0x00},{0x7737, 0x01},
+	{0x7738, 0x05},{0x7739, 0x74},{0x773a, 0x03},{0x773b, 0x92},{0x773c, 0x05},
+	{0x773d, 0x83},{0x773e, 0x00},{0x773f, 0x01},{0x7740, 0x05},{0x7741, 0x03},
+	{0x7742, 0x05},{0x7743, 0x32},{0x7744, 0x00},{0x7745, 0x00},{0x7746, 0x05},
+	{0x7747, 0x70},{0x7748, 0x00},{0x7749, 0x01},{0x774a, 0x05},{0x774b, 0x74},
+	{0x774c, 0x03},{0x774d, 0x91},{0x774e, 0x05},{0x774f, 0x83},{0x7750, 0x00},
+	{0x7751, 0x01},{0x7752, 0x05},{0x7753, 0x03},{0x7754, 0x05},{0x7755, 0x32},
+	{0x7756, 0x00},{0x7757, 0x00},{0x7758, 0x05},{0x7759, 0x70},{0x775a, 0x00},
+	{0x775b, 0x01},{0x775c, 0x05},{0x775d, 0x74},{0x775e, 0x03},{0x775f, 0x90},
+	{0x7760, 0x05},{0x7761, 0x83},{0x7762, 0x00},{0x7763, 0x01},{0x7764, 0x05},
+	{0x7765, 0x03},{0x7766, 0x05},{0x7767, 0x32},{0x7768, 0x00},{0x7769, 0x00},
+	{0x776a, 0x05},{0x776b, 0x70},{0x776c, 0x00},{0x776d, 0x01},{0x776e, 0x05},
+	{0x776f, 0x74},{0x7770, 0x02},{0x7771, 0x90},{0x7772, 0x05},{0x7773, 0x03},
+	{0x7774, 0x07},{0x7775, 0x00},{0x7776, 0x0f},{0x7777, 0x00},{0x7778, 0x08},
+	{0x7779, 0x31},{0x777a, 0x08},{0x777b, 0xd1},{0x777c, 0x0f},{0x777d, 0x00},
+	{0x777e, 0x04},{0x777f, 0xe5},{0x7780, 0x06},{0x7781, 0x50},{0x7782, 0x04},
+	{0x7783, 0xe4},{0x7784, 0x00},{0x7785, 0x00},{0x7786, 0x06},{0x7787, 0x5c},
+	{0x7788, 0x09},{0x7789, 0x14},{0x778a, 0x06},{0x778b, 0x1c},{0x778c, 0x00},
+	{0x778d, 0x02},{0x778e, 0x06},{0x778f, 0xa0},{0x7790, 0x00},{0x7791, 0x01},
+	{0x7792, 0x06},{0x7793, 0xac},{0x7794, 0x00},{0x7795, 0x0f},{0x7796, 0x05},
+	{0x7797, 0x30},{0x7798, 0x0f},{0x7799, 0x00},{0x779a, 0x00},{0x779b, 0x00},
+	{0x779c, 0x00},{0x779d, 0x02},{0x779e, 0x04},{0x779f, 0xe5},{0x77a0, 0x04},
+	{0x77a1, 0xe4},{0x77a2, 0x07},{0x77a3, 0x10},{0x77a4, 0x00},{0x77a5, 0x00},
+	{0x77a6, 0x07},{0x77a7, 0x00},{0x77a8, 0x01},{0x77a9, 0xbb},{0x77aa, 0x07},
+	{0x77ab, 0x10},{0x77ac, 0x00},{0x77ad, 0x00},{0x77ae, 0x07},{0x77af, 0x00},
+	{0x77b0, 0x01},{0x77b1, 0xaa},{0x77b2, 0x07},{0x77b3, 0x10},{0x77b4, 0x00},
+	{0x77b5, 0x00},{0x77b6, 0x07},{0x77b7, 0x00},{0x77b8, 0x01},{0x77b9, 0x99},
+	{0x77ba, 0x07},{0x77bb, 0x10},{0x77bc, 0x00},{0x77bd, 0x00},{0x77be, 0x07},
+	{0x77bf, 0x00},{0x77c0, 0x01},{0x77c1, 0x88},{0x77c2, 0x07},{0x77c3, 0x10},
+	{0x77c4, 0x00},{0x77c5, 0x00},{0x77c6, 0x07},{0x77c7, 0x00},{0x77c8, 0x01},
+	{0x77c9, 0x77},{0x77ca, 0x07},{0x77cb, 0x10},{0x77cc, 0x00},{0x77cd, 0x00},
+	{0x77ce, 0x07},{0x77cf, 0x00},{0x77d0, 0x01},{0x77d1, 0x66},{0x77d2, 0x07},
+	{0x77d3, 0x10},{0x77d4, 0x00},{0x77d5, 0x00},{0x77d6, 0x07},{0x77d7, 0x00},
+	{0x77d8, 0x01},{0x77d9, 0x55},{0x77da, 0x07},{0x77db, 0x10},{0x77dc, 0x00},
+	{0x77dd, 0x00},{0x77de, 0x07},{0x77df, 0x00},{0x77e0, 0x01},{0x77e1, 0x44},
+	{0x77e2, 0x07},{0x77e3, 0x10},{0x77e4, 0x00},{0x77e5, 0x00},{0x77e6, 0x07},
+	{0x77e7, 0x00},{0x77e8, 0x01},{0x77e9, 0x33},{0x77ea, 0x07},{0x77eb, 0x10},
+	{0x77ec, 0x00},{0x77ed, 0x00},{0x77ee, 0x07},{0x77ef, 0x00},{0x77f0, 0x01},
+	{0x77f1, 0x22},{0x77f2, 0x07},{0x77f3, 0x10},{0x77f4, 0x00},{0x77f5, 0x00},
+	{0x77f6, 0x07},{0x77f7, 0x00},{0x77f8, 0x01},{0x77f9, 0x11},{0x77fa, 0x07},
+	{0x77fb, 0x10},{0x77fc, 0x00},{0x77fd, 0x00},{0x77fe, 0x07},{0x77ff, 0x00},
+	{0x7800, 0x01},{0x7801, 0x00},{0x7802, 0x01},{0x7803, 0xff},{0x7804, 0x07},
+	{0x7805, 0x00},{0x7806, 0x02},{0x7807, 0xa0},{0x7808, 0x05},{0x7809, 0x33},
+	{0x780a, 0x0f},{0x780b, 0x00},{0x780c, 0x08},{0x780d, 0x36},{0x780e, 0x06},
+	{0x780f, 0x50},{0x7810, 0x04},{0x7811, 0xe4},{0x7812, 0x00},{0x7813, 0x00},
+	{0x7814, 0x06},{0x7815, 0x5c},{0x7816, 0x09},{0x7817, 0x14},{0x7818, 0x06},
+	{0x7819, 0x1c},{0x781a, 0x05},{0x781b, 0x33},{0x781c, 0x00},{0x781d, 0x01},
+	{0x781e, 0x06},{0x781f, 0x24},{0x7820, 0x00},{0x7821, 0x01},{0x7822, 0x06},
+	{0x7823, 0x20},{0x7824, 0x0f},{0x7825, 0x00},{0x7826, 0x08},{0x7827, 0x36},
+	{0x7828, 0x07},{0x7829, 0x10},{0x782a, 0x00},{0x782b, 0x00},{0x782c, 0x07},
+	{0x782d, 0x00},{0x782e, 0x01},{0x782f, 0xbb},{0x7830, 0x07},{0x7831, 0x10},
+	{0x7832, 0x00},{0x7833, 0x00},{0x7834, 0x07},{0x7835, 0x00},{0x7836, 0x01},
+	{0x7837, 0xaa},{0x7838, 0x07},{0x7839, 0x10},{0x783a, 0x00},{0x783b, 0x00},
+	{0x783c, 0x07},{0x783d, 0x00},{0x783e, 0x01},{0x783f, 0x99},{0x7840, 0x07},
+	{0x7841, 0x10},{0x7842, 0x00},{0x7843, 0x00},{0x7844, 0x07},{0x7845, 0x00},
+	{0x7846, 0x01},{0x7847, 0x88},{0x7848, 0x07},{0x7849, 0x10},{0x784a, 0x00},
+	{0x784b, 0x00},{0x784c, 0x07},{0x784d, 0x00},{0x784e, 0x01},{0x784f, 0x77},
+	{0x7850, 0x07},{0x7851, 0x10},{0x7852, 0x00},{0x7853, 0x00},{0x7854, 0x07},
+	{0x7855, 0x00},{0x7856, 0x01},{0x7857, 0x66},{0x7858, 0x07},{0x7859, 0x10},
+	{0x785a, 0x00},{0x785b, 0x00},{0x785c, 0x07},{0x785d, 0x00},{0x785e, 0x01},
+	{0x785f, 0x55},{0x7860, 0x07},{0x7861, 0x10},{0x7862, 0x00},{0x7863, 0x00},
+	{0x7864, 0x07},{0x7865, 0x00},{0x7866, 0x01},{0x7867, 0x44},{0x7868, 0x07},
+	{0x7869, 0x10},{0x786a, 0x00},{0x786b, 0x00},{0x786c, 0x07},{0x786d, 0x00},
+	{0x786e, 0x01},{0x786f, 0x33},{0x7870, 0x07},{0x7871, 0x10},{0x7872, 0x00},
+	{0x7873, 0x00},{0x7874, 0x07},{0x7875, 0x00},{0x7876, 0x01},{0x7877, 0x22},
+	{0x7878, 0x07},{0x7879, 0x10},{0x787a, 0x00},{0x787b, 0x00},{0x787c, 0x07},
+	{0x787d, 0x00},{0x787e, 0x01},{0x787f, 0x11},{0x7880, 0x07},{0x7881, 0x10},
+	{0x7882, 0x00},{0x7883, 0x00},{0x7884, 0x07},{0x7885, 0x00},{0x7886, 0x01},
+	{0x7887, 0x00},{0x7888, 0x01},{0x7889, 0xff},{0x788a, 0x02},{0x788b, 0xa0},
+	{0x788c, 0x05},{0x788d, 0x33},{0x788e, 0x0f},{0x788f, 0x00},{0x7890, 0x08},
+	{0x7891, 0x3b},{0x7892, 0x08},{0x7893, 0x5e},{0x7894, 0x0f},{0x7895, 0x00},
+	{0x7896, 0x04},{0x7897, 0xc0},{0x7898, 0x09},{0x7899, 0x14},{0x789a, 0x04},
+	{0x789b, 0x99},{0x789c, 0x07},{0x789d, 0x14},{0x789e, 0x04},{0x789f, 0x80},
+	{0x78a0, 0x04},{0x78a1, 0xa4},{0x78a2, 0x00},{0x78a3, 0x0a},{0x78a4, 0x04},
+	{0x78a5, 0xa6},{0x78a6, 0x00},{0x78a7, 0x00},{0x78a8, 0x04},{0x78a9, 0xa0},
+	{0x78aa, 0x04},{0x78ab, 0x80},{0x78ac, 0x04},{0x78ad, 0x00},{0x78ae, 0x05},
+	{0x78af, 0x03},{0x78b0, 0x06},{0x78b1, 0x00},{0x78b2, 0x0f},{0x78b3, 0x00},
+	{0x78b4, 0x0f},{0x78b5, 0x00},{0x78b6, 0x0f},{0x78b7, 0x00},{0x31a0, 0x00},
+	{0x30b0, 0x08},{0x30b1, 0x20},{0x30b2, 0x04},{0x30b3, 0xB3},{0x30b6, 0x00},
+	{0x30b9, 0x02},{0x30bb, 0x00},{0x3197, 0x00},{0x3195, 0x28},{0x315a, 0x02},
+	{0x315b, 0x00},{0x315c, 0x02},{0x315d, 0x86},{0x315e, 0x02},{0x315f, 0x86},
+	{0x304b, 0x00},{0x304d, 0xa4},{0x3033, 0x30},
+
+	/* mirror on */
+	{0x30c0, 0x04},{0x30a9, 0x05},{0x3252, 0x21},
+
+	{0x3012, 0x01},{0x3030, 0x02},
+};
+
+static struct vin_reg_16_8 ov2718_12b_combined_hdr_regs[] = {
+	/* MIPI Combined 12bit 1928x1088 30fps 600Mbps v1.0 */
+	{0x3013, 0x01},{0x3000, 0x05},{0x3001, 0x64},{0x3002, 0x07},{0x3003, 0x01},
+	{0x3004, 0x06},{0x3005, 0x49},{0x3006, 0x00},{0x3007, 0x07},{0x3008, 0x01},
+	{0x3009, 0x00},{0x300c, 0x6c},{0x300d, 0xe1},{0x300e, 0x80},{0x300f, 0x00},
+	{0x3012, 0x00},{0x3013, 0x00},{0x3014, 0x84},{0x3015, 0x00},{0x3017, 0x00},
+	{0x3018, 0x00},{0x3019, 0x00},{0x301a, 0x00},{0x301b, 0x01},{0x301e, 0x10},
+	{0x301f, 0x5f},{0x3030, 0x0a},{0x3031, 0x63},{0x3032, 0xf0},{0x3033, 0x30},
+	{0x3034, 0x34},{0x3035, 0x51},{0x3036, 0x02},{0x3037, 0x9f},{0x3038, 0x04},
+	{0x3039, 0xb7},{0x303a, 0x04},{0x303b, 0x07},{0x303c, 0xf0},{0x303d, 0x00},
+	{0x303e, 0x0b},{0x303f, 0xe3},{0x3040, 0xf3},{0x3041, 0x29},{0x3042, 0xf6},
+	{0x3043, 0x65},{0x3044, 0x06},{0x3045, 0x0f},{0x3046, 0x55},{0x3047, 0xf7},
+	{0x3048, 0x31},{0x3049, 0x0f},{0x304a, 0x10},{0x304b, 0xc0},{0x304c, 0x33},
+	{0x304d, 0x24},{0x304e, 0x0b},{0x304f, 0x3d},{0x3050, 0x10},{0x3060, 0x00},
+	{0x3061, 0x64},{0x3062, 0x01},{0x3063, 0x00},{0x3064, 0x0b},{0x3065, 0xf8},
+	{0x3066, 0x80},{0x3080, 0x00},{0x3081, 0x00},{0x3082, 0x01},{0x3083, 0xe3},
+	{0x3084, 0x05},{0x3085, 0x00},{0x3086, 0x10},{0x3087, 0x10},{0x3089, 0x00},
+	{0x308a, 0x01},{0x3093, 0x00},{0x30a0, 0x00},{0x30a1, 0x00},{0x30a2, 0x00},
+	{0x30a3, 0x00},{0x30a4, 0x07},{0x30a5, 0x8f},{0x30a6, 0x04},{0x30a7, 0x47},
+	{0x30a8, 0x00},{0x30a9, 0x04},{0x30aa, 0x00},{0x30ab, 0x04},{0x30ac, 0x07},
+	{0x30ad, 0x88},{0x30ae, 0x04},{0x30af, 0x40},{0x30b0, 0x08},{0x30b1, 0xae},
+	{0x30b2, 0x04},{0x30b3, 0x65},{0x30b4, 0x00},{0x30b5, 0x00},{0x30b6, 0x00},
+	{0x30b7, 0x10},{0x30b8, 0x00},{0x30b9, 0x02},{0x30ba, 0x10},{0x30bb, 0x00},
+	{0x30bc, 0x00},{0x30bd, 0x03},{0x30be, 0x5c},{0x30bf, 0x00},{0x30c0, 0x00},
+	{0x30c1, 0x00},{0x30c2, 0x20},{0x30c3, 0x00},{0x30c4, 0x4a},{0x30c5, 0x00},
+	{0x30c7, 0x00},{0x30c8, 0x00},{0x30d1, 0x00},{0x30d2, 0x00},{0x30d3, 0x80},
+	{0x30d4, 0x00},{0x30d9, 0x09},{0x30da, 0x64},{0x30dd, 0x00},{0x30de, 0x16},
+	{0x30df, 0x00},{0x30e0, 0x17},{0x30e1, 0x00},{0x30e2, 0x18},{0x30e3, 0x10},
+	{0x30e4, 0x04},{0x30e5, 0x00},{0x30e6, 0x00},{0x30e7, 0x00},{0x30e8, 0x00},
+	{0x30e9, 0x00},{0x30ea, 0x00},{0x30eb, 0x00},{0x30ec, 0x00},{0x30ed, 0x00},
+	{0x3101, 0x00},{0x3102, 0x00},{0x3103, 0x00},{0x3104, 0x00},{0x3105, 0x6c},
+	{0x3106, 0x83},{0x3107, 0x72},{0x3108, 0x70},{0x3109, 0x6c},{0x310a, 0x83},
+	{0x310b, 0x69},{0x310c, 0x43},{0x310d, 0x42},{0x310e, 0x00},{0x3120, 0x00},
+	{0x3121, 0x00},{0x3122, 0x00},{0x3123, 0xf0},{0x3124, 0x00},{0x3125, 0xa0},
+	{0x3126, 0x3f},{0x3127, 0x0f},{0x3128, 0x00},{0x3129, 0x3a},{0x312a, 0x02},
+	{0x312b, 0x0f},{0x312c, 0x00},{0x312d, 0x0f},{0x312e, 0x1d},{0x312f, 0x00},
+	{0x3130, 0x00},{0x3131, 0x00},{0x3132, 0x00},{0x3140, 0x02},{0x3141, 0x07},
+	{0x3142, 0x00},{0x3143, 0x00},{0x3144, 0x00},{0x3145, 0x00},{0x3146, 0x00},
+	{0x3147, 0x00},{0x3148, 0x00},{0x3149, 0x00},{0x314a, 0x00},{0x314b, 0x00},
+	{0x314c, 0x00},{0x314d, 0x00},{0x314e, 0x1c},{0x314f, 0x10},{0x3150, 0x10},
+	{0x3151, 0x10},{0x3152, 0x80},{0x3153, 0x80},{0x3154, 0x80},{0x3155, 0x00},
+	{0x3156, 0x01},{0x3157, 0x00},{0x3158, 0x0f},{0x3159, 0xff},{0x315a, 0x01},
+	{0x315b, 0x00},{0x315c, 0x01},{0x315d, 0x00},{0x315e, 0x01},{0x315f, 0x00},
+	{0x3160, 0x00},{0x3161, 0x40},{0x3162, 0x00},{0x3163, 0x40},{0x3164, 0x00},
+	{0x3165, 0x40},{0x3190, 0x02},{0x3191, 0x99},{0x3193, 0x08},{0x3194, 0x13},
+	{0x3195, 0x33},{0x3196, 0x00},{0x3197, 0x10},{0x3198, 0x00},{0x3199, 0x7f},
+	{0x319a, 0x00},{0x319b, 0x00},{0x319c, 0x80},{0x319d, 0xbf},{0x319e, 0xc0},
+	{0x319f, 0xff},{0x31a0, 0x24},{0x31a1, 0x55},{0x31a2, 0x00},{0x31a3, 0x00},
+	{0x31a6, 0x00},{0x31a7, 0x00},{0x31b0, 0x00},{0x31b1, 0x00},{0x31b2, 0x02},
+	{0x31b3, 0x00},{0x31b4, 0x00},{0x31b5, 0x01},{0x31b6, 0x00},{0x31b7, 0x00},
+	{0x31b8, 0x00},{0x31b9, 0x00},{0x31ba, 0x00},{0x31d0, 0x3c},{0x31d1, 0x34},
+	{0x31d2, 0x3c},{0x31d3, 0x00},{0x31d4, 0x2d},{0x31d5, 0x00},{0x31d6, 0x01},
+	{0x31d7, 0x06},{0x31d8, 0x00},{0x31d9, 0x64},{0x31da, 0x00},{0x31db, 0x28},
+	{0x31dc, 0x04},{0x31dd, 0x69},{0x31de, 0x0a},{0x31df, 0x3c},{0x31e0, 0x04},
+	{0x31e1, 0x32},{0x31e2, 0x00},{0x31e3, 0x01},{0x31e4, 0x0d},{0x31e5, 0x80},
+	{0x31e6, 0x00},{0x31e7, 0x2c},{0x31e8, 0x6c},{0x31e9, 0xac},{0x31ea, 0xec},
+	{0x31eb, 0x3f},{0x31ec, 0x0f},{0x31ed, 0x20},{0x31ee, 0x04},{0x31ef, 0x48},
+	{0x31f0, 0x07},{0x31f1, 0x90},{0x31f2, 0x04},{0x31f3, 0x48},{0x31f4, 0x07},
+	{0x31f5, 0x90},{0x31f6, 0x04},{0x31f7, 0x48},{0x31f8, 0x07},{0x31f9, 0x90},
+	{0x31fa, 0x04},{0x31fb, 0x48},{0x31fd, 0xcb},{0x31fe, 0x0f},{0x31ff, 0x03},
+	{0x3200, 0x00},{0x3201, 0xff},{0x3202, 0x00},{0x3203, 0xff},{0x3204, 0xff},
+	{0x3205, 0xff},{0x3206, 0xff},{0x3207, 0xff},{0x3208, 0xff},{0x3209, 0xff},
+	{0x320a, 0xff},{0x320b, 0x1b},{0x320c, 0x1f},{0x320d, 0x1e},{0x320e, 0x30},
+	{0x320f, 0x2d},{0x3210, 0x2c},{0x3211, 0x2b},{0x3212, 0x2a},{0x3213, 0x24},
+	{0x3214, 0x22},{0x3215, 0x00},{0x3216, 0x04},{0x3217, 0x2c},{0x3218, 0x6c},
+	{0x3219, 0xac},{0x321a, 0xec},{0x321b, 0x00},{0x3230, 0x3a},{0x3231, 0x00},
+	{0x3232, 0x80},{0x3233, 0x00},{0x3234, 0x10},{0x3235, 0xaa},{0x3236, 0x55},
+	{0x3237, 0x99},{0x3238, 0x66},{0x3239, 0x08},{0x323a, 0x88},{0x323b, 0x00},
+	{0x323c, 0x00},{0x323d, 0x03},{0x3250, 0x33},{0x3251, 0x00},{0x3252, 0x20},
+	{0x3253, 0x00},{0x3254, 0x11},{0x3255, 0x01},{0x3256, 0x00},{0x3257, 0x00},
+	{0x3258, 0x00},{0x3270, 0x01},{0x3271, 0x60},{0x3272, 0xc0},{0x3273, 0x00},
+	{0x3274, 0x80},{0x3275, 0x40},{0x3276, 0x02},{0x3277, 0x08},{0x3278, 0x10},
+	{0x3279, 0x04},{0x327a, 0x00},{0x327b, 0x03},{0x327c, 0x10},{0x327d, 0x60},
+	{0x327e, 0xc0},{0x327f, 0x06},{0x3288, 0x10},{0x3289, 0x00},{0x328a, 0x08},
+	{0x328b, 0x00},{0x328c, 0x04},{0x328d, 0x00},{0x328e, 0x02},{0x328f, 0x00},
+	{0x3290, 0x20},{0x3291, 0x00},{0x3292, 0x10},{0x3293, 0x00},{0x3294, 0x08},
+	{0x3295, 0x00},{0x3296, 0x04},{0x3297, 0x00},{0x3298, 0x40},{0x3299, 0x00},
+	{0x329a, 0x20},{0x329b, 0x00},{0x329c, 0x10},{0x329d, 0x00},{0x329e, 0x08},
+	{0x329f, 0x00},{0x32a0, 0x7f},{0x32a1, 0xff},{0x32a2, 0x40},{0x32a3, 0x00},
+	{0x32a4, 0x20},{0x32a5, 0x00},{0x32a6, 0x10},{0x32a7, 0x00},{0x32a8, 0x00},
+	{0x32a9, 0x00},{0x32aa, 0x00},{0x32ab, 0x00},{0x32ac, 0x00},{0x32ad, 0x00},
+	{0x32ae, 0x00},{0x32af, 0x00},{0x32b0, 0x00},{0x32b1, 0x00},{0x32b2, 0x00},
+	{0x32b3, 0x00},{0x32b4, 0x00},{0x32b5, 0x00},{0x32b6, 0x00},{0x32b7, 0x00},
+	{0x32b8, 0x00},{0x32b9, 0x00},{0x32ba, 0x00},{0x32bb, 0x00},{0x32bc, 0x00},
+	{0x32bd, 0x00},{0x32be, 0x00},{0x32bf, 0x00},{0x32c0, 0x00},{0x32c1, 0x00},
+	{0x32c2, 0x00},{0x32c3, 0x00},{0x32c4, 0x00},{0x32c5, 0x00},{0x32c6, 0x00},
+	{0x32c7, 0x00},{0x32c8, 0x87},{0x32c9, 0x00},{0x3330, 0x03},{0x3331, 0xc8},
+	{0x3332, 0x02},{0x3333, 0x24},{0x3334, 0x00},{0x3335, 0x00},{0x3336, 0x00},
+	{0x3337, 0x00},{0x3338, 0x03},{0x3339, 0xc8},{0x333a, 0x02},{0x333b, 0x24},
+	{0x333c, 0x00},{0x333d, 0x00},{0x333e, 0x00},{0x333f, 0x00},{0x3340, 0x03},
+	{0x3341, 0xc8},{0x3342, 0x02},{0x3343, 0x24},{0x3344, 0x00},{0x3345, 0x00},
+	{0x3346, 0x00},{0x3347, 0x00},{0x3348, 0x40},{0x3349, 0x00},{0x334a, 0x00},
+	{0x334b, 0x00},{0x334c, 0x00},{0x334d, 0x00},{0x334e, 0x80},{0x3360, 0x01},
+	{0x3361, 0x00},{0x3362, 0x01},{0x3363, 0x00},{0x3364, 0x01},{0x3365, 0x00},
+	{0x3366, 0x01},{0x3367, 0x00},{0x3368, 0x01},{0x3369, 0x00},{0x336a, 0x01},
+	{0x336b, 0x00},{0x336c, 0x01},{0x336d, 0x00},{0x336e, 0x01},{0x336f, 0x00},
+	{0x3370, 0x01},{0x3371, 0x00},{0x3372, 0x01},{0x3373, 0x00},{0x3374, 0x01},
+	{0x3375, 0x00},{0x3376, 0x01},{0x3377, 0x00},{0x3378, 0x00},{0x3379, 0x00},
+	{0x337a, 0x00},{0x337b, 0x00},{0x337c, 0x00},{0x337d, 0x00},{0x337e, 0x00},
+	{0x337f, 0x00},{0x3380, 0x00},{0x3381, 0x00},{0x3382, 0x00},{0x3383, 0x00},
+	{0x3384, 0x00},{0x3385, 0x00},{0x3386, 0x00},{0x3387, 0x00},{0x3388, 0x00},
+	{0x3389, 0x00},{0x338a, 0x00},{0x338b, 0x00},{0x338c, 0x00},{0x338d, 0x00},
+	{0x338e, 0x00},{0x338f, 0x00},{0x3390, 0x00},{0x3391, 0x00},{0x3392, 0x00},
+	{0x3393, 0x00},{0x3394, 0x00},{0x3395, 0x00},{0x3396, 0x00},{0x3397, 0x00},
+	{0x3398, 0x00},{0x3399, 0x00},{0x339a, 0x00},{0x339b, 0x00},{0x33b0, 0x00},
+	{0x33b1, 0x50},{0x33b2, 0x01},{0x33b3, 0xff},{0x33b4, 0xe0},{0x33b5, 0x6b},
+	{0x33b6, 0x00},{0x33b7, 0x00},{0x33b8, 0x00},{0x33b9, 0x00},{0x33ba, 0x00},
+	{0x33bb, 0x1f},{0x33bc, 0x01},{0x33bd, 0x01},{0x33be, 0x01},{0x33bf, 0x01},
+	{0x33c0, 0x00},{0x33c1, 0x00},{0x33c2, 0x00},{0x33c3, 0x00},{0x33e0, 0x14},
+	{0x33e1, 0x0f},{0x33e2, 0x04},{0x33e3, 0x02},{0x33e4, 0x01},{0x33e5, 0x01},
+	{0x33e6, 0x00},{0x33e7, 0x04},{0x33e8, 0x0c},{0x33e9, 0x00},{0x33ea, 0x01},
+	{0x33eb, 0x02},{0x33ec, 0x03},{0x33ed, 0x03},{0x33ee, 0x0f},{0x33ef, 0x3f},
+	{0x33f0, 0x08},{0x33f1, 0x04},{0x33f2, 0x04},{0x33f3, 0x00},{0x33f4, 0x03},
+	{0x33f5, 0x14},{0x33f6, 0x0f},{0x33f7, 0x04},{0x33f8, 0x02},{0x33f9, 0x01},
+	{0x33fa, 0x01},{0x33fb, 0x00},{0x33fc, 0x04},{0x33fd, 0x0c},{0x33fe, 0x00},
+	{0x33ff, 0x01},{0x3400, 0x02},{0x3401, 0x03},{0x3402, 0x03},{0x3403, 0x0f},
+	{0x3404, 0x3f},{0x3405, 0x08},{0x3406, 0x04},{0x3407, 0x04},{0x3408, 0x00},
+	{0x3409, 0x03},{0x340a, 0x14},{0x340b, 0x0f},{0x340c, 0x04},{0x340d, 0x02},
+	{0x340e, 0x01},{0x340f, 0x01},{0x3410, 0x00},{0x3411, 0x04},{0x3412, 0x0c},
+	{0x3413, 0x00},{0x3414, 0x01},{0x3415, 0x02},{0x3416, 0x03},{0x3417, 0x03},
+	{0x3418, 0x0f},{0x3419, 0x3f},{0x341a, 0x08},{0x341b, 0x04},{0x341c, 0x04},
+	{0x341d, 0x00},{0x341e, 0x03},{0x3440, 0x00},{0x3441, 0x00},{0x3442, 0x00},
+	{0x3443, 0x00},{0x3444, 0x02},{0x3445, 0xf0},{0x3446, 0x02},{0x3447, 0x08},
+	{0x3448, 0x00},{0x3460, 0x40},{0x3461, 0x40},{0x3462, 0x40},{0x3463, 0x40},
+	{0x3464, 0x03},{0x3465, 0x01},{0x3466, 0x01},{0x3467, 0x02},{0x3468, 0x30},
+	{0x3469, 0x00},{0x346a, 0x35},{0x346b, 0x00},{0x3480, 0x40},{0x3481, 0x00},
+	{0x3482, 0x00},{0x3483, 0x00},{0x3484, 0x07},{0x3485, 0x00},{0x3486, 0x00},
+	{0x3487, 0x00},{0x3488, 0x00},{0x3489, 0x00},{0x348a, 0x00},{0x348b, 0x04},
+	{0x348c, 0x00},{0x348d, 0x01},{0x348f, 0x01},{0x7000, 0xda},{0x7001, 0xcf},
+	{0x7002, 0xac},{0x7003, 0xd0},{0x7004, 0xac},{0x7005, 0xd1},{0x7006, 0x50},
+	{0x7007, 0xb6},{0x7008, 0xee},{0x7009, 0xac},{0x700a, 0xd2},{0x700b, 0xdc},
+	{0x700c, 0xdf},{0x700d, 0x0f},{0x700e, 0xe1},{0x700f, 0x36},{0x7010, 0x30},
+	{0x7011, 0xd3},{0x7012, 0x2e},{0x7013, 0x54},{0x7014, 0x46},{0x7015, 0xb4},
+	{0x7016, 0x00},{0x7017, 0x1a},{0x7018, 0xc1},{0x7019, 0x0e},{0x701a, 0xe8},
+	{0x701b, 0x00},{0x701c, 0xe6},{0x701d, 0xb0},{0x701e, 0x6e},{0x701f, 0xbd},
+	{0x7020, 0x01},{0x7021, 0xd7},{0x7022, 0xed},{0x7023, 0xbc},{0x7024, 0x22},
+	{0x7025, 0xb9},{0x7026, 0x66},{0x7027, 0x2c},{0x7028, 0x28},{0x7029, 0x19},
+	{0x702a, 0xc1},{0x702b, 0x32},{0x702c, 0xa1},{0x702d, 0xac},{0x702e, 0xd8},
+	{0x702f, 0xd6},{0x7030, 0xb4},{0x7031, 0x04},{0x7032, 0x46},{0x7033, 0xb7},
+	{0x7034, 0x00},{0x7035, 0xbe},{0x7036, 0x08},{0x7037, 0xc3},{0x7038, 0xdb},
+	{0x7039, 0xad},{0x703a, 0xc3},{0x703b, 0xbf},{0x703c, 0x50},{0x703d, 0x20},
+	{0x703e, 0xb8},{0x703f, 0x02},{0x7040, 0xbc},{0x7041, 0x17},{0x7042, 0xdb},
+	{0x7043, 0xa0},{0x7044, 0xb8},{0x7045, 0x00},{0x7046, 0x28},{0x7047, 0x54},
+	{0x7048, 0xb4},{0x7049, 0xbc},{0x704a, 0xbe},{0x704b, 0x06},{0x704c, 0xd8},
+	{0x704d, 0xd6},{0x704e, 0x00},{0x704f, 0xb9},{0x7050, 0x64},{0x7051, 0xee},
+	{0x7052, 0xe8},{0x7053, 0xb4},{0x7054, 0x14},{0x7055, 0xab},{0x7056, 0xbc},
+	{0x7057, 0x17},{0x7058, 0x62},{0x7059, 0x07},{0x705a, 0xb9},{0x705b, 0x05},
+	{0x705c, 0xad},{0x705d, 0xb4},{0x705e, 0x25},{0x705f, 0xc3},{0x7060, 0xc1},
+	{0x7061, 0x00},{0x7062, 0xc0},{0x7063, 0x42},{0x7064, 0x50},{0x7065, 0x20},
+	{0x7066, 0x04},{0x7067, 0xb8},{0x7068, 0x02},{0x7069, 0xdb},{0x706a, 0xd8},
+	{0x706b, 0xac},{0x706c, 0xb7},{0x706d, 0x00},{0x706e, 0xbc},{0x706f, 0x11},
+	{0x7070, 0xd6},{0x7071, 0xc7},{0x7072, 0xb8},{0x7073, 0x00},{0x7074, 0x28},
+	{0x7075, 0x54},{0x7076, 0xb4},{0x7077, 0x04},{0x7078, 0x46},{0x7079, 0xbe},
+	{0x707a, 0x06},{0x707b, 0xc3},{0x707c, 0xdb},{0x707d, 0xbd},{0x707e, 0x03},
+	{0x707f, 0xee},{0x7080, 0xad},{0x7081, 0xc3},{0x7082, 0xbf},{0x7083, 0x00},
+	{0x7084, 0xec},{0x7085, 0x00},{0x7086, 0x15},{0x7087, 0xc2},{0x7088, 0x47},
+	{0x7089, 0xc3},{0x708a, 0xb7},{0x708b, 0xc0},{0x708c, 0x43},{0x708d, 0x00},
+	{0x708e, 0x00},{0x708f, 0x00},{0x7090, 0xb9},{0x7091, 0x64},{0x7092, 0x29},
+	{0x7093, 0x00},{0x7094, 0xb8},{0x7095, 0x12},{0x7096, 0xbe},{0x7097, 0x01},
+	{0x7098, 0xd0},{0x7099, 0xbc},{0x709a, 0x01},{0x709b, 0xac},{0x709c, 0x37},
+	{0x709d, 0xd1},{0x709e, 0xac},{0x709f, 0xd2},{0x70a0, 0xac},{0x70a1, 0xad},
+	{0x70a2, 0x28},{0x70a3, 0x00},{0x70a4, 0xb8},{0x70a5, 0x00},{0x70a6, 0xbc},
+	{0x70a7, 0x01},{0x70a8, 0xe1},{0x70a9, 0x36},{0x70aa, 0xd3},{0x70ab, 0x30},
+	{0x70ac, 0x04},{0x70ad, 0xe0},{0x70ae, 0xd8},{0x70af, 0xb4},{0x70b0, 0xcd},
+	{0x70b1, 0x45},{0x70b2, 0x00},{0x70b3, 0xe8},{0x70b4, 0xbe},{0x70b5, 0x05},
+	{0x70b6, 0xbc},{0x70b7, 0x1e},{0x70b8, 0x62},{0x70b9, 0x07},{0x70ba, 0xb9},
+	{0x70bb, 0x05},{0x70bc, 0xad},{0x70bd, 0xc3},{0x70be, 0xd2},{0x70bf, 0x00},
+	{0x70c0, 0x15},{0x70c1, 0xc2},{0x70c2, 0x64},{0x70c3, 0xc3},{0x70c4, 0xcd},
+	{0x70c5, 0xc0},{0x70c6, 0x60},{0x70c7, 0x00},{0x70c8, 0x46},{0x70c9, 0x00},
+	{0x70ca, 0x00},{0x70cb, 0x19},{0x70cc, 0xc1},{0x70cd, 0x7e},{0x70ce, 0xa1},
+	{0x70cf, 0xb9},{0x70d0, 0x64},{0x70d1, 0x29},{0x70d2, 0x00},{0x70d3, 0xb8},
+	{0x70d4, 0x02},{0x70d5, 0xbe},{0x70d6, 0x02},{0x70d7, 0xd0},{0x70d8, 0xdc},
+	{0x70d9, 0xac},{0x70da, 0xbc},{0x70db, 0x01},{0x70dc, 0x37},{0x70dd, 0xd1},
+	{0x70de, 0xac},{0x70df, 0xd2},{0x70e0, 0xad},{0x70e1, 0x28},{0x70e2, 0x00},
+	{0x70e3, 0xb8},{0x70e4, 0x00},{0x70e5, 0xbc},{0x70e6, 0x01},{0x70e7, 0xe1},
+	{0x70e8, 0x36},{0x70e9, 0x30},{0x70ea, 0xe0},{0x70eb, 0xd8},{0x70ec, 0xb5},
+	{0x70ed, 0x06},{0x70ee, 0x45},{0x70ef, 0xd6},{0x70f0, 0xbe},{0x70f1, 0x07},
+	{0x70f2, 0x00},{0x70f3, 0xe8},{0x70f4, 0x62},{0x70f5, 0x07},{0x70f6, 0xb9},
+	{0x70f7, 0x05},{0x70f8, 0xad},{0x70f9, 0xc3},{0x70fa, 0xd2},{0x70fb, 0x46},
+	{0x70fc, 0xd5},{0x70fd, 0xe3},{0x70fe, 0x18},{0x70ff, 0xc2},{0x7100, 0xae},
+	{0x7101, 0xb9},{0x7102, 0x64},{0x7103, 0xd1},{0x7104, 0x50},{0x7105, 0xdd},
+	{0x7106, 0xac},{0x7107, 0xcf},{0x7108, 0xdf},{0x7109, 0xb6},{0x710a, 0xee},
+	{0x710b, 0xbc},{0x710c, 0x13},{0x710d, 0xe1},{0x710e, 0x36},{0x710f, 0x30},
+	{0x7110, 0xd3},{0x7111, 0x2e},{0x7112, 0x54},{0x7113, 0xbc},{0x7114, 0x32},
+	{0x7115, 0x2c},{0x7116, 0x50},{0x7117, 0x20},{0x7118, 0x04},{0x7119, 0xb8},
+	{0x711a, 0x02},{0x711b, 0xbc},{0x711c, 0x18},{0x711d, 0xc7},{0x711e, 0xb8},
+	{0x711f, 0x00},{0x7120, 0x28},{0x7121, 0x54},{0x7122, 0xb4},{0x7123, 0xbf},
+	{0x7124, 0x46},{0x7125, 0xbe},{0x7126, 0x04},{0x7127, 0xd6},{0x7128, 0xd8},
+	{0x7129, 0xab},{0x712a, 0x00},{0x712b, 0xe8},{0x712c, 0x62},{0x712d, 0x07},
+	{0x712e, 0xb9},{0x712f, 0x05},{0x7130, 0xad},{0x7131, 0xc3},{0x7132, 0xbf},
+	{0x7133, 0xb9},{0x7134, 0x64},{0x7135, 0x29},{0x7136, 0x00},{0x7137, 0xb8},
+	{0x7138, 0x02},{0x7139, 0xbe},{0x713a, 0x00},{0x713b, 0xe6},{0x713c, 0xbd},
+	{0x713d, 0x03},{0x713e, 0xec},{0x713f, 0xad},{0x7140, 0xe2},{0x7141, 0x28},
+	{0x7142, 0x00},{0x7143, 0xb8},{0x7144, 0x00},{0x7145, 0xe0},{0x7146, 0xd8},
+	{0x7147, 0xb4},{0x7148, 0xcd},{0x7149, 0x45},{0x714a, 0xbe},{0x714b, 0x03},
+	{0x714c, 0x00},{0x714d, 0x30},{0x714e, 0xe8},{0x714f, 0xbc},{0x7150, 0x1c},
+	{0x7151, 0x62},{0x7152, 0x07},{0x7153, 0xb9},{0x7154, 0x05},{0x7155, 0xad},
+	{0x7156, 0xc3},{0x7157, 0xd2},{0x7158, 0x46},{0x7159, 0xe4},{0x715a, 0xd5},
+	{0x715b, 0x00},{0x715c, 0x17},{0x715d, 0xc2},{0x715e, 0xc6},{0x715f, 0xde},
+	{0x7160, 0xcf},{0x7161, 0xdf},{0x7162, 0xac},{0x7163, 0xd1},{0x7164, 0x44},
+	{0x7165, 0xac},{0x7166, 0xb9},{0x7167, 0x76},{0x7168, 0xb8},{0x7169, 0x08},
+	{0x716a, 0xb6},{0x716b, 0xfe},{0x716c, 0xb4},{0x716d, 0xbf},{0x716e, 0xd6},
+	{0x716f, 0xd8},{0x7170, 0xab},{0x7171, 0xe8},{0x7172, 0x00},{0x7173, 0xe1},
+	{0x7174, 0x36},{0x7175, 0x30},{0x7176, 0xd3},{0x7177, 0xbc},{0x7178, 0x5e},
+	{0x7179, 0xb4},{0x717a, 0x1d},{0x717b, 0xaa},{0x717c, 0xb8},{0x717d, 0x0c},
+	{0x717e, 0x45},{0x717f, 0xe6},{0x7180, 0xbd},{0x7181, 0x03},{0x7182, 0xec},
+	{0x7183, 0xbc},{0x7184, 0x7d},{0x7185, 0xc3},{0x7186, 0xd2},{0x7187, 0x42},
+	{0x7188, 0xb8},{0x7189, 0x00},{0x718a, 0xe4},{0x718b, 0xd5},{0x718c, 0xb6},
+	{0x718d, 0x00},{0x718e, 0xb9},{0x718f, 0x0a},{0x7190, 0xbd},{0x7191, 0x03},
+	{0x7192, 0xb5},{0x7193, 0x4b},{0x7194, 0x40},{0x7195, 0x58},{0x7196, 0x76},
+	{0x7197, 0x01},{0x7198, 0x6a},{0x7199, 0xdd},{0x719a, 0x1a},{0x719b, 0xc2},
+	{0x719c, 0xd1},{0x719d, 0xe8},{0x719e, 0xbd},{0x719f, 0x03},{0x71a0, 0xe6},
+	{0x71a1, 0xec},{0x71a2, 0xbc},{0x71a3, 0x19},{0x71a4, 0xb9},{0x71a5, 0xf6},
+	{0x71a6, 0x14},{0x71a7, 0xc1},{0x71a8, 0xda},{0x71a9, 0xd1},{0x71aa, 0xac},
+	{0x71ab, 0x37},{0x71ac, 0xbc},{0x71ad, 0x35},{0x71ae, 0x36},{0x71af, 0x30},
+	{0x71b0, 0xe1},{0x71b1, 0xd3},{0x71b2, 0xc0},{0x71b3, 0xd3},{0x71b4, 0xb6},
+	{0x71b5, 0x0c},{0x71b6, 0xff},{0x71b7, 0xb4},{0x71b8, 0xbc},{0x71b9, 0xd9},
+	{0x71ba, 0x00},{0x71bb, 0xe8},{0x71bc, 0x56},{0x71bd, 0xc0},{0x71be, 0xe3},
+	{0x71bf, 0xb4},{0x71c0, 0x1d},{0x71c1, 0x56},{0x71c2, 0xaa},{0x71c3, 0xbc},
+	{0x71c4, 0x1a},{0x71c5, 0x00},{0x71c6, 0xb5},{0x71c7, 0x48},{0x71c8, 0x57},
+	{0x71c9, 0x00},{0x71ca, 0x54},{0x71cb, 0xe7},{0x71cc, 0xc8},{0x71cd, 0xb5},
+	{0x71ce, 0x13},{0x71cf, 0xd9},{0x71d0, 0x00},{0x71d1, 0xe8},{0x71d2, 0x56},
+	{0x71d3, 0x08},{0x71d4, 0xb4},{0x71d5, 0x44},{0x71d6, 0x57},{0x71d7, 0x00},
+	{0x71d8, 0x54},{0x71d9, 0xe7},{0x71da, 0xc8},{0x71db, 0xab},{0x71dc, 0x00},
+	{0x71dd, 0x66},{0x71de, 0x62},{0x71df, 0x06},{0x71e0, 0x74},{0x71e1, 0xb9},
+	{0x71e2, 0x05},{0x71e3, 0xb7},{0x71e4, 0x10},{0x71e5, 0xbc},{0x71e6, 0x26},
+	{0x71e7, 0xb7},{0x71e8, 0x00},{0x71e9, 0xc8},{0x7600, 0x04},{0x7601, 0x80},
+	{0x7602, 0x07},{0x7603, 0x44},{0x7604, 0x05},{0x7605, 0x33},{0x7606, 0x0f},
+	{0x7607, 0x00},{0x7608, 0x07},{0x7609, 0x40},{0x760a, 0x04},{0x760b, 0xe5},
+	{0x760c, 0x06},{0x760d, 0x50},{0x760e, 0x04},{0x760f, 0xe4},{0x7610, 0x00},
+	{0x7611, 0x00},{0x7612, 0x06},{0x7613, 0x5c},{0x7614, 0x00},{0x7615, 0x0f},
+	{0x7616, 0x06},{0x7617, 0x1c},{0x7618, 0x00},{0x7619, 0x02},{0x761a, 0x06},
+	{0x761b, 0xa0},{0x761c, 0x00},{0x761d, 0x01},{0x761e, 0x06},{0x761f, 0xac},
+	{0x7620, 0x00},{0x7621, 0x0f},{0x7622, 0x05},{0x7623, 0x30},{0x7624, 0x07},
+	{0x7625, 0x00},{0x7626, 0x0f},{0x7627, 0x00},{0x7628, 0x04},{0x7629, 0xe5},
+	{0x762a, 0x05},{0x762b, 0x33},{0x762c, 0x06},{0x762d, 0x50},{0x762e, 0x00},
+	{0x762f, 0x01},{0x7630, 0x06},{0x7631, 0x5c},{0x7632, 0x04},{0x7633, 0xe4},
+	{0x7634, 0x00},{0x7635, 0x0e},{0x7636, 0x05},{0x7637, 0x30},{0x7638, 0x0f},
+	{0x7639, 0x00},{0x763a, 0x06},{0x763b, 0x24},{0x763c, 0x00},{0x763d, 0x03},
+	{0x763e, 0x05},{0x763f, 0x33},{0x7640, 0x07},{0x7641, 0x02},{0x7642, 0x06},
+	{0x7643, 0x24},{0x7644, 0x00},{0x7645, 0x01},{0x7646, 0x06},{0x7647, 0x20},
+	{0x7648, 0x0f},{0x7649, 0x00},{0x764a, 0x06},{0x764b, 0x14},{0x764c, 0x00},
+	{0x764d, 0x03},{0x764e, 0x05},{0x764f, 0x33},{0x7650, 0x07},{0x7651, 0x02},
+	{0x7652, 0x06},{0x7653, 0x14},{0x7654, 0x00},{0x7655, 0x01},{0x7656, 0x06},
+	{0x7657, 0x10},{0x7658, 0x0f},{0x7659, 0x00},{0x765a, 0x06},{0x765b, 0x10},
+	{0x765c, 0x0f},{0x765d, 0x00},{0x765e, 0x06},{0x765f, 0x20},{0x7660, 0x0f},
+	{0x7661, 0x00},{0x7662, 0x00},{0x7663, 0x00},{0x7664, 0x00},{0x7665, 0x02},
+	{0x7666, 0x04},{0x7667, 0xe5},{0x7668, 0x04},{0x7669, 0xe4},{0x766a, 0x0f},
+	{0x766b, 0x00},{0x766c, 0x00},{0x766d, 0x00},{0x766e, 0x00},{0x766f, 0x02},
+	{0x7670, 0x04},{0x7671, 0xe5},{0x7672, 0x04},{0x7673, 0xe4},{0x7674, 0x0f},
+	{0x7675, 0x00},{0x7676, 0x00},{0x7677, 0x02},{0x7678, 0x04},{0x7679, 0xe4},
+	{0x767a, 0x00},{0x767b, 0x02},{0x767c, 0x04},{0x767d, 0xc4},{0x767e, 0x00},
+	{0x767f, 0x04},{0x7680, 0x04},{0x7681, 0xc4},{0x7682, 0x05},{0x7683, 0x83},
+	{0x7684, 0x07},{0x7685, 0x02},{0x7686, 0x0f},{0x7687, 0x00},{0x7688, 0x00},
+	{0x7689, 0x02},{0x768a, 0x04},{0x768b, 0xe4},{0x768c, 0x00},{0x768d, 0x02},
+	{0x768e, 0x04},{0x768f, 0xc4},{0x7690, 0x00},{0x7691, 0x04},{0x7692, 0x04},
+	{0x7693, 0xc4},{0x7694, 0x05},{0x7695, 0x83},{0x7696, 0x07},{0x7697, 0x02},
+	{0x7698, 0x03},{0x7699, 0x0b},{0x769a, 0x05},{0x769b, 0x83},{0x769c, 0x00},
+	{0x769d, 0x08},{0x769e, 0x05},{0x769f, 0x03},{0x76a0, 0x05},{0x76a1, 0x32},
+	{0x76a2, 0x00},{0x76a3, 0x00},{0x76a4, 0x05},{0x76a5, 0x70},{0x76a6, 0x00},
+	{0x76a7, 0x01},{0x76a8, 0x05},{0x76a9, 0x74},{0x76aa, 0x03},{0x76ab, 0x9a},
+	{0x76ac, 0x05},{0x76ad, 0x83},{0x76ae, 0x00},{0x76af, 0x05},{0x76b0, 0x05},
+	{0x76b1, 0x03},{0x76b2, 0x05},{0x76b3, 0x32},{0x76b4, 0x00},{0x76b5, 0x00},
+	{0x76b6, 0x05},{0x76b7, 0x70},{0x76b8, 0x00},{0x76b9, 0x01},{0x76ba, 0x05},
+	{0x76bb, 0x74},{0x76bc, 0x03},{0x76bd, 0x99},{0x76be, 0x05},{0x76bf, 0x83},
+	{0x76c0, 0x00},{0x76c1, 0x03},{0x76c2, 0x05},{0x76c3, 0x03},{0x76c4, 0x05},
+	{0x76c5, 0x32},{0x76c6, 0x00},{0x76c7, 0x00},{0x76c8, 0x05},{0x76c9, 0x70},
+	{0x76ca, 0x00},{0x76cb, 0x01},{0x76cc, 0x05},{0x76cd, 0x74},{0x76ce, 0x03},
+	{0x76cf, 0x98},{0x76d0, 0x05},{0x76d1, 0x83},{0x76d2, 0x00},{0x76d3, 0x01},
+	{0x76d4, 0x05},{0x76d5, 0x03},{0x76d6, 0x05},{0x76d7, 0x32},{0x76d8, 0x00},
+	{0x76d9, 0x00},{0x76da, 0x05},{0x76db, 0x70},{0x76dc, 0x00},{0x76dd, 0x01},
+	{0x76de, 0x05},{0x76df, 0x74},{0x76e0, 0x03},{0x76e1, 0x97},{0x76e2, 0x05},
+	{0x76e3, 0x83},{0x76e4, 0x00},{0x76e5, 0x01},{0x76e6, 0x05},{0x76e7, 0x03},
+	{0x76e8, 0x05},{0x76e9, 0x32},{0x76ea, 0x00},{0x76eb, 0x00},{0x76ec, 0x05},
+	{0x76ed, 0x70},{0x76ee, 0x00},{0x76ef, 0x01},{0x76f0, 0x05},{0x76f1, 0x74},
+	{0x76f2, 0x03},{0x76f3, 0x96},{0x76f4, 0x05},{0x76f5, 0x83},{0x76f6, 0x00},
+	{0x76f7, 0x01},{0x76f8, 0x05},{0x76f9, 0x03},{0x76fa, 0x05},{0x76fb, 0x32},
+	{0x76fc, 0x00},{0x76fd, 0x00},{0x76fe, 0x05},{0x76ff, 0x70},{0x7700, 0x00},
+	{0x7701, 0x01},{0x7702, 0x05},{0x7703, 0x74},{0x7704, 0x03},{0x7705, 0x95},
+	{0x7706, 0x05},{0x7707, 0x83},{0x7708, 0x00},{0x7709, 0x01},{0x770a, 0x05},
+	{0x770b, 0x03},{0x770c, 0x05},{0x770d, 0x32},{0x770e, 0x00},{0x770f, 0x00},
+	{0x7710, 0x05},{0x7711, 0x70},{0x7712, 0x00},{0x7713, 0x01},{0x7714, 0x05},
+	{0x7715, 0x74},{0x7716, 0x03},{0x7717, 0x94},{0x7718, 0x05},{0x7719, 0x83},
+	{0x771a, 0x00},{0x771b, 0x03},{0x771c, 0x05},{0x771d, 0x03},{0x771e, 0x05},
+	{0x771f, 0x32},{0x7720, 0x00},{0x7721, 0x00},{0x7722, 0x05},{0x7723, 0x70},
+	{0x7724, 0x00},{0x7725, 0x01},{0x7726, 0x05},{0x7727, 0x74},{0x7728, 0x03},
+	{0x7729, 0x93},{0x772a, 0x05},{0x772b, 0x83},{0x772c, 0x00},{0x772d, 0x02},
+	{0x772e, 0x05},{0x772f, 0x03},{0x7730, 0x05},{0x7731, 0x32},{0x7732, 0x00},
+	{0x7733, 0x00},{0x7734, 0x05},{0x7735, 0x70},{0x7736, 0x00},{0x7737, 0x01},
+	{0x7738, 0x05},{0x7739, 0x74},{0x773a, 0x03},{0x773b, 0x92},{0x773c, 0x05},
+	{0x773d, 0x83},{0x773e, 0x00},{0x773f, 0x01},{0x7740, 0x05},{0x7741, 0x03},
+	{0x7742, 0x05},{0x7743, 0x32},{0x7744, 0x00},{0x7745, 0x00},{0x7746, 0x05},
+	{0x7747, 0x70},{0x7748, 0x00},{0x7749, 0x01},{0x774a, 0x05},{0x774b, 0x74},
+	{0x774c, 0x03},{0x774d, 0x91},{0x774e, 0x05},{0x774f, 0x83},{0x7750, 0x00},
+	{0x7751, 0x01},{0x7752, 0x05},{0x7753, 0x03},{0x7754, 0x05},{0x7755, 0x32},
+	{0x7756, 0x00},{0x7757, 0x00},{0x7758, 0x05},{0x7759, 0x70},{0x775a, 0x00},
+	{0x775b, 0x01},{0x775c, 0x05},{0x775d, 0x74},{0x775e, 0x03},{0x775f, 0x90},
+	{0x7760, 0x05},{0x7761, 0x83},{0x7762, 0x00},{0x7763, 0x01},{0x7764, 0x05},
+	{0x7765, 0x03},{0x7766, 0x05},{0x7767, 0x32},{0x7768, 0x00},{0x7769, 0x00},
+	{0x776a, 0x05},{0x776b, 0x70},{0x776c, 0x00},{0x776d, 0x01},{0x776e, 0x05},
+	{0x776f, 0x74},{0x7770, 0x02},{0x7771, 0x90},{0x7772, 0x05},{0x7773, 0x03},
+	{0x7774, 0x07},{0x7775, 0x00},{0x7776, 0x0f},{0x7777, 0x00},{0x7778, 0x08},
+	{0x7779, 0x31},{0x777a, 0x08},{0x777b, 0xd1},{0x777c, 0x0f},{0x777d, 0x00},
+	{0x777e, 0x04},{0x777f, 0xe5},{0x7780, 0x06},{0x7781, 0x50},{0x7782, 0x04},
+	{0x7783, 0xe4},{0x7784, 0x00},{0x7785, 0x00},{0x7786, 0x06},{0x7787, 0x5c},
+	{0x7788, 0x09},{0x7789, 0x14},{0x778a, 0x06},{0x778b, 0x1c},{0x778c, 0x00},
+	{0x778d, 0x02},{0x778e, 0x06},{0x778f, 0xa0},{0x7790, 0x00},{0x7791, 0x01},
+	{0x7792, 0x06},{0x7793, 0xac},{0x7794, 0x00},{0x7795, 0x0f},{0x7796, 0x05},
+	{0x7797, 0x30},{0x7798, 0x0f},{0x7799, 0x00},{0x779a, 0x00},{0x779b, 0x00},
+	{0x779c, 0x00},{0x779d, 0x02},{0x779e, 0x04},{0x779f, 0xe5},{0x77a0, 0x04},
+	{0x77a1, 0xe4},{0x77a2, 0x07},{0x77a3, 0x10},{0x77a4, 0x00},{0x77a5, 0x00},
+	{0x77a6, 0x07},{0x77a7, 0x00},{0x77a8, 0x01},{0x77a9, 0xbb},{0x77aa, 0x07},
+	{0x77ab, 0x10},{0x77ac, 0x00},{0x77ad, 0x00},{0x77ae, 0x07},{0x77af, 0x00},
+	{0x77b0, 0x01},{0x77b1, 0xaa},{0x77b2, 0x07},{0x77b3, 0x10},{0x77b4, 0x00},
+	{0x77b5, 0x00},{0x77b6, 0x07},{0x77b7, 0x00},{0x77b8, 0x01},{0x77b9, 0x99},
+	{0x77ba, 0x07},{0x77bb, 0x10},{0x77bc, 0x00},{0x77bd, 0x00},{0x77be, 0x07},
+	{0x77bf, 0x00},{0x77c0, 0x01},{0x77c1, 0x88},{0x77c2, 0x07},{0x77c3, 0x10},
+	{0x77c4, 0x00},{0x77c5, 0x00},{0x77c6, 0x07},{0x77c7, 0x00},{0x77c8, 0x01},
+	{0x77c9, 0x77},{0x77ca, 0x07},{0x77cb, 0x10},{0x77cc, 0x00},{0x77cd, 0x00},
+	{0x77ce, 0x07},{0x77cf, 0x00},{0x77d0, 0x01},{0x77d1, 0x66},{0x77d2, 0x07},
+	{0x77d3, 0x10},{0x77d4, 0x00},{0x77d5, 0x00},{0x77d6, 0x07},{0x77d7, 0x00},
+	{0x77d8, 0x01},{0x77d9, 0x55},{0x77da, 0x07},{0x77db, 0x10},{0x77dc, 0x00},
+	{0x77dd, 0x00},{0x77de, 0x07},{0x77df, 0x00},{0x77e0, 0x01},{0x77e1, 0x44},
+	{0x77e2, 0x07},{0x77e3, 0x10},{0x77e4, 0x00},{0x77e5, 0x00},{0x77e6, 0x07},
+	{0x77e7, 0x00},{0x77e8, 0x01},{0x77e9, 0x33},{0x77ea, 0x07},{0x77eb, 0x10},
+	{0x77ec, 0x00},{0x77ed, 0x00},{0x77ee, 0x07},{0x77ef, 0x00},{0x77f0, 0x01},
+	{0x77f1, 0x22},{0x77f2, 0x07},{0x77f3, 0x10},{0x77f4, 0x00},{0x77f5, 0x00},
+	{0x77f6, 0x07},{0x77f7, 0x00},{0x77f8, 0x01},{0x77f9, 0x11},{0x77fa, 0x07},
+	{0x77fb, 0x10},{0x77fc, 0x00},{0x77fd, 0x00},{0x77fe, 0x07},{0x77ff, 0x00},
+	{0x7800, 0x01},{0x7801, 0x00},{0x7802, 0x01},{0x7803, 0xff},{0x7804, 0x07},
+	{0x7805, 0x00},{0x7806, 0x02},{0x7807, 0xa0},{0x7808, 0x05},{0x7809, 0x33},
+	{0x780a, 0x0f},{0x780b, 0x00},{0x780c, 0x08},{0x780d, 0x36},{0x780e, 0x06},
+	{0x780f, 0x50},{0x7810, 0x04},{0x7811, 0xe4},{0x7812, 0x00},{0x7813, 0x00},
+	{0x7814, 0x06},{0x7815, 0x5c},{0x7816, 0x09},{0x7817, 0x14},{0x7818, 0x06},
+	{0x7819, 0x1c},{0x781a, 0x05},{0x781b, 0x33},{0x781c, 0x00},{0x781d, 0x01},
+	{0x781e, 0x06},{0x781f, 0x24},{0x7820, 0x00},{0x7821, 0x01},{0x7822, 0x06},
+	{0x7823, 0x20},{0x7824, 0x0f},{0x7825, 0x00},{0x7826, 0x08},{0x7827, 0x36},
+	{0x7828, 0x07},{0x7829, 0x10},{0x782a, 0x00},{0x782b, 0x00},{0x782c, 0x07},
+	{0x782d, 0x00},{0x782e, 0x01},{0x782f, 0xbb},{0x7830, 0x07},{0x7831, 0x10},
+	{0x7832, 0x00},{0x7833, 0x00},{0x7834, 0x07},{0x7835, 0x00},{0x7836, 0x01},
+	{0x7837, 0xaa},{0x7838, 0x07},{0x7839, 0x10},{0x783a, 0x00},{0x783b, 0x00},
+	{0x783c, 0x07},{0x783d, 0x00},{0x783e, 0x01},{0x783f, 0x99},{0x7840, 0x07},
+	{0x7841, 0x10},{0x7842, 0x00},{0x7843, 0x00},{0x7844, 0x07},{0x7845, 0x00},
+	{0x7846, 0x01},{0x7847, 0x88},{0x7848, 0x07},{0x7849, 0x10},{0x784a, 0x00},
+	{0x784b, 0x00},{0x784c, 0x07},{0x784d, 0x00},{0x784e, 0x01},{0x784f, 0x77},
+	{0x7850, 0x07},{0x7851, 0x10},{0x7852, 0x00},{0x7853, 0x00},{0x7854, 0x07},
+	{0x7855, 0x00},{0x7856, 0x01},{0x7857, 0x66},{0x7858, 0x07},{0x7859, 0x10},
+	{0x785a, 0x00},{0x785b, 0x00},{0x785c, 0x07},{0x785d, 0x00},{0x785e, 0x01},
+	{0x785f, 0x55},{0x7860, 0x07},{0x7861, 0x10},{0x7862, 0x00},{0x7863, 0x00},
+	{0x7864, 0x07},{0x7865, 0x00},{0x7866, 0x01},{0x7867, 0x44},{0x7868, 0x07},
+	{0x7869, 0x10},{0x786a, 0x00},{0x786b, 0x00},{0x786c, 0x07},{0x786d, 0x00},
+	{0x786e, 0x01},{0x786f, 0x33},{0x7870, 0x07},{0x7871, 0x10},{0x7872, 0x00},
+	{0x7873, 0x00},{0x7874, 0x07},{0x7875, 0x00},{0x7876, 0x01},{0x7877, 0x22},
+	{0x7878, 0x07},{0x7879, 0x10},{0x787a, 0x00},{0x787b, 0x00},{0x787c, 0x07},
+	{0x787d, 0x00},{0x787e, 0x01},{0x787f, 0x11},{0x7880, 0x07},{0x7881, 0x10},
+	{0x7882, 0x00},{0x7883, 0x00},{0x7884, 0x07},{0x7885, 0x00},{0x7886, 0x01},
+	{0x7887, 0x00},{0x7888, 0x01},{0x7889, 0xff},{0x788a, 0x02},{0x788b, 0xa0},
+	{0x788c, 0x05},{0x788d, 0x33},{0x788e, 0x0f},{0x788f, 0x00},{0x7890, 0x08},
+	{0x7891, 0x3b},{0x7892, 0x08},{0x7893, 0x5e},{0x7894, 0x0f},{0x7895, 0x00},
+	{0x7896, 0x04},{0x7897, 0xc0},{0x7898, 0x09},{0x7899, 0x14},{0x789a, 0x04},
+	{0x789b, 0x99},{0x789c, 0x07},{0x789d, 0x14},{0x789e, 0x04},{0x789f, 0x80},
+	{0x78a0, 0x04},{0x78a1, 0xa4},{0x78a2, 0x00},{0x78a3, 0x0a},{0x78a4, 0x04},
+	{0x78a5, 0xa6},{0x78a6, 0x00},{0x78a7, 0x00},{0x78a8, 0x04},{0x78a9, 0xa0},
+	{0x78aa, 0x04},{0x78ab, 0x80},{0x78ac, 0x04},{0x78ad, 0x00},{0x78ae, 0x05},
+	{0x78af, 0x03},{0x78b0, 0x06},{0x78b1, 0x00},{0x78b2, 0x0f},{0x78b3, 0x00},
+	{0x78b4, 0x0f},{0x78b5, 0x00},{0x78b6, 0x0f},{0x78b7, 0x00},{0x3288, 0x2a},
+	{0x3289, 0x00},{0x328a, 0x15},{0x328b, 0x00},{0x328c, 0x0a},{0x328d, 0x80},
+	{0x328e, 0x05},{0x328f, 0x40},{0x3290, 0x54},{0x3291, 0x00},{0x3292, 0x2a},
+	{0x3293, 0x00},{0x3294, 0x15},{0x3295, 0x00},{0x3296, 0x0a},{0x3297, 0x80},
+	{0x3298, 0x7f},{0x3299, 0xff},{0x329a, 0x54},{0x329b, 0x00},{0x329c, 0x2a},
+	{0x329d, 0x00},{0x329e, 0x15},{0x329f, 0x00},{0x32a0, 0x7f},{0x32a1, 0xff},
+	{0x32a2, 0x7f},{0x32a3, 0xff},{0x32a4, 0x54},{0x32a5, 0x00},{0x32a6, 0x2a},
+	{0x32a7, 0x00},{0x32c8, 0x87},{0x30b0, 0x08},{0x30b1, 0x98},{0x30b2, 0x04},
+	{0x30b3, 0x70},{0x3196, 0x00},{0x3197, 0x10},{0x3195, 0x28},{0x304b, 0x00},
+	{0x304d, 0xa4},{0x3033, 0x30},{0x315a, 0x02},{0x315b, 0x00},{0x315c, 0x02},
+	{0x315d, 0x86},{0x315e, 0x02},{0x315f, 0x86},
+
+	/* mirror on */
+	{0x30c0, 0x04},{0x30a9, 0x05},{0x3252, 0x21},
+
+	{0x3012, 0x01},{0x3030, 0x02},
+};
+
+static struct vin_reg_16_8 ov2718_dcg_vs_hdr_regs[] = {
+	/* ov2718_1920x1080_3x12_27.7fps_MIPI600_NoVC */
+	{0x3013, 0x01},{0x3000, 0x05},{0x3001, 0x64},{0x3002, 0x07},{0x3003, 0x01},
+	{0x3004, 0x06},{0x3005, 0x49},{0x3006, 0x00},{0x3007, 0x07},{0x3008, 0x01},
+	{0x3009, 0x00},{0x300c, 0x6c},{0x300d, 0xe1},{0x300e, 0x80},{0x300f, 0x00},
+	{0x3012, 0x00},{0x3013, 0x00},{0x3014, 0x84},{0x3015, 0x00},{0x3017, 0x00},
+	{0x3018, 0x00},{0x3019, 0x00},{0x301a, 0x00},{0x301b, 0x01},{0x301e, 0x10},
+	{0x301f, 0x5f},{0x3030, 0x0a},{0x3031, 0x63},{0x3032, 0xf0},{0x3033, 0x30},
+	{0x3034, 0x34},{0x3035, 0x51},{0x3036, 0x02},{0x3037, 0x9f},{0x3038, 0x04},
+	{0x3039, 0xb7},{0x303a, 0x04},{0x303b, 0x07},{0x303c, 0xf0},{0x303d, 0x00},
+	{0x303e, 0x0b},{0x303f, 0xe3},{0x3040, 0xf3},{0x3041, 0x29},{0x3042, 0xf6},
+	{0x3043, 0x65},{0x3044, 0x06},{0x3045, 0x0f},{0x3046, 0x55},{0x3047, 0xf7},
+	{0x3048, 0x31},{0x3049, 0x0f},{0x304a, 0x10},{0x304b, 0xc0},{0x304c, 0x33},
+	{0x304d, 0x24},{0x304e, 0x0b},{0x304f, 0x3d},{0x3050, 0x10},{0x3060, 0x00},
+	{0x3061, 0x64},{0x3062, 0x01},{0x3063, 0x00},{0x3064, 0x0b},{0x3065, 0xf8},
+	{0x3066, 0x80},{0x3080, 0x00},{0x3081, 0x00},{0x3082, 0x01},{0x3083, 0xe3},
+	{0x3084, 0x05},{0x3085, 0x00},{0x3086, 0x10},{0x3087, 0x10},{0x3089, 0x00},
+	{0x308a, 0x01},{0x3093, 0x00},{0x30a0, 0x00},{0x30a1, 0x04},{0x30a2, 0x00},
+	{0x30a3, 0x04},{0x30a4, 0x07},{0x30a5, 0x8b},{0x30a6, 0x04},{0x30a7, 0x43},
+	{0x30a8, 0x00},{0x30a9, 0x04},{0x30aa, 0x00},{0x30ab, 0x04},{0x30ac, 0x07},
+	{0x30ad, 0x80},{0x30ae, 0x04},{0x30af, 0x38},{0x30b0, 0x08},{0x30b1, 0x98},
+	{0x30b2, 0x04},{0x30b3, 0x70},{0x30b4, 0x00},{0x30b5, 0x00},{0x30b6, 0x00},
+	{0x30b7, 0x10},{0x30b8, 0x00},{0x30b9, 0x02},{0x30ba, 0x10},{0x30bb, 0x00},
+	{0x30bc, 0x00},{0x30bd, 0x03},{0x30be, 0x5c},{0x30bf, 0x00},{0x30c0, 0x00},
+	{0x30c1, 0x00},{0x30c2, 0x20},{0x30c3, 0x00},{0x30c4, 0x4a},{0x30c5, 0x00},
+	{0x30c7, 0x00},{0x30c8, 0x00},{0x30d1, 0x00},{0x30d2, 0x00},{0x30d3, 0x80},
+	{0x30d4, 0x00},{0x30d9, 0x09},{0x30da, 0x64},{0x30dd, 0x00},{0x30de, 0x16},
+	{0x30df, 0x00},{0x30e0, 0x17},{0x30e1, 0x00},{0x30e2, 0x18},{0x30e3, 0x10},
+	{0x30e4, 0x04},{0x30e5, 0x00},{0x30e6, 0x00},{0x30e7, 0x00},{0x30e8, 0x00},
+	{0x30e9, 0x00},{0x30ea, 0x00},{0x30eb, 0x00},{0x30ec, 0x00},{0x30ed, 0x00},
+	{0x3101, 0x00},{0x3102, 0x00},{0x3103, 0x00},{0x3104, 0x00},{0x3105, 0x6c},
+	{0x3106, 0x83},{0x3107, 0x72},{0x3108, 0x70},{0x3109, 0x6c},{0x310a, 0x83},
+	{0x310b, 0x69},{0x310c, 0x43},{0x310d, 0x42},{0x310e, 0x00},{0x3120, 0x00},
+	{0x3121, 0x00},{0x3122, 0x00},{0x3123, 0x00},{0x3124, 0x00},{0x3125, 0xa0},
+	{0x3126, 0x3f},{0x3127, 0x0f},{0x3128, 0x00},{0x3129, 0x3a},{0x312a, 0x02},
+	{0x312b, 0x0f},{0x312c, 0x00},{0x312d, 0x0f},{0x312e, 0x1d},{0x312f, 0x00},
+	{0x3130, 0x00},{0x3131, 0x00},{0x3132, 0x00},{0x3140, 0x02},{0x3141, 0x03},
+	{0x3142, 0x00},{0x3143, 0x00},{0x3144, 0x00},{0x3145, 0x00},{0x3146, 0x00},
+	{0x3147, 0x00},{0x3148, 0x00},{0x3149, 0x00},{0x314a, 0x00},{0x314b, 0x00},
+	{0x314c, 0x00},{0x314d, 0x00},{0x314e, 0x1c},{0x314f, 0x02},{0x3150, 0x02},
+	{0x3151, 0x10},{0x3152, 0x10},{0x3153, 0x10},{0x3154, 0x80},{0x3155, 0x00},
+	{0x3156, 0x03},{0x3157, 0x00},{0x3158, 0x0f},{0x3159, 0xff},{0x315a, 0x01},
+	{0x315b, 0x00},{0x315c, 0x01},{0x315d, 0x00},{0x315e, 0x01},{0x315f, 0x00},
+	{0x3160, 0x00},{0x3161, 0x40},{0x3162, 0x00},{0x3163, 0x40},{0x3164, 0x00},
+	{0x3165, 0x40},{0x3190, 0x05},{0x3191, 0xc9},{0x3193, 0x08},{0x3194, 0x13},
+	{0x3195, 0x33},{0x3196, 0x00},{0x3197, 0x10},{0x3198, 0x00},{0x3199, 0x3f},
+	{0x319a, 0x40},{0x319b, 0x7f},{0x319c, 0x80},{0x319d, 0xbf},{0x319e, 0xc0},
+	{0x319f, 0xff},{0x31a0, 0x00},{0x31a1, 0x55},{0x31a2, 0x00},{0x31a3, 0x00},
+	{0x31a6, 0x00},{0x31a7, 0x00},{0x31b0, 0x00},{0x31b1, 0x00},{0x31b2, 0x02},
+	{0x31b3, 0x00},{0x31b4, 0x00},{0x31b5, 0x01},{0x31b6, 0x00},{0x31b7, 0x00},
+	{0x31b8, 0x00},{0x31b9, 0x00},{0x31ba, 0x00},{0x31d0, 0x3c},{0x31d1, 0x34},
+	{0x31d2, 0x3c},{0x31d3, 0x00},{0x31d4, 0x2d},{0x31d5, 0x00},{0x31d6, 0x01},
+	{0x31d7, 0x06},{0x31d8, 0x00},{0x31d9, 0x64},{0x31da, 0x00},{0x31db, 0x28},
+	{0x31dc, 0x04},{0x31dd, 0x69},{0x31de, 0x0a},{0x31df, 0x3c},{0x31e0, 0x04},
+	{0x31e1, 0x32},{0x31e2, 0x00},{0x31e3, 0x01},{0x31e4, 0x0d},{0x31e5, 0x80},
+	{0x31e6, 0x00},{0x31e7, 0x2c},{0x31e8, 0x6c},{0x31e9, 0xac},{0x31ea, 0xec},
+	{0x31eb, 0x3f},{0x31ec, 0x0f},{0x31ed, 0x20},{0x31ee, 0x04},{0x31ef, 0x48},
+	{0x31f0, 0x07},{0x31f1, 0x90},{0x31f2, 0x04},{0x31f3, 0x48},{0x31f4, 0x07},
+	{0x31f5, 0x90},{0x31f6, 0x04},{0x31f7, 0x48},{0x31f8, 0x07},{0x31f9, 0x90},
+	{0x31fa, 0x04},{0x31fb, 0x48},{0x31fd, 0xcb},{0x31fe, 0x0f},{0x31ff, 0x03},
+	{0x3200, 0x00},{0x3201, 0xff},{0x3202, 0x00},{0x3203, 0xff},{0x3204, 0xff},
+	{0x3205, 0xff},{0x3206, 0xff},{0x3207, 0xff},{0x3208, 0xff},{0x3209, 0xff},
+	{0x320a, 0xff},{0x320b, 0x1b},{0x320c, 0x1f},{0x320d, 0x1e},{0x320e, 0x30},
+	{0x320f, 0x2d},{0x3210, 0x2c},{0x3211, 0x2b},{0x3212, 0x2a},{0x3213, 0x24},
+	{0x3214, 0x22},{0x3215, 0x00},{0x3216, 0x04},{0x3217, 0x2c},{0x3218, 0x6c},
+	{0x3219, 0xac},{0x321a, 0xec},{0x321b, 0x00},{0x3230, 0x3a},{0x3231, 0x00},
+	{0x3232, 0x80},{0x3233, 0x00},{0x3234, 0x10},{0x3235, 0xaa},{0x3236, 0x55},
+	{0x3237, 0x99},{0x3238, 0x66},{0x3239, 0x08},{0x323a, 0x88},{0x323b, 0x00},
+	{0x323c, 0x00},{0x323d, 0x03},{0x3250, 0x33},{0x3251, 0x00},{0x3252, 0x20},
+	{0x3253, 0x00},{0x3254, 0x11},{0x3255, 0x01},{0x3256, 0x00},{0x3257, 0x00},
+	{0x3258, 0x00},{0x3270, 0x01},{0x3271, 0x60},{0x3272, 0xc0},{0x3273, 0x00},
+	{0x3274, 0x80},{0x3275, 0x40},{0x3276, 0x02},{0x3277, 0x08},{0x3278, 0x10},
+	{0x3279, 0x04},{0x327a, 0x00},{0x327b, 0x03},{0x327c, 0x10},{0x327d, 0x60},
+	{0x327e, 0xc0},{0x327f, 0x06},{0x3288, 0x10},{0x3289, 0x00},{0x328a, 0x08},
+	{0x328b, 0x00},{0x328c, 0x04},{0x328d, 0x00},{0x328e, 0x02},{0x328f, 0x00},
+	{0x3290, 0x20},{0x3291, 0x00},{0x3292, 0x10},{0x3293, 0x00},{0x3294, 0x08},
+	{0x3295, 0x00},{0x3296, 0x04},{0x3297, 0x00},{0x3298, 0x40},{0x3299, 0x00},
+	{0x329a, 0x20},{0x329b, 0x00},{0x329c, 0x10},{0x329d, 0x00},{0x329e, 0x08},
+	{0x329f, 0x00},{0x32a0, 0x7f},{0x32a1, 0xff},{0x32a2, 0x40},{0x32a3, 0x00},
+	{0x32a4, 0x20},{0x32a5, 0x00},{0x32a6, 0x10},{0x32a7, 0x00},{0x32a8, 0x00},
+	{0x32a9, 0x00},{0x32aa, 0x00},{0x32ab, 0x00},{0x32ac, 0x00},{0x32ad, 0x00},
+	{0x32ae, 0x00},{0x32af, 0x00},{0x32b0, 0x00},{0x32b1, 0x00},{0x32b2, 0x00},
+	{0x32b3, 0x00},{0x32b4, 0x00},{0x32b5, 0x00},{0x32b6, 0x00},{0x32b7, 0x00},
+	{0x32b8, 0x00},{0x32b9, 0x00},{0x32ba, 0x00},{0x32bb, 0x00},{0x32bc, 0x00},
+	{0x32bd, 0x00},{0x32be, 0x00},{0x32bf, 0x00},{0x32c0, 0x00},{0x32c1, 0x00},
+	{0x32c2, 0x00},{0x32c3, 0x00},{0x32c4, 0x00},{0x32c5, 0x00},{0x32c6, 0x00},
+	{0x32c7, 0x00},{0x32c8, 0x87},{0x32c9, 0x00},{0x3330, 0x03},{0x3331, 0xc8},
+	{0x3332, 0x02},{0x3333, 0x24},{0x3334, 0x00},{0x3335, 0x00},{0x3336, 0x00},
+	{0x3337, 0x00},{0x3338, 0x03},{0x3339, 0xc8},{0x333a, 0x02},{0x333b, 0x24},
+	{0x333c, 0x00},{0x333d, 0x00},{0x333e, 0x00},{0x333f, 0x00},{0x3340, 0x03},
+	{0x3341, 0xc8},{0x3342, 0x02},{0x3343, 0x24},{0x3344, 0x00},{0x3345, 0x00},
+	{0x3346, 0x00},{0x3347, 0x00},{0x3348, 0x40},{0x3349, 0x00},{0x334a, 0x00},
+	{0x334b, 0x00},{0x334c, 0x00},{0x334d, 0x00},{0x334e, 0x80},{0x3360, 0x01},
+	{0x3361, 0x00},{0x3362, 0x01},{0x3363, 0x00},{0x3364, 0x01},{0x3365, 0x00},
+	{0x3366, 0x01},{0x3367, 0x00},{0x3368, 0x01},{0x3369, 0x00},{0x336a, 0x01},
+	{0x336b, 0x00},{0x336c, 0x01},{0x336d, 0x00},{0x336e, 0x01},{0x336f, 0x00},
+	{0x3370, 0x01},{0x3371, 0x00},{0x3372, 0x01},{0x3373, 0x00},{0x3374, 0x01},
+	{0x3375, 0x00},{0x3376, 0x01},{0x3377, 0x00},{0x3378, 0x00},{0x3379, 0x00},
+	{0x337a, 0x00},{0x337b, 0x00},{0x337c, 0x00},{0x337d, 0x00},{0x337e, 0x00},
+	{0x337f, 0x00},{0x3380, 0x00},{0x3381, 0x00},{0x3382, 0x00},{0x3383, 0x00},
+	{0x3384, 0x00},{0x3385, 0x00},{0x3386, 0x00},{0x3387, 0x00},{0x3388, 0x00},
+	{0x3389, 0x00},{0x338a, 0x00},{0x338b, 0x00},{0x338c, 0x00},{0x338d, 0x00},
+	{0x338e, 0x00},{0x338f, 0x00},{0x3390, 0x00},{0x3391, 0x00},{0x3392, 0x00},
+	{0x3393, 0x00},{0x3394, 0x00},{0x3395, 0x00},{0x3396, 0x00},{0x3397, 0x00},
+	{0x3398, 0x00},{0x3399, 0x00},{0x339a, 0x00},{0x339b, 0x00},{0x33b0, 0x00},
+	{0x33b1, 0x50},{0x33b2, 0x01},{0x33b3, 0xff},{0x33b4, 0xe0},{0x33b5, 0x6b},
+	{0x33b6, 0x00},{0x33b7, 0x00},{0x33b8, 0x00},{0x33b9, 0x00},{0x33ba, 0x00},
+	{0x33bb, 0x1f},{0x33bc, 0x01},{0x33bd, 0x01},{0x33be, 0x01},{0x33bf, 0x01},
+	{0x33c0, 0x00},{0x33c1, 0x00},{0x33c2, 0x00},{0x33c3, 0x00},{0x33e0, 0x14},
+	{0x33e1, 0x0f},{0x33e2, 0x04},{0x33e3, 0x02},{0x33e4, 0x01},{0x33e5, 0x01},
+	{0x33e6, 0x00},{0x33e7, 0x04},{0x33e8, 0x0c},{0x33e9, 0x00},{0x33ea, 0x01},
+	{0x33eb, 0x02},{0x33ec, 0x03},{0x33ed, 0x02},{0x33ee, 0x05},{0x33ef, 0x0a},
+	{0x33f0, 0x08},{0x33f1, 0x04},{0x33f2, 0x04},{0x33f3, 0x00},{0x33f4, 0x03},
+	{0x33f5, 0x14},{0x33f6, 0x0f},{0x33f7, 0x02},{0x33f8, 0x01},{0x33f9, 0x01},
+	{0x33fa, 0x01},{0x33fb, 0x00},{0x33fc, 0x04},{0x33fd, 0x0c},{0x33fe, 0x00},
+	{0x33ff, 0x01},{0x3400, 0x02},{0x3401, 0x03},{0x3402, 0x01},{0x3403, 0x02},
+	{0x3404, 0x08},{0x3405, 0x08},{0x3406, 0x04},{0x3407, 0x04},{0x3408, 0x00},
+	{0x3409, 0x03},{0x340a, 0x14},{0x340b, 0x0f},{0x340c, 0x04},{0x340d, 0x02},
+	{0x340e, 0x01},{0x340f, 0x01},{0x3410, 0x00},{0x3411, 0x04},{0x3412, 0x0c},
+	{0x3413, 0x00},{0x3414, 0x01},{0x3415, 0x02},{0x3416, 0x03},{0x3417, 0x02},
+	{0x3418, 0x05},{0x3419, 0x0a},{0x341a, 0x08},{0x341b, 0x04},{0x341c, 0x04},
+	{0x341d, 0x00},{0x341e, 0x03},{0x3440, 0x00},{0x3441, 0x00},{0x3442, 0x00},
+	{0x3443, 0x00},{0x3444, 0x02},{0x3445, 0xf0},{0x3446, 0x02},{0x3447, 0x08},
+	{0x3448, 0x00},{0x3460, 0x40},{0x3461, 0x40},{0x3462, 0x40},{0x3463, 0x40},
+	{0x3464, 0x03},{0x3465, 0x01},{0x3466, 0x01},{0x3467, 0x02},{0x3468, 0x30},
+	{0x3469, 0x00},{0x346a, 0x35},{0x346b, 0x00},{0x3480, 0x40},{0x3481, 0x00},
+	{0x3482, 0x00},{0x3483, 0x00},{0x3484, 0x07},{0x3485, 0x00},{0x3486, 0x00},
+	{0x3487, 0x00},{0x3488, 0x00},{0x3489, 0x00},{0x348a, 0x00},{0x348b, 0x04},
+	{0x348c, 0x00},{0x348d, 0x01},{0x348f, 0x01},{0x7000, 0xda},{0x7001, 0xcf},
+	{0x7002, 0xac},{0x7003, 0xd0},{0x7004, 0xac},{0x7005, 0xd1},{0x7006, 0x50},
+	{0x7007, 0xb6},{0x7008, 0xee},{0x7009, 0xac},{0x700a, 0xd2},{0x700b, 0xdc},
+	{0x700c, 0xdf},{0x700d, 0x0f},{0x700e, 0xe1},{0x700f, 0x36},{0x7010, 0x30},
+	{0x7011, 0xd3},{0x7012, 0x2e},{0x7013, 0x54},{0x7014, 0x46},{0x7015, 0xb4},
+	{0x7016, 0x00},{0x7017, 0x1a},{0x7018, 0xc1},{0x7019, 0x0e},{0x701a, 0xe8},
+	{0x701b, 0x00},{0x701c, 0xe6},{0x701d, 0xb0},{0x701e, 0x6e},{0x701f, 0xbd},
+	{0x7020, 0x01},{0x7021, 0xd7},{0x7022, 0xed},{0x7023, 0xbc},{0x7024, 0x22},
+	{0x7025, 0xb9},{0x7026, 0x66},{0x7027, 0x2c},{0x7028, 0x28},{0x7029, 0x19},
+	{0x702a, 0xc1},{0x702b, 0x32},{0x702c, 0xa1},{0x702d, 0xac},{0x702e, 0xd8},
+	{0x702f, 0xd6},{0x7030, 0xb4},{0x7031, 0x04},{0x7032, 0x46},{0x7033, 0xb7},
+	{0x7034, 0x00},{0x7035, 0xbe},{0x7036, 0x08},{0x7037, 0xc3},{0x7038, 0xdb},
+	{0x7039, 0xad},{0x703a, 0xc3},{0x703b, 0xbf},{0x703c, 0x50},{0x703d, 0x20},
+	{0x703e, 0xb8},{0x703f, 0x02},{0x7040, 0xbc},{0x7041, 0x17},{0x7042, 0xdb},
+	{0x7043, 0xa0},{0x7044, 0xb8},{0x7045, 0x00},{0x7046, 0x28},{0x7047, 0x54},
+	{0x7048, 0xb4},{0x7049, 0xbc},{0x704a, 0xbe},{0x704b, 0x06},{0x704c, 0xd8},
+	{0x704d, 0xd6},{0x704e, 0x00},{0x704f, 0xb9},{0x7050, 0x64},{0x7051, 0xee},
+	{0x7052, 0xe8},{0x7053, 0xb4},{0x7054, 0x14},{0x7055, 0xab},{0x7056, 0xbc},
+	{0x7057, 0x17},{0x7058, 0x62},{0x7059, 0x07},{0x705a, 0xb9},{0x705b, 0x05},
+	{0x705c, 0xad},{0x705d, 0xb4},{0x705e, 0x25},{0x705f, 0xc3},{0x7060, 0xc1},
+	{0x7061, 0x00},{0x7062, 0xc0},{0x7063, 0x42},{0x7064, 0x50},{0x7065, 0x20},
+	{0x7066, 0x04},{0x7067, 0xb8},{0x7068, 0x02},{0x7069, 0xdb},{0x706a, 0xd8},
+	{0x706b, 0xac},{0x706c, 0xb7},{0x706d, 0x00},{0x706e, 0xbc},{0x706f, 0x11},
+	{0x7070, 0xd6},{0x7071, 0xc7},{0x7072, 0xb8},{0x7073, 0x00},{0x7074, 0x28},
+	{0x7075, 0x54},{0x7076, 0xb4},{0x7077, 0x04},{0x7078, 0x46},{0x7079, 0xbe},
+	{0x707a, 0x06},{0x707b, 0xc3},{0x707c, 0xdb},{0x707d, 0xbd},{0x707e, 0x03},
+	{0x707f, 0xee},{0x7080, 0xad},{0x7081, 0xc3},{0x7082, 0xbf},{0x7083, 0x00},
+	{0x7084, 0xec},{0x7085, 0x00},{0x7086, 0x15},{0x7087, 0xc2},{0x7088, 0x47},
+	{0x7089, 0xc3},{0x708a, 0xb7},{0x708b, 0xc0},{0x708c, 0x43},{0x708d, 0x00},
+	{0x708e, 0x00},{0x708f, 0x00},{0x7090, 0xb9},{0x7091, 0x64},{0x7092, 0x29},
+	{0x7093, 0x00},{0x7094, 0xb8},{0x7095, 0x12},{0x7096, 0xbe},{0x7097, 0x01},
+	{0x7098, 0xd0},{0x7099, 0xbc},{0x709a, 0x01},{0x709b, 0xac},{0x709c, 0x37},
+	{0x709d, 0xd1},{0x709e, 0xac},{0x709f, 0xd2},{0x70a0, 0xac},{0x70a1, 0xad},
+	{0x70a2, 0x28},{0x70a3, 0x00},{0x70a4, 0xb8},{0x70a5, 0x00},{0x70a6, 0xbc},
+	{0x70a7, 0x01},{0x70a8, 0xe1},{0x70a9, 0x36},{0x70aa, 0xd3},{0x70ab, 0x30},
+	{0x70ac, 0x04},{0x70ad, 0xe0},{0x70ae, 0xd8},{0x70af, 0xb4},{0x70b0, 0xcd},
+	{0x70b1, 0x45},{0x70b2, 0x00},{0x70b3, 0xe8},{0x70b4, 0xbe},{0x70b5, 0x05},
+	{0x70b6, 0xbc},{0x70b7, 0x1e},{0x70b8, 0x62},{0x70b9, 0x07},{0x70ba, 0xb9},
+	{0x70bb, 0x05},{0x70bc, 0xad},{0x70bd, 0xc3},{0x70be, 0xd2},{0x70bf, 0x00},
+	{0x70c0, 0x15},{0x70c1, 0xc2},{0x70c2, 0x64},{0x70c3, 0xc3},{0x70c4, 0xcd},
+	{0x70c5, 0xc0},{0x70c6, 0x60},{0x70c7, 0x00},{0x70c8, 0x46},{0x70c9, 0x00},
+	{0x70ca, 0x00},{0x70cb, 0x19},{0x70cc, 0xc1},{0x70cd, 0x7e},{0x70ce, 0xa1},
+	{0x70cf, 0xb9},{0x70d0, 0x64},{0x70d1, 0x29},{0x70d2, 0x00},{0x70d3, 0xb8},
+	{0x70d4, 0x02},{0x70d5, 0xbe},{0x70d6, 0x02},{0x70d7, 0xd0},{0x70d8, 0xdc},
+	{0x70d9, 0xac},{0x70da, 0xbc},{0x70db, 0x01},{0x70dc, 0x37},{0x70dd, 0xd1},
+	{0x70de, 0xac},{0x70df, 0xd2},{0x70e0, 0xad},{0x70e1, 0x28},{0x70e2, 0x00},
+	{0x70e3, 0xb8},{0x70e4, 0x00},{0x70e5, 0xbc},{0x70e6, 0x01},{0x70e7, 0xe1},
+	{0x70e8, 0x36},{0x70e9, 0x30},{0x70ea, 0xe0},{0x70eb, 0xd8},{0x70ec, 0xb5},
+	{0x70ed, 0x06},{0x70ee, 0x45},{0x70ef, 0xd6},{0x70f0, 0xbe},{0x70f1, 0x07},
+	{0x70f2, 0x00},{0x70f3, 0xe8},{0x70f4, 0x62},{0x70f5, 0x07},{0x70f6, 0xb9},
+	{0x70f7, 0x05},{0x70f8, 0xad},{0x70f9, 0xc3},{0x70fa, 0xd2},{0x70fb, 0x46},
+	{0x70fc, 0xd5},{0x70fd, 0xe3},{0x70fe, 0x18},{0x70ff, 0xc2},{0x7100, 0xae},
+	{0x7101, 0xb9},{0x7102, 0x64},{0x7103, 0xd1},{0x7104, 0x50},{0x7105, 0xdd},
+	{0x7106, 0xac},{0x7107, 0xcf},{0x7108, 0xdf},{0x7109, 0xb6},{0x710a, 0xee},
+	{0x710b, 0xbc},{0x710c, 0x13},{0x710d, 0xe1},{0x710e, 0x36},{0x710f, 0x30},
+	{0x7110, 0xd3},{0x7111, 0x2e},{0x7112, 0x54},{0x7113, 0xbc},{0x7114, 0x32},
+	{0x7115, 0x2c},{0x7116, 0x50},{0x7117, 0x20},{0x7118, 0x04},{0x7119, 0xb8},
+	{0x711a, 0x02},{0x711b, 0xbc},{0x711c, 0x18},{0x711d, 0xc7},{0x711e, 0xb8},
+	{0x711f, 0x00},{0x7120, 0x28},{0x7121, 0x54},{0x7122, 0xb4},{0x7123, 0xbf},
+	{0x7124, 0x46},{0x7125, 0xbe},{0x7126, 0x04},{0x7127, 0xd6},{0x7128, 0xd8},
+	{0x7129, 0xab},{0x712a, 0x00},{0x712b, 0xe8},{0x712c, 0x62},{0x712d, 0x07},
+	{0x712e, 0xb9},{0x712f, 0x05},{0x7130, 0xad},{0x7131, 0xc3},{0x7132, 0xbf},
+	{0x7133, 0xb9},{0x7134, 0x64},{0x7135, 0x29},{0x7136, 0x00},{0x7137, 0xb8},
+	{0x7138, 0x02},{0x7139, 0xbe},{0x713a, 0x00},{0x713b, 0xe6},{0x713c, 0xbd},
+	{0x713d, 0x03},{0x713e, 0xec},{0x713f, 0xad},{0x7140, 0xe2},{0x7141, 0x28},
+	{0x7142, 0x00},{0x7143, 0xb8},{0x7144, 0x00},{0x7145, 0xe0},{0x7146, 0xd8},
+	{0x7147, 0xb4},{0x7148, 0xcd},{0x7149, 0x45},{0x714a, 0xbe},{0x714b, 0x03},
+	{0x714c, 0x00},{0x714d, 0x30},{0x714e, 0xe8},{0x714f, 0xbc},{0x7150, 0x1c},
+	{0x7151, 0x62},{0x7152, 0x07},{0x7153, 0xb9},{0x7154, 0x05},{0x7155, 0xad},
+	{0x7156, 0xc3},{0x7157, 0xd2},{0x7158, 0x46},{0x7159, 0xe4},{0x715a, 0xd5},
+	{0x715b, 0x00},{0x715c, 0x17},{0x715d, 0xc2},{0x715e, 0xc6},{0x715f, 0xde},
+	{0x7160, 0xcf},{0x7161, 0xdf},{0x7162, 0xac},{0x7163, 0xd1},{0x7164, 0x44},
+	{0x7165, 0xac},{0x7166, 0xb9},{0x7167, 0x76},{0x7168, 0xb8},{0x7169, 0x08},
+	{0x716a, 0xb6},{0x716b, 0xfe},{0x716c, 0xb4},{0x716d, 0xbf},{0x716e, 0xd6},
+	{0x716f, 0xd8},{0x7170, 0xab},{0x7171, 0xe8},{0x7172, 0x00},{0x7173, 0xe1},
+	{0x7174, 0x36},{0x7175, 0x30},{0x7176, 0xd3},{0x7177, 0xbc},{0x7178, 0x5e},
+	{0x7179, 0xb4},{0x717a, 0x1d},{0x717b, 0xaa},{0x717c, 0xb8},{0x717d, 0x0c},
+	{0x717e, 0x45},{0x717f, 0xe6},{0x7180, 0xbd},{0x7181, 0x03},{0x7182, 0xec},
+	{0x7183, 0xbc},{0x7184, 0x7d},{0x7185, 0xc3},{0x7186, 0xd2},{0x7187, 0x42},
+	{0x7188, 0xb8},{0x7189, 0x00},{0x718a, 0xe4},{0x718b, 0xd5},{0x718c, 0xb6},
+	{0x718d, 0x00},{0x718e, 0xb9},{0x718f, 0x0a},{0x7190, 0xbd},{0x7191, 0x03},
+	{0x7192, 0xb5},{0x7193, 0x4b},{0x7194, 0x40},{0x7195, 0x58},{0x7196, 0x76},
+	{0x7197, 0x01},{0x7198, 0x6a},{0x7199, 0xdd},{0x719a, 0x1a},{0x719b, 0xc2},
+	{0x719c, 0xd1},{0x719d, 0xe8},{0x719e, 0xbd},{0x719f, 0x03},{0x71a0, 0xe6},
+	{0x71a1, 0xec},{0x71a2, 0xbc},{0x71a3, 0x19},{0x71a4, 0xb9},{0x71a5, 0xf6},
+	{0x71a6, 0x14},{0x71a7, 0xc1},{0x71a8, 0xda},{0x71a9, 0xd1},{0x71aa, 0xac},
+	{0x71ab, 0x37},{0x71ac, 0xbc},{0x71ad, 0x35},{0x71ae, 0x36},{0x71af, 0x30},
+	{0x71b0, 0xe1},{0x71b1, 0xd3},{0x71b2, 0xc0},{0x71b3, 0xd3},{0x71b4, 0xb6},
+	{0x71b5, 0x0c},{0x71b6, 0xff},{0x71b7, 0xb4},{0x71b8, 0xbc},{0x71b9, 0xd9},
+	{0x71ba, 0x00},{0x71bb, 0xe8},{0x71bc, 0x56},{0x71bd, 0xc0},{0x71be, 0xe3},
+	{0x71bf, 0xb4},{0x71c0, 0x1d},{0x71c1, 0x56},{0x71c2, 0xaa},{0x71c3, 0xbc},
+	{0x71c4, 0x1a},{0x71c5, 0x00},{0x71c6, 0xb5},{0x71c7, 0x48},{0x71c8, 0x57},
+	{0x71c9, 0x00},{0x71ca, 0x54},{0x71cb, 0xe7},{0x71cc, 0xc8},{0x71cd, 0xb5},
+	{0x71ce, 0x13},{0x71cf, 0xd9},{0x71d0, 0x00},{0x71d1, 0xe8},{0x71d2, 0x56},
+	{0x71d3, 0x08},{0x71d4, 0xb4},{0x71d5, 0x44},{0x71d6, 0x57},{0x71d7, 0x00},
+	{0x71d8, 0x54},{0x71d9, 0xe7},{0x71da, 0xc8},{0x71db, 0xab},{0x71dc, 0x00},
+	{0x71dd, 0x66},{0x71de, 0x62},{0x71df, 0x06},{0x71e0, 0x74},{0x71e1, 0xb9},
+	{0x71e2, 0x05},{0x71e3, 0xb7},{0x71e4, 0x10},{0x71e5, 0xbc},{0x71e6, 0x26},
+	{0x71e7, 0xb7},{0x71e8, 0x00},{0x71e9, 0xc8},{0x7600, 0x04},{0x7601, 0x80},
+	{0x7602, 0x07},{0x7603, 0x44},{0x7604, 0x05},{0x7605, 0x33},{0x7606, 0x0f},
+	{0x7607, 0x00},{0x7608, 0x07},{0x7609, 0x40},{0x760a, 0x04},{0x760b, 0xe5},
+	{0x760c, 0x06},{0x760d, 0x50},{0x760e, 0x04},{0x760f, 0xe4},{0x7610, 0x00},
+	{0x7611, 0x00},{0x7612, 0x06},{0x7613, 0x5c},{0x7614, 0x00},{0x7615, 0x0f},
+	{0x7616, 0x06},{0x7617, 0x1c},{0x7618, 0x00},{0x7619, 0x02},{0x761a, 0x06},
+	{0x761b, 0xa0},{0x761c, 0x00},{0x761d, 0x01},{0x761e, 0x06},{0x761f, 0xac},
+	{0x7620, 0x00},{0x7621, 0x0f},{0x7622, 0x05},{0x7623, 0x30},{0x7624, 0x07},
+	{0x7625, 0x00},{0x7626, 0x0f},{0x7627, 0x00},{0x7628, 0x04},{0x7629, 0xe5},
+	{0x762a, 0x05},{0x762b, 0x33},{0x762c, 0x06},{0x762d, 0x50},{0x762e, 0x00},
+	{0x762f, 0x01},{0x7630, 0x06},{0x7631, 0x5c},{0x7632, 0x04},{0x7633, 0xe4},
+	{0x7634, 0x00},{0x7635, 0x0e},{0x7636, 0x05},{0x7637, 0x30},{0x7638, 0x0f},
+	{0x7639, 0x00},{0x763a, 0x06},{0x763b, 0x24},{0x763c, 0x00},{0x763d, 0x03},
+	{0x763e, 0x05},{0x763f, 0x33},{0x7640, 0x07},{0x7641, 0x02},{0x7642, 0x06},
+	{0x7643, 0x24},{0x7644, 0x00},{0x7645, 0x01},{0x7646, 0x06},{0x7647, 0x20},
+	{0x7648, 0x0f},{0x7649, 0x00},{0x764a, 0x06},{0x764b, 0x14},{0x764c, 0x00},
+	{0x764d, 0x03},{0x764e, 0x05},{0x764f, 0x33},{0x7650, 0x07},{0x7651, 0x02},
+	{0x7652, 0x06},{0x7653, 0x14},{0x7654, 0x00},{0x7655, 0x01},{0x7656, 0x06},
+	{0x7657, 0x10},{0x7658, 0x0f},{0x7659, 0x00},{0x765a, 0x06},{0x765b, 0x10},
+	{0x765c, 0x0f},{0x765d, 0x00},{0x765e, 0x06},{0x765f, 0x20},{0x7660, 0x0f},
+	{0x7661, 0x00},{0x7662, 0x00},{0x7663, 0x00},{0x7664, 0x00},{0x7665, 0x02},
+	{0x7666, 0x04},{0x7667, 0xe5},{0x7668, 0x04},{0x7669, 0xe4},{0x766a, 0x0f},
+	{0x766b, 0x00},{0x766c, 0x00},{0x766d, 0x00},{0x766e, 0x00},{0x766f, 0x02},
+	{0x7670, 0x04},{0x7671, 0xe5},{0x7672, 0x04},{0x7673, 0xe4},{0x7674, 0x0f},
+	{0x7675, 0x00},{0x7676, 0x00},{0x7677, 0x02},{0x7678, 0x04},{0x7679, 0xe4},
+	{0x767a, 0x00},{0x767b, 0x02},{0x767c, 0x04},{0x767d, 0xc4},{0x767e, 0x00},
+	{0x767f, 0x04},{0x7680, 0x04},{0x7681, 0xc4},{0x7682, 0x05},{0x7683, 0x83},
+	{0x7684, 0x07},{0x7685, 0x02},{0x7686, 0x0f},{0x7687, 0x00},{0x7688, 0x00},
+	{0x7689, 0x02},{0x768a, 0x04},{0x768b, 0xe4},{0x768c, 0x00},{0x768d, 0x02},
+	{0x768e, 0x04},{0x768f, 0xc4},{0x7690, 0x00},{0x7691, 0x04},{0x7692, 0x04},
+	{0x7693, 0xc4},{0x7694, 0x05},{0x7695, 0x83},{0x7696, 0x07},{0x7697, 0x02},
+	{0x7698, 0x03},{0x7699, 0x0b},{0x769a, 0x05},{0x769b, 0x83},{0x769c, 0x00},
+	{0x769d, 0x08},{0x769e, 0x05},{0x769f, 0x03},{0x76a0, 0x05},{0x76a1, 0x32},
+	{0x76a2, 0x00},{0x76a3, 0x00},{0x76a4, 0x05},{0x76a5, 0x70},{0x76a6, 0x00},
+	{0x76a7, 0x01},{0x76a8, 0x05},{0x76a9, 0x74},{0x76aa, 0x03},{0x76ab, 0x9a},
+	{0x76ac, 0x05},{0x76ad, 0x83},{0x76ae, 0x00},{0x76af, 0x05},{0x76b0, 0x05},
+	{0x76b1, 0x03},{0x76b2, 0x05},{0x76b3, 0x32},{0x76b4, 0x00},{0x76b5, 0x00},
+	{0x76b6, 0x05},{0x76b7, 0x70},{0x76b8, 0x00},{0x76b9, 0x01},{0x76ba, 0x05},
+	{0x76bb, 0x74},{0x76bc, 0x03},{0x76bd, 0x99},{0x76be, 0x05},{0x76bf, 0x83},
+	{0x76c0, 0x00},{0x76c1, 0x03},{0x76c2, 0x05},{0x76c3, 0x03},{0x76c4, 0x05},
+	{0x76c5, 0x32},{0x76c6, 0x00},{0x76c7, 0x00},{0x76c8, 0x05},{0x76c9, 0x70},
+	{0x76ca, 0x00},{0x76cb, 0x01},{0x76cc, 0x05},{0x76cd, 0x74},{0x76ce, 0x03},
+	{0x76cf, 0x98},{0x76d0, 0x05},{0x76d1, 0x83},{0x76d2, 0x00},{0x76d3, 0x01},
+	{0x76d4, 0x05},{0x76d5, 0x03},{0x76d6, 0x05},{0x76d7, 0x32},{0x76d8, 0x00},
+	{0x76d9, 0x00},{0x76da, 0x05},{0x76db, 0x70},{0x76dc, 0x00},{0x76dd, 0x01},
+	{0x76de, 0x05},{0x76df, 0x74},{0x76e0, 0x03},{0x76e1, 0x97},{0x76e2, 0x05},
+	{0x76e3, 0x83},{0x76e4, 0x00},{0x76e5, 0x01},{0x76e6, 0x05},{0x76e7, 0x03},
+	{0x76e8, 0x05},{0x76e9, 0x32},{0x76ea, 0x00},{0x76eb, 0x00},{0x76ec, 0x05},
+	{0x76ed, 0x70},{0x76ee, 0x00},{0x76ef, 0x01},{0x76f0, 0x05},{0x76f1, 0x74},
+	{0x76f2, 0x03},{0x76f3, 0x96},{0x76f4, 0x05},{0x76f5, 0x83},{0x76f6, 0x00},
+	{0x76f7, 0x01},{0x76f8, 0x05},{0x76f9, 0x03},{0x76fa, 0x05},{0x76fb, 0x32},
+	{0x76fc, 0x00},{0x76fd, 0x00},{0x76fe, 0x05},{0x76ff, 0x70},{0x7700, 0x00},
+	{0x7701, 0x01},{0x7702, 0x05},{0x7703, 0x74},{0x7704, 0x03},{0x7705, 0x95},
+	{0x7706, 0x05},{0x7707, 0x83},{0x7708, 0x00},{0x7709, 0x01},{0x770a, 0x05},
+	{0x770b, 0x03},{0x770c, 0x05},{0x770d, 0x32},{0x770e, 0x00},{0x770f, 0x00},
+	{0x7710, 0x05},{0x7711, 0x70},{0x7712, 0x00},{0x7713, 0x01},{0x7714, 0x05},
+	{0x7715, 0x74},{0x7716, 0x03},{0x7717, 0x94},{0x7718, 0x05},{0x7719, 0x83},
+	{0x771a, 0x00},{0x771b, 0x03},{0x771c, 0x05},{0x771d, 0x03},{0x771e, 0x05},
+	{0x771f, 0x32},{0x7720, 0x00},{0x7721, 0x00},{0x7722, 0x05},{0x7723, 0x70},
+	{0x7724, 0x00},{0x7725, 0x01},{0x7726, 0x05},{0x7727, 0x74},{0x7728, 0x03},
+	{0x7729, 0x93},{0x772a, 0x05},{0x772b, 0x83},{0x772c, 0x00},{0x772d, 0x02},
+	{0x772e, 0x05},{0x772f, 0x03},{0x7730, 0x05},{0x7731, 0x32},{0x7732, 0x00},
+	{0x7733, 0x00},{0x7734, 0x05},{0x7735, 0x70},{0x7736, 0x00},{0x7737, 0x01},
+	{0x7738, 0x05},{0x7739, 0x74},{0x773a, 0x03},{0x773b, 0x92},{0x773c, 0x05},
+	{0x773d, 0x83},{0x773e, 0x00},{0x773f, 0x01},{0x7740, 0x05},{0x7741, 0x03},
+	{0x7742, 0x05},{0x7743, 0x32},{0x7744, 0x00},{0x7745, 0x00},{0x7746, 0x05},
+	{0x7747, 0x70},{0x7748, 0x00},{0x7749, 0x01},{0x774a, 0x05},{0x774b, 0x74},
+	{0x774c, 0x03},{0x774d, 0x91},{0x774e, 0x05},{0x774f, 0x83},{0x7750, 0x00},
+	{0x7751, 0x01},{0x7752, 0x05},{0x7753, 0x03},{0x7754, 0x05},{0x7755, 0x32},
+	{0x7756, 0x00},{0x7757, 0x00},{0x7758, 0x05},{0x7759, 0x70},{0x775a, 0x00},
+	{0x775b, 0x01},{0x775c, 0x05},{0x775d, 0x74},{0x775e, 0x03},{0x775f, 0x90},
+	{0x7760, 0x05},{0x7761, 0x83},{0x7762, 0x00},{0x7763, 0x01},{0x7764, 0x05},
+	{0x7765, 0x03},{0x7766, 0x05},{0x7767, 0x32},{0x7768, 0x00},{0x7769, 0x00},
+	{0x776a, 0x05},{0x776b, 0x70},{0x776c, 0x00},{0x776d, 0x01},{0x776e, 0x05},
+	{0x776f, 0x74},{0x7770, 0x02},{0x7771, 0x90},{0x7772, 0x05},{0x7773, 0x03},
+	{0x7774, 0x07},{0x7775, 0x00},{0x7776, 0x0f},{0x7777, 0x00},{0x7778, 0x08},
+	{0x7779, 0x31},{0x777a, 0x08},{0x777b, 0xd1},{0x777c, 0x0f},{0x777d, 0x00},
+	{0x777e, 0x04},{0x777f, 0xe5},{0x7780, 0x06},{0x7781, 0x50},{0x7782, 0x04},
+	{0x7783, 0xe4},{0x7784, 0x00},{0x7785, 0x00},{0x7786, 0x06},{0x7787, 0x5c},
+	{0x7788, 0x09},{0x7789, 0x14},{0x778a, 0x06},{0x778b, 0x1c},{0x778c, 0x00},
+	{0x778d, 0x02},{0x778e, 0x06},{0x778f, 0xa0},{0x7790, 0x00},{0x7791, 0x01},
+	{0x7792, 0x06},{0x7793, 0xac},{0x7794, 0x00},{0x7795, 0x0f},{0x7796, 0x05},
+	{0x7797, 0x30},{0x7798, 0x0f},{0x7799, 0x00},{0x779a, 0x00},{0x779b, 0x00},
+	{0x779c, 0x00},{0x779d, 0x02},{0x779e, 0x04},{0x779f, 0xe5},{0x77a0, 0x04},
+	{0x77a1, 0xe4},{0x77a2, 0x07},{0x77a3, 0x10},{0x77a4, 0x00},{0x77a5, 0x00},
+	{0x77a6, 0x07},{0x77a7, 0x00},{0x77a8, 0x01},{0x77a9, 0xbb},{0x77aa, 0x07},
+	{0x77ab, 0x10},{0x77ac, 0x00},{0x77ad, 0x00},{0x77ae, 0x07},{0x77af, 0x00},
+	{0x77b0, 0x01},{0x77b1, 0xaa},{0x77b2, 0x07},{0x77b3, 0x10},{0x77b4, 0x00},
+	{0x77b5, 0x00},{0x77b6, 0x07},{0x77b7, 0x00},{0x77b8, 0x01},{0x77b9, 0x99},
+	{0x77ba, 0x07},{0x77bb, 0x10},{0x77bc, 0x00},{0x77bd, 0x00},{0x77be, 0x07},
+	{0x77bf, 0x00},{0x77c0, 0x01},{0x77c1, 0x88},{0x77c2, 0x07},{0x77c3, 0x10},
+	{0x77c4, 0x00},{0x77c5, 0x00},{0x77c6, 0x07},{0x77c7, 0x00},{0x77c8, 0x01},
+	{0x77c9, 0x77},{0x77ca, 0x07},{0x77cb, 0x10},{0x77cc, 0x00},{0x77cd, 0x00},
+	{0x77ce, 0x07},{0x77cf, 0x00},{0x77d0, 0x01},{0x77d1, 0x66},{0x77d2, 0x07},
+	{0x77d3, 0x10},{0x77d4, 0x00},{0x77d5, 0x00},{0x77d6, 0x07},{0x77d7, 0x00},
+	{0x77d8, 0x01},{0x77d9, 0x55},{0x77da, 0x07},{0x77db, 0x10},{0x77dc, 0x00},
+	{0x77dd, 0x00},{0x77de, 0x07},{0x77df, 0x00},{0x77e0, 0x01},{0x77e1, 0x44},
+	{0x77e2, 0x07},{0x77e3, 0x10},{0x77e4, 0x00},{0x77e5, 0x00},{0x77e6, 0x07},
+	{0x77e7, 0x00},{0x77e8, 0x01},{0x77e9, 0x33},{0x77ea, 0x07},{0x77eb, 0x10},
+	{0x77ec, 0x00},{0x77ed, 0x00},{0x77ee, 0x07},{0x77ef, 0x00},{0x77f0, 0x01},
+	{0x77f1, 0x22},{0x77f2, 0x07},{0x77f3, 0x10},{0x77f4, 0x00},{0x77f5, 0x00},
+	{0x77f6, 0x07},{0x77f7, 0x00},{0x77f8, 0x01},{0x77f9, 0x11},{0x77fa, 0x07},
+	{0x77fb, 0x10},{0x77fc, 0x00},{0x77fd, 0x00},{0x77fe, 0x07},{0x77ff, 0x00},
+	{0x7800, 0x01},{0x7801, 0x00},{0x7802, 0x01},{0x7803, 0xff},{0x7804, 0x07},
+	{0x7805, 0x00},{0x7806, 0x02},{0x7807, 0xa0},{0x7808, 0x05},{0x7809, 0x33},
+	{0x780a, 0x0f},{0x780b, 0x00},{0x780c, 0x08},{0x780d, 0x36},{0x780e, 0x06},
+	{0x780f, 0x50},{0x7810, 0x04},{0x7811, 0xe4},{0x7812, 0x00},{0x7813, 0x00},
+	{0x7814, 0x06},{0x7815, 0x5c},{0x7816, 0x09},{0x7817, 0x14},{0x7818, 0x06},
+	{0x7819, 0x1c},{0x781a, 0x05},{0x781b, 0x33},{0x781c, 0x00},{0x781d, 0x01},
+	{0x781e, 0x06},{0x781f, 0x24},{0x7820, 0x00},{0x7821, 0x01},{0x7822, 0x06},
+	{0x7823, 0x20},{0x7824, 0x0f},{0x7825, 0x00},{0x7826, 0x08},{0x7827, 0x36},
+	{0x7828, 0x07},{0x7829, 0x10},{0x782a, 0x00},{0x782b, 0x00},{0x782c, 0x07},
+	{0x782d, 0x00},{0x782e, 0x01},{0x782f, 0xbb},{0x7830, 0x07},{0x7831, 0x10},
+	{0x7832, 0x00},{0x7833, 0x00},{0x7834, 0x07},{0x7835, 0x00},{0x7836, 0x01},
+	{0x7837, 0xaa},{0x7838, 0x07},{0x7839, 0x10},{0x783a, 0x00},{0x783b, 0x00},
+	{0x783c, 0x07},{0x783d, 0x00},{0x783e, 0x01},{0x783f, 0x99},{0x7840, 0x07},
+	{0x7841, 0x10},{0x7842, 0x00},{0x7843, 0x00},{0x7844, 0x07},{0x7845, 0x00},
+	{0x7846, 0x01},{0x7847, 0x88},{0x7848, 0x07},{0x7849, 0x10},{0x784a, 0x00},
+	{0x784b, 0x00},{0x784c, 0x07},{0x784d, 0x00},{0x784e, 0x01},{0x784f, 0x77},
+	{0x7850, 0x07},{0x7851, 0x10},{0x7852, 0x00},{0x7853, 0x00},{0x7854, 0x07},
+	{0x7855, 0x00},{0x7856, 0x01},{0x7857, 0x66},{0x7858, 0x07},{0x7859, 0x10},
+	{0x785a, 0x00},{0x785b, 0x00},{0x785c, 0x07},{0x785d, 0x00},{0x785e, 0x01},
+	{0x785f, 0x55},{0x7860, 0x07},{0x7861, 0x10},{0x7862, 0x00},{0x7863, 0x00},
+	{0x7864, 0x07},{0x7865, 0x00},{0x7866, 0x01},{0x7867, 0x44},{0x7868, 0x07},
+	{0x7869, 0x10},{0x786a, 0x00},{0x786b, 0x00},{0x786c, 0x07},{0x786d, 0x00},
+	{0x786e, 0x01},{0x786f, 0x33},{0x7870, 0x07},{0x7871, 0x10},{0x7872, 0x00},
+	{0x7873, 0x00},{0x7874, 0x07},{0x7875, 0x00},{0x7876, 0x01},{0x7877, 0x22},
+	{0x7878, 0x07},{0x7879, 0x10},{0x787a, 0x00},{0x787b, 0x00},{0x787c, 0x07},
+	{0x787d, 0x00},{0x787e, 0x01},{0x787f, 0x11},{0x7880, 0x07},{0x7881, 0x10},
+	{0x7882, 0x00},{0x7883, 0x00},{0x7884, 0x07},{0x7885, 0x00},{0x7886, 0x01},
+	{0x7887, 0x00},{0x7888, 0x01},{0x7889, 0xff},{0x788a, 0x02},{0x788b, 0xa0},
+	{0x788c, 0x05},{0x788d, 0x33},{0x788e, 0x0f},{0x788f, 0x00},{0x7890, 0x08},
+	{0x7891, 0x3b},{0x7892, 0x08},{0x7893, 0x5e},{0x7894, 0x0f},{0x7895, 0x00},
+	{0x7896, 0x04},{0x7897, 0xc0},{0x7898, 0x09},{0x7899, 0x14},{0x789a, 0x04},
+	{0x789b, 0x99},{0x789c, 0x07},{0x789d, 0x14},{0x789e, 0x04},{0x789f, 0x80},
+	{0x78a0, 0x04},{0x78a1, 0xa4},{0x78a2, 0x00},{0x78a3, 0x0a},{0x78a4, 0x04},
+	{0x78a5, 0xa6},{0x78a6, 0x00},{0x78a7, 0x00},{0x78a8, 0x04},{0x78a9, 0xa0},
+	{0x78aa, 0x04},{0x78ab, 0x80},{0x78ac, 0x04},{0x78ad, 0x00},{0x78ae, 0x05},
+	{0x78af, 0x03},{0x78b0, 0x06},{0x78b1, 0x00},{0x78b2, 0x0f},{0x78b3, 0x00},
+	{0x78b4, 0x0f},{0x78b5, 0x00},{0x78b6, 0x0f},{0x78b7, 0x00},{0x30b0, 0x09},
+	{0x30b1, 0x60},{0x30b2, 0x04},{0x30b3, 0x65},{0x3196, 0x00},{0x3197, 0x00},
+	{0x3195, 0x27},{0x315a, 0x02},{0x315b, 0x00},{0x315c, 0x02},{0x315d, 0x86},
+	{0x315e, 0x02},{0x315f, 0x86},{0x304b, 0x00},{0x304d, 0xa4},{0x3033, 0x30},
+
+	/* mirror on */
+	{0x30c0, 0x04},{0x30a9, 0x05},{0x3252, 0x21},
+
+	{0x3012, 0x01},{0x3030, 0x02},
+};
+
+/* Linear Gain Table */
+#define OV2718_GAIN_ROWS			(715)
+#define OV2718_GAIN_COLS			(2)
+#define OV2718_GAIN_MAXDB		(714)
+
+#define OV2718_GAIN_COL_AGAIN	(0)
+#define OV2718_GAIN_COL_DGAIN	(1)
+
+static const u16 OV2718_GAIN_TABLE[OV2718_GAIN_ROWS][OV2718_GAIN_COLS] = {
+	{0x00, 0x0286}, /* index:0, gain:0.00000db -> x2.523438, DCG:off */
+	{0x00, 0x028d}, /* index:1, gain:0.09375db -> x2.550821, DCG:off */
+	{0x00, 0x0294}, /* index:2, gain:0.18750db -> x2.578502, DCG:off */
+	{0x00, 0x029b}, /* index:3, gain:0.28125db -> x2.606484, DCG:off */
+	{0x00, 0x02a2}, /* index:4, gain:0.37500db -> x2.634769, DCG:off */
+	{0x00, 0x02a9}, /* index:5, gain:0.46875db -> x2.663361, DCG:off */
+	{0x00, 0x02b1}, /* index:6, gain:0.56250db -> x2.692263, DCG:off */
+	{0x00, 0x02b8}, /* index:7, gain:0.65625db -> x2.721479, DCG:off */
+	{0x00, 0x02c0}, /* index:8, gain:0.75000db -> x2.751012, DCG:off */
+	{0x00, 0x02c7}, /* index:9, gain:0.84375db -> x2.780866, DCG:off */
+	{0x00, 0x02cf}, /* index:10, gain:0.93750db -> x2.811043, DCG:off */
+	{0x00, 0x02d7}, /* index:11, gain:1.03125db -> x2.841548, DCG:off */
+	{0x00, 0x02df}, /* index:12, gain:1.12500db -> x2.872384, DCG:off */
+	{0x00, 0x02e7}, /* index:13, gain:1.21875db -> x2.903555, DCG:off */
+	{0x00, 0x02ef}, /* index:14, gain:1.31250db -> x2.935064, DCG:off */
+	{0x00, 0x02f7}, /* index:15, gain:1.40625db -> x2.966915, DCG:off */
+	{0x00, 0x02ff}, /* index:16, gain:1.50000db -> x2.999111, DCG:off */
+	{0x00, 0x0308}, /* index:17, gain:1.59375db -> x3.031657, DCG:off */
+	{0x00, 0x0310}, /* index:18, gain:1.68750db -> x3.064556, DCG:off */
+	{0x00, 0x0319}, /* index:19, gain:1.78125db -> x3.097812, DCG:off */
+	{0x00, 0x0321}, /* index:20, gain:1.87500db -> x3.131429, DCG:off */
+	{0x00, 0x032a}, /* index:21, gain:1.96875db -> x3.165411, DCG:off */
+	{0x00, 0x0333}, /* index:22, gain:2.06250db -> x3.199761, DCG:off */
+	{0x00, 0x033c}, /* index:23, gain:2.15625db -> x3.234484, DCG:off */
+	{0x00, 0x0345}, /* index:24, gain:2.25000db -> x3.269584, DCG:off */
+	{0x00, 0x034e}, /* index:25, gain:2.34375db -> x3.305065, DCG:off */
+	{0x00, 0x0357}, /* index:26, gain:2.43750db -> x3.340931, DCG:off */
+	{0x00, 0x0360}, /* index:27, gain:2.53125db -> x3.377187, DCG:off */
+	{0x00, 0x0369}, /* index:28, gain:2.62500db -> x3.413835, DCG:off */
+	{0x00, 0x0373}, /* index:29, gain:2.71875db -> x3.450882, DCG:off */
+	{0x00, 0x037d}, /* index:30, gain:2.81250db -> x3.488330, DCG:off */
+	{0x00, 0x0386}, /* index:31, gain:2.90625db -> x3.526185, DCG:off */
+	{0x00, 0x0390}, /* index:32, gain:3.00000db -> x3.564450, DCG:off */
+	{0x00, 0x039a}, /* index:33, gain:3.09375db -> x3.603131, DCG:off */
+	{0x00, 0x03a4}, /* index:34, gain:3.18750db -> x3.642232, DCG:off */
+	{0x00, 0x03ae}, /* index:35, gain:3.28125db -> x3.681756, DCG:off */
+	{0x00, 0x03b8}, /* index:36, gain:3.37500db -> x3.721710, DCG:off */
+	{0x00, 0x03c3}, /* index:37, gain:3.46875db -> x3.762098, DCG:off */
+	{0x00, 0x03cd}, /* index:38, gain:3.56250db -> x3.802923, DCG:off */
+	{0x00, 0x03d8}, /* index:39, gain:3.65625db -> x3.844192, DCG:off */
+	{0x00, 0x03e2}, /* index:40, gain:3.75000db -> x3.885908, DCG:off */
+	{0x00, 0x03ed}, /* index:41, gain:3.84375db -> x3.928078, DCG:off */
+	{0x00, 0x03f8}, /* index:42, gain:3.93750db -> x3.970704, DCG:off */
+	{0x00, 0x0403}, /* index:43, gain:4.03125db -> x4.013794, DCG:off */
+	{0x00, 0x040e}, /* index:44, gain:4.12500db -> x4.057351, DCG:off */
+	{0x00, 0x0419}, /* index:45, gain:4.21875db -> x4.101380, DCG:off */
+	{0x00, 0x0425}, /* index:46, gain:4.31250db -> x4.145888, DCG:off */
+	{0x00, 0x0430}, /* index:47, gain:4.40625db -> x4.190878, DCG:off */
+	{0x00, 0x043c}, /* index:48, gain:4.50000db -> x4.236357, DCG:off */
+	{0x00, 0x0448}, /* index:49, gain:4.59375db -> x4.282329, DCG:off */
+	{0x00, 0x0454}, /* index:50, gain:4.68750db -> x4.328800, DCG:off */
+	{0x00, 0x0460}, /* index:51, gain:4.78125db -> x4.375776, DCG:off */
+	{0x00, 0x046c}, /* index:52, gain:4.87500db -> x4.423261, DCG:off */
+	{0x00, 0x0478}, /* index:53, gain:4.96875db -> x4.471261, DCG:off */
+	{0x00, 0x0485}, /* index:54, gain:5.06250db -> x4.519783, DCG:off */
+	{0x00, 0x0491}, /* index:55, gain:5.15625db -> x4.568831, DCG:off */
+	{0x00, 0x049e}, /* index:56, gain:5.25000db -> x4.618411, DCG:off */
+	{0x00, 0x04ab}, /* index:57, gain:5.34375db -> x4.668529, DCG:off */
+	{0x00, 0x04b8}, /* index:58, gain:5.43750db -> x4.719191, DCG:off */
+	{0x00, 0x04c5}, /* index:59, gain:5.53125db -> x4.770403, DCG:off */
+	{0x00, 0x04d2}, /* index:60, gain:5.62500db -> x4.822170, DCG:off */
+	{0x00, 0x04df}, /* index:61, gain:5.71875db -> x4.874500, DCG:off */
+	{0x00, 0x04ed}, /* index:62, gain:5.81250db -> x4.927397, DCG:off */
+	{0x00, 0x04fb}, /* index:63, gain:5.90625db -> x4.980868, DCG:off */
+	{0x00, 0x0508}, /* index:64, gain:6.00000db -> x5.034920, DCG:off */
+	{0x01, 0x028b}, /* index:65, gain:6.09375db -> x5.089558, DCG:off */
+	{0x01, 0x0292}, /* index:66, gain:6.18750db -> x5.144789, DCG:off */
+	{0x01, 0x0299}, /* index:67, gain:6.28125db -> x5.200619, DCG:off */
+	{0x01, 0x02a0}, /* index:68, gain:6.37500db -> x5.257055, DCG:off */
+	{0x01, 0x02a8}, /* index:69, gain:6.46875db -> x5.314104, DCG:off */
+	{0x01, 0x02af}, /* index:70, gain:6.56250db -> x5.371772, DCG:off */
+	{0x01, 0x02b7}, /* index:71, gain:6.65625db -> x5.430065, DCG:off */
+	{0x01, 0x02be}, /* index:72, gain:6.75000db -> x5.488992, DCG:off */
+	{0x01, 0x02c6}, /* index:73, gain:6.84375db -> x5.548557, DCG:off */
+	{0x01, 0x02cd}, /* index:74, gain:6.93750db -> x5.608769, DCG:off */
+	{0x01, 0x02d5}, /* index:75, gain:7.03125db -> x5.669634, DCG:off */
+	{0x01, 0x02dd}, /* index:76, gain:7.12500db -> x5.731160, DCG:off */
+	{0x01, 0x02e5}, /* index:77, gain:7.21875db -> x5.793354, DCG:off */
+	{0x01, 0x02ed}, /* index:78, gain:7.31250db -> x5.856222, DCG:off */
+	{0x01, 0x02f5}, /* index:79, gain:7.40625db -> x5.919773, DCG:off */
+	{0x01, 0x02fd}, /* index:80, gain:7.50000db -> x5.984013, DCG:off */
+	{0x01, 0x0306}, /* index:81, gain:7.59375db -> x6.048951, DCG:off */
+	{0x01, 0x030e}, /* index:82, gain:7.68750db -> x6.114593, DCG:off */
+	{0x01, 0x0317}, /* index:83, gain:7.78125db -> x6.180947, DCG:off */
+	{0x01, 0x031f}, /* index:84, gain:7.87500db -> x6.248022, DCG:off */
+	{0x01, 0x0328}, /* index:85, gain:7.96875db -> x6.315824, DCG:off */
+	{0x01, 0x0331}, /* index:86, gain:8.06250db -> x6.384363, DCG:off */
+	{0x01, 0x033a}, /* index:87, gain:8.15625db -> x6.453645, DCG:off */
+	{0x01, 0x0343}, /* index:88, gain:8.25000db -> x6.523678, DCG:off */
+	{0x01, 0x034c}, /* index:89, gain:8.34375db -> x6.594473, DCG:off */
+	{0x01, 0x0355}, /* index:90, gain:8.43750db -> x6.666034, DCG:off */
+	{0x01, 0x035e}, /* index:91, gain:8.53125db -> x6.738373, DCG:off */
+	{0x01, 0x0367}, /* index:92, gain:8.62500db -> x6.811497, DCG:off */
+	{0x01, 0x0371}, /* index:93, gain:8.71875db -> x6.885414, DCG:off */
+	{0x01, 0x037a}, /* index:94, gain:8.81250db -> x6.960133, DCG:off */
+	{0x01, 0x0384}, /* index:95, gain:8.90625db -> x7.035663, DCG:off */
+	{0x01, 0x038e}, /* index:96, gain:9.00000db -> x7.112013, DCG:off */
+	{0x01, 0x0398}, /* index:97, gain:9.09375db -> x7.189192, DCG:off */
+	{0x01, 0x03a2}, /* index:98, gain:9.18750db -> x7.267207, DCG:off */
+	{0x01, 0x03ac}, /* index:99, gain:9.28125db -> x7.346070, DCG:off */
+	{0x01, 0x03b6}, /* index:100, gain:9.37500db -> x7.425788, DCG:off */
+	{0x01, 0x03c0}, /* index:101, gain:9.46875db -> x7.506371, DCG:off */
+	{0x01, 0x03cb}, /* index:102, gain:9.56250db -> x7.587829, DCG:off */
+	{0x01, 0x03d5}, /* index:103, gain:9.65625db -> x7.670171, DCG:off */
+	{0x01, 0x03e0}, /* index:104, gain:9.75000db -> x7.753407, DCG:off */
+	{0x01, 0x03eb}, /* index:105, gain:9.84375db -> x7.837545, DCG:off */
+	{0x01, 0x03f6}, /* index:106, gain:9.93750db -> x7.922597, DCG:off */
+	{0x01, 0x0401}, /* index:107, gain:10.03125db -> x8.008571, DCG:off */
+	{0x01, 0x040c}, /* index:108, gain:10.12500db -> x8.095479, DCG:off */
+	{0x01, 0x0417}, /* index:109, gain:10.21875db -> x8.183330, DCG:off */
+	{0x01, 0x0422}, /* index:110, gain:10.31250db -> x8.272134, DCG:off */
+	{0x01, 0x042e}, /* index:111, gain:10.40625db -> x8.361901, DCG:off */
+	{0x01, 0x0439}, /* index:112, gain:10.50000db -> x8.452643, DCG:off */
+	{0x01, 0x0445}, /* index:113, gain:10.59375db -> x8.544371, DCG:off */
+	{0x01, 0x0451}, /* index:114, gain:10.68750db -> x8.637092, DCG:off */
+	{0x01, 0x045d}, /* index:115, gain:10.78125db -> x8.730820, DCG:off */
+	{0x01, 0x0469}, /* index:116, gain:10.87500db -> x8.825565, DCG:off */
+	{0x01, 0x0475}, /* index:117, gain:10.96875db -> x8.921339, DCG:off */
+	{0x01, 0x0482}, /* index:118, gain:11.06250db -> x9.018153, DCG:off */
+	{0x01, 0x048e}, /* index:119, gain:11.15625db -> x9.116016, DCG:off */
+	{0x01, 0x049b}, /* index:120, gain:11.25000db -> x9.214941, DCG:off */
+	{0x01, 0x04a8}, /* index:121, gain:11.34375db -> x9.314940, DCG:off */
+	{0x01, 0x04b5}, /* index:122, gain:11.43750db -> x9.416023, DCG:off */
+	{0x01, 0x04c2}, /* index:123, gain:11.53125db -> x9.518205, DCG:off */
+	{0x01, 0x04cf}, /* index:124, gain:11.62500db -> x9.621495, DCG:off */
+	{0x01, 0x04dc}, /* index:125, gain:11.71875db -> x9.725906, DCG:off */
+	{0x01, 0x04ea}, /* index:126, gain:11.81250db -> x9.831449, DCG:off */
+	{0x01, 0x04f8}, /* index:127, gain:11.90625db -> x9.938138, DCG:off */
+	{0x01, 0x0505}, /* index:128, gain:12.00000db -> x10.045986, DCG:off */
+	{0x02, 0x0289}, /* index:129, gain:12.09375db -> x10.155003, DCG:off */
+	{0x02, 0x0290}, /* index:130, gain:12.18750db -> x10.265203, DCG:off */
+	{0x02, 0x0298}, /* index:131, gain:12.28125db -> x10.376599, DCG:off */
+	{0x02, 0x029f}, /* index:132, gain:12.37500db -> x10.489204, DCG:off */
+	{0x02, 0x02a6}, /* index:133, gain:12.46875db -> x10.603032, DCG:off */
+	{0x02, 0x02ad}, /* index:134, gain:12.56250db -> x10.718094, DCG:off */
+	{0x02, 0x02b5}, /* index:135, gain:12.65625db -> x10.834405, DCG:off */
+	{0x02, 0x02bc}, /* index:136, gain:12.75000db -> x10.951977, DCG:off */
+	{0x02, 0x02c4}, /* index:137, gain:12.84375db -> x11.070826, DCG:off */
+	{0x02, 0x02cc}, /* index:138, gain:12.93750db -> x11.190966, DCG:off */
+	{0x02, 0x02d3}, /* index:139, gain:13.03125db -> x11.312408, DCG:off */
+	{0x02, 0x02db}, /* index:140, gain:13.12500db -> x11.435168, DCG:off */
+	{0x02, 0x02e3}, /* index:141, gain:13.21875db -> x11.559260, DCG:off */
+	{0x02, 0x02eb}, /* index:142, gain:13.31250db -> x11.684699, DCG:off */
+	{0x02, 0x02f3}, /* index:143, gain:13.40625db -> x11.811501, DCG:off */
+	{0x02, 0x02fc}, /* index:144, gain:13.50000db -> x11.939677, DCG:off */
+	{0x02, 0x0304}, /* index:145, gain:13.59375db -> x12.069244, DCG:off */
+	{0x02, 0x030c}, /* index:146, gain:13.68750db -> x12.200217, DCG:off */
+	{0x02, 0x0315}, /* index:147, gain:13.78125db -> x12.332611, DCG:off */
+	{0x02, 0x031d}, /* index:148, gain:13.87500db -> x12.466444, DCG:off */
+	{0x02, 0x0326}, /* index:149, gain:13.96875db -> x12.601727, DCG:off */
+	{0x02, 0x032f}, /* index:150, gain:14.06250db -> x12.738478, DCG:off */
+	{0x02, 0x0338}, /* index:151, gain:14.15625db -> x12.876714, DCG:off */
+	{0x02, 0x0341}, /* index:152, gain:14.25000db -> x13.016449, DCG:off */
+	{0x02, 0x034a}, /* index:153, gain:14.34375db -> x13.157703, DCG:off */
+	{0x02, 0x0353}, /* index:154, gain:14.43750db -> x13.300488, DCG:off */
+	{0x02, 0x035c}, /* index:155, gain:14.53125db -> x13.444822, DCG:off */
+	{0x02, 0x0365}, /* index:156, gain:14.62500db -> x13.590722, DCG:off */
+	{0x02, 0x036f}, /* index:157, gain:14.71875db -> x13.738206, DCG:off */
+	{0x02, 0x0378}, /* index:158, gain:14.81250db -> x13.887292, DCG:off */
+	{0x02, 0x0382}, /* index:159, gain:14.90625db -> x14.037994, DCG:off */
+	{0x02, 0x038c}, /* index:160, gain:15.00000db -> x14.190332, DCG:off */
+	{0x02, 0x0396}, /* index:161, gain:15.09375db -> x14.344322, DCG:off */
+	{0x02, 0x039f}, /* index:162, gain:15.18750db -> x14.499984, DCG:off */
+	{0x02, 0x03aa}, /* index:163, gain:15.28125db -> x14.657337, DCG:off */
+	{0x02, 0x03b4}, /* index:164, gain:15.37500db -> x14.816396, DCG:off */
+	{0x02, 0x03be}, /* index:165, gain:15.46875db -> x14.977180, DCG:off */
+	{0x02, 0x03c8}, /* index:166, gain:15.56250db -> x15.139709, DCG:off */
+	{0x02, 0x03d3}, /* index:167, gain:15.65625db -> x15.304003, DCG:off */
+	{0x02, 0x03de}, /* index:168, gain:15.75000db -> x15.470081, DCG:off */
+	{0x02, 0x03e8}, /* index:169, gain:15.84375db -> x15.637959, DCG:off */
+	{0x02, 0x03f3}, /* index:170, gain:15.93750db -> x15.807659, DCG:off */
+	{0x02, 0x03fe}, /* index:171, gain:16.03125db -> x15.979200, DCG:off */
+	{0x02, 0x0409}, /* index:172, gain:16.12500db -> x16.152603, DCG:off */
+	{0x02, 0x0414}, /* index:173, gain:16.21875db -> x16.327890, DCG:off */
+	{0x02, 0x0420}, /* index:174, gain:16.31250db -> x16.505077, DCG:off */
+	{0x02, 0x042b}, /* index:175, gain:16.40625db -> x16.684187, DCG:off */
+	{0x02, 0x0437}, /* index:176, gain:16.50000db -> x16.865241, DCG:off */
+	{0x02, 0x0443}, /* index:177, gain:16.59375db -> x17.048259, DCG:off */
+	{0x02, 0x044e}, /* index:178, gain:16.68750db -> x17.233265, DCG:off */
+	{0x02, 0x045a}, /* index:179, gain:16.78125db -> x17.420277, DCG:off */
+	{0x02, 0x0466}, /* index:180, gain:16.87500db -> x17.609319, DCG:off */
+	{0x02, 0x0473}, /* index:181, gain:16.96875db -> x17.800411, DCG:off */
+	{0x02, 0x047f}, /* index:182, gain:17.06250db -> x17.993578, DCG:off */
+	{0x02, 0x048c}, /* index:183, gain:17.15625db -> x18.188843, DCG:off */
+	{0x02, 0x0498}, /* index:184, gain:17.25000db -> x18.386225, DCG:off */
+	{0x02, 0x04a5}, /* index:185, gain:17.34375db -> x18.585748, DCG:off */
+	{0x02, 0x04b2}, /* index:186, gain:17.43750db -> x18.787437, DCG:off */
+	{0x02, 0x04bf}, /* index:187, gain:17.53125db -> x18.991315, DCG:off */
+	{0x02, 0x04cc}, /* index:188, gain:17.62500db -> x19.197407, DCG:off */
+	{0x02, 0x04d9}, /* index:189, gain:17.71875db -> x19.405734, DCG:off */
+	{0x02, 0x04e7}, /* index:190, gain:17.81250db -> x19.616321, DCG:off */
+	{0x02, 0x04f5}, /* index:191, gain:17.90625db -> x19.829193, DCG:off */
+	{0x02, 0x0502}, /* index:192, gain:18.00000db -> x20.044375, DCG:off */
+	{0x03, 0x0288}, /* index:193, gain:18.09375db -> x20.261896, DCG:off */
+	{0x03, 0x028f}, /* index:194, gain:18.18750db -> x20.481774, DCG:off */
+	{0x03, 0x0296}, /* index:195, gain:18.28125db -> x20.704038, DCG:off */
+	{0x03, 0x029d}, /* index:196, gain:18.37500db -> x20.928714, DCG:off */
+	{0x03, 0x02a4}, /* index:197, gain:18.46875db -> x21.155828, DCG:off */
+	{0x03, 0x02ac}, /* index:198, gain:18.56250db -> x21.385410, DCG:off */
+	{0x03, 0x02b3}, /* index:199, gain:18.65625db -> x21.617480, DCG:off */
+	{0x03, 0x02bb}, /* index:200, gain:18.75000db -> x21.852068, DCG:off */
+	{0x40, 0x0202}, /* index:201, gain:18.84375db -> x22.089203, DCG:on */
+	{0x40, 0x0207}, /* index:202, gain:18.93750db -> x22.328910, DCG:on */
+	{0x40, 0x020d}, /* index:203, gain:19.03125db -> x22.571222, DCG:on */
+	{0x40, 0x0212}, /* index:204, gain:19.12500db -> x22.816161, DCG:on */
+	{0x40, 0x0218}, /* index:205, gain:19.21875db -> x23.063757, DCG:on */
+	{0x40, 0x021e}, /* index:206, gain:19.31250db -> x23.314040, DCG:on */
+	{0x40, 0x0224}, /* index:207, gain:19.40625db -> x23.567039, DCG:on */
+	{0x40, 0x022a}, /* index:208, gain:19.50000db -> x23.822787, DCG:on */
+	{0x40, 0x0230}, /* index:209, gain:19.59375db -> x24.081308, DCG:on */
+	{0x40, 0x0236}, /* index:210, gain:19.68750db -> x24.342633, DCG:on */
+	{0x40, 0x023c}, /* index:211, gain:19.78125db -> x24.606794, DCG:on */
+	{0x40, 0x0242}, /* index:212, gain:19.87500db -> x24.873822, DCG:on */
+	{0x40, 0x0249}, /* index:213, gain:19.96875db -> x25.143752, DCG:on */
+	{0x40, 0x024f}, /* index:214, gain:20.06250db -> x25.416603, DCG:on */
+	{0x40, 0x0255}, /* index:215, gain:20.15625db -> x25.692422, DCG:on */
+	{0x40, 0x025c}, /* index:216, gain:20.25000db -> x25.971235, DCG:on */
+	{0x40, 0x0262}, /* index:217, gain:20.34375db -> x26.253066, DCG:on */
+	{0x40, 0x0269}, /* index:218, gain:20.43750db -> x26.537963, DCG:on */
+	{0x40, 0x0270}, /* index:219, gain:20.53125db -> x26.825943, DCG:on */
+	{0x40, 0x0277}, /* index:220, gain:20.62500db -> x27.117057, DCG:on */
+	{0x40, 0x027d}, /* index:221, gain:20.71875db -> x27.411330, DCG:on */
+	{0x40, 0x0284}, /* index:222, gain:20.81250db -> x27.708788, DCG:on */
+	{0x40, 0x028b}, /* index:223, gain:20.90625db -> x28.009482, DCG:on */
+	{0x40, 0x0292}, /* index:224, gain:21.00000db -> x28.313431, DCG:on */
+	{0x40, 0x029a}, /* index:225, gain:21.09375db -> x28.620687, DCG:on */
+	{0x40, 0x02a1}, /* index:226, gain:21.18750db -> x28.931277, DCG:on */
+	{0x40, 0x02a8}, /* index:227, gain:21.28125db -> x29.245229, DCG:on */
+	{0x40, 0x02b0}, /* index:228, gain:21.37500db -> x29.562597, DCG:on */
+	{0x40, 0x02b7}, /* index:229, gain:21.46875db -> x29.883400, DCG:on */
+	{0x40, 0x02bf}, /* index:230, gain:21.56250db -> x30.207693, DCG:on */
+	{0x40, 0x02c6}, /* index:231, gain:21.65625db -> x30.535505, DCG:on */
+	{0x40, 0x02ce}, /* index:232, gain:21.75000db -> x30.866865, DCG:on */
+	{0x40, 0x02d6}, /* index:233, gain:21.84375db -> x31.201831, DCG:on */
+	{0x40, 0x02de}, /* index:234, gain:21.93750db -> x31.540422, DCG:on */
+	{0x40, 0x02e5}, /* index:235, gain:22.03125db -> x31.882697, DCG:on */
+	{0x40, 0x02ee}, /* index:236, gain:22.12500db -> x32.228686, DCG:on */
+	{0x40, 0x02f6}, /* index:237, gain:22.21875db -> x32.578421, DCG:on */
+	{0x40, 0x02fe}, /* index:238, gain:22.31250db -> x32.931960, DCG:on */
+	{0x40, 0x0306}, /* index:239, gain:22.40625db -> x33.289326, DCG:on */
+	{0x40, 0x030f}, /* index:240, gain:22.50000db -> x33.650580, DCG:on */
+	{0x40, 0x0317}, /* index:241, gain:22.59375db -> x34.015754, DCG:on */
+	{0x40, 0x0320}, /* index:242, gain:22.68750db -> x34.384881, DCG:on */
+	{0x40, 0x0328}, /* index:243, gain:22.78125db -> x34.758024, DCG:on */
+	{0x40, 0x0331}, /* index:244, gain:22.87500db -> x35.135206, DCG:on */
+	{0x40, 0x033a}, /* index:245, gain:22.96875db -> x35.516491, DCG:on */
+	{0x40, 0x0343}, /* index:246, gain:23.06250db -> x35.901914, DCG:on */
+	{0x40, 0x034c}, /* index:247, gain:23.15625db -> x36.291509, DCG:on */
+	{0x40, 0x0355}, /* index:248, gain:23.25000db -> x36.685342, DCG:on */
+	{0x40, 0x035f}, /* index:249, gain:23.34375db -> x37.083439, DCG:on */
+	{0x40, 0x0368}, /* index:250, gain:23.43750db -> x37.485866, DCG:on */
+	{0x40, 0x0371}, /* index:251, gain:23.53125db -> x37.892661, DCG:on */
+	{0x40, 0x037b}, /* index:252, gain:23.62500db -> x38.303859, DCG:on */
+	{0x40, 0x0385}, /* index:253, gain:23.71875db -> x38.719530, DCG:on */
+	{0x40, 0x038e}, /* index:254, gain:23.81250db -> x39.139701, DCG:on */
+	{0x40, 0x0398}, /* index:255, gain:23.90625db -> x39.564443, DCG:on */
+	{0x40, 0x03a2}, /* index:256, gain:24.00000db -> x39.993794, DCG:on */
+	{0x40, 0x03ac}, /* index:257, gain:24.09375db -> x40.427793, DCG:on */
+	{0x40, 0x03b7}, /* index:258, gain:24.18750db -> x40.866512, DCG:on */
+	{0x40, 0x03c1}, /* index:259, gain:24.28125db -> x41.309982, DCG:on */
+	{0x40, 0x03cb}, /* index:260, gain:24.37500db -> x41.758275, DCG:on */
+	{0x40, 0x03d6}, /* index:261, gain:24.46875db -> x42.211433, DCG:on */
+	{0x40, 0x03e1}, /* index:262, gain:24.56250db -> x42.669498, DCG:on */
+	{0x40, 0x03eb}, /* index:263, gain:24.65625db -> x43.132544, DCG:on */
+	{0x40, 0x03f6}, /* index:264, gain:24.75000db -> x43.600604, DCG:on */
+	{0x41, 0x0200}, /* index:265, gain:24.84375db -> x44.073755, DCG:on */
+	{0x41, 0x0206}, /* index:266, gain:24.93750db -> x44.552041, DCG:on */
+	{0x41, 0x020c}, /* index:267, gain:25.03125db -> x45.035504, DCG:on */
+	{0x41, 0x0211}, /* index:268, gain:25.12500db -> x45.524227, DCG:on */
+	{0x41, 0x0217}, /* index:269, gain:25.21875db -> x46.018240, DCG:on */
+	{0x41, 0x021d}, /* index:270, gain:25.31250db -> x46.517627, DCG:on */
+	{0x41, 0x0223}, /* index:271, gain:25.40625db -> x47.022433, DCG:on */
+	{0x41, 0x0229}, /* index:272, gain:25.50000db -> x47.532705, DCG:on */
+	{0x41, 0x022f}, /* index:273, gain:25.59375db -> x48.048527, DCG:on */
+	{0x41, 0x0235}, /* index:274, gain:25.68750db -> x48.569933, DCG:on */
+	{0x41, 0x023b}, /* index:275, gain:25.78125db -> x49.097011, DCG:on */
+	{0x41, 0x0241}, /* index:276, gain:25.87500db -> x49.629809, DCG:on */
+	{0x41, 0x0247}, /* index:277, gain:25.96875db -> x50.168374, DCG:on */
+	{0x41, 0x024e}, /* index:278, gain:26.06250db -> x50.712798, DCG:on */
+	{0x41, 0x0254}, /* index:279, gain:26.15625db -> x51.263116, DCG:on */
+	{0x41, 0x025a}, /* index:280, gain:26.25000db -> x51.819421, DCG:on */
+	{0x41, 0x0261}, /* index:281, gain:26.34375db -> x52.381762, DCG:on */
+	{0x41, 0x0268}, /* index:282, gain:26.43750db -> x52.950191, DCG:on */
+	{0x41, 0x026e}, /* index:283, gain:26.53125db -> x53.524803, DCG:on */
+	{0x41, 0x0275}, /* index:284, gain:26.62500db -> x54.105636, DCG:on */
+	{0x41, 0x027c}, /* index:285, gain:26.71875db -> x54.692787, DCG:on */
+	{0x41, 0x0283}, /* index:286, gain:26.81250db -> x55.286309, DCG:on */
+	{0x41, 0x028a}, /* index:287, gain:26.90625db -> x55.886258, DCG:on */
+	{0x41, 0x0291}, /* index:288, gain:27.00000db -> x56.492732, DCG:on */
+	{0x41, 0x0298}, /* index:289, gain:27.09375db -> x57.105772, DCG:on */
+	{0x41, 0x029f}, /* index:290, gain:27.18750db -> x57.725480, DCG:on */
+	{0x41, 0x02a7}, /* index:291, gain:27.28125db -> x58.351913, DCG:on */
+	{0x41, 0x02ae}, /* index:292, gain:27.37500db -> x58.985128, DCG:on */
+	{0x41, 0x02b5}, /* index:293, gain:27.46875db -> x59.625231, DCG:on */
+	{0x41, 0x02bd}, /* index:294, gain:27.56250db -> x60.272264, DCG:on */
+	{0x41, 0x02c4}, /* index:295, gain:27.65625db -> x60.926335, DCG:on */
+	{0x41, 0x02cc}, /* index:296, gain:27.75000db -> x61.587504, DCG:on */
+	{0x41, 0x02d4}, /* index:297, gain:27.84375db -> x62.255830, DCG:on */
+	{0x41, 0x02dc}, /* index:298, gain:27.93750db -> x62.931427, DCG:on */
+	{0x41, 0x02e4}, /* index:299, gain:28.03125db -> x63.614337, DCG:on */
+	{0x41, 0x02ec}, /* index:300, gain:28.12500db -> x64.304676, DCG:on */
+	{0x41, 0x02f4}, /* index:301, gain:28.21875db -> x65.002506, DCG:on */
+	{0x41, 0x02fc}, /* index:302, gain:28.31250db -> x65.707891, DCG:on */
+	{0x41, 0x0304}, /* index:303, gain:28.40625db -> x66.420949, DCG:on */
+	{0x41, 0x030d}, /* index:304, gain:28.50000db -> x67.141727, DCG:on */
+	{0x41, 0x0315}, /* index:305, gain:28.59375db -> x67.870344, DCG:on */
+	{0x41, 0x031e}, /* index:306, gain:28.68750db -> x68.606869, DCG:on */
+	{0x41, 0x0326}, /* index:307, gain:28.78125db -> x69.351367, DCG:on */
+	{0x41, 0x032f}, /* index:308, gain:28.87500db -> x70.103964, DCG:on */
+	{0x41, 0x0338}, /* index:309, gain:28.96875db -> x70.864708, DCG:on */
+	{0x41, 0x0341}, /* index:310, gain:29.06250db -> x71.633728, DCG:on */
+	{0x41, 0x034a}, /* index:311, gain:29.15625db -> x72.411093, DCG:on */
+	{0x41, 0x0353}, /* index:312, gain:29.25000db -> x73.196873, DCG:on */
+	{0x41, 0x035c}, /* index:313, gain:29.34375db -> x73.991201, DCG:on */
+	{0x41, 0x0366}, /* index:314, gain:29.43750db -> x74.794128, DCG:on */
+	{0x41, 0x036f}, /* index:315, gain:29.53125db -> x75.605789, DCG:on */
+	{0x41, 0x0379}, /* index:316, gain:29.62500db -> x76.426259, DCG:on */
+	{0x41, 0x0382}, /* index:317, gain:29.71875db -> x77.255611, DCG:on */
+	{0x41, 0x038c}, /* index:318, gain:29.81250db -> x78.093984, DCG:on */
+	{0x41, 0x0396}, /* index:319, gain:29.90625db -> x78.941433, DCG:on */
+	{0x41, 0x03a0}, /* index:320, gain:30.00000db -> x79.798100, DCG:on */
+	{0x41, 0x03aa}, /* index:321, gain:30.09375db -> x80.664064, DCG:on */
+	{0x41, 0x03b4}, /* index:322, gain:30.18750db -> x81.539403, DCG:on */
+	{0x41, 0x03bf}, /* index:323, gain:30.28125db -> x82.424264, DCG:on */
+	{0x41, 0x03c9}, /* index:324, gain:30.37500db -> x83.318704, DCG:on */
+	{0x41, 0x03d4}, /* index:325, gain:30.46875db -> x84.222873, DCG:on */
+	{0x41, 0x03de}, /* index:326, gain:30.56250db -> x85.136854, DCG:on */
+	{0x41, 0x03e9}, /* index:327, gain:30.65625db -> x86.060731, DCG:on */
+	{0x41, 0x03f4}, /* index:328, gain:30.75000db -> x86.994656, DCG:on */
+	{0x41, 0x03ff}, /* index:329, gain:30.84375db -> x87.938693, DCG:on */
+	{0x42, 0x0205}, /* index:330, gain:30.93750db -> x88.892998, DCG:on */
+	{0x42, 0x020a}, /* index:331, gain:31.03125db -> x89.857659, DCG:on */
+	{0x42, 0x0210}, /* index:332, gain:31.12500db -> x90.832764, DCG:on */
+	{0x42, 0x0216}, /* index:333, gain:31.21875db -> x91.818475, DCG:on */
+	{0x42, 0x021c}, /* index:334, gain:31.31250db -> x92.814858, DCG:on */
+	{0x42, 0x0221}, /* index:335, gain:31.40625db -> x93.822079, DCG:on */
+	{0x42, 0x0227}, /* index:336, gain:31.50000db -> x94.840230, DCG:on */
+	{0x42, 0x022d}, /* index:337, gain:31.59375db -> x95.869404, DCG:on */
+	{0x42, 0x0233}, /* index:338, gain:31.68750db -> x96.909773, DCG:on */
+	{0x42, 0x0239}, /* index:339, gain:31.78125db -> x97.961405, DCG:on */
+	{0x42, 0x0240}, /* index:340, gain:31.87500db -> x99.024476, DCG:on */
+	{0x42, 0x0246}, /* index:341, gain:31.96875db -> x100.099083, DCG:on */
+	{0x42, 0x024c}, /* index:342, gain:32.06250db -> x101.185325, DCG:on */
+	{0x42, 0x0253}, /* index:343, gain:32.15625db -> x102.283381, DCG:on */
+	{0x42, 0x0259}, /* index:344, gain:32.25000db -> x103.393326, DCG:on */
+	{0x42, 0x0260}, /* index:345, gain:32.34375db -> x104.515344, DCG:on */
+	{0x42, 0x0266}, /* index:346, gain:32.43750db -> x105.649538, DCG:on */
+	{0x42, 0x026d}, /* index:347, gain:32.53125db -> x106.796010, DCG:on */
+	{0x42, 0x0274}, /* index:348, gain:32.62500db -> x107.954954, DCG:on */
+	{0x42, 0x027a}, /* index:349, gain:32.71875db -> x109.126444, DCG:on */
+	{0x42, 0x0281}, /* index:350, gain:32.81250db -> x110.310678, DCG:on */
+	{0x42, 0x0288}, /* index:351, gain:32.90625db -> x111.507762, DCG:on */
+	{0x42, 0x028f}, /* index:352, gain:33.00000db -> x112.717807, DCG:on */
+	{0x42, 0x0296}, /* index:353, gain:33.09375db -> x113.941013, DCG:on */
+	{0x42, 0x029e}, /* index:354, gain:33.18750db -> x115.177462, DCG:on */
+	{0x42, 0x02a5}, /* index:355, gain:33.28125db -> x116.427361, DCG:on */
+	{0x42, 0x02ac}, /* index:356, gain:33.37500db -> x117.690823, DCG:on */
+	{0x42, 0x02b4}, /* index:357, gain:33.46875db -> x118.967964, DCG:on */
+	{0x42, 0x02bb}, /* index:358, gain:33.56250db -> x120.258997, DCG:on */
+	{0x42, 0x02c3}, /* index:359, gain:33.65625db -> x121.564006, DCG:on */
+	{0x42, 0x02ca}, /* index:360, gain:33.75000db -> x122.883211, DCG:on */
+	{0x42, 0x02d2}, /* index:361, gain:33.84375db -> x124.216732, DCG:on */
+	{0x42, 0x02da}, /* index:362, gain:33.93750db -> x125.564690, DCG:on */
+	{0x42, 0x02e2}, /* index:363, gain:34.03125db -> x126.927310, DCG:on */
+	{0x42, 0x02ea}, /* index:364, gain:34.12500db -> x128.304682, DCG:on */
+	{0x42, 0x02f2}, /* index:365, gain:34.21875db -> x129.697036, DCG:on */
+	{0x42, 0x02fa}, /* index:366, gain:34.31250db -> x131.104501, DCG:on */
+	{0x42, 0x0303}, /* index:367, gain:34.40625db -> x132.527202, DCG:on */
+	{0x42, 0x030b}, /* index:368, gain:34.50000db -> x133.965379, DCG:on */
+	{0x42, 0x0313}, /* index:369, gain:34.59375db -> x135.419126, DCG:on */
+	{0x42, 0x031c}, /* index:370, gain:34.68750db -> x136.888685, DCG:on */
+	{0x42, 0x0325}, /* index:371, gain:34.78125db -> x138.374193, DCG:on */
+	{0x42, 0x032d}, /* index:372, gain:34.87500db -> x139.875782, DCG:on */
+	{0x42, 0x0336}, /* index:373, gain:34.96875db -> x141.393706, DCG:on */
+	{0x42, 0x033f}, /* index:374, gain:35.06250db -> x142.928062, DCG:on */
+	{0x42, 0x0348}, /* index:375, gain:35.15625db -> x144.479108, DCG:on */
+	{0x42, 0x0351}, /* index:376, gain:35.25000db -> x146.046987, DCG:on */
+	{0x42, 0x035a}, /* index:377, gain:35.34375db -> x147.631839, DCG:on */
+	{0x42, 0x0364}, /* index:378, gain:35.43750db -> x149.233930, DCG:on */
+	{0x42, 0x036d}, /* index:379, gain:35.53125db -> x150.853366, DCG:on */
+	{0x42, 0x0377}, /* index:380, gain:35.62500db -> x152.490417, DCG:on */
+	{0x42, 0x0380}, /* index:381, gain:35.71875db -> x154.145234, DCG:on */
+	{0x42, 0x038a}, /* index:382, gain:35.81250db -> x155.817965, DCG:on */
+	{0x42, 0x0394}, /* index:383, gain:35.90625db -> x157.508892, DCG:on */
+	{0x42, 0x039e}, /* index:384, gain:36.00000db -> x159.218125, DCG:on */
+	{0x42, 0x03a8}, /* index:385, gain:36.09375db -> x160.945950, DCG:on */
+	{0x42, 0x03b2}, /* index:386, gain:36.18750db -> x162.692525, DCG:on */
+	{0x42, 0x03bc}, /* index:387, gain:36.28125db -> x164.458009, DCG:on */
+	{0x42, 0x03c7}, /* index:388, gain:36.37500db -> x166.242697, DCG:on */
+	{0x42, 0x03d1}, /* index:389, gain:36.46875db -> x168.046706, DCG:on */
+	{0x42, 0x03dc}, /* index:390, gain:36.56250db -> x169.870339, DCG:on */
+	{0x42, 0x03e7}, /* index:391, gain:36.65625db -> x171.713761, DCG:on */
+	{0x42, 0x03f1}, /* index:392, gain:36.75000db -> x173.577140, DCG:on */
+	{0x42, 0x03fc}, /* index:393, gain:36.84375db -> x175.460788, DCG:on */
+	{0x43, 0x0203}, /* index:394, gain:36.93750db -> x177.364829, DCG:on */
+	{0x43, 0x0209}, /* index:395, gain:37.03125db -> x179.289581, DCG:on */
+	{0x43, 0x020f}, /* index:396, gain:37.12500db -> x181.235220, DCG:on */
+	{0x43, 0x0214}, /* index:397, gain:37.21875db -> x183.201923, DCG:on */
+	{0x43, 0x021a}, /* index:398, gain:37.31250db -> x185.190019, DCG:on */
+	{0x43, 0x0220}, /* index:399, gain:37.40625db -> x187.199638, DCG:on */
+	{0x43, 0x0226}, /* index:400, gain:37.50000db -> x189.231117, DCG:on */
+	{0x43, 0x022c}, /* index:401, gain:37.59375db -> x191.284641, DCG:on */
+	{0x43, 0x0232}, /* index:402, gain:37.68750db -> x193.360397, DCG:on */
+	{0x43, 0x0238}, /* index:403, gain:37.78125db -> x195.458732, DCG:on */
+	{0x43, 0x023e}, /* index:404, gain:37.87500db -> x197.579783, DCG:on */
+	{0x43, 0x0245}, /* index:405, gain:37.96875db -> x199.723907, DCG:on */
+	{0x43, 0x024b}, /* index:406, gain:38.06250db -> x201.891298, DCG:on */
+	{0x43, 0x0251}, /* index:407, gain:38.15625db -> x204.082154, DCG:on */
+	{0x43, 0x0258}, /* index:408, gain:38.25000db -> x206.296840, DCG:on */
+	{0x43, 0x025e}, /* index:409, gain:38.34375db -> x208.535504, DCG:on */
+	{0x43, 0x0265}, /* index:410, gain:38.43750db -> x210.798518, DCG:on */
+	{0x43, 0x026b}, /* index:411, gain:38.53125db -> x213.086090, DCG:on */
+	{0x43, 0x0272}, /* index:412, gain:38.62500db -> x215.398428, DCG:on */
+	{0x43, 0x0279}, /* index:413, gain:38.71875db -> x217.735918, DCG:on */
+	{0x43, 0x0280}, /* index:414, gain:38.81250db -> x220.098714, DCG:on */
+	{0x43, 0x0287}, /* index:415, gain:38.90625db -> x222.487211, DCG:on */
+	{0x43, 0x028e}, /* index:416, gain:39.00000db -> x224.901629, DCG:on */
+	{0x43, 0x0295}, /* index:417, gain:39.09375db -> x227.342185, DCG:on */
+	{0x43, 0x029c}, /* index:418, gain:39.18750db -> x229.809288, DCG:on */
+	{0x43, 0x02a3}, /* index:419, gain:39.28125db -> x232.303100, DCG:on */
+	{0x43, 0x02ab}, /* index:420, gain:39.37500db -> x234.824038, DCG:on */
+	{0x43, 0x02b2}, /* index:421, gain:39.46875db -> x237.372334, DCG:on */
+	{0x43, 0x02ba}, /* index:422, gain:39.56250db -> x239.948218, DCG:on */
+	{0x43, 0x02c1}, /* index:423, gain:39.65625db -> x242.552121, DCG:on */
+	{0x43, 0x02c9}, /* index:424, gain:39.75000db -> x245.184214, DCG:on */
+	{0x43, 0x02d1}, /* index:425, gain:39.84375db -> x247.844938, DCG:on */
+	{0x43, 0x02d8}, /* index:426, gain:39.93750db -> x250.534535, DCG:on */
+	{0x43, 0x02e0}, /* index:427, gain:40.03125db -> x253.253320, DCG:on */
+	{0x43, 0x02e8}, /* index:428, gain:40.12500db -> x256.001469, DCG:on */
+	{0x43, 0x02f0}, /* index:429, gain:40.21875db -> x258.779581, DCG:on */
+	{0x43, 0x02f8}, /* index:430, gain:40.31250db -> x261.587841, DCG:on */
+	{0x43, 0x0301}, /* index:431, gain:40.40625db -> x264.426575, DCG:on */
+	{0x43, 0x0309}, /* index:432, gain:40.50000db -> x267.296116, DCG:on */
+	{0x43, 0x0312}, /* index:433, gain:40.59375db -> x270.196648, DCG:on */
+	{0x43, 0x031a}, /* index:434, gain:40.68750db -> x273.128805, DCG:on */
+	{0x43, 0x0323}, /* index:435, gain:40.78125db -> x276.092782, DCG:on */
+	{0x43, 0x032b}, /* index:436, gain:40.87500db -> x279.088923, DCG:on */
+	{0x43, 0x0334}, /* index:437, gain:40.96875db -> x282.117579, DCG:on */
+	{0x43, 0x033d}, /* index:438, gain:41.06250db -> x285.178945, DCG:on */
+	{0x43, 0x0346}, /* index:439, gain:41.15625db -> x288.273689, DCG:on */
+	{0x43, 0x034f}, /* index:440, gain:41.25000db -> x291.402016, DCG:on */
+	{0x43, 0x0358}, /* index:441, gain:41.34375db -> x294.564293, DCG:on */
+	{0x43, 0x0362}, /* index:442, gain:41.43750db -> x297.760886, DCG:on */
+	{0x43, 0x036b}, /* index:443, gain:41.53125db -> x300.992003, DCG:on */
+	{0x43, 0x0375}, /* index:444, gain:41.62500db -> x304.258349, DCG:on */
+	{0x43, 0x037e}, /* index:445, gain:41.71875db -> x307.560142, DCG:on */
+	{0x43, 0x0388}, /* index:446, gain:41.81250db -> x310.897765, DCG:on */
+	{0x43, 0x0392}, /* index:447, gain:41.90625db -> x314.271608, DCG:on */
+	{0x43, 0x039c}, /* index:448, gain:42.00000db -> x317.681890, DCG:on */
+	{0x43, 0x03a6}, /* index:449, gain:42.09375db -> x321.129354, DCG:on */
+	{0x43, 0x03b0}, /* index:450, gain:42.18750db -> x324.614229, DCG:on */
+	{0x43, 0x03ba}, /* index:451, gain:42.28125db -> x328.136922, DCG:on */
+	{0x43, 0x03c4}, /* index:452, gain:42.37500db -> x331.697844, DCG:on */
+	{0x43, 0x03cf}, /* index:453, gain:42.46875db -> x335.297224, DCG:on */
+	{0x43, 0x03d9}, /* index:454, gain:42.56250db -> x338.935848, DCG:on */
+	{0x43, 0x03e4}, /* index:455, gain:42.65625db -> x342.613959, DCG:on */
+	{0x43, 0x03ef}, /* index:456, gain:42.75000db -> x346.331984, DCG:on */
+	{0x43, 0x03fa}, /* index:457, gain:42.84375db -> x350.090357, DCG:on */
+	{0x43, 0x0405}, /* index:458, gain:42.93750db -> x353.889321, DCG:on */
+	{0x43, 0x0410}, /* index:459, gain:43.03125db -> x357.729705, DCG:on */
+	{0x43, 0x041b}, /* index:460, gain:43.12500db -> x361.611766, DCG:on */
+	{0x43, 0x0427}, /* index:461, gain:43.21875db -> x365.535954, DCG:on */
+	{0x43, 0x0432}, /* index:462, gain:43.31250db -> x369.502727, DCG:on */
+	{0x43, 0x043e}, /* index:463, gain:43.40625db -> x373.512342, DCG:on */
+	{0x43, 0x044a}, /* index:464, gain:43.50000db -> x377.565675, DCG:on */
+	{0x43, 0x0456}, /* index:465, gain:43.59375db -> x381.662994, DCG:on */
+	{0x43, 0x0462}, /* index:466, gain:43.68750db -> x385.804777, DCG:on */
+	{0x43, 0x046e}, /* index:467, gain:43.78125db -> x389.991506, DCG:on */
+	{0x43, 0x047a}, /* index:468, gain:43.87500db -> x394.223453, DCG:on */
+	{0x43, 0x0487}, /* index:469, gain:43.96875db -> x398.501541, DCG:on */
+	{0x43, 0x0493}, /* index:470, gain:44.06250db -> x402.826055, DCG:on */
+	{0x43, 0x04a0}, /* index:471, gain:44.15625db -> x407.197498, DCG:on */
+	{0x43, 0x04ad}, /* index:472, gain:44.25000db -> x411.616379, DCG:on */
+	{0x43, 0x04ba}, /* index:473, gain:44.34375db -> x416.082986, DCG:on */
+	{0x43, 0x04c7}, /* index:474, gain:44.43750db -> x420.598292, DCG:on */
+	{0x43, 0x04d4}, /* index:475, gain:44.53125db -> x425.162598, DCG:on */
+	{0x43, 0x04e2}, /* index:476, gain:44.62500db -> x429.776436, DCG:on */
+	{0x43, 0x04ef}, /* index:477, gain:44.71875db -> x434.440343, DCG:on */
+	{0x43, 0x04fd}, /* index:478, gain:44.81250db -> x439.154621, DCG:on */
+	{0x43, 0x050b}, /* index:479, gain:44.90625db -> x443.920300, DCG:on */
+	{0x43, 0x0519}, /* index:480, gain:45.00000db -> x448.737695, DCG:on */
+	{0x43, 0x0527}, /* index:481, gain:45.09375db -> x453.607368, DCG:on */
+	{0x43, 0x0535}, /* index:482, gain:45.18750db -> x458.529887, DCG:on */
+	{0x43, 0x0544}, /* index:483, gain:45.28125db -> x463.505570, DCG:on */
+	{0x43, 0x0553}, /* index:484, gain:45.37500db -> x468.535503, DCG:on */
+	{0x43, 0x0561}, /* index:485, gain:45.46875db -> x473.620021, DCG:on */
+	{0x43, 0x0570}, /* index:486, gain:45.56250db -> x478.759716, DCG:on */
+	{0x43, 0x057f}, /* index:487, gain:45.65625db -> x483.955186, DCG:on */
+	{0x43, 0x058f}, /* index:488, gain:45.75000db -> x489.206769, DCG:on */
+	{0x43, 0x059e}, /* index:489, gain:45.84375db -> x494.515610, DCG:on */
+	{0x43, 0x05ae}, /* index:490, gain:45.93750db -> x499.882062, DCG:on */
+	{0x43, 0x05bd}, /* index:491, gain:46.03125db -> x505.306751, DCG:on */
+	{0x43, 0x05cd}, /* index:492, gain:46.12500db -> x510.790308, DCG:on */
+	{0x43, 0x05de}, /* index:493, gain:46.21875db -> x516.333089, DCG:on */
+	{0x43, 0x05ee}, /* index:494, gain:46.31250db -> x521.936303, DCG:on */
+	{0x43, 0x05fe}, /* index:495, gain:46.40625db -> x527.600323, DCG:on */
+	{0x43, 0x060f}, /* index:496, gain:46.50000db -> x533.325808, DCG:on */
+	{0x43, 0x0620}, /* index:497, gain:46.59375db -> x539.113427, DCG:on */
+	{0x43, 0x0631}, /* index:498, gain:46.68750db -> x544.963552, DCG:on */
+	{0x43, 0x0642}, /* index:499, gain:46.78125db -> x550.877463, DCG:on */
+	{0x43, 0x0653}, /* index:500, gain:46.87500db -> x556.855550, DCG:on */
+	{0x43, 0x0665}, /* index:501, gain:46.96875db -> x562.898512, DCG:on */
+	{0x43, 0x0677}, /* index:502, gain:47.06250db -> x569.007051, DCG:on */
+	{0x43, 0x0689}, /* index:503, gain:47.15625db -> x575.181564, DCG:on */
+	{0x43, 0x069b}, /* index:504, gain:47.25000db -> x581.423398, DCG:on */
+	{0x43, 0x06ad}, /* index:505, gain:47.34375db -> x587.732968, DCG:on */
+	{0x43, 0x06c0}, /* index:506, gain:47.43750db -> x594.111009, DCG:on */
+	{0x43, 0x06d3}, /* index:507, gain:47.53125db -> x600.558265, DCG:on */
+	{0x43, 0x06e6}, /* index:508, gain:47.62500db -> x607.075152, DCG:on */
+	{0x43, 0x06f9}, /* index:509, gain:47.71875db -> x613.663093, DCG:on */
+	{0x43, 0x070c}, /* index:510, gain:47.81250db -> x620.322527, DCG:on */
+	{0x43, 0x0720}, /* index:511, gain:47.90625db -> x627.054228, DCG:on */
+	{0x43, 0x0733}, /* index:512, gain:48.00000db -> x633.858981, DCG:on */
+	{0x43, 0x0747}, /* index:513, gain:48.09375db -> x640.737227, DCG:on */
+	{0x43, 0x075c}, /* index:514, gain:48.18750db -> x647.690467, DCG:on */
+	{0x43, 0x0770}, /* index:515, gain:48.28125db -> x654.719163, DCG:on */
+	{0x43, 0x0785}, /* index:516, gain:48.37500db -> x661.824134, DCG:on */
+	{0x43, 0x079a}, /* index:517, gain:48.46875db -> x669.006208, DCG:on */
+	{0x43, 0x07af}, /* index:518, gain:48.56250db -> x676.265850, DCG:on */
+	{0x43, 0x07c4}, /* index:519, gain:48.65625db -> x683.604645, DCG:on */
+	{0x43, 0x07da}, /* index:520, gain:48.75000db -> x691.023080, DCG:on */
+	{0x43, 0x07f0}, /* index:521, gain:48.84375db -> x698.522019, DCG:on */
+	{0x43, 0x0806}, /* index:522, gain:48.93750db -> x706.102336, DCG:on */
+	{0x43, 0x081c}, /* index:523, gain:49.03125db -> x713.764522, DCG:on */
+	{0x43, 0x0832}, /* index:524, gain:49.12500db -> x721.510250, DCG:on */
+	{0x43, 0x0849}, /* index:525, gain:49.21875db -> x729.340034, DCG:on */
+	{0x43, 0x0860}, /* index:526, gain:49.31250db -> x737.254786, DCG:on */
+	{0x43, 0x0878}, /* index:527, gain:49.40625db -> x745.255428, DCG:on */
+	{0x43, 0x088f}, /* index:528, gain:49.50000db -> x753.342480, DCG:on */
+	{0x43, 0x08a7}, /* index:529, gain:49.59375db -> x761.517705, DCG:on */
+	{0x43, 0x08bf}, /* index:530, gain:49.68750db -> x769.781647, DCG:on */
+	{0x43, 0x08d7}, /* index:531, gain:49.78125db -> x778.135269, DCG:on */
+	{0x43, 0x08f0}, /* index:532, gain:49.87500db -> x786.579544, DCG:on */
+	{0x43, 0x0909}, /* index:533, gain:49.96875db -> x795.115020, DCG:on */
+	{0x43, 0x0922}, /* index:534, gain:50.06250db -> x803.743558, DCG:on */
+	{0x43, 0x093b}, /* index:535, gain:50.15625db -> x812.465732, DCG:on */
+	{0x43, 0x0955}, /* index:536, gain:50.25000db -> x821.282559, DCG:on */
+	{0x43, 0x096f}, /* index:537, gain:50.34375db -> x830.195066, DCG:on */
+	{0x43, 0x0989}, /* index:538, gain:50.43750db -> x839.203830, DCG:on */
+	{0x43, 0x09a3}, /* index:539, gain:50.53125db -> x848.310817, DCG:on */
+	{0x43, 0x09be}, /* index:540, gain:50.62500db -> x857.516633, DCG:on */
+	{0x43, 0x09d9}, /* index:541, gain:50.71875db -> x866.822350, DCG:on */
+	{0x43, 0x09f5}, /* index:542, gain:50.81250db -> x876.229051, DCG:on */
+	{0x43, 0x0a10}, /* index:543, gain:50.90625db -> x885.737348, DCG:on */
+	{0x43, 0x0a2c}, /* index:544, gain:51.00000db -> x895.349314, DCG:on */
+	{0x43, 0x0a48}, /* index:545, gain:51.09375db -> x905.065588, DCG:on */
+	{0x43, 0x0a65}, /* index:546, gain:51.18750db -> x914.887303, DCG:on */
+	{0x43, 0x0a82}, /* index:547, gain:51.28125db -> x924.815602, DCG:on */
+	{0x43, 0x0a9f}, /* index:548, gain:51.37500db -> x934.851130, DCG:on */
+	{0x43, 0x0abd}, /* index:549, gain:51.46875db -> x944.996076, DCG:on */
+	{0x43, 0x0ada}, /* index:550, gain:51.56250db -> x955.251114, DCG:on */
+	{0x43, 0x0af9}, /* index:551, gain:51.65625db -> x965.617439, DCG:on */
+	{0x43, 0x0b17}, /* index:552, gain:51.75000db -> x976.096258, DCG:on */
+	{0x43, 0x0b36}, /* index:553, gain:51.84375db -> x986.688252, DCG:on */
+	{0x43, 0x0b55}, /* index:554, gain:51.93750db -> x997.395731, DCG:on */
+	{0x43, 0x0b75}, /* index:555, gain:52.03125db -> x1008.219407, DCG:on */
+	{0x43, 0x0b94}, /* index:556, gain:52.12500db -> x1019.160540, DCG:on */
+	{0x43, 0x0bb5}, /* index:557, gain:52.21875db -> x1030.220406, DCG:on */
+	{0x43, 0x0bd5}, /* index:558, gain:52.31250db -> x1041.399722, DCG:on */
+	{0x43, 0x0bf6}, /* index:559, gain:52.40625db -> x1052.700926, DCG:on */
+	{0x43, 0x0c17}, /* index:560, gain:52.50000db -> x1064.124770, DCG:on */
+	{0x43, 0x0c39}, /* index:561, gain:52.59375db -> x1075.672585, DCG:on */
+	{0x43, 0x0c5b}, /* index:562, gain:52.68750db -> x1087.345717, DCG:on */
+	{0x43, 0x0c7d}, /* index:563, gain:52.78125db -> x1099.144921, DCG:on */
+	{0x43, 0x0ca0}, /* index:564, gain:52.87500db -> x1111.072772, DCG:on */
+	{0x43, 0x0cc3}, /* index:565, gain:52.96875db -> x1123.130064, DCG:on */
+	{0x43, 0x0ce6}, /* index:566, gain:53.06250db -> x1135.318201, DCG:on */
+	{0x43, 0x0d0a}, /* index:567, gain:53.15625db -> x1147.638603, DCG:on */
+	{0x43, 0x0d2e}, /* index:568, gain:53.25000db -> x1160.092068, DCG:on */
+	{0x43, 0x0d53}, /* index:569, gain:53.34375db -> x1172.681314, DCG:on */
+	{0x43, 0x0d78}, /* index:570, gain:53.43750db -> x1185.407178, DCG:on */
+	{0x43, 0x0d9d}, /* index:571, gain:53.53125db -> x1198.271142, DCG:on */
+	{0x43, 0x0dc3}, /* index:572, gain:53.62500db -> x1211.274705, DCG:on */
+	{0x43, 0x0de9}, /* index:573, gain:53.71875db -> x1224.418710, DCG:on */
+	{0x43, 0x0e10}, /* index:574, gain:53.81250db -> x1237.706025, DCG:on */
+	{0x43, 0x0e37}, /* index:575, gain:53.90625db -> x1251.137533, DCG:on */
+	{0x43, 0x0e5f}, /* index:576, gain:54.00000db -> x1264.714799, DCG:on */
+	{0x43, 0x0e87}, /* index:577, gain:54.09375db -> x1278.439404, DCG:on */
+	{0x43, 0x0eaf}, /* index:578, gain:54.18750db -> x1292.312239, DCG:on */
+	{0x43, 0x0ed8}, /* index:579, gain:54.28125db -> x1306.336330, DCG:on */
+	{0x43, 0x0f01}, /* index:580, gain:54.37500db -> x1320.512610, DCG:on */
+	{0x43, 0x0f2b}, /* index:581, gain:54.46875db -> x1334.842730, DCG:on */
+	{0x43, 0x0f55}, /* index:582, gain:54.56250db -> x1349.328359, DCG:on */
+	{0x43, 0x0f7f}, /* index:583, gain:54.65625db -> x1363.970437, DCG:on */
+	{0x43, 0x0faa}, /* index:584, gain:54.75000db -> x1378.772158, DCG:on */
+	{0x43, 0x0fd6}, /* index:585, gain:54.84375db -> x1393.734507, DCG:on */
+	{0x43, 0x1002}, /* index:586, gain:54.93750db -> x1408.859226, DCG:on */
+	{0x43, 0x102e}, /* index:587, gain:55.03125db -> x1424.148078, DCG:on */
+	{0x43, 0x105b}, /* index:588, gain:55.12500db -> x1439.602053, DCG:on */
+	{0x43, 0x1089}, /* index:589, gain:55.21875db -> x1455.224524, DCG:on */
+	{0x43, 0x10b7}, /* index:590, gain:55.31250db -> x1471.016529, DCG:on */
+	{0x43, 0x10e5}, /* index:591, gain:55.40625db -> x1486.979908, DCG:on */
+	{0x43, 0x1114}, /* index:592, gain:55.50000db -> x1503.116520, DCG:on */
+	{0x43, 0x1144}, /* index:593, gain:55.59375db -> x1519.427412, DCG:on */
+	{0x43, 0x1174}, /* index:594, gain:55.68750db -> x1535.916143, DCG:on */
+	{0x43, 0x11a4}, /* index:595, gain:55.78125db -> x1552.583808, DCG:on */
+	{0x43, 0x11d5}, /* index:596, gain:55.87500db -> x1569.432350, DCG:on */
+	{0x43, 0x1207}, /* index:597, gain:55.96875db -> x1586.463732, DCG:on */
+	{0x43, 0x1239}, /* index:598, gain:56.06250db -> x1603.679056, DCG:on */
+	{0x43, 0x126b}, /* index:599, gain:56.15625db -> x1621.082080, DCG:on */
+	{0x43, 0x129f}, /* index:600, gain:56.25000db -> x1638.673961, DCG:on */
+	{0x43, 0x12d2}, /* index:601, gain:56.34375db -> x1656.456748, DCG:on */
+	{0x43, 0x1307}, /* index:602, gain:56.43750db -> x1674.432512, DCG:on */
+	{0x43, 0x133b}, /* index:603, gain:56.53125db -> x1692.602419, DCG:on */
+	{0x43, 0x1371}, /* index:604, gain:56.62500db -> x1710.970434, DCG:on */
+	{0x43, 0x13a7}, /* index:605, gain:56.71875db -> x1729.537778, DCG:on */
+	{0x43, 0x13dd}, /* index:606, gain:56.81250db -> x1748.306613, DCG:on */
+	{0x43, 0x1415}, /* index:607, gain:56.90625db -> x1767.279127, DCG:on */
+	{0x43, 0x144c}, /* index:608, gain:57.00000db -> x1786.456548, DCG:on */
+	{0x43, 0x1485}, /* index:609, gain:57.09375db -> x1805.843062, DCG:on */
+	{0x43, 0x14be}, /* index:610, gain:57.18750db -> x1825.439958, DCG:on */
+	{0x43, 0x14f7}, /* index:611, gain:57.28125db -> x1845.249517, DCG:on */
+	{0x43, 0x1532}, /* index:612, gain:57.37500db -> x1865.274049, DCG:on */
+	{0x43, 0x156d}, /* index:613, gain:57.46875db -> x1885.514851, DCG:on */
+	{0x43, 0x15a8}, /* index:614, gain:57.56250db -> x1905.976339, DCG:on */
+	{0x43, 0x15e4}, /* index:615, gain:57.65625db -> x1926.659875, DCG:on */
+	{0x43, 0x1621}, /* index:616, gain:57.75000db -> x1947.567866, DCG:on */
+	{0x43, 0x165f}, /* index:617, gain:57.84375db -> x1968.702750, DCG:on */
+	{0x43, 0x169d}, /* index:618, gain:57.93750db -> x1990.065896, DCG:on */
+	{0x43, 0x16dc}, /* index:619, gain:58.03125db -> x2011.661966, DCG:on */
+	{0x43, 0x171b}, /* index:620, gain:58.12500db -> x2033.492396, DCG:on */
+	{0x43, 0x175b}, /* index:621, gain:58.21875db -> x2055.559727, DCG:on */
+	{0x43, 0x179c}, /* index:622, gain:58.31250db -> x2077.866532, DCG:on */
+	{0x43, 0x17de}, /* index:623, gain:58.40625db -> x2100.414256, DCG:on */
+	{0x43, 0x1820}, /* index:624, gain:58.50000db -> x2123.207820, DCG:on */
+	{0x43, 0x1863}, /* index:625, gain:58.59375db -> x2146.248737, DCG:on */
+	{0x43, 0x18a7}, /* index:626, gain:58.68750db -> x2169.539694, DCG:on */
+	{0x43, 0x18eb}, /* index:627, gain:58.78125db -> x2193.083402, DCG:on */
+	{0x43, 0x1931}, /* index:628, gain:58.87500db -> x2216.881388, DCG:on */
+	{0x43, 0x1977}, /* index:629, gain:58.96875db -> x2240.938846, DCG:on */
+	{0x43, 0x19bd}, /* index:630, gain:59.06250db -> x2265.257373, DCG:on */
+	{0x43, 0x1a05}, /* index:631, gain:59.15625db -> x2289.839804, DCG:on */
+	{0x43, 0x1a4d}, /* index:632, gain:59.25000db -> x2314.689001, DCG:on */
+	{0x43, 0x1a96}, /* index:633, gain:59.34375db -> x2339.806577, DCG:on */
+	{0x43, 0x1ae0}, /* index:634, gain:59.43750db -> x2365.198010, DCG:on */
+	{0x43, 0x1b2b}, /* index:635, gain:59.53125db -> x2390.864991, DCG:on */
+	{0x43, 0x1b76}, /* index:636, gain:59.62500db -> x2416.810507, DCG:on */
+	{0x43, 0x1bc3}, /* index:637, gain:59.71875db -> x2443.037583, DCG:on */
+	{0x43, 0x1c10}, /* index:638, gain:59.81250db -> x2469.547917, DCG:on */
+	{0x43, 0x1c5e}, /* index:639, gain:59.90625db -> x2496.347296, DCG:on */
+	{0x43, 0x1cac}, /* index:640, gain:60.00000db -> x2523.437500, DCG:on */
+	{0x43, 0x1cfc}, /* index:641, gain:60.09375db -> x2550.821685, DCG:on */
+	{0x43, 0x1d4d}, /* index:642, gain:60.18750db -> x2578.503042, DCG:on */
+	{0x43, 0x1d9e}, /* index:643, gain:60.28125db -> x2606.483364, DCG:on */
+	{0x43, 0x1df0}, /* index:644, gain:60.37500db -> x2634.768757, DCG:on */
+	{0x43, 0x1e43}, /* index:645, gain:60.46875db -> x2663.361102, DCG:on */
+	{0x43, 0x1e98}, /* index:646, gain:60.56250db -> x2692.263729, DCG:on */
+	{0x43, 0x1eed}, /* index:647, gain:60.65625db -> x2721.480006, DCG:on */
+	{0x43, 0x1f42}, /* index:648, gain:60.75000db -> x2751.011826, DCG:on */
+	{0x43, 0x1f99}, /* index:649, gain:60.84375db -> x2780.865633, DCG:on */
+	{0x43, 0x1ff1}, /* index:650, gain:60.93750db -> x2811.043412, DCG:on */
+	{0x43, 0x204a}, /* index:651, gain:61.03125db -> x2841.548679, DCG:on */
+	{0x43, 0x20a4}, /* index:652, gain:61.12500db -> x2872.384986, DCG:on */
+	{0x43, 0x20fe}, /* index:653, gain:61.21875db -> x2903.554334, DCG:on */
+	{0x43, 0x215a}, /* index:654, gain:61.31250db -> x2935.063523, DCG:on */
+	{0x43, 0x21b7}, /* index:655, gain:61.40625db -> x2966.914648, DCG:on */
+	{0x43, 0x2214}, /* index:656, gain:61.50000db -> x2999.111419, DCG:on */
+	{0x43, 0x2273}, /* index:657, gain:61.59375db -> x3031.657587, DCG:on */
+	{0x43, 0x22d3}, /* index:658, gain:61.68750db -> x3064.555263, DCG:on */
+	{0x43, 0x2333}, /* index:659, gain:61.78125db -> x3097.811624, DCG:on */
+	{0x43, 0x2395}, /* index:660, gain:61.87500db -> x3131.428881, DCG:on */
+	{0x43, 0x23f8}, /* index:661, gain:61.96875db -> x3165.410950, DCG:on */
+	{0x43, 0x245c}, /* index:662, gain:62.06250db -> x3199.761791, DCG:on */
+	{0x43, 0x24c1}, /* index:663, gain:62.15625db -> x3234.483629, DCG:on */
+	{0x43, 0x2527}, /* index:664, gain:62.25000db -> x3269.584042, DCG:on */
+	{0x43, 0x258e}, /* index:665, gain:62.34375db -> x3305.065362, DCG:on */
+	{0x43, 0x25f7}, /* index:666, gain:62.43750db -> x3340.931724, DCG:on */
+	{0x43, 0x2660}, /* index:667, gain:62.53125db -> x3377.187305, DCG:on */
+	{0x43, 0x26cb}, /* index:668, gain:62.62500db -> x3413.834455, DCG:on */
+	{0x43, 0x2736}, /* index:669, gain:62.71875db -> x3450.881172, DCG:on */
+	{0x43, 0x27a3}, /* index:670, gain:62.81250db -> x3488.329917, DCG:on */
+	{0x43, 0x2811}, /* index:671, gain:62.90625db -> x3526.185054, DCG:on */
+	{0x43, 0x2881}, /* index:672, gain:63.00000db -> x3564.450993, DCG:on */
+	{0x43, 0x28f1}, /* index:673, gain:63.09375db -> x3603.130213, DCG:on */
+	{0x43, 0x2963}, /* index:674, gain:63.18750db -> x3642.231156, DCG:on */
+	{0x43, 0x29d6}, /* index:675, gain:63.28125db -> x3681.756419, DCG:on */
+	{0x43, 0x2a4a}, /* index:676, gain:63.37500db -> x3721.710608, DCG:on */
+	{0x43, 0x2ac0}, /* index:677, gain:63.46875db -> x3762.098378, DCG:on */
+	{0x43, 0x2b37}, /* index:678, gain:63.56250db -> x3802.922345, DCG:on */
+	{0x43, 0x2baf}, /* index:679, gain:63.65625db -> x3844.191419, DCG:on */
+	{0x43, 0x2c28}, /* index:680, gain:63.75000db -> x3885.908343, DCG:on */
+	{0x43, 0x2ca3}, /* index:681, gain:63.84375db -> x3928.077976, DCG:on */
+	{0x43, 0x2d1f}, /* index:682, gain:63.93750db -> x3970.705231, DCG:on */
+	{0x43, 0x2d9c}, /* index:683, gain:64.03125db -> x4013.792871, DCG:on */
+	{0x43, 0x2e1b}, /* index:684, gain:64.12500db -> x4057.350299, DCG:on */
+	{0x43, 0x2e9b}, /* index:685, gain:64.21875db -> x4101.380410, DCG:on */
+	{0x43, 0x2f1c}, /* index:686, gain:64.31250db -> x4145.888332, DCG:on */
+	{0x43, 0x2f9f}, /* index:687, gain:64.40625db -> x4190.879252, DCG:on */
+	{0x43, 0x3023}, /* index:688, gain:64.50000db -> x4236.356084, DCG:on */
+	{0x43, 0x30a9}, /* index:689, gain:64.59375db -> x4282.328754, DCG:on */
+	{0x43, 0x3130}, /* index:690, gain:64.68750db -> x4328.800317, DCG:on */
+	{0x43, 0x31b9}, /* index:691, gain:64.78125db -> x4375.776185, DCG:on */
+	{0x43, 0x3243}, /* index:692, gain:64.87500db -> x4423.261834, DCG:on */
+	{0x43, 0x32cf}, /* index:693, gain:64.96875db -> x4471.260338, DCG:on */
+	{0x43, 0x335c}, /* index:694, gain:65.06250db -> x4519.782174, DCG:on */
+	{0x43, 0x33eb}, /* index:695, gain:65.15625db -> x4568.830566, DCG:on */
+	{0x43, 0x347b}, /* index:696, gain:65.25000db -> x4618.411228, DCG:on */
+	{0x43, 0x350d}, /* index:697, gain:65.34375db -> x4668.529937, DCG:on */
+	{0x43, 0x35a0}, /* index:698, gain:65.43750db -> x4719.189939, DCG:on */
+	{0x43, 0x3635}, /* index:699, gain:65.53125db -> x4770.402292, DCG:on */
+	{0x43, 0x36cc}, /* index:700, gain:65.62500db -> x4822.170398, DCG:on */
+	{0x43, 0x3764}, /* index:701, gain:65.71875db -> x4874.500288, DCG:on */
+	{0x43, 0x37fe}, /* index:702, gain:65.81250db -> x4927.398058, DCG:on */
+	{0x43, 0x3899}, /* index:703, gain:65.90625db -> x4980.867138, DCG:on */
+	{0x43, 0x3937}, /* index:704, gain:66.00000db -> x5034.919195, DCG:on */
+	{0x43, 0x39d5}, /* index:705, gain:66.09375db -> x5089.557822, DCG:on */
+	{0x43, 0x3a76}, /* index:706, gain:66.18750db -> x5144.789383, DCG:on */
+	{0x43, 0x3b19}, /* index:707, gain:66.28125db -> x5200.620314, DCG:on */
+	{0x43, 0x3bbd}, /* index:708, gain:66.37500db -> x5257.054233, DCG:on */
+	{0x43, 0x3c63}, /* index:709, gain:66.46875db -> x5314.103455, DCG:on */
+	{0x43, 0x3d0a}, /* index:710, gain:66.56250db -> x5371.771772, DCG:on */
+	{0x43, 0x3db4}, /* index:711, gain:66.65625db -> x5430.065901, DCG:on */
+	{0x43, 0x3e5f}, /* index:712, gain:66.75000db -> x5488.992635, DCG:on */
+	{0x43, 0x3f0d}, /* index:713, gain:66.84375db -> x5548.555792, DCG:on */
+	{0x43, 0x3fbc}, /* index:714, gain:66.93750db -> x5608.768371, DCG:on */
+};
+
+/* Dual-Gain HDR Gain Table */
+#define OV2718_HDR_GAIN_ROWS				(493)
+#define OV2718_HDR_GAIN_COLS				(2)
+#define OV2718_HDR_GAIN_MAXDB				(492)
+
+#define OV2718_HDR_GAIN_COL_AGAIN			(0)
+#define OV2718_HDR_GAIN_COL_DGAIN			(1)
+
+static const u16 OV2718_HDR_GAIN_TABLE[OV2718_HDR_GAIN_ROWS][OV2718_HDR_GAIN_COLS] = {
+	{0x00, 0x0286}, /* index:0, gain:0.00000db -> x2.523438 */
+	{0x00, 0x028d}, /* index:1, gain:0.09375db -> x2.550821 */
+	{0x00, 0x0294}, /* index:2, gain:0.18750db -> x2.578502 */
+	{0x00, 0x029b}, /* index:3, gain:0.28125db -> x2.606484 */
+	{0x00, 0x02a2}, /* index:4, gain:0.37500db -> x2.634769 */
+	{0x00, 0x02a9}, /* index:5, gain:0.46875db -> x2.663361 */
+	{0x00, 0x02b1}, /* index:6, gain:0.56250db -> x2.692263 */
+	{0x00, 0x02b8}, /* index:7, gain:0.65625db -> x2.721479 */
+	{0x00, 0x02c0}, /* index:8, gain:0.75000db -> x2.751012 */
+	{0x00, 0x02c7}, /* index:9, gain:0.84375db -> x2.780866 */
+	{0x00, 0x02cf}, /* index:10, gain:0.93750db -> x2.811043 */
+	{0x00, 0x02d7}, /* index:11, gain:1.03125db -> x2.841548 */
+	{0x00, 0x02df}, /* index:12, gain:1.12500db -> x2.872384 */
+	{0x00, 0x02e7}, /* index:13, gain:1.21875db -> x2.903555 */
+	{0x00, 0x02ef}, /* index:14, gain:1.31250db -> x2.935064 */
+	{0x00, 0x02f7}, /* index:15, gain:1.40625db -> x2.966915 */
+	{0x00, 0x02ff}, /* index:16, gain:1.50000db -> x2.999111 */
+	{0x00, 0x0308}, /* index:17, gain:1.59375db -> x3.031657 */
+	{0x00, 0x0310}, /* index:18, gain:1.68750db -> x3.064556 */
+	{0x00, 0x0319}, /* index:19, gain:1.78125db -> x3.097812 */
+	{0x00, 0x0321}, /* index:20, gain:1.87500db -> x3.131429 */
+	{0x00, 0x032a}, /* index:21, gain:1.96875db -> x3.165411 */
+	{0x00, 0x0333}, /* index:22, gain:2.06250db -> x3.199761 */
+	{0x00, 0x033c}, /* index:23, gain:2.15625db -> x3.234484 */
+	{0x00, 0x0345}, /* index:24, gain:2.25000db -> x3.269584 */
+	{0x00, 0x034e}, /* index:25, gain:2.34375db -> x3.305065 */
+	{0x00, 0x0357}, /* index:26, gain:2.43750db -> x3.340931 */
+	{0x00, 0x0360}, /* index:27, gain:2.53125db -> x3.377187 */
+	{0x00, 0x0369}, /* index:28, gain:2.62500db -> x3.413835 */
+	{0x00, 0x0373}, /* index:29, gain:2.71875db -> x3.450882 */
+	{0x00, 0x037d}, /* index:30, gain:2.81250db -> x3.488330 */
+	{0x00, 0x0386}, /* index:31, gain:2.90625db -> x3.526185 */
+	{0x00, 0x0390}, /* index:32, gain:3.00000db -> x3.564450 */
+	{0x00, 0x039a}, /* index:33, gain:3.09375db -> x3.603131 */
+	{0x00, 0x03a4}, /* index:34, gain:3.18750db -> x3.642232 */
+	{0x00, 0x03ae}, /* index:35, gain:3.28125db -> x3.681756 */
+	{0x00, 0x03b8}, /* index:36, gain:3.37500db -> x3.721710 */
+	{0x00, 0x03c3}, /* index:37, gain:3.46875db -> x3.762098 */
+	{0x00, 0x03cd}, /* index:38, gain:3.56250db -> x3.802923 */
+	{0x00, 0x03d8}, /* index:39, gain:3.65625db -> x3.844192 */
+	{0x00, 0x03e2}, /* index:40, gain:3.75000db -> x3.885908 */
+	{0x00, 0x03ed}, /* index:41, gain:3.84375db -> x3.928078 */
+	{0x00, 0x03f8}, /* index:42, gain:3.93750db -> x3.970704 */
+	{0x00, 0x0403}, /* index:43, gain:4.03125db -> x4.013794 */
+	{0x00, 0x040e}, /* index:44, gain:4.12500db -> x4.057351 */
+	{0x00, 0x0419}, /* index:45, gain:4.21875db -> x4.101380 */
+	{0x00, 0x0425}, /* index:46, gain:4.31250db -> x4.145888 */
+	{0x00, 0x0430}, /* index:47, gain:4.40625db -> x4.190878 */
+	{0x00, 0x043c}, /* index:48, gain:4.50000db -> x4.236357 */
+	{0x00, 0x0448}, /* index:49, gain:4.59375db -> x4.282329 */
+	{0x00, 0x0454}, /* index:50, gain:4.68750db -> x4.328800 */
+	{0x00, 0x0460}, /* index:51, gain:4.78125db -> x4.375776 */
+	{0x00, 0x046c}, /* index:52, gain:4.87500db -> x4.423261 */
+	{0x00, 0x0478}, /* index:53, gain:4.96875db -> x4.471261 */
+	{0x00, 0x0485}, /* index:54, gain:5.06250db -> x4.519783 */
+	{0x00, 0x0491}, /* index:55, gain:5.15625db -> x4.568831 */
+	{0x00, 0x049e}, /* index:56, gain:5.25000db -> x4.618411 */
+	{0x00, 0x04ab}, /* index:57, gain:5.34375db -> x4.668529 */
+	{0x00, 0x04b8}, /* index:58, gain:5.43750db -> x4.719191 */
+	{0x00, 0x04c5}, /* index:59, gain:5.53125db -> x4.770403 */
+	{0x00, 0x04d2}, /* index:60, gain:5.62500db -> x4.822170 */
+	{0x00, 0x04df}, /* index:61, gain:5.71875db -> x4.874500 */
+	{0x00, 0x04ed}, /* index:62, gain:5.81250db -> x4.927397 */
+	{0x00, 0x04fb}, /* index:63, gain:5.90625db -> x4.980868 */
+	{0x00, 0x0508}, /* index:64, gain:6.00000db -> x5.034920 */
+	{0x01, 0x028b}, /* index:65, gain:6.09375db -> x5.089558 */
+	{0x01, 0x0292}, /* index:66, gain:6.18750db -> x5.144789 */
+	{0x01, 0x0299}, /* index:67, gain:6.28125db -> x5.200619 */
+	{0x01, 0x02a0}, /* index:68, gain:6.37500db -> x5.257055 */
+	{0x01, 0x02a8}, /* index:69, gain:6.46875db -> x5.314104 */
+	{0x01, 0x02af}, /* index:70, gain:6.56250db -> x5.371772 */
+	{0x01, 0x02b7}, /* index:71, gain:6.65625db -> x5.430065 */
+	{0x01, 0x02be}, /* index:72, gain:6.75000db -> x5.488992 */
+	{0x01, 0x02c6}, /* index:73, gain:6.84375db -> x5.548557 */
+	{0x01, 0x02cd}, /* index:74, gain:6.93750db -> x5.608769 */
+	{0x01, 0x02d5}, /* index:75, gain:7.03125db -> x5.669634 */
+	{0x01, 0x02dd}, /* index:76, gain:7.12500db -> x5.731160 */
+	{0x01, 0x02e5}, /* index:77, gain:7.21875db -> x5.793354 */
+	{0x01, 0x02ed}, /* index:78, gain:7.31250db -> x5.856222 */
+	{0x01, 0x02f5}, /* index:79, gain:7.40625db -> x5.919773 */
+	{0x01, 0x02fd}, /* index:80, gain:7.50000db -> x5.984013 */
+	{0x01, 0x0306}, /* index:81, gain:7.59375db -> x6.048951 */
+	{0x01, 0x030e}, /* index:82, gain:7.68750db -> x6.114593 */
+	{0x01, 0x0317}, /* index:83, gain:7.78125db -> x6.180947 */
+	{0x01, 0x031f}, /* index:84, gain:7.87500db -> x6.248022 */
+	{0x01, 0x0328}, /* index:85, gain:7.96875db -> x6.315824 */
+	{0x01, 0x0331}, /* index:86, gain:8.06250db -> x6.384363 */
+	{0x01, 0x033a}, /* index:87, gain:8.15625db -> x6.453645 */
+	{0x01, 0x0343}, /* index:88, gain:8.25000db -> x6.523678 */
+	{0x01, 0x034c}, /* index:89, gain:8.34375db -> x6.594473 */
+	{0x01, 0x0355}, /* index:90, gain:8.43750db -> x6.666034 */
+	{0x01, 0x035e}, /* index:91, gain:8.53125db -> x6.738373 */
+	{0x01, 0x0367}, /* index:92, gain:8.62500db -> x6.811497 */
+	{0x01, 0x0371}, /* index:93, gain:8.71875db -> x6.885414 */
+	{0x01, 0x037a}, /* index:94, gain:8.81250db -> x6.960133 */
+	{0x01, 0x0384}, /* index:95, gain:8.90625db -> x7.035663 */
+	{0x01, 0x038e}, /* index:96, gain:9.00000db -> x7.112013 */
+	{0x01, 0x0398}, /* index:97, gain:9.09375db -> x7.189192 */
+	{0x01, 0x03a2}, /* index:98, gain:9.18750db -> x7.267207 */
+	{0x01, 0x03ac}, /* index:99, gain:9.28125db -> x7.346070 */
+	{0x01, 0x03b6}, /* index:100, gain:9.37500db -> x7.425788 */
+	{0x01, 0x03c0}, /* index:101, gain:9.46875db -> x7.506371 */
+	{0x01, 0x03cb}, /* index:102, gain:9.56250db -> x7.587829 */
+	{0x01, 0x03d5}, /* index:103, gain:9.65625db -> x7.670171 */
+	{0x01, 0x03e0}, /* index:104, gain:9.75000db -> x7.753407 */
+	{0x01, 0x03eb}, /* index:105, gain:9.84375db -> x7.837545 */
+	{0x01, 0x03f6}, /* index:106, gain:9.93750db -> x7.922597 */
+	{0x01, 0x0401}, /* index:107, gain:10.03125db -> x8.008571 */
+	{0x01, 0x040c}, /* index:108, gain:10.12500db -> x8.095479 */
+	{0x01, 0x0417}, /* index:109, gain:10.21875db -> x8.183330 */
+	{0x01, 0x0422}, /* index:110, gain:10.31250db -> x8.272134 */
+	{0x01, 0x042e}, /* index:111, gain:10.40625db -> x8.361901 */
+	{0x01, 0x0439}, /* index:112, gain:10.50000db -> x8.452643 */
+	{0x01, 0x0445}, /* index:113, gain:10.59375db -> x8.544371 */
+	{0x01, 0x0451}, /* index:114, gain:10.68750db -> x8.637092 */
+	{0x01, 0x045d}, /* index:115, gain:10.78125db -> x8.730820 */
+	{0x01, 0x0469}, /* index:116, gain:10.87500db -> x8.825565 */
+	{0x01, 0x0475}, /* index:117, gain:10.96875db -> x8.921339 */
+	{0x01, 0x0482}, /* index:118, gain:11.06250db -> x9.018153 */
+	{0x01, 0x048e}, /* index:119, gain:11.15625db -> x9.116016 */
+	{0x01, 0x049b}, /* index:120, gain:11.25000db -> x9.214941 */
+	{0x01, 0x04a8}, /* index:121, gain:11.34375db -> x9.314940 */
+	{0x01, 0x04b5}, /* index:122, gain:11.43750db -> x9.416023 */
+	{0x01, 0x04c2}, /* index:123, gain:11.53125db -> x9.518205 */
+	{0x01, 0x04cf}, /* index:124, gain:11.62500db -> x9.621495 */
+	{0x01, 0x04dc}, /* index:125, gain:11.71875db -> x9.725906 */
+	{0x01, 0x04ea}, /* index:126, gain:11.81250db -> x9.831449 */
+	{0x01, 0x04f8}, /* index:127, gain:11.90625db -> x9.938138 */
+	{0x01, 0x0505}, /* index:128, gain:12.00000db -> x10.045986 */
+	{0x02, 0x0289}, /* index:129, gain:12.09375db -> x10.155003 */
+	{0x02, 0x0290}, /* index:130, gain:12.18750db -> x10.265203 */
+	{0x02, 0x0298}, /* index:131, gain:12.28125db -> x10.376599 */
+	{0x02, 0x029f}, /* index:132, gain:12.37500db -> x10.489204 */
+	{0x02, 0x02a6}, /* index:133, gain:12.46875db -> x10.603032 */
+	{0x02, 0x02ad}, /* index:134, gain:12.56250db -> x10.718094 */
+	{0x02, 0x02b5}, /* index:135, gain:12.65625db -> x10.834405 */
+	{0x02, 0x02bc}, /* index:136, gain:12.75000db -> x10.951977 */
+	{0x02, 0x02c4}, /* index:137, gain:12.84375db -> x11.070826 */
+	{0x02, 0x02cc}, /* index:138, gain:12.93750db -> x11.190966 */
+	{0x02, 0x02d3}, /* index:139, gain:13.03125db -> x11.312408 */
+	{0x02, 0x02db}, /* index:140, gain:13.12500db -> x11.435168 */
+	{0x02, 0x02e3}, /* index:141, gain:13.21875db -> x11.559260 */
+	{0x02, 0x02eb}, /* index:142, gain:13.31250db -> x11.684699 */
+	{0x02, 0x02f3}, /* index:143, gain:13.40625db -> x11.811501 */
+	{0x02, 0x02fc}, /* index:144, gain:13.50000db -> x11.939677 */
+	{0x02, 0x0304}, /* index:145, gain:13.59375db -> x12.069244 */
+	{0x02, 0x030c}, /* index:146, gain:13.68750db -> x12.200217 */
+	{0x02, 0x0315}, /* index:147, gain:13.78125db -> x12.332611 */
+	{0x02, 0x031d}, /* index:148, gain:13.87500db -> x12.466444 */
+	{0x02, 0x0326}, /* index:149, gain:13.96875db -> x12.601727 */
+	{0x02, 0x032f}, /* index:150, gain:14.06250db -> x12.738478 */
+	{0x02, 0x0338}, /* index:151, gain:14.15625db -> x12.876714 */
+	{0x02, 0x0341}, /* index:152, gain:14.25000db -> x13.016449 */
+	{0x02, 0x034a}, /* index:153, gain:14.34375db -> x13.157703 */
+	{0x02, 0x0353}, /* index:154, gain:14.43750db -> x13.300488 */
+	{0x02, 0x035c}, /* index:155, gain:14.53125db -> x13.444822 */
+	{0x02, 0x0365}, /* index:156, gain:14.62500db -> x13.590722 */
+	{0x02, 0x036f}, /* index:157, gain:14.71875db -> x13.738206 */
+	{0x02, 0x0378}, /* index:158, gain:14.81250db -> x13.887292 */
+	{0x02, 0x0382}, /* index:159, gain:14.90625db -> x14.037994 */
+	{0x02, 0x038c}, /* index:160, gain:15.00000db -> x14.190332 */
+	{0x02, 0x0396}, /* index:161, gain:15.09375db -> x14.344322 */
+	{0x02, 0x039f}, /* index:162, gain:15.18750db -> x14.499984 */
+	{0x02, 0x03aa}, /* index:163, gain:15.28125db -> x14.657337 */
+	{0x02, 0x03b4}, /* index:164, gain:15.37500db -> x14.816396 */
+	{0x02, 0x03be}, /* index:165, gain:15.46875db -> x14.977180 */
+	{0x02, 0x03c8}, /* index:166, gain:15.56250db -> x15.139709 */
+	{0x02, 0x03d3}, /* index:167, gain:15.65625db -> x15.304003 */
+	{0x02, 0x03de}, /* index:168, gain:15.75000db -> x15.470081 */
+	{0x02, 0x03e8}, /* index:169, gain:15.84375db -> x15.637959 */
+	{0x02, 0x03f3}, /* index:170, gain:15.93750db -> x15.807659 */
+	{0x02, 0x03fe}, /* index:171, gain:16.03125db -> x15.979200 */
+	{0x02, 0x0409}, /* index:172, gain:16.12500db -> x16.152603 */
+	{0x02, 0x0414}, /* index:173, gain:16.21875db -> x16.327890 */
+	{0x02, 0x0420}, /* index:174, gain:16.31250db -> x16.505077 */
+	{0x02, 0x042b}, /* index:175, gain:16.40625db -> x16.684187 */
+	{0x02, 0x0437}, /* index:176, gain:16.50000db -> x16.865241 */
+	{0x02, 0x0443}, /* index:177, gain:16.59375db -> x17.048259 */
+	{0x02, 0x044e}, /* index:178, gain:16.68750db -> x17.233265 */
+	{0x02, 0x045a}, /* index:179, gain:16.78125db -> x17.420277 */
+	{0x02, 0x0466}, /* index:180, gain:16.87500db -> x17.609319 */
+	{0x02, 0x0473}, /* index:181, gain:16.96875db -> x17.800411 */
+	{0x02, 0x047f}, /* index:182, gain:17.06250db -> x17.993578 */
+	{0x02, 0x048c}, /* index:183, gain:17.15625db -> x18.188843 */
+	{0x02, 0x0498}, /* index:184, gain:17.25000db -> x18.386225 */
+	{0x02, 0x04a5}, /* index:185, gain:17.34375db -> x18.585748 */
+	{0x02, 0x04b2}, /* index:186, gain:17.43750db -> x18.787437 */
+	{0x02, 0x04bf}, /* index:187, gain:17.53125db -> x18.991315 */
+	{0x02, 0x04cc}, /* index:188, gain:17.62500db -> x19.197407 */
+	{0x02, 0x04d9}, /* index:189, gain:17.71875db -> x19.405734 */
+	{0x02, 0x04e7}, /* index:190, gain:17.81250db -> x19.616321 */
+	{0x02, 0x04f5}, /* index:191, gain:17.90625db -> x19.829193 */
+	{0x02, 0x0502}, /* index:192, gain:18.00000db -> x20.044375 */
+	{0x03, 0x0288}, /* index:193, gain:18.09375db -> x20.261896 */
+	{0x03, 0x028f}, /* index:194, gain:18.18750db -> x20.481774 */
+	{0x03, 0x0296}, /* index:195, gain:18.28125db -> x20.704038 */
+	{0x03, 0x029d}, /* index:196, gain:18.37500db -> x20.928714 */
+	{0x03, 0x02a4}, /* index:197, gain:18.46875db -> x21.155828 */
+	{0x03, 0x02ac}, /* index:198, gain:18.56250db -> x21.385410 */
+	{0x03, 0x02b3}, /* index:199, gain:18.65625db -> x21.617480 */
+	{0x03, 0x02bb}, /* index:200, gain:18.75000db -> x21.852068 */
+	{0x03, 0x02c2}, /* index:201, gain:18.84375db -> x22.089203 */
+	{0x03, 0x02ca}, /* index:202, gain:18.93750db -> x22.328910 */
+	{0x03, 0x02d2}, /* index:203, gain:19.03125db -> x22.571222 */
+	{0x03, 0x02da}, /* index:204, gain:19.12500db -> x22.816161 */
+	{0x03, 0x02e2}, /* index:205, gain:19.21875db -> x23.063757 */
+	{0x03, 0x02ea}, /* index:206, gain:19.31250db -> x23.314040 */
+	{0x03, 0x02f2}, /* index:207, gain:19.40625db -> x23.567039 */
+	{0x03, 0x02fa}, /* index:208, gain:19.50000db -> x23.822787 */
+	{0x03, 0x0302}, /* index:209, gain:19.59375db -> x24.081308 */
+	{0x03, 0x030a}, /* index:210, gain:19.68750db -> x24.342633 */
+	{0x03, 0x0313}, /* index:211, gain:19.78125db -> x24.606794 */
+	{0x03, 0x031b}, /* index:212, gain:19.87500db -> x24.873822 */
+	{0x03, 0x0324}, /* index:213, gain:19.96875db -> x25.143752 */
+	{0x03, 0x032d}, /* index:214, gain:20.06250db -> x25.416603 */
+	{0x03, 0x0336}, /* index:215, gain:20.15625db -> x25.692422 */
+	{0x03, 0x033f}, /* index:216, gain:20.25000db -> x25.971235 */
+	{0x03, 0x0348}, /* index:217, gain:20.34375db -> x26.253066 */
+	{0x03, 0x0351}, /* index:218, gain:20.43750db -> x26.537963 */
+	{0x03, 0x035a}, /* index:219, gain:20.53125db -> x26.825943 */
+	{0x03, 0x0363}, /* index:220, gain:20.62500db -> x27.117057 */
+	{0x03, 0x036d}, /* index:221, gain:20.71875db -> x27.411330 */
+	{0x03, 0x0376}, /* index:222, gain:20.81250db -> x27.708788 */
+	{0x03, 0x0380}, /* index:223, gain:20.90625db -> x28.009482 */
+	{0x03, 0x038a}, /* index:224, gain:21.00000db -> x28.313431 */
+	{0x03, 0x0393}, /* index:225, gain:21.09375db -> x28.620687 */
+	{0x03, 0x039d}, /* index:226, gain:21.18750db -> x28.931277 */
+	{0x03, 0x03a7}, /* index:227, gain:21.28125db -> x29.245229 */
+	{0x03, 0x03b2}, /* index:228, gain:21.37500db -> x29.562597 */
+	{0x03, 0x03bc}, /* index:229, gain:21.46875db -> x29.883400 */
+	{0x03, 0x03c6}, /* index:230, gain:21.56250db -> x30.207693 */
+	{0x03, 0x03d1}, /* index:231, gain:21.65625db -> x30.535505 */
+	{0x03, 0x03db}, /* index:232, gain:21.75000db -> x30.866865 */
+	{0x03, 0x03e6}, /* index:233, gain:21.84375db -> x31.201831 */
+	{0x03, 0x03f1}, /* index:234, gain:21.93750db -> x31.540422 */
+	{0x03, 0x03fc}, /* index:235, gain:22.03125db -> x31.882697 */
+	{0x03, 0x0407}, /* index:236, gain:22.12500db -> x32.228686 */
+	{0x03, 0x0412}, /* index:237, gain:22.21875db -> x32.578421 */
+	{0x03, 0x041d}, /* index:238, gain:22.31250db -> x32.931960 */
+	{0x03, 0x0429}, /* index:239, gain:22.40625db -> x33.289326 */
+	{0x03, 0x0434}, /* index:240, gain:22.50000db -> x33.650580 */
+	{0x03, 0x0440}, /* index:241, gain:22.59375db -> x34.015754 */
+	{0x03, 0x044c}, /* index:242, gain:22.68750db -> x34.384881 */
+	{0x03, 0x0458}, /* index:243, gain:22.78125db -> x34.758024 */
+	{0x03, 0x0464}, /* index:244, gain:22.87500db -> x35.135206 */
+	{0x03, 0x0470}, /* index:245, gain:22.96875db -> x35.516491 */
+	{0x03, 0x047c}, /* index:246, gain:23.06250db -> x35.901914 */
+	{0x03, 0x0489}, /* index:247, gain:23.15625db -> x36.291509 */
+	{0x03, 0x0495}, /* index:248, gain:23.25000db -> x36.685342 */
+	{0x03, 0x04a2}, /* index:249, gain:23.34375db -> x37.083439 */
+	{0x03, 0x04af}, /* index:250, gain:23.43750db -> x37.485866 */
+	{0x03, 0x04bc}, /* index:251, gain:23.53125db -> x37.892661 */
+	{0x03, 0x04c9}, /* index:252, gain:23.62500db -> x38.303859 */
+	{0x03, 0x04d7}, /* index:253, gain:23.71875db -> x38.719530 */
+	{0x03, 0x04e4}, /* index:254, gain:23.81250db -> x39.139701 */
+	{0x03, 0x04f2}, /* index:255, gain:23.90625db -> x39.564443 */
+	{0x03, 0x04ff}, /* index:256, gain:24.00000db -> x39.993794 */
+	{0x03, 0x050d}, /* index:257, gain:24.09375db -> x40.427793 */
+	{0x03, 0x051b}, /* index:258, gain:24.18750db -> x40.866512 */
+	{0x03, 0x0529}, /* index:259, gain:24.28125db -> x41.309982 */
+	{0x03, 0x0538}, /* index:260, gain:24.37500db -> x41.758275 */
+	{0x03, 0x0546}, /* index:261, gain:24.46875db -> x42.211433 */
+	{0x03, 0x0555}, /* index:262, gain:24.56250db -> x42.669498 */
+	{0x03, 0x0564}, /* index:263, gain:24.65625db -> x43.132544 */
+	{0x03, 0x0573}, /* index:264, gain:24.75000db -> x43.600604 */
+	{0x03, 0x0582}, /* index:265, gain:24.84375db -> x44.073755 */
+	{0x03, 0x0591}, /* index:266, gain:24.93750db -> x44.552041 */
+	{0x03, 0x05a1}, /* index:267, gain:25.03125db -> x45.035504 */
+	{0x03, 0x05b0}, /* index:268, gain:25.12500db -> x45.524227 */
+	{0x03, 0x05c0}, /* index:269, gain:25.21875db -> x46.018240 */
+	{0x03, 0x05d0}, /* index:270, gain:25.31250db -> x46.517627 */
+	{0x03, 0x05e0}, /* index:271, gain:25.40625db -> x47.022433 */
+	{0x03, 0x05f1}, /* index:272, gain:25.50000db -> x47.532705 */
+	{0x03, 0x0601}, /* index:273, gain:25.59375db -> x48.048527 */
+	{0x03, 0x0612}, /* index:274, gain:25.68750db -> x48.569933 */
+	{0x03, 0x0623}, /* index:275, gain:25.78125db -> x49.097011 */
+	{0x03, 0x0634}, /* index:276, gain:25.87500db -> x49.629809 */
+	{0x03, 0x0645}, /* index:277, gain:25.96875db -> x50.168374 */
+	{0x03, 0x0656}, /* index:278, gain:26.06250db -> x50.712798 */
+	{0x03, 0x0668}, /* index:279, gain:26.15625db -> x51.263116 */
+	{0x03, 0x067a}, /* index:280, gain:26.25000db -> x51.819421 */
+	{0x03, 0x068c}, /* index:281, gain:26.34375db -> x52.381762 */
+	{0x03, 0x069e}, /* index:282, gain:26.43750db -> x52.950191 */
+	{0x03, 0x06b0}, /* index:283, gain:26.53125db -> x53.524803 */
+	{0x03, 0x06c3}, /* index:284, gain:26.62500db -> x54.105636 */
+	{0x03, 0x06d6}, /* index:285, gain:26.71875db -> x54.692787 */
+	{0x03, 0x06e9}, /* index:286, gain:26.81250db -> x55.286309 */
+	{0x03, 0x06fc}, /* index:287, gain:26.90625db -> x55.886258 */
+	{0x03, 0x070f}, /* index:288, gain:27.00000db -> x56.492732 */
+	{0x03, 0x0723}, /* index:289, gain:27.09375db -> x57.105772 */
+	{0x03, 0x0737}, /* index:290, gain:27.18750db -> x57.725480 */
+	{0x03, 0x074b}, /* index:291, gain:27.28125db -> x58.351913 */
+	{0x03, 0x075f}, /* index:292, gain:27.37500db -> x58.985128 */
+	{0x03, 0x0774}, /* index:293, gain:27.46875db -> x59.625231 */
+	{0x03, 0x0788}, /* index:294, gain:27.56250db -> x60.272264 */
+	{0x03, 0x079d}, /* index:295, gain:27.65625db -> x60.926335 */
+	{0x03, 0x07b2}, /* index:296, gain:27.75000db -> x61.587504 */
+	{0x03, 0x07c8}, /* index:297, gain:27.84375db -> x62.255830 */
+	{0x03, 0x07dd}, /* index:298, gain:27.93750db -> x62.931427 */
+	{0x03, 0x07f3}, /* index:299, gain:28.03125db -> x63.614337 */
+	{0x03, 0x0809}, /* index:300, gain:28.12500db -> x64.304676 */
+	{0x03, 0x0820}, /* index:301, gain:28.21875db -> x65.002506 */
+	{0x03, 0x0836}, /* index:302, gain:28.31250db -> x65.707891 */
+	{0x03, 0x084d}, /* index:303, gain:28.40625db -> x66.420949 */
+	{0x03, 0x0864}, /* index:304, gain:28.50000db -> x67.141727 */
+	{0x03, 0x087b}, /* index:305, gain:28.59375db -> x67.870344 */
+	{0x03, 0x0893}, /* index:306, gain:28.68750db -> x68.606869 */
+	{0x03, 0x08ab}, /* index:307, gain:28.78125db -> x69.351367 */
+	{0x03, 0x08c3}, /* index:308, gain:28.87500db -> x70.103964 */
+	{0x03, 0x08db}, /* index:309, gain:28.96875db -> x70.864708 */
+	{0x03, 0x08f4}, /* index:310, gain:29.06250db -> x71.633728 */
+	{0x03, 0x090d}, /* index:311, gain:29.15625db -> x72.411093 */
+	{0x03, 0x0926}, /* index:312, gain:29.25000db -> x73.196873 */
+	{0x03, 0x093f}, /* index:313, gain:29.34375db -> x73.991201 */
+	{0x03, 0x0959}, /* index:314, gain:29.43750db -> x74.794128 */
+	{0x03, 0x0973}, /* index:315, gain:29.53125db -> x75.605789 */
+	{0x03, 0x098d}, /* index:316, gain:29.62500db -> x76.426259 */
+	{0x03, 0x09a8}, /* index:317, gain:29.71875db -> x77.255611 */
+	{0x03, 0x09c3}, /* index:318, gain:29.81250db -> x78.093984 */
+	{0x03, 0x09de}, /* index:319, gain:29.90625db -> x78.941433 */
+	{0x03, 0x09f9}, /* index:320, gain:30.00000db -> x79.798100 */
+	{0x03, 0x0a15}, /* index:321, gain:30.09375db -> x80.664064 */
+	{0x03, 0x0a31}, /* index:322, gain:30.18750db -> x81.539403 */
+	{0x03, 0x0a4d}, /* index:323, gain:30.28125db -> x82.424264 */
+	{0x03, 0x0a6a}, /* index:324, gain:30.37500db -> x83.318704 */
+	{0x03, 0x0a87}, /* index:325, gain:30.46875db -> x84.222873 */
+	{0x03, 0x0aa4}, /* index:326, gain:30.56250db -> x85.136854 */
+	{0x03, 0x0ac1}, /* index:327, gain:30.65625db -> x86.060731 */
+	{0x03, 0x0adf}, /* index:328, gain:30.75000db -> x86.994656 */
+	{0x03, 0x0afe}, /* index:329, gain:30.84375db -> x87.938693 */
+	{0x03, 0x0b1c}, /* index:330, gain:30.93750db -> x88.892998 */
+	{0x03, 0x0b3b}, /* index:331, gain:31.03125db -> x89.857659 */
+	{0x03, 0x0b5a}, /* index:332, gain:31.12500db -> x90.832764 */
+	{0x03, 0x0b7a}, /* index:333, gain:31.21875db -> x91.818475 */
+	{0x03, 0x0b9a}, /* index:334, gain:31.31250db -> x92.814858 */
+	{0x03, 0x0bba}, /* index:335, gain:31.40625db -> x93.822079 */
+	{0x03, 0x0bda}, /* index:336, gain:31.50000db -> x94.840230 */
+	{0x03, 0x0bfb}, /* index:337, gain:31.59375db -> x95.869404 */
+	{0x03, 0x0c1d}, /* index:338, gain:31.68750db -> x96.909773 */
+	{0x03, 0x0c3e}, /* index:339, gain:31.78125db -> x97.961405 */
+	{0x03, 0x0c60}, /* index:340, gain:31.87500db -> x99.024476 */
+	{0x03, 0x0c83}, /* index:341, gain:31.96875db -> x100.099083 */
+	{0x03, 0x0ca5}, /* index:342, gain:32.06250db -> x101.185325 */
+	{0x03, 0x0cc9}, /* index:343, gain:32.15625db -> x102.283381 */
+	{0x03, 0x0cec}, /* index:344, gain:32.25000db -> x103.393326 */
+	{0x03, 0x0d10}, /* index:345, gain:32.34375db -> x104.515344 */
+	{0x03, 0x0d34}, /* index:346, gain:32.43750db -> x105.649538 */
+	{0x03, 0x0d59}, /* index:347, gain:32.53125db -> x106.796010 */
+	{0x03, 0x0d7e}, /* index:348, gain:32.62500db -> x107.954954 */
+	{0x03, 0x0da4}, /* index:349, gain:32.71875db -> x109.126444 */
+	{0x03, 0x0dc9}, /* index:350, gain:32.81250db -> x110.310678 */
+	{0x03, 0x0df0}, /* index:351, gain:32.90625db -> x111.507762 */
+	{0x03, 0x0e16}, /* index:352, gain:33.00000db -> x112.717807 */
+	{0x03, 0x0e3e}, /* index:353, gain:33.09375db -> x113.941013 */
+	{0x03, 0x0e65}, /* index:354, gain:33.18750db -> x115.177462 */
+	{0x03, 0x0e8d}, /* index:355, gain:33.28125db -> x116.427361 */
+	{0x03, 0x0eb6}, /* index:356, gain:33.37500db -> x117.690823 */
+	{0x03, 0x0ede}, /* index:357, gain:33.46875db -> x118.967964 */
+	{0x03, 0x0f08}, /* index:358, gain:33.56250db -> x120.258997 */
+	{0x03, 0x0f32}, /* index:359, gain:33.65625db -> x121.564006 */
+	{0x03, 0x0f5c}, /* index:360, gain:33.75000db -> x122.883211 */
+	{0x03, 0x0f86}, /* index:361, gain:33.84375db -> x124.216732 */
+	{0x03, 0x0fb2}, /* index:362, gain:33.93750db -> x125.564690 */
+	{0x03, 0x0fdd}, /* index:363, gain:34.03125db -> x126.927310 */
+	{0x03, 0x1009}, /* index:364, gain:34.12500db -> x128.304682 */
+	{0x03, 0x1036}, /* index:365, gain:34.21875db -> x129.697036 */
+	{0x03, 0x1063}, /* index:366, gain:34.31250db -> x131.104501 */
+	{0x03, 0x1090}, /* index:367, gain:34.40625db -> x132.527202 */
+	{0x03, 0x10be}, /* index:368, gain:34.50000db -> x133.965379 */
+	{0x03, 0x10ed}, /* index:369, gain:34.59375db -> x135.419126 */
+	{0x03, 0x111c}, /* index:370, gain:34.68750db -> x136.888685 */
+	{0x03, 0x114b}, /* index:371, gain:34.78125db -> x138.374193 */
+	{0x03, 0x117c}, /* index:372, gain:34.87500db -> x139.875782 */
+	{0x03, 0x11ac}, /* index:373, gain:34.96875db -> x141.393706 */
+	{0x03, 0x11dd}, /* index:374, gain:35.06250db -> x142.928062 */
+	{0x03, 0x120f}, /* index:375, gain:35.15625db -> x144.479108 */
+	{0x03, 0x1241}, /* index:376, gain:35.25000db -> x146.046987 */
+	{0x03, 0x1274}, /* index:377, gain:35.34375db -> x147.631839 */
+	{0x03, 0x12a7}, /* index:378, gain:35.43750db -> x149.233930 */
+	{0x03, 0x12db}, /* index:379, gain:35.53125db -> x150.853366 */
+	{0x03, 0x130f}, /* index:380, gain:35.62500db -> x152.490417 */
+	{0x03, 0x1344}, /* index:381, gain:35.71875db -> x154.145234 */
+	{0x03, 0x137a}, /* index:382, gain:35.81250db -> x155.817965 */
+	{0x03, 0x13b0}, /* index:383, gain:35.90625db -> x157.508892 */
+	{0x03, 0x13e6}, /* index:384, gain:36.00000db -> x159.218125 */
+	{0x03, 0x141e}, /* index:385, gain:36.09375db -> x160.945950 */
+	{0x03, 0x1456}, /* index:386, gain:36.18750db -> x162.692525 */
+	{0x03, 0x148e}, /* index:387, gain:36.28125db -> x164.458009 */
+	{0x03, 0x14c7}, /* index:388, gain:36.37500db -> x166.242697 */
+	{0x03, 0x1501}, /* index:389, gain:36.46875db -> x168.046706 */
+	{0x03, 0x153b}, /* index:390, gain:36.56250db -> x169.870339 */
+	{0x03, 0x1576}, /* index:391, gain:36.65625db -> x171.713761 */
+	{0x03, 0x15b2}, /* index:392, gain:36.75000db -> x173.577140 */
+	{0x03, 0x15ee}, /* index:393, gain:36.84375db -> x175.460788 */
+	{0x03, 0x162b}, /* index:394, gain:36.93750db -> x177.364829 */
+	{0x03, 0x1669}, /* index:395, gain:37.03125db -> x179.289581 */
+	{0x03, 0x16a7}, /* index:396, gain:37.12500db -> x181.235220 */
+	{0x03, 0x16e6}, /* index:397, gain:37.21875db -> x183.201923 */
+	{0x03, 0x1726}, /* index:398, gain:37.31250db -> x185.190019 */
+	{0x03, 0x1766}, /* index:399, gain:37.40625db -> x187.199638 */
+	{0x03, 0x17a7}, /* index:400, gain:37.50000db -> x189.231117 */
+	{0x03, 0x17e9}, /* index:401, gain:37.59375db -> x191.284641 */
+	{0x03, 0x182b}, /* index:402, gain:37.68750db -> x193.360397 */
+	{0x03, 0x186e}, /* index:403, gain:37.78125db -> x195.458732 */
+	{0x03, 0x18b2}, /* index:404, gain:37.87500db -> x197.579783 */
+	{0x03, 0x18f7}, /* index:405, gain:37.96875db -> x199.723907 */
+	{0x03, 0x193c}, /* index:406, gain:38.06250db -> x201.891298 */
+	{0x03, 0x1982}, /* index:407, gain:38.15625db -> x204.082154 */
+	{0x03, 0x19c9}, /* index:408, gain:38.25000db -> x206.296840 */
+	{0x03, 0x1a11}, /* index:409, gain:38.34375db -> x208.535504 */
+	{0x03, 0x1a59}, /* index:410, gain:38.43750db -> x210.798518 */
+	{0x03, 0x1aa2}, /* index:411, gain:38.53125db -> x213.086090 */
+	{0x03, 0x1aec}, /* index:412, gain:38.62500db -> x215.398428 */
+	{0x03, 0x1b37}, /* index:413, gain:38.71875db -> x217.735918 */
+	{0x03, 0x1b83}, /* index:414, gain:38.81250db -> x220.098714 */
+	{0x03, 0x1bcf}, /* index:415, gain:38.90625db -> x222.487211 */
+	{0x03, 0x1c1c}, /* index:416, gain:39.00000db -> x224.901629 */
+	{0x03, 0x1c6a}, /* index:417, gain:39.09375db -> x227.342185 */
+	{0x03, 0x1cb9}, /* index:418, gain:39.18750db -> x229.809288 */
+	{0x03, 0x1d09}, /* index:419, gain:39.28125db -> x232.303100 */
+	{0x03, 0x1d5a}, /* index:420, gain:39.37500db -> x234.824038 */
+	{0x03, 0x1dab}, /* index:421, gain:39.46875db -> x237.372334 */
+	{0x03, 0x1dfe}, /* index:422, gain:39.56250db -> x239.948218 */
+	{0x03, 0x1e51}, /* index:423, gain:39.65625db -> x242.552121 */
+	{0x03, 0x1ea5}, /* index:424, gain:39.75000db -> x245.184214 */
+	{0x03, 0x1efb}, /* index:425, gain:39.84375db -> x247.844938 */
+	{0x03, 0x1f51}, /* index:426, gain:39.93750db -> x250.534535 */
+	{0x03, 0x1fa8}, /* index:427, gain:40.03125db -> x253.253320 */
+	{0x03, 0x2000}, /* index:428, gain:40.12500db -> x256.001469 */
+	{0x03, 0x2058}, /* index:429, gain:40.21875db -> x258.779581 */
+	{0x03, 0x20b2}, /* index:430, gain:40.31250db -> x261.587841 */
+	{0x03, 0x210d}, /* index:431, gain:40.40625db -> x264.426575 */
+	{0x03, 0x2169}, /* index:432, gain:40.50000db -> x267.296116 */
+	{0x03, 0x21c6}, /* index:433, gain:40.59375db -> x270.196648 */
+	{0x03, 0x2224}, /* index:434, gain:40.68750db -> x273.128805 */
+	{0x03, 0x2282}, /* index:435, gain:40.78125db -> x276.092782 */
+	{0x03, 0x22e2}, /* index:436, gain:40.87500db -> x279.088923 */
+	{0x03, 0x2343}, /* index:437, gain:40.96875db -> x282.117579 */
+	{0x03, 0x23a5}, /* index:438, gain:41.06250db -> x285.178945 */
+	{0x03, 0x2408}, /* index:439, gain:41.15625db -> x288.273689 */
+	{0x03, 0x246c}, /* index:440, gain:41.25000db -> x291.402016 */
+	{0x03, 0x24d2}, /* index:441, gain:41.34375db -> x294.564293 */
+	{0x03, 0x2538}, /* index:442, gain:41.43750db -> x297.760886 */
+	{0x03, 0x259f}, /* index:443, gain:41.53125db -> x300.992003 */
+	{0x03, 0x2608}, /* index:444, gain:41.62500db -> x304.258349 */
+	{0x03, 0x2671}, /* index:445, gain:41.71875db -> x307.560142 */
+	{0x03, 0x26dc}, /* index:446, gain:41.81250db -> x310.897765 */
+	{0x03, 0x2748}, /* index:447, gain:41.90625db -> x314.271608 */
+	{0x03, 0x27b5}, /* index:448, gain:42.00000db -> x317.681890 */
+	{0x03, 0x2824}, /* index:449, gain:42.09375db -> x321.129354 */
+	{0x03, 0x2893}, /* index:450, gain:42.18750db -> x324.614229 */
+	{0x03, 0x2904}, /* index:451, gain:42.28125db -> x328.136922 */
+	{0x03, 0x2976}, /* index:452, gain:42.37500db -> x331.697844 */
+	{0x03, 0x29e9}, /* index:453, gain:42.46875db -> x335.297224 */
+	{0x03, 0x2a5d}, /* index:454, gain:42.56250db -> x338.935848 */
+	{0x03, 0x2ad3}, /* index:455, gain:42.65625db -> x342.613959 */
+	{0x03, 0x2b4a}, /* index:456, gain:42.75000db -> x346.331984 */
+	{0x03, 0x2bc2}, /* index:457, gain:42.84375db -> x350.090357 */
+	{0x03, 0x2c3c}, /* index:458, gain:42.93750db -> x353.889321 */
+	{0x03, 0x2cb7}, /* index:459, gain:43.03125db -> x357.729705 */
+	{0x03, 0x2d33}, /* index:460, gain:43.12500db -> x361.611766 */
+	{0x03, 0x2db1}, /* index:461, gain:43.21875db -> x365.535954 */
+	{0x03, 0x2e30}, /* index:462, gain:43.31250db -> x369.502727 */
+	{0x03, 0x2eb0}, /* index:463, gain:43.40625db -> x373.512342 */
+	{0x03, 0x2f32}, /* index:464, gain:43.50000db -> x377.565675 */
+	{0x03, 0x2fb5}, /* index:465, gain:43.59375db -> x381.662994 */
+	{0x03, 0x3039}, /* index:466, gain:43.68750db -> x385.804777 */
+	{0x03, 0x30bf}, /* index:467, gain:43.78125db -> x389.991506 */
+	{0x03, 0x3147}, /* index:468, gain:43.87500db -> x394.223453 */
+	{0x03, 0x31d0}, /* index:469, gain:43.96875db -> x398.501541 */
+	{0x03, 0x325a}, /* index:470, gain:44.06250db -> x402.826055 */
+	{0x03, 0x32e6}, /* index:471, gain:44.15625db -> x407.197498 */
+	{0x03, 0x3373}, /* index:472, gain:44.25000db -> x411.616379 */
+	{0x03, 0x3402}, /* index:473, gain:44.34375db -> x416.082986 */
+	{0x03, 0x3493}, /* index:474, gain:44.43750db -> x420.598292 */
+	{0x03, 0x3525}, /* index:475, gain:44.53125db -> x425.162598 */
+	{0x03, 0x35b8}, /* index:476, gain:44.62500db -> x429.776436 */
+	{0x03, 0x364e}, /* index:477, gain:44.71875db -> x434.440343 */
+	{0x03, 0x36e4}, /* index:478, gain:44.81250db -> x439.154621 */
+	{0x03, 0x377d}, /* index:479, gain:44.90625db -> x443.920300 */
+	{0x03, 0x3817}, /* index:480, gain:45.00000db -> x448.737695 */
+	{0x03, 0x38b3}, /* index:481, gain:45.09375db -> x453.607368 */
+	{0x03, 0x3950}, /* index:482, gain:45.18750db -> x458.529887 */
+	{0x03, 0x39f0}, /* index:483, gain:45.28125db -> x463.505570 */
+	{0x03, 0x3a91}, /* index:484, gain:45.37500db -> x468.535503 */
+	{0x03, 0x3b33}, /* index:485, gain:45.46875db -> x473.620021 */
+	{0x03, 0x3bd8}, /* index:486, gain:45.56250db -> x478.759716 */
+	{0x03, 0x3c7e}, /* index:487, gain:45.65625db -> x483.955186 */
+	{0x03, 0x3d26}, /* index:488, gain:45.75000db -> x489.206769 */
+	{0x03, 0x3dd0}, /* index:489, gain:45.84375db -> x494.515610 */
+	{0x03, 0x3e7c}, /* index:490, gain:45.93750db -> x499.882062 */
+	{0x03, 0x3f29}, /* index:491, gain:46.03125db -> x505.306751 */
+	{0x03, 0x3fd9}, /* index:492, gain:46.12500db -> x510.790308 */
+};
diff --git a/drivers/vin/sensors/onsemi_ar0237/Kbuild b/drivers/vin/sensors/onsemi_ar0237/Kbuild
new file mode 100644
index 0000000..75486c3
--- /dev/null
+++ b/drivers/vin/sensors/onsemi_ar0237/Kbuild
@@ -0,0 +1,38 @@
+##
+## Filename : Kbuild
+##
+## History:
+##     2015/09/07 - [Hao Zeng] Create
+##
+## Copyright (c) 2015 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+
+EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
+EXTRA_AFLAGS		+= $(AMBARELLA_DRV_AFLAGS)
+EXTRA_LDFLAGS		+= $(AMBARELLA_DRV_LDFLAGS)
+
+obj-m := ar0237.o
+
diff --git a/drivers/vin/sensors/onsemi_ar0237/ar0237.c b/drivers/vin/sensors/onsemi_ar0237/ar0237.c
new file mode 100644
index 0000000..e3b1f09
--- /dev/null
+++ b/drivers/vin/sensors/onsemi_ar0237/ar0237.c
@@ -0,0 +1,677 @@
+/*
+ * Filename : ar0237.c
+ *
+ * History:
+ *    2015/09/07 - [Hao Zeng] Create
+ *
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/ambpriv_device.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <iav_utils.h>
+#include <vin_api.h>
+#include "ar0237.h"
+#include "ar0237_table.c"
+
+static int bus_addr = (0 << 16) | (0x20 >> 1);
+module_param(bus_addr, int, 0644);
+MODULE_PARM_DESC(bus_addr, " bus and addr: bit16~bit31: bus, bit0~bit15: addr");
+
+struct ar0237_priv {
+	void *control_data;
+	struct vindev_wdr_gp_s wdr_again_gp;
+	struct vindev_wdr_gp_s wdr_shutter_gp;
+	u32 frame_length_lines;
+	u32 line_length;
+};
+
+static int ar0237_write_reg(struct vin_device *vdev, u32 subaddr, u32 data)
+{
+	int rval;
+	struct ar0237_priv *ar0237;
+	struct i2c_client *client;
+	struct i2c_msg msgs[1];
+	u8 pbuf[4];
+
+	ar0237 = (struct ar0237_priv *)vdev->priv;
+	client = ar0237->control_data;
+
+	pbuf[0] = (subaddr & 0xff00) >> 8;
+	pbuf[1] = subaddr & 0xff;
+	pbuf[2] = (data & 0xff00) >> 8;
+	pbuf[3] = data & 0xff;
+
+	msgs[0].len = 4;
+	msgs[0].addr = client->addr;
+	if (unlikely(subaddr == AR0237_RESET_REGISTER))
+		msgs[0].flags = client->flags | I2C_M_IGNORE_NAK;
+	else
+		msgs[0].flags = client->flags;
+	msgs[0].buf = pbuf;
+
+	rval = i2c_transfer(client->adapter, msgs, 1);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x:0x%x]\n", rval, subaddr, data);
+		return rval;
+	}
+
+	return 0;
+}
+
+static int ar0237_read_reg(struct vin_device *vdev, u32 subaddr, u32 *data)
+{
+	int rval = 0;
+	struct ar0237_priv *ar0237;
+	struct i2c_client *client;
+	struct i2c_msg msgs[2];
+	u8 pbuf0[2];
+	u8 pbuf[6];
+
+	ar0237 = (struct ar0237_priv *)vdev->priv;
+	client = ar0237->control_data;
+
+	pbuf0[0] = (subaddr & 0xff00) >> 8;
+	pbuf0[1] = subaddr & 0xff;
+
+	msgs[0].len = 2;
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].buf = pbuf0;
+
+	msgs[1].addr = client->addr;
+	msgs[1].flags = client->flags | I2C_M_RD;
+	msgs[1].buf = pbuf;
+	msgs[1].len = 2;
+
+	rval = i2c_transfer(client->adapter, msgs, 2);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x]\n", rval, subaddr);
+		return rval;
+	}
+
+	*data = (pbuf[0] << 8) | pbuf[1];
+
+	return 0;
+}
+
+static int ar0237_set_vin_mode(struct vin_device *vdev, struct vin_video_format *format)
+{
+	struct vin_device_config ar0237_config;
+
+	memset(&ar0237_config, 0, sizeof (ar0237_config));
+
+	ar0237_config.interface_type = SENSOR_SERIAL_LVDS;
+	ar0237_config.sync_mode = SENSOR_SYNC_MODE_MASTER;
+
+	ar0237_config.slvds_cfg.lane_number = SENSOR_4_LANE;
+	ar0237_config.slvds_cfg.sync_code_style = SENSOR_SYNC_STYLE_HISPI;
+
+	ar0237_config.cap_win.x = format->def_start_x;
+	ar0237_config.cap_win.y = format->def_start_y;
+	ar0237_config.cap_win.width = format->def_width;
+	ar0237_config.cap_win.height = format->def_height;
+
+	ar0237_config.hdr_cfg.act_win.x = format->act_start_x;
+	ar0237_config.hdr_cfg.act_win.y = format->act_start_y;
+	ar0237_config.hdr_cfg.act_win.width = format->act_width;
+	ar0237_config.hdr_cfg.act_win.height = format->act_height;
+	ar0237_config.hdr_cfg.act_win.max_width = format->max_act_width;
+	ar0237_config.hdr_cfg.act_win.max_height = format->max_act_height;
+
+	ar0237_config.sensor_id	= GENERIC_SENSOR;
+	ar0237_config.input_format	= AMBA_VIN_INPUT_FORMAT_RGB_RAW;
+	ar0237_config.bayer_pattern	= format->bayer_pattern;
+	ar0237_config.video_format	= format->format;
+	ar0237_config.bit_resolution	= format->bits;
+
+	return ambarella_set_vin_config(vdev, &ar0237_config);
+}
+
+static void ar0237_sw_reset(struct vin_device *vdev)
+{
+	ar0237_write_reg(vdev, AR0237_RESET_REGISTER, 0x0001);/* Register RESET_REGISTER */
+	msleep(1);
+	ar0237_write_reg(vdev, AR0237_RESET_REGISTER, 0x10D8);/* Register RESET_REGISTER */
+}
+
+static int ar0237_init_device(struct vin_device *vdev)
+{
+	ar0237_sw_reset(vdev);
+	return 0;
+}
+
+static int ar0237_set_pll(struct vin_device *vdev, int pll_idx)
+{
+	struct vin_reg_16_16 *regs;
+	int i, regs_num;
+
+	regs = ar0237_pll_regs[pll_idx];
+	regs_num = ARRAY_SIZE(ar0237_pll_regs[pll_idx]);
+	for (i = 0; i < regs_num; i++)
+		ar0237_write_reg(vdev, regs[i].addr, regs[i].data);
+
+	return 0;
+}
+
+static void ar0237_start_streaming(struct vin_device *vdev)
+{
+	u32 data;
+	ar0237_read_reg(vdev, AR0237_RESET_REGISTER, &data);
+	data = (data | 0x0004);
+	ar0237_write_reg(vdev, AR0237_RESET_REGISTER, data);/* start streaming */
+}
+
+static int ar0237_update_hv_info(struct vin_device *vdev)
+{
+	struct ar0237_priv *pinfo = (struct ar0237_priv *)vdev->priv;
+
+	ar0237_read_reg(vdev, AR0237_LINE_LENGTH_PCK, &pinfo->line_length);
+	if (unlikely(!pinfo->line_length)) {
+		vin_error("line length is 0!\n");
+		return -EIO;
+	}
+
+	ar0237_read_reg(vdev, AR0237_FRAME_LENGTH_LINES, &pinfo->frame_length_lines);
+
+	return 0;
+}
+
+static int ar0237_get_line_time(struct vin_device *vdev)
+{
+	u64 h_clks;
+	struct ar0237_priv *pinfo = (struct ar0237_priv *)vdev->priv;
+
+	h_clks = (u64)pinfo->line_length * 512000000;
+	h_clks = DIV64_CLOSEST(h_clks, vdev->cur_pll->pixelclk);
+
+	vdev->cur_format->line_time = (u32)h_clks;
+
+	return 0;
+}
+
+static int ar0237_set_format(struct vin_device *vdev, struct vin_video_format *format)
+{
+	struct vin_reg_16_16 *regs;
+	int i, regs_num = 0, rval;
+	struct ar0237_priv *pinfo;
+
+	pinfo = (struct ar0237_priv *)vdev->priv;
+
+	if (format->hdr_mode == AMBA_VIDEO_LINEAR_MODE) {
+		regs = ar0237_linear_share_regs;
+		regs_num = ARRAY_SIZE(ar0237_linear_share_regs);
+		for (i = 0; i < regs_num; i++)
+			ar0237_write_reg(vdev, regs[i].addr, regs[i].data);
+
+		regs = ar0237_mode_regs[format->device_mode];
+		regs_num = ARRAY_SIZE(ar0237_mode_regs[format->device_mode]);
+		for (i = 0; i < regs_num; i++)
+			ar0237_write_reg(vdev, regs[i].addr, regs[i].data);
+		/* mapping from 0db */
+		vdev->agc_db_max = 0x2C700000;	/* 44.4375dB */
+		vdev->agc_db_min = 0x00000000;	/* 0dB */
+		vdev->agc_db_step = 0x00180000;	/* 0.09375dB */
+	} else {
+		regs = ar0237_2x_hdr_share_regs;
+		regs_num = ARRAY_SIZE(ar0237_2x_hdr_share_regs);
+		for (i = 0; i < regs_num; i++)
+			ar0237_write_reg(vdev, regs[i].addr, regs[i].data);
+		/* mapping from 0db */
+		vdev->agc_db_max = 0x1A700000;	/* 26.4375dB */
+		vdev->agc_db_min = 0x00000000;	/* 0dB */
+		vdev->agc_db_step = 0x00180000;	/* 0.09375dB */
+	}
+
+	rval = ar0237_update_hv_info(vdev);
+	if (rval < 0)
+		return rval;
+
+	ar0237_get_line_time(vdev);
+
+	/* Enable Streaming */
+	ar0237_start_streaming(vdev);
+
+	/* communiate with IAV */
+	rval = ar0237_set_vin_mode(vdev, format);
+	if (rval < 0)
+		return rval;
+
+	return 0;
+}
+
+static int ar0237_set_shutter_row(struct vin_device *vdev, u32 row)
+{
+	u64 exposure_lines;
+	u32 num_line, min_line, max_line;
+	int errCode = 0;
+	struct ar0237_priv *pinfo = (struct ar0237_priv *)vdev->priv;
+
+	num_line = row;
+
+	/* FIXME: shutter width: 1 ~ (Frame format(V) - 4) */
+	min_line = 1;
+	max_line = pinfo->frame_length_lines - 4;
+	num_line = clamp(num_line, min_line, max_line);
+
+	ar0237_write_reg(vdev, AR0237_COARSE_INTEGRATION_TIME, num_line);
+
+	exposure_lines = num_line;
+	exposure_lines = exposure_lines * (u64)pinfo->line_length * 512000000;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, vdev->cur_pll->pixelclk);
+
+	vdev->shutter_time = (u32)exposure_lines;
+	vin_debug("shutter_time:%d, row:%d\n", vdev->shutter_time, num_line);
+
+	return errCode;
+}
+
+static int ar0237_set_wdr_shutter_row_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_shutter_gp)
+{
+	struct ar0237_priv *pinfo = (struct ar0237_priv *)vdev->priv;
+	u32 t1t2_ratio, shutter_long, shutter_short;
+	u32 use_reg;
+	u64 vb_time;
+	int errCode = 0;
+
+	ar0237_read_reg(vdev, 0x3082, &t1t2_ratio);
+	use_reg = t1t2_ratio&0x0800; /* bit 11 */
+	t1t2_ratio = 1<<(((t1t2_ratio&0xC)>>2) + 2);
+
+	/* T1 */
+	shutter_long = p_shutter_gp->l;
+	/* T2 */
+	shutter_short = use_reg ? p_shutter_gp->s1 : (shutter_long/t1t2_ratio);
+
+	/* shutter limitation check */
+	if ((shutter_long + shutter_short + 2 > pinfo->frame_length_lines) ||
+		(1080 + shutter_short + 2 > pinfo->frame_length_lines)) {
+		vin_error("shutter exceeds limitation! long:%d, short:%d, V:%d, ratio:%d\n",
+			shutter_long, shutter_short, pinfo->frame_length_lines, t1t2_ratio);
+		return -EPERM;
+	}
+
+	/* T1 */
+	ar0237_write_reg(vdev, AR0237_COARSE_INTEGRATION_TIME, shutter_long);
+	if (use_reg) /* T2 */
+		ar0237_write_reg(vdev, AR0237_COARSE_INTEGRATION_TIME2, shutter_short);
+
+	memcpy(&(pinfo->wdr_shutter_gp),  p_shutter_gp, sizeof(struct vindev_wdr_gp_s));
+
+	vb_time = pinfo->frame_length_lines - vdev->cur_format->height - pinfo->wdr_shutter_gp.s1;
+	vb_time = pinfo->line_length * (u64)vb_time * 1000000000;
+	vb_time = DIV64_CLOSEST(vb_time, vdev->cur_pll->pixelclk);
+	vdev->cur_format->vb_time = vb_time;
+
+	vin_debug("shutter long:%d, short:%d, ratio:%d, vb_time:%d\n",
+		shutter_long, shutter_short, t1t2_ratio, vdev->cur_format->vb_time);
+
+	return errCode;
+}
+
+static int ar0237_get_wdr_shutter_row_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_shutter_gp)
+{
+	struct ar0237_priv *pinfo = (struct ar0237_priv *)vdev->priv;
+	memcpy(p_shutter_gp, &(pinfo->wdr_shutter_gp), sizeof(struct vindev_wdr_gp_s));
+
+	return 0;
+}
+
+static int ar0237_shutter2row(struct vin_device *vdev, u32 *shutter_time)
+{
+	u64 exposure_lines;
+	int rval = 0;
+	struct ar0237_priv *pinfo = (struct ar0237_priv *)vdev->priv;
+
+	/* for fast boot, it may call set shutter time directly, so we must read line length/frame line */
+	if (unlikely(!pinfo->line_length)) {
+		rval = ar0237_update_hv_info(vdev);
+		if (rval < 0)
+			return rval;
+
+		ar0237_get_line_time(vdev);
+	}
+
+	exposure_lines = (*shutter_time) * (u64)vdev->cur_pll->pixelclk;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, pinfo->line_length);
+	exposure_lines = DIV64_CLOSEST(exposure_lines, 512000000);
+
+	*shutter_time = exposure_lines;
+
+	return rval;
+}
+
+static int ar0237_set_fps(struct vin_device *vdev, int fps)
+{
+	u64 pixelclk, v_lines, vb_time;
+	u32 vsync_delay;
+	struct ar0237_priv *pinfo = (struct ar0237_priv *)vdev->priv;
+
+	pixelclk = vdev->cur_pll->pixelclk;
+
+	v_lines = fps * pixelclk;
+	v_lines = DIV64_CLOSEST(v_lines, pinfo->line_length);
+	v_lines = DIV64_CLOSEST(v_lines, 512000000);
+	ar0237_write_reg(vdev, AR0237_FRAME_LENGTH_LINES, v_lines);
+
+	pinfo->frame_length_lines = (u32)v_lines;
+
+	vb_time = pinfo->line_length * (u64)(v_lines - vdev->cur_format->height) * 1000000000;
+	vb_time = DIV64_CLOSEST(vb_time, pixelclk);
+	vdev->cur_format->vb_time = vb_time;
+
+	if (vdev->cur_format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {
+		/* FIXME: make T1 and T2 effective at n+2 frame after T2 sync point */
+		vsync_delay = (u32)DIV64_CLOSEST((u64)vdev->cur_format->line_time * 1000, 512);
+		vsync_delay *= (pinfo->frame_length_lines - 1080 - 20 - 8);
+		ambarella_vin_vsync_delay(vdev, vsync_delay);
+	}
+
+	return 0;
+}
+
+static int ar0237_set_agc_index(struct vin_device *vdev, int agc_idx)
+{
+	if (agc_idx > AR0237_GAIN_48DB) {
+		vin_error("agc index %d exceeds maximum %d\n", agc_idx, AR0237_GAIN_48DB);
+		return -EINVAL;
+	}
+
+	ar0237_write_reg(vdev, AR0237_AGAIN, AR0237_GAIN_TABLE[agc_idx][AR0237_GAIN_COL_AGAIN]);
+	ar0237_write_reg(vdev, AR0237_DGAIN, AR0237_GAIN_TABLE[agc_idx][AR0237_GAIN_COL_DGAIN]);
+	ar0237_write_reg(vdev, AR0237_DCG_CTL, AR0237_GAIN_TABLE[agc_idx][AR0237_GAIN_COL_DCG]);
+
+	return 0;
+}
+
+static int ar0237_set_wdr_again_idx_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_again_gp)
+{
+	struct ar0237_priv *pinfo = (struct ar0237_priv *)vdev->priv;
+	int gain_index;
+
+	gain_index = p_again_gp->l;
+
+	ar0237_write_reg(vdev, AR0237_AGAIN, AR0237_HDR_GAIN_TABLE[gain_index][AR0237_GAIN_COL_AGAIN]);
+	ar0237_write_reg(vdev, AR0237_DGAIN, AR0237_HDR_GAIN_TABLE[gain_index][AR0237_GAIN_COL_DGAIN]);
+	ar0237_write_reg(vdev, AR0237_DCG_CTL, AR0237_HDR_GAIN_TABLE[gain_index][AR0237_GAIN_COL_DCG]);
+
+	memcpy(&(pinfo->wdr_again_gp), p_again_gp, sizeof(struct vindev_wdr_gp_s));
+	vin_debug("hdr again index:%d\n", p_again_gp->l);
+	return 0;
+}
+
+static int ar0237_get_wdr_again_idx_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_again_gp)
+{
+	struct ar0237_priv *pinfo = (struct ar0237_priv *)vdev->priv;
+
+	memcpy(p_again_gp, &(pinfo->wdr_again_gp), sizeof(struct vindev_wdr_gp_s));
+	return 0;
+}
+
+static int ar0237_set_wdr_dgain_idx_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_dgain_gp)
+{
+	return 0;
+}
+
+static int ar0237_get_wdr_dgain_idx_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_dgain_gp)
+{
+	return 0;
+}
+
+static int ar0237_wdr_shutter2row(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_shutter2row)
+{
+	return ar0237_shutter2row(vdev, &p_shutter2row->l);
+}
+
+static int ar0237_set_mirror_mode(struct vin_device *vdev,
+		struct vindev_mirror *mirror_mode)
+{
+	u32 tmp_reg, readmode, bayer_pattern;
+
+	switch (mirror_mode->pattern) {
+	case VINDEV_MIRROR_AUTO:
+		return 0;
+
+	case VINDEV_MIRROR_HORRIZONTALLY_VERTICALLY:
+		readmode = AR0237_H_MIRROR + AR0237_V_FLIP;
+		bayer_pattern = VINDEV_BAYER_PATTERN_GR;
+		break;
+
+	case VINDEV_MIRROR_HORRIZONTALLY:
+		readmode = AR0237_H_MIRROR;
+		bayer_pattern = VINDEV_BAYER_PATTERN_GR;
+		break;
+
+	case VINDEV_MIRROR_VERTICALLY:
+		readmode = AR0237_V_FLIP;
+		bayer_pattern = VINDEV_BAYER_PATTERN_GR;
+		break;
+
+	case VINDEV_MIRROR_NONE:
+		readmode = 0;
+		bayer_pattern = VINDEV_BAYER_PATTERN_GR;
+		break;
+
+	default:
+		vin_error("do not support cmd mirror mode\n");
+		return -EINVAL;
+	}
+
+	ar0237_read_reg(vdev, AR0237_READ_MODE, &tmp_reg);
+	tmp_reg &= (~AR0237_MIRROR_MASK);
+	tmp_reg |= readmode;
+	ar0237_write_reg(vdev, AR0237_READ_MODE, tmp_reg);
+
+	if (mirror_mode->bayer_pattern == VINDEV_BAYER_PATTERN_AUTO)
+		mirror_mode->bayer_pattern = bayer_pattern;
+
+	return 0;
+}
+
+static int ar0237_get_aaa_info(struct vin_device *vdev,
+	struct vindev_aaa_info *aaa_info)
+{
+	struct ar0237_priv *pinfo = (struct ar0237_priv *)vdev->priv;
+
+	aaa_info->sht0_max = pinfo->frame_length_lines - 4;
+	aaa_info->sht1_max = pinfo->frame_length_lines - vdev->cur_format->height - 2;
+	aaa_info->sht2_max = 0;
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int ar0237_suspend(struct vin_device *vdev)
+{
+	u32 i, tmp;
+
+	for (i = 0; i < ARRAY_SIZE(pm_regs); i++) {
+		ar0237_read_reg(vdev, pm_regs[i].addr, &tmp);
+		pm_regs[i].data = (u16)tmp;
+	}
+
+	return 0;
+}
+
+static int ar0237_resume(struct vin_device *vdev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(pm_regs); i++) {
+		ar0237_write_reg(vdev, pm_regs[i].addr, pm_regs[i].data);
+	}
+
+	return 0;
+}
+#endif
+
+static struct vin_ops ar0237_ops = {
+	.init_device		= ar0237_init_device,
+	.set_pll			= ar0237_set_pll,
+	.set_format		= ar0237_set_format,
+	.set_shutter_row	= ar0237_set_shutter_row,
+	.shutter2row		= ar0237_shutter2row,
+	.set_frame_rate	= ar0237_set_fps,
+	.set_agc_index		= ar0237_set_agc_index,
+	.set_mirror_mode	= ar0237_set_mirror_mode,
+	.get_aaa_info		= ar0237_get_aaa_info,
+	.read_reg			= ar0237_read_reg,
+	.write_reg		= ar0237_write_reg,
+#ifdef CONFIG_PM
+	.suspend		= ar0237_suspend,
+	.resume 		= ar0237_resume,
+#endif
+
+	/* for wdr sensor */
+	.set_wdr_again_idx_gp = ar0237_set_wdr_again_idx_group,
+	.get_wdr_again_idx_gp = ar0237_get_wdr_again_idx_group,
+	.set_wdr_dgain_idx_gp = ar0237_set_wdr_dgain_idx_group,
+	.get_wdr_dgain_idx_gp = ar0237_get_wdr_dgain_idx_group,
+	.set_wdr_shutter_row_gp = ar0237_set_wdr_shutter_row_group,
+	.get_wdr_shutter_row_gp = ar0237_get_wdr_shutter_row_group,
+	.wdr_shutter2row = ar0237_wdr_shutter2row,
+};
+
+/* ========================================================================== */
+static int ar0237_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	int rval = 0;
+	struct vin_device *vdev;
+	struct ar0237_priv *ar0237;
+	u32 version;
+
+	vdev = ambarella_vin_create_device(client->name,
+			SENSOR_AR0237, sizeof(struct ar0237_priv));
+	if (!vdev)
+		return -ENOMEM;
+
+	vdev->intf_id = 0;
+	vdev->dev_type = VINDEV_TYPE_SENSOR;
+	vdev->sub_type = VINDEV_SUBTYPE_CMOS;
+	vdev->default_mode = AMBA_VIDEO_MODE_1080P;
+	vdev->default_hdr_mode = AMBA_VIDEO_LINEAR_MODE;
+	vdev->agc_db_max = 0x2C700000; /* 44.4375dB */
+	vdev->agc_db_min = 0x00000000; /* 0dB */
+	vdev->agc_db_step = 0x00180000;/* 0.09375dB */
+	vdev->wdr_again_idx_min = 0;
+	vdev->wdr_again_idx_max = AR0237_GAIN_48DB;
+
+	/* mode switch needs hw reset */
+	vdev->reset_for_mode_switch = true;
+
+	i2c_set_clientdata(client, vdev);
+
+	ar0237 = (struct ar0237_priv *)vdev->priv;
+	ar0237->control_data = client;
+
+	rval = ambarella_vin_register_device(vdev, &ar0237_ops,
+			ar0237_formats, ARRAY_SIZE(ar0237_formats),
+			ar0237_plls, ARRAY_SIZE(ar0237_plls));
+	if (rval < 0)
+		goto ar0237_probe_err;
+
+	/* query sensor id */
+	ar0237_read_reg(vdev, AR0237_CHIP_VERSION_REG, &version);
+	vin_info("AR0237 init(4-lane HISPI), sensor ID: 0x%x\n", version);
+
+	return 0;
+
+ar0237_probe_err:
+	ambarella_vin_free_device(vdev);
+	return rval;
+}
+
+static int ar0237_remove(struct i2c_client *client)
+{
+	struct vin_device *vdev;
+
+	vdev = (struct vin_device *)i2c_get_clientdata(client);
+	ambarella_vin_unregister_device(vdev);
+	ambarella_vin_free_device(vdev);
+
+	return 0;
+}
+
+static const struct i2c_device_id ar0237_idtable[] = {
+	{ "ar0237", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ar0237_idtable);
+
+static struct i2c_driver i2c_driver_ar0237 = {
+	.driver = {
+		.name	= "ar0237",
+	},
+
+	.id_table	= ar0237_idtable,
+	.probe		= ar0237_probe,
+	.remove		= ar0237_remove,
+
+};
+
+static int __init ar0237_init(void)
+{
+	int bus, addr, rval;
+
+	bus = bus_addr >> 16;
+	addr = bus_addr & 0xffff;
+
+	rval = ambpriv_i2c_update_addr("ar0237", bus, addr);
+	if (rval < 0)
+		return rval;
+
+	rval = i2c_add_driver(&i2c_driver_ar0237);
+	if (rval < 0)
+		return rval;
+
+	return 0;
+}
+
+static void __exit ar0237_exit(void)
+{
+	i2c_del_driver(&i2c_driver_ar0237);
+}
+
+module_init(ar0237_init);
+module_exit(ar0237_exit);
+
+MODULE_DESCRIPTION("AR0237 1/2.7 -Inch, 1928x1088, 2.1-Megapixel CMOS Digital Image Sensor");
+MODULE_AUTHOR("Hao Zeng, <haozeng@ambarella.com>");
+MODULE_LICENSE("Proprietary");
+
diff --git a/drivers/vin/sensors/onsemi_ar0237/ar0237.h b/drivers/vin/sensors/onsemi_ar0237/ar0237.h
new file mode 100644
index 0000000..2497429
--- /dev/null
+++ b/drivers/vin/sensors/onsemi_ar0237/ar0237.h
@@ -0,0 +1,60 @@
+/*
+ * Filename : ar0237.h
+ *
+ * History:
+ *    2015/09/07 - [Hao Zeng] Create
+ *
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __AR0237_PRI_H__
+#define __AR0237_PRI_H__
+
+#define AR0237_RESET_REGISTER				0x301A
+#define AR0237_LINE_LENGTH_PCK			0x300C
+#define AR0237_FRAME_LENGTH_LINES			0x300A
+
+#define AR0237_CHIP_VERSION_REG			0x3000
+#define AR0237_COARSE_INTEGRATION_TIME	0x3012
+#define AR0237_COARSE_INTEGRATION_TIME2	0x3212
+
+#define AR0237_VT_PIX_CLK_DIV				0x302A
+#define AR0237_VT_SYS_CLK_DIV				0x302C
+#define AR0237_PRE_PLL_CLK_DIV				0x302E
+#define AR0237_PLL_MULTIPLIER				0x3030
+
+#define AR0237_DGAIN						0x305E
+#define AR0237_AGAIN						0x3060
+#define AR0237_DCG_CTL						0x3100
+
+/* AR0237 mirror mode */
+#define AR0237_READ_MODE				0x3040
+#define AR0237_H_MIRROR			(0x01 << 14)
+#define AR0237_V_FLIP				(0x01 << 15)
+#define AR0237_MIRROR_MASK			(AR0237_H_MIRROR + AR0237_V_FLIP)
+
+#endif /* __AR0237_PRI_H__ */
diff --git a/drivers/vin/sensors/onsemi_ar0237/ar0237_table.c b/drivers/vin/sensors/onsemi_ar0237/ar0237_table.c
new file mode 100644
index 0000000..c1146b9
--- /dev/null
+++ b/drivers/vin/sensors/onsemi_ar0237/ar0237_table.c
@@ -0,0 +1,1778 @@
+/*
+ * Filename : ar0237_table.c
+ *
+ * History:
+ *    2015/09/07 - [Hao Zeng] Create
+ *
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+static struct vin_reg_16_16 ar0237_pll_regs[][6] = {
+	{
+		{0x302A, 0x0006}, /* VT_PIX_CLK_DIV  */
+		{0x302C, 0x0001}, /* VT_SYS_CLK_DIV  */
+		{0x302E, 0x0004}, /* PRE_PLL_CLK_DIV */
+		{0x3030, 0x0042}, /* PLL_MULTIPLIER  */
+		{0x3036, 0x000C}, /* OP_PIX_CLK_DIV  */
+		{0x3038, 0x0001}, /* OP_SYS_CLK_DIV  */
+	},
+};
+
+static struct vin_video_pll ar0237_plls[] = {
+	{0, 27000000, 74250000},
+};
+
+static struct vin_reg_16_16 ar0237_mode_regs[][9] = {
+	{	 /* 1920x1080 */
+		{0x3002, 0x0004}, /* Y_ADDR_START */
+		{0x3004, 0x000c}, /* X_ADDR_START */
+		{0x3006, 0x043b}, /* Y_ADDR_END */
+		{0x3008, 0x078b}, /* X_ADDR_END(0x0787) */
+		{0x300A, 0x0452}, /* FRAME_LENGTH_LINES */
+		{0x300C, 0x045E}, /* LINE_LENGTH_PCK */
+		{0x30A2, 0x0001}, /* X_ODD_INC */
+		{0x30A6, 0x0001}, /* Y_ODD_INC */
+		{0x3040, 0x0000}, /* READ_MODE */
+	},
+	{	/* 1280x720 */
+		{0x3002, 0x00B8}, /* Y_ADDR_START */
+		{0x3004, 0x014C}, /* X_ADDR_START */
+		{0x3006, 0x0387}, /* Y_ADDR_END */
+		{0x3008, 0x064B}, /* X_ADDR_END */
+		{0x300A, 0x044A}, /* FRAME_LENGTH_LINES */
+		{0x300C, 0x0467}, /* LINE_LENGTH_PCK */
+		{0x30A2, 0x0001}, /* X_ODD_INC */
+		{0x30A6, 0x0001}, /* Y_ODD_INC */
+		{0x3040, 0x0000}, /* READ_MODE */
+	},
+	{	/* 640x480 */
+		{0x3002, 0x0040}, /* Y_ADDR_START */
+		{0x3004, 0x014C}, /* X_ADDR_START */
+		{0x3006, 0x03FF}, /* Y_ADDR_END */
+		{0x3008, 0x064B}, /* X_ADDR_END */
+		{0x300A, 0x03D2}, /* FRAME_LENGTH_LINES */
+		{0x300C, 0x034B}, /* LINE_LENGTH_PCK */
+		{0x30A2, 0x0003}, /* X_ODD_INC */
+		{0x30A6, 0x0003}, /* Y_ODD_INC */
+		{0x3040, 0x3000}, /* READ_MODE */
+	},
+};
+
+static struct vin_video_format ar0237_formats[] = {
+	{
+		.video_mode	= AMBA_VIDEO_MODE_1080P,
+		.def_start_x	= 0,
+		.def_start_y	= 0,
+		.def_width	= 1920,
+		.def_height	= 1080,
+		.act_start_x	= 0,
+		.act_start_y	= 0,
+		.act_width	= 1920,
+		.act_height	= 1080,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_LINEAR_MODE,
+		.device_mode	= 0,
+		.pll_idx	= 0,
+		.width		= 1920,
+		.height		= 1080,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_60,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_GR,
+	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_720P,
+		.def_start_x	= 0,
+		.def_start_y	= 0,
+		.def_width	= 1280,
+		.def_height	= 720,
+		.act_start_x	= 0,
+		.act_start_y	= 0,
+		.act_width	= 1280,
+		.act_height	= 720,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_LINEAR_MODE,
+		.device_mode	= 1,
+		.pll_idx	= 0,
+		.width		= 1280,
+		.height		= 720,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_60,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_GR,
+	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_VGA,
+		.def_start_x	= 0,
+		.def_start_y	= 0,
+		.def_width	= 640,
+		.def_height	= 480,
+		.act_start_x	= 0,
+		.act_start_y	= 0,
+		.act_width	= 640,
+		.act_height	= 480,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_LINEAR_MODE,
+		.device_mode	= 2,
+		.pll_idx	= 0,
+		.width		= 1920,
+		.height		= 1080,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_4_3,
+		.max_fps	= AMBA_VIDEO_FPS(90),
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_GR,
+	},
+	{	/* 2x hdr mode */
+		.video_mode	= AMBA_VIDEO_MODE_1080P,
+		.def_start_x	= 0,
+		.def_start_y	= 0,
+		.def_width	= 1920,
+		.def_height	= (1080 + 134 + 2) * 2,/* (1080+max T2+2) * 2 */
+		.act_start_x	= 0,
+		.act_start_y	= 0,
+		.act_width	= 1920,
+		.act_height	= 1080,
+		.max_act_width = 1920,
+		.max_act_height = 1080,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_2X_HDR_MODE,
+		.device_mode	= 3,
+		.pll_idx	= 0,
+		.width		= 1920,
+		.height		= 1080,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_GR,
+	},
+};
+
+static struct vin_reg_16_16 ar0237_linear_share_regs[] = {
+	/* V1.3-1080p60fps */
+	{0x3088, 0x8242}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4558}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x729B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4A31}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4342}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8E03}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2A14}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4578}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x7B3D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xFF3D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xFF3D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xEA2A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x043D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x102A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x052A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1535}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2A05}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3D10}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4558}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2A04}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2A14}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3DFF}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3DFF}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3DEA}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2A04}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x622A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x288E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0036}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2A08}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3D64}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x7A3D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0444}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2C4B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8F03}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x430D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2D46}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4316}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x5F16}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x530D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1660}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3E4C}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2904}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2984}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8E03}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2AFC}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x5C1D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x5754}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x495F}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x5305}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x5307}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4D2B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xF810}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x164C}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0955}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x562B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xB82B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x984E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1129}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x9460}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x5C19}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x5C1B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4548}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4508}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4588}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x29B6}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8E01}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2AF8}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3E02}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2AFA}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3F09}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x5C1B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x29B2}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3F0C}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3E03}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3E15}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x5C13}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3F11}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3E0F}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x5F2B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x902A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xF22B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x803E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x063F}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0660}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x29A2}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x29A3}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x5F4D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1C2A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xFA29}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8345}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xA83E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x072A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xFB3E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2945}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8824}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3E08}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2AFA}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x5D29}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x9288}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x102B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x048B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1686}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8D48}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4D4E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2B80}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4C0B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x603F}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x302A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xF23F}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1029}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8229}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8329}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x435C}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x155F}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4D1C}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2AFA}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4558}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8E00}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2A98}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3F0A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4A0A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4316}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0B43}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x168E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x032A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x9C45}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x783F}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x072A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x9D3E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x305D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2944}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8810}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2B04}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x530D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4558}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3E08}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8E01}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2A98}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8E00}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x769C}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x779C}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4644}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1616}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x907A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1244}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4B18}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4A04}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4316}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0643}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1605}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4316}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0743}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1658}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4316}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x5A43}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1645}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x588E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x032A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x9C45}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x787B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3F07}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2A9D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x530D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8B16}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x863E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2345}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x5825}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3E10}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8E01}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2A98}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8E00}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3E10}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8D60}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1244}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4B2C}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2C2C}, /* SEQ_CTRL_PORT */
+
+	{0x2412, 0x002D}, /* ALTM_POWER_OFFSET */
+	{0x2410, 0x0005}, /* ALTM_POWER_GAIN */
+
+	{0x3ED6, 0x2CB3}, /* DAC_LD_10_11 */
+	{0x2436, 0x000E}, /* ALTM_CONTROL_AVERAGED_LUMA_NOISE_FLOOR */
+	{0x320C, 0x0180}, /* ADACD_GAIN_THRESHOLD_0 */
+	{0x320E, 0x0300}, /* ADACD_GAIN_THRESHOLD_1 */
+	{0x3210, 0x0500}, /* ADACD_GAIN_THRESHOLD_2 */
+	{0x3204, 0x0B6D}, /* ADACD_NOISE_MODEL2 */
+	{0x30FE, 0x0080}, /* NOISE_PEDESTAL */
+	{0x3ED8, 0x7B99}, /* DAC_LD_12_13 */
+	{0x3EDC, 0x9BA8}, /* DAC_LD_16_17 */
+	{0x3EDA, 0x9B9B}, /* DAC_LD_14_15 */
+	{0x3092, 0x006F}, /* ROW_NOISE_CONTROL */
+	{0x3EEC, 0x1C04}, /* DAC_LD_32_33 */
+	{0x30BA, 0x779C}, /* DIGITAL_CTRL */
+	{0x3EF6, 0xA70F}, /* DAC_LD_42_43 */
+	{0x3044, 0x0410}, /* DARK_CONTROL */
+	{0x3ED0, 0xFF44}, /* DAC_LD_4_5 */
+	{0x3ED4, 0x031F}, /* DAC_LD_8_9 */
+	{0x30FE, 0x0080}, /* NOISE_PEDESTAL */
+	{0x3EE2, 0x8866}, /* DAC_LD_22_23 */
+	{0x3EE4, 0x6623}, /* DAC_LD_24_25 */
+	{0x3EE6, 0x2263}, /* DAC_LD_26_27 */
+	{0x30E0, 0x4283}, /* ADC_COMMAND1 */
+	{0x30F0, 0x1283}, /* ADC_COMMAND1_HS */
+	{0x301A, 0x0058}, /* RESET_REGISTER */
+	{0x30B0, 0x0118}, /* DIGITAL_TEST */
+	{0x31AC, 0x0C0C}, /* DATA_FORMAT_BITS */
+
+	/* size */
+	{0x3002, 0x0004}, /* Y_ADDR_START */
+	{0x3004, 0x000c}, /* X_ADDR_START */
+	{0x3006, 0x043b}, /* Y_ADDR_END */
+	{0x3008, 0x078b}, /* X_ADDR_END(0x0787) */
+	{0x300A, 0x0452}, /* FRAME_LENGTH_LINES */
+	{0x300C, 0x045E}, /* LINE_LENGTH_PCK */
+
+	{0x3012, 0x0416}, /* COARSE_INTEGRATION_TIME */
+	{0x30A2, 0x0001}, /* X_ODD_INC */
+	{0x30A6, 0x0001}, /* Y_ODD_INC */
+	{0x30AE, 0x0001}, /* X_ODD_INC_CB */
+	{0x30A8, 0x0001}, /* Y_ODD_INC_CB */
+	{0x3040, 0x0000}, /* READ_MODE */
+	{0x3082, 0x0009}, /* OPERATION_MODE_CTRL */
+	{0x30BA, 0x769C}, /* DIGITAL_CTRL */
+	{0x31E0, 0x0200}, /* PIX_DEF_ID */
+	{0x318C, 0x0000}, /* HDR_MC_CTRL2 */
+	{0x3060, 0x000B}, /* ANALOG_GAIN */
+	{0x3096, 0x0080}, /* ROW_NOISE_ADJUST_TOP */
+	{0x3098, 0x0080}, /* ROW_NOISE_ADJUST_BTM */
+	{0x3206, 0x0B08}, /* ADACD_NOISE_FLOOR1 */
+	{0x3208, 0x1E13}, /* ADACD_NOISE_FLOOR2 */
+	{0x3202, 0x0080}, /* ADACD_NOISE_MODEL1 */
+	{0x3200, 0x0000}, /* ADACD_CONTROL */
+	{0x3100, 0x0000}, /* AECTRLREG */
+	//{0x3200, 0x0002}, /* ADACD_CONTROL */
+	{0x31D0, 0x0000}, /* COMPANDING */
+	{0x2400, 0x0003}, /* ALTM_CONTROL */
+	{0x301E, 0x00A8}, /* DATA_PEDESTAL */
+	{0x2450, 0x0000}, /* ALTM_OUT_PEDESTAL */
+	{0x320A, 0x0080}, /* ADACD_PEDESTAL */
+	{0x3064, 0x1802}, /* SMIA_TEST */
+	{0x31AE, 0x0304}, /* SERIAL_FORMAT */
+	{0x31C6, 0x8002}, /* HISPI_CONTROL_STATUS, for ambarella, MSB first */
+	{0x306E, 0x9010}, /* DATAPATH_SELECT */
+	{0x301A, 0x005C}, /* RESET_REGISTER */
+};
+
+static struct vin_reg_16_16 ar0237_2x_hdr_share_regs[] = {
+	/* interleave-HDR 1080P@30FPS */
+	{0x3088, 0x816A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4558}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x729B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4A31}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4342}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8E03}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2A14}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4578}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x7B3D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xFF3D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xFF3D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xEA2A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x043D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x102A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x052A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1535}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2A05}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3D10}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4558}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2A04}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2A14}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3DFF}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3DFF}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3DEA}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2A04}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x622A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x288E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0036}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2A08}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3D64}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x7A3D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0444}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2C4B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8F00}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x430C}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2D63}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4316}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2A90}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3E06}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2A98}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x168E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x032A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xFC5C}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1D57}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x5449}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x5F53}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0553}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x074D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2BF8}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1016}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4C08}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x5556}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2BB8}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2B98}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4E11}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2904}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2984}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2994}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x605C}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x195C}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1B45}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4845}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0845}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8829}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xB68E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x012A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xF83E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x022A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xFA3F}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x095C}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1B29}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xB23F}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0C3E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x023E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x135C}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x133F}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x113E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0B5F}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2B90}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2B80}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3E06}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x162A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xF23F}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x103E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0160}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x29A2}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x29A3}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x5F4D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x192A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xFA29}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8345}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xA83E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x072A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xFB3E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2945}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8821}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3E08}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2AFA}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x5D29}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x9288}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x102B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x048B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1685}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8D48}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4D4E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2B80}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4C0B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3F2B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2AF2}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3F10}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3E01}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x6029}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8229}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8329}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x435C}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x155F}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4D19}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2AFA}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4558}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8E00}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2A98}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3F06}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1244}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4A04}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4316}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0543}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1658}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4316}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x5A43}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1606}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4316}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0743}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x168E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x032A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x9C45}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x787B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3F07}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2A9D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3E2E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4558}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x253E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x068E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x012A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x988E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0012}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x444B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0343}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2D46}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4316}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xA343}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x165D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0D29}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4488}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x102B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0453}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0D8B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1685}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x448E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x032A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xFC5C}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1D8D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x6057}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x5417}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xFF17}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4B2A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xF43E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x062A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xFC49}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x5F53}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0553}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x074D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2BF8}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1016}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4C08}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x5556}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2BB8}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2B98}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4E11}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2904}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2984}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2994}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x605C}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x195C}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1B45}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4845}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0845}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8829}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xB68E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x012A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xF83E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x022A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xFA3F}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x095C}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1B29}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xB23F}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0C3E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x023E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x135C}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x133F}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x113E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0B5F}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2B90}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2B80}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3E10}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2AF2}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3F10}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3E01}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x6029}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xA229}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xA35F}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4D1C}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2AFA}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2983}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x45A8}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3E07}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2AFB}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3E29}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4588}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x243E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x082A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xFA5D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2992}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8810}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2B04}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8B16}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x868D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x484D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4E2B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x804C}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0B3F}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x332A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xF23F}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x103E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0160}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2982}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2983}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2943}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x5C15}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x5F4D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1C2A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xFA45}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x588E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x002A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x983F}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x064A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x739D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0A43}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x160B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4316}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8E03}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2A9C}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4578}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3F07}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2A9D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3E12}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4558}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3F04}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8E01}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2A98}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x8E00}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x9176}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x9C77}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x9C46}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4416}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1690}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x7A12}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x444B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4A00}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4316}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x6343}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1608}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4316}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x5043}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1665}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4316}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x6643}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x168E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x032A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x9C45}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x783F}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x072A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x9D5D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0C29}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4488}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x102B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0453}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x0D8B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x1686}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x3E1F}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4558}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x283E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x068E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x012A}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x988E}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x008D}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x6012}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x444B}, /* SEQ_CTRL_PORT */
+	{0x3086, 0xB92C}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x2C2C}, /* SEQ_DATA_PORT */
+
+	{0x30F0, 0x1283}, /* ADC_COMMAND1_HS */
+	{0x3064, 0x1802}, /* SMIA_TEST */
+	{0x3EEE, 0xA0AA}, /* DAC_LD_34_35 */
+	{0x30BA, 0x762C}, /* DIGITAL_CTRL */
+	{0x3F4A, 0x0F70},
+	{0x309E, 0x016C}, /* ERS_PROG_START_ADDR */
+	{0x3EE4, 0x9937},
+	{0x3EE6, 0x3863},
+	{0x3EEC, 0x3B0C},
+	{0x3EEA, 0x2838},
+	{0x3ECC, 0x4E2D},
+	{0x3ED2, 0xFEA6},
+	{0x3ED6, 0x2CB3},
+	{0x3EEA, 0x2819},
+
+	{0x3096, 0xF880}, /* ROW_NOISE_ADJUST_TOP */
+	{0x3F32, 0xF880}, /* ROW_NOISE_ADJUST_TOP_T1 */
+	{0x3092, 0x006F}, /* ROW_NOISE_CONTROL */
+	{0x301A, 0x0058}, /* RESET_REGISTER */
+	{0x30B0, 0x0938}, /* DIGITAL_TEST, generate continuous LINE_VALIDs, fix T2 6row issue */
+	{0x31AC, 0x100C}, /* DATA_FORMAT_BITS */
+
+	{0x302A, 0x0006}, /* VT_PIX_CLK_DIV */
+	{0x302C, 0x0001}, /* VT_SYS_CLK_DIV */
+	{0x302E, 0x0004}, /* PRE_PLL_CLK_DIV */
+	{0x3030, 0x0042}, /* PLL_MULTIPLIER */
+	{0x3036, 0x000C}, /* OP_PIX_CLK_DIV */
+	{0x3038, 0x0001}, /* OP_SYS_CLK_DIV */
+
+	{0x3002, 0x0004}, /* Y_ADDR_START */
+	{0x3004, 0x000c}, /* X_ADDR_START */
+	{0x3006, 0x043b}, /* Y_ADDR_END */
+	{0x3008, 0x078b}, /* X_ADDR_END(0x0787) */
+	{0x300A, 0x04C0}, /* FRAME_LENGTH_LINES(1216) */
+	{0x300C, 0x07F4}, /* LINE_LENGTH_PCK(2036) */
+	{0x3012, 0x0103}, /* COARSE_INTEGRATION_TIME */
+	{0x30A2, 0x0001}, /* X_ODD_INC */
+	{0x30A6, 0x0001}, /* Y_ODD_INC */
+	{0x30AE, 0x0001}, /* X_ODD_INC_CB */
+	{0x30A8, 0x0001}, /* Y_ODD_INC_CB */
+
+	{0x3040, 0x0000}, /* READ_MODE */
+	{0x3082, 0x0808}, /* HDR 16x; 0: 4x; 4: 8x; 8: 16x; C: 32x, use_reg for T2 */
+	{0x3060, 0x000B}, /* ANALOG_GAIN */
+	{0x3100, 0x0000}, /* AECTRLREG */
+	{0x30BA, 0x772C}, /* DIGITAL_CTRL */
+	{0x3064, 0x1982}, /* SMIA_TEST */
+	{0x31AE, 0x0304}, /* SERIAL_FORMAT */
+	{0x31C6, 0x8002}, /* HiSpi Steraming-S, 0x0402:HiSpi protocol Packetized-SP; MSB output */
+	{0x306E, 0x9010}, /* DATAPATH_SELECT */
+	{0x3064, 0x1802}, /* SMIA_TEST */
+	{0x318E, 0x1000}, /* HDR_MC_CTRL3 */
+	{0x31D0, 0x0000}, /* COMPANDING */
+	{0x301A, 0x005C}, /* RESET_REGISTER */
+};
+
+#ifdef CONFIG_PM
+static struct vin_reg_16_16 pm_regs[] = {
+	{AR0237_COARSE_INTEGRATION_TIME, 0x0000},
+	{AR0237_COARSE_INTEGRATION_TIME2, 0x0000},
+	{AR0237_AGAIN, 0x0000},
+	{AR0237_DGAIN, 0x0000},
+	{AR0237_DCG_CTL, 0x0000},
+};
+#endif
+
+/** AR0237 global gain table row size */
+#define AR0237_GAIN_ROWS		475
+#define AR0237_GAIN_COLS 		3
+
+#define AR0237_GAIN_48DB		474
+#define AR0237_GAIN_DCG_ON	54
+
+#define AR0237_GAIN_COL_AGAIN		0
+#define AR0237_GAIN_COL_DGAIN		1
+#define AR0237_GAIN_COL_DCG		2
+
+const u16 AR0237_GAIN_TABLE[AR0237_GAIN_ROWS][AR0237_GAIN_COLS] = {
+	/* analog gain 1.52x~43.2x, and if gain >=2.7, turn on DCG */
+	{0x000b, 0x0080, 0x0000}, /* index: 0, gain:3.636900db->x1.520005, DCG:0 */
+	{0x000b, 0x0081, 0x0000}, /* index: 1, gain:3.730650db->x1.536500, DCG:0 */
+	{0x000b, 0x0082, 0x0000}, /* index: 2, gain:3.824400db->x1.553174, DCG:0 */
+	{0x000b, 0x0084, 0x0000}, /* index: 3, gain:3.918150db->x1.570028, DCG:0 */
+	{0x000b, 0x0085, 0x0000}, /* index: 4, gain:4.011900db->x1.587066, DCG:0 */
+	{0x000c, 0x0080, 0x0000}, /* index: 5, gain:4.105650db->x1.604289, DCG:0 */
+	{0x000c, 0x0081, 0x0000}, /* index: 6, gain:4.199400db->x1.621698, DCG:0 */
+	{0x000c, 0x0083, 0x0000}, /* index: 7, gain:4.293150db->x1.639296, DCG:0 */
+	{0x000c, 0x0084, 0x0000}, /* index: 8, gain:4.386900db->x1.657086, DCG:0 */
+	{0x000c, 0x0086, 0x0000}, /* index: 9, gain:4.480650db->x1.675068, DCG:0 */
+	{0x000d, 0x0081, 0x0000}, /* index: 10, gain:4.574400db->x1.693246, DCG:0 */
+	{0x000d, 0x0082, 0x0000}, /* index: 11, gain:4.668150db->x1.711621, DCG:0 */
+	{0x000d, 0x0083, 0x0000}, /* index: 12, gain:4.761900db->x1.730195, DCG:0 */
+	{0x000d, 0x0085, 0x0000}, /* index: 13, gain:4.855650db->x1.748971, DCG:0 */
+	{0x000d, 0x0086, 0x0000}, /* index: 14, gain:4.949400db->x1.767950, DCG:0 */
+	{0x000e, 0x0080, 0x0000}, /* index: 15, gain:5.043150db->x1.787136, DCG:0 */
+	{0x000e, 0x0081, 0x0000}, /* index: 16, gain:5.136900db->x1.806529, DCG:0 */
+	{0x000e, 0x0083, 0x0000}, /* index: 17, gain:5.230650db->x1.826133, DCG:0 */
+	{0x000e, 0x0084, 0x0000}, /* index: 18, gain:5.324400db->x1.845950, DCG:0 */
+	{0x000e, 0x0086, 0x0000}, /* index: 19, gain:5.418150db->x1.865982, DCG:0 */
+	{0x000f, 0x0080, 0x0000}, /* index: 20, gain:5.511900db->x1.886232, DCG:0 */
+	{0x000f, 0x0081, 0x0000}, /* index: 21, gain:5.605650db->x1.906701, DCG:0 */
+	{0x000f, 0x0083, 0x0000}, /* index: 22, gain:5.699400db->x1.927392, DCG:0 */
+	{0x000f, 0x0084, 0x0000}, /* index: 23, gain:5.793150db->x1.948307, DCG:0 */
+	{0x000f, 0x0086, 0x0000}, /* index: 24, gain:5.886900db->x1.969450, DCG:0 */
+	{0x000f, 0x0087, 0x0000}, /* index: 25, gain:5.980650db->x1.990822, DCG:0 */
+	{0x0010, 0x0080, 0x0000}, /* index: 26, gain:6.074400db->x2.012426, DCG:0 */
+	{0x0010, 0x0082, 0x0000}, /* index: 27, gain:6.168150db->x2.034265, DCG:0 */
+	{0x0010, 0x0083, 0x0000}, /* index: 28, gain:6.261900db->x2.056340, DCG:0 */
+	{0x0011, 0x0081, 0x0000}, /* index: 29, gain:6.355650db->x2.078655, DCG:0 */
+	{0x0011, 0x0082, 0x0000}, /* index: 30, gain:6.449400db->x2.101213, DCG:0 */
+	{0x0011, 0x0083, 0x0000}, /* index: 31, gain:6.543150db->x2.124015, DCG:0 */
+	{0x0012, 0x0080, 0x0000}, /* index: 32, gain:6.636900db->x2.147064, DCG:0 */
+	{0x0012, 0x0081, 0x0000}, /* index: 33, gain:6.730650db->x2.170364, DCG:0 */
+	{0x0012, 0x0083, 0x0000}, /* index: 34, gain:6.824400db->x2.193916, DCG:0 */
+	{0x0013, 0x0081, 0x0000}, /* index: 35, gain:6.918150db->x2.217724, DCG:0 */
+	{0x0013, 0x0082, 0x0000}, /* index: 36, gain:7.011900db->x2.241790, DCG:0 */
+	{0x0013, 0x0083, 0x0000}, /* index: 37, gain:7.105650db->x2.266118, DCG:0 */
+	{0x0014, 0x0080, 0x0000}, /* index: 38, gain:7.199400db->x2.290709, DCG:0 */
+	{0x0014, 0x0081, 0x0000}, /* index: 39, gain:7.293150db->x2.315568, DCG:0 */
+	{0x0014, 0x0083, 0x0000}, /* index: 40, gain:7.386900db->x2.340696, DCG:0 */
+	{0x0014, 0x0084, 0x0000}, /* index: 41, gain:7.480650db->x2.366097, DCG:0 */
+	{0x0015, 0x0080, 0x0000}, /* index: 42, gain:7.574400db->x2.391773, DCG:0 */
+	{0x0015, 0x0082, 0x0000}, /* index: 43, gain:7.668150db->x2.417728, DCG:0 */
+	{0x0015, 0x0083, 0x0000}, /* index: 44, gain:7.761900db->x2.443965, DCG:0 */
+	{0x0016, 0x0080, 0x0000}, /* index: 45, gain:7.855650db->x2.470487, DCG:0 */
+	{0x0016, 0x0081, 0x0000}, /* index: 46, gain:7.949400db->x2.497296, DCG:0 */
+	{0x0016, 0x0083, 0x0000}, /* index: 47, gain:8.043150db->x2.524396, DCG:0 */
+	{0x0016, 0x0084, 0x0000}, /* index: 48, gain:8.136900db->x2.551790, DCG:0 */
+	{0x0017, 0x0080, 0x0000}, /* index: 49, gain:8.230650db->x2.579482, DCG:0 */
+	{0x0017, 0x0082, 0x0000}, /* index: 50, gain:8.324400db->x2.607474, DCG:0 */
+	{0x0017, 0x0083, 0x0000}, /* index: 51, gain:8.418150db->x2.635770, DCG:0 */
+	{0x0018, 0x0080, 0x0000}, /* index: 52, gain:8.511900db->x2.664373, DCG:0 */
+	{0x0018, 0x0081, 0x0000}, /* index: 53, gain:8.605650db->x2.693286, DCG:0 */
+	{0x0000, 0x0081, 0x0004}, /* index: 54, gain:8.699400db->x2.722513, DCG:1 */
+	{0x0000, 0x0082, 0x0004}, /* index: 55, gain:8.793150db->x2.752057, DCG:1 */
+	{0x0001, 0x0080, 0x0004}, /* index: 56, gain:8.886900db->x2.781922, DCG:1 */
+	{0x0001, 0x0081, 0x0004}, /* index: 57, gain:8.980650db->x2.812111, DCG:1 */
+	{0x0001, 0x0082, 0x0004}, /* index: 58, gain:9.074400db->x2.842628, DCG:1 */
+	{0x0001, 0x0084, 0x0004}, /* index: 59, gain:9.168150db->x2.873476, DCG:1 */
+	{0x0002, 0x0080, 0x0004}, /* index: 60, gain:9.261900db->x2.904658, DCG:1 */
+	{0x0002, 0x0082, 0x0004}, /* index: 61, gain:9.355650db->x2.936179, DCG:1 */
+	{0x0002, 0x0083, 0x0004}, /* index: 62, gain:9.449400db->x2.968042, DCG:1 */
+	{0x0003, 0x0081, 0x0004}, /* index: 63, gain:9.543150db->x3.000250, DCG:1 */
+	{0x0003, 0x0082, 0x0004}, /* index: 64, gain:9.636900db->x3.032809, DCG:1 */
+	{0x0003, 0x0084, 0x0004}, /* index: 65, gain:9.730650db->x3.065720, DCG:1 */
+	{0x0004, 0x0080, 0x0004}, /* index: 66, gain:9.824400db->x3.098989, DCG:1 */
+	{0x0004, 0x0082, 0x0004}, /* index: 67, gain:9.918150db->x3.132618, DCG:1 */
+	{0x0004, 0x0083, 0x0004}, /* index: 68, gain:10.011900db->x3.166613, DCG:1 */
+	{0x0004, 0x0085, 0x0004}, /* index: 69, gain:10.105650db->x3.200977, DCG:1 */
+	{0x0005, 0x0080, 0x0004}, /* index: 70, gain:10.199400db->x3.235713, DCG:1 */
+	{0x0005, 0x0082, 0x0004}, /* index: 71, gain:10.293150db->x3.270826, DCG:1 */
+	{0x0005, 0x0083, 0x0004}, /* index: 72, gain:10.386900db->x3.306321, DCG:1 */
+	{0x0006, 0x0080, 0x0004}, /* index: 73, gain:10.480650db->x3.342201, DCG:1 */
+	{0x0006, 0x0082, 0x0004}, /* index: 74, gain:10.574400db->x3.378469, DCG:1 */
+	{0x0006, 0x0083, 0x0004}, /* index: 75, gain:10.668150db->x3.415132, DCG:1 */
+	{0x0006, 0x0085, 0x0004}, /* index: 76, gain:10.761900db->x3.452192, DCG:1 */
+	{0x0007, 0x0081, 0x0004}, /* index: 77, gain:10.855650db->x3.489655, DCG:1 */
+	{0x0007, 0x0082, 0x0004}, /* index: 78, gain:10.949400db->x3.527524, DCG:1 */
+	{0x0007, 0x0084, 0x0004}, /* index: 79, gain:11.043150db->x3.565804, DCG:1 */
+	{0x0008, 0x0080, 0x0004}, /* index: 80, gain:11.136900db->x3.604500, DCG:1 */
+	{0x0008, 0x0081, 0x0004}, /* index: 81, gain:11.230650db->x3.643615, DCG:1 */
+	{0x0008, 0x0083, 0x0004}, /* index: 82, gain:11.324400db->x3.683155, DCG:1 */
+	{0x0008, 0x0084, 0x0004}, /* index: 83, gain:11.418150db->x3.723124, DCG:1 */
+	{0x0009, 0x0080, 0x0004}, /* index: 84, gain:11.511900db->x3.763527, DCG:1 */
+	{0x0009, 0x0081, 0x0004}, /* index: 85, gain:11.605650db->x3.804368, DCG:1 */
+	{0x0009, 0x0083, 0x0004}, /* index: 86, gain:11.699400db->x3.845652, DCG:1 */
+	{0x0009, 0x0084, 0x0004}, /* index: 87, gain:11.793150db->x3.887385, DCG:1 */
+	{0x0009, 0x0086, 0x0004}, /* index: 88, gain:11.886900db->x3.929570, DCG:1 */
+	{0x000a, 0x0080, 0x0004}, /* index: 89, gain:11.980650db->x3.972213, DCG:1 */
+	{0x000a, 0x0082, 0x0004}, /* index: 90, gain:12.074400db->x4.015319, DCG:1 */
+	{0x000a, 0x0083, 0x0004}, /* index: 91, gain:12.168150db->x4.058892, DCG:1 */
+	{0x000a, 0x0085, 0x0004}, /* index: 92, gain:12.261900db->x4.102938, DCG:1 */
+	{0x000b, 0x0081, 0x0004}, /* index: 93, gain:12.355650db->x4.147463, DCG:1 */
+	{0x000b, 0x0082, 0x0004}, /* index: 94, gain:12.449400db->x4.192470, DCG:1 */
+	{0x000b, 0x0084, 0x0004}, /* index: 95, gain:12.543150db->x4.237966, DCG:1 */
+	{0x000b, 0x0085, 0x0004}, /* index: 96, gain:12.636900db->x4.283956, DCG:1 */
+	{0x000c, 0x0080, 0x0004}, /* index: 97, gain:12.730650db->x4.330445, DCG:1 */
+	{0x000c, 0x0081, 0x0004}, /* index: 98, gain:12.824400db->x4.377438, DCG:1 */
+	{0x000c, 0x0083, 0x0004}, /* index: 99, gain:12.918150db->x4.424941, DCG:1 */
+	{0x000c, 0x0084, 0x0004}, /* index: 100, gain:13.011900db->x4.472960, DCG:1 */
+	{0x000c, 0x0085, 0x0004}, /* index: 101, gain:13.105650db->x4.521500, DCG:1 */
+	{0x000d, 0x0080, 0x0004}, /* index: 102, gain:13.199400db->x4.570566, DCG:1 */
+	{0x000d, 0x0082, 0x0004}, /* index: 103, gain:13.293150db->x4.620165, DCG:1 */
+	{0x000d, 0x0083, 0x0004}, /* index: 104, gain:13.386900db->x4.670302, DCG:1 */
+	{0x000d, 0x0085, 0x0004}, /* index: 105, gain:13.480650db->x4.720984, DCG:1 */
+	{0x000d, 0x0086, 0x0004}, /* index: 106, gain:13.574400db->x4.772215, DCG:1 */
+	{0x000e, 0x0080, 0x0004}, /* index: 107, gain:13.668150db->x4.824002, DCG:1 */
+	{0x000e, 0x0081, 0x0004}, /* index: 108, gain:13.761900db->x4.876351, DCG:1 */
+	{0x000e, 0x0083, 0x0004}, /* index: 109, gain:13.855650db->x4.929269, DCG:1 */
+	{0x000e, 0x0084, 0x0004}, /* index: 110, gain:13.949400db->x4.982760, DCG:1 */
+	{0x000e, 0x0086, 0x0004}, /* index: 111, gain:14.043150db->x5.036832, DCG:1 */
+	{0x000f, 0x0080, 0x0004}, /* index: 112, gain:14.136900db->x5.091491, DCG:1 */
+	{0x000f, 0x0081, 0x0004}, /* index: 113, gain:14.230650db->x5.146743, DCG:1 */
+	{0x000f, 0x0083, 0x0004}, /* index: 114, gain:14.324400db->x5.202595, DCG:1 */
+	{0x000f, 0x0084, 0x0004}, /* index: 115, gain:14.418150db->x5.259052, DCG:1 */
+	{0x000f, 0x0086, 0x0004}, /* index: 116, gain:14.511900db->x5.316123, DCG:1 */
+	{0x000f, 0x0087, 0x0004}, /* index: 117, gain:14.605650db->x5.373812, DCG:1 */
+	{0x0010, 0x0080, 0x0004}, /* index: 118, gain:14.699400db->x5.432128, DCG:1 */
+	{0x0010, 0x0082, 0x0004}, /* index: 119, gain:14.793150db->x5.491077, DCG:1 */
+	{0x0010, 0x0083, 0x0004}, /* index: 120, gain:14.886900db->x5.550665, DCG:1 */
+	{0x0011, 0x0081, 0x0004}, /* index: 121, gain:14.980650db->x5.610900, DCG:1 */
+	{0x0011, 0x0082, 0x0004}, /* index: 122, gain:15.074400db->x5.671788, DCG:1 */
+	{0x0011, 0x0083, 0x0004}, /* index: 123, gain:15.168150db->x5.733337, DCG:1 */
+	{0x0012, 0x0080, 0x0004}, /* index: 124, gain:15.261900db->x5.795555, DCG:1 */
+	{0x0012, 0x0081, 0x0004}, /* index: 125, gain:15.355650db->x5.858447, DCG:1 */
+	{0x0012, 0x0083, 0x0004}, /* index: 126, gain:15.449400db->x5.922022, DCG:1 */
+	{0x0013, 0x0080, 0x0004}, /* index: 127, gain:15.543150db->x5.986287, DCG:1 */
+	{0x0013, 0x0082, 0x0004}, /* index: 128, gain:15.636900db->x6.051249, DCG:1 */
+	{0x0013, 0x0083, 0x0004}, /* index: 129, gain:15.730650db->x6.116916, DCG:1 */
+	{0x0014, 0x0080, 0x0004}, /* index: 130, gain:15.824400db->x6.183295, DCG:1 */
+	{0x0014, 0x0081, 0x0004}, /* index: 131, gain:15.918150db->x6.250396, DCG:1 */
+	{0x0014, 0x0083, 0x0004}, /* index: 132, gain:16.011900db->x6.318224, DCG:1 */
+	{0x0014, 0x0084, 0x0004}, /* index: 133, gain:16.105650db->x6.386788, DCG:1 */
+	{0x0015, 0x0080, 0x0004}, /* index: 134, gain:16.199400db->x6.456096, DCG:1 */
+	{0x0015, 0x0081, 0x0004}, /* index: 135, gain:16.293150db->x6.526157, DCG:1 */
+	{0x0015, 0x0083, 0x0004}, /* index: 136, gain:16.386900db->x6.596977, DCG:1 */
+	{0x0016, 0x0080, 0x0004}, /* index: 137, gain:16.480650db->x6.668567, DCG:1 */
+	{0x0016, 0x0081, 0x0004}, /* index: 138, gain:16.574400db->x6.740933, DCG:1 */
+	{0x0016, 0x0083, 0x0004}, /* index: 139, gain:16.668150db->x6.814084, DCG:1 */
+	{0x0016, 0x0084, 0x0004}, /* index: 140, gain:16.761900db->x6.888030, DCG:1 */
+	{0x0017, 0x0080, 0x0004}, /* index: 141, gain:16.855650db->x6.962777, DCG:1 */
+	{0x0017, 0x0082, 0x0004}, /* index: 142, gain:16.949400db->x7.038336, DCG:1 */
+	{0x0017, 0x0083, 0x0004}, /* index: 143, gain:17.043150db->x7.114715, DCG:1 */
+	{0x0018, 0x0080, 0x0004}, /* index: 144, gain:17.136900db->x7.191923, DCG:1 */
+	{0x0018, 0x0081, 0x0004}, /* index: 145, gain:17.230650db->x7.269968, DCG:1 */
+	{0x0018, 0x0082, 0x0004}, /* index: 146, gain:17.324400db->x7.348860, DCG:1 */
+	{0x0018, 0x0084, 0x0004}, /* index: 147, gain:17.418150db->x7.428609, DCG:1 */
+	{0x0019, 0x0080, 0x0004}, /* index: 148, gain:17.511900db->x7.509223, DCG:1 */
+	{0x0019, 0x0081, 0x0004}, /* index: 149, gain:17.605650db->x7.590712, DCG:1 */
+	{0x0019, 0x0082, 0x0004}, /* index: 150, gain:17.699400db->x7.673085, DCG:1 */
+	{0x0019, 0x0084, 0x0004}, /* index: 151, gain:17.793150db->x7.756352, DCG:1 */
+	{0x0019, 0x0085, 0x0004}, /* index: 152, gain:17.886900db->x7.840522, DCG:1 */
+	{0x001a, 0x0080, 0x0004}, /* index: 153, gain:17.980650db->x7.925606, DCG:1 */
+	{0x001a, 0x0082, 0x0004}, /* index: 154, gain:18.074400db->x8.011614, DCG:1 */
+	{0x001a, 0x0083, 0x0004}, /* index: 155, gain:18.168150db->x8.098554, DCG:1 */
+	{0x001a, 0x0084, 0x0004}, /* index: 156, gain:18.261900db->x8.186438, DCG:1 */
+	{0x001b, 0x0081, 0x0004}, /* index: 157, gain:18.355650db->x8.275276, DCG:1 */
+	{0x001b, 0x0082, 0x0004}, /* index: 158, gain:18.449400db->x8.365078, DCG:1 */
+	{0x001b, 0x0083, 0x0004}, /* index: 159, gain:18.543150db->x8.455854, DCG:1 */
+	{0x001b, 0x0085, 0x0004}, /* index: 160, gain:18.636900db->x8.547616, DCG:1 */
+	{0x001c, 0x0080, 0x0004}, /* index: 161, gain:18.730650db->x8.640373, DCG:1 */
+	{0x001c, 0x0081, 0x0004}, /* index: 162, gain:18.824400db->x8.734137, DCG:1 */
+	{0x001c, 0x0082, 0x0004}, /* index: 163, gain:18.918150db->x8.828918, DCG:1 */
+	{0x001c, 0x0084, 0x0004}, /* index: 164, gain:19.011900db->x8.924728, DCG:1 */
+	{0x001c, 0x0085, 0x0004}, /* index: 165, gain:19.105650db->x9.021578, DCG:1 */
+	{0x001d, 0x0080, 0x0004}, /* index: 166, gain:19.199400db->x9.119478, DCG:1 */
+	{0x001d, 0x0082, 0x0004}, /* index: 167, gain:19.293150db->x9.218441, DCG:1 */
+	{0x001d, 0x0083, 0x0004}, /* index: 168, gain:19.386900db->x9.318478, DCG:1 */
+	{0x001d, 0x0084, 0x0004}, /* index: 169, gain:19.480650db->x9.419601, DCG:1 */
+	{0x001d, 0x0086, 0x0004}, /* index: 170, gain:19.574400db->x9.521821, DCG:1 */
+	{0x001e, 0x0080, 0x0004}, /* index: 171, gain:19.668150db->x9.625150, DCG:1 */
+	{0x001e, 0x0081, 0x0004}, /* index: 172, gain:19.761900db->x9.729600, DCG:1 */
+	{0x001e, 0x0082, 0x0004}, /* index: 173, gain:19.855650db->x9.835184, DCG:1 */
+	{0x001e, 0x0084, 0x0004}, /* index: 174, gain:19.949400db->x9.941914, DCG:1 */
+	{0x001e, 0x0085, 0x0004}, /* index: 175, gain:20.043150db->x10.049802, DCG:1 */
+	{0x001f, 0x0080, 0x0004}, /* index: 176, gain:20.136900db->x10.158861, DCG:1 */
+	{0x001f, 0x0081, 0x0004}, /* index: 177, gain:20.230650db->x10.269103, DCG:1 */
+	{0x001f, 0x0082, 0x0004}, /* index: 178, gain:20.324400db->x10.380541, DCG:1 */
+	{0x001f, 0x0084, 0x0004}, /* index: 179, gain:20.418150db->x10.493189, DCG:1 */
+	{0x001f, 0x0085, 0x0004}, /* index: 180, gain:20.511900db->x10.607059, DCG:1 */
+	{0x001f, 0x0087, 0x0004}, /* index: 181, gain:20.605650db->x10.722165, DCG:1 */
+	{0x0020, 0x0080, 0x0004}, /* index: 182, gain:20.699400db->x10.838520, DCG:1 */
+	{0x0020, 0x0081, 0x0004}, /* index: 183, gain:20.793150db->x10.956138, DCG:1 */
+	{0x0020, 0x0083, 0x0004}, /* index: 184, gain:20.886900db->x11.075032, DCG:1 */
+	{0x0021, 0x0080, 0x0004}, /* index: 185, gain:20.980650db->x11.195217, DCG:1 */
+	{0x0021, 0x0082, 0x0004}, /* index: 186, gain:21.074400db->x11.316705, DCG:1 */
+	{0x0021, 0x0083, 0x0004}, /* index: 187, gain:21.168150db->x11.439512, DCG:1 */
+	{0x0022, 0x0080, 0x0004}, /* index: 188, gain:21.261900db->x11.563652, DCG:1 */
+	{0x0022, 0x0081, 0x0004}, /* index: 189, gain:21.355650db->x11.689138, DCG:1 */
+	{0x0022, 0x0082, 0x0004}, /* index: 190, gain:21.449400db->x11.815987, DCG:1 */
+	{0x0023, 0x0080, 0x0004}, /* index: 191, gain:21.543150db->x11.944212, DCG:1 */
+	{0x0023, 0x0082, 0x0004}, /* index: 192, gain:21.636900db->x12.073828, DCG:1 */
+	{0x0023, 0x0083, 0x0004}, /* index: 193, gain:21.730650db->x12.204852, DCG:1 */
+	{0x0024, 0x0080, 0x0004}, /* index: 194, gain:21.824400db->x12.337296, DCG:1 */
+	{0x0024, 0x0081, 0x0004}, /* index: 195, gain:21.918150db->x12.471179, DCG:1 */
+	{0x0024, 0x0083, 0x0004}, /* index: 196, gain:22.011900db->x12.606514, DCG:1 */
+	{0x0024, 0x0084, 0x0004}, /* index: 197, gain:22.105650db->x12.743317, DCG:1 */
+	{0x0025, 0x0080, 0x0004}, /* index: 198, gain:22.199400db->x12.881606, DCG:1 */
+	{0x0025, 0x0081, 0x0004}, /* index: 199, gain:22.293150db->x13.021395, DCG:1 */
+	{0x0025, 0x0083, 0x0004}, /* index: 200, gain:22.386900db->x13.162701, DCG:1 */
+	{0x0026, 0x0080, 0x0004}, /* index: 201, gain:22.480650db->x13.305540, DCG:1 */
+	{0x0026, 0x0081, 0x0004}, /* index: 202, gain:22.574400db->x13.449929, DCG:1 */
+	{0x0026, 0x0083, 0x0004}, /* index: 203, gain:22.668150db->x13.595886, DCG:1 */
+	{0x0026, 0x0084, 0x0004}, /* index: 204, gain:22.761900db->x13.743426, DCG:1 */
+	{0x0027, 0x0080, 0x0004}, /* index: 205, gain:22.855650db->x13.892567, DCG:1 */
+	{0x0027, 0x0082, 0x0004}, /* index: 206, gain:22.949400db->x14.043327, DCG:1 */
+	{0x0027, 0x0083, 0x0004}, /* index: 207, gain:23.043150db->x14.195722, DCG:1 */
+	{0x0027, 0x0084, 0x0004}, /* index: 208, gain:23.136900db->x14.349772, DCG:1 */
+	{0x0028, 0x0081, 0x0004}, /* index: 209, gain:23.230650db->x14.505493, DCG:1 */
+	{0x0028, 0x0082, 0x0004}, /* index: 210, gain:23.324400db->x14.662904, DCG:1 */
+	{0x0028, 0x0084, 0x0004}, /* index: 211, gain:23.418150db->x14.822024, DCG:1 */
+	{0x0028, 0x0085, 0x0004}, /* index: 212, gain:23.511900db->x14.982870, DCG:1 */
+	{0x0029, 0x0081, 0x0004}, /* index: 213, gain:23.605650db->x15.145461, DCG:1 */
+	{0x0029, 0x0082, 0x0004}, /* index: 214, gain:23.699400db->x15.309817, DCG:1 */
+	{0x0029, 0x0083, 0x0004}, /* index: 215, gain:23.793150db->x15.475956, DCG:1 */
+	{0x0029, 0x0085, 0x0004}, /* index: 216, gain:23.886900db->x15.643899, DCG:1 */
+	{0x002a, 0x0080, 0x0004}, /* index: 217, gain:23.980650db->x15.813664, DCG:1 */
+	{0x002a, 0x0081, 0x0004}, /* index: 218, gain:24.074400db->x15.985271, DCG:1 */
+	{0x002a, 0x0083, 0x0004}, /* index: 219, gain:24.168150db->x16.158740, DCG:1 */
+	{0x002a, 0x0084, 0x0004}, /* index: 220, gain:24.261900db->x16.334092, DCG:1 */
+	{0x002b, 0x0080, 0x0004}, /* index: 221, gain:24.355650db->x16.511347, DCG:1 */
+	{0x002b, 0x0082, 0x0004}, /* index: 222, gain:24.449400db->x16.690525, DCG:1 */
+	{0x002b, 0x0083, 0x0004}, /* index: 223, gain:24.543150db->x16.871648, DCG:1 */
+	{0x002b, 0x0084, 0x0004}, /* index: 224, gain:24.636900db->x17.054736, DCG:1 */
+	{0x002b, 0x0086, 0x0004}, /* index: 225, gain:24.730650db->x17.239811, DCG:1 */
+	{0x002c, 0x0081, 0x0004}, /* index: 226, gain:24.824400db->x17.426894, DCG:1 */
+	{0x002c, 0x0082, 0x0004}, /* index: 227, gain:24.918150db->x17.616008, DCG:1 */
+	{0x002c, 0x0083, 0x0004}, /* index: 228, gain:25.011900db->x17.807174, DCG:1 */
+	{0x002c, 0x0085, 0x0004}, /* index: 229, gain:25.105650db->x18.000414, DCG:1 */
+	{0x002d, 0x0080, 0x0004}, /* index: 230, gain:25.199400db->x18.195752, DCG:1 */
+	{0x002d, 0x0081, 0x0004}, /* index: 231, gain:25.293150db->x18.393209, DCG:1 */
+	{0x002d, 0x0083, 0x0004}, /* index: 232, gain:25.386900db->x18.592809, DCG:1 */
+	{0x002d, 0x0084, 0x0004}, /* index: 233, gain:25.480650db->x18.794575, DCG:1 */
+	{0x002d, 0x0086, 0x0004}, /* index: 234, gain:25.574400db->x18.998530, DCG:1 */
+	{0x002d, 0x0087, 0x0004}, /* index: 235, gain:25.668150db->x19.204699, DCG:1 */
+	{0x002e, 0x0081, 0x0004}, /* index: 236, gain:25.761900db->x19.413105, DCG:1 */
+	{0x002e, 0x0082, 0x0004}, /* index: 237, gain:25.855650db->x19.623772, DCG:1 */
+	{0x002e, 0x0084, 0x0004}, /* index: 238, gain:25.949400db->x19.836726, DCG:1 */
+	{0x002e, 0x0085, 0x0004}, /* index: 239, gain:26.043150db->x20.051991, DCG:1 */
+	{0x002e, 0x0086, 0x0004}, /* index: 240, gain:26.136900db->x20.269592, DCG:1 */
+	{0x002f, 0x0081, 0x0004}, /* index: 241, gain:26.230650db->x20.489554, DCG:1 */
+	{0x002f, 0x0082, 0x0004}, /* index: 242, gain:26.324400db->x20.711903, DCG:1 */
+	{0x002f, 0x0083, 0x0004}, /* index: 243, gain:26.418150db->x20.936665, DCG:1 */
+	{0x002f, 0x0085, 0x0004}, /* index: 244, gain:26.511900db->x21.163866, DCG:1 */
+	{0x002f, 0x0086, 0x0004}, /* index: 245, gain:26.605650db->x21.393532, DCG:1 */
+	{0x0030, 0x0080, 0x0004}, /* index: 246, gain:26.699400db->x21.625691, DCG:1 */
+	{0x0030, 0x0081, 0x0004}, /* index: 247, gain:26.793150db->x21.860370, DCG:1 */
+	{0x0030, 0x0082, 0x0004}, /* index: 248, gain:26.886900db->x22.097595, DCG:1 */
+	{0x0031, 0x0080, 0x0004}, /* index: 249, gain:26.980650db->x22.337394, DCG:1 */
+	{0x0031, 0x0081, 0x0004}, /* index: 250, gain:27.074400db->x22.579795, DCG:1 */
+	{0x0031, 0x0083, 0x0004}, /* index: 251, gain:27.168150db->x22.824827, DCG:1 */
+	{0x0031, 0x0084, 0x0004}, /* index: 252, gain:27.261900db->x23.072518, DCG:1 */
+	{0x0032, 0x0081, 0x0004}, /* index: 253, gain:27.355650db->x23.322897, DCG:1 */
+	{0x0032, 0x0082, 0x0004}, /* index: 254, gain:27.449400db->x23.575993, DCG:1 */
+	{0x0033, 0x0080, 0x0004}, /* index: 255, gain:27.543150db->x23.831836, DCG:1 */
+	{0x0033, 0x0081, 0x0004}, /* index: 256, gain:27.636900db->x24.090455, DCG:1 */
+	{0x0033, 0x0083, 0x0004}, /* index: 257, gain:27.730650db->x24.351880, DCG:1 */
+	{0x0033, 0x0084, 0x0004}, /* index: 258, gain:27.824400db->x24.616143, DCG:1 */
+	{0x0034, 0x0081, 0x0004}, /* index: 259, gain:27.918150db->x24.883273, DCG:1 */
+	{0x0034, 0x0082, 0x0004}, /* index: 260, gain:28.011900db->x25.153302, DCG:1 */
+	{0x0034, 0x0084, 0x0004}, /* index: 261, gain:28.105650db->x25.426261, DCG:1 */
+	{0x0034, 0x0085, 0x0004}, /* index: 262, gain:28.199400db->x25.702182, DCG:1 */
+	{0x0035, 0x0081, 0x0004}, /* index: 263, gain:28.293150db->x25.981098, DCG:1 */
+	{0x0035, 0x0082, 0x0004}, /* index: 264, gain:28.386900db->x26.263040, DCG:1 */
+	{0x0035, 0x0084, 0x0004}, /* index: 265, gain:28.480650db->x26.548042, DCG:1 */
+	{0x0036, 0x0081, 0x0004}, /* index: 266, gain:28.574400db->x26.836137, DCG:1 */
+	{0x0036, 0x0082, 0x0004}, /* index: 267, gain:28.668150db->x27.127358, DCG:1 */
+	{0x0036, 0x0084, 0x0004}, /* index: 268, gain:28.761900db->x27.421739, DCG:1 */
+	{0x0037, 0x0080, 0x0004}, /* index: 269, gain:28.855650db->x27.719315, DCG:1 */
+	{0x0037, 0x0081, 0x0004}, /* index: 270, gain:28.949400db->x28.020121, DCG:1 */
+	{0x0037, 0x0083, 0x0004}, /* index: 271, gain:29.043150db->x28.324190, DCG:1 */
+	{0x0037, 0x0084, 0x0004}, /* index: 272, gain:29.136900db->x28.631559, DCG:1 */
+	{0x0038, 0x0080, 0x0004}, /* index: 273, gain:29.230650db->x28.942264, DCG:1 */
+	{0x0038, 0x0082, 0x0004}, /* index: 274, gain:29.324400db->x29.256340, DCG:1 */
+	{0x0038, 0x0083, 0x0004}, /* index: 275, gain:29.418150db->x29.573825, DCG:1 */
+	{0x0038, 0x0085, 0x0004}, /* index: 276, gain:29.511900db->x29.894755, DCG:1 */
+	{0x0039, 0x0080, 0x0004}, /* index: 277, gain:29.605650db->x30.219168, DCG:1 */
+	{0x0039, 0x0082, 0x0004}, /* index: 278, gain:29.699400db->x30.547101, DCG:1 */
+	{0x0039, 0x0083, 0x0004}, /* index: 279, gain:29.793150db->x30.878593, DCG:1 */
+	{0x0039, 0x0085, 0x0004}, /* index: 280, gain:29.886900db->x31.213682, DCG:1 */
+	{0x003a, 0x0080, 0x0004}, /* index: 281, gain:29.980650db->x31.552407, DCG:1 */
+	{0x003a, 0x0081, 0x0004}, /* index: 282, gain:30.074400db->x31.894809, DCG:1 */
+	{0x003a, 0x0082, 0x0004}, /* index: 283, gain:30.168150db->x32.240925, DCG:1 */
+	{0x003a, 0x0084, 0x0004}, /* index: 284, gain:30.261900db->x32.590798, DCG:1 */
+	{0x003b, 0x0080, 0x0004}, /* index: 285, gain:30.355650db->x32.944468, DCG:1 */
+	{0x003b, 0x0081, 0x0004}, /* index: 286, gain:30.449400db->x33.301976, DCG:1 */
+	{0x003b, 0x0083, 0x0004}, /* index: 287, gain:30.543150db->x33.663363, DCG:1 */
+	{0x003b, 0x0084, 0x0004}, /* index: 288, gain:30.636900db->x34.028672, DCG:1 */
+	{0x003b, 0x0086, 0x0004}, /* index: 289, gain:30.730650db->x34.397945, DCG:1 */
+	{0x003c, 0x0080, 0x0004}, /* index: 290, gain:30.824400db->x34.771226, DCG:1 */
+	{0x003c, 0x0082, 0x0004}, /* index: 291, gain:30.918150db->x35.148557, DCG:1 */
+	{0x003c, 0x0083, 0x0004}, /* index: 292, gain:31.011900db->x35.529983, DCG:1 */
+	{0x003c, 0x0085, 0x0004}, /* index: 293, gain:31.105650db->x35.915548, DCG:1 */
+	{0x003d, 0x0080, 0x0004}, /* index: 294, gain:31.199400db->x36.305298, DCG:1 */
+	{0x003d, 0x0081, 0x0004}, /* index: 295, gain:31.293150db->x36.699276, DCG:1 */
+	{0x003d, 0x0082, 0x0004}, /* index: 296, gain:31.386900db->x37.097530, DCG:1 */
+	{0x003d, 0x0084, 0x0004}, /* index: 297, gain:31.480650db->x37.500106, DCG:1 */
+	{0x003d, 0x0085, 0x0004}, /* index: 298, gain:31.574400db->x37.907051, DCG:1 */
+	{0x003d, 0x0087, 0x0004}, /* index: 299, gain:31.668150db->x38.318412, DCG:1 */
+	{0x003e, 0x0080, 0x0004}, /* index: 300, gain:31.761900db->x38.734237, DCG:1 */
+	{0x003e, 0x0082, 0x0004}, /* index: 301, gain:31.855650db->x39.154574, DCG:1 */
+	{0x003e, 0x0083, 0x0004}, /* index: 302, gain:31.949400db->x39.579472, DCG:1 */
+	{0x003e, 0x0085, 0x0004}, /* index: 303, gain:32.043150db->x40.008982, DCG:1 */
+	{0x003e, 0x0086, 0x0004}, /* index: 304, gain:32.136900db->x40.443152, DCG:1 */
+	{0x003f, 0x0080, 0x0004}, /* index: 305, gain:32.230650db->x40.882034, DCG:1 */
+	{0x003f, 0x0082, 0x0004}, /* index: 306, gain:32.324400db->x41.325679, DCG:1 */
+	{0x003f, 0x0083, 0x0004}, /* index: 307, gain:32.418150db->x41.774138, DCG:1 */
+	{0x003f, 0x0085, 0x0004}, /* index: 308, gain:32.511900db->x42.227464, DCG:1 */
+	{0x003f, 0x0086, 0x0004}, /* index: 309, gain:32.605650db->x42.685709, DCG:1 */
+	{0x003f, 0x0088, 0x0004}, /* index: 310, gain:32.699400db->x43.148927, DCG:1 */
+	{0x0040, 0x0081, 0x0004}, /* index: 311, gain:32.793150db->x43.617172, DCG:1 */
+	{0x0040, 0x0082, 0x0004}, /* index: 312, gain:32.886900db->x44.090498, DCG:1 */
+	{0x0041, 0x0080, 0x0004}, /* index: 313, gain:32.980650db->x44.568960, DCG:1 */
+	{0x0041, 0x0081, 0x0004}, /* index: 314, gain:33.074400db->x45.052615, DCG:1 */
+	{0x0041, 0x0083, 0x0004}, /* index: 315, gain:33.168150db->x45.541518, DCG:1 */
+	{0x0041, 0x0084, 0x0004}, /* index: 316, gain:33.261900db->x46.035726, DCG:1 */
+	{0x0042, 0x0080, 0x0004}, /* index: 317, gain:33.355650db->x46.535298, DCG:1 */
+	{0x0042, 0x0082, 0x0004}, /* index: 318, gain:33.449400db->x47.040291, DCG:1 */
+	{0x0043, 0x0080, 0x0004}, /* index: 319, gain:33.543150db->x47.550764, DCG:1 */
+	{0x0043, 0x0081, 0x0004}, /* index: 320, gain:33.636900db->x48.066777, DCG:1 */
+	{0x0043, 0x0082, 0x0004}, /* index: 321, gain:33.730650db->x48.588389, DCG:1 */
+	{0x0043, 0x0084, 0x0004}, /* index: 322, gain:33.824400db->x49.115662, DCG:1 */
+	{0x0044, 0x0081, 0x0004}, /* index: 323, gain:33.918150db->x49.648656, DCG:1 */
+	{0x0044, 0x0082, 0x0004}, /* index: 324, gain:34.011900db->x50.187435, DCG:1 */
+	{0x0044, 0x0083, 0x0004}, /* index: 325, gain:34.105650db->x50.732060, DCG:1 */
+	{0x0044, 0x0085, 0x0004}, /* index: 326, gain:34.199400db->x51.282596, DCG:1 */
+	{0x0045, 0x0081, 0x0004}, /* index: 327, gain:34.293150db->x51.839106, DCG:1 */
+	{0x0045, 0x0082, 0x0004}, /* index: 328, gain:34.386900db->x52.401655, DCG:1 */
+	{0x0045, 0x0083, 0x0004}, /* index: 329, gain:34.480650db->x52.970308, DCG:1 */
+	{0x0046, 0x0080, 0x0004}, /* index: 330, gain:34.574400db->x53.545133, DCG:1 */
+	{0x0046, 0x0082, 0x0004}, /* index: 331, gain:34.668150db->x54.126195, DCG:1 */
+	{0x0046, 0x0083, 0x0004}, /* index: 332, gain:34.761900db->x54.713563, DCG:1 */
+	{0x0047, 0x0080, 0x0004}, /* index: 333, gain:34.855650db->x55.307305, DCG:1 */
+	{0x0047, 0x0081, 0x0004}, /* index: 334, gain:34.949400db->x55.907491, DCG:1 */
+	{0x0047, 0x0082, 0x0004}, /* index: 335, gain:35.043150db->x56.514189, DCG:1 */
+	{0x0047, 0x0084, 0x0004}, /* index: 336, gain:35.136900db->x57.127471, DCG:1 */
+	{0x0048, 0x0080, 0x0004}, /* index: 337, gain:35.230650db->x57.747409, DCG:1 */
+	{0x0048, 0x0082, 0x0004}, /* index: 338, gain:35.324400db->x58.374073, DCG:1 */
+	{0x0048, 0x0083, 0x0004}, /* index: 339, gain:35.418150db->x59.007539, DCG:1 */
+	{0x0048, 0x0084, 0x0004}, /* index: 340, gain:35.511900db->x59.647878, DCG:1 */
+	{0x0049, 0x0080, 0x0004}, /* index: 341, gain:35.605650db->x60.295167, DCG:1 */
+	{0x0049, 0x0081, 0x0004}, /* index: 342, gain:35.699400db->x60.949479, DCG:1 */
+	{0x0049, 0x0083, 0x0004}, /* index: 343, gain:35.793150db->x61.610892, DCG:1 */
+	{0x0049, 0x0084, 0x0004}, /* index: 344, gain:35.886900db->x62.279483, DCG:1 */
+	{0x0049, 0x0086, 0x0004}, /* index: 345, gain:35.980650db->x62.955329, DCG:1 */
+	{0x004a, 0x0081, 0x0004}, /* index: 346, gain:36.074400db->x63.638510, DCG:1 */
+	{0x004a, 0x0082, 0x0004}, /* index: 347, gain:36.168150db->x64.329104, DCG:1 */
+	{0x004a, 0x0083, 0x0004}, /* index: 348, gain:36.261900db->x65.027192, DCG:1 */
+	{0x004b, 0x0080, 0x0004}, /* index: 349, gain:36.355650db->x65.732856, DCG:1 */
+	{0x004b, 0x0081, 0x0004}, /* index: 350, gain:36.449400db->x66.446177, DCG:1 */
+	{0x004b, 0x0082, 0x0004}, /* index: 351, gain:36.543150db->x67.167240, DCG:1 */
+	{0x004b, 0x0084, 0x0004}, /* index: 352, gain:36.636900db->x67.896127, DCG:1 */
+	{0x004b, 0x0085, 0x0004}, /* index: 353, gain:36.730650db->x68.632924, DCG:1 */
+	{0x004c, 0x0080, 0x0004}, /* index: 354, gain:36.824400db->x69.377716, DCG:1 */
+	{0x004c, 0x0081, 0x0004}, /* index: 355, gain:36.918150db->x70.130591, DCG:1 */
+	{0x004c, 0x0083, 0x0004}, /* index: 356, gain:37.011900db->x70.891636, DCG:1 */
+	{0x004c, 0x0084, 0x0004}, /* index: 357, gain:37.105650db->x71.660940, DCG:1 */
+	{0x004c, 0x0086, 0x0004}, /* index: 358, gain:37.199400db->x72.438592, DCG:1 */
+	{0x004d, 0x0081, 0x0004}, /* index: 359, gain:37.293150db->x73.224683, DCG:1 */
+	{0x004d, 0x0082, 0x0004}, /* index: 360, gain:37.386900db->x74.019304, DCG:1 */
+	{0x004d, 0x0083, 0x0004}, /* index: 361, gain:37.480650db->x74.822549, DCG:1 */
+	{0x004d, 0x0085, 0x0004}, /* index: 362, gain:37.574400db->x75.634510, DCG:1 */
+	{0x004d, 0x0086, 0x0004}, /* index: 363, gain:37.668150db->x76.455283, DCG:1 */
+	{0x004e, 0x0080, 0x0004}, /* index: 364, gain:37.761900db->x77.284962, DCG:1 */
+	{0x004e, 0x0082, 0x0004}, /* index: 365, gain:37.855650db->x78.123645, DCG:1 */
+	{0x004e, 0x0083, 0x0004}, /* index: 366, gain:37.949400db->x78.971430, DCG:1 */
+	{0x004e, 0x0084, 0x0004}, /* index: 367, gain:38.043150db->x79.828414, DCG:1 */
+	{0x004e, 0x0086, 0x0004}, /* index: 368, gain:38.136900db->x80.694698, DCG:1 */
+	{0x004f, 0x0080, 0x0004}, /* index: 369, gain:38.230650db->x81.570383, DCG:1 */
+	{0x004f, 0x0081, 0x0004}, /* index: 370, gain:38.324400db->x82.455570, DCG:1 */
+	{0x004f, 0x0083, 0x0004}, /* index: 371, gain:38.418150db->x83.350364, DCG:1 */
+	{0x004f, 0x0084, 0x0004}, /* index: 372, gain:38.511900db->x84.254868, DCG:1 */
+	{0x004f, 0x0086, 0x0004}, /* index: 373, gain:38.605650db->x85.169187, DCG:1 */
+	{0x004f, 0x0087, 0x0004}, /* index: 374, gain:38.699400db->x86.093428, DCG:1 */
+	{0x004f, 0x0089, 0x0004}, /* index: 375, gain:38.793150db->x87.027699, DCG:1 */
+	{0x004f, 0x008a, 0x0004}, /* index: 376, gain:38.886900db->x87.972108, DCG:1 */
+	{0x004f, 0x008c, 0x0004}, /* index: 377, gain:38.980650db->x88.926766, DCG:1 */
+	{0x004f, 0x008d, 0x0004}, /* index: 378, gain:39.074400db->x89.891784, DCG:1 */
+	{0x004f, 0x008f, 0x0004}, /* index: 379, gain:39.168150db->x90.867274, DCG:1 */
+	{0x004f, 0x0090, 0x0004}, /* index: 380, gain:39.261900db->x91.853350, DCG:1 */
+	{0x004f, 0x0092, 0x0004}, /* index: 381, gain:39.355650db->x92.850127, DCG:1 */
+	{0x004f, 0x0093, 0x0004}, /* index: 382, gain:39.449400db->x93.857720, DCG:1 */
+	{0x004f, 0x0095, 0x0004}, /* index: 383, gain:39.543150db->x94.876248, DCG:1 */
+	{0x004f, 0x0097, 0x0004}, /* index: 384, gain:39.636900db->x95.905828, DCG:1 */
+	{0x004f, 0x0098, 0x0004}, /* index: 385, gain:39.730650db->x96.946582, DCG:1 */
+	{0x004f, 0x009a, 0x0004}, /* index: 386, gain:39.824400db->x97.998629, DCG:1 */
+	{0x004f, 0x009c, 0x0004}, /* index: 387, gain:39.918150db->x99.062093, DCG:1 */
+	{0x004f, 0x009d, 0x0004}, /* index: 388, gain:40.011900db->x100.137098, DCG:1 */
+	{0x004f, 0x009f, 0x0004}, /* index: 389, gain:40.105650db->x101.223768, DCG:1 */
+	{0x004f, 0x00a1, 0x0004}, /* index: 390, gain:40.199400db->x102.322231, DCG:1 */
+	{0x004f, 0x00a3, 0x0004}, /* index: 391, gain:40.293150db->x103.432614, DCG:1 */
+	{0x004f, 0x00a4, 0x0004}, /* index: 392, gain:40.386900db->x104.555047, DCG:1 */
+	{0x004f, 0x00a6, 0x0004}, /* index: 393, gain:40.480650db->x105.689660, DCG:1 */
+	{0x004f, 0x00a8, 0x0004}, /* index: 394, gain:40.574400db->x106.836586, DCG:1 */
+	{0x004f, 0x00aa, 0x0004}, /* index: 395, gain:40.668150db->x107.995958, DCG:1 */
+	{0x004f, 0x00ac, 0x0004}, /* index: 396, gain:40.761900db->x109.167911, DCG:1 */
+	{0x004f, 0x00ad, 0x0004}, /* index: 397, gain:40.855650db->x110.352582, DCG:1 */
+	{0x004f, 0x00af, 0x0004}, /* index: 398, gain:40.949400db->x111.550109, DCG:1 */
+	{0x004f, 0x00b1, 0x0004}, /* index: 399, gain:41.043150db->x112.760632, DCG:1 */
+	{0x004f, 0x00b3, 0x0004}, /* index: 400, gain:41.136900db->x113.984290, DCG:1 */
+	{0x004f, 0x00b5, 0x0004}, /* index: 401, gain:41.230650db->x115.221228, DCG:1 */
+	{0x004f, 0x00b7, 0x0004}, /* index: 402, gain:41.324400db->x116.471589, DCG:1 */
+	{0x004f, 0x00b9, 0x0004}, /* index: 403, gain:41.418150db->x117.735518, DCG:1 */
+	{0x004f, 0x00bb, 0x0004}, /* index: 404, gain:41.511900db->x119.013164, DCG:1 */
+	{0x004f, 0x00bd, 0x0004}, /* index: 405, gain:41.605650db->x120.304674, DCG:1 */
+	{0x004f, 0x00bf, 0x0004}, /* index: 406, gain:41.699400db->x121.610199, DCG:1 */
+	{0x004f, 0x00c1, 0x0004}, /* index: 407, gain:41.793150db->x122.929892, DCG:1 */
+	{0x004f, 0x00c3, 0x0004}, /* index: 408, gain:41.886900db->x124.263906, DCG:1 */
+	{0x004f, 0x00c5, 0x0004}, /* index: 409, gain:41.980650db->x125.612396, DCG:1 */
+	{0x004f, 0x00c8, 0x0004}, /* index: 410, gain:42.074400db->x126.975520, DCG:1 */
+	{0x004f, 0x00ca, 0x0004}, /* index: 411, gain:42.168150db->x128.353436, DCG:1 */
+	{0x004f, 0x00cc, 0x0004}, /* index: 412, gain:42.261900db->x129.746305, DCG:1 */
+	{0x004f, 0x00ce, 0x0004}, /* index: 413, gain:42.355650db->x131.154290, DCG:1 */
+	{0x004f, 0x00d0, 0x0004}, /* index: 414, gain:42.449400db->x132.577553, DCG:1 */
+	{0x004f, 0x00d3, 0x0004}, /* index: 415, gain:42.543150db->x134.016262, DCG:1 */
+	{0x004f, 0x00d5, 0x0004}, /* index: 416, gain:42.636900db->x135.470583, DCG:1 */
+	{0x004f, 0x00d7, 0x0004}, /* index: 417, gain:42.730650db->x136.940686, DCG:1 */
+	{0x004f, 0x00da, 0x0004}, /* index: 418, gain:42.824400db->x138.426743, DCG:1 */
+	{0x004f, 0x00dc, 0x0004}, /* index: 419, gain:42.918150db->x139.928926, DCG:1 */
+	{0x004f, 0x00de, 0x0004}, /* index: 420, gain:43.011900db->x141.447410, DCG:1 */
+	{0x004f, 0x00e1, 0x0004}, /* index: 421, gain:43.105650db->x142.982373, DCG:1 */
+	{0x004f, 0x00e3, 0x0004}, /* index: 422, gain:43.199400db->x144.533993, DCG:1 */
+	{0x004f, 0x00e6, 0x0004}, /* index: 423, gain:43.293150db->x146.102450, DCG:1 */
+	{0x004f, 0x00e8, 0x0004}, /* index: 424, gain:43.386900db->x147.687929, DCG:1 */
+	{0x004f, 0x00eb, 0x0004}, /* index: 425, gain:43.480650db->x149.290613, DCG:1 */
+	{0x004f, 0x00ed, 0x0004}, /* index: 426, gain:43.574400db->x150.910688, DCG:1 */
+	{0x004f, 0x00f0, 0x0004}, /* index: 427, gain:43.668150db->x152.548345, DCG:1 */
+	{0x004f, 0x00f3, 0x0004}, /* index: 428, gain:43.761900db->x154.203773, DCG:1 */
+	{0x004f, 0x00f5, 0x0004}, /* index: 429, gain:43.855650db->x155.877166, DCG:1 */
+	{0x004f, 0x00f8, 0x0004}, /* index: 430, gain:43.949400db->x157.568717, DCG:1 */
+	{0x004f, 0x00fb, 0x0004}, /* index: 431, gain:44.043150db->x159.278626, DCG:1 */
+	{0x004f, 0x00fd, 0x0004}, /* index: 432, gain:44.136900db->x161.007090, DCG:1 */
+	{0x004f, 0x0100, 0x0004}, /* index: 433, gain:44.230650db->x162.754311, DCG:1 */
+	{0x004f, 0x0103, 0x0004}, /* index: 434, gain:44.324400db->x164.520492, DCG:1 */
+	{0x004f, 0x0106, 0x0004}, /* index: 435, gain:44.418150db->x166.305840, DCG:1 */
+	{0x004f, 0x0108, 0x0004}, /* index: 436, gain:44.511900db->x168.110562, DCG:1 */
+	{0x004f, 0x010b, 0x0004}, /* index: 437, gain:44.605650db->x169.934869, DCG:1 */
+	{0x004f, 0x010e, 0x0004}, /* index: 438, gain:44.699400db->x171.778972, DCG:1 */
+	{0x004f, 0x0111, 0x0004}, /* index: 439, gain:44.793150db->x173.643088, DCG:1 */
+	{0x004f, 0x0114, 0x0004}, /* index: 440, gain:44.886900db->x175.527432, DCG:1 */
+	{0x004f, 0x0117, 0x0004}, /* index: 441, gain:44.980650db->x177.432226, DCG:1 */
+	{0x004f, 0x011a, 0x0004}, /* index: 442, gain:45.074400db->x179.357689, DCG:1 */
+	{0x004f, 0x011d, 0x0004}, /* index: 443, gain:45.168150db->x181.304048, DCG:1 */
+	{0x004f, 0x0120, 0x0004}, /* index: 444, gain:45.261900db->x183.271528, DCG:1 */
+	{0x004f, 0x0123, 0x0004}, /* index: 445, gain:45.355650db->x185.260358, DCG:1 */
+	{0x004f, 0x0127, 0x0004}, /* index: 446, gain:45.449400db->x187.270772, DCG:1 */
+	{0x004f, 0x012a, 0x0004}, /* index: 447, gain:45.543150db->x189.303002, DCG:1 */
+	{0x004f, 0x012d, 0x0004}, /* index: 448, gain:45.636900db->x191.357285, DCG:1 */
+	{0x004f, 0x0130, 0x0004}, /* index: 449, gain:45.730650db->x193.433861, DCG:1 */
+	{0x004f, 0x0134, 0x0004}, /* index: 450, gain:45.824400db->x195.532971, DCG:1 */
+	{0x004f, 0x0137, 0x0004}, /* index: 451, gain:45.918150db->x197.654861, DCG:1 */
+	{0x004f, 0x013a, 0x0004}, /* index: 452, gain:46.011900db->x199.799777, DCG:1 */
+	{0x004f, 0x013e, 0x0004}, /* index: 453, gain:46.105650db->x201.967970, DCG:1 */
+	{0x004f, 0x0141, 0x0004}, /* index: 454, gain:46.199400db->x204.159691, DCG:1 */
+	{0x004f, 0x0145, 0x0004}, /* index: 455, gain:46.293150db->x206.375197, DCG:1 */
+	{0x004f, 0x0148, 0x0004}, /* index: 456, gain:46.386900db->x208.614744, DCG:1 */
+	{0x004f, 0x014c, 0x0004}, /* index: 457, gain:46.480650db->x210.878595, DCG:1 */
+	{0x004f, 0x014f, 0x0004}, /* index: 458, gain:46.574400db->x213.167013, DCG:1 */
+	{0x004f, 0x0153, 0x0004}, /* index: 459, gain:46.668150db->x215.480265, DCG:1 */
+	{0x004f, 0x0157, 0x0004}, /* index: 460, gain:46.761900db->x217.818619, DCG:1 */
+	{0x004f, 0x015b, 0x0004}, /* index: 461, gain:46.855650db->x220.182349, DCG:1 */
+	{0x004f, 0x015e, 0x0004}, /* index: 462, gain:46.949400db->x222.571729, DCG:1 */
+	{0x004f, 0x0162, 0x0004}, /* index: 463, gain:47.043150db->x224.987039, DCG:1 */
+	{0x004f, 0x0166, 0x0004}, /* index: 464, gain:47.136900db->x227.428559, DCG:1 */
+	{0x004f, 0x016a, 0x0004}, /* index: 465, gain:47.230650db->x229.896574, DCG:1 */
+	{0x004f, 0x016e, 0x0004}, /* index: 466, gain:47.324400db->x232.391372, DCG:1 */
+	{0x004f, 0x0172, 0x0004}, /* index: 467, gain:47.418150db->x234.913243, DCG:1 */
+	{0x004f, 0x0176, 0x0004}, /* index: 468, gain:47.511900db->x237.462480, DCG:1 */
+	{0x004f, 0x017a, 0x0004}, /* index: 469, gain:47.605650db->x240.039382, DCG:1 */
+	{0x004f, 0x017e, 0x0004}, /* index: 470, gain:47.699400db->x242.644248, DCG:1 */
+	{0x004f, 0x0182, 0x0004}, /* index: 471, gain:47.793150db->x245.277381, DCG:1 */
+	{0x004f, 0x0186, 0x0004}, /* index: 472, gain:47.886900db->x247.939088, DCG:1 */
+	{0x004f, 0x018b, 0x0004}, /* index: 473, gain:47.980650db->x250.629680, DCG:1 */
+	{0x004f, 0x018f, 0x0004}, /* index: 474, gain:48.074400db->x253.349470, DCG:1 */
+};
+
+const u16 AR0237_HDR_GAIN_TABLE[AR0237_GAIN_ROWS][AR0237_GAIN_COLS] = {
+	/* analog gain 1.52x~31.43x, and if gain >=2.7, turn on DCG */
+	{0x000a, 0x0085, 0x0000}, /* index: 0, gain:3.636900db->x1.520005, DCG:0 */
+	{0x000a, 0x0086, 0x0000}, /* index: 1, gain:3.730650db->x1.536500, DCG:0 */
+	{0x000a, 0x0088, 0x0000}, /* index: 2, gain:3.824400db->x1.553174, DCG:0 */
+	{0x000a, 0x0089, 0x0000}, /* index: 3, gain:3.918150db->x1.570028, DCG:0 */
+	{0x000a, 0x008b, 0x0000}, /* index: 4, gain:4.011900db->x1.587066, DCG:0 */
+	{0x000a, 0x008c, 0x0000}, /* index: 5, gain:4.105650db->x1.604289, DCG:0 */
+	{0x000a, 0x008e, 0x0000}, /* index: 6, gain:4.199400db->x1.621698, DCG:0 */
+	{0x000a, 0x008f, 0x0000}, /* index: 7, gain:4.293150db->x1.639296, DCG:0 */
+	{0x000a, 0x0091, 0x0000}, /* index: 8, gain:4.386900db->x1.657086, DCG:0 */
+	{0x000a, 0x0092, 0x0000}, /* index: 9, gain:4.480650db->x1.675068, DCG:0 */
+	{0x000a, 0x0094, 0x0000}, /* index: 10, gain:4.574400db->x1.693246, DCG:0 */
+	{0x000a, 0x0096, 0x0000}, /* index: 11, gain:4.668150db->x1.711621, DCG:0 */
+	{0x000a, 0x0097, 0x0000}, /* index: 12, gain:4.761900db->x1.730195, DCG:0 */
+	{0x000a, 0x0099, 0x0000}, /* index: 13, gain:4.855650db->x1.748971, DCG:0 */
+	{0x000a, 0x009a, 0x0000}, /* index: 14, gain:4.949400db->x1.767950, DCG:0 */
+	{0x000a, 0x009c, 0x0000}, /* index: 15, gain:5.043150db->x1.787136, DCG:0 */
+	{0x000a, 0x009e, 0x0000}, /* index: 16, gain:5.136900db->x1.806529, DCG:0 */
+	{0x000a, 0x00a0, 0x0000}, /* index: 17, gain:5.230650db->x1.826133, DCG:0 */
+	{0x000a, 0x00a1, 0x0000}, /* index: 18, gain:5.324400db->x1.845950, DCG:0 */
+	{0x000a, 0x00a3, 0x0000}, /* index: 19, gain:5.418150db->x1.865982, DCG:0 */
+	{0x000a, 0x00a5, 0x0000}, /* index: 20, gain:5.511900db->x1.886232, DCG:0 */
+	{0x000a, 0x00a7, 0x0000}, /* index: 21, gain:5.605650db->x1.906701, DCG:0 */
+	{0x000a, 0x00a8, 0x0000}, /* index: 22, gain:5.699400db->x1.927392, DCG:0 */
+	{0x000a, 0x00aa, 0x0000}, /* index: 23, gain:5.793150db->x1.948307, DCG:0 */
+	{0x000a, 0x00ac, 0x0000}, /* index: 24, gain:5.886900db->x1.969450, DCG:0 */
+	{0x000a, 0x00ae, 0x0000}, /* index: 25, gain:5.980650db->x1.990822, DCG:0 */
+	{0x0010, 0x0080, 0x0000}, /* index: 26, gain:6.074400db->x2.012426, DCG:0 */
+	{0x0010, 0x0082, 0x0000}, /* index: 27, gain:6.168150db->x2.034265, DCG:0 */
+	{0x0010, 0x0083, 0x0000}, /* index: 28, gain:6.261900db->x2.056340, DCG:0 */
+	{0x0011, 0x0081, 0x0000}, /* index: 29, gain:6.355650db->x2.078655, DCG:0 */
+	{0x0011, 0x0082, 0x0000}, /* index: 30, gain:6.449400db->x2.101213, DCG:0 */
+	{0x0011, 0x0083, 0x0000}, /* index: 31, gain:6.543150db->x2.124015, DCG:0 */
+	{0x0012, 0x0080, 0x0000}, /* index: 32, gain:6.636900db->x2.147064, DCG:0 */
+	{0x0012, 0x0081, 0x0000}, /* index: 33, gain:6.730650db->x2.170364, DCG:0 */
+	{0x0012, 0x0083, 0x0000}, /* index: 34, gain:6.824400db->x2.193916, DCG:0 */
+	{0x0013, 0x0081, 0x0000}, /* index: 35, gain:6.918150db->x2.217724, DCG:0 */
+	{0x0013, 0x0082, 0x0000}, /* index: 36, gain:7.011900db->x2.241790, DCG:0 */
+	{0x0013, 0x0083, 0x0000}, /* index: 37, gain:7.105650db->x2.266118, DCG:0 */
+	{0x0014, 0x0080, 0x0000}, /* index: 38, gain:7.199400db->x2.290709, DCG:0 */
+	{0x0014, 0x0081, 0x0000}, /* index: 39, gain:7.293150db->x2.315568, DCG:0 */
+	{0x0014, 0x0083, 0x0000}, /* index: 40, gain:7.386900db->x2.340696, DCG:0 */
+	{0x0014, 0x0084, 0x0000}, /* index: 41, gain:7.480650db->x2.366097, DCG:0 */
+	{0x0015, 0x0080, 0x0000}, /* index: 42, gain:7.574400db->x2.391773, DCG:0 */
+	{0x0015, 0x0082, 0x0000}, /* index: 43, gain:7.668150db->x2.417728, DCG:0 */
+	{0x0015, 0x0083, 0x0000}, /* index: 44, gain:7.761900db->x2.443965, DCG:0 */
+	{0x0016, 0x0080, 0x0000}, /* index: 45, gain:7.855650db->x2.470487, DCG:0 */
+	{0x0016, 0x0081, 0x0000}, /* index: 46, gain:7.949400db->x2.497296, DCG:0 */
+	{0x0016, 0x0083, 0x0000}, /* index: 47, gain:8.043150db->x2.524396, DCG:0 */
+	{0x0016, 0x0084, 0x0000}, /* index: 48, gain:8.136900db->x2.551790, DCG:0 */
+	{0x0017, 0x0080, 0x0000}, /* index: 49, gain:8.230650db->x2.579482, DCG:0 */
+	{0x0017, 0x0082, 0x0000}, /* index: 50, gain:8.324400db->x2.607474, DCG:0 */
+	{0x0017, 0x0083, 0x0000}, /* index: 51, gain:8.418150db->x2.635770, DCG:0 */
+	{0x0018, 0x0080, 0x0000}, /* index: 52, gain:8.511900db->x2.664373, DCG:0 */
+	{0x0018, 0x0081, 0x0000}, /* index: 53, gain:8.605650db->x2.693286, DCG:0 */
+	{0x0000, 0x0081, 0x0004}, /* index: 54, gain:8.699400db->x2.722513, DCG:1 */
+	{0x0000, 0x0082, 0x0004}, /* index: 55, gain:8.793150db->x2.752057, DCG:1 */
+	{0x0001, 0x0080, 0x0004}, /* index: 56, gain:8.886900db->x2.781922, DCG:1 */
+	{0x0001, 0x0081, 0x0004}, /* index: 57, gain:8.980650db->x2.812111, DCG:1 */
+	{0x0001, 0x0082, 0x0004}, /* index: 58, gain:9.074400db->x2.842628, DCG:1 */
+	{0x0001, 0x0084, 0x0004}, /* index: 59, gain:9.168150db->x2.873476, DCG:1 */
+	{0x0002, 0x0080, 0x0004}, /* index: 60, gain:9.261900db->x2.904658, DCG:1 */
+	{0x0002, 0x0082, 0x0004}, /* index: 61, gain:9.355650db->x2.936179, DCG:1 */
+	{0x0002, 0x0083, 0x0004}, /* index: 62, gain:9.449400db->x2.968042, DCG:1 */
+	{0x0003, 0x0081, 0x0004}, /* index: 63, gain:9.543150db->x3.000250, DCG:1 */
+	{0x0003, 0x0082, 0x0004}, /* index: 64, gain:9.636900db->x3.032809, DCG:1 */
+	{0x0003, 0x0084, 0x0004}, /* index: 65, gain:9.730650db->x3.065720, DCG:1 */
+	{0x0004, 0x0080, 0x0004}, /* index: 66, gain:9.824400db->x3.098989, DCG:1 */
+	{0x0004, 0x0082, 0x0004}, /* index: 67, gain:9.918150db->x3.132618, DCG:1 */
+	{0x0004, 0x0083, 0x0004}, /* index: 68, gain:10.011900db->x3.166613, DCG:1 */
+	{0x0004, 0x0085, 0x0004}, /* index: 69, gain:10.105650db->x3.200977, DCG:1 */
+	{0x0005, 0x0080, 0x0004}, /* index: 70, gain:10.199400db->x3.235713, DCG:1 */
+	{0x0005, 0x0082, 0x0004}, /* index: 71, gain:10.293150db->x3.270826, DCG:1 */
+	{0x0005, 0x0083, 0x0004}, /* index: 72, gain:10.386900db->x3.306321, DCG:1 */
+	{0x0006, 0x0080, 0x0004}, /* index: 73, gain:10.480650db->x3.342201, DCG:1 */
+	{0x0006, 0x0082, 0x0004}, /* index: 74, gain:10.574400db->x3.378469, DCG:1 */
+	{0x0006, 0x0083, 0x0004}, /* index: 75, gain:10.668150db->x3.415132, DCG:1 */
+	{0x0006, 0x0085, 0x0004}, /* index: 76, gain:10.761900db->x3.452192, DCG:1 */
+	{0x0007, 0x0081, 0x0004}, /* index: 77, gain:10.855650db->x3.489655, DCG:1 */
+	{0x0007, 0x0082, 0x0004}, /* index: 78, gain:10.949400db->x3.527524, DCG:1 */
+	{0x0007, 0x0084, 0x0004}, /* index: 79, gain:11.043150db->x3.565804, DCG:1 */
+	{0x0008, 0x0080, 0x0004}, /* index: 80, gain:11.136900db->x3.604500, DCG:1 */
+	{0x0008, 0x0081, 0x0004}, /* index: 81, gain:11.230650db->x3.643615, DCG:1 */
+	{0x0008, 0x0083, 0x0004}, /* index: 82, gain:11.324400db->x3.683155, DCG:1 */
+	{0x0008, 0x0084, 0x0004}, /* index: 83, gain:11.418150db->x3.723124, DCG:1 */
+	{0x0009, 0x0080, 0x0004}, /* index: 84, gain:11.511900db->x3.763527, DCG:1 */
+	{0x0009, 0x0081, 0x0004}, /* index: 85, gain:11.605650db->x3.804368, DCG:1 */
+	{0x0009, 0x0083, 0x0004}, /* index: 86, gain:11.699400db->x3.845652, DCG:1 */
+	{0x0009, 0x0084, 0x0004}, /* index: 87, gain:11.793150db->x3.887385, DCG:1 */
+	{0x0009, 0x0086, 0x0004}, /* index: 88, gain:11.886900db->x3.929570, DCG:1 */
+	{0x000a, 0x0080, 0x0004}, /* index: 89, gain:11.980650db->x3.972213, DCG:1 */
+	{0x000a, 0x0082, 0x0004}, /* index: 90, gain:12.074400db->x4.015319, DCG:1 */
+	{0x000a, 0x0083, 0x0004}, /* index: 91, gain:12.168150db->x4.058892, DCG:1 */
+	{0x000a, 0x0085, 0x0004}, /* index: 92, gain:12.261900db->x4.102938, DCG:1 */
+	{0x000a, 0x0086, 0x0004}, /* index: 93, gain:12.355650db->x4.147463, DCG:1 */
+	{0x000a, 0x0088, 0x0004}, /* index: 94, gain:12.449400db->x4.192470, DCG:1 */
+	{0x000a, 0x0089, 0x0004}, /* index: 95, gain:12.543150db->x4.237966, DCG:1 */
+	{0x000a, 0x008b, 0x0004}, /* index: 96, gain:12.636900db->x4.283956, DCG:1 */
+	{0x000a, 0x008c, 0x0004}, /* index: 97, gain:12.730650db->x4.330445, DCG:1 */
+	{0x000a, 0x008e, 0x0004}, /* index: 98, gain:12.824400db->x4.377438, DCG:1 */
+	{0x000a, 0x008f, 0x0004}, /* index: 99, gain:12.918150db->x4.424941, DCG:1 */
+	{0x000a, 0x0091, 0x0004}, /* index: 100, gain:13.011900db->x4.472960, DCG:1 */
+	{0x000a, 0x0092, 0x0004}, /* index: 101, gain:13.105650db->x4.521500, DCG:1 */
+	{0x000a, 0x0094, 0x0004}, /* index: 102, gain:13.199400db->x4.570566, DCG:1 */
+	{0x000a, 0x0096, 0x0004}, /* index: 103, gain:13.293150db->x4.620165, DCG:1 */
+	{0x000a, 0x0097, 0x0004}, /* index: 104, gain:13.386900db->x4.670302, DCG:1 */
+	{0x000a, 0x0099, 0x0004}, /* index: 105, gain:13.480650db->x4.720984, DCG:1 */
+	{0x000a, 0x009a, 0x0004}, /* index: 106, gain:13.574400db->x4.772215, DCG:1 */
+	{0x000a, 0x009c, 0x0004}, /* index: 107, gain:13.668150db->x4.824002, DCG:1 */
+	{0x000a, 0x009e, 0x0004}, /* index: 108, gain:13.761900db->x4.876351, DCG:1 */
+	{0x000a, 0x00a0, 0x0004}, /* index: 109, gain:13.855650db->x4.929269, DCG:1 */
+	{0x000a, 0x00a1, 0x0004}, /* index: 110, gain:13.949400db->x4.982760, DCG:1 */
+	{0x000a, 0x00a3, 0x0004}, /* index: 111, gain:14.043150db->x5.036832, DCG:1 */
+	{0x000a, 0x00a5, 0x0004}, /* index: 112, gain:14.136900db->x5.091491, DCG:1 */
+	{0x000a, 0x00a7, 0x0004}, /* index: 113, gain:14.230650db->x5.146743, DCG:1 */
+	{0x000a, 0x00a8, 0x0004}, /* index: 114, gain:14.324400db->x5.202595, DCG:1 */
+	{0x000a, 0x00aa, 0x0004}, /* index: 115, gain:14.418150db->x5.259052, DCG:1 */
+	{0x000a, 0x00ac, 0x0004}, /* index: 116, gain:14.511900db->x5.316123, DCG:1 */
+	{0x000a, 0x00ae, 0x0004}, /* index: 117, gain:14.605650db->x5.373812, DCG:1 */
+	{0x0010, 0x0080, 0x0004}, /* index: 118, gain:14.699400db->x5.432128, DCG:1 */
+	{0x0010, 0x0082, 0x0004}, /* index: 119, gain:14.793150db->x5.491077, DCG:1 */
+	{0x0010, 0x0083, 0x0004}, /* index: 120, gain:14.886900db->x5.550665, DCG:1 */
+	{0x0011, 0x0081, 0x0004}, /* index: 121, gain:14.980650db->x5.610900, DCG:1 */
+	{0x0011, 0x0082, 0x0004}, /* index: 122, gain:15.074400db->x5.671788, DCG:1 */
+	{0x0011, 0x0083, 0x0004}, /* index: 123, gain:15.168150db->x5.733337, DCG:1 */
+	{0x0012, 0x0080, 0x0004}, /* index: 124, gain:15.261900db->x5.795555, DCG:1 */
+	{0x0012, 0x0081, 0x0004}, /* index: 125, gain:15.355650db->x5.858447, DCG:1 */
+	{0x0012, 0x0083, 0x0004}, /* index: 126, gain:15.449400db->x5.922022, DCG:1 */
+	{0x0013, 0x0080, 0x0004}, /* index: 127, gain:15.543150db->x5.986287, DCG:1 */
+	{0x0013, 0x0082, 0x0004}, /* index: 128, gain:15.636900db->x6.051249, DCG:1 */
+	{0x0013, 0x0083, 0x0004}, /* index: 129, gain:15.730650db->x6.116916, DCG:1 */
+	{0x0014, 0x0080, 0x0004}, /* index: 130, gain:15.824400db->x6.183295, DCG:1 */
+	{0x0014, 0x0081, 0x0004}, /* index: 131, gain:15.918150db->x6.250396, DCG:1 */
+	{0x0014, 0x0083, 0x0004}, /* index: 132, gain:16.011900db->x6.318224, DCG:1 */
+	{0x0014, 0x0084, 0x0004}, /* index: 133, gain:16.105650db->x6.386788, DCG:1 */
+	{0x0015, 0x0080, 0x0004}, /* index: 134, gain:16.199400db->x6.456096, DCG:1 */
+	{0x0015, 0x0081, 0x0004}, /* index: 135, gain:16.293150db->x6.526157, DCG:1 */
+	{0x0015, 0x0083, 0x0004}, /* index: 136, gain:16.386900db->x6.596977, DCG:1 */
+	{0x0016, 0x0080, 0x0004}, /* index: 137, gain:16.480650db->x6.668567, DCG:1 */
+	{0x0016, 0x0081, 0x0004}, /* index: 138, gain:16.574400db->x6.740933, DCG:1 */
+	{0x0016, 0x0083, 0x0004}, /* index: 139, gain:16.668150db->x6.814084, DCG:1 */
+	{0x0016, 0x0084, 0x0004}, /* index: 140, gain:16.761900db->x6.888030, DCG:1 */
+	{0x0017, 0x0080, 0x0004}, /* index: 141, gain:16.855650db->x6.962777, DCG:1 */
+	{0x0017, 0x0082, 0x0004}, /* index: 142, gain:16.949400db->x7.038336, DCG:1 */
+	{0x0017, 0x0083, 0x0004}, /* index: 143, gain:17.043150db->x7.114715, DCG:1 */
+	{0x0018, 0x0080, 0x0004}, /* index: 144, gain:17.136900db->x7.191923, DCG:1 */
+	{0x0018, 0x0081, 0x0004}, /* index: 145, gain:17.230650db->x7.269968, DCG:1 */
+	{0x0018, 0x0082, 0x0004}, /* index: 146, gain:17.324400db->x7.348860, DCG:1 */
+	{0x0018, 0x0084, 0x0004}, /* index: 147, gain:17.418150db->x7.428609, DCG:1 */
+	{0x0019, 0x0080, 0x0004}, /* index: 148, gain:17.511900db->x7.509223, DCG:1 */
+	{0x0019, 0x0081, 0x0004}, /* index: 149, gain:17.605650db->x7.590712, DCG:1 */
+	{0x0019, 0x0082, 0x0004}, /* index: 150, gain:17.699400db->x7.673085, DCG:1 */
+	{0x0019, 0x0084, 0x0004}, /* index: 151, gain:17.793150db->x7.756352, DCG:1 */
+	{0x0019, 0x0085, 0x0004}, /* index: 152, gain:17.886900db->x7.840522, DCG:1 */
+	{0x001a, 0x0080, 0x0004}, /* index: 153, gain:17.980650db->x7.925606, DCG:1 */
+	{0x001a, 0x0082, 0x0004}, /* index: 154, gain:18.074400db->x8.011614, DCG:1 */
+	{0x001a, 0x0083, 0x0004}, /* index: 155, gain:18.168150db->x8.098554, DCG:1 */
+	{0x001a, 0x0084, 0x0004}, /* index: 156, gain:18.261900db->x8.186438, DCG:1 */
+	{0x001a, 0x0086, 0x0004}, /* index: 157, gain:18.355650db->x8.275276, DCG:1 */
+	{0x001a, 0x0087, 0x0004}, /* index: 158, gain:18.449400db->x8.365078, DCG:1 */
+	{0x001a, 0x0089, 0x0004}, /* index: 159, gain:18.543150db->x8.455854, DCG:1 */
+	{0x001a, 0x008a, 0x0004}, /* index: 160, gain:18.636900db->x8.547616, DCG:1 */
+	{0x001a, 0x008c, 0x0004}, /* index: 161, gain:18.730650db->x8.640373, DCG:1 */
+	{0x001a, 0x008d, 0x0004}, /* index: 162, gain:18.824400db->x8.734137, DCG:1 */
+	{0x001a, 0x008f, 0x0004}, /* index: 163, gain:18.918150db->x8.828918, DCG:1 */
+	{0x001a, 0x0090, 0x0004}, /* index: 164, gain:19.011900db->x8.924728, DCG:1 */
+	{0x001a, 0x0092, 0x0004}, /* index: 165, gain:19.105650db->x9.021578, DCG:1 */
+	{0x001a, 0x0094, 0x0004}, /* index: 166, gain:19.199400db->x9.119478, DCG:1 */
+	{0x001a, 0x0095, 0x0004}, /* index: 167, gain:19.293150db->x9.218441, DCG:1 */
+	{0x001a, 0x0097, 0x0004}, /* index: 168, gain:19.386900db->x9.318478, DCG:1 */
+	{0x001a, 0x0098, 0x0004}, /* index: 169, gain:19.480650db->x9.419601, DCG:1 */
+	{0x001a, 0x009a, 0x0004}, /* index: 170, gain:19.574400db->x9.521821, DCG:1 */
+	{0x001a, 0x009c, 0x0004}, /* index: 171, gain:19.668150db->x9.625150, DCG:1 */
+	{0x001a, 0x009d, 0x0004}, /* index: 172, gain:19.761900db->x9.729600, DCG:1 */
+	{0x001a, 0x009f, 0x0004}, /* index: 173, gain:19.855650db->x9.835184, DCG:1 */
+	{0x001a, 0x00a1, 0x0004}, /* index: 174, gain:19.949400db->x9.941914, DCG:1 */
+	{0x001a, 0x00a3, 0x0004}, /* index: 175, gain:20.043150db->x10.049802, DCG:1 */
+	{0x001a, 0x00a4, 0x0004}, /* index: 176, gain:20.136900db->x10.158861, DCG:1 */
+	{0x001a, 0x00a6, 0x0004}, /* index: 177, gain:20.230650db->x10.269103, DCG:1 */
+	{0x001a, 0x00a8, 0x0004}, /* index: 178, gain:20.324400db->x10.380541, DCG:1 */
+	{0x001a, 0x00aa, 0x0004}, /* index: 179, gain:20.418150db->x10.493189, DCG:1 */
+	{0x001a, 0x00ac, 0x0004}, /* index: 180, gain:20.511900db->x10.607059, DCG:1 */
+	{0x001a, 0x00ae, 0x0004}, /* index: 181, gain:20.605650db->x10.722165, DCG:1 */
+	{0x0020, 0x0080, 0x0004}, /* index: 182, gain:20.699400db->x10.838520, DCG:1 */
+	{0x0020, 0x0081, 0x0004}, /* index: 183, gain:20.793150db->x10.956138, DCG:1 */
+	{0x0020, 0x0083, 0x0004}, /* index: 184, gain:20.886900db->x11.075032, DCG:1 */
+	{0x0021, 0x0080, 0x0004}, /* index: 185, gain:20.980650db->x11.195217, DCG:1 */
+	{0x0021, 0x0082, 0x0004}, /* index: 186, gain:21.074400db->x11.316705, DCG:1 */
+	{0x0021, 0x0083, 0x0004}, /* index: 187, gain:21.168150db->x11.439512, DCG:1 */
+	{0x0022, 0x0080, 0x0004}, /* index: 188, gain:21.261900db->x11.563652, DCG:1 */
+	{0x0022, 0x0081, 0x0004}, /* index: 189, gain:21.355650db->x11.689138, DCG:1 */
+	{0x0022, 0x0082, 0x0004}, /* index: 190, gain:21.449400db->x11.815987, DCG:1 */
+	{0x0023, 0x0080, 0x0004}, /* index: 191, gain:21.543150db->x11.944212, DCG:1 */
+	{0x0023, 0x0082, 0x0004}, /* index: 192, gain:21.636900db->x12.073828, DCG:1 */
+	{0x0023, 0x0083, 0x0004}, /* index: 193, gain:21.730650db->x12.204852, DCG:1 */
+	{0x0024, 0x0080, 0x0004}, /* index: 194, gain:21.824400db->x12.337296, DCG:1 */
+	{0x0024, 0x0081, 0x0004}, /* index: 195, gain:21.918150db->x12.471179, DCG:1 */
+	{0x0024, 0x0083, 0x0004}, /* index: 196, gain:22.011900db->x12.606514, DCG:1 */
+	{0x0024, 0x0084, 0x0004}, /* index: 197, gain:22.105650db->x12.743317, DCG:1 */
+	{0x0025, 0x0080, 0x0004}, /* index: 198, gain:22.199400db->x12.881606, DCG:1 */
+	{0x0025, 0x0081, 0x0004}, /* index: 199, gain:22.293150db->x13.021395, DCG:1 */
+	{0x0025, 0x0083, 0x0004}, /* index: 200, gain:22.386900db->x13.162701, DCG:1 */
+	{0x0026, 0x0080, 0x0004}, /* index: 201, gain:22.480650db->x13.305540, DCG:1 */
+	{0x0026, 0x0081, 0x0004}, /* index: 202, gain:22.574400db->x13.449929, DCG:1 */
+	{0x0026, 0x0083, 0x0004}, /* index: 203, gain:22.668150db->x13.595886, DCG:1 */
+	{0x0026, 0x0084, 0x0004}, /* index: 204, gain:22.761900db->x13.743426, DCG:1 */
+	{0x0027, 0x0080, 0x0004}, /* index: 205, gain:22.855650db->x13.892567, DCG:1 */
+	{0x0027, 0x0082, 0x0004}, /* index: 206, gain:22.949400db->x14.043327, DCG:1 */
+	{0x0027, 0x0083, 0x0004}, /* index: 207, gain:23.043150db->x14.195722, DCG:1 */
+	{0x0027, 0x0084, 0x0004}, /* index: 208, gain:23.136900db->x14.349772, DCG:1 */
+	{0x0028, 0x0081, 0x0004}, /* index: 209, gain:23.230650db->x14.505493, DCG:1 */
+	{0x0028, 0x0082, 0x0004}, /* index: 210, gain:23.324400db->x14.662904, DCG:1 */
+	{0x0028, 0x0084, 0x0004}, /* index: 211, gain:23.418150db->x14.822024, DCG:1 */
+	{0x0028, 0x0085, 0x0004}, /* index: 212, gain:23.511900db->x14.982870, DCG:1 */
+	{0x0029, 0x0081, 0x0004}, /* index: 213, gain:23.605650db->x15.145461, DCG:1 */
+	{0x0029, 0x0082, 0x0004}, /* index: 214, gain:23.699400db->x15.309817, DCG:1 */
+	{0x0029, 0x0083, 0x0004}, /* index: 215, gain:23.793150db->x15.475956, DCG:1 */
+	{0x0029, 0x0085, 0x0004}, /* index: 216, gain:23.886900db->x15.643899, DCG:1 */
+	{0x002a, 0x0080, 0x0004}, /* index: 217, gain:23.980650db->x15.813664, DCG:1 */
+	{0x002a, 0x0081, 0x0004}, /* index: 218, gain:24.074400db->x15.985271, DCG:1 */
+	{0x002a, 0x0083, 0x0004}, /* index: 219, gain:24.168150db->x16.158740, DCG:1 */
+	{0x002a, 0x0084, 0x0004}, /* index: 220, gain:24.261900db->x16.334092, DCG:1 */
+	{0x002a, 0x0086, 0x0004}, /* index: 221, gain:24.355650db->x16.511347, DCG:1 */
+	{0x002a, 0x0087, 0x0004}, /* index: 222, gain:24.449400db->x16.690525, DCG:1 */
+	{0x002a, 0x0088, 0x0004}, /* index: 223, gain:24.543150db->x16.871648, DCG:1 */
+	{0x002a, 0x008a, 0x0004}, /* index: 224, gain:24.636900db->x17.054736, DCG:1 */
+	{0x002a, 0x008b, 0x0004}, /* index: 225, gain:24.730650db->x17.239811, DCG:1 */
+	{0x002a, 0x008d, 0x0004}, /* index: 226, gain:24.824400db->x17.426894, DCG:1 */
+	{0x002a, 0x008f, 0x0004}, /* index: 227, gain:24.918150db->x17.616008, DCG:1 */
+	{0x002a, 0x0090, 0x0004}, /* index: 228, gain:25.011900db->x17.807174, DCG:1 */
+	{0x002a, 0x0092, 0x0004}, /* index: 229, gain:25.105650db->x18.000414, DCG:1 */
+	{0x002a, 0x0093, 0x0004}, /* index: 230, gain:25.199400db->x18.195752, DCG:1 */
+	{0x002a, 0x0095, 0x0004}, /* index: 231, gain:25.293150db->x18.393209, DCG:1 */
+	{0x002a, 0x0096, 0x0004}, /* index: 232, gain:25.386900db->x18.592809, DCG:1 */
+	{0x002a, 0x0098, 0x0004}, /* index: 233, gain:25.480650db->x18.794575, DCG:1 */
+	{0x002a, 0x009a, 0x0004}, /* index: 234, gain:25.574400db->x18.998530, DCG:1 */
+	{0x002a, 0x009b, 0x0004}, /* index: 235, gain:25.668150db->x19.204699, DCG:1 */
+	{0x002a, 0x009d, 0x0004}, /* index: 236, gain:25.761900db->x19.413105, DCG:1 */
+	{0x002a, 0x009f, 0x0004}, /* index: 237, gain:25.855650db->x19.623772, DCG:1 */
+	{0x002a, 0x00a1, 0x0004}, /* index: 238, gain:25.949400db->x19.836726, DCG:1 */
+	{0x002a, 0x00a2, 0x0004}, /* index: 239, gain:26.043150db->x20.051991, DCG:1 */
+	{0x002a, 0x00a4, 0x0004}, /* index: 240, gain:26.136900db->x20.269592, DCG:1 */
+	{0x002a, 0x00a6, 0x0004}, /* index: 241, gain:26.230650db->x20.489554, DCG:1 */
+	{0x002a, 0x00a8, 0x0004}, /* index: 242, gain:26.324400db->x20.711903, DCG:1 */
+	{0x002a, 0x00a9, 0x0004}, /* index: 243, gain:26.418150db->x20.936665, DCG:1 */
+	{0x002a, 0x00ab, 0x0004}, /* index: 244, gain:26.511900db->x21.163866, DCG:1 */
+	{0x002a, 0x00ad, 0x0004}, /* index: 245, gain:26.605650db->x21.393532, DCG:1 */
+	{0x0030, 0x0080, 0x0004}, /* index: 246, gain:26.699400db->x21.625691, DCG:1 */
+	{0x0030, 0x0081, 0x0004}, /* index: 247, gain:26.793150db->x21.860370, DCG:1 */
+	{0x0030, 0x0082, 0x0004}, /* index: 248, gain:26.886900db->x22.097595, DCG:1 */
+	{0x0031, 0x0080, 0x0004}, /* index: 249, gain:26.980650db->x22.337394, DCG:1 */
+	{0x0031, 0x0081, 0x0004}, /* index: 250, gain:27.074400db->x22.579795, DCG:1 */
+	{0x0031, 0x0083, 0x0004}, /* index: 251, gain:27.168150db->x22.824827, DCG:1 */
+	{0x0031, 0x0084, 0x0004}, /* index: 252, gain:27.261900db->x23.072518, DCG:1 */
+	{0x0032, 0x0081, 0x0004}, /* index: 253, gain:27.355650db->x23.322897, DCG:1 */
+	{0x0032, 0x0082, 0x0004}, /* index: 254, gain:27.449400db->x23.575993, DCG:1 */
+	{0x0033, 0x0080, 0x0004}, /* index: 255, gain:27.543150db->x23.831836, DCG:1 */
+	{0x0033, 0x0081, 0x0004}, /* index: 256, gain:27.636900db->x24.090455, DCG:1 */
+	{0x0033, 0x0083, 0x0004}, /* index: 257, gain:27.730650db->x24.351880, DCG:1 */
+	{0x0033, 0x0084, 0x0004}, /* index: 258, gain:27.824400db->x24.616143, DCG:1 */
+	{0x0034, 0x0081, 0x0004}, /* index: 259, gain:27.918150db->x24.883273, DCG:1 */
+	{0x0034, 0x0082, 0x0004}, /* index: 260, gain:28.011900db->x25.153302, DCG:1 */
+	{0x0034, 0x0084, 0x0004}, /* index: 261, gain:28.105650db->x25.426261, DCG:1 */
+	{0x0034, 0x0085, 0x0004}, /* index: 262, gain:28.199400db->x25.702182, DCG:1 */
+	{0x0035, 0x0081, 0x0004}, /* index: 263, gain:28.293150db->x25.981098, DCG:1 */
+	{0x0035, 0x0082, 0x0004}, /* index: 264, gain:28.386900db->x26.263040, DCG:1 */
+	{0x0035, 0x0084, 0x0004}, /* index: 265, gain:28.480650db->x26.548042, DCG:1 */
+	{0x0036, 0x0081, 0x0004}, /* index: 266, gain:28.574400db->x26.836137, DCG:1 */
+	{0x0036, 0x0082, 0x0004}, /* index: 267, gain:28.668150db->x27.127358, DCG:1 */
+	{0x0036, 0x0084, 0x0004}, /* index: 268, gain:28.761900db->x27.421739, DCG:1 */
+	{0x0037, 0x0080, 0x0004}, /* index: 269, gain:28.855650db->x27.719315, DCG:1 */
+	{0x0037, 0x0081, 0x0004}, /* index: 270, gain:28.949400db->x28.020121, DCG:1 */
+	{0x0037, 0x0083, 0x0004}, /* index: 271, gain:29.043150db->x28.324190, DCG:1 */
+	{0x0037, 0x0084, 0x0004}, /* index: 272, gain:29.136900db->x28.631559, DCG:1 */
+	{0x0038, 0x0080, 0x0004}, /* index: 273, gain:29.230650db->x28.942264, DCG:1 */
+	{0x0038, 0x0082, 0x0004}, /* index: 274, gain:29.324400db->x29.256340, DCG:1 */
+	{0x0038, 0x0083, 0x0004}, /* index: 275, gain:29.418150db->x29.573825, DCG:1 */
+	{0x0038, 0x0085, 0x0004}, /* index: 276, gain:29.511900db->x29.894755, DCG:1 */
+	{0x0039, 0x0080, 0x0004}, /* index: 277, gain:29.605650db->x30.219168, DCG:1 */
+	{0x0039, 0x0082, 0x0004}, /* index: 278, gain:29.699400db->x30.547101, DCG:1 */
+	{0x0039, 0x0083, 0x0004}, /* index: 279, gain:29.793150db->x30.878593, DCG:1 */
+	{0x0039, 0x0085, 0x0004}, /* index: 280, gain:29.886900db->x31.213682, DCG:1 */
+	{0x003a, 0x0080, 0x0004}, /* index: 281, gain:29.980650db->x31.552407, DCG:1 */
+	{0x003a, 0x0081, 0x0004}, /* index: 282, gain:30.074400db->x31.894809, DCG:1 */
+	{0x003a, 0x0082, 0x0004}, /* index: 283, gain:30.168150db->x32.240925, DCG:1 */
+	{0x003a, 0x0084, 0x0004}, /* index: 284, gain:30.261900db->x32.590798, DCG:1 */
+	{0x003a, 0x0085, 0x0004}, /* index: 285, gain:30.355650db->x32.944468, DCG:1 */
+	{0x003a, 0x0087, 0x0004}, /* index: 286, gain:30.449400db->x33.301976, DCG:1 */
+	{0x003a, 0x0088, 0x0004}, /* index: 287, gain:30.543150db->x33.663363, DCG:1 */
+	{0x003a, 0x008a, 0x0004}, /* index: 288, gain:30.636900db->x34.028672, DCG:1 */
+	{0x003a, 0x008b, 0x0004}, /* index: 289, gain:30.730650db->x34.397945, DCG:1 */
+	{0x003a, 0x008d, 0x0004}, /* index: 290, gain:30.824400db->x34.771226, DCG:1 */
+	{0x003a, 0x008e, 0x0004}, /* index: 291, gain:30.918150db->x35.148557, DCG:1 */
+	{0x003a, 0x0090, 0x0004}, /* index: 292, gain:31.011900db->x35.529983, DCG:1 */
+	{0x003a, 0x0091, 0x0004}, /* index: 293, gain:31.105650db->x35.915548, DCG:1 */
+	{0x003a, 0x0093, 0x0004}, /* index: 294, gain:31.199400db->x36.305298, DCG:1 */
+	{0x003a, 0x0094, 0x0004}, /* index: 295, gain:31.293150db->x36.699276, DCG:1 */
+	{0x003a, 0x0096, 0x0004}, /* index: 296, gain:31.386900db->x37.097530, DCG:1 */
+	{0x003a, 0x0098, 0x0004}, /* index: 297, gain:31.480650db->x37.500106, DCG:1 */
+	{0x003a, 0x0099, 0x0004}, /* index: 298, gain:31.574400db->x37.907051, DCG:1 */
+	{0x003a, 0x009b, 0x0004}, /* index: 299, gain:31.668150db->x38.318412, DCG:1 */
+	{0x003a, 0x009d, 0x0004}, /* index: 300, gain:31.761900db->x38.734237, DCG:1 */
+	{0x003a, 0x009e, 0x0004}, /* index: 301, gain:31.855650db->x39.154574, DCG:1 */
+	{0x003a, 0x00a0, 0x0004}, /* index: 302, gain:31.949400db->x39.579472, DCG:1 */
+	{0x003a, 0x00a2, 0x0004}, /* index: 303, gain:32.043150db->x40.008982, DCG:1 */
+	{0x003a, 0x00a4, 0x0004}, /* index: 304, gain:32.136900db->x40.443152, DCG:1 */
+	{0x003a, 0x00a5, 0x0004}, /* index: 305, gain:32.230650db->x40.882034, DCG:1 */
+	{0x003a, 0x00a7, 0x0004}, /* index: 306, gain:32.324400db->x41.325679, DCG:1 */
+	{0x003a, 0x00a9, 0x0004}, /* index: 307, gain:32.418150db->x41.774138, DCG:1 */
+	{0x003a, 0x00ab, 0x0004}, /* index: 308, gain:32.511900db->x42.227464, DCG:1 */
+	{0x003a, 0x00ad, 0x0004}, /* index: 309, gain:32.605650db->x42.685709, DCG:1 */
+	{0x003a, 0x00af, 0x0004}, /* index: 310, gain:32.699400db->x43.148927, DCG:1 */
+	{0x003a, 0x00b1, 0x0004}, /* index: 311, gain:32.793150db->x43.617172, DCG:1 */
+	{0x003a, 0x00b2, 0x0004}, /* index: 312, gain:32.886900db->x44.090498, DCG:1 */
+	{0x003a, 0x00b4, 0x0004}, /* index: 313, gain:32.980650db->x44.568960, DCG:1 */
+	{0x003a, 0x00b6, 0x0004}, /* index: 314, gain:33.074400db->x45.052615, DCG:1 */
+	{0x003a, 0x00b8, 0x0004}, /* index: 315, gain:33.168150db->x45.541518, DCG:1 */
+	{0x003a, 0x00ba, 0x0004}, /* index: 316, gain:33.261900db->x46.035726, DCG:1 */
+	{0x003a, 0x00bc, 0x0004}, /* index: 317, gain:33.355650db->x46.535298, DCG:1 */
+	{0x003a, 0x00be, 0x0004}, /* index: 318, gain:33.449400db->x47.040291, DCG:1 */
+	{0x003a, 0x00c1, 0x0004}, /* index: 319, gain:33.543150db->x47.550764, DCG:1 */
+	{0x003a, 0x00c3, 0x0004}, /* index: 320, gain:33.636900db->x48.066777, DCG:1 */
+	{0x003a, 0x00c5, 0x0004}, /* index: 321, gain:33.730650db->x48.588389, DCG:1 */
+	{0x003a, 0x00c7, 0x0004}, /* index: 322, gain:33.824400db->x49.115662, DCG:1 */
+	{0x003a, 0x00c9, 0x0004}, /* index: 323, gain:33.918150db->x49.648656, DCG:1 */
+	{0x003a, 0x00cb, 0x0004}, /* index: 324, gain:34.011900db->x50.187435, DCG:1 */
+	{0x003a, 0x00cd, 0x0004}, /* index: 325, gain:34.105650db->x50.732060, DCG:1 */
+	{0x003a, 0x00d0, 0x0004}, /* index: 326, gain:34.199400db->x51.282596, DCG:1 */
+	{0x003a, 0x00d2, 0x0004}, /* index: 327, gain:34.293150db->x51.839106, DCG:1 */
+	{0x003a, 0x00d4, 0x0004}, /* index: 328, gain:34.386900db->x52.401655, DCG:1 */
+	{0x003a, 0x00d6, 0x0004}, /* index: 329, gain:34.480650db->x52.970308, DCG:1 */
+	{0x003a, 0x00d9, 0x0004}, /* index: 330, gain:34.574400db->x53.545133, DCG:1 */
+	{0x003a, 0x00db, 0x0004}, /* index: 331, gain:34.668150db->x54.126195, DCG:1 */
+	{0x003a, 0x00de, 0x0004}, /* index: 332, gain:34.761900db->x54.713563, DCG:1 */
+	{0x003a, 0x00e0, 0x0004}, /* index: 333, gain:34.855650db->x55.307305, DCG:1 */
+	{0x003a, 0x00e2, 0x0004}, /* index: 334, gain:34.949400db->x55.907491, DCG:1 */
+	{0x003a, 0x00e5, 0x0004}, /* index: 335, gain:35.043150db->x56.514189, DCG:1 */
+	{0x003a, 0x00e7, 0x0004}, /* index: 336, gain:35.136900db->x57.127471, DCG:1 */
+	{0x003a, 0x00ea, 0x0004}, /* index: 337, gain:35.230650db->x57.747409, DCG:1 */
+	{0x003a, 0x00ec, 0x0004}, /* index: 338, gain:35.324400db->x58.374073, DCG:1 */
+	{0x003a, 0x00ef, 0x0004}, /* index: 339, gain:35.418150db->x59.007539, DCG:1 */
+	{0x003a, 0x00f2, 0x0004}, /* index: 340, gain:35.511900db->x59.647878, DCG:1 */
+	{0x003a, 0x00f4, 0x0004}, /* index: 341, gain:35.605650db->x60.295167, DCG:1 */
+	{0x003a, 0x00f7, 0x0004}, /* index: 342, gain:35.699400db->x60.949479, DCG:1 */
+	{0x003a, 0x00fa, 0x0004}, /* index: 343, gain:35.793150db->x61.610892, DCG:1 */
+	{0x003a, 0x00fc, 0x0004}, /* index: 344, gain:35.886900db->x62.279483, DCG:1 */
+	{0x003a, 0x00ff, 0x0004}, /* index: 345, gain:35.980650db->x62.955329, DCG:1 */
+	{0x003a, 0x0102, 0x0004}, /* index: 346, gain:36.074400db->x63.638510, DCG:1 */
+	{0x003a, 0x0105, 0x0004}, /* index: 347, gain:36.168150db->x64.329104, DCG:1 */
+	{0x003a, 0x0107, 0x0004}, /* index: 348, gain:36.261900db->x65.027192, DCG:1 */
+	{0x003a, 0x010a, 0x0004}, /* index: 349, gain:36.355650db->x65.732856, DCG:1 */
+	{0x003a, 0x010d, 0x0004}, /* index: 350, gain:36.449400db->x66.446177, DCG:1 */
+	{0x003a, 0x0110, 0x0004}, /* index: 351, gain:36.543150db->x67.167240, DCG:1 */
+	{0x003a, 0x0113, 0x0004}, /* index: 352, gain:36.636900db->x67.896127, DCG:1 */
+	{0x003a, 0x0116, 0x0004}, /* index: 353, gain:36.730650db->x68.632924, DCG:1 */
+	{0x003a, 0x0119, 0x0004}, /* index: 354, gain:36.824400db->x69.377716, DCG:1 */
+	{0x003a, 0x011c, 0x0004}, /* index: 355, gain:36.918150db->x70.130591, DCG:1 */
+	{0x003a, 0x011f, 0x0004}, /* index: 356, gain:37.011900db->x70.891636, DCG:1 */
+	{0x003a, 0x0122, 0x0004}, /* index: 357, gain:37.105650db->x71.660940, DCG:1 */
+	{0x003a, 0x0126, 0x0004}, /* index: 358, gain:37.199400db->x72.438592, DCG:1 */
+	{0x003a, 0x0129, 0x0004}, /* index: 359, gain:37.293150db->x73.224683, DCG:1 */
+	{0x003a, 0x012c, 0x0004}, /* index: 360, gain:37.386900db->x74.019304, DCG:1 */
+	{0x003a, 0x012f, 0x0004}, /* index: 361, gain:37.480650db->x74.822549, DCG:1 */
+	{0x003a, 0x0132, 0x0004}, /* index: 362, gain:37.574400db->x75.634510, DCG:1 */
+	{0x003a, 0x0136, 0x0004}, /* index: 363, gain:37.668150db->x76.455283, DCG:1 */
+	{0x003a, 0x0139, 0x0004}, /* index: 364, gain:37.761900db->x77.284962, DCG:1 */
+	{0x003a, 0x013d, 0x0004}, /* index: 365, gain:37.855650db->x78.123645, DCG:1 */
+	{0x003a, 0x0140, 0x0004}, /* index: 366, gain:37.949400db->x78.971430, DCG:1 */
+	{0x003a, 0x0144, 0x0004}, /* index: 367, gain:38.043150db->x79.828414, DCG:1 */
+	{0x003a, 0x0147, 0x0004}, /* index: 368, gain:38.136900db->x80.694698, DCG:1 */
+	{0x003a, 0x014b, 0x0004}, /* index: 369, gain:38.230650db->x81.570383, DCG:1 */
+	{0x003a, 0x014e, 0x0004}, /* index: 370, gain:38.324400db->x82.455570, DCG:1 */
+	{0x003a, 0x0152, 0x0004}, /* index: 371, gain:38.418150db->x83.350364, DCG:1 */
+	{0x003a, 0x0155, 0x0004}, /* index: 372, gain:38.511900db->x84.254868, DCG:1 */
+	{0x003a, 0x0159, 0x0004}, /* index: 373, gain:38.605650db->x85.169187, DCG:1 */
+	{0x003a, 0x015d, 0x0004}, /* index: 374, gain:38.699400db->x86.093428, DCG:1 */
+	{0x003a, 0x0161, 0x0004}, /* index: 375, gain:38.793150db->x87.027699, DCG:1 */
+	{0x003a, 0x0165, 0x0004}, /* index: 376, gain:38.886900db->x87.972108, DCG:1 */
+	{0x003a, 0x0168, 0x0004}, /* index: 377, gain:38.980650db->x88.926766, DCG:1 */
+	{0x003a, 0x016c, 0x0004}, /* index: 378, gain:39.074400db->x89.891784, DCG:1 */
+	{0x003a, 0x0170, 0x0004}, /* index: 379, gain:39.168150db->x90.867274, DCG:1 */
+	{0x003a, 0x0174, 0x0004}, /* index: 380, gain:39.261900db->x91.853350, DCG:1 */
+	{0x003a, 0x0178, 0x0004}, /* index: 381, gain:39.355650db->x92.850127, DCG:1 */
+	{0x003a, 0x017c, 0x0004}, /* index: 382, gain:39.449400db->x93.857720, DCG:1 */
+	{0x003a, 0x0181, 0x0004}, /* index: 383, gain:39.543150db->x94.876248, DCG:1 */
+	{0x003a, 0x0185, 0x0004}, /* index: 384, gain:39.636900db->x95.905828, DCG:1 */
+	{0x003a, 0x0189, 0x0004}, /* index: 385, gain:39.730650db->x96.946582, DCG:1 */
+	{0x003a, 0x018d, 0x0004}, /* index: 386, gain:39.824400db->x97.998629, DCG:1 */
+	{0x003a, 0x0192, 0x0004}, /* index: 387, gain:39.918150db->x99.062093, DCG:1 */
+	{0x003a, 0x0196, 0x0004}, /* index: 388, gain:40.011900db->x100.137098, DCG:1 */
+	{0x003a, 0x019a, 0x0004}, /* index: 389, gain:40.105650db->x101.223768, DCG:1 */
+	{0x003a, 0x019f, 0x0004}, /* index: 390, gain:40.199400db->x102.322231, DCG:1 */
+	{0x003a, 0x01a3, 0x0004}, /* index: 391, gain:40.293150db->x103.432614, DCG:1 */
+	{0x003a, 0x01a8, 0x0004}, /* index: 392, gain:40.386900db->x104.555047, DCG:1 */
+	{0x003a, 0x01ac, 0x0004}, /* index: 393, gain:40.480650db->x105.689660, DCG:1 */
+	{0x003a, 0x01b1, 0x0004}, /* index: 394, gain:40.574400db->x106.836586, DCG:1 */
+	{0x003a, 0x01b6, 0x0004}, /* index: 395, gain:40.668150db->x107.995958, DCG:1 */
+	{0x003a, 0x01bb, 0x0004}, /* index: 396, gain:40.761900db->x109.167911, DCG:1 */
+	{0x003a, 0x01bf, 0x0004}, /* index: 397, gain:40.855650db->x110.352582, DCG:1 */
+	{0x003a, 0x01c4, 0x0004}, /* index: 398, gain:40.949400db->x111.550109, DCG:1 */
+	{0x003a, 0x01c9, 0x0004}, /* index: 399, gain:41.043150db->x112.760632, DCG:1 */
+	{0x003a, 0x01ce, 0x0004}, /* index: 400, gain:41.136900db->x113.984290, DCG:1 */
+	{0x003a, 0x01d3, 0x0004}, /* index: 401, gain:41.230650db->x115.221228, DCG:1 */
+	{0x003a, 0x01d8, 0x0004}, /* index: 402, gain:41.324400db->x116.471589, DCG:1 */
+	{0x003a, 0x01dd, 0x0004}, /* index: 403, gain:41.418150db->x117.735518, DCG:1 */
+	{0x003a, 0x01e3, 0x0004}, /* index: 404, gain:41.511900db->x119.013164, DCG:1 */
+	{0x003a, 0x01e8, 0x0004}, /* index: 405, gain:41.605650db->x120.304674, DCG:1 */
+	{0x003a, 0x01ed, 0x0004}, /* index: 406, gain:41.699400db->x121.610199, DCG:1 */
+	{0x003a, 0x01f2, 0x0004}, /* index: 407, gain:41.793150db->x122.929892, DCG:1 */
+	{0x003a, 0x01f8, 0x0004}, /* index: 408, gain:41.886900db->x124.263906, DCG:1 */
+	{0x003a, 0x01fd, 0x0004}, /* index: 409, gain:41.980650db->x125.612396, DCG:1 */
+	{0x003a, 0x0203, 0x0004}, /* index: 410, gain:42.074400db->x126.975520, DCG:1 */
+	{0x003a, 0x0208, 0x0004}, /* index: 411, gain:42.168150db->x128.353436, DCG:1 */
+	{0x003a, 0x020e, 0x0004}, /* index: 412, gain:42.261900db->x129.746305, DCG:1 */
+	{0x003a, 0x0214, 0x0004}, /* index: 413, gain:42.355650db->x131.154290, DCG:1 */
+	{0x003a, 0x021a, 0x0004}, /* index: 414, gain:42.449400db->x132.577553, DCG:1 */
+	{0x003a, 0x021f, 0x0004}, /* index: 415, gain:42.543150db->x134.016262, DCG:1 */
+	{0x003a, 0x0225, 0x0004}, /* index: 416, gain:42.636900db->x135.470583, DCG:1 */
+	{0x003a, 0x022b, 0x0004}, /* index: 417, gain:42.730650db->x136.940686, DCG:1 */
+	{0x003a, 0x0231, 0x0004}, /* index: 418, gain:42.824400db->x138.426743, DCG:1 */
+	{0x003a, 0x0237, 0x0004}, /* index: 419, gain:42.918150db->x139.928926, DCG:1 */
+	{0x003a, 0x023e, 0x0004}, /* index: 420, gain:43.011900db->x141.447410, DCG:1 */
+	{0x003a, 0x0244, 0x0004}, /* index: 421, gain:43.105650db->x142.982373, DCG:1 */
+	{0x003a, 0x024a, 0x0004}, /* index: 422, gain:43.199400db->x144.533993, DCG:1 */
+	{0x003a, 0x0251, 0x0004}, /* index: 423, gain:43.293150db->x146.102450, DCG:1 */
+	{0x003a, 0x0257, 0x0004}, /* index: 424, gain:43.386900db->x147.687929, DCG:1 */
+	{0x003a, 0x025d, 0x0004}, /* index: 425, gain:43.480650db->x149.290613, DCG:1 */
+	{0x003a, 0x0264, 0x0004}, /* index: 426, gain:43.574400db->x150.910688, DCG:1 */
+	{0x003a, 0x026b, 0x0004}, /* index: 427, gain:43.668150db->x152.548345, DCG:1 */
+	{0x003a, 0x0271, 0x0004}, /* index: 428, gain:43.761900db->x154.203773, DCG:1 */
+	{0x003a, 0x0278, 0x0004}, /* index: 429, gain:43.855650db->x155.877166, DCG:1 */
+	{0x003a, 0x027f, 0x0004}, /* index: 430, gain:43.949400db->x157.568717, DCG:1 */
+	{0x003a, 0x0286, 0x0004}, /* index: 431, gain:44.043150db->x159.278626, DCG:1 */
+	{0x003a, 0x028d, 0x0004}, /* index: 432, gain:44.136900db->x161.007090, DCG:1 */
+	{0x003a, 0x0294, 0x0004}, /* index: 433, gain:44.230650db->x162.754311, DCG:1 */
+	{0x003a, 0x029b, 0x0004}, /* index: 434, gain:44.324400db->x164.520492, DCG:1 */
+	{0x003a, 0x02a3, 0x0004}, /* index: 435, gain:44.418150db->x166.305840, DCG:1 */
+	{0x003a, 0x02aa, 0x0004}, /* index: 436, gain:44.511900db->x168.110562, DCG:1 */
+	{0x003a, 0x02b1, 0x0004}, /* index: 437, gain:44.605650db->x169.934869, DCG:1 */
+	{0x003a, 0x02b9, 0x0004}, /* index: 438, gain:44.699400db->x171.778972, DCG:1 */
+	{0x003a, 0x02c0, 0x0004}, /* index: 439, gain:44.793150db->x173.643088, DCG:1 */
+	{0x003a, 0x02c8, 0x0004}, /* index: 440, gain:44.886900db->x175.527432, DCG:1 */
+	{0x003a, 0x02d0, 0x0004}, /* index: 441, gain:44.980650db->x177.432226, DCG:1 */
+	{0x003a, 0x02d7, 0x0004}, /* index: 442, gain:45.074400db->x179.357689, DCG:1 */
+	{0x003a, 0x02df, 0x0004}, /* index: 443, gain:45.168150db->x181.304048, DCG:1 */
+	{0x003a, 0x02e7, 0x0004}, /* index: 444, gain:45.261900db->x183.271528, DCG:1 */
+	{0x003a, 0x02ef, 0x0004}, /* index: 445, gain:45.355650db->x185.260358, DCG:1 */
+	{0x003a, 0x02f8, 0x0004}, /* index: 446, gain:45.449400db->x187.270772, DCG:1 */
+	{0x003a, 0x0300, 0x0004}, /* index: 447, gain:45.543150db->x189.303002, DCG:1 */
+	{0x003a, 0x0308, 0x0004}, /* index: 448, gain:45.636900db->x191.357285, DCG:1 */
+	{0x003a, 0x0311, 0x0004}, /* index: 449, gain:45.730650db->x193.433861, DCG:1 */
+	{0x003a, 0x0319, 0x0004}, /* index: 450, gain:45.824400db->x195.532971, DCG:1 */
+	{0x003a, 0x0322, 0x0004}, /* index: 451, gain:45.918150db->x197.654861, DCG:1 */
+	{0x003a, 0x032a, 0x0004}, /* index: 452, gain:46.011900db->x199.799777, DCG:1 */
+	{0x003a, 0x0333, 0x0004}, /* index: 453, gain:46.105650db->x201.967970, DCG:1 */
+	{0x003a, 0x033c, 0x0004}, /* index: 454, gain:46.199400db->x204.159691, DCG:1 */
+	{0x003a, 0x0345, 0x0004}, /* index: 455, gain:46.293150db->x206.375197, DCG:1 */
+	{0x003a, 0x034e, 0x0004}, /* index: 456, gain:46.386900db->x208.614744, DCG:1 */
+	{0x003a, 0x0357, 0x0004}, /* index: 457, gain:46.480650db->x210.878595, DCG:1 */
+	{0x003a, 0x0361, 0x0004}, /* index: 458, gain:46.574400db->x213.167013, DCG:1 */
+	{0x003a, 0x036a, 0x0004}, /* index: 459, gain:46.668150db->x215.480265, DCG:1 */
+	{0x003a, 0x0374, 0x0004}, /* index: 460, gain:46.761900db->x217.818619, DCG:1 */
+	{0x003a, 0x037d, 0x0004}, /* index: 461, gain:46.855650db->x220.182349, DCG:1 */
+	{0x003a, 0x0387, 0x0004}, /* index: 462, gain:46.949400db->x222.571729, DCG:1 */
+	{0x003a, 0x0391, 0x0004}, /* index: 463, gain:47.043150db->x224.987039, DCG:1 */
+	{0x003a, 0x039b, 0x0004}, /* index: 464, gain:47.136900db->x227.428559, DCG:1 */
+	{0x003a, 0x03a5, 0x0004}, /* index: 465, gain:47.230650db->x229.896574, DCG:1 */
+	{0x003a, 0x03af, 0x0004}, /* index: 466, gain:47.324400db->x232.391372, DCG:1 */
+	{0x003a, 0x03b9, 0x0004}, /* index: 467, gain:47.418150db->x234.913243, DCG:1 */
+	{0x003a, 0x03c3, 0x0004}, /* index: 468, gain:47.511900db->x237.462480, DCG:1 */
+	{0x003a, 0x03ce, 0x0004}, /* index: 469, gain:47.605650db->x240.039382, DCG:1 */
+	{0x003a, 0x03d8, 0x0004}, /* index: 470, gain:47.699400db->x242.644248, DCG:1 */
+	{0x003a, 0x03e3, 0x0004}, /* index: 471, gain:47.793150db->x245.277381, DCG:1 */
+	{0x003a, 0x03ee, 0x0004}, /* index: 472, gain:47.886900db->x247.939088, DCG:1 */
+	{0x003a, 0x03f9, 0x0004}, /* index: 473, gain:47.980650db->x250.629680, DCG:1 */
+	{0x003a, 0x0404, 0x0004}, /* index: 474, gain:48.074400db->x253.349470, DCG:1 */
+};
+
diff --git a/drivers/vin/sensors/onsemi_ar0237/make.inc b/drivers/vin/sensors/onsemi_ar0237/make.inc
new file mode 100644
index 0000000..e2722b7
--- /dev/null
+++ b/drivers/vin/sensors/onsemi_ar0237/make.inc
@@ -0,0 +1,45 @@
+##
+## kernel/private/drivers/vin/sensors/onsemi_ar0237/make.inc
+##
+## History:
+##    2015/09/07 - [Hao Zeng] Create
+##
+## Copyright (c) 2015 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+ifeq ($(CONFIG_SENSOR_AR0237), y)
+
+LOCAL_PATH	:= $(call my-dir)
+
+###
+include $(CLEAR_VARS)
+
+LOCAL_SRCS	:= $(wildcard $(LOCAL_PATH)/*.c) $(wildcard $(LOCAL_PATH)/*.h)
+LOCAL_SRCS	+= $(LOCAL_PATH)/Kbuild
+
+include $(BUILD_DRIVER)
+
+endif
+
diff --git a/drivers/vin/sensors/onsemi_ar0237_parallel/Kbuild b/drivers/vin/sensors/onsemi_ar0237_parallel/Kbuild
new file mode 100644
index 0000000..b6e795a
--- /dev/null
+++ b/drivers/vin/sensors/onsemi_ar0237_parallel/Kbuild
@@ -0,0 +1,39 @@
+##
+## Filename : Kbuild
+##
+## History:
+##     2015/09/07 - [Hao Zeng] Create
+##
+## Copyright (c) 2015 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+
+EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
+EXTRA_AFLAGS		+= $(AMBARELLA_DRV_AFLAGS)
+EXTRA_LDFLAGS		+= $(AMBARELLA_DRV_LDFLAGS)
+
+obj-m := ar0237_parallel.o
+ar0237_parallel-y := ar0237.o
+
diff --git a/drivers/vin/sensors/onsemi_ar0237_parallel/ar0237.c b/drivers/vin/sensors/onsemi_ar0237_parallel/ar0237.c
new file mode 100644
index 0000000..f39cd23
--- /dev/null
+++ b/drivers/vin/sensors/onsemi_ar0237_parallel/ar0237.c
@@ -0,0 +1,531 @@
+/*
+ * Filename : ar0237.c
+ *
+ * History:
+ *    2015/09/07 - [Hao Zeng] Create
+ *
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/ambpriv_device.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <iav_utils.h>
+#include <vin_api.h>
+#include "ar0237.h"
+#include "ar0237_table.c"
+
+static int bus_addr = (0 << 16) | (0x20 >> 1);
+module_param(bus_addr, int, 0644);
+MODULE_PARM_DESC(bus_addr, " bus and addr: bit16~bit31: bus, bit0~bit15: addr");
+
+static int bayer_pattern = VINDEV_BAYER_PATTERN_AUTO;
+module_param(bayer_pattern, int, 0644);
+MODULE_PARM_DESC(bayer_pattern, "set bayer pattern: 0:RG, 1:BG, 2:GR, 3:GB, 255:default");
+
+struct ar0237_priv {
+	void *control_data;
+	u32 frame_length_lines;
+	u32 line_length;
+};
+
+static int ar0237_write_reg(struct vin_device *vdev, u32 subaddr, u32 data)
+{
+	int rval;
+	struct ar0237_priv *ar0237;
+	struct i2c_client *client;
+	struct i2c_msg msgs[1];
+	u8 pbuf[4];
+
+	ar0237 = (struct ar0237_priv *)vdev->priv;
+	client = ar0237->control_data;
+
+	pbuf[0] = (subaddr & 0xff00) >> 8;
+	pbuf[1] = subaddr & 0xff;
+	pbuf[2] = (data & 0xff00) >> 8;
+	pbuf[3] = data & 0xff;
+
+	msgs[0].len = 4;
+	msgs[0].addr = client->addr;
+	if (unlikely(subaddr == AR0237_RESET_REGISTER))
+		msgs[0].flags = client->flags | I2C_M_IGNORE_NAK;
+	else
+		msgs[0].flags = client->flags;
+	msgs[0].buf = pbuf;
+
+	rval = i2c_transfer(client->adapter, msgs, 1);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x:0x%x]\n", rval, subaddr, data);
+		return rval;
+	}
+
+	return 0;
+}
+
+static int ar0237_read_reg(struct vin_device *vdev, u32 subaddr, u32 *data)
+{
+	int rval = 0;
+	struct ar0237_priv *ar0237;
+	struct i2c_client *client;
+	struct i2c_msg msgs[2];
+	u8 pbuf0[2];
+	u8 pbuf[2];
+
+	ar0237 = (struct ar0237_priv *)vdev->priv;
+	client = ar0237->control_data;
+
+	pbuf0[0] = (subaddr & 0xff00) >> 8;
+	pbuf0[1] = subaddr & 0xff;
+
+	msgs[0].len = 2;
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].buf = pbuf0;
+
+	msgs[1].addr = client->addr;
+	msgs[1].flags = client->flags | I2C_M_RD;
+	msgs[1].buf = pbuf;
+	msgs[1].len = 2;
+
+	rval = i2c_transfer(client->adapter, msgs, 2);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x]\n", rval, subaddr);
+		return rval;
+	}
+
+	*data = (pbuf[0] << 8) | pbuf[1];
+
+	return 0;
+}
+
+static int ar0237_set_vin_mode(struct vin_device *vdev, struct vin_video_format *format)
+{
+	struct vin_device_config ar0237_config;
+
+	memset(&ar0237_config, 0, sizeof(ar0237_config));
+
+	ar0237_config.interface_type = SENSOR_PARALLEL_LVCMOS;
+	ar0237_config.sync_mode = SENSOR_SYNC_MODE_MASTER;
+	ar0237_config.input_mode = SENSOR_RGB_1PIX;
+
+	ar0237_config.plvcmos_cfg.vs_hs_polarity = SENSOR_VS_HIGH | SENSOR_HS_HIGH;
+	ar0237_config.plvcmos_cfg.data_edge = SENSOR_DATA_RISING_EDGE;
+	ar0237_config.plvcmos_cfg.paralle_sync_type = SENSOR_PARALLEL_SYNC_601;
+
+	ar0237_config.cap_win.x = format->def_start_x;
+	ar0237_config.cap_win.y = format->def_start_y;
+	ar0237_config.cap_win.width = format->def_width;
+	ar0237_config.cap_win.height = format->def_height;
+
+	ar0237_config.hdr_cfg.act_win.x = format->act_start_x;
+	ar0237_config.hdr_cfg.act_win.y = format->act_start_y;
+	ar0237_config.hdr_cfg.act_win.width = format->act_width;
+	ar0237_config.hdr_cfg.act_win.height = format->act_height;
+
+	ar0237_config.sensor_id	= GENERIC_SENSOR;
+	ar0237_config.input_format	= AMBA_VIN_INPUT_FORMAT_RGB_RAW;
+	ar0237_config.bayer_pattern	= format->bayer_pattern;
+	ar0237_config.video_format	= format->format;
+	ar0237_config.bit_resolution	= format->bits;
+
+	return ambarella_set_vin_config(vdev, &ar0237_config);
+}
+
+static void ar0237_sw_reset(struct vin_device *vdev)
+{
+	ar0237_write_reg(vdev, AR0237_RESET_REGISTER, 0x0001);/* Register RESET_REGISTER */
+	msleep(1);
+	ar0237_write_reg(vdev, AR0237_RESET_REGISTER, 0x10D8);/* Register RESET_REGISTER */
+}
+
+static int ar0237_init_device(struct vin_device *vdev)
+{
+	ar0237_sw_reset(vdev);
+	return 0;
+}
+
+static int ar0237_set_pll(struct vin_device *vdev, int pll_idx)
+{
+	struct vin_reg_16_16 *regs;
+	int i, regs_num;
+
+	regs = ar0237_pll_regs[pll_idx];
+	regs_num = ARRAY_SIZE(ar0237_pll_regs[pll_idx]);
+	for (i = 0; i < regs_num; i++)
+		ar0237_write_reg(vdev, regs[i].addr, regs[i].data);
+
+	return 0;
+}
+
+static void ar0237_start_streaming(struct vin_device *vdev)
+{
+	u32 data;
+	ar0237_read_reg(vdev, AR0237_RESET_REGISTER, &data);
+	data = (data | 0x0004);
+	ar0237_write_reg(vdev, AR0237_RESET_REGISTER, data);/* start streaming */
+}
+
+static int ar0237_update_hv_info(struct vin_device *vdev)
+{
+	struct ar0237_priv *pinfo = (struct ar0237_priv *)vdev->priv;
+
+	ar0237_read_reg(vdev, AR0237_LINE_LENGTH_PCK, &pinfo->line_length);
+	if (unlikely(!pinfo->line_length)) {
+		vin_error("line length is 0!\n");
+		return -EIO;
+	}
+
+	ar0237_read_reg(vdev, AR0237_FRAME_LENGTH_LINES, &pinfo->frame_length_lines);
+
+	return 0;
+}
+
+static int ar0237_get_line_time(struct vin_device *vdev)
+{
+	u64 h_clks;
+	struct ar0237_priv *pinfo = (struct ar0237_priv *)vdev->priv;
+
+	h_clks = (u64)pinfo->line_length * 512000000;
+	h_clks = DIV64_CLOSEST(h_clks, vdev->cur_pll->pixelclk);
+
+	vdev->cur_format->line_time = (u32)h_clks;
+
+	return 0;
+}
+
+static int ar0237_set_format(struct vin_device *vdev, struct vin_video_format *format)
+{
+	struct vin_reg_16_16 *regs;
+	int i, regs_num = 0, rval;
+	struct ar0237_priv *pinfo;
+
+	pinfo = (struct ar0237_priv *)vdev->priv;
+
+	regs = ar0237_linear_share_regs;
+	regs_num = ARRAY_SIZE(ar0237_linear_share_regs);
+	for (i = 0; i < regs_num; i++)
+		ar0237_write_reg(vdev, regs[i].addr, regs[i].data);
+
+	rval = ar0237_update_hv_info(vdev);
+	if (rval < 0)
+		return rval;
+
+	ar0237_get_line_time(vdev);
+
+	/* Enable Streaming */
+	ar0237_start_streaming(vdev);
+
+	/* communiate with IAV */
+	rval = ar0237_set_vin_mode(vdev, format);
+	if (rval < 0)
+		return rval;
+
+	return 0;
+}
+
+static int ar0237_set_shutter_row(struct vin_device *vdev, u32 row)
+{
+	u64 exposure_lines;
+	u32 num_line, min_line, max_line;
+	int errCode = 0;
+	struct ar0237_priv *pinfo = (struct ar0237_priv *)vdev->priv;
+
+	num_line = row;
+
+	/* FIXME: shutter width: 1 ~ (Frame format(V) - 4) */
+	min_line = 1;
+	max_line = pinfo->frame_length_lines - 4;
+	num_line = clamp(num_line, min_line, max_line);
+
+	ar0237_write_reg(vdev, AR0237_COARSE_INTEGRATION_TIME, num_line);
+
+	exposure_lines = num_line;
+	exposure_lines = exposure_lines * (u64)pinfo->line_length * 512000000;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, vdev->cur_pll->pixelclk);
+
+	vdev->shutter_time = (u32)exposure_lines;
+	vin_debug("shutter_time:%d, row:%d\n", vdev->shutter_time, num_line);
+
+	return errCode;
+}
+
+static int ar0237_shutter2row(struct vin_device *vdev, u32 *shutter_time)
+{
+	u64 exposure_lines;
+	int rval = 0;
+	struct ar0237_priv *pinfo = (struct ar0237_priv *)vdev->priv;
+
+	/* for fast boot, it may call set shutter time directly, so we must read line length/frame line */
+	if (unlikely(!pinfo->line_length)) {
+		rval = ar0237_update_hv_info(vdev);
+		if (rval < 0)
+			return rval;
+
+		ar0237_get_line_time(vdev);
+	}
+
+	exposure_lines = (*shutter_time) * (u64)vdev->cur_pll->pixelclk;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, pinfo->line_length);
+	exposure_lines = DIV64_CLOSEST(exposure_lines, 512000000);
+
+	*shutter_time = exposure_lines;
+
+	return rval;
+}
+
+static int ar0237_set_fps(struct vin_device *vdev, int fps)
+{
+	u64 pixelclk, v_lines, vb_time;
+	struct ar0237_priv *pinfo = (struct ar0237_priv *)vdev->priv;
+
+	pixelclk = vdev->cur_pll->pixelclk;
+
+	v_lines = fps * pixelclk;
+	v_lines = DIV64_CLOSEST(v_lines, pinfo->line_length);
+	v_lines = DIV64_CLOSEST(v_lines, 512000000);
+	ar0237_write_reg(vdev, AR0237_FRAME_LENGTH_LINES, v_lines);
+
+	pinfo->frame_length_lines = (u32)v_lines;
+
+	vb_time = pinfo->line_length * (u64)(v_lines - vdev->cur_format->height) * 1000000000;
+	vb_time = DIV64_CLOSEST(vb_time, pixelclk);
+	vdev->cur_format->vb_time = vb_time;
+
+	return 0;
+}
+
+static int ar0237_set_agc_index(struct vin_device *vdev, int agc_idx)
+{
+	if (agc_idx > AR0237_GAIN_48DB) {
+		vin_error("agc index %d exceeds maximum %d\n", agc_idx, AR0237_GAIN_48DB);
+		return -EINVAL;
+	}
+
+	if (agc_idx < AR0237_GAIN_DCG_ON) {
+		/* Low Conversion Gain */
+		ar0237_write_reg(vdev, 0x3206, 0x0B08);/* ADACD_NOISE_FLOOR1 */
+		ar0237_write_reg(vdev, 0x3208, 0x1E13);/* ADACD_NOISE_FLOOR2 */
+		ar0237_write_reg(vdev, 0x3202, 0x0080);/* ADACD_NOISE_MODEL1 */
+		if  (vdev->cur_format->hdr_mode != AMBA_VIDEO_LINEAR_MODE) {
+			ar0237_write_reg(vdev, 0x3096, 0x0480);/* ROW_NOISE_ADJUST_TOP */
+			ar0237_write_reg(vdev, 0x3098, 0x0480);/* ROW_NOISE_ADJUST_BTM */
+		}
+	} else {
+		/* High Conversion Gain */
+		ar0237_write_reg(vdev, 0x3206, 0x1C0E);/* ADACD_NOISE_FLOOR1 */
+		ar0237_write_reg(vdev, 0x3208, 0x4E39);/* ADACD_NOISE_FLOOR2 */
+		ar0237_write_reg(vdev, 0x3202, 0x00B0);/* ADACD_NOISE_MODEL1 */
+		if  (vdev->cur_format->hdr_mode != AMBA_VIDEO_LINEAR_MODE) {
+			ar0237_write_reg(vdev, 0x3096, 0x0780);/* ROW_NOISE_ADJUST_TOP */
+			ar0237_write_reg(vdev, 0x3098, 0x0780);/* ROW_NOISE_ADJUST_BTM */
+		}
+	}
+
+	ar0237_write_reg(vdev, AR0237_AGAIN,
+		AR0237_GAIN_TABLE[agc_idx][AR0237_GAIN_COL_AGAIN]);
+	ar0237_write_reg(vdev, AR0237_DGAIN,
+		AR0237_GAIN_TABLE[agc_idx][AR0237_GAIN_COL_DGAIN]);
+	ar0237_write_reg(vdev, AR0237_DCG_CTL,
+		AR0237_GAIN_TABLE[agc_idx][AR0237_GAIN_COL_DCG]);
+
+	return 0;
+}
+
+static int ar0237_set_mirror_mode(struct vin_device *vdev,
+	struct vindev_mirror *mirror_mode)
+{
+	u32 tmp_reg, readmode, bayer_pattern;
+
+	switch (mirror_mode->pattern) {
+	case VINDEV_MIRROR_AUTO:
+		return 0;
+
+	case VINDEV_MIRROR_HORRIZONTALLY_VERTICALLY:
+		readmode = AR0237_H_MIRROR + AR0237_V_FLIP;
+		bayer_pattern = VINDEV_BAYER_PATTERN_GR;
+		break;
+
+	case VINDEV_MIRROR_HORRIZONTALLY:
+		readmode = AR0237_H_MIRROR;
+		bayer_pattern = VINDEV_BAYER_PATTERN_GR;
+		break;
+
+	case VINDEV_MIRROR_VERTICALLY:
+		readmode = AR0237_V_FLIP;
+		bayer_pattern = VINDEV_BAYER_PATTERN_GR;
+		break;
+
+	case VINDEV_MIRROR_NONE:
+		readmode = 0;
+		bayer_pattern = VINDEV_BAYER_PATTERN_GR;
+		break;
+
+	default:
+		vin_error("do not support cmd mirror mode\n");
+		return -EINVAL;
+	}
+
+	ar0237_read_reg(vdev, AR0237_READ_MODE, &tmp_reg);
+	tmp_reg &= (~AR0237_MIRROR_MASK);
+	tmp_reg |= readmode;
+	ar0237_write_reg(vdev, AR0237_READ_MODE, tmp_reg);
+
+	if (mirror_mode->bayer_pattern == VINDEV_BAYER_PATTERN_AUTO)
+		mirror_mode->bayer_pattern = bayer_pattern;
+
+	return 0;
+}
+
+static struct vin_ops ar0237_ops = {
+	.init_device		= ar0237_init_device,
+	.set_pll			= ar0237_set_pll,
+	.set_format		= ar0237_set_format,
+	.set_shutter_row	= ar0237_set_shutter_row,
+	.shutter2row		= ar0237_shutter2row,
+	.set_frame_rate	= ar0237_set_fps,
+	.set_agc_index		= ar0237_set_agc_index,
+	.set_mirror_mode	= ar0237_set_mirror_mode,
+	.read_reg			= ar0237_read_reg,
+	.write_reg		= ar0237_write_reg,
+};
+
+/* ========================================================================== */
+static int ar0237_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	int i, rval = 0;
+	struct vin_device *vdev;
+	struct ar0237_priv *ar0237;
+	u32 version;
+
+	vdev = ambarella_vin_create_device(client->name,
+		SENSOR_AR0237, sizeof(struct ar0237_priv));
+	if (!vdev)
+		return -ENOMEM;
+
+	vdev->intf_id = 0;
+	vdev->dev_type = VINDEV_TYPE_SENSOR;
+	vdev->sub_type = VINDEV_SUBTYPE_CMOS;
+	vdev->default_mode = AMBA_VIDEO_MODE_1080P;
+	vdev->default_hdr_mode = AMBA_VIDEO_LINEAR_MODE;
+	vdev->agc_db_max = 0x2C700000;	/* 44.4375dB */
+	vdev->agc_db_min = 0x00000000;	/* 0dB */
+	vdev->agc_db_step = 0x00180000;	/* 0.09375dB */
+
+	i2c_set_clientdata(client, vdev);
+
+	ar0237 = (struct ar0237_priv *)vdev->priv;
+	ar0237->control_data = client;
+
+	if (bayer_pattern != VINDEV_BAYER_PATTERN_AUTO) {
+		if (bayer_pattern > VINDEV_BAYER_PATTERN_GB) {
+			vin_error("invalid bayer pattern:%d\n", bayer_pattern);
+			return -EINVAL;
+		} else {
+			for (i = 0; i < ARRAY_SIZE(ar0237_formats); i++)
+				ar0237_formats[i].default_bayer_pattern = bayer_pattern;
+		}
+	}
+
+	rval = ambarella_vin_register_device(vdev, &ar0237_ops,
+		ar0237_formats, ARRAY_SIZE(ar0237_formats),
+		ar0237_plls, ARRAY_SIZE(ar0237_plls));
+	if (rval < 0)
+		goto ar0237_probe_err;
+
+	/* query sensor id */
+	ar0237_read_reg(vdev, AR0237_CHIP_VERSION_REG, &version);
+	vin_info("AR0237 init(parallel), sensor ID: 0x%x\n", version);
+
+	return 0;
+
+ar0237_probe_err:
+	ambarella_vin_free_device(vdev);
+	return rval;
+}
+
+static int ar0237_remove(struct i2c_client *client)
+{
+	struct vin_device *vdev;
+
+	vdev = (struct vin_device *)i2c_get_clientdata(client);
+	ambarella_vin_unregister_device(vdev);
+	ambarella_vin_free_device(vdev);
+
+	return 0;
+}
+
+static const struct i2c_device_id ar0237_idtable[] = {
+	{ "ar0237", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ar0237_idtable);
+
+static struct i2c_driver i2c_driver_ar0237 = {
+	.driver = {
+		.name	= "ar0237",
+	},
+
+	.id_table	= ar0237_idtable,
+	.probe		= ar0237_probe,
+	.remove		= ar0237_remove,
+
+};
+
+static int __init ar0237_init(void)
+{
+	int bus, addr, rval;
+
+	bus = bus_addr >> 16;
+	addr = bus_addr & 0xffff;
+
+	rval = ambpriv_i2c_update_addr("ar0237", bus, addr);
+	if (rval < 0)
+		return rval;
+
+	rval = i2c_add_driver(&i2c_driver_ar0237);
+	if (rval < 0)
+		return rval;
+
+	return 0;
+}
+
+static void __exit ar0237_exit(void)
+{
+	i2c_del_driver(&i2c_driver_ar0237);
+}
+
+module_init(ar0237_init);
+module_exit(ar0237_exit);
+
+MODULE_DESCRIPTION("AR0237 1/2.7 -Inch, 1928x1088, 2.1-Megapixel CMOS Digital Image Sensor");
+MODULE_AUTHOR("Hao Zeng, <haozeng@ambarella.com>");
+MODULE_LICENSE("Proprietary");
+
diff --git a/drivers/vin/sensors/onsemi_ar0237_parallel/ar0237.h b/drivers/vin/sensors/onsemi_ar0237_parallel/ar0237.h
new file mode 100644
index 0000000..75881f9
--- /dev/null
+++ b/drivers/vin/sensors/onsemi_ar0237_parallel/ar0237.h
@@ -0,0 +1,60 @@
+/*
+ * Filename : ar0237.h
+ *
+ * History:
+ *    2015/09/07 - [Hao Zeng] Create
+ *
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __AR0237_PRI_H__
+#define __AR0237_PRI_H__
+
+#define AR0237_RESET_REGISTER				0x301A
+#define AR0237_LINE_LENGTH_PCK			0x300C
+#define AR0237_FRAME_LENGTH_LINES			0x300A
+
+#define AR0237_CHIP_VERSION_REG			0x3000
+#define AR0237_COARSE_INTEGRATION_TIME	0x3012
+
+#define AR0237_VT_PIX_CLK_DIV				0x302A
+#define AR0237_VT_SYS_CLK_DIV				0x302C
+#define AR0237_PRE_PLL_CLK_DIV				0x302E
+#define AR0237_PLL_MULTIPLIER				0x3030
+
+#define AR0237_DGAIN						0x305E
+#define AR0237_AGAIN						0x3060
+#define AR0237_DCG_CTL						0x3100
+
+/* AR0237 mirror mode */
+#define AR0237_READ_MODE				0x3040
+#define AR0237_H_MIRROR			(0x01 << 14)
+#define AR0237_V_FLIP				(0x01 << 15)
+#define AR0237_MIRROR_MASK			(AR0237_H_MIRROR + AR0237_V_FLIP)
+
+#endif /* __AR0237_PRI_H__ */
+
diff --git a/drivers/vin/sensors/onsemi_ar0237_parallel/ar0237_table.c b/drivers/vin/sensors/onsemi_ar0237_parallel/ar0237_table.c
new file mode 100644
index 0000000..3be1bb3
--- /dev/null
+++ b/drivers/vin/sensors/onsemi_ar0237_parallel/ar0237_table.c
@@ -0,0 +1,796 @@
+/*
+ * Filename : ar0237_table.c
+ *
+ * History:
+ *    2015/09/07 - [Hao Zeng] Create
+ *
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+static struct vin_reg_16_16 ar0237_pll_regs[][6] = {
+	{
+		{0x302A, 0x0008}, /* VT_PIX_CLK_DIV  */
+		{0x302C, 0x0001}, /* VT_SYS_CLK_DIV  */
+		{0x302E, 0x0002}, /* PRE_PLL_CLK_DIV */
+		{0x3030, 0x002C}, /* PLL_MULTIPLIER  */
+		{0x3036, 0x000C}, /* OP_PIX_CLK_DIV  */
+		{0x3038, 0x0001}, /* OP_SYS_CLK_DIV  */
+	},
+};
+
+static struct vin_video_pll ar0237_plls[] = {
+	{0, 27000000, 37125000},
+};
+
+static struct vin_video_format ar0237_formats[] = {
+	{
+		.video_mode	= AMBA_VIDEO_MODE_1080P,
+		.def_start_x	= 0,
+		.def_start_y	= 0,
+		.def_width	= 1920,
+		.def_height	= 1080,
+		.act_start_x	= 0,
+		.act_start_y	= 0,
+		.act_width	= 1920,
+		.act_height	= 1080,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_LINEAR_MODE,
+		.device_mode	= 0,
+		.pll_idx	= 0,
+		.width		= 1920,
+		.height		= 1080,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_30,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_GR,
+	},
+};
+
+static struct vin_reg_16_16 ar0237_linear_share_regs[] = {
+	/* 1080p@30fps-parallel mode(27M--74.25M) */
+	{0x3088, 0x8000}, /* SEQ_CTRL_PORT */
+	{0x3086, 0x4558}, /* SEQ_DATA_PORT */
+	{0x3086, 0x72A6}, /* SEQ_DATA_PORT */
+	{0x3086, 0x4A31}, /* SEQ_DATA_PORT */
+	{0x3086, 0x4342}, /* SEQ_DATA_PORT */
+	{0x3086, 0x8E03}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2A14}, /* SEQ_DATA_PORT */
+	{0x3086, 0x4578}, /* SEQ_DATA_PORT */
+	{0x3086, 0x7B3D}, /* SEQ_DATA_PORT */
+	{0x3086, 0xFF3D}, /* SEQ_DATA_PORT */
+	{0x3086, 0xFF3D}, /* SEQ_DATA_PORT */
+	{0x3086, 0xEA2A}, /* SEQ_DATA_PORT */
+	{0x3086, 0x043D}, /* SEQ_DATA_PORT */
+	{0x3086, 0x102A}, /* SEQ_DATA_PORT */
+	{0x3086, 0x052A}, /* SEQ_DATA_PORT */
+	{0x3086, 0x1535}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2A05}, /* SEQ_DATA_PORT */
+	{0x3086, 0x3D10}, /* SEQ_DATA_PORT */
+	{0x3086, 0x4558}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2A04}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2A14}, /* SEQ_DATA_PORT */
+	{0x3086, 0x3DFF}, /* SEQ_DATA_PORT */
+	{0x3086, 0x3DFF}, /* SEQ_DATA_PORT */
+	{0x3086, 0x3DEA}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2A04}, /* SEQ_DATA_PORT */
+	{0x3086, 0x622A}, /* SEQ_DATA_PORT */
+	{0x3086, 0x288E}, /* SEQ_DATA_PORT */
+	{0x3086, 0x0036}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2A08}, /* SEQ_DATA_PORT */
+	{0x3086, 0x3D64}, /* SEQ_DATA_PORT */
+	{0x3086, 0x7A3D}, /* SEQ_DATA_PORT */
+	{0x3086, 0x0444}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2C4B}, /* SEQ_DATA_PORT */
+	{0x3086, 0xA403}, /* SEQ_DATA_PORT */
+	{0x3086, 0x430D}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2D46}, /* SEQ_DATA_PORT */
+	{0x3086, 0x4316}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2A90}, /* SEQ_DATA_PORT */
+	{0x3086, 0x3E06}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2A98}, /* SEQ_DATA_PORT */
+	{0x3086, 0x5F16}, /* SEQ_DATA_PORT */
+	{0x3086, 0x530D}, /* SEQ_DATA_PORT */
+	{0x3086, 0x1660}, /* SEQ_DATA_PORT */
+	{0x3086, 0x3E4C}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2904}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2984}, /* SEQ_DATA_PORT */
+	{0x3086, 0x8E03}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2AFC}, /* SEQ_DATA_PORT */
+	{0x3086, 0x5C1D}, /* SEQ_DATA_PORT */
+	{0x3086, 0x5754}, /* SEQ_DATA_PORT */
+	{0x3086, 0x495F}, /* SEQ_DATA_PORT */
+	{0x3086, 0x5305}, /* SEQ_DATA_PORT */
+	{0x3086, 0x5307}, /* SEQ_DATA_PORT */
+	{0x3086, 0x4D2B}, /* SEQ_DATA_PORT */
+	{0x3086, 0xF810}, /* SEQ_DATA_PORT */
+	{0x3086, 0x164C}, /* SEQ_DATA_PORT */
+	{0x3086, 0x0955}, /* SEQ_DATA_PORT */
+	{0x3086, 0x562B}, /* SEQ_DATA_PORT */
+	{0x3086, 0xB82B}, /* SEQ_DATA_PORT */
+	{0x3086, 0x984E}, /* SEQ_DATA_PORT */
+	{0x3086, 0x1129}, /* SEQ_DATA_PORT */
+	{0x3086, 0x9460}, /* SEQ_DATA_PORT */
+	{0x3086, 0x5C19}, /* SEQ_DATA_PORT */
+	{0x3086, 0x5C1B}, /* SEQ_DATA_PORT */
+	{0x3086, 0x4548}, /* SEQ_DATA_PORT */
+	{0x3086, 0x4508}, /* SEQ_DATA_PORT */
+	{0x3086, 0x4588}, /* SEQ_DATA_PORT */
+	{0x3086, 0x29B6}, /* SEQ_DATA_PORT */
+	{0x3086, 0x8E01}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2AF8}, /* SEQ_DATA_PORT */
+	{0x3086, 0x3E02}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2AFA}, /* SEQ_DATA_PORT */
+	{0x3086, 0x3F09}, /* SEQ_DATA_PORT */
+	{0x3086, 0x5C1B}, /* SEQ_DATA_PORT */
+	{0x3086, 0x29B2}, /* SEQ_DATA_PORT */
+	{0x3086, 0x3F0C}, /* SEQ_DATA_PORT */
+	{0x3086, 0x3E03}, /* SEQ_DATA_PORT */
+	{0x3086, 0x3E15}, /* SEQ_DATA_PORT */
+	{0x3086, 0x5C13}, /* SEQ_DATA_PORT */
+	{0x3086, 0x3F11}, /* SEQ_DATA_PORT */
+	{0x3086, 0x3E0F}, /* SEQ_DATA_PORT */
+	{0x3086, 0x5F2B}, /* SEQ_DATA_PORT */
+	{0x3086, 0x902B}, /* SEQ_DATA_PORT */
+	{0x3086, 0x803E}, /* SEQ_DATA_PORT */
+	{0x3086, 0x062A}, /* SEQ_DATA_PORT */
+	{0x3086, 0xF23F}, /* SEQ_DATA_PORT */
+	{0x3086, 0x103E}, /* SEQ_DATA_PORT */
+	{0x3086, 0x0160}, /* SEQ_DATA_PORT */
+	{0x3086, 0x29A2}, /* SEQ_DATA_PORT */
+	{0x3086, 0x29A3}, /* SEQ_DATA_PORT */
+	{0x3086, 0x5F4D}, /* SEQ_DATA_PORT */
+	{0x3086, 0x1C2A}, /* SEQ_DATA_PORT */
+	{0x3086, 0xFA29}, /* SEQ_DATA_PORT */
+	{0x3086, 0x8345}, /* SEQ_DATA_PORT */
+	{0x3086, 0xA83E}, /* SEQ_DATA_PORT */
+	{0x3086, 0x072A}, /* SEQ_DATA_PORT */
+	{0x3086, 0xFB3E}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2945}, /* SEQ_DATA_PORT */
+	{0x3086, 0x8824}, /* SEQ_DATA_PORT */
+	{0x3086, 0x3E08}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2AFA}, /* SEQ_DATA_PORT */
+	{0x3086, 0x5D29}, /* SEQ_DATA_PORT */
+	{0x3086, 0x9288}, /* SEQ_DATA_PORT */
+	{0x3086, 0x102B}, /* SEQ_DATA_PORT */
+	{0x3086, 0x048B}, /* SEQ_DATA_PORT */
+	{0x3086, 0x1686}, /* SEQ_DATA_PORT */
+	{0x3086, 0x8D48}, /* SEQ_DATA_PORT */
+	{0x3086, 0x4D4E}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2B80}, /* SEQ_DATA_PORT */
+	{0x3086, 0x4C0B}, /* SEQ_DATA_PORT */
+	{0x3086, 0x3F36}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2AF2}, /* SEQ_DATA_PORT */
+	{0x3086, 0x3F10}, /* SEQ_DATA_PORT */
+	{0x3086, 0x3E01}, /* SEQ_DATA_PORT */
+	{0x3086, 0x6029}, /* SEQ_DATA_PORT */
+	{0x3086, 0x8229}, /* SEQ_DATA_PORT */
+	{0x3086, 0x8329}, /* SEQ_DATA_PORT */
+	{0x3086, 0x435C}, /* SEQ_DATA_PORT */
+	{0x3086, 0x155F}, /* SEQ_DATA_PORT */
+	{0x3086, 0x4D1C}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2AFA}, /* SEQ_DATA_PORT */
+	{0x3086, 0x4558}, /* SEQ_DATA_PORT */
+	{0x3086, 0x8E00}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2A98}, /* SEQ_DATA_PORT */
+	{0x3086, 0x3F0A}, /* SEQ_DATA_PORT */
+	{0x3086, 0x4A0A}, /* SEQ_DATA_PORT */
+	{0x3086, 0x4316}, /* SEQ_DATA_PORT */
+	{0x3086, 0x0B43}, /* SEQ_DATA_PORT */
+	{0x3086, 0x168E}, /* SEQ_DATA_PORT */
+	{0x3086, 0x032A}, /* SEQ_DATA_PORT */
+	{0x3086, 0x9C45}, /* SEQ_DATA_PORT */
+	{0x3086, 0x783F}, /* SEQ_DATA_PORT */
+	{0x3086, 0x072A}, /* SEQ_DATA_PORT */
+	{0x3086, 0x9D3E}, /* SEQ_DATA_PORT */
+	{0x3086, 0x305D}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2944}, /* SEQ_DATA_PORT */
+	{0x3086, 0x8810}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2B04}, /* SEQ_DATA_PORT */
+	{0x3086, 0x530D}, /* SEQ_DATA_PORT */
+	{0x3086, 0x4558}, /* SEQ_DATA_PORT */
+	{0x3086, 0x3E08}, /* SEQ_DATA_PORT */
+	{0x3086, 0x8E01}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2A98}, /* SEQ_DATA_PORT */
+	{0x3086, 0x8E00}, /* SEQ_DATA_PORT */
+	{0x3086, 0x76A7}, /* SEQ_DATA_PORT */
+	{0x3086, 0x77A7}, /* SEQ_DATA_PORT */
+	{0x3086, 0x4644}, /* SEQ_DATA_PORT */
+	{0x3086, 0x1616}, /* SEQ_DATA_PORT */
+	{0x3086, 0xA57A}, /* SEQ_DATA_PORT */
+	{0x3086, 0x1244}, /* SEQ_DATA_PORT */
+	{0x3086, 0x4B18}, /* SEQ_DATA_PORT */
+	{0x3086, 0x4A04}, /* SEQ_DATA_PORT */
+	{0x3086, 0x4316}, /* SEQ_DATA_PORT */
+	{0x3086, 0x0643}, /* SEQ_DATA_PORT */
+	{0x3086, 0x1605}, /* SEQ_DATA_PORT */
+	{0x3086, 0x4316}, /* SEQ_DATA_PORT */
+	{0x3086, 0x0743}, /* SEQ_DATA_PORT */
+	{0x3086, 0x1658}, /* SEQ_DATA_PORT */
+	{0x3086, 0x4316}, /* SEQ_DATA_PORT */
+	{0x3086, 0x5A43}, /* SEQ_DATA_PORT */
+	{0x3086, 0x1645}, /* SEQ_DATA_PORT */
+	{0x3086, 0x588E}, /* SEQ_DATA_PORT */
+	{0x3086, 0x032A}, /* SEQ_DATA_PORT */
+	{0x3086, 0x9C45}, /* SEQ_DATA_PORT */
+	{0x3086, 0x787B}, /* SEQ_DATA_PORT */
+	{0x3086, 0x3F07}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2A9D}, /* SEQ_DATA_PORT */
+	{0x3086, 0x530D}, /* SEQ_DATA_PORT */
+	{0x3086, 0x8B16}, /* SEQ_DATA_PORT */
+	{0x3086, 0x863E}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2345}, /* SEQ_DATA_PORT */
+	{0x3086, 0x5825}, /* SEQ_DATA_PORT */
+	{0x3086, 0x3E10}, /* SEQ_DATA_PORT */
+	{0x3086, 0x8E01}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2A98}, /* SEQ_DATA_PORT */
+	{0x3086, 0x8E00}, /* SEQ_DATA_PORT */
+	{0x3086, 0x3E10}, /* SEQ_DATA_PORT */
+	{0x3086, 0x8D60}, /* SEQ_DATA_PORT */
+	{0x3086, 0x1244}, /* SEQ_DATA_PORT */
+	{0x3086, 0x4BB9}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2C2C}, /* SEQ_DATA_PORT */
+	{0x3086, 0x2C2C}, /* SEQ_DATA_PORT */
+
+	{0x30F0, 0x1283}, /* ADC_COMMAND1_HS */
+	{0x3064, 0x1802}, /* SMIA_TEST */
+	{0x3EEE, 0xA0AA}, /* DAC_LD_34_35 */
+	{0x30BA, 0x762C}, /* DIGITAL_CTRL */
+	{0x3FA4, 0x0F70},
+	{0x309E, 0x016A}, /* ERS_PROG_START_ADDR */
+	{0x3096, 0xF880}, /* ROW_NOISE_ADJUST_TOP */
+	{0x3F32, 0xF880}, /* ROW_NOISE_ADJUST_TOP_T1 */
+	{0x3092, 0x006F}, /* ROW_NOISE_CONTROL */
+	{0x301A, 0x10D8}, /* RESET_REGISTER */
+	{0x30B0, 0x1118}, /* DIGITAL_TEST(0x0118) */
+	{0x31AC, 0x0C0C}, /* DATA_FORMAT_BITS */
+
+	{0x302A, 0x0008}, /* VT_PIX_CLK_DIV */
+	{0x302C, 0x0001}, /* VT_SYS_CLK_DIV */
+	{0x302E, 0x0002}, /* PRE_PLL_CLK_DIV */
+	{0x3030, 0x002C}, /* PLL_MULTIPLIER */
+	{0x3036, 0x000C}, /* OP_PIX_CLK_DIV */
+	{0x3038, 0x0001}, /* OP_SYS_CLK_DIV */
+
+	{0x3002, 0x0004}, /* Y_ADDR_START */
+	{0x3004, 0x000c}, /* X_ADDR_START */
+	{0x3006, 0x043b}, /* Y_ADDR_END */
+	{0x3008, 0x078b}, /* X_ADDR_END(0x0787) */
+	{0x300A, 0x0465}, /* FRAME_LENGTH_LINES(1125) */
+	{0x300C, 0x044C}, /* LINE_LENGTH_PCK(1100) */
+	{0x3012, 0x0416}, /* COARSE_INTEGRATION_TIME */
+	{0x30A2, 0x0001}, /* X_ODD_INC */
+	{0x30A6, 0x0001}, /* Y_ODD_INC */
+	{0x30AE, 0x0001}, /* X_ODD_INC_CB */
+	{0x30A8, 0x0001}, /* Y_ODD_INC_CB */
+
+	{0x3040, 0x0000}, /* READ_MODE */
+	{0x31AE, 0x0301}, /* SERIAL_FORMAT */
+	{0x3082, 0x0009}, /* OPERATION_MODE_CTRL */
+	{0x30BA, 0x762C}, /* DIGITAL_CTRL */
+	{0x3096, 0x0080}, /* ROW_NOISE_ADJUST_TOP */
+	{0x3098, 0x0080}, /* ROW_NOISE_ADJUST_BTM */
+	{0x3060, 0x000B}, /* ANALOG_GAIN */
+	{0x3100, 0x0004}, /* AECTRLREG */
+	{0x31D0, 0x0000}, /* COMPANDING */
+	{0x3064, 0x1802}, /* SMIA_TEST */
+	{0x301A, 0x10DC}, /* RESET_REGISTER */
+};
+
+/** AR0237 global gain table row size */
+#define AR0237_GAIN_ROWS		475
+#define AR0237_GAIN_COLS 		3
+
+#define AR0237_GAIN_48DB		474
+#define AR0237_GAIN_DCG_ON	54
+
+#define AR0237_GAIN_COL_AGAIN		0
+#define AR0237_GAIN_COL_DGAIN		1
+#define AR0237_GAIN_COL_DCG		2
+
+const u16 AR0237_GAIN_TABLE[AR0237_GAIN_ROWS][AR0237_GAIN_COLS] = {
+	/* analog gain 1.52x~43.2x, and if gain >=2.7, turn on DCG */
+	{0x000b, 0x0080, 0x0000}, /* index: 0, gain:3.636900db->x1.520005, DCG:0 */
+	{0x000b, 0x0081, 0x0000}, /* index: 1, gain:3.730650db->x1.536500, DCG:0 */
+	{0x000b, 0x0082, 0x0000}, /* index: 2, gain:3.824400db->x1.553174, DCG:0 */
+	{0x000b, 0x0084, 0x0000}, /* index: 3, gain:3.918150db->x1.570028, DCG:0 */
+	{0x000b, 0x0085, 0x0000}, /* index: 4, gain:4.011900db->x1.587066, DCG:0 */
+	{0x000c, 0x0080, 0x0000}, /* index: 5, gain:4.105650db->x1.604289, DCG:0 */
+	{0x000c, 0x0081, 0x0000}, /* index: 6, gain:4.199400db->x1.621698, DCG:0 */
+	{0x000c, 0x0083, 0x0000}, /* index: 7, gain:4.293150db->x1.639296, DCG:0 */
+	{0x000c, 0x0084, 0x0000}, /* index: 8, gain:4.386900db->x1.657086, DCG:0 */
+	{0x000c, 0x0086, 0x0000}, /* index: 9, gain:4.480650db->x1.675068, DCG:0 */
+	{0x000d, 0x0081, 0x0000}, /* index: 10, gain:4.574400db->x1.693246, DCG:0 */
+	{0x000d, 0x0082, 0x0000}, /* index: 11, gain:4.668150db->x1.711621, DCG:0 */
+	{0x000d, 0x0083, 0x0000}, /* index: 12, gain:4.761900db->x1.730195, DCG:0 */
+	{0x000d, 0x0085, 0x0000}, /* index: 13, gain:4.855650db->x1.748971, DCG:0 */
+	{0x000d, 0x0086, 0x0000}, /* index: 14, gain:4.949400db->x1.767950, DCG:0 */
+	{0x000e, 0x0080, 0x0000}, /* index: 15, gain:5.043150db->x1.787136, DCG:0 */
+	{0x000e, 0x0081, 0x0000}, /* index: 16, gain:5.136900db->x1.806529, DCG:0 */
+	{0x000e, 0x0083, 0x0000}, /* index: 17, gain:5.230650db->x1.826133, DCG:0 */
+	{0x000e, 0x0084, 0x0000}, /* index: 18, gain:5.324400db->x1.845950, DCG:0 */
+	{0x000e, 0x0086, 0x0000}, /* index: 19, gain:5.418150db->x1.865982, DCG:0 */
+	{0x000f, 0x0080, 0x0000}, /* index: 20, gain:5.511900db->x1.886232, DCG:0 */
+	{0x000f, 0x0081, 0x0000}, /* index: 21, gain:5.605650db->x1.906701, DCG:0 */
+	{0x000f, 0x0083, 0x0000}, /* index: 22, gain:5.699400db->x1.927392, DCG:0 */
+	{0x000f, 0x0084, 0x0000}, /* index: 23, gain:5.793150db->x1.948307, DCG:0 */
+	{0x000f, 0x0086, 0x0000}, /* index: 24, gain:5.886900db->x1.969450, DCG:0 */
+	{0x000f, 0x0087, 0x0000}, /* index: 25, gain:5.980650db->x1.990822, DCG:0 */
+	{0x0010, 0x0080, 0x0000}, /* index: 26, gain:6.074400db->x2.012426, DCG:0 */
+	{0x0010, 0x0082, 0x0000}, /* index: 27, gain:6.168150db->x2.034265, DCG:0 */
+	{0x0010, 0x0083, 0x0000}, /* index: 28, gain:6.261900db->x2.056340, DCG:0 */
+	{0x0011, 0x0081, 0x0000}, /* index: 29, gain:6.355650db->x2.078655, DCG:0 */
+	{0x0011, 0x0082, 0x0000}, /* index: 30, gain:6.449400db->x2.101213, DCG:0 */
+	{0x0011, 0x0083, 0x0000}, /* index: 31, gain:6.543150db->x2.124015, DCG:0 */
+	{0x0012, 0x0080, 0x0000}, /* index: 32, gain:6.636900db->x2.147064, DCG:0 */
+	{0x0012, 0x0081, 0x0000}, /* index: 33, gain:6.730650db->x2.170364, DCG:0 */
+	{0x0012, 0x0083, 0x0000}, /* index: 34, gain:6.824400db->x2.193916, DCG:0 */
+	{0x0013, 0x0081, 0x0000}, /* index: 35, gain:6.918150db->x2.217724, DCG:0 */
+	{0x0013, 0x0082, 0x0000}, /* index: 36, gain:7.011900db->x2.241790, DCG:0 */
+	{0x0013, 0x0083, 0x0000}, /* index: 37, gain:7.105650db->x2.266118, DCG:0 */
+	{0x0014, 0x0080, 0x0000}, /* index: 38, gain:7.199400db->x2.290709, DCG:0 */
+	{0x0014, 0x0081, 0x0000}, /* index: 39, gain:7.293150db->x2.315568, DCG:0 */
+	{0x0014, 0x0083, 0x0000}, /* index: 40, gain:7.386900db->x2.340696, DCG:0 */
+	{0x0014, 0x0084, 0x0000}, /* index: 41, gain:7.480650db->x2.366097, DCG:0 */
+	{0x0015, 0x0080, 0x0000}, /* index: 42, gain:7.574400db->x2.391773, DCG:0 */
+	{0x0015, 0x0082, 0x0000}, /* index: 43, gain:7.668150db->x2.417728, DCG:0 */
+	{0x0015, 0x0083, 0x0000}, /* index: 44, gain:7.761900db->x2.443965, DCG:0 */
+	{0x0016, 0x0080, 0x0000}, /* index: 45, gain:7.855650db->x2.470487, DCG:0 */
+	{0x0016, 0x0081, 0x0000}, /* index: 46, gain:7.949400db->x2.497296, DCG:0 */
+	{0x0016, 0x0083, 0x0000}, /* index: 47, gain:8.043150db->x2.524396, DCG:0 */
+	{0x0016, 0x0084, 0x0000}, /* index: 48, gain:8.136900db->x2.551790, DCG:0 */
+	{0x0017, 0x0080, 0x0000}, /* index: 49, gain:8.230650db->x2.579482, DCG:0 */
+	{0x0017, 0x0082, 0x0000}, /* index: 50, gain:8.324400db->x2.607474, DCG:0 */
+	{0x0017, 0x0083, 0x0000}, /* index: 51, gain:8.418150db->x2.635770, DCG:0 */
+	{0x0018, 0x0080, 0x0000}, /* index: 52, gain:8.511900db->x2.664373, DCG:0 */
+	{0x0018, 0x0081, 0x0000}, /* index: 53, gain:8.605650db->x2.693286, DCG:0 */
+	{0x0000, 0x0081, 0x0004}, /* index: 54, gain:8.699400db->x2.722513, DCG:1 */
+	{0x0000, 0x0082, 0x0004}, /* index: 55, gain:8.793150db->x2.752057, DCG:1 */
+	{0x0001, 0x0080, 0x0004}, /* index: 56, gain:8.886900db->x2.781922, DCG:1 */
+	{0x0001, 0x0081, 0x0004}, /* index: 57, gain:8.980650db->x2.812111, DCG:1 */
+	{0x0001, 0x0082, 0x0004}, /* index: 58, gain:9.074400db->x2.842628, DCG:1 */
+	{0x0001, 0x0084, 0x0004}, /* index: 59, gain:9.168150db->x2.873476, DCG:1 */
+	{0x0002, 0x0080, 0x0004}, /* index: 60, gain:9.261900db->x2.904658, DCG:1 */
+	{0x0002, 0x0082, 0x0004}, /* index: 61, gain:9.355650db->x2.936179, DCG:1 */
+	{0x0002, 0x0083, 0x0004}, /* index: 62, gain:9.449400db->x2.968042, DCG:1 */
+	{0x0003, 0x0081, 0x0004}, /* index: 63, gain:9.543150db->x3.000250, DCG:1 */
+	{0x0003, 0x0082, 0x0004}, /* index: 64, gain:9.636900db->x3.032809, DCG:1 */
+	{0x0003, 0x0084, 0x0004}, /* index: 65, gain:9.730650db->x3.065720, DCG:1 */
+	{0x0004, 0x0080, 0x0004}, /* index: 66, gain:9.824400db->x3.098989, DCG:1 */
+	{0x0004, 0x0082, 0x0004}, /* index: 67, gain:9.918150db->x3.132618, DCG:1 */
+	{0x0004, 0x0083, 0x0004}, /* index: 68, gain:10.011900db->x3.166613, DCG:1 */
+	{0x0004, 0x0085, 0x0004}, /* index: 69, gain:10.105650db->x3.200977, DCG:1 */
+	{0x0005, 0x0080, 0x0004}, /* index: 70, gain:10.199400db->x3.235713, DCG:1 */
+	{0x0005, 0x0082, 0x0004}, /* index: 71, gain:10.293150db->x3.270826, DCG:1 */
+	{0x0005, 0x0083, 0x0004}, /* index: 72, gain:10.386900db->x3.306321, DCG:1 */
+	{0x0006, 0x0080, 0x0004}, /* index: 73, gain:10.480650db->x3.342201, DCG:1 */
+	{0x0006, 0x0082, 0x0004}, /* index: 74, gain:10.574400db->x3.378469, DCG:1 */
+	{0x0006, 0x0083, 0x0004}, /* index: 75, gain:10.668150db->x3.415132, DCG:1 */
+	{0x0006, 0x0085, 0x0004}, /* index: 76, gain:10.761900db->x3.452192, DCG:1 */
+	{0x0007, 0x0081, 0x0004}, /* index: 77, gain:10.855650db->x3.489655, DCG:1 */
+	{0x0007, 0x0082, 0x0004}, /* index: 78, gain:10.949400db->x3.527524, DCG:1 */
+	{0x0007, 0x0084, 0x0004}, /* index: 79, gain:11.043150db->x3.565804, DCG:1 */
+	{0x0008, 0x0080, 0x0004}, /* index: 80, gain:11.136900db->x3.604500, DCG:1 */
+	{0x0008, 0x0081, 0x0004}, /* index: 81, gain:11.230650db->x3.643615, DCG:1 */
+	{0x0008, 0x0083, 0x0004}, /* index: 82, gain:11.324400db->x3.683155, DCG:1 */
+	{0x0008, 0x0084, 0x0004}, /* index: 83, gain:11.418150db->x3.723124, DCG:1 */
+	{0x0009, 0x0080, 0x0004}, /* index: 84, gain:11.511900db->x3.763527, DCG:1 */
+	{0x0009, 0x0081, 0x0004}, /* index: 85, gain:11.605650db->x3.804368, DCG:1 */
+	{0x0009, 0x0083, 0x0004}, /* index: 86, gain:11.699400db->x3.845652, DCG:1 */
+	{0x0009, 0x0084, 0x0004}, /* index: 87, gain:11.793150db->x3.887385, DCG:1 */
+	{0x0009, 0x0086, 0x0004}, /* index: 88, gain:11.886900db->x3.929570, DCG:1 */
+	{0x000a, 0x0080, 0x0004}, /* index: 89, gain:11.980650db->x3.972213, DCG:1 */
+	{0x000a, 0x0082, 0x0004}, /* index: 90, gain:12.074400db->x4.015319, DCG:1 */
+	{0x000a, 0x0083, 0x0004}, /* index: 91, gain:12.168150db->x4.058892, DCG:1 */
+	{0x000a, 0x0085, 0x0004}, /* index: 92, gain:12.261900db->x4.102938, DCG:1 */
+	{0x000b, 0x0081, 0x0004}, /* index: 93, gain:12.355650db->x4.147463, DCG:1 */
+	{0x000b, 0x0082, 0x0004}, /* index: 94, gain:12.449400db->x4.192470, DCG:1 */
+	{0x000b, 0x0084, 0x0004}, /* index: 95, gain:12.543150db->x4.237966, DCG:1 */
+	{0x000b, 0x0085, 0x0004}, /* index: 96, gain:12.636900db->x4.283956, DCG:1 */
+	{0x000c, 0x0080, 0x0004}, /* index: 97, gain:12.730650db->x4.330445, DCG:1 */
+	{0x000c, 0x0081, 0x0004}, /* index: 98, gain:12.824400db->x4.377438, DCG:1 */
+	{0x000c, 0x0083, 0x0004}, /* index: 99, gain:12.918150db->x4.424941, DCG:1 */
+	{0x000c, 0x0084, 0x0004}, /* index: 100, gain:13.011900db->x4.472960, DCG:1 */
+	{0x000c, 0x0085, 0x0004}, /* index: 101, gain:13.105650db->x4.521500, DCG:1 */
+	{0x000d, 0x0080, 0x0004}, /* index: 102, gain:13.199400db->x4.570566, DCG:1 */
+	{0x000d, 0x0082, 0x0004}, /* index: 103, gain:13.293150db->x4.620165, DCG:1 */
+	{0x000d, 0x0083, 0x0004}, /* index: 104, gain:13.386900db->x4.670302, DCG:1 */
+	{0x000d, 0x0085, 0x0004}, /* index: 105, gain:13.480650db->x4.720984, DCG:1 */
+	{0x000d, 0x0086, 0x0004}, /* index: 106, gain:13.574400db->x4.772215, DCG:1 */
+	{0x000e, 0x0080, 0x0004}, /* index: 107, gain:13.668150db->x4.824002, DCG:1 */
+	{0x000e, 0x0081, 0x0004}, /* index: 108, gain:13.761900db->x4.876351, DCG:1 */
+	{0x000e, 0x0083, 0x0004}, /* index: 109, gain:13.855650db->x4.929269, DCG:1 */
+	{0x000e, 0x0084, 0x0004}, /* index: 110, gain:13.949400db->x4.982760, DCG:1 */
+	{0x000e, 0x0086, 0x0004}, /* index: 111, gain:14.043150db->x5.036832, DCG:1 */
+	{0x000f, 0x0080, 0x0004}, /* index: 112, gain:14.136900db->x5.091491, DCG:1 */
+	{0x000f, 0x0081, 0x0004}, /* index: 113, gain:14.230650db->x5.146743, DCG:1 */
+	{0x000f, 0x0083, 0x0004}, /* index: 114, gain:14.324400db->x5.202595, DCG:1 */
+	{0x000f, 0x0084, 0x0004}, /* index: 115, gain:14.418150db->x5.259052, DCG:1 */
+	{0x000f, 0x0086, 0x0004}, /* index: 116, gain:14.511900db->x5.316123, DCG:1 */
+	{0x000f, 0x0087, 0x0004}, /* index: 117, gain:14.605650db->x5.373812, DCG:1 */
+	{0x0010, 0x0080, 0x0004}, /* index: 118, gain:14.699400db->x5.432128, DCG:1 */
+	{0x0010, 0x0082, 0x0004}, /* index: 119, gain:14.793150db->x5.491077, DCG:1 */
+	{0x0010, 0x0083, 0x0004}, /* index: 120, gain:14.886900db->x5.550665, DCG:1 */
+	{0x0011, 0x0081, 0x0004}, /* index: 121, gain:14.980650db->x5.610900, DCG:1 */
+	{0x0011, 0x0082, 0x0004}, /* index: 122, gain:15.074400db->x5.671788, DCG:1 */
+	{0x0011, 0x0083, 0x0004}, /* index: 123, gain:15.168150db->x5.733337, DCG:1 */
+	{0x0012, 0x0080, 0x0004}, /* index: 124, gain:15.261900db->x5.795555, DCG:1 */
+	{0x0012, 0x0081, 0x0004}, /* index: 125, gain:15.355650db->x5.858447, DCG:1 */
+	{0x0012, 0x0083, 0x0004}, /* index: 126, gain:15.449400db->x5.922022, DCG:1 */
+	{0x0013, 0x0080, 0x0004}, /* index: 127, gain:15.543150db->x5.986287, DCG:1 */
+	{0x0013, 0x0082, 0x0004}, /* index: 128, gain:15.636900db->x6.051249, DCG:1 */
+	{0x0013, 0x0083, 0x0004}, /* index: 129, gain:15.730650db->x6.116916, DCG:1 */
+	{0x0014, 0x0080, 0x0004}, /* index: 130, gain:15.824400db->x6.183295, DCG:1 */
+	{0x0014, 0x0081, 0x0004}, /* index: 131, gain:15.918150db->x6.250396, DCG:1 */
+	{0x0014, 0x0083, 0x0004}, /* index: 132, gain:16.011900db->x6.318224, DCG:1 */
+	{0x0014, 0x0084, 0x0004}, /* index: 133, gain:16.105650db->x6.386788, DCG:1 */
+	{0x0015, 0x0080, 0x0004}, /* index: 134, gain:16.199400db->x6.456096, DCG:1 */
+	{0x0015, 0x0081, 0x0004}, /* index: 135, gain:16.293150db->x6.526157, DCG:1 */
+	{0x0015, 0x0083, 0x0004}, /* index: 136, gain:16.386900db->x6.596977, DCG:1 */
+	{0x0016, 0x0080, 0x0004}, /* index: 137, gain:16.480650db->x6.668567, DCG:1 */
+	{0x0016, 0x0081, 0x0004}, /* index: 138, gain:16.574400db->x6.740933, DCG:1 */
+	{0x0016, 0x0083, 0x0004}, /* index: 139, gain:16.668150db->x6.814084, DCG:1 */
+	{0x0016, 0x0084, 0x0004}, /* index: 140, gain:16.761900db->x6.888030, DCG:1 */
+	{0x0017, 0x0080, 0x0004}, /* index: 141, gain:16.855650db->x6.962777, DCG:1 */
+	{0x0017, 0x0082, 0x0004}, /* index: 142, gain:16.949400db->x7.038336, DCG:1 */
+	{0x0017, 0x0083, 0x0004}, /* index: 143, gain:17.043150db->x7.114715, DCG:1 */
+	{0x0018, 0x0080, 0x0004}, /* index: 144, gain:17.136900db->x7.191923, DCG:1 */
+	{0x0018, 0x0081, 0x0004}, /* index: 145, gain:17.230650db->x7.269968, DCG:1 */
+	{0x0018, 0x0082, 0x0004}, /* index: 146, gain:17.324400db->x7.348860, DCG:1 */
+	{0x0018, 0x0084, 0x0004}, /* index: 147, gain:17.418150db->x7.428609, DCG:1 */
+	{0x0019, 0x0080, 0x0004}, /* index: 148, gain:17.511900db->x7.509223, DCG:1 */
+	{0x0019, 0x0081, 0x0004}, /* index: 149, gain:17.605650db->x7.590712, DCG:1 */
+	{0x0019, 0x0082, 0x0004}, /* index: 150, gain:17.699400db->x7.673085, DCG:1 */
+	{0x0019, 0x0084, 0x0004}, /* index: 151, gain:17.793150db->x7.756352, DCG:1 */
+	{0x0019, 0x0085, 0x0004}, /* index: 152, gain:17.886900db->x7.840522, DCG:1 */
+	{0x001a, 0x0080, 0x0004}, /* index: 153, gain:17.980650db->x7.925606, DCG:1 */
+	{0x001a, 0x0082, 0x0004}, /* index: 154, gain:18.074400db->x8.011614, DCG:1 */
+	{0x001a, 0x0083, 0x0004}, /* index: 155, gain:18.168150db->x8.098554, DCG:1 */
+	{0x001a, 0x0084, 0x0004}, /* index: 156, gain:18.261900db->x8.186438, DCG:1 */
+	{0x001b, 0x0081, 0x0004}, /* index: 157, gain:18.355650db->x8.275276, DCG:1 */
+	{0x001b, 0x0082, 0x0004}, /* index: 158, gain:18.449400db->x8.365078, DCG:1 */
+	{0x001b, 0x0083, 0x0004}, /* index: 159, gain:18.543150db->x8.455854, DCG:1 */
+	{0x001b, 0x0085, 0x0004}, /* index: 160, gain:18.636900db->x8.547616, DCG:1 */
+	{0x001c, 0x0080, 0x0004}, /* index: 161, gain:18.730650db->x8.640373, DCG:1 */
+	{0x001c, 0x0081, 0x0004}, /* index: 162, gain:18.824400db->x8.734137, DCG:1 */
+	{0x001c, 0x0082, 0x0004}, /* index: 163, gain:18.918150db->x8.828918, DCG:1 */
+	{0x001c, 0x0084, 0x0004}, /* index: 164, gain:19.011900db->x8.924728, DCG:1 */
+	{0x001c, 0x0085, 0x0004}, /* index: 165, gain:19.105650db->x9.021578, DCG:1 */
+	{0x001d, 0x0080, 0x0004}, /* index: 166, gain:19.199400db->x9.119478, DCG:1 */
+	{0x001d, 0x0082, 0x0004}, /* index: 167, gain:19.293150db->x9.218441, DCG:1 */
+	{0x001d, 0x0083, 0x0004}, /* index: 168, gain:19.386900db->x9.318478, DCG:1 */
+	{0x001d, 0x0084, 0x0004}, /* index: 169, gain:19.480650db->x9.419601, DCG:1 */
+	{0x001d, 0x0086, 0x0004}, /* index: 170, gain:19.574400db->x9.521821, DCG:1 */
+	{0x001e, 0x0080, 0x0004}, /* index: 171, gain:19.668150db->x9.625150, DCG:1 */
+	{0x001e, 0x0081, 0x0004}, /* index: 172, gain:19.761900db->x9.729600, DCG:1 */
+	{0x001e, 0x0082, 0x0004}, /* index: 173, gain:19.855650db->x9.835184, DCG:1 */
+	{0x001e, 0x0084, 0x0004}, /* index: 174, gain:19.949400db->x9.941914, DCG:1 */
+	{0x001e, 0x0085, 0x0004}, /* index: 175, gain:20.043150db->x10.049802, DCG:1 */
+	{0x001f, 0x0080, 0x0004}, /* index: 176, gain:20.136900db->x10.158861, DCG:1 */
+	{0x001f, 0x0081, 0x0004}, /* index: 177, gain:20.230650db->x10.269103, DCG:1 */
+	{0x001f, 0x0082, 0x0004}, /* index: 178, gain:20.324400db->x10.380541, DCG:1 */
+	{0x001f, 0x0084, 0x0004}, /* index: 179, gain:20.418150db->x10.493189, DCG:1 */
+	{0x001f, 0x0085, 0x0004}, /* index: 180, gain:20.511900db->x10.607059, DCG:1 */
+	{0x001f, 0x0087, 0x0004}, /* index: 181, gain:20.605650db->x10.722165, DCG:1 */
+	{0x0020, 0x0080, 0x0004}, /* index: 182, gain:20.699400db->x10.838520, DCG:1 */
+	{0x0020, 0x0081, 0x0004}, /* index: 183, gain:20.793150db->x10.956138, DCG:1 */
+	{0x0020, 0x0083, 0x0004}, /* index: 184, gain:20.886900db->x11.075032, DCG:1 */
+	{0x0021, 0x0080, 0x0004}, /* index: 185, gain:20.980650db->x11.195217, DCG:1 */
+	{0x0021, 0x0082, 0x0004}, /* index: 186, gain:21.074400db->x11.316705, DCG:1 */
+	{0x0021, 0x0083, 0x0004}, /* index: 187, gain:21.168150db->x11.439512, DCG:1 */
+	{0x0022, 0x0080, 0x0004}, /* index: 188, gain:21.261900db->x11.563652, DCG:1 */
+	{0x0022, 0x0081, 0x0004}, /* index: 189, gain:21.355650db->x11.689138, DCG:1 */
+	{0x0022, 0x0082, 0x0004}, /* index: 190, gain:21.449400db->x11.815987, DCG:1 */
+	{0x0023, 0x0080, 0x0004}, /* index: 191, gain:21.543150db->x11.944212, DCG:1 */
+	{0x0023, 0x0082, 0x0004}, /* index: 192, gain:21.636900db->x12.073828, DCG:1 */
+	{0x0023, 0x0083, 0x0004}, /* index: 193, gain:21.730650db->x12.204852, DCG:1 */
+	{0x0024, 0x0080, 0x0004}, /* index: 194, gain:21.824400db->x12.337296, DCG:1 */
+	{0x0024, 0x0081, 0x0004}, /* index: 195, gain:21.918150db->x12.471179, DCG:1 */
+	{0x0024, 0x0083, 0x0004}, /* index: 196, gain:22.011900db->x12.606514, DCG:1 */
+	{0x0024, 0x0084, 0x0004}, /* index: 197, gain:22.105650db->x12.743317, DCG:1 */
+	{0x0025, 0x0080, 0x0004}, /* index: 198, gain:22.199400db->x12.881606, DCG:1 */
+	{0x0025, 0x0081, 0x0004}, /* index: 199, gain:22.293150db->x13.021395, DCG:1 */
+	{0x0025, 0x0083, 0x0004}, /* index: 200, gain:22.386900db->x13.162701, DCG:1 */
+	{0x0026, 0x0080, 0x0004}, /* index: 201, gain:22.480650db->x13.305540, DCG:1 */
+	{0x0026, 0x0081, 0x0004}, /* index: 202, gain:22.574400db->x13.449929, DCG:1 */
+	{0x0026, 0x0083, 0x0004}, /* index: 203, gain:22.668150db->x13.595886, DCG:1 */
+	{0x0026, 0x0084, 0x0004}, /* index: 204, gain:22.761900db->x13.743426, DCG:1 */
+	{0x0027, 0x0080, 0x0004}, /* index: 205, gain:22.855650db->x13.892567, DCG:1 */
+	{0x0027, 0x0082, 0x0004}, /* index: 206, gain:22.949400db->x14.043327, DCG:1 */
+	{0x0027, 0x0083, 0x0004}, /* index: 207, gain:23.043150db->x14.195722, DCG:1 */
+	{0x0027, 0x0084, 0x0004}, /* index: 208, gain:23.136900db->x14.349772, DCG:1 */
+	{0x0028, 0x0081, 0x0004}, /* index: 209, gain:23.230650db->x14.505493, DCG:1 */
+	{0x0028, 0x0082, 0x0004}, /* index: 210, gain:23.324400db->x14.662904, DCG:1 */
+	{0x0028, 0x0084, 0x0004}, /* index: 211, gain:23.418150db->x14.822024, DCG:1 */
+	{0x0028, 0x0085, 0x0004}, /* index: 212, gain:23.511900db->x14.982870, DCG:1 */
+	{0x0029, 0x0081, 0x0004}, /* index: 213, gain:23.605650db->x15.145461, DCG:1 */
+	{0x0029, 0x0082, 0x0004}, /* index: 214, gain:23.699400db->x15.309817, DCG:1 */
+	{0x0029, 0x0083, 0x0004}, /* index: 215, gain:23.793150db->x15.475956, DCG:1 */
+	{0x0029, 0x0085, 0x0004}, /* index: 216, gain:23.886900db->x15.643899, DCG:1 */
+	{0x002a, 0x0080, 0x0004}, /* index: 217, gain:23.980650db->x15.813664, DCG:1 */
+	{0x002a, 0x0081, 0x0004}, /* index: 218, gain:24.074400db->x15.985271, DCG:1 */
+	{0x002a, 0x0083, 0x0004}, /* index: 219, gain:24.168150db->x16.158740, DCG:1 */
+	{0x002a, 0x0084, 0x0004}, /* index: 220, gain:24.261900db->x16.334092, DCG:1 */
+	{0x002b, 0x0080, 0x0004}, /* index: 221, gain:24.355650db->x16.511347, DCG:1 */
+	{0x002b, 0x0082, 0x0004}, /* index: 222, gain:24.449400db->x16.690525, DCG:1 */
+	{0x002b, 0x0083, 0x0004}, /* index: 223, gain:24.543150db->x16.871648, DCG:1 */
+	{0x002b, 0x0084, 0x0004}, /* index: 224, gain:24.636900db->x17.054736, DCG:1 */
+	{0x002b, 0x0086, 0x0004}, /* index: 225, gain:24.730650db->x17.239811, DCG:1 */
+	{0x002c, 0x0081, 0x0004}, /* index: 226, gain:24.824400db->x17.426894, DCG:1 */
+	{0x002c, 0x0082, 0x0004}, /* index: 227, gain:24.918150db->x17.616008, DCG:1 */
+	{0x002c, 0x0083, 0x0004}, /* index: 228, gain:25.011900db->x17.807174, DCG:1 */
+	{0x002c, 0x0085, 0x0004}, /* index: 229, gain:25.105650db->x18.000414, DCG:1 */
+	{0x002d, 0x0080, 0x0004}, /* index: 230, gain:25.199400db->x18.195752, DCG:1 */
+	{0x002d, 0x0081, 0x0004}, /* index: 231, gain:25.293150db->x18.393209, DCG:1 */
+	{0x002d, 0x0083, 0x0004}, /* index: 232, gain:25.386900db->x18.592809, DCG:1 */
+	{0x002d, 0x0084, 0x0004}, /* index: 233, gain:25.480650db->x18.794575, DCG:1 */
+	{0x002d, 0x0086, 0x0004}, /* index: 234, gain:25.574400db->x18.998530, DCG:1 */
+	{0x002d, 0x0087, 0x0004}, /* index: 235, gain:25.668150db->x19.204699, DCG:1 */
+	{0x002e, 0x0081, 0x0004}, /* index: 236, gain:25.761900db->x19.413105, DCG:1 */
+	{0x002e, 0x0082, 0x0004}, /* index: 237, gain:25.855650db->x19.623772, DCG:1 */
+	{0x002e, 0x0084, 0x0004}, /* index: 238, gain:25.949400db->x19.836726, DCG:1 */
+	{0x002e, 0x0085, 0x0004}, /* index: 239, gain:26.043150db->x20.051991, DCG:1 */
+	{0x002e, 0x0086, 0x0004}, /* index: 240, gain:26.136900db->x20.269592, DCG:1 */
+	{0x002f, 0x0081, 0x0004}, /* index: 241, gain:26.230650db->x20.489554, DCG:1 */
+	{0x002f, 0x0082, 0x0004}, /* index: 242, gain:26.324400db->x20.711903, DCG:1 */
+	{0x002f, 0x0083, 0x0004}, /* index: 243, gain:26.418150db->x20.936665, DCG:1 */
+	{0x002f, 0x0085, 0x0004}, /* index: 244, gain:26.511900db->x21.163866, DCG:1 */
+	{0x002f, 0x0086, 0x0004}, /* index: 245, gain:26.605650db->x21.393532, DCG:1 */
+	{0x0030, 0x0080, 0x0004}, /* index: 246, gain:26.699400db->x21.625691, DCG:1 */
+	{0x0030, 0x0081, 0x0004}, /* index: 247, gain:26.793150db->x21.860370, DCG:1 */
+	{0x0030, 0x0082, 0x0004}, /* index: 248, gain:26.886900db->x22.097595, DCG:1 */
+	{0x0031, 0x0080, 0x0004}, /* index: 249, gain:26.980650db->x22.337394, DCG:1 */
+	{0x0031, 0x0081, 0x0004}, /* index: 250, gain:27.074400db->x22.579795, DCG:1 */
+	{0x0031, 0x0083, 0x0004}, /* index: 251, gain:27.168150db->x22.824827, DCG:1 */
+	{0x0031, 0x0084, 0x0004}, /* index: 252, gain:27.261900db->x23.072518, DCG:1 */
+	{0x0032, 0x0081, 0x0004}, /* index: 253, gain:27.355650db->x23.322897, DCG:1 */
+	{0x0032, 0x0082, 0x0004}, /* index: 254, gain:27.449400db->x23.575993, DCG:1 */
+	{0x0033, 0x0080, 0x0004}, /* index: 255, gain:27.543150db->x23.831836, DCG:1 */
+	{0x0033, 0x0081, 0x0004}, /* index: 256, gain:27.636900db->x24.090455, DCG:1 */
+	{0x0033, 0x0083, 0x0004}, /* index: 257, gain:27.730650db->x24.351880, DCG:1 */
+	{0x0033, 0x0084, 0x0004}, /* index: 258, gain:27.824400db->x24.616143, DCG:1 */
+	{0x0034, 0x0081, 0x0004}, /* index: 259, gain:27.918150db->x24.883273, DCG:1 */
+	{0x0034, 0x0082, 0x0004}, /* index: 260, gain:28.011900db->x25.153302, DCG:1 */
+	{0x0034, 0x0084, 0x0004}, /* index: 261, gain:28.105650db->x25.426261, DCG:1 */
+	{0x0034, 0x0085, 0x0004}, /* index: 262, gain:28.199400db->x25.702182, DCG:1 */
+	{0x0035, 0x0081, 0x0004}, /* index: 263, gain:28.293150db->x25.981098, DCG:1 */
+	{0x0035, 0x0082, 0x0004}, /* index: 264, gain:28.386900db->x26.263040, DCG:1 */
+	{0x0035, 0x0084, 0x0004}, /* index: 265, gain:28.480650db->x26.548042, DCG:1 */
+	{0x0036, 0x0081, 0x0004}, /* index: 266, gain:28.574400db->x26.836137, DCG:1 */
+	{0x0036, 0x0082, 0x0004}, /* index: 267, gain:28.668150db->x27.127358, DCG:1 */
+	{0x0036, 0x0084, 0x0004}, /* index: 268, gain:28.761900db->x27.421739, DCG:1 */
+	{0x0037, 0x0080, 0x0004}, /* index: 269, gain:28.855650db->x27.719315, DCG:1 */
+	{0x0037, 0x0081, 0x0004}, /* index: 270, gain:28.949400db->x28.020121, DCG:1 */
+	{0x0037, 0x0083, 0x0004}, /* index: 271, gain:29.043150db->x28.324190, DCG:1 */
+	{0x0037, 0x0084, 0x0004}, /* index: 272, gain:29.136900db->x28.631559, DCG:1 */
+	{0x0038, 0x0080, 0x0004}, /* index: 273, gain:29.230650db->x28.942264, DCG:1 */
+	{0x0038, 0x0082, 0x0004}, /* index: 274, gain:29.324400db->x29.256340, DCG:1 */
+	{0x0038, 0x0083, 0x0004}, /* index: 275, gain:29.418150db->x29.573825, DCG:1 */
+	{0x0038, 0x0085, 0x0004}, /* index: 276, gain:29.511900db->x29.894755, DCG:1 */
+	{0x0039, 0x0080, 0x0004}, /* index: 277, gain:29.605650db->x30.219168, DCG:1 */
+	{0x0039, 0x0082, 0x0004}, /* index: 278, gain:29.699400db->x30.547101, DCG:1 */
+	{0x0039, 0x0083, 0x0004}, /* index: 279, gain:29.793150db->x30.878593, DCG:1 */
+	{0x0039, 0x0085, 0x0004}, /* index: 280, gain:29.886900db->x31.213682, DCG:1 */
+	{0x003a, 0x0080, 0x0004}, /* index: 281, gain:29.980650db->x31.552407, DCG:1 */
+	{0x003a, 0x0081, 0x0004}, /* index: 282, gain:30.074400db->x31.894809, DCG:1 */
+	{0x003a, 0x0082, 0x0004}, /* index: 283, gain:30.168150db->x32.240925, DCG:1 */
+	{0x003a, 0x0084, 0x0004}, /* index: 284, gain:30.261900db->x32.590798, DCG:1 */
+	{0x003b, 0x0080, 0x0004}, /* index: 285, gain:30.355650db->x32.944468, DCG:1 */
+	{0x003b, 0x0081, 0x0004}, /* index: 286, gain:30.449400db->x33.301976, DCG:1 */
+	{0x003b, 0x0083, 0x0004}, /* index: 287, gain:30.543150db->x33.663363, DCG:1 */
+	{0x003b, 0x0084, 0x0004}, /* index: 288, gain:30.636900db->x34.028672, DCG:1 */
+	{0x003b, 0x0086, 0x0004}, /* index: 289, gain:30.730650db->x34.397945, DCG:1 */
+	{0x003c, 0x0080, 0x0004}, /* index: 290, gain:30.824400db->x34.771226, DCG:1 */
+	{0x003c, 0x0082, 0x0004}, /* index: 291, gain:30.918150db->x35.148557, DCG:1 */
+	{0x003c, 0x0083, 0x0004}, /* index: 292, gain:31.011900db->x35.529983, DCG:1 */
+	{0x003c, 0x0085, 0x0004}, /* index: 293, gain:31.105650db->x35.915548, DCG:1 */
+	{0x003d, 0x0080, 0x0004}, /* index: 294, gain:31.199400db->x36.305298, DCG:1 */
+	{0x003d, 0x0081, 0x0004}, /* index: 295, gain:31.293150db->x36.699276, DCG:1 */
+	{0x003d, 0x0082, 0x0004}, /* index: 296, gain:31.386900db->x37.097530, DCG:1 */
+	{0x003d, 0x0084, 0x0004}, /* index: 297, gain:31.480650db->x37.500106, DCG:1 */
+	{0x003d, 0x0085, 0x0004}, /* index: 298, gain:31.574400db->x37.907051, DCG:1 */
+	{0x003d, 0x0087, 0x0004}, /* index: 299, gain:31.668150db->x38.318412, DCG:1 */
+	{0x003e, 0x0080, 0x0004}, /* index: 300, gain:31.761900db->x38.734237, DCG:1 */
+	{0x003e, 0x0082, 0x0004}, /* index: 301, gain:31.855650db->x39.154574, DCG:1 */
+	{0x003e, 0x0083, 0x0004}, /* index: 302, gain:31.949400db->x39.579472, DCG:1 */
+	{0x003e, 0x0085, 0x0004}, /* index: 303, gain:32.043150db->x40.008982, DCG:1 */
+	{0x003e, 0x0086, 0x0004}, /* index: 304, gain:32.136900db->x40.443152, DCG:1 */
+	{0x003f, 0x0080, 0x0004}, /* index: 305, gain:32.230650db->x40.882034, DCG:1 */
+	{0x003f, 0x0082, 0x0004}, /* index: 306, gain:32.324400db->x41.325679, DCG:1 */
+	{0x003f, 0x0083, 0x0004}, /* index: 307, gain:32.418150db->x41.774138, DCG:1 */
+	{0x003f, 0x0085, 0x0004}, /* index: 308, gain:32.511900db->x42.227464, DCG:1 */
+	{0x003f, 0x0086, 0x0004}, /* index: 309, gain:32.605650db->x42.685709, DCG:1 */
+	{0x003f, 0x0088, 0x0004}, /* index: 310, gain:32.699400db->x43.148927, DCG:1 */
+	{0x0040, 0x0081, 0x0004}, /* index: 311, gain:32.793150db->x43.617172, DCG:1 */
+	{0x0040, 0x0082, 0x0004}, /* index: 312, gain:32.886900db->x44.090498, DCG:1 */
+	{0x0041, 0x0080, 0x0004}, /* index: 313, gain:32.980650db->x44.568960, DCG:1 */
+	{0x0041, 0x0081, 0x0004}, /* index: 314, gain:33.074400db->x45.052615, DCG:1 */
+	{0x0041, 0x0083, 0x0004}, /* index: 315, gain:33.168150db->x45.541518, DCG:1 */
+	{0x0041, 0x0084, 0x0004}, /* index: 316, gain:33.261900db->x46.035726, DCG:1 */
+	{0x0042, 0x0080, 0x0004}, /* index: 317, gain:33.355650db->x46.535298, DCG:1 */
+	{0x0042, 0x0082, 0x0004}, /* index: 318, gain:33.449400db->x47.040291, DCG:1 */
+	{0x0043, 0x0080, 0x0004}, /* index: 319, gain:33.543150db->x47.550764, DCG:1 */
+	{0x0043, 0x0081, 0x0004}, /* index: 320, gain:33.636900db->x48.066777, DCG:1 */
+	{0x0043, 0x0082, 0x0004}, /* index: 321, gain:33.730650db->x48.588389, DCG:1 */
+	{0x0043, 0x0084, 0x0004}, /* index: 322, gain:33.824400db->x49.115662, DCG:1 */
+	{0x0044, 0x0081, 0x0004}, /* index: 323, gain:33.918150db->x49.648656, DCG:1 */
+	{0x0044, 0x0082, 0x0004}, /* index: 324, gain:34.011900db->x50.187435, DCG:1 */
+	{0x0044, 0x0083, 0x0004}, /* index: 325, gain:34.105650db->x50.732060, DCG:1 */
+	{0x0044, 0x0085, 0x0004}, /* index: 326, gain:34.199400db->x51.282596, DCG:1 */
+	{0x0045, 0x0081, 0x0004}, /* index: 327, gain:34.293150db->x51.839106, DCG:1 */
+	{0x0045, 0x0082, 0x0004}, /* index: 328, gain:34.386900db->x52.401655, DCG:1 */
+	{0x0045, 0x0083, 0x0004}, /* index: 329, gain:34.480650db->x52.970308, DCG:1 */
+	{0x0046, 0x0080, 0x0004}, /* index: 330, gain:34.574400db->x53.545133, DCG:1 */
+	{0x0046, 0x0082, 0x0004}, /* index: 331, gain:34.668150db->x54.126195, DCG:1 */
+	{0x0046, 0x0083, 0x0004}, /* index: 332, gain:34.761900db->x54.713563, DCG:1 */
+	{0x0047, 0x0080, 0x0004}, /* index: 333, gain:34.855650db->x55.307305, DCG:1 */
+	{0x0047, 0x0081, 0x0004}, /* index: 334, gain:34.949400db->x55.907491, DCG:1 */
+	{0x0047, 0x0082, 0x0004}, /* index: 335, gain:35.043150db->x56.514189, DCG:1 */
+	{0x0047, 0x0084, 0x0004}, /* index: 336, gain:35.136900db->x57.127471, DCG:1 */
+	{0x0048, 0x0080, 0x0004}, /* index: 337, gain:35.230650db->x57.747409, DCG:1 */
+	{0x0048, 0x0082, 0x0004}, /* index: 338, gain:35.324400db->x58.374073, DCG:1 */
+	{0x0048, 0x0083, 0x0004}, /* index: 339, gain:35.418150db->x59.007539, DCG:1 */
+	{0x0048, 0x0084, 0x0004}, /* index: 340, gain:35.511900db->x59.647878, DCG:1 */
+	{0x0049, 0x0080, 0x0004}, /* index: 341, gain:35.605650db->x60.295167, DCG:1 */
+	{0x0049, 0x0081, 0x0004}, /* index: 342, gain:35.699400db->x60.949479, DCG:1 */
+	{0x0049, 0x0083, 0x0004}, /* index: 343, gain:35.793150db->x61.610892, DCG:1 */
+	{0x0049, 0x0084, 0x0004}, /* index: 344, gain:35.886900db->x62.279483, DCG:1 */
+	{0x0049, 0x0086, 0x0004}, /* index: 345, gain:35.980650db->x62.955329, DCG:1 */
+	{0x004a, 0x0081, 0x0004}, /* index: 346, gain:36.074400db->x63.638510, DCG:1 */
+	{0x004a, 0x0082, 0x0004}, /* index: 347, gain:36.168150db->x64.329104, DCG:1 */
+	{0x004a, 0x0083, 0x0004}, /* index: 348, gain:36.261900db->x65.027192, DCG:1 */
+	{0x004b, 0x0080, 0x0004}, /* index: 349, gain:36.355650db->x65.732856, DCG:1 */
+	{0x004b, 0x0081, 0x0004}, /* index: 350, gain:36.449400db->x66.446177, DCG:1 */
+	{0x004b, 0x0082, 0x0004}, /* index: 351, gain:36.543150db->x67.167240, DCG:1 */
+	{0x004b, 0x0084, 0x0004}, /* index: 352, gain:36.636900db->x67.896127, DCG:1 */
+	{0x004b, 0x0085, 0x0004}, /* index: 353, gain:36.730650db->x68.632924, DCG:1 */
+	{0x004c, 0x0080, 0x0004}, /* index: 354, gain:36.824400db->x69.377716, DCG:1 */
+	{0x004c, 0x0081, 0x0004}, /* index: 355, gain:36.918150db->x70.130591, DCG:1 */
+	{0x004c, 0x0083, 0x0004}, /* index: 356, gain:37.011900db->x70.891636, DCG:1 */
+	{0x004c, 0x0084, 0x0004}, /* index: 357, gain:37.105650db->x71.660940, DCG:1 */
+	{0x004c, 0x0086, 0x0004}, /* index: 358, gain:37.199400db->x72.438592, DCG:1 */
+	{0x004d, 0x0081, 0x0004}, /* index: 359, gain:37.293150db->x73.224683, DCG:1 */
+	{0x004d, 0x0082, 0x0004}, /* index: 360, gain:37.386900db->x74.019304, DCG:1 */
+	{0x004d, 0x0083, 0x0004}, /* index: 361, gain:37.480650db->x74.822549, DCG:1 */
+	{0x004d, 0x0085, 0x0004}, /* index: 362, gain:37.574400db->x75.634510, DCG:1 */
+	{0x004d, 0x0086, 0x0004}, /* index: 363, gain:37.668150db->x76.455283, DCG:1 */
+	{0x004e, 0x0080, 0x0004}, /* index: 364, gain:37.761900db->x77.284962, DCG:1 */
+	{0x004e, 0x0082, 0x0004}, /* index: 365, gain:37.855650db->x78.123645, DCG:1 */
+	{0x004e, 0x0083, 0x0004}, /* index: 366, gain:37.949400db->x78.971430, DCG:1 */
+	{0x004e, 0x0084, 0x0004}, /* index: 367, gain:38.043150db->x79.828414, DCG:1 */
+	{0x004e, 0x0086, 0x0004}, /* index: 368, gain:38.136900db->x80.694698, DCG:1 */
+	{0x004f, 0x0080, 0x0004}, /* index: 369, gain:38.230650db->x81.570383, DCG:1 */
+	{0x004f, 0x0081, 0x0004}, /* index: 370, gain:38.324400db->x82.455570, DCG:1 */
+	{0x004f, 0x0083, 0x0004}, /* index: 371, gain:38.418150db->x83.350364, DCG:1 */
+	{0x004f, 0x0084, 0x0004}, /* index: 372, gain:38.511900db->x84.254868, DCG:1 */
+	{0x004f, 0x0086, 0x0004}, /* index: 373, gain:38.605650db->x85.169187, DCG:1 */
+	{0x004f, 0x0087, 0x0004}, /* index: 374, gain:38.699400db->x86.093428, DCG:1 */
+	{0x004f, 0x0089, 0x0004}, /* index: 375, gain:38.793150db->x87.027699, DCG:1 */
+	{0x004f, 0x008a, 0x0004}, /* index: 376, gain:38.886900db->x87.972108, DCG:1 */
+	{0x004f, 0x008c, 0x0004}, /* index: 377, gain:38.980650db->x88.926766, DCG:1 */
+	{0x004f, 0x008d, 0x0004}, /* index: 378, gain:39.074400db->x89.891784, DCG:1 */
+	{0x004f, 0x008f, 0x0004}, /* index: 379, gain:39.168150db->x90.867274, DCG:1 */
+	{0x004f, 0x0090, 0x0004}, /* index: 380, gain:39.261900db->x91.853350, DCG:1 */
+	{0x004f, 0x0092, 0x0004}, /* index: 381, gain:39.355650db->x92.850127, DCG:1 */
+	{0x004f, 0x0093, 0x0004}, /* index: 382, gain:39.449400db->x93.857720, DCG:1 */
+	{0x004f, 0x0095, 0x0004}, /* index: 383, gain:39.543150db->x94.876248, DCG:1 */
+	{0x004f, 0x0097, 0x0004}, /* index: 384, gain:39.636900db->x95.905828, DCG:1 */
+	{0x004f, 0x0098, 0x0004}, /* index: 385, gain:39.730650db->x96.946582, DCG:1 */
+	{0x004f, 0x009a, 0x0004}, /* index: 386, gain:39.824400db->x97.998629, DCG:1 */
+	{0x004f, 0x009c, 0x0004}, /* index: 387, gain:39.918150db->x99.062093, DCG:1 */
+	{0x004f, 0x009d, 0x0004}, /* index: 388, gain:40.011900db->x100.137098, DCG:1 */
+	{0x004f, 0x009f, 0x0004}, /* index: 389, gain:40.105650db->x101.223768, DCG:1 */
+	{0x004f, 0x00a1, 0x0004}, /* index: 390, gain:40.199400db->x102.322231, DCG:1 */
+	{0x004f, 0x00a3, 0x0004}, /* index: 391, gain:40.293150db->x103.432614, DCG:1 */
+	{0x004f, 0x00a4, 0x0004}, /* index: 392, gain:40.386900db->x104.555047, DCG:1 */
+	{0x004f, 0x00a6, 0x0004}, /* index: 393, gain:40.480650db->x105.689660, DCG:1 */
+	{0x004f, 0x00a8, 0x0004}, /* index: 394, gain:40.574400db->x106.836586, DCG:1 */
+	{0x004f, 0x00aa, 0x0004}, /* index: 395, gain:40.668150db->x107.995958, DCG:1 */
+	{0x004f, 0x00ac, 0x0004}, /* index: 396, gain:40.761900db->x109.167911, DCG:1 */
+	{0x004f, 0x00ad, 0x0004}, /* index: 397, gain:40.855650db->x110.352582, DCG:1 */
+	{0x004f, 0x00af, 0x0004}, /* index: 398, gain:40.949400db->x111.550109, DCG:1 */
+	{0x004f, 0x00b1, 0x0004}, /* index: 399, gain:41.043150db->x112.760632, DCG:1 */
+	{0x004f, 0x00b3, 0x0004}, /* index: 400, gain:41.136900db->x113.984290, DCG:1 */
+	{0x004f, 0x00b5, 0x0004}, /* index: 401, gain:41.230650db->x115.221228, DCG:1 */
+	{0x004f, 0x00b7, 0x0004}, /* index: 402, gain:41.324400db->x116.471589, DCG:1 */
+	{0x004f, 0x00b9, 0x0004}, /* index: 403, gain:41.418150db->x117.735518, DCG:1 */
+	{0x004f, 0x00bb, 0x0004}, /* index: 404, gain:41.511900db->x119.013164, DCG:1 */
+	{0x004f, 0x00bd, 0x0004}, /* index: 405, gain:41.605650db->x120.304674, DCG:1 */
+	{0x004f, 0x00bf, 0x0004}, /* index: 406, gain:41.699400db->x121.610199, DCG:1 */
+	{0x004f, 0x00c1, 0x0004}, /* index: 407, gain:41.793150db->x122.929892, DCG:1 */
+	{0x004f, 0x00c3, 0x0004}, /* index: 408, gain:41.886900db->x124.263906, DCG:1 */
+	{0x004f, 0x00c5, 0x0004}, /* index: 409, gain:41.980650db->x125.612396, DCG:1 */
+	{0x004f, 0x00c8, 0x0004}, /* index: 410, gain:42.074400db->x126.975520, DCG:1 */
+	{0x004f, 0x00ca, 0x0004}, /* index: 411, gain:42.168150db->x128.353436, DCG:1 */
+	{0x004f, 0x00cc, 0x0004}, /* index: 412, gain:42.261900db->x129.746305, DCG:1 */
+	{0x004f, 0x00ce, 0x0004}, /* index: 413, gain:42.355650db->x131.154290, DCG:1 */
+	{0x004f, 0x00d0, 0x0004}, /* index: 414, gain:42.449400db->x132.577553, DCG:1 */
+	{0x004f, 0x00d3, 0x0004}, /* index: 415, gain:42.543150db->x134.016262, DCG:1 */
+	{0x004f, 0x00d5, 0x0004}, /* index: 416, gain:42.636900db->x135.470583, DCG:1 */
+	{0x004f, 0x00d7, 0x0004}, /* index: 417, gain:42.730650db->x136.940686, DCG:1 */
+	{0x004f, 0x00da, 0x0004}, /* index: 418, gain:42.824400db->x138.426743, DCG:1 */
+	{0x004f, 0x00dc, 0x0004}, /* index: 419, gain:42.918150db->x139.928926, DCG:1 */
+	{0x004f, 0x00de, 0x0004}, /* index: 420, gain:43.011900db->x141.447410, DCG:1 */
+	{0x004f, 0x00e1, 0x0004}, /* index: 421, gain:43.105650db->x142.982373, DCG:1 */
+	{0x004f, 0x00e3, 0x0004}, /* index: 422, gain:43.199400db->x144.533993, DCG:1 */
+	{0x004f, 0x00e6, 0x0004}, /* index: 423, gain:43.293150db->x146.102450, DCG:1 */
+	{0x004f, 0x00e8, 0x0004}, /* index: 424, gain:43.386900db->x147.687929, DCG:1 */
+	{0x004f, 0x00eb, 0x0004}, /* index: 425, gain:43.480650db->x149.290613, DCG:1 */
+	{0x004f, 0x00ed, 0x0004}, /* index: 426, gain:43.574400db->x150.910688, DCG:1 */
+	{0x004f, 0x00f0, 0x0004}, /* index: 427, gain:43.668150db->x152.548345, DCG:1 */
+	{0x004f, 0x00f3, 0x0004}, /* index: 428, gain:43.761900db->x154.203773, DCG:1 */
+	{0x004f, 0x00f5, 0x0004}, /* index: 429, gain:43.855650db->x155.877166, DCG:1 */
+	{0x004f, 0x00f8, 0x0004}, /* index: 430, gain:43.949400db->x157.568717, DCG:1 */
+	{0x004f, 0x00fb, 0x0004}, /* index: 431, gain:44.043150db->x159.278626, DCG:1 */
+	{0x004f, 0x00fd, 0x0004}, /* index: 432, gain:44.136900db->x161.007090, DCG:1 */
+	{0x004f, 0x0100, 0x0004}, /* index: 433, gain:44.230650db->x162.754311, DCG:1 */
+	{0x004f, 0x0103, 0x0004}, /* index: 434, gain:44.324400db->x164.520492, DCG:1 */
+	{0x004f, 0x0106, 0x0004}, /* index: 435, gain:44.418150db->x166.305840, DCG:1 */
+	{0x004f, 0x0108, 0x0004}, /* index: 436, gain:44.511900db->x168.110562, DCG:1 */
+	{0x004f, 0x010b, 0x0004}, /* index: 437, gain:44.605650db->x169.934869, DCG:1 */
+	{0x004f, 0x010e, 0x0004}, /* index: 438, gain:44.699400db->x171.778972, DCG:1 */
+	{0x004f, 0x0111, 0x0004}, /* index: 439, gain:44.793150db->x173.643088, DCG:1 */
+	{0x004f, 0x0114, 0x0004}, /* index: 440, gain:44.886900db->x175.527432, DCG:1 */
+	{0x004f, 0x0117, 0x0004}, /* index: 441, gain:44.980650db->x177.432226, DCG:1 */
+	{0x004f, 0x011a, 0x0004}, /* index: 442, gain:45.074400db->x179.357689, DCG:1 */
+	{0x004f, 0x011d, 0x0004}, /* index: 443, gain:45.168150db->x181.304048, DCG:1 */
+	{0x004f, 0x0120, 0x0004}, /* index: 444, gain:45.261900db->x183.271528, DCG:1 */
+	{0x004f, 0x0123, 0x0004}, /* index: 445, gain:45.355650db->x185.260358, DCG:1 */
+	{0x004f, 0x0127, 0x0004}, /* index: 446, gain:45.449400db->x187.270772, DCG:1 */
+	{0x004f, 0x012a, 0x0004}, /* index: 447, gain:45.543150db->x189.303002, DCG:1 */
+	{0x004f, 0x012d, 0x0004}, /* index: 448, gain:45.636900db->x191.357285, DCG:1 */
+	{0x004f, 0x0130, 0x0004}, /* index: 449, gain:45.730650db->x193.433861, DCG:1 */
+	{0x004f, 0x0134, 0x0004}, /* index: 450, gain:45.824400db->x195.532971, DCG:1 */
+	{0x004f, 0x0137, 0x0004}, /* index: 451, gain:45.918150db->x197.654861, DCG:1 */
+	{0x004f, 0x013a, 0x0004}, /* index: 452, gain:46.011900db->x199.799777, DCG:1 */
+	{0x004f, 0x013e, 0x0004}, /* index: 453, gain:46.105650db->x201.967970, DCG:1 */
+	{0x004f, 0x0141, 0x0004}, /* index: 454, gain:46.199400db->x204.159691, DCG:1 */
+	{0x004f, 0x0145, 0x0004}, /* index: 455, gain:46.293150db->x206.375197, DCG:1 */
+	{0x004f, 0x0148, 0x0004}, /* index: 456, gain:46.386900db->x208.614744, DCG:1 */
+	{0x004f, 0x014c, 0x0004}, /* index: 457, gain:46.480650db->x210.878595, DCG:1 */
+	{0x004f, 0x014f, 0x0004}, /* index: 458, gain:46.574400db->x213.167013, DCG:1 */
+	{0x004f, 0x0153, 0x0004}, /* index: 459, gain:46.668150db->x215.480265, DCG:1 */
+	{0x004f, 0x0157, 0x0004}, /* index: 460, gain:46.761900db->x217.818619, DCG:1 */
+	{0x004f, 0x015b, 0x0004}, /* index: 461, gain:46.855650db->x220.182349, DCG:1 */
+	{0x004f, 0x015e, 0x0004}, /* index: 462, gain:46.949400db->x222.571729, DCG:1 */
+	{0x004f, 0x0162, 0x0004}, /* index: 463, gain:47.043150db->x224.987039, DCG:1 */
+	{0x004f, 0x0166, 0x0004}, /* index: 464, gain:47.136900db->x227.428559, DCG:1 */
+	{0x004f, 0x016a, 0x0004}, /* index: 465, gain:47.230650db->x229.896574, DCG:1 */
+	{0x004f, 0x016e, 0x0004}, /* index: 466, gain:47.324400db->x232.391372, DCG:1 */
+	{0x004f, 0x0172, 0x0004}, /* index: 467, gain:47.418150db->x234.913243, DCG:1 */
+	{0x004f, 0x0176, 0x0004}, /* index: 468, gain:47.511900db->x237.462480, DCG:1 */
+	{0x004f, 0x017a, 0x0004}, /* index: 469, gain:47.605650db->x240.039382, DCG:1 */
+	{0x004f, 0x017e, 0x0004}, /* index: 470, gain:47.699400db->x242.644248, DCG:1 */
+	{0x004f, 0x0182, 0x0004}, /* index: 471, gain:47.793150db->x245.277381, DCG:1 */
+	{0x004f, 0x0186, 0x0004}, /* index: 472, gain:47.886900db->x247.939088, DCG:1 */
+	{0x004f, 0x018b, 0x0004}, /* index: 473, gain:47.980650db->x250.629680, DCG:1 */
+	{0x004f, 0x018f, 0x0004}, /* index: 474, gain:48.074400db->x253.349470, DCG:1 */
+};
diff --git a/drivers/vin/sensors/onsemi_ar0237_parallel/make.inc b/drivers/vin/sensors/onsemi_ar0237_parallel/make.inc
new file mode 100644
index 0000000..87fb32f
--- /dev/null
+++ b/drivers/vin/sensors/onsemi_ar0237_parallel/make.inc
@@ -0,0 +1,45 @@
+##
+## kernel/private/drivers/vin/sensors/onsemi_ar0237_parallel/make.inc
+##
+## History:
+##    2015/09/07 - [Hao Zeng] Create
+##
+## Copyright (c) 2015 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+ifeq ($(CONFIG_SENSOR_AR0237P), y)
+
+LOCAL_PATH	:= $(call my-dir)
+
+###
+include $(CLEAR_VARS)
+
+LOCAL_SRCS	:= $(wildcard $(LOCAL_PATH)/*.c) $(wildcard $(LOCAL_PATH)/*.h)
+LOCAL_SRCS	+= $(LOCAL_PATH)/Kbuild
+
+include $(BUILD_DRIVER)
+
+endif
+
diff --git a/drivers/vin/sensors/panasonic_mn34227pl/Kbuild b/drivers/vin/sensors/panasonic_mn34227pl/Kbuild
new file mode 100644
index 0000000..cdea4c4
--- /dev/null
+++ b/drivers/vin/sensors/panasonic_mn34227pl/Kbuild
@@ -0,0 +1,38 @@
+##
+## Filename : Kbuild
+##
+## History:
+##    2012/12/24 - [Long Zhao] Create
+##
+## Copyright (c) 2015 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+
+EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
+EXTRA_AFLAGS		+= $(AMBARELLA_DRV_AFLAGS)
+EXTRA_LDFLAGS		+= $(AMBARELLA_DRV_LDFLAGS)
+
+obj-m := mn34227pl.o
+
diff --git a/drivers/vin/sensors/panasonic_mn34227pl/make.inc b/drivers/vin/sensors/panasonic_mn34227pl/make.inc
new file mode 100644
index 0000000..80d4605
--- /dev/null
+++ b/drivers/vin/sensors/panasonic_mn34227pl/make.inc
@@ -0,0 +1,45 @@
+##
+## kernel/private/drivers/vin/sensors/panasonic_mn34227pl/make.inc
+##
+## History:
+##    2012/06/04 - [Cao Rongrong] Created file
+##
+## Copyright (c) 2015 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+ifeq ($(CONFIG_SENSOR_MN34227PL), y)
+
+LOCAL_PATH	:= $(call my-dir)
+
+###
+include $(CLEAR_VARS)
+
+LOCAL_SRCS	:= $(wildcard $(LOCAL_PATH)/*.c) $(wildcard $(LOCAL_PATH)/*.h)
+LOCAL_SRCS	+= $(LOCAL_PATH)/Kbuild
+
+include $(BUILD_DRIVER)
+
+endif
+
diff --git a/drivers/vin/sensors/panasonic_mn34227pl/mn34227pl.c b/drivers/vin/sensors/panasonic_mn34227pl/mn34227pl.c
new file mode 100644
index 0000000..e19f05b
--- /dev/null
+++ b/drivers/vin/sensors/panasonic_mn34227pl/mn34227pl.c
@@ -0,0 +1,695 @@
+/*
+ * Filename : mn34227pl.c
+ *
+ * History:
+ *    2015/05/27 - [Long Zhao] Create
+ *
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/ambpriv_device.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <plat/spi.h>
+#include <iav_utils.h>
+#include <vin_api.h>
+#include "mn34227pl.h"
+
+static int bus_addr = (0 << 16) | (0x6C >> 1);
+module_param(bus_addr, int, 0644);
+MODULE_PARM_DESC(bus_addr, " bus and addr: bit16~bit31: bus, bit0~bit15: addr");
+
+struct mn34227pl_priv {
+	void *control_data;
+	struct vindev_wdr_gp_s wdr_again_gp;
+	struct vindev_wdr_gp_s wdr_dgain_gp;
+	struct vindev_wdr_gp_s wdr_shutter_gp;
+	u32 line_length;
+	u32 frame_length_lines;
+};
+
+#include "mn34227pl_table.c"
+
+static int mn34227pl_write_reg( struct vin_device *vdev, u32 subaddr, u32 data)
+{
+	int rval;
+	struct mn34227pl_priv *mn34227pl;
+	struct i2c_client *client;
+	struct i2c_msg msgs[1];
+	u8 pbuf[3];
+
+	mn34227pl = (struct mn34227pl_priv *)vdev->priv;
+	client = mn34227pl->control_data;
+
+	pbuf[0] = (subaddr & 0xff00) >> 8;
+	pbuf[1] = subaddr & 0xff;
+	pbuf[2] = data;
+
+	msgs[0].len = 3;
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].buf = pbuf;
+
+	rval = i2c_transfer(client->adapter, msgs, 1);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x:0x%x]\n", rval, subaddr, data);
+		return rval;
+	}
+
+	return 0;
+}
+
+static int mn34227pl_read_reg( struct vin_device *vdev, u32 subaddr, u32 *data)
+{
+	int rval = 0;
+	struct mn34227pl_priv *mn34227pl;
+	struct i2c_client *client;
+	struct i2c_msg msgs[2];
+	u8 pbuf0[2];
+	u8 pbuf[1];
+
+	mn34227pl = (struct mn34227pl_priv *)vdev->priv;
+	client = mn34227pl->control_data;
+
+	pbuf0[0] = (subaddr &0xff00) >> 8;
+	pbuf0[1] = subaddr & 0xff;
+
+	msgs[0].len = 2;
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].buf = pbuf0;
+
+	msgs[1].addr = client->addr;
+	msgs[1].flags = client->flags | I2C_M_RD;
+	msgs[1].buf = pbuf;
+	msgs[1].len = 1;
+
+	rval = i2c_transfer(client->adapter, msgs, 2);
+	if (rval < 0){
+		vin_error("failed(%d): [0x%x]\n", rval, subaddr);
+		return rval;
+	}
+
+	*data = pbuf[0];
+
+	return 0;
+}
+
+static int mn34227pl_set_vin_mode(struct vin_device *vdev, struct vin_video_format *format)
+{
+	struct vin_device_config mn34227pl_config;
+
+	memset(&mn34227pl_config, 0, sizeof (mn34227pl_config));
+
+	mn34227pl_config.interface_type = SENSOR_SERIAL_LVDS;
+	mn34227pl_config.sync_mode = SENSOR_SYNC_MODE_MASTER;
+
+	mn34227pl_config.slvds_cfg.lane_number = SENSOR_4_LANE;
+
+	if (format->hdr_mode == AMBA_VIDEO_LINEAR_MODE)
+		mn34227pl_config.slvds_cfg.sync_code_style = SENSOR_SYNC_STYLE_SONY;
+	else
+		mn34227pl_config.slvds_cfg.sync_code_style = SENSOR_SYNC_STYLE_PANASONIC;
+
+	mn34227pl_config.cap_win.x = format->def_start_x;
+	mn34227pl_config.cap_win.y = format->def_start_y;
+	mn34227pl_config.cap_win.width = format->def_width;
+	mn34227pl_config.cap_win.height = format->def_height;
+
+	/* for hdr sensor */
+	mn34227pl_config.hdr_cfg.act_win.x = format->act_start_x;
+	mn34227pl_config.hdr_cfg.act_win.y = format->act_start_y;
+	mn34227pl_config.hdr_cfg.act_win.width = format->act_width;
+	mn34227pl_config.hdr_cfg.act_win.height = format->act_height;
+	mn34227pl_config.hdr_cfg.act_win.max_width = format->max_act_width;
+	mn34227pl_config.hdr_cfg.act_win.max_height = format->max_act_height;
+
+	mn34227pl_config.sensor_id	= GENERIC_SENSOR;
+	mn34227pl_config.input_format	= AMBA_VIN_INPUT_FORMAT_RGB_RAW;
+	mn34227pl_config.bayer_pattern	= format->bayer_pattern;
+	mn34227pl_config.video_format	= format->format;
+	mn34227pl_config.bit_resolution	= format->bits;
+
+	return ambarella_set_vin_config(vdev, &mn34227pl_config);
+}
+
+static void mn34227pl_sw_reset(struct vin_device *vdev)
+{
+	mn34227pl_write_reg(vdev, 0x3001, 0x0000);
+}
+
+static int mn34227pl_init_device(struct vin_device *vdev)
+{
+	mn34227pl_sw_reset(vdev);
+
+	return 0;
+}
+
+static int mn34227pl_update_hv_info(struct vin_device *vdev)
+{
+	u32 val_high, val_low;
+	struct mn34227pl_priv *pinfo = (struct mn34227pl_priv *)vdev->priv;
+
+	mn34227pl_read_reg(vdev, 0x0343, &val_low);	/* HCYCLE_LSB */
+	mn34227pl_read_reg(vdev, 0x0342, &val_high);	/* HCYCLE_MSB */
+	pinfo->line_length = (val_high << 8) + val_low;
+	if(unlikely(!pinfo->line_length)) {
+		vin_error("line length is 0!\n");
+		return -EIO;
+	}
+
+	mn34227pl_read_reg(vdev, 0x0341, &val_low);/* VCYCLE_LSB */
+	mn34227pl_read_reg(vdev, 0x0340, &val_high);/* VCYCLE_MSB */
+	pinfo->frame_length_lines = (val_high << 8) + val_low;
+
+	return 0;
+}
+
+static int mn34227pl_get_line_time(struct vin_device *vdev)
+{
+	u64 h_clks;
+	struct mn34227pl_priv *pinfo = (struct mn34227pl_priv *)vdev->priv;
+
+	h_clks = (u64)pinfo->line_length * 512000000;
+	h_clks = DIV64_CLOSEST(h_clks, vdev->cur_pll->pixelclk);
+
+	vdev->cur_format->line_time = (u32)h_clks;
+
+	return 0;
+}
+
+static int mn34227pl_set_format(struct vin_device *vdev, struct vin_video_format *format)
+{
+	struct vin_reg_16_16 *regs;
+	int i, regs_num;
+	int rval;
+
+	switch (format->hdr_mode) {
+	case AMBA_VIDEO_LINEAR_MODE:
+		regs = mn34227pl_linear_mode_regs;
+		regs_num = ARRAY_SIZE(mn34227pl_linear_mode_regs);
+		break;
+	case AMBA_VIDEO_2X_HDR_MODE:
+		regs = mn34227pl_2x_wdr_mode_regs;
+		regs_num = ARRAY_SIZE(mn34227pl_2x_wdr_mode_regs);
+		break;
+	default:
+		regs = NULL;
+		regs_num = 0;
+		vin_info("Unsupported mode\n");
+		break;
+	}
+
+	for (i = 0; i < regs_num; i++)
+		mn34227pl_write_reg(vdev, regs[i].addr, regs[i].data);
+
+	rval = mn34227pl_update_hv_info(vdev);
+	if (rval < 0)
+		return rval;
+
+	mn34227pl_get_line_time(vdev);
+
+	return mn34227pl_set_vin_mode(vdev, format);
+}
+
+static int mn34227pl_set_fps(struct vin_device *vdev, int fps)
+{
+	u64	v_lines, vb_time;
+	struct mn34227pl_priv *pinfo = (struct mn34227pl_priv *)vdev->priv;
+
+	v_lines = fps * (u64)vdev->cur_pll->pixelclk;
+	v_lines = DIV64_CLOSEST(v_lines, pinfo->line_length);
+	v_lines = DIV64_CLOSEST(v_lines, 512000000);
+
+	mn34227pl_write_reg(vdev, 0x0340, (u8)(v_lines >> 8));
+	mn34227pl_write_reg(vdev, 0x0341, (u8)v_lines);
+
+	pinfo->frame_length_lines = (u32)v_lines;
+
+	vb_time = pinfo->line_length * (u64)(v_lines - vdev->cur_format->height) * 1000000000;
+	vb_time = DIV64_CLOSEST(vb_time, vdev->cur_pll->pixelclk);
+	vdev->cur_format->vb_time = vb_time;
+
+	return 0;
+}
+
+static int mn34227pl_set_agc_index(struct vin_device *vdev, int agc_idx)
+{
+	if (vdev->cur_format->hdr_mode != AMBA_VIDEO_LINEAR_MODE) {
+		vin_debug("hdr mode doesn't use this API %s!\n", __func__);
+		return 0;
+	}
+
+	if (agc_idx > MN34227PL_GAIN_0DB) {
+		vin_warn("agc index %d exceeds maximum %d\n", agc_idx, MN34227PL_GAIN_0DB);
+		agc_idx = MN34227PL_GAIN_0DB;
+	}
+
+	agc_idx = MN34227PL_GAIN_0DB - agc_idx;
+
+	mn34227pl_write_reg(vdev, 0x0204, (MN34227PL_GAIN_TABLE[agc_idx][MN34227PL_GAIN_COL_AGAIN] >> 8) & 0x3);
+	mn34227pl_write_reg(vdev, 0x0205, (u8)MN34227PL_GAIN_TABLE[agc_idx][MN34227PL_GAIN_COL_AGAIN]);
+	/* DGAIN-Gr */
+	mn34227pl_write_reg(vdev, 0x020E, (MN34227PL_GAIN_TABLE[agc_idx][MN34227PL_GAIN_COL_DGAIN] >> 8) & 0x3);
+	mn34227pl_write_reg(vdev, 0x020F, (u8)MN34227PL_GAIN_TABLE[agc_idx][MN34227PL_GAIN_COL_DGAIN]);
+	/* DGAIN-R */
+	mn34227pl_write_reg(vdev, 0x0210, (MN34227PL_GAIN_TABLE[agc_idx][MN34227PL_GAIN_COL_DGAIN] >> 8) & 0x3);
+	mn34227pl_write_reg(vdev, 0x0211, (u8)MN34227PL_GAIN_TABLE[agc_idx][MN34227PL_GAIN_COL_DGAIN]);
+	/* DGAIN-B */
+	mn34227pl_write_reg(vdev, 0x0212, (MN34227PL_GAIN_TABLE[agc_idx][MN34227PL_GAIN_COL_DGAIN] >> 8) & 0x3);
+	mn34227pl_write_reg(vdev, 0x0213, (u8)MN34227PL_GAIN_TABLE[agc_idx][MN34227PL_GAIN_COL_DGAIN]);
+	/* DGAIN-Gb */
+	mn34227pl_write_reg(vdev, 0x0214, (MN34227PL_GAIN_TABLE[agc_idx][MN34227PL_GAIN_COL_DGAIN] >> 8) & 0x3);
+	mn34227pl_write_reg(vdev, 0x0215, (u8)MN34227PL_GAIN_TABLE[agc_idx][MN34227PL_GAIN_COL_DGAIN]);
+
+	return 0;
+}
+
+static int mn34227pl_set_mirror_mode(struct vin_device *vdev,
+		struct vindev_mirror *mirror_mode)
+{
+	u32 tmp_reg, readmode, bayer_pattern;
+
+	switch (mirror_mode->pattern) {
+	case VINDEV_MIRROR_AUTO:
+		return 0;
+
+	case VINDEV_MIRROR_VERTICALLY:
+		readmode = MN34227PL_V_FLIP;
+		bayer_pattern = VINDEV_BAYER_PATTERN_GR;
+		break;
+
+	case VINDEV_MIRROR_NONE:
+		readmode = 0;
+		bayer_pattern = VINDEV_BAYER_PATTERN_GR;
+		break;
+
+	case VINDEV_MIRROR_HORRIZONTALLY_VERTICALLY:
+	case VINDEV_MIRROR_HORRIZONTALLY:
+	default:
+		vin_error("do not support cmd mirror mode\n");
+		return -EINVAL;
+	}
+
+	mn34227pl_read_reg(vdev, 0x0101, &tmp_reg);
+	tmp_reg &= (~MN34227PL_V_FLIP);
+	tmp_reg |= readmode;
+	mn34227pl_write_reg(vdev, 0x0101, tmp_reg);
+
+	if (mirror_mode->bayer_pattern == VINDEV_BAYER_PATTERN_AUTO)
+		mirror_mode->bayer_pattern = bayer_pattern;
+
+	return 0;
+}
+
+static int mn34227pl_set_wdr_shutter_row_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_shutter_gp)
+{
+	struct mn34227pl_priv *pinfo = (struct mn34227pl_priv *)vdev->priv;
+	int shutter_long, shutter_short1;
+	u32 active_lines;
+	u64 vb_time;
+	int errCode = 0;
+
+	active_lines = vdev->cur_format->height;
+
+	/* long shutter */
+	shutter_long = p_shutter_gp->l;
+
+	/* short shutter 1 */
+	shutter_short1 = p_shutter_gp->s1;
+
+	/* shutter limitation check */
+	switch(vdev->cur_format->hdr_mode){
+		case AMBA_VIDEO_2X_HDR_MODE:
+			if(shutter_long + shutter_short1 + 5 > pinfo->frame_length_lines){
+				vin_error("shutter exceeds limitation! long:%d, short:%d, V:%d\n",
+					shutter_long, shutter_short1, pinfo->frame_length_lines);
+				return -EPERM;
+			}else if(shutter_short1 + 2 > pinfo->frame_length_lines - active_lines) {
+				vin_error("short frame offset exceeds limitation! short:%d, VB:%d\n",
+					shutter_short1, pinfo->frame_length_lines - active_lines);
+			}
+			break;
+		case AMBA_VIDEO_LINEAR_MODE:
+		default:
+			vin_error("Unsupported mode\n");
+			return -EPERM;
+	}
+
+	/* long shutter */
+	mn34227pl_write_reg(vdev, 0x0203, (u8)(shutter_long & 0xFF));
+	mn34227pl_write_reg(vdev, 0x0202, (u8)(shutter_long >> 8));
+	mn34227pl_write_reg(vdev, 0x0221, (u8)((shutter_long >> 16) & 0x1));
+
+	/* short shutter 1 */
+	mn34227pl_write_reg(vdev, 0x312B, (u8)(shutter_short1 & 0xFF));
+	mn34227pl_write_reg(vdev, 0x312A, (u8)(shutter_short1 >> 8));
+
+	memcpy(&(pinfo->wdr_shutter_gp),  p_shutter_gp, sizeof(struct vindev_wdr_gp_s));
+
+	switch(vdev->cur_format->hdr_mode) {
+	case AMBA_VIDEO_2X_HDR_MODE:
+		vb_time = pinfo->frame_length_lines - vdev->cur_format->height - pinfo->wdr_shutter_gp.s1;
+		break;
+	default:
+		vin_error("Unsupported mode\n");
+		return -EPERM;
+	}
+
+	vb_time = pinfo->line_length * (u64)vb_time * 1000000000;
+	vb_time = DIV64_CLOSEST(vb_time, vdev->cur_pll->pixelclk);
+	vdev->cur_format->vb_time = vb_time;
+
+	vin_debug("shutter long:%d, short1:%d, vb_time:%d\n", p_shutter_gp->l,
+		p_shutter_gp->s1,, vdev->cur_format->vb_time);
+
+	return errCode;
+}
+
+static int mn34227pl_get_wdr_shutter_row_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_shutter_gp)
+{
+	struct mn34227pl_priv *pinfo = (struct mn34227pl_priv *)vdev->priv;
+	memcpy(p_shutter_gp, &(pinfo->wdr_shutter_gp), sizeof(struct vindev_wdr_gp_s));
+
+	return 0;
+}
+
+static int mn34227pl_set_wdr_again_idx_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_again_gp)
+{
+	struct mn34227pl_priv *pinfo = (struct mn34227pl_priv *)vdev->priv;
+	u32 again_index;
+
+	again_index = MN34227PL_GAIN_0DB - p_again_gp->l;
+	mn34227pl_write_reg(vdev, 0x0204, (MN34227PL_GAIN_TABLE[again_index][MN34227PL_GAIN_COL_AGAIN] >> 8) & 0x3);
+	mn34227pl_write_reg(vdev, 0x0205, (u8)MN34227PL_GAIN_TABLE[again_index][MN34227PL_GAIN_COL_AGAIN]);
+
+	memcpy(&(pinfo->wdr_again_gp), p_again_gp, sizeof(struct vindev_wdr_gp_s));
+
+	vin_debug("long again index:%d, short1 again index:%d, short2 again index:%d\n",
+		p_again_gp->l, p_again_gp->s1, p_again_gp->s2);
+
+	return 0;
+}
+
+static int mn34227pl_get_wdr_again_idx_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_again_gp)
+{
+	struct mn34227pl_priv *pinfo = (struct mn34227pl_priv *)vdev->priv;
+
+	memcpy(p_again_gp, &(pinfo->wdr_again_gp), sizeof(struct vindev_wdr_gp_s));
+	return 0;
+}
+
+static int mn34227pl_set_wdr_dgain_idx_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_dgain_gp)
+{
+	struct mn34227pl_priv *pinfo = (struct mn34227pl_priv *)vdev->priv;
+	int gain_index;
+
+	/* long frame */
+	gain_index = MN34227PL_WDR_GAIN_18DB - p_dgain_gp->l;
+	if(vdev->cur_format->hdr_mode == AMBA_VIDEO_2X_HDR_MODE) {// Fix me, for 2x setting, use 0x3108 and 0x3109 as dgain
+		mn34227pl_write_reg(vdev, 0x3108, (MN34227PL_GAIN_TABLE[gain_index][MN34227PL_GAIN_COL_DGAIN] >> 8) & 0x3);
+		mn34227pl_write_reg(vdev, 0x3109, (u8)MN34227PL_GAIN_TABLE[gain_index][MN34227PL_GAIN_COL_DGAIN]);
+
+		memcpy(&(pinfo->wdr_dgain_gp), p_dgain_gp, sizeof(struct vindev_wdr_gp_s));
+		return 0;
+	} else {
+		/* DGAIN-Gr */
+		mn34227pl_write_reg(vdev, 0x020E, (MN34227PL_GAIN_TABLE[gain_index][MN34227PL_GAIN_COL_DGAIN] >> 8) & 0x3);
+		mn34227pl_write_reg(vdev, 0x020F, (u8)MN34227PL_GAIN_TABLE[gain_index][MN34227PL_GAIN_COL_DGAIN]);
+		/* DGAIN-R */
+		mn34227pl_write_reg(vdev, 0x0210, (MN34227PL_GAIN_TABLE[gain_index][MN34227PL_GAIN_COL_DGAIN] >> 8) & 0x3);
+		mn34227pl_write_reg(vdev, 0x0211, (u8)MN34227PL_GAIN_TABLE[gain_index][MN34227PL_GAIN_COL_DGAIN]);
+		/* DGAIN-B */
+		mn34227pl_write_reg(vdev, 0x0212, (MN34227PL_GAIN_TABLE[gain_index][MN34227PL_GAIN_COL_DGAIN] >> 8) & 0x3);
+		mn34227pl_write_reg(vdev, 0x0213, (u8)MN34227PL_GAIN_TABLE[gain_index][MN34227PL_GAIN_COL_DGAIN]);
+		/* DGAIN-Gb */
+		mn34227pl_write_reg(vdev, 0x0214, (MN34227PL_GAIN_TABLE[gain_index][MN34227PL_GAIN_COL_DGAIN] >> 8) & 0x3);
+		mn34227pl_write_reg(vdev, 0x0215, (u8)MN34227PL_GAIN_TABLE[gain_index][MN34227PL_GAIN_COL_DGAIN]);
+	}
+
+	/* short frame 1 */
+	gain_index = MN34227PL_WDR_GAIN_18DB - p_dgain_gp->s1;
+	/* DGAIN-Gr */
+	mn34227pl_write_reg(vdev, 0x310A, (MN34227PL_GAIN_TABLE[gain_index][MN34227PL_GAIN_COL_DGAIN] >> 8) & 0x3);
+	mn34227pl_write_reg(vdev, 0x310B, (u8)MN34227PL_GAIN_TABLE[gain_index][MN34227PL_GAIN_COL_DGAIN]);
+	/* DGAIN-R */
+	mn34227pl_write_reg(vdev, 0x310C, (MN34227PL_GAIN_TABLE[gain_index][MN34227PL_GAIN_COL_DGAIN] >> 8) & 0x3);
+	mn34227pl_write_reg(vdev, 0x310D, (u8)MN34227PL_GAIN_TABLE[gain_index][MN34227PL_GAIN_COL_DGAIN]);
+	/* DGAIN-B */
+	mn34227pl_write_reg(vdev, 0x310E, (MN34227PL_GAIN_TABLE[gain_index][MN34227PL_GAIN_COL_DGAIN] >> 8) & 0x3);
+	mn34227pl_write_reg(vdev, 0x310F, (u8)MN34227PL_GAIN_TABLE[gain_index][MN34227PL_GAIN_COL_DGAIN]);
+	/* DGAIN-Gb */
+	mn34227pl_write_reg(vdev, 0x3110, (MN34227PL_GAIN_TABLE[gain_index][MN34227PL_GAIN_COL_DGAIN] >> 8) & 0x3);
+	mn34227pl_write_reg(vdev, 0x3111, (u8)MN34227PL_GAIN_TABLE[gain_index][MN34227PL_GAIN_COL_DGAIN]);
+
+	memcpy(&(pinfo->wdr_dgain_gp), p_dgain_gp, sizeof(struct vindev_wdr_gp_s));
+
+	return 0;
+}
+
+static int mn34227pl_get_wdr_dgain_idx_group(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_dgain_gp)
+{
+	struct mn34227pl_priv *pinfo = (struct mn34227pl_priv *)vdev->priv;
+
+	memcpy(p_dgain_gp, &(pinfo->wdr_dgain_gp), sizeof(struct vindev_wdr_gp_s));
+	return 0;
+}
+
+static int mn34227pl_wdr_shutter2row(struct vin_device *vdev,
+	struct vindev_wdr_gp_s *p_shutter2row)
+{
+	u64 exposure_lines;
+	int errCode = 0;
+	struct mn34227pl_priv *pinfo = (struct mn34227pl_priv *)vdev->priv;
+
+	/* long shutter */
+	exposure_lines = p_shutter2row->l * (u64)vdev->cur_pll->pixelclk;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, pinfo->line_length);
+	exposure_lines = DIV64_CLOSEST(exposure_lines, 512000000);
+	p_shutter2row->l = (u32)exposure_lines;
+
+	/* short shutter 1 */
+	exposure_lines = p_shutter2row->s1 * (u64)vdev->cur_pll->pixelclk;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, pinfo->line_length);
+	exposure_lines = DIV64_CLOSEST(exposure_lines, 512000000);
+	p_shutter2row->s1 = (u32)exposure_lines;
+
+	return errCode;
+}
+
+static int mn34227pl_set_shutter_row(struct vin_device *vdev, u32 row)
+{
+	u64 exposure_lines;
+	u32 num_line, min_line, max_line;
+	struct mn34227pl_priv *pinfo = (struct mn34227pl_priv *)vdev->priv;
+
+	num_line = row;
+
+	/* FIXME: shutter width: 1 ~ (Frame format(V) - 2) */
+	min_line = 1;
+	max_line = pinfo->frame_length_lines - 2;
+	num_line = clamp(num_line, min_line, max_line);
+
+	mn34227pl_write_reg(vdev, 0x0221, (num_line >> 16) & 0x01);
+	mn34227pl_write_reg(vdev, 0x0202, (num_line >> 8) & 0xFF);
+	mn34227pl_write_reg(vdev, 0x0203, num_line & 0xFF);
+
+	exposure_lines = num_line;
+	exposure_lines = exposure_lines * (u64)pinfo->line_length * 512000000;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, vdev->cur_pll->pixelclk);
+
+	vdev->shutter_time = (u32)exposure_lines;
+	vin_debug("shutter_time:%d, row:%d\n", vdev->shutter_time, num_line);
+
+	return 0;
+}
+
+static int mn34227pl_shutter2row(struct vin_device *vdev, u32* shutter_time)
+{
+	u64 exposure_lines;
+	int rval = 0;
+	struct mn34227pl_priv *pinfo = (struct mn34227pl_priv *)vdev->priv;
+
+	if(unlikely(!pinfo->line_length)) {
+		rval = mn34227pl_update_hv_info(vdev);
+		if (rval < 0)
+			return rval;
+	}
+
+	exposure_lines = (*shutter_time) * (u64)vdev->cur_pll->pixelclk;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, pinfo->line_length);
+	exposure_lines = DIV64_CLOSEST(exposure_lines, 512000000);
+
+	*shutter_time = exposure_lines;
+
+	return rval;
+}
+
+static struct vin_ops mn34227pl_ops = {
+	.init_device		= mn34227pl_init_device,
+	.set_format		= mn34227pl_set_format,
+	.set_shutter_row 	= mn34227pl_set_shutter_row,
+	.shutter2row 		= mn34227pl_shutter2row,
+	.set_frame_rate	= mn34227pl_set_fps,
+	.set_agc_index	= mn34227pl_set_agc_index,
+	.set_mirror_mode	= mn34227pl_set_mirror_mode,
+	.read_reg			= mn34227pl_read_reg,
+	.write_reg		= mn34227pl_write_reg,
+
+	/* for wdr sensor */
+	.set_wdr_again_idx_gp = mn34227pl_set_wdr_again_idx_group,
+	.get_wdr_again_idx_gp = mn34227pl_get_wdr_again_idx_group,
+	.set_wdr_dgain_idx_gp = mn34227pl_set_wdr_dgain_idx_group,
+	.get_wdr_dgain_idx_gp = mn34227pl_get_wdr_dgain_idx_group,
+	.set_wdr_shutter_row_gp = mn34227pl_set_wdr_shutter_row_group,
+	.get_wdr_shutter_row_gp = mn34227pl_get_wdr_shutter_row_group,
+	.wdr_shutter2row = mn34227pl_wdr_shutter2row,
+};
+
+/*	< include init.c here for aptina sensor, which is produce by perl >  */
+/* ========================================================================== */
+static int mn34227pl_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	int rval = 0;
+	struct vin_device *vdev;
+	struct mn34227pl_priv *mn34227pl;
+
+	vdev = ambarella_vin_create_device(client->name,
+			SENSOR_MN34227PL, sizeof(struct mn34227pl_priv));
+	if (!vdev)
+		return -ENOMEM;
+
+	vdev->intf_id = 0;
+	vdev->dev_type = VINDEV_TYPE_SENSOR;
+	vdev->sub_type = VINDEV_SUBTYPE_CMOS;
+	vdev->default_mode = AMBA_VIDEO_MODE_1080P;
+	vdev->default_hdr_mode = AMBA_VIDEO_LINEAR_MODE;
+	vdev->agc_db_max = 0x30000000;	// 48dB
+	vdev->agc_db_min = 0x00000000;	// 0dB
+#if GAIN_160_STEPS
+	vdev->agc_db_step = 0x00600000;	// 0.375dB
+#else
+	vdev->agc_db_step = 0x00180000;	// 0.09375dB
+#endif
+	vdev->pixel_size = 0x0002C000;	/* 2.75um */
+
+	vdev->wdr_again_idx_min = 0;
+	vdev->wdr_again_idx_max = MN34227PL_WDR_GAIN_30DB;
+	vdev->wdr_dgain_idx_min = 0;
+	vdev->wdr_dgain_idx_max = MN34227PL_WDR_GAIN_18DB;
+
+	/* mode switch needs hw reset */
+	vdev->reset_for_mode_switch = true;
+
+	i2c_set_clientdata(client, vdev);
+
+	mn34227pl = (struct mn34227pl_priv *)vdev->priv;
+	mn34227pl->control_data = client;
+
+	rval = ambarella_vin_register_device(vdev, &mn34227pl_ops,
+			mn34227pl_formats, ARRAY_SIZE(mn34227pl_formats),
+			mn34227pl_plls, ARRAY_SIZE(mn34227pl_plls));
+	if (rval < 0)
+		goto mn34227pl_probe_err;
+
+	vin_info("MN34227PL init(4-lane lvds)\n");
+
+	return 0;
+
+mn34227pl_probe_err:
+	ambarella_vin_free_device(vdev);
+	return rval;
+}
+
+static int mn34227pl_remove(struct i2c_client *client)
+{
+	struct vin_device *vdev;
+
+	vdev = (struct vin_device *)i2c_get_clientdata(client);
+	ambarella_vin_unregister_device(vdev);
+	ambarella_vin_free_device(vdev);
+
+	return 0;
+}
+
+static const struct i2c_device_id mn34227pl_idtable[] = {
+	{ "mn34227pl", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, mn34227pl_idtable);
+
+static struct i2c_driver i2c_driver_mn34227pl = {
+	.driver = {
+		.name	= "mn34227pl",
+	},
+
+	.id_table	= mn34227pl_idtable,
+	.probe		= mn34227pl_probe,
+	.remove		= mn34227pl_remove,
+
+};
+
+static int __init mn34227pl_init(void)
+{
+	int bus, addr, rval;
+
+	bus = bus_addr >> 16;
+	addr = bus_addr & 0xffff;
+
+	rval = ambpriv_i2c_update_addr("mn34227pl", bus, addr);
+	if (rval < 0)
+		return rval;
+
+	rval = i2c_add_driver(&i2c_driver_mn34227pl);
+	if (rval < 0)
+		return rval;
+
+	return 0;
+}
+
+static void __exit mn34227pl_exit(void)
+{
+	i2c_del_driver(&i2c_driver_mn34227pl);
+}
+
+module_init(mn34227pl_init);
+module_exit(mn34227pl_exit);
+
+MODULE_DESCRIPTION("MN34227PL 1/3 -Inch, 1944x1092, 2.1-Megapixel CMOS Digital Image Sensor");
+MODULE_AUTHOR("Long Zhao, <longzhao@ambarella.com>");
+MODULE_LICENSE("Proprietary");
+
diff --git a/drivers/vin/sensors/panasonic_mn34227pl/mn34227pl.h b/drivers/vin/sensors/panasonic_mn34227pl/mn34227pl.h
new file mode 100644
index 0000000..48ca9c2
--- /dev/null
+++ b/drivers/vin/sensors/panasonic_mn34227pl/mn34227pl.h
@@ -0,0 +1,42 @@
+/*
+ * Filename : mn34227pl_pri.h
+ *
+ * History:
+ *    2015/05/27 - [Long Zhao] Create
+ *
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __MN34227PL_PRI_H__
+#define __MN34227PL_PRI_H__
+
+#define GAIN_160_STEPS (1)
+
+#define MN34227PL_V_FLIP (1<<1)
+
+#endif /* __MN34227PL_PRI_H__ */
+
diff --git a/drivers/vin/sensors/panasonic_mn34227pl/mn34227pl_table.c b/drivers/vin/sensors/panasonic_mn34227pl/mn34227pl_table.c
new file mode 100644
index 0000000..c05f302
--- /dev/null
+++ b/drivers/vin/sensors/panasonic_mn34227pl/mn34227pl_table.c
@@ -0,0 +1,948 @@
+/*
+ * Filename : mn34227pl_reg_tbl.c
+ *
+ * History:
+ *	2015/05/27 - [Long Zhao] Create
+ *
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+
+static struct vin_video_pll mn34227pl_plls[] = {
+	{0, 27000000, 74250000},/* for linear */
+	{0, 27000000, 148500000},/* 2x wdr mode */
+};
+
+static struct vin_video_format mn34227pl_formats[] = {
+	{
+		.video_mode	= AMBA_VIDEO_MODE_1080P,
+		.def_start_x	= 4,
+		.def_start_y	= 2+10+4,
+		.def_width	= 1920,
+		.def_height	= 1080,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_LINEAR_MODE,
+		.device_mode	= 0,
+		.pll_idx	= 0,
+		.width		= 1956,
+		.height		= 1108,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_30,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_GR,
+	},
+	/* 2x hdr mode */
+	{
+		.video_mode	= AMBA_VIDEO_MODE_1080P,
+		.def_start_x	= 4,
+		.def_start_y	= (2+10+4)*2,
+		.def_width	= 1920,
+		.def_height	= 4500 - (2+10+4)*2, /* VMAX*2 - def_start_y*2 */
+		.act_start_x	= 0,
+		.act_start_y	= 0,
+		.act_width	= 1920,
+		.act_height	= 1080,
+		.max_act_width = 1944,
+		.max_act_height = 1092,
+		/* sensor mode */
+		.hdr_mode = AMBA_VIDEO_2X_HDR_MODE,
+		.device_mode	= 0,
+		.pll_idx	= 1,
+		.width		= 1956,
+		.height		= 1108,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_15,
+		.default_fps	= AMBA_VIDEO_FPS_15,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_15,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_GR,
+	},
+};
+
+static struct vin_reg_16_16 mn34227pl_linear_mode_regs[] = {
+	/* N111_S12_P4_FHD_V1125_12b_222MHz_30fps_vM17e_141006_Mst_I2C_d_Amb */
+	/* VCYCLE:1125 HCYCLE:800 (@MCLK) */
+	{0x300E, 0x0001},
+	{0x300F, 0x0000},
+	{0x0307, 0x0021},
+	{0x3000, 0x0000},
+	{0x3001, 0x0003},
+	{0x0112, 0x000C},
+	{0x0113, 0x000C},
+	{0x3005, 0x0064},
+	{0x3007, 0x0014},
+	{0x3018, 0x0043},
+	{0x3019, 0x0010},
+	{0x301A, 0x00B9},
+	{0x3000, 0x0000},
+	{0x3001, 0x0053},
+	{0x300B, 0x0000},
+	{0x300E, 0x0000},
+	{0x300F, 0x0000},
+	{0x0202, 0x0004},
+	{0x0203, 0x0063},
+	{0x3036, 0x0000},
+	{0x3039, 0x002E},
+	{0x3058, 0x000F},
+	{0x305D, 0x0040},
+	{0x3066, 0x000A},
+	{0x3067, 0x00B0},
+	{0x3068, 0x0008},
+	{0x3069, 0x0000},
+	{0x306A, 0x000B},
+	{0x306B, 0x0060},
+	{0x306C, 0x0009},
+	{0x306D, 0x00D0},
+	{0x306E, 0x000C},
+	{0x306F, 0x0000},
+	{0x3074, 0x0001},
+	{0x3098, 0x0000},
+	{0x3099, 0x0000},
+	{0x309A, 0x0001},
+	{0x3104, 0x0004},
+	{0x3106, 0x0000},
+	{0x3107, 0x00C0},
+	{0x3141, 0x0040},
+	{0x3143, 0x0002},
+	{0x3144, 0x0002},
+	{0x3145, 0x0002},
+	{0x3146, 0x0000},
+	{0x3147, 0x0002},
+	{0x314A, 0x0001},
+	{0x314B, 0x0002},
+	{0x314C, 0x0002},
+	{0x314D, 0x0002},
+	{0x314E, 0x0001},
+	{0x314F, 0x0002},
+	{0x3150, 0x0002},
+	{0x3152, 0x0004},
+	{0x3153, 0x00E3},
+	{0x316F, 0x00C6},
+	{0x3175, 0x0080},
+	{0x318E, 0x0020},
+	{0x318F, 0x0070},
+	{0x3196, 0x0008},
+	{0x3243, 0x00D7},
+	{0x3247, 0x0038},
+	{0x3248, 0x0003},
+	{0x3249, 0x00E2},
+	{0x324A, 0x0030},
+	{0x324B, 0x0018},
+	{0x324C, 0x0002},
+	{0x3253, 0x00DE},
+	{0x3259, 0x0068},
+	{0x3272, 0x0046},
+	{0x3280, 0x0030},
+	{0x3288, 0x0001},
+	{0x330E, 0x0005},
+	{0x3310, 0x0002},
+	{0x3315, 0x001F},
+	{0x332C, 0x0002},
+	{0x3339, 0x0002},
+	{0x3000, 0x0000},
+	{0x3001, 0x00D3},
+	{0x0100, 0x0001},
+	{0x0101, 0x0000},
+};
+
+static struct vin_reg_16_16 mn34227pl_2x_wdr_mode_regs[] = {
+	/* NP10_S12_P4_FHD_WDRx2_V2250_12b_445MHz_15fps_vM17e_150518_Mst_I2C_d_Amb.txt */
+	/* VCYCLE:2250 HCYCLE:800 (@MCLK) */
+	{0x300E, 0x0001},
+	{0x300F, 0x0000},
+	{0x0307, 0x0021},
+	{0x3000, 0x0000},
+	{0x3001, 0x0003},
+	{0x0112, 0x000C},
+	{0x0113, 0x000C},
+	{0x3005, 0x0064},
+	{0x3018, 0x0043},
+	{0x3019, 0x0010},
+	{0x301A, 0x00B9},
+	{0x3000, 0x0000},
+	{0x3001, 0x0053},
+	{0x300B, 0x0000},
+	{0x300E, 0x0000},
+	{0x300F, 0x0000},
+	{0x0202, 0x0000},
+	{0x0203, 0x0020},
+	{0x0340, 0x0008},
+	{0x0341, 0x00CA},
+	{0x0342, 0x0011},
+	{0x0343, 0x0030},
+	{0x3036, 0x0000},
+	{0x3039, 0x002E},
+	{0x3058, 0x000F},
+	{0x305D, 0x0042},
+#if 0
+	{0x3066, 0x000A},
+	{0x3067, 0x00B0},
+	{0x3068, 0x0008},
+	{0x3069, 0x0000},
+	{0x306A, 0x0009},
+	{0x306B, 0x00D0},
+	{0x306C, 0x0009},
+	{0x306D, 0x00D0},
+#endif
+	{0x306E, 0x000C},
+	{0x306F, 0x0000},
+	{0x3074, 0x0001},
+	{0x3078, 0x0001},
+	{0x3098, 0x0000},
+	{0x3099, 0x0000},
+	{0x309A, 0x0001},
+	{0x3101, 0x0001},
+	{0x3104, 0x0004},
+	{0x3106, 0x0000},
+	{0x3107, 0x00C0},
+	{0x312B, 0x0020},
+	{0x312D, 0x0020},
+	{0x312F, 0x0020},
+	{0x3141, 0x0040},
+	{0x3143, 0x0002},
+	{0x3144, 0x0002},
+	{0x3145, 0x0002},
+	{0x3146, 0x0000},
+	{0x3147, 0x0002},
+	{0x314A, 0x0001},
+	{0x314B, 0x0002},
+	{0x314C, 0x0002},
+	{0x314D, 0x0002},
+	{0x314E, 0x0001},
+	{0x314F, 0x0002},
+	{0x3150, 0x0002},
+	{0x3152, 0x0004},
+	{0x3153, 0x00E3},
+	{0x316F, 0x00C6},
+	{0x3175, 0x0080},
+	{0x318E, 0x0020},
+	{0x318F, 0x0070},
+	{0x3196, 0x0008},
+	{0x323C, 0x0070},
+	{0x323E, 0x0000},
+	{0x3243, 0x00D7},
+	{0x3247, 0x0079},
+	{0x324A, 0x0030},
+	{0x324B, 0x0018},
+	{0x324C, 0x0002},
+	{0x3253, 0x00DE},
+	{0x3259, 0x0049},
+	{0x3272, 0x0046},
+	{0x3280, 0x0030},
+	{0x3288, 0x0001},
+	{0x330E, 0x0005},
+	{0x3310, 0x0002},
+	{0x3315, 0x001F},
+	{0x332C, 0x0002},
+	{0x3339, 0x0002},
+	{0x3000, 0x0000},
+	{0x3001, 0x00D3},
+	{0x0100, 0x0001},
+	{0x0101, 0x0000},
+};
+
+#define MN34227PL_GAIN_COLS		(2)
+#define MN34227PL_GAIN_COL_AGAIN	(0)
+#define MN34227PL_GAIN_COL_DGAIN	(1)
+
+#if GAIN_160_STEPS
+/** MN34227PL global gain table row size */
+#define MN34227PL_GAIN_ROWS		(128 + 1)
+#define MN34227PL_GAIN_0DB		(128)
+#define MN34227PL_WDR_GAIN_18DB 	(48)
+#define MN34227PL_WDR_GAIN_30DB	(80)
+
+/* MN34227PL_GAIN_ROWS = 129, MN34227PL_GAIN_COLS = 2 */
+const s16 MN34227PL_GAIN_TABLE[MN34227PL_GAIN_ROWS][MN34227PL_GAIN_COLS] =
+{
+	/* Analog Gain,Digital Gain */
+	{0x240, 0x1c0}, /* index 128, gain_db=48.000000 DB, again_db=30.000000 DB, dgain_db=18.000000 DB */
+	{0x240, 0x1bc}, /* index 127, gain_db=47.625000 DB, again_db=30.000000 DB, dgain_db=17.625000 DB */
+	{0x240, 0x1b8}, /* index 126, gain_db=47.250000 DB, again_db=30.000000 DB, dgain_db=17.250000 DB */
+	{0x240, 0x1b4}, /* index 125, gain_db=46.875000 DB, again_db=30.000000 DB, dgain_db=16.875000 DB */
+	{0x240, 0x1b0}, /* index 124, gain_db=46.500000 DB, again_db=30.000000 DB, dgain_db=16.500000 DB */
+	{0x240, 0x1ac}, /* index 123, gain_db=46.125000 DB, again_db=30.000000 DB, dgain_db=16.125000 DB */
+	{0x240, 0x1a8}, /* index 122, gain_db=45.750000 DB, again_db=30.000000 DB, dgain_db=15.750000 DB */
+	{0x240, 0x1a4}, /* index 121, gain_db=45.375000 DB, again_db=30.000000 DB, dgain_db=15.375000 DB */
+	{0x240, 0x1a0}, /* index 120, gain_db=45.000000 DB, again_db=30.000000 DB, dgain_db=15.000000 DB */
+	{0x240, 0x19c}, /* index 119, gain_db=44.625000 DB, again_db=30.000000 DB, dgain_db=14.625000 DB */
+	{0x240, 0x198}, /* index 118, gain_db=44.250000 DB, again_db=30.000000 DB, dgain_db=14.250000 DB */
+	{0x240, 0x194}, /* index 117, gain_db=43.875000 DB, again_db=30.000000 DB, dgain_db=13.875000 DB */
+	{0x240, 0x190}, /* index 116, gain_db=43.500000 DB, again_db=30.000000 DB, dgain_db=13.500000 DB */
+	{0x240, 0x18c}, /* index 115, gain_db=43.125000 DB, again_db=30.000000 DB, dgain_db=13.125000 DB */
+	{0x240, 0x188}, /* index 114, gain_db=42.750000 DB, again_db=30.000000 DB, dgain_db=12.750000 DB */
+	{0x240, 0x184}, /* index 113, gain_db=42.375000 DB, again_db=30.000000 DB, dgain_db=12.375000 DB */
+	{0x240, 0x180}, /* index 112, gain_db=42.000000 DB, again_db=30.000000 DB, dgain_db=12.000000 DB */
+	{0x240, 0x17c}, /* index 111, gain_db=41.625000 DB, again_db=30.000000 DB, dgain_db=11.625000 DB */
+	{0x240, 0x178}, /* index 110, gain_db=41.250000 DB, again_db=30.000000 DB, dgain_db=11.250000 DB */
+	{0x240, 0x174}, /* index 109, gain_db=40.875000 DB, again_db=30.000000 DB, dgain_db=10.875000 DB */
+	{0x240, 0x170}, /* index 108, gain_db=40.500000 DB, again_db=30.000000 DB, dgain_db=10.500000 DB */
+	{0x240, 0x16c}, /* index 107, gain_db=40.125000 DB, again_db=30.000000 DB, dgain_db=10.125000 DB */
+	{0x240, 0x168}, /* index 106, gain_db=39.750000 DB, again_db=30.000000 DB, dgain_db=9.750000 DB */
+	{0x240, 0x164}, /* index 105, gain_db=39.375000 DB, again_db=30.000000 DB, dgain_db=9.375000 DB */
+	{0x240, 0x160}, /* index 104, gain_db=39.000000 DB, again_db=30.000000 DB, dgain_db=9.000000 DB */
+	{0x240, 0x15c}, /* index 103, gain_db=38.625000 DB, again_db=30.000000 DB, dgain_db=8.625000 DB */
+	{0x240, 0x158}, /* index 102, gain_db=38.250000 DB, again_db=30.000000 DB, dgain_db=8.250000 DB */
+	{0x240, 0x154}, /* index 101, gain_db=37.875000 DB, again_db=30.000000 DB, dgain_db=7.875000 DB */
+	{0x240, 0x150}, /* index 100, gain_db=37.500000 DB, again_db=30.000000 DB, dgain_db=7.500000 DB */
+	{0x240, 0x14c}, /* index 99, gain_db=37.125000 DB, again_db=30.000000 DB, dgain_db=7.125000 DB */
+	{0x240, 0x148}, /* index 98, gain_db=36.750000 DB, again_db=30.000000 DB, dgain_db=6.750000 DB */
+	{0x240, 0x144}, /* index 97, gain_db=36.375000 DB, again_db=30.000000 DB, dgain_db=6.375000 DB */
+	{0x240, 0x140}, /* index 96, gain_db=36.000000 DB, again_db=30.000000 DB, dgain_db=6.000000 DB */
+	{0x240, 0x13c}, /* index 95, gain_db=35.625000 DB, again_db=30.000000 DB, dgain_db=5.625000 DB */
+	{0x240, 0x138}, /* index 94, gain_db=35.250000 DB, again_db=30.000000 DB, dgain_db=5.250000 DB */
+	{0x240, 0x134}, /* index 93, gain_db=34.875000 DB, again_db=30.000000 DB, dgain_db=4.875000 DB */
+	{0x240, 0x130}, /* index 92, gain_db=34.500000 DB, again_db=30.000000 DB, dgain_db=4.500000 DB */
+	{0x240, 0x12c}, /* index 91, gain_db=34.125000 DB, again_db=30.000000 DB, dgain_db=4.125000 DB */
+	{0x240, 0x128}, /* index 90, gain_db=33.750000 DB, again_db=30.000000 DB, dgain_db=3.750000 DB */
+	{0x240, 0x124}, /* index 89, gain_db=33.375000 DB, again_db=30.000000 DB, dgain_db=3.375000 DB */
+	{0x240, 0x120}, /* index 88, gain_db=33.000000 DB, again_db=30.000000 DB, dgain_db=3.000000 DB */
+	{0x240, 0x11c}, /* index 87, gain_db=32.625000 DB, again_db=30.000000 DB, dgain_db=2.625000 DB */
+	{0x240, 0x118}, /* index 86, gain_db=32.250000 DB, again_db=30.000000 DB, dgain_db=2.250000 DB */
+	{0x240, 0x114}, /* index 85, gain_db=31.875000 DB, again_db=30.000000 DB, dgain_db=1.875000 DB */
+	{0x240, 0x110}, /* index 84, gain_db=31.500000 DB, again_db=30.000000 DB, dgain_db=1.500000 DB */
+	{0x240, 0x10c}, /* index 83, gain_db=31.125000 DB, again_db=30.000000 DB, dgain_db=1.125000 DB */
+	{0x240, 0x108}, /* index 82, gain_db=30.750000 DB, again_db=30.000000 DB, dgain_db=0.750000 DB */
+	{0x240, 0x104}, /* index 81, gain_db=30.375000 DB, again_db=30.000000 DB, dgain_db=0.375000 DB */
+	{0x240, 0x100}, /* index 80, gain_db=30.000000 DB, again_db=30.000000 DB, dgain_db=0.000000 DB */
+
+	{0x23c, 0x100}, /* index 79, gain_db=29.625000 DB, again_db=29.625000 DB, dgain_db=0.000000 DB */
+	{0x238, 0x100}, /* index 78, gain_db=29.250000 DB, again_db=29.250000 DB, dgain_db=0.000000 DB */
+	{0x234, 0x100}, /* index 77, gain_db=28.875000 DB, again_db=28.875000 DB, dgain_db=0.000000 DB */
+	{0x230, 0x100}, /* index 76, gain_db=28.500000 DB, again_db=28.500000 DB, dgain_db=0.000000 DB */
+	{0x22c, 0x100}, /* index 75, gain_db=28.125000 DB, again_db=28.125000 DB, dgain_db=0.000000 DB */
+	{0x228, 0x100}, /* index 74, gain_db=27.750000 DB, again_db=27.750000 DB, dgain_db=0.000000 DB */
+	{0x224, 0x100}, /* index 73, gain_db=27.375000 DB, again_db=27.375000 DB, dgain_db=0.000000 DB */
+	{0x220, 0x100}, /* index 72, gain_db=27.000000 DB, again_db=27.000000 DB, dgain_db=0.000000 DB */
+	{0x21c, 0x100}, /* index 71, gain_db=26.625000 DB, again_db=26.625000 DB, dgain_db=0.000000 DB */
+	{0x218, 0x100}, /* index 70, gain_db=26.250000 DB, again_db=26.250000 DB, dgain_db=0.000000 DB */
+	{0x214, 0x100}, /* index 69, gain_db=25.875000 DB, again_db=25.875000 DB, dgain_db=0.000000 DB */
+	{0x210, 0x100}, /* index 68, gain_db=25.500000 DB, again_db=25.500000 DB, dgain_db=0.000000 DB */
+	{0x20c, 0x100}, /* index 67, gain_db=25.125000 DB, again_db=25.125000 DB, dgain_db=0.000000 DB */
+	{0x208, 0x100}, /* index 66, gain_db=24.750000 DB, again_db=24.750000 DB, dgain_db=0.000000 DB */
+	{0x204, 0x100}, /* index 65, gain_db=24.375000 DB, again_db=24.375000 DB, dgain_db=0.000000 DB */
+	{0x200, 0x100}, /* index 64, gain_db=24.000000 DB, again_db=24.000000 DB, dgain_db=0.000000 DB */
+	{0x1fc, 0x100}, /* index 63, gain_db=23.625000 DB, again_db=23.625000 DB, dgain_db=0.000000 DB */
+	{0x1f8, 0x100}, /* index 62, gain_db=23.250000 DB, again_db=23.250000 DB, dgain_db=0.000000 DB */
+	{0x1f4, 0x100}, /* index 61, gain_db=22.875000 DB, again_db=22.875000 DB, dgain_db=0.000000 DB */
+	{0x1f0, 0x100}, /* index 60, gain_db=22.500000 DB, again_db=22.500000 DB, dgain_db=0.000000 DB */
+	{0x1ec, 0x100}, /* index 59, gain_db=22.125000 DB, again_db=22.125000 DB, dgain_db=0.000000 DB */
+	{0x1e8, 0x100}, /* index 58, gain_db=21.750000 DB, again_db=21.750000 DB, dgain_db=0.000000 DB */
+	{0x1e4, 0x100}, /* index 57, gain_db=21.375000 DB, again_db=21.375000 DB, dgain_db=0.000000 DB */
+	{0x1e0, 0x100}, /* index 56, gain_db=21.000000 DB, again_db=21.000000 DB, dgain_db=0.000000 DB */
+	{0x1dc, 0x100}, /* index 55, gain_db=20.625000 DB, again_db=20.625000 DB, dgain_db=0.000000 DB */
+	{0x1d8, 0x100}, /* index 54, gain_db=20.250000 DB, again_db=20.250000 DB, dgain_db=0.000000 DB */
+	{0x1d4, 0x100}, /* index 53, gain_db=19.875000 DB, again_db=19.875000 DB, dgain_db=0.000000 DB */
+	{0x1d0, 0x100}, /* index 52, gain_db=19.500000 DB, again_db=19.500000 DB, dgain_db=0.000000 DB */
+	{0x1cc, 0x100}, /* index 51, gain_db=19.125000 DB, again_db=19.125000 DB, dgain_db=0.000000 DB */
+	{0x1c8, 0x100}, /* index 50, gain_db=18.750000 DB, again_db=18.750000 DB, dgain_db=0.000000 DB */
+	{0x1c4, 0x100}, /* index 49, gain_db=18.375000 DB, again_db=18.375000 DB, dgain_db=0.000000 DB */
+	{0x1c0, 0x100}, /* index 48, gain_db=18.000000 DB, again_db=18.000000 DB, dgain_db=0.000000 DB */
+	{0x1bc, 0x100}, /* index 47, gain_db=17.625000 DB, again_db=17.625000 DB, dgain_db=0.000000 DB */
+	{0x1b8, 0x100}, /* index 46, gain_db=17.250000 DB, again_db=17.250000 DB, dgain_db=0.000000 DB */
+	{0x1b4, 0x100}, /* index 45, gain_db=16.875000 DB, again_db=16.875000 DB, dgain_db=0.000000 DB */
+	{0x1b0, 0x100}, /* index 44, gain_db=16.500000 DB, again_db=16.500000 DB, dgain_db=0.000000 DB */
+	{0x1ac, 0x100}, /* index 43, gain_db=16.125000 DB, again_db=16.125000 DB, dgain_db=0.000000 DB */
+	{0x1a8, 0x100}, /* index 42, gain_db=15.750000 DB, again_db=15.750000 DB, dgain_db=0.000000 DB */
+	{0x1a4, 0x100}, /* index 41, gain_db=15.375000 DB, again_db=15.375000 DB, dgain_db=0.000000 DB */
+	{0x1a0, 0x100}, /* index 40, gain_db=15.000000 DB, again_db=15.000000 DB, dgain_db=0.000000 DB */
+	{0x19c, 0x100}, /* index 39, gain_db=14.625000 DB, again_db=14.625000 DB, dgain_db=0.000000 DB */
+	{0x198, 0x100}, /* index 38, gain_db=14.250000 DB, again_db=14.250000 DB, dgain_db=0.000000 DB */
+	{0x194, 0x100}, /* index 37, gain_db=13.875000 DB, again_db=13.875000 DB, dgain_db=0.000000 DB */
+	{0x190, 0x100}, /* index 36, gain_db=13.500000 DB, again_db=13.500000 DB, dgain_db=0.000000 DB */
+	{0x18c, 0x100}, /* index 35, gain_db=13.125000 DB, again_db=13.125000 DB, dgain_db=0.000000 DB */
+	{0x188, 0x100}, /* index 34, gain_db=12.750000 DB, again_db=12.750000 DB, dgain_db=0.000000 DB */
+	{0x184, 0x100}, /* index 33, gain_db=12.375000 DB, again_db=12.375000 DB, dgain_db=0.000000 DB */
+	{0x180, 0x100}, /* index 32, gain_db=12.000000 DB, again_db=12.000000 DB, dgain_db=0.000000 DB */
+	{0x17c, 0x100}, /* index 31, gain_db=11.625000 DB, again_db=11.625000 DB, dgain_db=0.000000 DB */
+	{0x178, 0x100}, /* index 30, gain_db=11.250000 DB, again_db=11.250000 DB, dgain_db=0.000000 DB */
+	{0x174, 0x100}, /* index 29, gain_db=10.875000 DB, again_db=10.875000 DB, dgain_db=0.000000 DB */
+	{0x170, 0x100}, /* index 28, gain_db=10.500000 DB, again_db=10.500000 DB, dgain_db=0.000000 DB */
+	{0x16c, 0x100}, /* index 27, gain_db=10.125000 DB, again_db=10.125000 DB, dgain_db=0.000000 DB */
+	{0x168, 0x100}, /* index 26, gain_db=9.750000 DB, again_db=9.750000 DB, dgain_db=0.000000 DB */
+	{0x164, 0x100}, /* index 25, gain_db=9.375000 DB, again_db=9.375000 DB, dgain_db=0.000000 DB */
+	{0x160, 0x100}, /* index 24, gain_db=9.000000 DB, again_db=9.000000 DB, dgain_db=0.000000 DB */
+	{0x15c, 0x100}, /* index 23, gain_db=8.625000 DB, again_db=8.625000 DB, dgain_db=0.000000 DB */
+	{0x158, 0x100}, /* index 22, gain_db=8.250000 DB, again_db=8.250000 DB, dgain_db=0.000000 DB */
+	{0x154, 0x100}, /* index 21, gain_db=7.875000 DB, again_db=7.875000 DB, dgain_db=0.000000 DB */
+	{0x150, 0x100}, /* index 20, gain_db=7.500000 DB, again_db=7.500000 DB, dgain_db=0.000000 DB */
+	{0x14c, 0x100}, /* index 19, gain_db=7.125000 DB, again_db=7.125000 DB, dgain_db=0.000000 DB */
+	{0x148, 0x100}, /* index 18, gain_db=6.750000 DB, again_db=6.750000 DB, dgain_db=0.000000 DB */
+	{0x144, 0x100}, /* index 17, gain_db=6.375000 DB, again_db=6.375000 DB, dgain_db=0.000000 DB */
+	{0x140, 0x100}, /* index 16, gain_db=6.000000 DB, again_db=6.000000 DB, dgain_db=0.000000 DB */
+	{0x13c, 0x100}, /* index 15, gain_db=5.625000 DB, again_db=5.625000 DB, dgain_db=0.000000 DB */
+	{0x138, 0x100}, /* index 14, gain_db=5.250000 DB, again_db=5.250000 DB, dgain_db=0.000000 DB */
+	{0x134, 0x100}, /* index 13, gain_db=4.875000 DB, again_db=4.875000 DB, dgain_db=0.000000 DB */
+	{0x130, 0x100}, /* index 12, gain_db=4.500000 DB, again_db=4.500000 DB, dgain_db=0.000000 DB */
+	{0x12c, 0x100}, /* index 11, gain_db=4.125000 DB, again_db=4.125000 DB, dgain_db=0.000000 DB */
+	{0x128, 0x100}, /* index 10, gain_db=3.750000 DB, again_db=3.750000 DB, dgain_db=0.000000 DB */
+	{0x124, 0x100}, /* index 9, gain_db=3.375000 DB, again_db=3.375000 DB, dgain_db=0.000000 DB */
+	{0x120, 0x100}, /* index 8, gain_db=3.000000 DB, again_db=3.000000 DB, dgain_db=0.000000 DB */
+	{0x11c, 0x100}, /* index 7, gain_db=2.625000 DB, again_db=2.625000 DB, dgain_db=0.000000 DB */
+	{0x118, 0x100}, /* index 6, gain_db=2.250000 DB, again_db=2.250000 DB, dgain_db=0.000000 DB */
+	{0x114, 0x100}, /* index 5, gain_db=1.875000 DB, again_db=1.875000 DB, dgain_db=0.000000 DB */
+	{0x110, 0x100}, /* index 4, gain_db=1.500000 DB, again_db=1.500000 DB, dgain_db=0.000000 DB */
+	{0x10c, 0x100}, /* index 3, gain_db=1.125000 DB, again_db=1.125000 DB, dgain_db=0.000000 DB */
+	{0x108, 0x100}, /* index 2, gain_db=0.750000 DB, again_db=0.750000 DB, dgain_db=0.000000 DB */
+	{0x104, 0x100}, /* index 1, gain_db=0.375000 DB, again_db=0.375000 DB, dgain_db=0.000000 DB */
+	{0x100, 0x100}, /* index 0, gain_db=0.000000 DB, again_db=0.000000 DB, dgain_db=0.000000 DB */
+};
+#else
+/** MN34227PL global gain table row size */
+#define MN34227PL_GAIN_ROWS		(512 + 1)
+#define MN34227PL_GAIN_0DB		(512)
+#define MN34227PL_WDR_GAIN_18DB 	(192)
+#define MN34227PL_WDR_GAIN_30DB	(320)
+
+/* MN34227PL_GAIN_ROWS = 641, MN34227PL_GAIN_COLS = 2 */
+const s16 MN34227PL_GAIN_TABLE[MN34227PL_GAIN_ROWS][MN34227PL_GAIN_COLS] =
+{
+	/* Analog Gain,Digital Gain */
+	{0x240, 0x1c0}, /* index 512, gain_db=48.000000 DB, again_db=30.000000 DB, dgain_db=18.000000 DB */
+	{0x240, 0x1bf}, /* index 511, gain_db=47.906250 DB, again_db=30.000000 DB, dgain_db=17.906250 DB */
+	{0x240, 0x1be}, /* index 510, gain_db=47.812500 DB, again_db=30.000000 DB, dgain_db=17.812500 DB */
+	{0x240, 0x1bd}, /* index 509, gain_db=47.718750 DB, again_db=30.000000 DB, dgain_db=17.718750 DB */
+	{0x240, 0x1bc}, /* index 508, gain_db=47.625000 DB, again_db=30.000000 DB, dgain_db=17.625000 DB */
+	{0x240, 0x1bb}, /* index 507, gain_db=47.531250 DB, again_db=30.000000 DB, dgain_db=17.531250 DB */
+	{0x240, 0x1ba}, /* index 506, gain_db=47.437500 DB, again_db=30.000000 DB, dgain_db=17.437500 DB */
+	{0x240, 0x1b9}, /* index 505, gain_db=47.343750 DB, again_db=30.000000 DB, dgain_db=17.343750 DB */
+	{0x240, 0x1b8}, /* index 504, gain_db=47.250000 DB, again_db=30.000000 DB, dgain_db=17.250000 DB */
+	{0x240, 0x1b7}, /* index 503, gain_db=47.156250 DB, again_db=30.000000 DB, dgain_db=17.156250 DB */
+	{0x240, 0x1b6}, /* index 502, gain_db=47.062500 DB, again_db=30.000000 DB, dgain_db=17.062500 DB */
+	{0x240, 0x1b5}, /* index 501, gain_db=46.968750 DB, again_db=30.000000 DB, dgain_db=16.968750 DB */
+	{0x240, 0x1b4}, /* index 500, gain_db=46.875000 DB, again_db=30.000000 DB, dgain_db=16.875000 DB */
+	{0x240, 0x1b3}, /* index 499, gain_db=46.781250 DB, again_db=30.000000 DB, dgain_db=16.781250 DB */
+	{0x240, 0x1b2}, /* index 498, gain_db=46.687500 DB, again_db=30.000000 DB, dgain_db=16.687500 DB */
+	{0x240, 0x1b1}, /* index 497, gain_db=46.593750 DB, again_db=30.000000 DB, dgain_db=16.593750 DB */
+	{0x240, 0x1b0}, /* index 496, gain_db=46.500000 DB, again_db=30.000000 DB, dgain_db=16.500000 DB */
+	{0x240, 0x1af}, /* index 495, gain_db=46.406250 DB, again_db=30.000000 DB, dgain_db=16.406250 DB */
+	{0x240, 0x1ae}, /* index 494, gain_db=46.312500 DB, again_db=30.000000 DB, dgain_db=16.312500 DB */
+	{0x240, 0x1ad}, /* index 493, gain_db=46.218750 DB, again_db=30.000000 DB, dgain_db=16.218750 DB */
+	{0x240, 0x1ac}, /* index 492, gain_db=46.125000 DB, again_db=30.000000 DB, dgain_db=16.125000 DB */
+	{0x240, 0x1ab}, /* index 491, gain_db=46.031250 DB, again_db=30.000000 DB, dgain_db=16.031250 DB */
+	{0x240, 0x1aa}, /* index 490, gain_db=45.937500 DB, again_db=30.000000 DB, dgain_db=15.937500 DB */
+	{0x240, 0x1a9}, /* index 489, gain_db=45.843750 DB, again_db=30.000000 DB, dgain_db=15.843750 DB */
+	{0x240, 0x1a8}, /* index 488, gain_db=45.750000 DB, again_db=30.000000 DB, dgain_db=15.750000 DB */
+	{0x240, 0x1a7}, /* index 487, gain_db=45.656250 DB, again_db=30.000000 DB, dgain_db=15.656250 DB */
+	{0x240, 0x1a6}, /* index 486, gain_db=45.562500 DB, again_db=30.000000 DB, dgain_db=15.562500 DB */
+	{0x240, 0x1a5}, /* index 485, gain_db=45.468750 DB, again_db=30.000000 DB, dgain_db=15.468750 DB */
+	{0x240, 0x1a4}, /* index 484, gain_db=45.375000 DB, again_db=30.000000 DB, dgain_db=15.375000 DB */
+	{0x240, 0x1a3}, /* index 483, gain_db=45.281250 DB, again_db=30.000000 DB, dgain_db=15.281250 DB */
+	{0x240, 0x1a2}, /* index 482, gain_db=45.187500 DB, again_db=30.000000 DB, dgain_db=15.187500 DB */
+	{0x240, 0x1a1}, /* index 481, gain_db=45.093750 DB, again_db=30.000000 DB, dgain_db=15.093750 DB */
+	{0x240, 0x1a0}, /* index 480, gain_db=45.000000 DB, again_db=30.000000 DB, dgain_db=15.000000 DB */
+	{0x240, 0x19f}, /* index 479, gain_db=44.906250 DB, again_db=30.000000 DB, dgain_db=14.906250 DB */
+	{0x240, 0x19e}, /* index 478, gain_db=44.812500 DB, again_db=30.000000 DB, dgain_db=14.812500 DB */
+	{0x240, 0x19d}, /* index 477, gain_db=44.718750 DB, again_db=30.000000 DB, dgain_db=14.718750 DB */
+	{0x240, 0x19c}, /* index 476, gain_db=44.625000 DB, again_db=30.000000 DB, dgain_db=14.625000 DB */
+	{0x240, 0x19b}, /* index 475, gain_db=44.531250 DB, again_db=30.000000 DB, dgain_db=14.531250 DB */
+	{0x240, 0x19a}, /* index 474, gain_db=44.437500 DB, again_db=30.000000 DB, dgain_db=14.437500 DB */
+	{0x240, 0x199}, /* index 473, gain_db=44.343750 DB, again_db=30.000000 DB, dgain_db=14.343750 DB */
+	{0x240, 0x198}, /* index 472, gain_db=44.250000 DB, again_db=30.000000 DB, dgain_db=14.250000 DB */
+	{0x240, 0x197}, /* index 471, gain_db=44.156250 DB, again_db=30.000000 DB, dgain_db=14.156250 DB */
+	{0x240, 0x196}, /* index 470, gain_db=44.062500 DB, again_db=30.000000 DB, dgain_db=14.062500 DB */
+	{0x240, 0x195}, /* index 469, gain_db=43.968750 DB, again_db=30.000000 DB, dgain_db=13.968750 DB */
+	{0x240, 0x194}, /* index 468, gain_db=43.875000 DB, again_db=30.000000 DB, dgain_db=13.875000 DB */
+	{0x240, 0x193}, /* index 467, gain_db=43.781250 DB, again_db=30.000000 DB, dgain_db=13.781250 DB */
+	{0x240, 0x192}, /* index 466, gain_db=43.687500 DB, again_db=30.000000 DB, dgain_db=13.687500 DB */
+	{0x240, 0x191}, /* index 465, gain_db=43.593750 DB, again_db=30.000000 DB, dgain_db=13.593750 DB */
+	{0x240, 0x190}, /* index 464, gain_db=43.500000 DB, again_db=30.000000 DB, dgain_db=13.500000 DB */
+	{0x240, 0x18f}, /* index 463, gain_db=43.406250 DB, again_db=30.000000 DB, dgain_db=13.406250 DB */
+	{0x240, 0x18e}, /* index 462, gain_db=43.312500 DB, again_db=30.000000 DB, dgain_db=13.312500 DB */
+	{0x240, 0x18d}, /* index 461, gain_db=43.218750 DB, again_db=30.000000 DB, dgain_db=13.218750 DB */
+	{0x240, 0x18c}, /* index 460, gain_db=43.125000 DB, again_db=30.000000 DB, dgain_db=13.125000 DB */
+	{0x240, 0x18b}, /* index 459, gain_db=43.031250 DB, again_db=30.000000 DB, dgain_db=13.031250 DB */
+	{0x240, 0x18a}, /* index 458, gain_db=42.937500 DB, again_db=30.000000 DB, dgain_db=12.937500 DB */
+	{0x240, 0x189}, /* index 457, gain_db=42.843750 DB, again_db=30.000000 DB, dgain_db=12.843750 DB */
+	{0x240, 0x188}, /* index 456, gain_db=42.750000 DB, again_db=30.000000 DB, dgain_db=12.750000 DB */
+	{0x240, 0x187}, /* index 455, gain_db=42.656250 DB, again_db=30.000000 DB, dgain_db=12.656250 DB */
+	{0x240, 0x186}, /* index 454, gain_db=42.562500 DB, again_db=30.000000 DB, dgain_db=12.562500 DB */
+	{0x240, 0x185}, /* index 453, gain_db=42.468750 DB, again_db=30.000000 DB, dgain_db=12.468750 DB */
+	{0x240, 0x184}, /* index 452, gain_db=42.375000 DB, again_db=30.000000 DB, dgain_db=12.375000 DB */
+	{0x240, 0x183}, /* index 451, gain_db=42.281250 DB, again_db=30.000000 DB, dgain_db=12.281250 DB */
+	{0x240, 0x182}, /* index 450, gain_db=42.187500 DB, again_db=30.000000 DB, dgain_db=12.187500 DB */
+	{0x240, 0x181}, /* index 449, gain_db=42.093750 DB, again_db=30.000000 DB, dgain_db=12.093750 DB */
+	{0x240, 0x180}, /* index 448, gain_db=42.000000 DB, again_db=30.000000 DB, dgain_db=12.000000 DB */
+	{0x240, 0x17f}, /* index 447, gain_db=41.906250 DB, again_db=30.000000 DB, dgain_db=11.906250 DB */
+	{0x240, 0x17e}, /* index 446, gain_db=41.812500 DB, again_db=30.000000 DB, dgain_db=11.812500 DB */
+	{0x240, 0x17d}, /* index 445, gain_db=41.718750 DB, again_db=30.000000 DB, dgain_db=11.718750 DB */
+	{0x240, 0x17c}, /* index 444, gain_db=41.625000 DB, again_db=30.000000 DB, dgain_db=11.625000 DB */
+	{0x240, 0x17b}, /* index 443, gain_db=41.531250 DB, again_db=30.000000 DB, dgain_db=11.531250 DB */
+	{0x240, 0x17a}, /* index 442, gain_db=41.437500 DB, again_db=30.000000 DB, dgain_db=11.437500 DB */
+	{0x240, 0x179}, /* index 441, gain_db=41.343750 DB, again_db=30.000000 DB, dgain_db=11.343750 DB */
+	{0x240, 0x178}, /* index 440, gain_db=41.250000 DB, again_db=30.000000 DB, dgain_db=11.250000 DB */
+	{0x240, 0x177}, /* index 439, gain_db=41.156250 DB, again_db=30.000000 DB, dgain_db=11.156250 DB */
+	{0x240, 0x176}, /* index 438, gain_db=41.062500 DB, again_db=30.000000 DB, dgain_db=11.062500 DB */
+	{0x240, 0x175}, /* index 437, gain_db=40.968750 DB, again_db=30.000000 DB, dgain_db=10.968750 DB */
+	{0x240, 0x174}, /* index 436, gain_db=40.875000 DB, again_db=30.000000 DB, dgain_db=10.875000 DB */
+	{0x240, 0x173}, /* index 435, gain_db=40.781250 DB, again_db=30.000000 DB, dgain_db=10.781250 DB */
+	{0x240, 0x172}, /* index 434, gain_db=40.687500 DB, again_db=30.000000 DB, dgain_db=10.687500 DB */
+	{0x240, 0x171}, /* index 433, gain_db=40.593750 DB, again_db=30.000000 DB, dgain_db=10.593750 DB */
+	{0x240, 0x170}, /* index 432, gain_db=40.500000 DB, again_db=30.000000 DB, dgain_db=10.500000 DB */
+	{0x240, 0x16f}, /* index 431, gain_db=40.406250 DB, again_db=30.000000 DB, dgain_db=10.406250 DB */
+	{0x240, 0x16e}, /* index 430, gain_db=40.312500 DB, again_db=30.000000 DB, dgain_db=10.312500 DB */
+	{0x240, 0x16d}, /* index 429, gain_db=40.218750 DB, again_db=30.000000 DB, dgain_db=10.218750 DB */
+	{0x240, 0x16c}, /* index 428, gain_db=40.125000 DB, again_db=30.000000 DB, dgain_db=10.125000 DB */
+	{0x240, 0x16b}, /* index 427, gain_db=40.031250 DB, again_db=30.000000 DB, dgain_db=10.031250 DB */
+	{0x240, 0x16a}, /* index 426, gain_db=39.937500 DB, again_db=30.000000 DB, dgain_db=9.937500 DB */
+	{0x240, 0x169}, /* index 425, gain_db=39.843750 DB, again_db=30.000000 DB, dgain_db=9.843750 DB */
+	{0x240, 0x168}, /* index 424, gain_db=39.750000 DB, again_db=30.000000 DB, dgain_db=9.750000 DB */
+	{0x240, 0x167}, /* index 423, gain_db=39.656250 DB, again_db=30.000000 DB, dgain_db=9.656250 DB */
+	{0x240, 0x166}, /* index 422, gain_db=39.562500 DB, again_db=30.000000 DB, dgain_db=9.562500 DB */
+	{0x240, 0x165}, /* index 421, gain_db=39.468750 DB, again_db=30.000000 DB, dgain_db=9.468750 DB */
+	{0x240, 0x164}, /* index 420, gain_db=39.375000 DB, again_db=30.000000 DB, dgain_db=9.375000 DB */
+	{0x240, 0x163}, /* index 419, gain_db=39.281250 DB, again_db=30.000000 DB, dgain_db=9.281250 DB */
+	{0x240, 0x162}, /* index 418, gain_db=39.187500 DB, again_db=30.000000 DB, dgain_db=9.187500 DB */
+	{0x240, 0x161}, /* index 417, gain_db=39.093750 DB, again_db=30.000000 DB, dgain_db=9.093750 DB */
+	{0x240, 0x160}, /* index 416, gain_db=39.000000 DB, again_db=30.000000 DB, dgain_db=9.000000 DB */
+	{0x240, 0x15f}, /* index 415, gain_db=38.906250 DB, again_db=30.000000 DB, dgain_db=8.906250 DB */
+	{0x240, 0x15e}, /* index 414, gain_db=38.812500 DB, again_db=30.000000 DB, dgain_db=8.812500 DB */
+	{0x240, 0x15d}, /* index 413, gain_db=38.718750 DB, again_db=30.000000 DB, dgain_db=8.718750 DB */
+	{0x240, 0x15c}, /* index 412, gain_db=38.625000 DB, again_db=30.000000 DB, dgain_db=8.625000 DB */
+	{0x240, 0x15b}, /* index 411, gain_db=38.531250 DB, again_db=30.000000 DB, dgain_db=8.531250 DB */
+	{0x240, 0x15a}, /* index 410, gain_db=38.437500 DB, again_db=30.000000 DB, dgain_db=8.437500 DB */
+	{0x240, 0x159}, /* index 409, gain_db=38.343750 DB, again_db=30.000000 DB, dgain_db=8.343750 DB */
+	{0x240, 0x158}, /* index 408, gain_db=38.250000 DB, again_db=30.000000 DB, dgain_db=8.250000 DB */
+	{0x240, 0x157}, /* index 407, gain_db=38.156250 DB, again_db=30.000000 DB, dgain_db=8.156250 DB */
+	{0x240, 0x156}, /* index 406, gain_db=38.062500 DB, again_db=30.000000 DB, dgain_db=8.062500 DB */
+	{0x240, 0x155}, /* index 405, gain_db=37.968750 DB, again_db=30.000000 DB, dgain_db=7.968750 DB */
+	{0x240, 0x154}, /* index 404, gain_db=37.875000 DB, again_db=30.000000 DB, dgain_db=7.875000 DB */
+	{0x240, 0x153}, /* index 403, gain_db=37.781250 DB, again_db=30.000000 DB, dgain_db=7.781250 DB */
+	{0x240, 0x152}, /* index 402, gain_db=37.687500 DB, again_db=30.000000 DB, dgain_db=7.687500 DB */
+	{0x240, 0x151}, /* index 401, gain_db=37.593750 DB, again_db=30.000000 DB, dgain_db=7.593750 DB */
+	{0x240, 0x150}, /* index 400, gain_db=37.500000 DB, again_db=30.000000 DB, dgain_db=7.500000 DB */
+	{0x240, 0x14f}, /* index 399, gain_db=37.406250 DB, again_db=30.000000 DB, dgain_db=7.406250 DB */
+	{0x240, 0x14e}, /* index 398, gain_db=37.312500 DB, again_db=30.000000 DB, dgain_db=7.312500 DB */
+	{0x240, 0x14d}, /* index 397, gain_db=37.218750 DB, again_db=30.000000 DB, dgain_db=7.218750 DB */
+	{0x240, 0x14c}, /* index 396, gain_db=37.125000 DB, again_db=30.000000 DB, dgain_db=7.125000 DB */
+	{0x240, 0x14b}, /* index 395, gain_db=37.031250 DB, again_db=30.000000 DB, dgain_db=7.031250 DB */
+	{0x240, 0x14a}, /* index 394, gain_db=36.937500 DB, again_db=30.000000 DB, dgain_db=6.937500 DB */
+	{0x240, 0x149}, /* index 393, gain_db=36.843750 DB, again_db=30.000000 DB, dgain_db=6.843750 DB */
+	{0x240, 0x148}, /* index 392, gain_db=36.750000 DB, again_db=30.000000 DB, dgain_db=6.750000 DB */
+	{0x240, 0x147}, /* index 391, gain_db=36.656250 DB, again_db=30.000000 DB, dgain_db=6.656250 DB */
+	{0x240, 0x146}, /* index 390, gain_db=36.562500 DB, again_db=30.000000 DB, dgain_db=6.562500 DB */
+	{0x240, 0x145}, /* index 389, gain_db=36.468750 DB, again_db=30.000000 DB, dgain_db=6.468750 DB */
+	{0x240, 0x144}, /* index 388, gain_db=36.375000 DB, again_db=30.000000 DB, dgain_db=6.375000 DB */
+	{0x240, 0x143}, /* index 387, gain_db=36.281250 DB, again_db=30.000000 DB, dgain_db=6.281250 DB */
+	{0x240, 0x142}, /* index 386, gain_db=36.187500 DB, again_db=30.000000 DB, dgain_db=6.187500 DB */
+	{0x240, 0x141}, /* index 385, gain_db=36.093750 DB, again_db=30.000000 DB, dgain_db=6.093750 DB */
+	{0x240, 0x140}, /* index 384, gain_db=36.000000 DB, again_db=30.000000 DB, dgain_db=6.000000 DB */
+	{0x240, 0x13f}, /* index 383, gain_db=35.906250 DB, again_db=30.000000 DB, dgain_db=5.906250 DB */
+	{0x240, 0x13e}, /* index 382, gain_db=35.812500 DB, again_db=30.000000 DB, dgain_db=5.812500 DB */
+	{0x240, 0x13d}, /* index 381, gain_db=35.718750 DB, again_db=30.000000 DB, dgain_db=5.718750 DB */
+	{0x240, 0x13c}, /* index 380, gain_db=35.625000 DB, again_db=30.000000 DB, dgain_db=5.625000 DB */
+	{0x240, 0x13b}, /* index 379, gain_db=35.531250 DB, again_db=30.000000 DB, dgain_db=5.531250 DB */
+	{0x240, 0x13a}, /* index 378, gain_db=35.437500 DB, again_db=30.000000 DB, dgain_db=5.437500 DB */
+	{0x240, 0x139}, /* index 377, gain_db=35.343750 DB, again_db=30.000000 DB, dgain_db=5.343750 DB */
+	{0x240, 0x138}, /* index 376, gain_db=35.250000 DB, again_db=30.000000 DB, dgain_db=5.250000 DB */
+	{0x240, 0x137}, /* index 375, gain_db=35.156250 DB, again_db=30.000000 DB, dgain_db=5.156250 DB */
+	{0x240, 0x136}, /* index 374, gain_db=35.062500 DB, again_db=30.000000 DB, dgain_db=5.062500 DB */
+	{0x240, 0x135}, /* index 373, gain_db=34.968750 DB, again_db=30.000000 DB, dgain_db=4.968750 DB */
+	{0x240, 0x134}, /* index 372, gain_db=34.875000 DB, again_db=30.000000 DB, dgain_db=4.875000 DB */
+	{0x240, 0x133}, /* index 371, gain_db=34.781250 DB, again_db=30.000000 DB, dgain_db=4.781250 DB */
+	{0x240, 0x132}, /* index 370, gain_db=34.687500 DB, again_db=30.000000 DB, dgain_db=4.687500 DB */
+	{0x240, 0x131}, /* index 369, gain_db=34.593750 DB, again_db=30.000000 DB, dgain_db=4.593750 DB */
+	{0x240, 0x130}, /* index 368, gain_db=34.500000 DB, again_db=30.000000 DB, dgain_db=4.500000 DB */
+	{0x240, 0x12f}, /* index 367, gain_db=34.406250 DB, again_db=30.000000 DB, dgain_db=4.406250 DB */
+	{0x240, 0x12e}, /* index 366, gain_db=34.312500 DB, again_db=30.000000 DB, dgain_db=4.312500 DB */
+	{0x240, 0x12d}, /* index 365, gain_db=34.218750 DB, again_db=30.000000 DB, dgain_db=4.218750 DB */
+	{0x240, 0x12c}, /* index 364, gain_db=34.125000 DB, again_db=30.000000 DB, dgain_db=4.125000 DB */
+	{0x240, 0x12b}, /* index 363, gain_db=34.031250 DB, again_db=30.000000 DB, dgain_db=4.031250 DB */
+	{0x240, 0x12a}, /* index 362, gain_db=33.937500 DB, again_db=30.000000 DB, dgain_db=3.937500 DB */
+	{0x240, 0x129}, /* index 361, gain_db=33.843750 DB, again_db=30.000000 DB, dgain_db=3.843750 DB */
+	{0x240, 0x128}, /* index 360, gain_db=33.750000 DB, again_db=30.000000 DB, dgain_db=3.750000 DB */
+	{0x240, 0x127}, /* index 359, gain_db=33.656250 DB, again_db=30.000000 DB, dgain_db=3.656250 DB */
+	{0x240, 0x126}, /* index 358, gain_db=33.562500 DB, again_db=30.000000 DB, dgain_db=3.562500 DB */
+	{0x240, 0x125}, /* index 357, gain_db=33.468750 DB, again_db=30.000000 DB, dgain_db=3.468750 DB */
+	{0x240, 0x124}, /* index 356, gain_db=33.375000 DB, again_db=30.000000 DB, dgain_db=3.375000 DB */
+	{0x240, 0x123}, /* index 355, gain_db=33.281250 DB, again_db=30.000000 DB, dgain_db=3.281250 DB */
+	{0x240, 0x122}, /* index 354, gain_db=33.187500 DB, again_db=30.000000 DB, dgain_db=3.187500 DB */
+	{0x240, 0x121}, /* index 353, gain_db=33.093750 DB, again_db=30.000000 DB, dgain_db=3.093750 DB */
+	{0x240, 0x120}, /* index 352, gain_db=33.000000 DB, again_db=30.000000 DB, dgain_db=3.000000 DB */
+	{0x240, 0x11f}, /* index 351, gain_db=32.906250 DB, again_db=30.000000 DB, dgain_db=2.906250 DB */
+	{0x240, 0x11e}, /* index 350, gain_db=32.812500 DB, again_db=30.000000 DB, dgain_db=2.812500 DB */
+	{0x240, 0x11d}, /* index 349, gain_db=32.718750 DB, again_db=30.000000 DB, dgain_db=2.718750 DB */
+	{0x240, 0x11c}, /* index 348, gain_db=32.625000 DB, again_db=30.000000 DB, dgain_db=2.625000 DB */
+	{0x240, 0x11b}, /* index 347, gain_db=32.531250 DB, again_db=30.000000 DB, dgain_db=2.531250 DB */
+	{0x240, 0x11a}, /* index 346, gain_db=32.437500 DB, again_db=30.000000 DB, dgain_db=2.437500 DB */
+	{0x240, 0x119}, /* index 345, gain_db=32.343750 DB, again_db=30.000000 DB, dgain_db=2.343750 DB */
+	{0x240, 0x118}, /* index 344, gain_db=32.250000 DB, again_db=30.000000 DB, dgain_db=2.250000 DB */
+	{0x240, 0x117}, /* index 343, gain_db=32.156250 DB, again_db=30.000000 DB, dgain_db=2.156250 DB */
+	{0x240, 0x116}, /* index 342, gain_db=32.062500 DB, again_db=30.000000 DB, dgain_db=2.062500 DB */
+	{0x240, 0x115}, /* index 341, gain_db=31.968750 DB, again_db=30.000000 DB, dgain_db=1.968750 DB */
+	{0x240, 0x114}, /* index 340, gain_db=31.875000 DB, again_db=30.000000 DB, dgain_db=1.875000 DB */
+	{0x240, 0x113}, /* index 339, gain_db=31.781250 DB, again_db=30.000000 DB, dgain_db=1.781250 DB */
+	{0x240, 0x112}, /* index 338, gain_db=31.687500 DB, again_db=30.000000 DB, dgain_db=1.687500 DB */
+	{0x240, 0x111}, /* index 337, gain_db=31.593750 DB, again_db=30.000000 DB, dgain_db=1.593750 DB */
+	{0x240, 0x110}, /* index 336, gain_db=31.500000 DB, again_db=30.000000 DB, dgain_db=1.500000 DB */
+	{0x240, 0x10f}, /* index 335, gain_db=31.406250 DB, again_db=30.000000 DB, dgain_db=1.406250 DB */
+	{0x240, 0x10e}, /* index 334, gain_db=31.312500 DB, again_db=30.000000 DB, dgain_db=1.312500 DB */
+	{0x240, 0x10d}, /* index 333, gain_db=31.218750 DB, again_db=30.000000 DB, dgain_db=1.218750 DB */
+	{0x240, 0x10c}, /* index 332, gain_db=31.125000 DB, again_db=30.000000 DB, dgain_db=1.125000 DB */
+	{0x240, 0x10b}, /* index 331, gain_db=31.031250 DB, again_db=30.000000 DB, dgain_db=1.031250 DB */
+	{0x240, 0x10a}, /* index 330, gain_db=30.937500 DB, again_db=30.000000 DB, dgain_db=0.937500 DB */
+	{0x240, 0x109}, /* index 329, gain_db=30.843750 DB, again_db=30.000000 DB, dgain_db=0.843750 DB */
+	{0x240, 0x108}, /* index 328, gain_db=30.750000 DB, again_db=30.000000 DB, dgain_db=0.750000 DB */
+	{0x240, 0x107}, /* index 327, gain_db=30.656250 DB, again_db=30.000000 DB, dgain_db=0.656250 DB */
+	{0x240, 0x106}, /* index 326, gain_db=30.562500 DB, again_db=30.000000 DB, dgain_db=0.562500 DB */
+	{0x240, 0x105}, /* index 325, gain_db=30.468750 DB, again_db=30.000000 DB, dgain_db=0.468750 DB */
+	{0x240, 0x104}, /* index 324, gain_db=30.375000 DB, again_db=30.000000 DB, dgain_db=0.375000 DB */
+	{0x240, 0x103}, /* index 323, gain_db=30.281250 DB, again_db=30.000000 DB, dgain_db=0.281250 DB */
+	{0x240, 0x102}, /* index 322, gain_db=30.187500 DB, again_db=30.000000 DB, dgain_db=0.187500 DB */
+	{0x240, 0x101}, /* index 321, gain_db=30.093750 DB, again_db=30.000000 DB, dgain_db=0.093750 DB */
+	{0x240, 0x100}, /* index 320, gain_db=30.000000 DB, again_db=30.000000 DB, dgain_db=0.000000 DB */
+
+	{0x23f, 0x100}, /* index 319, gain_db=29.906250 DB, again_db=29.906250 DB, dgain_db=0.000000 DB */
+	{0x23e, 0x100}, /* index 318, gain_db=29.812500 DB, again_db=29.812500 DB, dgain_db=0.000000 DB */
+	{0x23d, 0x100}, /* index 317, gain_db=29.718750 DB, again_db=29.718750 DB, dgain_db=0.000000 DB */
+	{0x23c, 0x100}, /* index 316, gain_db=29.625000 DB, again_db=29.625000 DB, dgain_db=0.000000 DB */
+	{0x23b, 0x100}, /* index 315, gain_db=29.531250 DB, again_db=29.531250 DB, dgain_db=0.000000 DB */
+	{0x23a, 0x100}, /* index 314, gain_db=29.437500 DB, again_db=29.437500 DB, dgain_db=0.000000 DB */
+	{0x239, 0x100}, /* index 313, gain_db=29.343750 DB, again_db=29.343750 DB, dgain_db=0.000000 DB */
+	{0x238, 0x100}, /* index 312, gain_db=29.250000 DB, again_db=29.250000 DB, dgain_db=0.000000 DB */
+	{0x237, 0x100}, /* index 311, gain_db=29.156250 DB, again_db=29.156250 DB, dgain_db=0.000000 DB */
+	{0x236, 0x100}, /* index 310, gain_db=29.062500 DB, again_db=29.062500 DB, dgain_db=0.000000 DB */
+	{0x235, 0x100}, /* index 309, gain_db=28.968750 DB, again_db=28.968750 DB, dgain_db=0.000000 DB */
+	{0x234, 0x100}, /* index 308, gain_db=28.875000 DB, again_db=28.875000 DB, dgain_db=0.000000 DB */
+	{0x233, 0x100}, /* index 307, gain_db=28.781250 DB, again_db=28.781250 DB, dgain_db=0.000000 DB */
+	{0x232, 0x100}, /* index 306, gain_db=28.687500 DB, again_db=28.687500 DB, dgain_db=0.000000 DB */
+	{0x231, 0x100}, /* index 305, gain_db=28.593750 DB, again_db=28.593750 DB, dgain_db=0.000000 DB */
+	{0x230, 0x100}, /* index 304, gain_db=28.500000 DB, again_db=28.500000 DB, dgain_db=0.000000 DB */
+	{0x22f, 0x100}, /* index 303, gain_db=28.406250 DB, again_db=28.406250 DB, dgain_db=0.000000 DB */
+	{0x22e, 0x100}, /* index 302, gain_db=28.312500 DB, again_db=28.312500 DB, dgain_db=0.000000 DB */
+	{0x22d, 0x100}, /* index 301, gain_db=28.218750 DB, again_db=28.218750 DB, dgain_db=0.000000 DB */
+	{0x22c, 0x100}, /* index 300, gain_db=28.125000 DB, again_db=28.125000 DB, dgain_db=0.000000 DB */
+	{0x22b, 0x100}, /* index 299, gain_db=28.031250 DB, again_db=28.031250 DB, dgain_db=0.000000 DB */
+	{0x22a, 0x100}, /* index 298, gain_db=27.937500 DB, again_db=27.937500 DB, dgain_db=0.000000 DB */
+	{0x229, 0x100}, /* index 297, gain_db=27.843750 DB, again_db=27.843750 DB, dgain_db=0.000000 DB */
+	{0x228, 0x100}, /* index 296, gain_db=27.750000 DB, again_db=27.750000 DB, dgain_db=0.000000 DB */
+	{0x227, 0x100}, /* index 295, gain_db=27.656250 DB, again_db=27.656250 DB, dgain_db=0.000000 DB */
+	{0x226, 0x100}, /* index 294, gain_db=27.562500 DB, again_db=27.562500 DB, dgain_db=0.000000 DB */
+	{0x225, 0x100}, /* index 293, gain_db=27.468750 DB, again_db=27.468750 DB, dgain_db=0.000000 DB */
+	{0x224, 0x100}, /* index 292, gain_db=27.375000 DB, again_db=27.375000 DB, dgain_db=0.000000 DB */
+	{0x223, 0x100}, /* index 291, gain_db=27.281250 DB, again_db=27.281250 DB, dgain_db=0.000000 DB */
+	{0x222, 0x100}, /* index 290, gain_db=27.187500 DB, again_db=27.187500 DB, dgain_db=0.000000 DB */
+	{0x221, 0x100}, /* index 289, gain_db=27.093750 DB, again_db=27.093750 DB, dgain_db=0.000000 DB */
+	{0x220, 0x100}, /* index 288, gain_db=27.000000 DB, again_db=27.000000 DB, dgain_db=0.000000 DB */
+	{0x21f, 0x100}, /* index 287, gain_db=26.906250 DB, again_db=26.906250 DB, dgain_db=0.000000 DB */
+	{0x21e, 0x100}, /* index 286, gain_db=26.812500 DB, again_db=26.812500 DB, dgain_db=0.000000 DB */
+	{0x21d, 0x100}, /* index 285, gain_db=26.718750 DB, again_db=26.718750 DB, dgain_db=0.000000 DB */
+	{0x21c, 0x100}, /* index 284, gain_db=26.625000 DB, again_db=26.625000 DB, dgain_db=0.000000 DB */
+	{0x21b, 0x100}, /* index 283, gain_db=26.531250 DB, again_db=26.531250 DB, dgain_db=0.000000 DB */
+	{0x21a, 0x100}, /* index 282, gain_db=26.437500 DB, again_db=26.437500 DB, dgain_db=0.000000 DB */
+	{0x219, 0x100}, /* index 281, gain_db=26.343750 DB, again_db=26.343750 DB, dgain_db=0.000000 DB */
+	{0x218, 0x100}, /* index 280, gain_db=26.250000 DB, again_db=26.250000 DB, dgain_db=0.000000 DB */
+	{0x217, 0x100}, /* index 279, gain_db=26.156250 DB, again_db=26.156250 DB, dgain_db=0.000000 DB */
+	{0x216, 0x100}, /* index 278, gain_db=26.062500 DB, again_db=26.062500 DB, dgain_db=0.000000 DB */
+	{0x215, 0x100}, /* index 277, gain_db=25.968750 DB, again_db=25.968750 DB, dgain_db=0.000000 DB */
+	{0x214, 0x100}, /* index 276, gain_db=25.875000 DB, again_db=25.875000 DB, dgain_db=0.000000 DB */
+	{0x213, 0x100}, /* index 275, gain_db=25.781250 DB, again_db=25.781250 DB, dgain_db=0.000000 DB */
+	{0x212, 0x100}, /* index 274, gain_db=25.687500 DB, again_db=25.687500 DB, dgain_db=0.000000 DB */
+	{0x211, 0x100}, /* index 273, gain_db=25.593750 DB, again_db=25.593750 DB, dgain_db=0.000000 DB */
+	{0x210, 0x100}, /* index 272, gain_db=25.500000 DB, again_db=25.500000 DB, dgain_db=0.000000 DB */
+	{0x20f, 0x100}, /* index 271, gain_db=25.406250 DB, again_db=25.406250 DB, dgain_db=0.000000 DB */
+	{0x20e, 0x100}, /* index 270, gain_db=25.312500 DB, again_db=25.312500 DB, dgain_db=0.000000 DB */
+	{0x20d, 0x100}, /* index 269, gain_db=25.218750 DB, again_db=25.218750 DB, dgain_db=0.000000 DB */
+	{0x20c, 0x100}, /* index 268, gain_db=25.125000 DB, again_db=25.125000 DB, dgain_db=0.000000 DB */
+	{0x20b, 0x100}, /* index 267, gain_db=25.031250 DB, again_db=25.031250 DB, dgain_db=0.000000 DB */
+	{0x20a, 0x100}, /* index 266, gain_db=24.937500 DB, again_db=24.937500 DB, dgain_db=0.000000 DB */
+	{0x209, 0x100}, /* index 265, gain_db=24.843750 DB, again_db=24.843750 DB, dgain_db=0.000000 DB */
+	{0x208, 0x100}, /* index 264, gain_db=24.750000 DB, again_db=24.750000 DB, dgain_db=0.000000 DB */
+	{0x207, 0x100}, /* index 263, gain_db=24.656250 DB, again_db=24.656250 DB, dgain_db=0.000000 DB */
+	{0x206, 0x100}, /* index 262, gain_db=24.562500 DB, again_db=24.562500 DB, dgain_db=0.000000 DB */
+	{0x205, 0x100}, /* index 261, gain_db=24.468750 DB, again_db=24.468750 DB, dgain_db=0.000000 DB */
+	{0x204, 0x100}, /* index 260, gain_db=24.375000 DB, again_db=24.375000 DB, dgain_db=0.000000 DB */
+	{0x203, 0x100}, /* index 259, gain_db=24.281250 DB, again_db=24.281250 DB, dgain_db=0.000000 DB */
+	{0x202, 0x100}, /* index 258, gain_db=24.187500 DB, again_db=24.187500 DB, dgain_db=0.000000 DB */
+	{0x201, 0x100}, /* index 257, gain_db=24.093750 DB, again_db=24.093750 DB, dgain_db=0.000000 DB */
+	{0x200, 0x100}, /* index 256, gain_db=24.000000 DB, again_db=24.000000 DB, dgain_db=0.000000 DB */
+	{0x1ff, 0x100}, /* index 255, gain_db=23.906250 DB, again_db=23.906250 DB, dgain_db=0.000000 DB */
+	{0x1fe, 0x100}, /* index 254, gain_db=23.812500 DB, again_db=23.812500 DB, dgain_db=0.000000 DB */
+	{0x1fd, 0x100}, /* index 253, gain_db=23.718750 DB, again_db=23.718750 DB, dgain_db=0.000000 DB */
+	{0x1fc, 0x100}, /* index 252, gain_db=23.625000 DB, again_db=23.625000 DB, dgain_db=0.000000 DB */
+	{0x1fb, 0x100}, /* index 251, gain_db=23.531250 DB, again_db=23.531250 DB, dgain_db=0.000000 DB */
+	{0x1fa, 0x100}, /* index 250, gain_db=23.437500 DB, again_db=23.437500 DB, dgain_db=0.000000 DB */
+	{0x1f9, 0x100}, /* index 249, gain_db=23.343750 DB, again_db=23.343750 DB, dgain_db=0.000000 DB */
+	{0x1f8, 0x100}, /* index 248, gain_db=23.250000 DB, again_db=23.250000 DB, dgain_db=0.000000 DB */
+	{0x1f7, 0x100}, /* index 247, gain_db=23.156250 DB, again_db=23.156250 DB, dgain_db=0.000000 DB */
+	{0x1f6, 0x100}, /* index 246, gain_db=23.062500 DB, again_db=23.062500 DB, dgain_db=0.000000 DB */
+	{0x1f5, 0x100}, /* index 245, gain_db=22.968750 DB, again_db=22.968750 DB, dgain_db=0.000000 DB */
+	{0x1f4, 0x100}, /* index 244, gain_db=22.875000 DB, again_db=22.875000 DB, dgain_db=0.000000 DB */
+	{0x1f3, 0x100}, /* index 243, gain_db=22.781250 DB, again_db=22.781250 DB, dgain_db=0.000000 DB */
+	{0x1f2, 0x100}, /* index 242, gain_db=22.687500 DB, again_db=22.687500 DB, dgain_db=0.000000 DB */
+	{0x1f1, 0x100}, /* index 241, gain_db=22.593750 DB, again_db=22.593750 DB, dgain_db=0.000000 DB */
+	{0x1f0, 0x100}, /* index 240, gain_db=22.500000 DB, again_db=22.500000 DB, dgain_db=0.000000 DB */
+	{0x1ef, 0x100}, /* index 239, gain_db=22.406250 DB, again_db=22.406250 DB, dgain_db=0.000000 DB */
+	{0x1ee, 0x100}, /* index 238, gain_db=22.312500 DB, again_db=22.312500 DB, dgain_db=0.000000 DB */
+	{0x1ed, 0x100}, /* index 237, gain_db=22.218750 DB, again_db=22.218750 DB, dgain_db=0.000000 DB */
+	{0x1ec, 0x100}, /* index 236, gain_db=22.125000 DB, again_db=22.125000 DB, dgain_db=0.000000 DB */
+	{0x1eb, 0x100}, /* index 235, gain_db=22.031250 DB, again_db=22.031250 DB, dgain_db=0.000000 DB */
+	{0x1ea, 0x100}, /* index 234, gain_db=21.937500 DB, again_db=21.937500 DB, dgain_db=0.000000 DB */
+	{0x1e9, 0x100}, /* index 233, gain_db=21.843750 DB, again_db=21.843750 DB, dgain_db=0.000000 DB */
+	{0x1e8, 0x100}, /* index 232, gain_db=21.750000 DB, again_db=21.750000 DB, dgain_db=0.000000 DB */
+	{0x1e7, 0x100}, /* index 231, gain_db=21.656250 DB, again_db=21.656250 DB, dgain_db=0.000000 DB */
+	{0x1e6, 0x100}, /* index 230, gain_db=21.562500 DB, again_db=21.562500 DB, dgain_db=0.000000 DB */
+	{0x1e5, 0x100}, /* index 229, gain_db=21.468750 DB, again_db=21.468750 DB, dgain_db=0.000000 DB */
+	{0x1e4, 0x100}, /* index 228, gain_db=21.375000 DB, again_db=21.375000 DB, dgain_db=0.000000 DB */
+	{0x1e3, 0x100}, /* index 227, gain_db=21.281250 DB, again_db=21.281250 DB, dgain_db=0.000000 DB */
+	{0x1e2, 0x100}, /* index 226, gain_db=21.187500 DB, again_db=21.187500 DB, dgain_db=0.000000 DB */
+	{0x1e1, 0x100}, /* index 225, gain_db=21.093750 DB, again_db=21.093750 DB, dgain_db=0.000000 DB */
+	{0x1e0, 0x100}, /* index 224, gain_db=21.000000 DB, again_db=21.000000 DB, dgain_db=0.000000 DB */
+	{0x1df, 0x100}, /* index 223, gain_db=20.906250 DB, again_db=20.906250 DB, dgain_db=0.000000 DB */
+	{0x1de, 0x100}, /* index 222, gain_db=20.812500 DB, again_db=20.812500 DB, dgain_db=0.000000 DB */
+	{0x1dd, 0x100}, /* index 221, gain_db=20.718750 DB, again_db=20.718750 DB, dgain_db=0.000000 DB */
+	{0x1dc, 0x100}, /* index 220, gain_db=20.625000 DB, again_db=20.625000 DB, dgain_db=0.000000 DB */
+	{0x1db, 0x100}, /* index 219, gain_db=20.531250 DB, again_db=20.531250 DB, dgain_db=0.000000 DB */
+	{0x1da, 0x100}, /* index 218, gain_db=20.437500 DB, again_db=20.437500 DB, dgain_db=0.000000 DB */
+	{0x1d9, 0x100}, /* index 217, gain_db=20.343750 DB, again_db=20.343750 DB, dgain_db=0.000000 DB */
+	{0x1d8, 0x100}, /* index 216, gain_db=20.250000 DB, again_db=20.250000 DB, dgain_db=0.000000 DB */
+	{0x1d7, 0x100}, /* index 215, gain_db=20.156250 DB, again_db=20.156250 DB, dgain_db=0.000000 DB */
+	{0x1d6, 0x100}, /* index 214, gain_db=20.062500 DB, again_db=20.062500 DB, dgain_db=0.000000 DB */
+	{0x1d5, 0x100}, /* index 213, gain_db=19.968750 DB, again_db=19.968750 DB, dgain_db=0.000000 DB */
+	{0x1d4, 0x100}, /* index 212, gain_db=19.875000 DB, again_db=19.875000 DB, dgain_db=0.000000 DB */
+	{0x1d3, 0x100}, /* index 211, gain_db=19.781250 DB, again_db=19.781250 DB, dgain_db=0.000000 DB */
+	{0x1d2, 0x100}, /* index 210, gain_db=19.687500 DB, again_db=19.687500 DB, dgain_db=0.000000 DB */
+	{0x1d1, 0x100}, /* index 209, gain_db=19.593750 DB, again_db=19.593750 DB, dgain_db=0.000000 DB */
+	{0x1d0, 0x100}, /* index 208, gain_db=19.500000 DB, again_db=19.500000 DB, dgain_db=0.000000 DB */
+	{0x1cf, 0x100}, /* index 207, gain_db=19.406250 DB, again_db=19.406250 DB, dgain_db=0.000000 DB */
+	{0x1ce, 0x100}, /* index 206, gain_db=19.312500 DB, again_db=19.312500 DB, dgain_db=0.000000 DB */
+	{0x1cd, 0x100}, /* index 205, gain_db=19.218750 DB, again_db=19.218750 DB, dgain_db=0.000000 DB */
+	{0x1cc, 0x100}, /* index 204, gain_db=19.125000 DB, again_db=19.125000 DB, dgain_db=0.000000 DB */
+	{0x1cb, 0x100}, /* index 203, gain_db=19.031250 DB, again_db=19.031250 DB, dgain_db=0.000000 DB */
+	{0x1ca, 0x100}, /* index 202, gain_db=18.937500 DB, again_db=18.937500 DB, dgain_db=0.000000 DB */
+	{0x1c9, 0x100}, /* index 201, gain_db=18.843750 DB, again_db=18.843750 DB, dgain_db=0.000000 DB */
+	{0x1c8, 0x100}, /* index 200, gain_db=18.750000 DB, again_db=18.750000 DB, dgain_db=0.000000 DB */
+	{0x1c7, 0x100}, /* index 199, gain_db=18.656250 DB, again_db=18.656250 DB, dgain_db=0.000000 DB */
+	{0x1c6, 0x100}, /* index 198, gain_db=18.562500 DB, again_db=18.562500 DB, dgain_db=0.000000 DB */
+	{0x1c5, 0x100}, /* index 197, gain_db=18.468750 DB, again_db=18.468750 DB, dgain_db=0.000000 DB */
+	{0x1c4, 0x100}, /* index 196, gain_db=18.375000 DB, again_db=18.375000 DB, dgain_db=0.000000 DB */
+	{0x1c3, 0x100}, /* index 195, gain_db=18.281250 DB, again_db=18.281250 DB, dgain_db=0.000000 DB */
+	{0x1c2, 0x100}, /* index 194, gain_db=18.187500 DB, again_db=18.187500 DB, dgain_db=0.000000 DB */
+	{0x1c1, 0x100}, /* index 193, gain_db=18.093750 DB, again_db=18.093750 DB, dgain_db=0.000000 DB */
+	{0x1c0, 0x100}, /* index 192, gain_db=18.000000 DB, again_db=18.000000 DB, dgain_db=0.000000 DB */
+	{0x1bf, 0x100}, /* index 191, gain_db=17.906250 DB, again_db=17.906250 DB, dgain_db=0.000000 DB */
+	{0x1be, 0x100}, /* index 190, gain_db=17.812500 DB, again_db=17.812500 DB, dgain_db=0.000000 DB */
+	{0x1bd, 0x100}, /* index 189, gain_db=17.718750 DB, again_db=17.718750 DB, dgain_db=0.000000 DB */
+	{0x1bc, 0x100}, /* index 188, gain_db=17.625000 DB, again_db=17.625000 DB, dgain_db=0.000000 DB */
+	{0x1bb, 0x100}, /* index 187, gain_db=17.531250 DB, again_db=17.531250 DB, dgain_db=0.000000 DB */
+	{0x1ba, 0x100}, /* index 186, gain_db=17.437500 DB, again_db=17.437500 DB, dgain_db=0.000000 DB */
+	{0x1b9, 0x100}, /* index 185, gain_db=17.343750 DB, again_db=17.343750 DB, dgain_db=0.000000 DB */
+	{0x1b8, 0x100}, /* index 184, gain_db=17.250000 DB, again_db=17.250000 DB, dgain_db=0.000000 DB */
+	{0x1b7, 0x100}, /* index 183, gain_db=17.156250 DB, again_db=17.156250 DB, dgain_db=0.000000 DB */
+	{0x1b6, 0x100}, /* index 182, gain_db=17.062500 DB, again_db=17.062500 DB, dgain_db=0.000000 DB */
+	{0x1b5, 0x100}, /* index 181, gain_db=16.968750 DB, again_db=16.968750 DB, dgain_db=0.000000 DB */
+	{0x1b4, 0x100}, /* index 180, gain_db=16.875000 DB, again_db=16.875000 DB, dgain_db=0.000000 DB */
+	{0x1b3, 0x100}, /* index 179, gain_db=16.781250 DB, again_db=16.781250 DB, dgain_db=0.000000 DB */
+	{0x1b2, 0x100}, /* index 178, gain_db=16.687500 DB, again_db=16.687500 DB, dgain_db=0.000000 DB */
+	{0x1b1, 0x100}, /* index 177, gain_db=16.593750 DB, again_db=16.593750 DB, dgain_db=0.000000 DB */
+	{0x1b0, 0x100}, /* index 176, gain_db=16.500000 DB, again_db=16.500000 DB, dgain_db=0.000000 DB */
+	{0x1af, 0x100}, /* index 175, gain_db=16.406250 DB, again_db=16.406250 DB, dgain_db=0.000000 DB */
+	{0x1ae, 0x100}, /* index 174, gain_db=16.312500 DB, again_db=16.312500 DB, dgain_db=0.000000 DB */
+	{0x1ad, 0x100}, /* index 173, gain_db=16.218750 DB, again_db=16.218750 DB, dgain_db=0.000000 DB */
+	{0x1ac, 0x100}, /* index 172, gain_db=16.125000 DB, again_db=16.125000 DB, dgain_db=0.000000 DB */
+	{0x1ab, 0x100}, /* index 171, gain_db=16.031250 DB, again_db=16.031250 DB, dgain_db=0.000000 DB */
+	{0x1aa, 0x100}, /* index 170, gain_db=15.937500 DB, again_db=15.937500 DB, dgain_db=0.000000 DB */
+	{0x1a9, 0x100}, /* index 169, gain_db=15.843750 DB, again_db=15.843750 DB, dgain_db=0.000000 DB */
+	{0x1a8, 0x100}, /* index 168, gain_db=15.750000 DB, again_db=15.750000 DB, dgain_db=0.000000 DB */
+	{0x1a7, 0x100}, /* index 167, gain_db=15.656250 DB, again_db=15.656250 DB, dgain_db=0.000000 DB */
+	{0x1a6, 0x100}, /* index 166, gain_db=15.562500 DB, again_db=15.562500 DB, dgain_db=0.000000 DB */
+	{0x1a5, 0x100}, /* index 165, gain_db=15.468750 DB, again_db=15.468750 DB, dgain_db=0.000000 DB */
+	{0x1a4, 0x100}, /* index 164, gain_db=15.375000 DB, again_db=15.375000 DB, dgain_db=0.000000 DB */
+	{0x1a3, 0x100}, /* index 163, gain_db=15.281250 DB, again_db=15.281250 DB, dgain_db=0.000000 DB */
+	{0x1a2, 0x100}, /* index 162, gain_db=15.187500 DB, again_db=15.187500 DB, dgain_db=0.000000 DB */
+	{0x1a1, 0x100}, /* index 161, gain_db=15.093750 DB, again_db=15.093750 DB, dgain_db=0.000000 DB */
+	{0x1a0, 0x100}, /* index 160, gain_db=15.000000 DB, again_db=15.000000 DB, dgain_db=0.000000 DB */
+	{0x19f, 0x100}, /* index 159, gain_db=14.906250 DB, again_db=14.906250 DB, dgain_db=0.000000 DB */
+	{0x19e, 0x100}, /* index 158, gain_db=14.812500 DB, again_db=14.812500 DB, dgain_db=0.000000 DB */
+	{0x19d, 0x100}, /* index 157, gain_db=14.718750 DB, again_db=14.718750 DB, dgain_db=0.000000 DB */
+	{0x19c, 0x100}, /* index 156, gain_db=14.625000 DB, again_db=14.625000 DB, dgain_db=0.000000 DB */
+	{0x19b, 0x100}, /* index 155, gain_db=14.531250 DB, again_db=14.531250 DB, dgain_db=0.000000 DB */
+	{0x19a, 0x100}, /* index 154, gain_db=14.437500 DB, again_db=14.437500 DB, dgain_db=0.000000 DB */
+	{0x199, 0x100}, /* index 153, gain_db=14.343750 DB, again_db=14.343750 DB, dgain_db=0.000000 DB */
+	{0x198, 0x100}, /* index 152, gain_db=14.250000 DB, again_db=14.250000 DB, dgain_db=0.000000 DB */
+	{0x197, 0x100}, /* index 151, gain_db=14.156250 DB, again_db=14.156250 DB, dgain_db=0.000000 DB */
+	{0x196, 0x100}, /* index 150, gain_db=14.062500 DB, again_db=14.062500 DB, dgain_db=0.000000 DB */
+	{0x195, 0x100}, /* index 149, gain_db=13.968750 DB, again_db=13.968750 DB, dgain_db=0.000000 DB */
+	{0x194, 0x100}, /* index 148, gain_db=13.875000 DB, again_db=13.875000 DB, dgain_db=0.000000 DB */
+	{0x193, 0x100}, /* index 147, gain_db=13.781250 DB, again_db=13.781250 DB, dgain_db=0.000000 DB */
+	{0x192, 0x100}, /* index 146, gain_db=13.687500 DB, again_db=13.687500 DB, dgain_db=0.000000 DB */
+	{0x191, 0x100}, /* index 145, gain_db=13.593750 DB, again_db=13.593750 DB, dgain_db=0.000000 DB */
+	{0x190, 0x100}, /* index 144, gain_db=13.500000 DB, again_db=13.500000 DB, dgain_db=0.000000 DB */
+	{0x18f, 0x100}, /* index 143, gain_db=13.406250 DB, again_db=13.406250 DB, dgain_db=0.000000 DB */
+	{0x18e, 0x100}, /* index 142, gain_db=13.312500 DB, again_db=13.312500 DB, dgain_db=0.000000 DB */
+	{0x18d, 0x100}, /* index 141, gain_db=13.218750 DB, again_db=13.218750 DB, dgain_db=0.000000 DB */
+	{0x18c, 0x100}, /* index 140, gain_db=13.125000 DB, again_db=13.125000 DB, dgain_db=0.000000 DB */
+	{0x18b, 0x100}, /* index 139, gain_db=13.031250 DB, again_db=13.031250 DB, dgain_db=0.000000 DB */
+	{0x18a, 0x100}, /* index 138, gain_db=12.937500 DB, again_db=12.937500 DB, dgain_db=0.000000 DB */
+	{0x189, 0x100}, /* index 137, gain_db=12.843750 DB, again_db=12.843750 DB, dgain_db=0.000000 DB */
+	{0x188, 0x100}, /* index 136, gain_db=12.750000 DB, again_db=12.750000 DB, dgain_db=0.000000 DB */
+	{0x187, 0x100}, /* index 135, gain_db=12.656250 DB, again_db=12.656250 DB, dgain_db=0.000000 DB */
+	{0x186, 0x100}, /* index 134, gain_db=12.562500 DB, again_db=12.562500 DB, dgain_db=0.000000 DB */
+	{0x185, 0x100}, /* index 133, gain_db=12.468750 DB, again_db=12.468750 DB, dgain_db=0.000000 DB */
+	{0x184, 0x100}, /* index 132, gain_db=12.375000 DB, again_db=12.375000 DB, dgain_db=0.000000 DB */
+	{0x183, 0x100}, /* index 131, gain_db=12.281250 DB, again_db=12.281250 DB, dgain_db=0.000000 DB */
+	{0x182, 0x100}, /* index 130, gain_db=12.187500 DB, again_db=12.187500 DB, dgain_db=0.000000 DB */
+	{0x181, 0x100}, /* index 129, gain_db=12.093750 DB, again_db=12.093750 DB, dgain_db=0.000000 DB */
+	{0x180, 0x100}, /* index 128, gain_db=12.000000 DB, again_db=12.000000 DB, dgain_db=0.000000 DB */
+	{0x17f, 0x100}, /* index 127, gain_db=11.906250 DB, again_db=11.906250 DB, dgain_db=0.000000 DB */
+	{0x17e, 0x100}, /* index 126, gain_db=11.812500 DB, again_db=11.812500 DB, dgain_db=0.000000 DB */
+	{0x17d, 0x100}, /* index 125, gain_db=11.718750 DB, again_db=11.718750 DB, dgain_db=0.000000 DB */
+	{0x17c, 0x100}, /* index 124, gain_db=11.625000 DB, again_db=11.625000 DB, dgain_db=0.000000 DB */
+	{0x17b, 0x100}, /* index 123, gain_db=11.531250 DB, again_db=11.531250 DB, dgain_db=0.000000 DB */
+	{0x17a, 0x100}, /* index 122, gain_db=11.437500 DB, again_db=11.437500 DB, dgain_db=0.000000 DB */
+	{0x179, 0x100}, /* index 121, gain_db=11.343750 DB, again_db=11.343750 DB, dgain_db=0.000000 DB */
+	{0x178, 0x100}, /* index 120, gain_db=11.250000 DB, again_db=11.250000 DB, dgain_db=0.000000 DB */
+	{0x177, 0x100}, /* index 119, gain_db=11.156250 DB, again_db=11.156250 DB, dgain_db=0.000000 DB */
+	{0x176, 0x100}, /* index 118, gain_db=11.062500 DB, again_db=11.062500 DB, dgain_db=0.000000 DB */
+	{0x175, 0x100}, /* index 117, gain_db=10.968750 DB, again_db=10.968750 DB, dgain_db=0.000000 DB */
+	{0x174, 0x100}, /* index 116, gain_db=10.875000 DB, again_db=10.875000 DB, dgain_db=0.000000 DB */
+	{0x173, 0x100}, /* index 115, gain_db=10.781250 DB, again_db=10.781250 DB, dgain_db=0.000000 DB */
+	{0x172, 0x100}, /* index 114, gain_db=10.687500 DB, again_db=10.687500 DB, dgain_db=0.000000 DB */
+	{0x171, 0x100}, /* index 113, gain_db=10.593750 DB, again_db=10.593750 DB, dgain_db=0.000000 DB */
+	{0x170, 0x100}, /* index 112, gain_db=10.500000 DB, again_db=10.500000 DB, dgain_db=0.000000 DB */
+	{0x16f, 0x100}, /* index 111, gain_db=10.406250 DB, again_db=10.406250 DB, dgain_db=0.000000 DB */
+	{0x16e, 0x100}, /* index 110, gain_db=10.312500 DB, again_db=10.312500 DB, dgain_db=0.000000 DB */
+	{0x16d, 0x100}, /* index 109, gain_db=10.218750 DB, again_db=10.218750 DB, dgain_db=0.000000 DB */
+	{0x16c, 0x100}, /* index 108, gain_db=10.125000 DB, again_db=10.125000 DB, dgain_db=0.000000 DB */
+	{0x16b, 0x100}, /* index 107, gain_db=10.031250 DB, again_db=10.031250 DB, dgain_db=0.000000 DB */
+	{0x16a, 0x100}, /* index 106, gain_db=9.937500 DB, again_db=9.937500 DB, dgain_db=0.000000 DB */
+	{0x169, 0x100}, /* index 105, gain_db=9.843750 DB, again_db=9.843750 DB, dgain_db=0.000000 DB */
+	{0x168, 0x100}, /* index 104, gain_db=9.750000 DB, again_db=9.750000 DB, dgain_db=0.000000 DB */
+	{0x167, 0x100}, /* index 103, gain_db=9.656250 DB, again_db=9.656250 DB, dgain_db=0.000000 DB */
+	{0x166, 0x100}, /* index 102, gain_db=9.562500 DB, again_db=9.562500 DB, dgain_db=0.000000 DB */
+	{0x165, 0x100}, /* index 101, gain_db=9.468750 DB, again_db=9.468750 DB, dgain_db=0.000000 DB */
+	{0x164, 0x100}, /* index 100, gain_db=9.375000 DB, again_db=9.375000 DB, dgain_db=0.000000 DB */
+	{0x163, 0x100}, /* index 99, gain_db=9.281250 DB, again_db=9.281250 DB, dgain_db=0.000000 DB */
+	{0x162, 0x100}, /* index 98, gain_db=9.187500 DB, again_db=9.187500 DB, dgain_db=0.000000 DB */
+	{0x161, 0x100}, /* index 97, gain_db=9.093750 DB, again_db=9.093750 DB, dgain_db=0.000000 DB */
+	{0x160, 0x100}, /* index 96, gain_db=9.000000 DB, again_db=9.000000 DB, dgain_db=0.000000 DB */
+	{0x15f, 0x100}, /* index 95, gain_db=8.906250 DB, again_db=8.906250 DB, dgain_db=0.000000 DB */
+	{0x15e, 0x100}, /* index 94, gain_db=8.812500 DB, again_db=8.812500 DB, dgain_db=0.000000 DB */
+	{0x15d, 0x100}, /* index 93, gain_db=8.718750 DB, again_db=8.718750 DB, dgain_db=0.000000 DB */
+	{0x15c, 0x100}, /* index 92, gain_db=8.625000 DB, again_db=8.625000 DB, dgain_db=0.000000 DB */
+	{0x15b, 0x100}, /* index 91, gain_db=8.531250 DB, again_db=8.531250 DB, dgain_db=0.000000 DB */
+	{0x15a, 0x100}, /* index 90, gain_db=8.437500 DB, again_db=8.437500 DB, dgain_db=0.000000 DB */
+	{0x159, 0x100}, /* index 89, gain_db=8.343750 DB, again_db=8.343750 DB, dgain_db=0.000000 DB */
+	{0x158, 0x100}, /* index 88, gain_db=8.250000 DB, again_db=8.250000 DB, dgain_db=0.000000 DB */
+	{0x157, 0x100}, /* index 87, gain_db=8.156250 DB, again_db=8.156250 DB, dgain_db=0.000000 DB */
+	{0x156, 0x100}, /* index 86, gain_db=8.062500 DB, again_db=8.062500 DB, dgain_db=0.000000 DB */
+	{0x155, 0x100}, /* index 85, gain_db=7.968750 DB, again_db=7.968750 DB, dgain_db=0.000000 DB */
+	{0x154, 0x100}, /* index 84, gain_db=7.875000 DB, again_db=7.875000 DB, dgain_db=0.000000 DB */
+	{0x153, 0x100}, /* index 83, gain_db=7.781250 DB, again_db=7.781250 DB, dgain_db=0.000000 DB */
+	{0x152, 0x100}, /* index 82, gain_db=7.687500 DB, again_db=7.687500 DB, dgain_db=0.000000 DB */
+	{0x151, 0x100}, /* index 81, gain_db=7.593750 DB, again_db=7.593750 DB, dgain_db=0.000000 DB */
+	{0x150, 0x100}, /* index 80, gain_db=7.500000 DB, again_db=7.500000 DB, dgain_db=0.000000 DB */
+	{0x14f, 0x100}, /* index 79, gain_db=7.406250 DB, again_db=7.406250 DB, dgain_db=0.000000 DB */
+	{0x14e, 0x100}, /* index 78, gain_db=7.312500 DB, again_db=7.312500 DB, dgain_db=0.000000 DB */
+	{0x14d, 0x100}, /* index 77, gain_db=7.218750 DB, again_db=7.218750 DB, dgain_db=0.000000 DB */
+	{0x14c, 0x100}, /* index 76, gain_db=7.125000 DB, again_db=7.125000 DB, dgain_db=0.000000 DB */
+	{0x14b, 0x100}, /* index 75, gain_db=7.031250 DB, again_db=7.031250 DB, dgain_db=0.000000 DB */
+	{0x14a, 0x100}, /* index 74, gain_db=6.937500 DB, again_db=6.937500 DB, dgain_db=0.000000 DB */
+	{0x149, 0x100}, /* index 73, gain_db=6.843750 DB, again_db=6.843750 DB, dgain_db=0.000000 DB */
+	{0x148, 0x100}, /* index 72, gain_db=6.750000 DB, again_db=6.750000 DB, dgain_db=0.000000 DB */
+	{0x147, 0x100}, /* index 71, gain_db=6.656250 DB, again_db=6.656250 DB, dgain_db=0.000000 DB */
+	{0x146, 0x100}, /* index 70, gain_db=6.562500 DB, again_db=6.562500 DB, dgain_db=0.000000 DB */
+	{0x145, 0x100}, /* index 69, gain_db=6.468750 DB, again_db=6.468750 DB, dgain_db=0.000000 DB */
+	{0x144, 0x100}, /* index 68, gain_db=6.375000 DB, again_db=6.375000 DB, dgain_db=0.000000 DB */
+	{0x143, 0x100}, /* index 67, gain_db=6.281250 DB, again_db=6.281250 DB, dgain_db=0.000000 DB */
+	{0x142, 0x100}, /* index 66, gain_db=6.187500 DB, again_db=6.187500 DB, dgain_db=0.000000 DB */
+	{0x141, 0x100}, /* index 65, gain_db=6.093750 DB, again_db=6.093750 DB, dgain_db=0.000000 DB */
+	{0x140, 0x100}, /* index 64, gain_db=6.000000 DB, again_db=6.000000 DB, dgain_db=0.000000 DB */
+	{0x13f, 0x100}, /* index 63, gain_db=5.906250 DB, again_db=5.906250 DB, dgain_db=0.000000 DB */
+	{0x13e, 0x100}, /* index 62, gain_db=5.812500 DB, again_db=5.812500 DB, dgain_db=0.000000 DB */
+	{0x13d, 0x100}, /* index 61, gain_db=5.718750 DB, again_db=5.718750 DB, dgain_db=0.000000 DB */
+	{0x13c, 0x100}, /* index 60, gain_db=5.625000 DB, again_db=5.625000 DB, dgain_db=0.000000 DB */
+	{0x13b, 0x100}, /* index 59, gain_db=5.531250 DB, again_db=5.531250 DB, dgain_db=0.000000 DB */
+	{0x13a, 0x100}, /* index 58, gain_db=5.437500 DB, again_db=5.437500 DB, dgain_db=0.000000 DB */
+	{0x139, 0x100}, /* index 57, gain_db=5.343750 DB, again_db=5.343750 DB, dgain_db=0.000000 DB */
+	{0x138, 0x100}, /* index 56, gain_db=5.250000 DB, again_db=5.250000 DB, dgain_db=0.000000 DB */
+	{0x137, 0x100}, /* index 55, gain_db=5.156250 DB, again_db=5.156250 DB, dgain_db=0.000000 DB */
+	{0x136, 0x100}, /* index 54, gain_db=5.062500 DB, again_db=5.062500 DB, dgain_db=0.000000 DB */
+	{0x135, 0x100}, /* index 53, gain_db=4.968750 DB, again_db=4.968750 DB, dgain_db=0.000000 DB */
+	{0x134, 0x100}, /* index 52, gain_db=4.875000 DB, again_db=4.875000 DB, dgain_db=0.000000 DB */
+	{0x133, 0x100}, /* index 51, gain_db=4.781250 DB, again_db=4.781250 DB, dgain_db=0.000000 DB */
+	{0x132, 0x100}, /* index 50, gain_db=4.687500 DB, again_db=4.687500 DB, dgain_db=0.000000 DB */
+	{0x131, 0x100}, /* index 49, gain_db=4.593750 DB, again_db=4.593750 DB, dgain_db=0.000000 DB */
+	{0x130, 0x100}, /* index 48, gain_db=4.500000 DB, again_db=4.500000 DB, dgain_db=0.000000 DB */
+	{0x12f, 0x100}, /* index 47, gain_db=4.406250 DB, again_db=4.406250 DB, dgain_db=0.000000 DB */
+	{0x12e, 0x100}, /* index 46, gain_db=4.312500 DB, again_db=4.312500 DB, dgain_db=0.000000 DB */
+	{0x12d, 0x100}, /* index 45, gain_db=4.218750 DB, again_db=4.218750 DB, dgain_db=0.000000 DB */
+	{0x12c, 0x100}, /* index 44, gain_db=4.125000 DB, again_db=4.125000 DB, dgain_db=0.000000 DB */
+	{0x12b, 0x100}, /* index 43, gain_db=4.031250 DB, again_db=4.031250 DB, dgain_db=0.000000 DB */
+	{0x12a, 0x100}, /* index 42, gain_db=3.937500 DB, again_db=3.937500 DB, dgain_db=0.000000 DB */
+	{0x129, 0x100}, /* index 41, gain_db=3.843750 DB, again_db=3.843750 DB, dgain_db=0.000000 DB */
+	{0x128, 0x100}, /* index 40, gain_db=3.750000 DB, again_db=3.750000 DB, dgain_db=0.000000 DB */
+	{0x127, 0x100}, /* index 39, gain_db=3.656250 DB, again_db=3.656250 DB, dgain_db=0.000000 DB */
+	{0x126, 0x100}, /* index 38, gain_db=3.562500 DB, again_db=3.562500 DB, dgain_db=0.000000 DB */
+	{0x125, 0x100}, /* index 37, gain_db=3.468750 DB, again_db=3.468750 DB, dgain_db=0.000000 DB */
+	{0x124, 0x100}, /* index 36, gain_db=3.375000 DB, again_db=3.375000 DB, dgain_db=0.000000 DB */
+	{0x123, 0x100}, /* index 35, gain_db=3.281250 DB, again_db=3.281250 DB, dgain_db=0.000000 DB */
+	{0x122, 0x100}, /* index 34, gain_db=3.187500 DB, again_db=3.187500 DB, dgain_db=0.000000 DB */
+	{0x121, 0x100}, /* index 33, gain_db=3.093750 DB, again_db=3.093750 DB, dgain_db=0.000000 DB */
+	{0x120, 0x100}, /* index 32, gain_db=3.000000 DB, again_db=3.000000 DB, dgain_db=0.000000 DB */
+	{0x11f, 0x100}, /* index 31, gain_db=2.906250 DB, again_db=2.906250 DB, dgain_db=0.000000 DB */
+	{0x11e, 0x100}, /* index 30, gain_db=2.812500 DB, again_db=2.812500 DB, dgain_db=0.000000 DB */
+	{0x11d, 0x100}, /* index 29, gain_db=2.718750 DB, again_db=2.718750 DB, dgain_db=0.000000 DB */
+	{0x11c, 0x100}, /* index 28, gain_db=2.625000 DB, again_db=2.625000 DB, dgain_db=0.000000 DB */
+	{0x11b, 0x100}, /* index 27, gain_db=2.531250 DB, again_db=2.531250 DB, dgain_db=0.000000 DB */
+	{0x11a, 0x100}, /* index 26, gain_db=2.437500 DB, again_db=2.437500 DB, dgain_db=0.000000 DB */
+	{0x119, 0x100}, /* index 25, gain_db=2.343750 DB, again_db=2.343750 DB, dgain_db=0.000000 DB */
+	{0x118, 0x100}, /* index 24, gain_db=2.250000 DB, again_db=2.250000 DB, dgain_db=0.000000 DB */
+	{0x117, 0x100}, /* index 23, gain_db=2.156250 DB, again_db=2.156250 DB, dgain_db=0.000000 DB */
+	{0x116, 0x100}, /* index 22, gain_db=2.062500 DB, again_db=2.062500 DB, dgain_db=0.000000 DB */
+	{0x115, 0x100}, /* index 21, gain_db=1.968750 DB, again_db=1.968750 DB, dgain_db=0.000000 DB */
+	{0x114, 0x100}, /* index 20, gain_db=1.875000 DB, again_db=1.875000 DB, dgain_db=0.000000 DB */
+	{0x113, 0x100}, /* index 19, gain_db=1.781250 DB, again_db=1.781250 DB, dgain_db=0.000000 DB */
+	{0x112, 0x100}, /* index 18, gain_db=1.687500 DB, again_db=1.687500 DB, dgain_db=0.000000 DB */
+	{0x111, 0x100}, /* index 17, gain_db=1.593750 DB, again_db=1.593750 DB, dgain_db=0.000000 DB */
+	{0x110, 0x100}, /* index 16, gain_db=1.500000 DB, again_db=1.500000 DB, dgain_db=0.000000 DB */
+	{0x10f, 0x100}, /* index 15, gain_db=1.406250 DB, again_db=1.406250 DB, dgain_db=0.000000 DB */
+	{0x10e, 0x100}, /* index 14, gain_db=1.312500 DB, again_db=1.312500 DB, dgain_db=0.000000 DB */
+	{0x10d, 0x100}, /* index 13, gain_db=1.218750 DB, again_db=1.218750 DB, dgain_db=0.000000 DB */
+	{0x10c, 0x100}, /* index 12, gain_db=1.125000 DB, again_db=1.125000 DB, dgain_db=0.000000 DB */
+	{0x10b, 0x100}, /* index 11, gain_db=1.031250 DB, again_db=1.031250 DB, dgain_db=0.000000 DB */
+	{0x10a, 0x100}, /* index 10, gain_db=0.937500 DB, again_db=0.937500 DB, dgain_db=0.000000 DB */
+	{0x109, 0x100}, /* index 9, gain_db=0.843750 DB, again_db=0.843750 DB, dgain_db=0.000000 DB */
+	{0x108, 0x100}, /* index 8, gain_db=0.750000 DB, again_db=0.750000 DB, dgain_db=0.000000 DB */
+	{0x107, 0x100}, /* index 7, gain_db=0.656250 DB, again_db=0.656250 DB, dgain_db=0.000000 DB */
+	{0x106, 0x100}, /* index 6, gain_db=0.562500 DB, again_db=0.562500 DB, dgain_db=0.000000 DB */
+	{0x105, 0x100}, /* index 5, gain_db=0.468750 DB, again_db=0.468750 DB, dgain_db=0.000000 DB */
+	{0x104, 0x100}, /* index 4, gain_db=0.375000 DB, again_db=0.375000 DB, dgain_db=0.000000 DB */
+	{0x103, 0x100}, /* index 3, gain_db=0.281250 DB, again_db=0.281250 DB, dgain_db=0.000000 DB */
+	{0x102, 0x100}, /* index 2, gain_db=0.187500 DB, again_db=0.187500 DB, dgain_db=0.000000 DB */
+	{0x101, 0x100}, /* index 1, gain_db=0.093750 DB, again_db=0.093750 DB, dgain_db=0.000000 DB */
+	{0x100, 0x100}, /* index 0, gain_db=0.000000 DB, again_db=0.000000 DB, dgain_db=0.000000 DB */
+};
+#endif
diff --git a/drivers/vin/sensors/sony_imx185/Kbuild b/drivers/vin/sensors/sony_imx185/Kbuild
new file mode 100644
index 0000000..791d236
--- /dev/null
+++ b/drivers/vin/sensors/sony_imx185/Kbuild
@@ -0,0 +1,37 @@
+##
+## Kbuild
+##
+## History:
+##    2015/01/09 - [Hao Zeng] Create
+##
+## Copyright (c) 2015 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+EXTRA_CFLAGS		+= $(AMBARELLA_DRV_CFLAGS)
+EXTRA_AFLAGS		+= $(AMBARELLA_DRV_AFLAGS)
+EXTRA_LDFLAGS		+= $(AMBARELLA_DRV_LDFLAGS)
+
+obj-m := imx185.o
+
diff --git a/drivers/vin/sensors/sony_imx185/imx185.c b/drivers/vin/sensors/sony_imx185/imx185.c
new file mode 100644
index 0000000..0d0b335
--- /dev/null
+++ b/drivers/vin/sensors/sony_imx185/imx185.c
@@ -0,0 +1,501 @@
+/*
+ * kernel/private/drivers/ambarella/vin/sensors/sony_imx185/imx185.c
+ *
+ * History:
+ *    2015/01/09 - [Hao Zeng] Create
+ *
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/ambpriv_device.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <iav_utils.h>
+#include <vin_api.h>
+#include "imx185.h"
+
+static int bus_addr = (0 << 16) | (0x34 >> 1);
+module_param(bus_addr, int, 0644);
+MODULE_PARM_DESC(bus_addr, " bus and addr: bit16~bit31: bus, bit0~bit15: addr");
+
+struct imx185_priv {
+	void *control_data;
+	u32 frame_length_lines;
+	u32 line_length;
+};
+
+#include "imx185_table.c"
+
+static int imx185_write_reg( struct vin_device *vdev, u32 subaddr, u32 data)
+{
+	int rval;
+	struct imx185_priv *imx185;
+	struct i2c_client *client;
+	struct i2c_msg msgs[1];
+	u8 pbuf[3];
+
+	imx185 = (struct imx185_priv *)vdev->priv;
+	client = imx185->control_data;
+
+	pbuf[0] = (subaddr & 0xff00) >> 8;
+	pbuf[1] = subaddr & 0xff;
+	pbuf[2] = data;
+
+	msgs[0].len = 3;
+	msgs[0].addr = client->addr;
+	if (unlikely(subaddr == IMX185_SWRESET))
+		msgs[0].flags = client->flags | I2C_M_IGNORE_NAK;
+	else
+		msgs[0].flags = client->flags;
+	msgs[0].buf = pbuf;
+
+	rval = i2c_transfer(client->adapter, msgs, 1);
+	if (rval < 0) {
+		vin_error("failed(%d): [0x%x:0x%x]\n", rval, subaddr, data);
+		return rval;
+	}
+
+	return 0;
+}
+
+static int imx185_read_reg( struct vin_device *vdev, u32 subaddr, u32 *data)
+{
+	int rval = 0;
+	struct imx185_priv *imx185;
+	struct i2c_client *client;
+	struct i2c_msg msgs[2];
+	u8 pbuf0[2];
+	u8 pbuf[1];
+
+	imx185 = (struct imx185_priv *)vdev->priv;
+	client = imx185->control_data;
+
+	pbuf0[0] = (subaddr &0xff00) >> 8;
+	pbuf0[1] = subaddr & 0xff;
+
+	msgs[0].len = 2;
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].buf = pbuf0;
+
+	msgs[1].addr = client->addr;
+	msgs[1].flags = client->flags | I2C_M_RD;
+	msgs[1].buf = pbuf;
+	msgs[1].len = 1;
+
+	rval = i2c_transfer(client->adapter, msgs, 2);
+	if (rval < 0){
+		vin_error("failed(%d): [0x%x]\n", rval, subaddr);
+		return rval;
+	}
+
+	*data = pbuf[0];
+
+	return 0;
+}
+
+static int imx185_set_vin_mode(struct vin_device *vdev, struct vin_video_format *format)
+{
+	struct vin_device_config imx185_config;
+
+	memset(&imx185_config, 0, sizeof (imx185_config));
+
+	imx185_config.interface_type = SENSOR_SERIAL_LVDS;
+	imx185_config.sync_mode = SENSOR_SYNC_MODE_MASTER;
+
+	imx185_config.slvds_cfg.lane_number = SENSOR_4_LANE;
+	imx185_config.slvds_cfg.sync_code_style = SENSOR_SYNC_STYLE_SONY;
+
+	imx185_config.cap_win.x = format->def_start_x;
+	imx185_config.cap_win.y = format->def_start_y;
+	imx185_config.cap_win.width = format->def_width;
+	imx185_config.cap_win.height = format->def_height;
+
+	imx185_config.sensor_id = GENERIC_SENSOR;
+	imx185_config.input_format = AMBA_VIN_INPUT_FORMAT_RGB_RAW;
+	imx185_config.bayer_pattern = format->bayer_pattern;
+	imx185_config.video_format = format->format;
+	imx185_config.bit_resolution = format->bits;
+
+	return ambarella_set_vin_config(vdev, &imx185_config);
+}
+
+static void imx185_sw_reset(struct vin_device *vdev)
+{
+	imx185_write_reg(vdev, IMX185_STANDBY, 0x01);	/* STANDBY */
+	imx185_write_reg(vdev, IMX185_SWRESET, 0x01);
+	msleep(10);
+}
+
+static void imx185_start_streaming(struct vin_device *vdev)
+{
+	imx185_write_reg(vdev, IMX185_XMSTA, 0x00);	/* master mode start */
+	imx185_write_reg(vdev, IMX185_STANDBY, 0x00);	/* cancel standby */
+}
+
+static int imx185_init_device(struct vin_device *vdev)
+{
+	struct vin_reg_16_8 *regs;
+	int i, regs_num;
+
+	imx185_sw_reset(vdev);
+
+	regs = imx185_share_regs;
+	regs_num = ARRAY_SIZE(imx185_share_regs);
+
+	for (i = 0; i < regs_num; i++)
+		imx185_write_reg(vdev, regs[i].addr, regs[i].data);
+
+	return 0;
+}
+
+static int imx185_set_pll(struct vin_device *vdev, int pll_idx)
+{
+	struct vin_reg_16_8 *regs;
+	int i, regs_num;
+
+	regs = imx185_pll_regs[pll_idx];
+	regs_num = ARRAY_SIZE(imx185_pll_regs[pll_idx]);
+
+	for (i = 0; i < regs_num; i++)
+		imx185_write_reg(vdev, regs[i].addr, regs[i].data);
+
+	return 0;
+}
+
+static int imx185_update_hv_info(struct vin_device *vdev)
+{
+	u32 val_high, val_mid, val_low;
+	struct imx185_priv *pinfo = (struct imx185_priv *)vdev->priv;
+
+	imx185_read_reg(vdev, IMX185_HMAX_MSB, &val_high);
+	imx185_read_reg(vdev, IMX185_HMAX_LSB, &val_low);
+	pinfo->line_length = (val_high << 8) + val_low;
+	if(unlikely(!pinfo->line_length)) {
+		vin_error("line length is 0!\n");
+		return -EIO;
+	}
+
+	imx185_read_reg(vdev, IMX185_VMAX_HSB, &val_high);
+	imx185_read_reg(vdev, IMX185_VMAX_MSB, &val_mid);
+	imx185_read_reg(vdev, IMX185_VMAX_LSB, &val_low);
+	pinfo->frame_length_lines = ((val_high & 0x01) << 16) + (val_mid << 8) + val_low;
+
+	return 0;
+}
+
+static int imx185_get_line_time(struct vin_device *vdev)
+{
+	u64 h_clks;
+	struct imx185_priv *pinfo = (struct imx185_priv *)vdev->priv;
+
+	h_clks = (u64)pinfo->line_length * 512000000;
+	h_clks = DIV64_CLOSEST(h_clks, vdev->cur_pll->pixelclk);
+
+	vdev->cur_format->line_time = (u32)h_clks;
+
+	return 0;
+}
+
+static int imx185_set_format(struct vin_device *vdev, struct vin_video_format *format)
+{
+	struct vin_reg_16_8 *regs;
+	int i, regs_num, rval;
+
+	regs = imx185_mode_regs[format->device_mode];
+	regs_num = ARRAY_SIZE(imx185_mode_regs[format->device_mode]);
+
+	for (i = 0; i < regs_num; i++)
+		imx185_write_reg(vdev, regs[i].addr, regs[i].data);
+
+	rval = imx185_update_hv_info(vdev);
+	if (rval < 0)
+		return rval;
+
+	imx185_get_line_time(vdev);
+
+	/* TG reset release ( Enable Streaming ) */
+	imx185_start_streaming(vdev);
+
+	/* communiate with IAV */
+	rval = imx185_set_vin_mode(vdev, format);
+	if (rval < 0)
+		return rval;
+
+	return 0;
+}
+
+static int imx185_set_shutter_row(struct vin_device *vdev, u32 row)
+{
+	u32 blank_lines;
+	u64 exposure_lines;
+	u32 num_line, max_line, min_line;
+	struct imx185_priv *pinfo = (struct imx185_priv *)vdev->priv;
+
+	num_line = row;
+
+	/* FIXME: shutter width: 1 ~ (Frame format(V) - 1) */
+	min_line = 1;
+	max_line = pinfo->frame_length_lines - 1;
+	num_line = clamp(num_line, min_line, max_line);
+
+	/* get the shutter sweep time */
+	blank_lines = pinfo->frame_length_lines - num_line - 1;
+	imx185_write_reg(vdev, IMX185_SHS1_HSB, blank_lines >> 16);
+	imx185_write_reg(vdev, IMX185_SHS1_MSB, blank_lines >> 8);
+	imx185_write_reg(vdev, IMX185_SHS1_LSB, blank_lines & 0xff);
+
+	exposure_lines = num_line;
+	exposure_lines = exposure_lines * (u64)pinfo->line_length * 512000000;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, vdev->cur_pll->pixelclk);
+
+	vdev->shutter_time = (u32)exposure_lines;
+	vin_debug("shutter_time:%d, row:%d\n", vdev->shutter_time, num_line);
+
+	return 0;
+}
+
+static int imx185_shutter2row(struct vin_device *vdev, u32* shutter_time)
+{
+	u64 exposure_lines;
+	int rval = 0;
+	struct imx185_priv *pinfo = (struct imx185_priv *)vdev->priv;
+
+	/* for fast boot, it may call set shutter time directly, so we must read line length/frame line */
+	if(unlikely(!pinfo->line_length)) {
+		rval = imx185_update_hv_info(vdev);
+		if (rval < 0)
+			return rval;
+	}
+
+	exposure_lines = (*shutter_time) * (u64)vdev->cur_pll->pixelclk;
+	exposure_lines = DIV64_CLOSEST(exposure_lines, pinfo->line_length);
+	exposure_lines = DIV64_CLOSEST(exposure_lines, 512000000);
+
+	*shutter_time = exposure_lines;
+
+	return rval;
+}
+
+static int imx185_set_fps( struct vin_device *vdev, int fps)
+{
+	u64 v_lines, vb_time;
+	struct imx185_priv *pinfo = (struct imx185_priv *)vdev->priv;
+
+	v_lines = fps * (u64)vdev->cur_pll->pixelclk;
+	v_lines = DIV64_CLOSEST(v_lines, pinfo->line_length);
+	v_lines = DIV64_CLOSEST(v_lines, 512000000);
+
+	imx185_write_reg(vdev, IMX185_VMAX_HSB, (v_lines >> 16) & 0x01);
+	imx185_write_reg(vdev, IMX185_VMAX_MSB, (v_lines >> 8) & 0xFF);
+	imx185_write_reg(vdev, IMX185_VMAX_LSB, v_lines & 0xFF);
+
+	pinfo->frame_length_lines = (u32)v_lines;
+
+	vb_time = pinfo->line_length * (u64)(v_lines - vdev->cur_format->height) * 1000000000;
+	vb_time = DIV64_CLOSEST(vb_time, vdev->cur_pll->pixelclk);
+	vdev->cur_format->vb_time = vb_time;
+
+	return 0;
+}
+
+static int imx185_set_agc_index( struct vin_device *vdev, int agc_idx)
+{
+	if (agc_idx > IMX185_GAIN_MAX_DB) {
+		vin_warn("agc index %d exceeds maximum %d\n", agc_idx, IMX185_GAIN_MAX_DB);
+		agc_idx = IMX185_GAIN_MAX_DB;
+	}
+
+	imx185_write_reg(vdev, IMX185_AGAIN, (u8)(agc_idx&0xFF));
+
+	return 0;
+}
+
+static int imx185_set_mirror_mode(struct vin_device *vdev,
+		struct vindev_mirror *mirror_mode)
+{
+	u32 tmp_reg, readmode, bayer_pattern;
+
+	switch (mirror_mode->pattern) {
+	case VINDEV_MIRROR_AUTO:
+		return 0;
+
+	case VINDEV_MIRROR_HORRIZONTALLY_VERTICALLY:
+		readmode = IMX185_H_MIRROR | IMX185_V_FLIP;
+		bayer_pattern = VINDEV_BAYER_PATTERN_RG;
+		break;
+
+	case VINDEV_MIRROR_HORRIZONTALLY:
+		readmode = IMX185_H_MIRROR;
+		bayer_pattern = VINDEV_BAYER_PATTERN_RG;
+		break;
+
+	case VINDEV_MIRROR_VERTICALLY:
+		readmode = IMX185_V_FLIP;
+		bayer_pattern = VINDEV_BAYER_PATTERN_RG;
+		break;
+
+	case VINDEV_MIRROR_NONE:
+		readmode = 0;
+		bayer_pattern = VINDEV_BAYER_PATTERN_RG;
+		break;
+
+	default:
+		vin_error("do not support cmd mirror mode\n");
+		return -EINVAL;
+	}
+
+	imx185_read_reg(vdev, IMX185_WINMODE, &tmp_reg);
+	tmp_reg &= ~(IMX185_H_MIRROR | IMX185_V_FLIP);
+	tmp_reg |= readmode;
+	imx185_write_reg(vdev, IMX185_WINMODE, tmp_reg);
+
+	if (mirror_mode->bayer_pattern == VINDEV_BAYER_PATTERN_AUTO)
+		mirror_mode->bayer_pattern = bayer_pattern;
+
+	return 0;
+}
+
+static struct vin_ops imx185_ops = {
+	.init_device		= imx185_init_device,
+	.set_format		= imx185_set_format,
+	.set_pll			= imx185_set_pll,
+	.set_shutter_row	= imx185_set_shutter_row,
+	.shutter2row		= imx185_shutter2row,
+	.set_frame_rate	= imx185_set_fps,
+	.set_agc_index		= imx185_set_agc_index,
+	.set_mirror_mode	= imx185_set_mirror_mode,
+	.read_reg		= imx185_read_reg,
+	.write_reg		= imx185_write_reg,
+};
+
+/*	< include init.c here for aptina sensor, which is produce by perl >  */
+/* ========================================================================== */
+static int imx185_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	int rval = 0;
+	struct vin_device *vdev;
+	struct imx185_priv *imx185;
+
+	vdev = ambarella_vin_create_device(client->name,
+		SENSOR_IMX185, sizeof(struct imx185_priv));
+
+	if (!vdev)
+		return -ENOMEM;
+
+	vdev->intf_id = 0;
+	vdev->dev_type = VINDEV_TYPE_SENSOR;
+	vdev->sub_type = VINDEV_SUBTYPE_CMOS;
+	vdev->default_mode = AMBA_VIDEO_MODE_1080P;
+	vdev->frame_rate = AMBA_VIDEO_FPS_29_97;
+	vdev->agc_db_max = 0x30000000;	/*  48dB */
+	vdev->agc_db_min = 0x00000000;	/*  0dB */
+	vdev->agc_db_step = 0x004CCCCC;	/*  0.3dB */
+
+	i2c_set_clientdata(client, vdev);
+
+	imx185 = (struct imx185_priv *)vdev->priv;
+	imx185->control_data = client;
+
+	rval = ambarella_vin_register_device(vdev, &imx185_ops,
+		imx185_formats, ARRAY_SIZE(imx185_formats),
+		imx185_plls, ARRAY_SIZE(imx185_plls));
+
+	if (rval < 0)
+		goto imx185_probe_err;
+
+	vin_info("IMX185 init(4-lane lvds)\n");
+
+	return 0;
+
+imx185_probe_err:
+	ambarella_vin_free_device(vdev);
+	return rval;
+}
+
+static int imx185_remove(struct i2c_client *client)
+{
+	struct vin_device *vdev;
+
+	vdev = (struct vin_device *)i2c_get_clientdata(client);
+	ambarella_vin_unregister_device(vdev);
+	ambarella_vin_free_device(vdev);
+
+	return 0;
+}
+
+static const struct i2c_device_id imx185_idtable[] = {
+	{ "imx185", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, imx185_idtable);
+
+static struct i2c_driver i2c_driver_imx185 = {
+	.driver = {
+		.name	= "imx185",
+	},
+
+	.id_table	= imx185_idtable,
+	.probe		= imx185_probe,
+	.remove		= imx185_remove,
+
+};
+
+static int __init imx185_init(void)
+{
+	int bus, addr, rval;
+
+	bus = bus_addr >> 16;
+	addr = bus_addr & 0xffff;
+
+	rval = ambpriv_i2c_update_addr("imx185", bus, addr);
+	if (rval < 0)
+		return rval;
+
+	rval = i2c_add_driver(&i2c_driver_imx185);
+	if (rval < 0)
+		return rval;
+
+	return 0;
+}
+
+static void __exit imx185_exit(void)
+{
+	i2c_del_driver(&i2c_driver_imx185);
+}
+
+module_init(imx185_init);
+module_exit(imx185_exit);
+
+MODULE_DESCRIPTION("IMX185 1/1.9 -Inch, 1920x1200, 2.31-Megapixel CMOS Digital Image Sensor");
+MODULE_AUTHOR("Hao Zeng, <haozeng@ambarella.com>");
+MODULE_LICENSE("Proprietary");
+
diff --git a/drivers/vin/sensors/sony_imx185/imx185.h b/drivers/vin/sensors/sony_imx185/imx185.h
new file mode 100644
index 0000000..dad6620
--- /dev/null
+++ b/drivers/vin/sensors/sony_imx185/imx185.h
@@ -0,0 +1,75 @@
+/*
+ * kernel/private/drivers/ambarella/vin/sensors/sony_imx185/imx185_pri.h
+ *
+ * History:
+ *    2015/01/09 - [Hao Zeng] Create
+ *
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+
+#ifndef __IMX185_PRI_H__
+#define __IMX185_PRI_H__
+
+#define IMX185_STANDBY			0x3000
+#define IMX185_REGHOLD			0x3001
+#define IMX185_XMSTA				0x3002
+#define IMX185_SWRESET			0x3003
+
+#define IMX185_ADBIT				0x3005
+#define IMX185_MODE				0x3006
+#define IMX185_WINMODE			0x3007
+
+#define IMX185_FRSEL				0x3009
+#define IMX185_BLKLEVEL_LSB		0X300A
+#define IMX185_BLKLEVEL_MSB		0x300B
+
+#define IMX185_AGAIN				0x3014
+
+#define IMX185_VMAX_LSB			0x3018
+#define IMX185_VMAX_MSB			0x3019
+#define IMX185_VMAX_HSB			0x301A
+#define IMX185_HMAX_LSB			0x301B
+#define IMX185_HMAX_MSB			0x301C
+
+#define IMX185_SHS1_LSB			0x3020
+#define IMX185_SHS1_MSB			0x3021
+#define IMX185_SHS1_HSB			0x3022
+
+#define IMX185_ODBIT				0x3044
+
+#define IMX185_INCKSEL1			0x305C
+#define IMX185_INCKSEL2			0x305D
+#define IMX185_INCKSEL3			0x305E
+#define IMX185_INCKSEL4			0x305F
+#define IMX185_INCKSEL5			0x3063
+
+#define IMX185_V_FLIP				(1<<0)
+#define IMX185_H_MIRROR			(1<<1)
+
+#endif /* __IMX185_PRI_H__ */
+
diff --git a/drivers/vin/sensors/sony_imx185/imx185_table.c b/drivers/vin/sensors/sony_imx185/imx185_table.c
new file mode 100644
index 0000000..8fc8dd8
--- /dev/null
+++ b/drivers/vin/sensors/sony_imx185/imx185_table.c
@@ -0,0 +1,267 @@
+/*
+ * kernel/private/drivers/ambarella/vin/sensors/sony_imx185/imx185_table.c
+ *
+ * History:
+ *    2015/01/09 - [Hao Zeng] Create
+ *
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+static struct vin_video_pll imx185_plls[] = {
+	{0, 37125000, 74250000},
+};
+
+static struct vin_reg_16_8 imx185_pll_regs[][6] = {
+	{
+		{IMX185_INCKSEL1, 0x20},
+		{IMX185_INCKSEL2, 0x00},
+		{IMX185_INCKSEL3, 0x18},
+		{IMX185_INCKSEL4, 0x00},
+		{IMX185_INCKSEL5, 0x74},
+	},
+};
+
+static struct vin_reg_16_8 imx185_mode_regs[][12] = {
+	{	/* 1920x1200(12bits)@50fps */
+		{0x3005, 0x01}, /* ADBIT */
+		{0x3006, 0x00}, /* MODE */
+		{0x3007, 0x00}, /* WINMODE WUXGA MODE */
+		{0x3009, 0x01}, /* FRSEL */
+		{0x3018, 0x28}, /* VMAX_LSB */
+		{0x3019, 0x05}, /* VMAX_MSB */
+		{0x301A, 0x00}, /* VMAX_HSB */
+		{0x301B, 0x65}, /* HMAX_LSB */
+		{0x301C, 0x04}, /* HMAX_MSB */
+		{0x3044, 0xE1}, /* ODBIT_OPORTSEL, 12bits */
+		{0x300A, 0xF0}, /* BLKLEVEL_LSB */
+		{0x300B, 0x00}, /* BLKLEVEL_MSB */
+	},
+	{	/* 1920x1080(12bits)@60fps */
+		{0x3005, 0x01}, /* ADBIT */
+		{0x3006, 0x00}, /* MODE */
+		{0x3007, 0x10}, /* WINMODE 1080P MODE */
+		{0x3009, 0x01}, /* FRSEL */
+		{0x3018, 0x65}, /* VMAX_LSB */
+		{0x3019, 0x04}, /* VMAX_MSB */
+		{0x301A, 0x00}, /* VMAX_HSB */
+		{0x301B, 0x4C}, /* HMAX_LSB */
+		{0x301C, 0x04}, /* HMAX_MSB */
+		{0x3044, 0xE1}, /* ODBIT_OPORTSEL, 12bits */
+		{0x300A, 0xF0}, /* BLKLEVEL_LSB */
+		{0x300B, 0x00}, /* BLKLEVEL_MSB */
+	},
+	{	/* 1280x720(10bits)@120fps */
+		{0x3005, 0x00}, /* ADBIT */
+		{0x3006, 0x00}, /* MODE */
+		{0x3007, 0x20}, /* WINMODE 720P MODE */
+		{0x3009, 0x00}, /* FRSEL */
+		{0x3018, 0xEE}, /* VMAX_LSB */
+		{0x3019, 0x02}, /* VMAX_MSB */
+		{0x301A, 0x00}, /* VMAX_HSB */
+		{0x301B, 0x39}, /* HMAX_LSB */
+		{0x301C, 0x03}, /* HMAX_MSB */
+		{0x3044, 0xE0}, /* ODBIT_OPORTSEL, 10bits */
+		{0x300A, 0x3C}, /* BLKLEVEL_LSB */
+		{0x300B, 0x00}, /* BLKLEVEL_MSB */
+	},
+};
+
+static struct vin_video_format imx185_formats[] = {
+	{
+		.video_mode	= AMBA_VIDEO_MODE_WUXGA,
+		.def_start_x	= 4+4+8,
+		.def_start_y	= 1+2+14+4+8,
+		.def_width	= 1920,
+		.def_height	= 1200,
+		/* sensor mode */
+		.device_mode	= 0,
+		.pll_idx	= 0,
+		.width		= 1920,
+		.height		= 1200,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS(50),
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_1080P,
+		.def_start_x	= 4+4+8,
+		.def_start_y	= 1+2+8+4+8,
+		.def_width	= 1920,
+		.def_height	= 1080,
+		/* sensor mode */
+		.device_mode	= 1,
+		.pll_idx	= 0,
+		.width		= 1920,
+		.height		= 1080,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_12,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_60,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_60,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+	},
+	{
+		.video_mode	= AMBA_VIDEO_MODE_720P,
+		.def_start_x	= 4+4+8,
+		.def_start_y	= 1+2+4+2+4,
+		.def_width	= 1280,
+		.def_height	= 720,
+		/* sensor mode */
+		.device_mode	= 2,
+		.pll_idx	= 0,
+		.width		= 1280,
+		.height		= 720,
+		.format		= AMBA_VIDEO_FORMAT_PROGRESSIVE,
+		.type		= AMBA_VIDEO_TYPE_RGB_RAW,
+		.bits		= AMBA_VIDEO_BITS_10,
+		.ratio		= AMBA_VIDEO_RATIO_16_9,
+		.max_fps	= AMBA_VIDEO_FPS_120,
+		.default_fps	= AMBA_VIDEO_FPS_29_97,
+		.default_agc	= 0,
+		.default_shutter_time	= AMBA_VIDEO_FPS_120,
+		.default_bayer_pattern	= VINDEV_BAYER_PATTERN_RG,
+	},
+};
+
+static struct vin_reg_16_8 imx185_share_regs[] = {
+	/* chip ID = 02h, do not change */
+	{0x301D, 0x08},
+	{0x301E, 0x02},
+	{0x3048, 0x33},
+
+	/* chip ID = 03h, do not change */
+	{0x311D, 0x0A},
+	{0x3123, 0x0F},
+	{0x3147, 0x87},
+	{0x31E1, 0x9E},
+	{0x31E2, 0x01},
+	{0x31E5, 0x05},
+	{0x31E6, 0x05},
+	{0x31E7, 0x3A},
+	{0x31E8, 0x3A},
+
+	/* chip ID = 04h, do not change */
+	{0x3203, 0xC8},
+	{0x3207, 0x54},
+	{0x3213, 0x16},
+	{0x3215, 0xF6},
+	{0x321A, 0x14},
+	{0x321B, 0x51},
+	{0x3229, 0xE7},
+	{0x322A, 0xF0},
+	{0x322B, 0x10},
+	{0x3231, 0xE7},
+	{0x3232, 0xF0},
+	{0x3233, 0x10},
+	{0x323C, 0xE8},
+	{0x323D, 0x70},
+	{0x3243, 0x08},
+	{0x3244, 0xE1},
+	{0x3245, 0x10},
+	{0x3247, 0xE7},
+	{0x3248, 0x60},
+	{0x3249, 0x1E},
+	{0x324B, 0x00},
+	{0x324C, 0x41},
+	{0x3250, 0x30},
+	{0x3251, 0x0A},
+	{0x3252, 0xFF},
+	{0x3253, 0xFF},
+	{0x3254, 0xFF},
+	{0x3255, 0x02},
+	{0x3257, 0xF0},
+	{0x325A, 0xA6},
+	{0x325D, 0x14},
+	{0x325E, 0x51},
+	{0x3260, 0x00},
+	{0x3261, 0x61},
+	{0x3266, 0x30},
+	{0x3267, 0x05},
+	{0x3275, 0xE7},
+	{0x3281, 0xEA},
+	{0x3282, 0x70},
+	{0x3285, 0xFF},
+	{0x328A, 0xF0},
+	{0x328D, 0xB6},
+	{0x328E, 0x40},
+	{0x3290, 0x42},
+	{0x3291, 0x51},
+	{0x3292, 0x1E},
+	{0x3294, 0xC4},
+	{0x3295, 0x20},
+	{0x3297, 0x50},
+	{0x3298, 0x31},
+	{0x3299, 0x1F},
+	{0x329B, 0xC0},
+	{0x329C, 0x60},
+	{0x329E, 0x4C},
+	{0x329F, 0x71},
+	{0x32A0, 0x1F},
+	{0x32A2, 0xB6},
+	{0x32A3, 0xC0},
+	{0x32A4, 0x0B},
+	{0x32A9, 0x24},
+	{0x32AA, 0x41},
+	{0x32B0, 0x25},
+	{0x32B1, 0x51},
+	{0x32B7, 0x1C},
+	{0x32B8, 0xC1},
+	{0x32B9, 0x12},
+	{0x32BE, 0x1D},
+	{0x32BF, 0xD1},
+	{0x32C0, 0x12},
+	{0x32C2, 0xA8},
+	{0x32C3, 0xC0},
+	{0x32C4, 0x0A},
+	{0x32C5, 0x1E},
+	{0x32C6, 0x21},
+	{0x32C9, 0xB0},
+	{0x32CA, 0x40},
+	{0x32CC, 0x26},
+	{0x32CD, 0xA1},
+	{0x32D0, 0xB6},
+	{0x32D1, 0xC0},
+	{0x32D2, 0x0B},
+	{0x32D4, 0xE2},
+	{0x32D5, 0x40},
+	{0x32D8, 0x4E},
+	{0x32D9, 0xA1},
+	{0x32EC, 0xF0},
+};
+
+#define IMX185_GAIN_MAX_DB	160
+#define IMX185_GAIN_ROWS	161
+
diff --git a/drivers/vin/sensors/sony_imx185/make.inc b/drivers/vin/sensors/sony_imx185/make.inc
new file mode 100644
index 0000000..586f3b9
--- /dev/null
+++ b/drivers/vin/sensors/sony_imx185/make.inc
@@ -0,0 +1,45 @@
+##
+## kernel/private/drivers/vin/sensors/sony_imx185/make.inc
+##
+## History:
+##    2015/01/09 - [Hao Zeng] Created file
+##
+## Copyright (c) 2015 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+ifeq ($(CONFIG_SENSOR_IMX185), y)
+
+LOCAL_PATH	:= $(call my-dir)
+
+###
+include $(CLEAR_VARS)
+
+LOCAL_SRCS	:= $(wildcard $(LOCAL_PATH)/*.c) $(wildcard $(LOCAL_PATH)/*.h)
+LOCAL_SRCS	+= $(LOCAL_PATH)/Kbuild
+
+include $(BUILD_DRIVER)
+
+endif
+
